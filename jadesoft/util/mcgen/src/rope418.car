C ROPE    4.18/07 000320 22.50    THE OPAL RECONSTRUCTION PROGRAM
*.
+PATCH,HISTORY.
*--   Version 4.18/07
*--  M.Schroder   Fix up FATMEN common block
*--   Version 4.18/06
*--  M.Schroder   RSWBUC: Use values from BEAM bank for all MC
*--  E.Barberio   Undated the fatman commons to use the new cernlib
*--   Version 4.18/05
*--  M.Schroder   Move call to ODFIX(0) in front of call to LLBAT,
*--               wrap odfix calls in 'if=-online'
*--  E.Barberio   Undated the fatman commons to use the new cernlib
*--   Version 4.18/04
*--  A.Williamson ROOFLX: allow more files to be prestaged in one go
*--   Version 4.18/03
*--  M.Schroder ROOPEN: fix format for printing of last SUDB update
*--   Version 4.18/02
*--  E.Barberio Version Y2K compatible
*--   Version 4.18/01
*--  M.Schroder First attempt at linux g77 compliance
*--
*--   Version 4.17/04
*--  E.Barberio reserve header word 63 for  Pretrigger Pam Scale Factors
*--   Version 4.17/03
*--  M.Schroder Remove superfluous calls to ROUPON from ROPBAT
*--  E.Barberio default call to ODFIX
*--  G.W.Wilson Introduce IEOPTR FYZ1 selection for trigger/FYZ1 monitoring
*--             (replaces unused NGAM bit).
*--   Version 4.17/02
*--  M.Schroder Change back ZEBRA logging
*--   Version 4.17/01
*--  J.Letts    Change ZEBRA logging on SHIFT
*--  E.Barberio and D.Strom modified REPORT, RIOMAS, 
*--                         ROLUSW, ROSWTC: fixes for run > 9999
*--  E.Barberio Added the new te rhorho trigger to fyz1
*--  G.W.Wilson Include pretrigger info in IIPDDF
*--  N.Watson   Fixes for expt. 10 database
*--
*--   Version 4.16 :
*--  M.Schroder Tighten ROGGSE selection
*--  D.Strom    Set ROSWVA variable EBEAM to 1000 for cosmics (beam energy=0)
*--  M.Schroder Fix bug in ROEVTY (IESWKP was not set), call BTINIT,MTINIT
*--  D.Strom    Increased range of variable IROPE in RSWCLS
*--  D.Strom    Fixes to ROLUSW ROSWTC
*--  M.Schroder Install new untagged gamma gamma exclusive selection,
*--             New event type bit for single photons (subselection)
*--  D.Strom    removed RSWTHR and RSWTHL.  No one should use these
*--             routines.  Also removed RSWSMR and RSWSML
*--  D.Strom    added missing RSWULx and RSWURx routines
*--  D.Strom    fix up nonstandard lumi code
*--  J.Conboy   change ROLUFD
*--  E.Barberio max size of IRDEXP is now MAXEXP(=15)
*--  D.Strom    change of all lumi code
*--  from the rope415 cradle:
*--  E.Barberio change the default server from shift8 to shift6
*--  M.Schroder reduce number of files to pre-stage to 10
*--  M.Schroder Add SW-keep-selection to phys1
*--  E.Barberio Add the new Mip plug trigger to phys1 selection
*--  M.Schroder Stop saving the TERA bank (TE packing works)
*--  S.O'Neale  allow fatmen access to SD-tapes (sacrifice EXABYTE and DAT90)
*--  S.O'Neale  change media preferences for fatmen (new SD-tapes) 
 
 
*--   Version 4.15 :
*-- emergency release for CS212 (changed COMMON blocks), no new cards file
*-- 
*--   Version 4.14 :
*-- M.Schroder RBKREV : a small fix for TE and 1990 data
*-- E.Barberio Make ROPE crash when try to write out ODFIXed data
*-- E.Barberio Changed behaviour of the beam energy: now it is updated by 
*--            default. Introduced a new datacard to inhibit the update
*--            of the beam energy (NOEBUPDT)
*-- A.Furtjes  ROCHSE : protect against writing outside MOMECL
*-- M.Schroder RNEVTL : fix number of arguments for ROCGEP
*-- M.Schroder Remove 529 trailing blanks
*-- N.Watson   Mods to ROWWSE
*-- E.Barberio Make RCNTLB report a CRASH if errors in FFREAD cards found
*-- J.Conboy   Revamped ROLUFD
*-- E.Barberio Set to 12 the maximum number of character in FFREAD cards
*-- M.Schroder incorperate rope413 cradle corrections,
*--            change poolname shift1 -> batch
*--            increase MAXEXP (9->15)
*--
*--   Version 4.13 :
*--
*--   Version 4.12 :
*-- M.Schroder really correct event type bit definitions in ROTPAR,
*--            add new bits to ROTPARM (for GROPE), change flag for
*--            dummy ROFPOS activation from '-SHIFT' to '-UNIX'
*-- A.Furtjes  protect ROCHSE against EBEAM=0
*-- M.Schroder correct event type bit definitions
*-- M.Schroder only use ROWWSE instead of 5 WW selection routines,
*--            fix number of processors in ROINIT and RPRTVS
*-- A.Furtjes  Mods in ROCHIN
*-- M.Schroder Add RL2MHS and WW selection routines, WW into CRVER,
*--            add INIT, SETR and FIN for ID, GC, HI, WW
*--            WWKEY called from RFUSER
*-- M.Schroder Add RONRMH selection routine, more new event type bits
*-- M.Schroder Avoid overwriting of FILTER bunchlet info (ROWOUT)
*--            new ROTPAR for new event selections
*--            Incorperate mods from ROPE411 CRADLE :
*--              - new ROSPAR values
*--              - RCASET : replace hardcoded 21 in CALWRITE part
*--              - RTETRG : scale by IRDEVT instead of internal counter
*--              - ROPTPR : Make TE process accessible (typo in IIFTEC)
*--              - RFLSET : Correct order of ECKEY elements
*--              - RFCLISU : fix multiple reading of catalog file
*--   Version 4.11 :
*-  M.Schroder only 1 RSLBIT please, correct its args in RFUSER
*-- M.Schroder correct LCALRD and LCALWT size (in RCNTRL)
*-- O.Schaile  deselect RNEVTL for non (UNIX or VAX) again
*--            change order of EM flags (IIFTBC ...)
*--            rename  CGETED,CGETEP to ROCGED, ROCGEP
*-- M.Schroder fix new bugs in RGETDA, ROGOKU, ROEXTR, ROEXJE,
*--            rename CGETEVD to CGETED, CGETEVP to CGETEP
*-- O.Schaile  Introduce TE (modifications at n+411 places)
*--            ask explicitely for direction 'OUT' in RIOFAT
*-- O.Schaile  Implement cradle from 410 + mods for Grope
*--            Important mods:
*--            Completely new handling of data access with eventlists
*--            now handled by a c-routine evget which access a server
*--            running on shift
*--            include a new routine ROEXTR expanding the MCtree for
*--            display by Grope
*--            many mods in interactive part to facilitate event
*--            selection and acces for scanning
*--            include C-code for Rope CDF
*--            gamma gamma selections, changed ROLUFD, ROFYZS
*--            RGETBU, ROFBUN, ROWOUT : fix bunchlet info in header
*--            new ROCROS routines
*--            trap REAL*8 FP exceptions under HPUX
*--            check IROBUN for jobs without opcal
*--            fix EBEAM bug; HI105 and GC102 released; fill LAYRES
*--            fix closing of dadlists in RNXTEV
*--            small change for ROCHSE, ROCHPR
*--   Version 4.10 :
*-- M.Schroder Add version info for HI,GC,PX,SQ, change ROTPAR, ROTPARM
*--            and ROEVTY for LLIL
*-- O.Schaile  extend ROCHPR, new RODIVE, init ROCHVA
*-- O.Schaile  Add calls to HISETR, HISELN, HIINIT, bits NELO, NETI
*-- A.Furtjes  More changes to ROCHSE; new ROCHIN, ROCHPR, seq. ROCHCU
*-- M.German   Changed RSWVA, RSWCOR, RSWCLS
*-- O.Schaile  Event selection: new commands ENABLE/IGNORE selections
*--            new ROCHSI call ROCHSE interactively
*--            remove RINPUT (handled by ROFILE now)
*--            remove code generated by KUIPC (+DECK,ROIKU.)
*-- M.Schroder Add slightly changed FISWBU to corr. 95 SW bunchlet info
*--            Add chargino event selection ROCHSE
*--            RNXTEV/ROOFLX fixes for dadlist and eventlist reading
*-- O.Schaile  Event selection based on bits in header (EVTY, FITY ..)
*--            new seq ROTPARM with mnemonics of Event types
*--            ROTNAM: return mnemonic + explanation for Event types
*--            new routine ROFILE (interactive OPEN)
*--            remove ROIKU (output of KUIPC)
*--            replace RSWCLS, ROSWVA
*-- O.Schaile  Implement cradle from 409, important mods:
*--            new routines to handle bunch train mode of LEP (M.S.)
*--            RCNRTL,ROBUN, dadlist for HPs, RIOFAT for DLT on shift
*--            mod +KEEP REBANK
*-- M.Schroder fixes for
*--                      NRMEM  (size)
*--                      ROFDCL (use NIFDET, NRFDET)
*--                      RGAM   (avoid double counting if CXUNCZ fails)T
*--                      RGEM   (documentation only)
*--   Version 4.09 :
*-- M.Schroder remove remote shell calls and path for sfget/sfsh
*-- A.McNab    Add signal handling for OSF/1
*-- M.Schroder New bank for bunch train time offsets,
*--            add routine ROFBUN to fill that bank
*-- M.Schroder Add SEQ ROBUN & routine RGETBU to fill ROBUN variables
*--   Version 4.08 :
*-- M.Manelli  Replace ROLUSW and ROSWTC for 1994 data
*-- O.Schaile  Add CALL GRBROW in ROPIKU
*-- O.Schaile  Introduce Patchy flag QMVAOS (Alpha OSF)
*-- O.Schaile  Implement cradle from 407, important mods:
*--            New ROCROS, ROCSUM, ROLUSW, ROSWTC.
*--            enable local opening of files on shift
*--            mod RIOCAT, P with FM default, New preseek logic
*--            Let FATMEN choose best medium (remove FMGETK calls)
*--            FATMEN: if path given explicitly only 1 file possible
*--            Call GGCLOS after reading INIT file
*--            Enhance multi file prestage with FATMEN
*--            Permit FATMEN access to Shift-only cartridges
*--            Mark banks right before calling FZOUT
*--            Save ODEM bank on DST/DDST
*--            Change CSINIT to CSINIR to avoid conflict with COMIS
*--            Use different temp. link commons in ROWDAO and RFGNCT
*--            close all input files (DAD+data)
*--            New FYZ1 selection for TE studies
*--            Allow Prestage on IBM and SHIFT
*--            Modified version of RTWOPH
*--            Set and clear IOCEXP and IOCPEX consistently
*--            Permit forced cartridge reading on Shift
*--            REPORT beam width and vertex error (superseded 940622)
*--            Major mods to RBABSW
*--            Add BXRTST standalone trigger to FYZ1 selection
*--            Ignore vault and robot specifications in *FATFILE card
*--            Allow users to open new native-mode files on VM
*--            Allow for Experiment No 0 !!!
*--   Version 4.07 :
*-- M.Redmond  Change **2. to **2 in ROCROS routines
*-- D.Wagner   New RBABSW (several S/Rs now)
*-- O.Schaile  New RHBEND, use new HFILES (temporary in ROPE)
*--            Use HRENDC, which closes the file
*-- O.Schaile  Mod in CDF
*-- M.Redmond  Call RGETCA for new constants or expt. number
*-- M.Redmond  Remove JCFNTP, JCFNTS, EEDDUP, EEDDPK from RDUMLD
*-- O.Schaile  Include ROCROS (Claudio Grandi)
*-- M.Redmond  Mods for SIW block, Add CU to list of procs
*-- M.Redmond  Execute ROPE EXEC after calling ROPSET
*-- O.Schaile  add call to USBAT(IIFODC)
*-- M.Redmond  Mod constants retrieval for TR
*-- O.Schaile  Call KUINIM early (David Ward)
*-- T.Smith    Change ONLINE event reading to use FZIN with FZHOOK.
*-- O.Schaile  Allow DADlist reading on non SHIFT (but no PRESEEK!)
*--            Add dummy RIRFIO
*--            Reinstall normal NanoDST reading
*--            if NPRTMX(1)=-1 suppress print in RMAIL during Init
*--                        <-1 suppress print in RMAIL completley
*--            Add KUIP Motif interface for Grope
*--            Simplify calls to DC (Daniel L)
*--            Allow output of RCO to DST also (RGETCA)
*-- M.Redmond  Implement calling CS and CX for DST analyses
*-- O.Schaile  Implement cradle from 405, important mods:
*--            Implement skipping of files with DADlists
*--            new routine RODSWP
*--            remove h/c 16384 in ROOFLX
*--            Allow format FSEQ1-5 for RSTAGE (shift)
*--            Drop the extra DST banks with SI hits
*--            changes to RBABSW
*--            changes to calling of ODTOSI
*--   Version 4.06 : skipped to get in line with OD407+DC407
*--   Version 4.05 :
*.  M.Mannelli Change ETFRAC to 0.6 in RBABSW
*-- O.Schaile  MOdify summary printing for CA and CE
*-- O.Schaile  Add FFREAD card ODTOSI
*-- D.Wagner   New RBABSW called from ROEVTY, add bits IESWIA etc.
*-- R.Kowalewski Get beam pos. for MC from SUDB: RGETDA, RGETCA, RFGNCT
*-- O.Schaile  L option to MZDROPS in ROWOUT, clean print of event loop
*-- O.Schaile  Call CXBAT after OD only if CX is selected from FFREAD
*--            call ODVRTX to update DST
*-- O.Schaile  Fill MAX(last update of SUDB, IDAMSU) in IUHEAD(IISULM)
*-- T.Smith    add some mods to ONLINE term. handling (use NSTOP = 8)
*-- O.Schaile  define bit IEPRSC in ROTPAR (Online ROPE prescaling)
*-- O.Schaile  Call LMBAT again right after FD in ROCALL
*-- M.Redmond  Don't hardcode pathname for sfget calls on Shift (ROOFLX)
*-- M.Redmond  Don't call ODTOSI with 'CX' option because it takes too
*--            much CPU time (ROPBAT)
*-- C.Darling  Replace ROFYZ1, ROFYZT, RTRGFD. Add ROFDCL. Remove
*--            ROMKFS, ROMKFT
*-- M.Redmond  Use remsh with sfget on Apollo
*-- D.Lellouch Fix to ROWDAO for normal DD/packed DST files
*-- O.Schaile  Include JUCOMP  (from GOPAL131)
*-- D.Lellouch Some mods to Data compression
*-- M.Redmond  Prevent calibration date and time from being overwritten
*-- O.Schaile  Write out headers also if empty d/s
*--            put CHI2 limit in PROB to 169. Put LURAWD=56 (reserved)
*-- C.Darling  Implement streams FYZS+FYZT (mod: ROTPAR,ROEVTY,RTRGFD,
*--            new: ROFYZT, ROFYZT, ROMKFS, ROMKFT)
*-- O.Schaile  Call USHEAD also if no pending d/s, suppress REPORT
*-- M.Redmond  make ODTOSI default
*-- O.Schaile  allow seq numbers when stageing files on shift
*--            dont stop if event not found given in eventlist
*-- C.Hawkes   new RTRGFD
*-- O.Schaile  Bug fix in ROOPEN
*-- O.Schaile  Call to FCGOLB in ROINIT, FSEQnn in RSTAGE for SHIFT
*-- O.Schaile  Implement cradle changes from 404,
*--            add hooks to new SU in RFUSER, RIOSET, ROOPEN
*--            pass argument = 0 to GOTREE (see S/R GOTREI)
*--            add HD cartridges on IBM (medium type 6) (ROOFLX,RIOFAT)
*--   Version 4.04 :
*-- O.Schaile  Add DDLU to RDSMRK
*-- C.Hawkes   New ROFYZ1, add SW filter keep
*-- C.Hawkes   New RGETLU from M.Thomson
*-- O.Schaile  Remove RDADOU, RDAFIL, RDASET, RNXTEV for QMALPH
*--            entries will be satisfied from DUMMY
*-- O.Schaile  Bug fix (ONLINE) in RGETDA, CTCVCA=>CTOCVN in ROTRIG
*-- D.Ward     Provide ROTRAP for DEC Alpha (Patchy flag: QMALPH)
*-- D.Wagner   Avoid blank line when printing dummies (35=>36)
*-- O.Schaile  Preset RTIMLF (if ONLINE)
*-- M.Lehto    Include 1992 and beyond Gamma Catcher (RTRGFD)
*-- T.Smith    ask for IER .EQ. 2 in ROTRIG
*-- O.Schaile  Implement @@ (execute shell script) in ROOFLX
*-- O.Schaile  Call JCOPEN (crosser analysis code) in ROTRIG
*-- O.Schaile  Remove all code selected by ONLINE_OLD (obsolete)
*-- J.Mildenberger remove CV calibration from ONLINE condition
*-- O.Schaile  Avoid TIMEL if ONLINE, add call t SWIKU
*-- O.Schaile  use RECFM F instead of U for IBM, (ROOFLX, RINPUT)
*-- M.Redmond  call TRCALR whenever TR library is loaded
*-- C.Hawkes   New RSPTRG, RTRGFD, RTRIGS
*-- O.Schaile  Fixed length rec on VAX if Xch (ROOFLX), update doc (404)
*-- O.Schaile  look for SW at pos. 3 in RFLSET, check NS in FOC (RBKREV)
*-- O.Schaile  NFORW=2 in RFLSET
*-- O.Schaile  Install hooks for SW in 7 sequences, 20 subroutines
*--            N.B. change COMMONs RCLINK, RCHTOP, RCNTRL
*--            include cradle from 403 upto  LSTUPD = 0001315
*-- C.Hawkes   Tighten Phys1 selections RTRGFD and RTRIGS
*-- D.Lellouch add, READONLY for dict on VAX, save uncomp. if comp fails
*-- O.Schaile  Move call to DCBAT 10 lines down,  DCREAD 2 lines down
*-- C.Hawkes   add call for DST-only CX analysis  (Bob Kowalewski)
*-- O.Schaile  add 'N' to CALL HROUT(....'NT') in ROPFIN
*-- O.Schaile  add hooks to Data Compression (DC) (Daniel Lellouch)
*--            modified sequences: CRVER, ROUNIT, ROCPAR
*--   Version 4.03 :
*-- O.Schaile  fix FORMAT in ROPUNI
*-- C.Hawkes   Add new LLGLOB sequence to ROEVTY
*-- C.Hawkes   Call REPORT, rather than MTLPRT, from PROB
*-- O.Schaile  add PROB to RDUMLD
*-- O.Schaile  Remove unused code from RNEVTL, remove check on NanoDst
*--            in RIOEVL, instead CALL RSCATA if no Catalog provided
*-- O.Schaile  Implement Bernd P. new event list handling
*--            no Masternano needed anymore
*-- C.Hawkes   Add 'DDCD' and 'DDOU' banks to RDSMRK
*-- C.Hawkes   Remove PRINT statements from RGTOEM
*-- G.Wilson   Mods to event types, SUBROUTINE RGTOEM and SEQ ROTPAR
*-- C.Hawkes   Calls to more LM routines
*-- G.Wilson   Fix RGTOEM
*-- C.Hawkes   Add CALL LMINIT to ROPINI
*-- C.Hawkes   Changes to 1-photon Phys1 selections (from G.Wilson)
*-- C.Hawkes   Add fixed, pre-release PROB function from CERNLIB
*-- O.Schaile  Make mod in RMOUNT depend on RAL - CERN
*-- O.Schaile  Redo mod in RMOUNT (doesnt work at CERN)
*-- B.Panzer   modify call to sfsh (RMULFI) for SHIFT
*-- O.Schaile  fix call to RSTAGE (IBM)(Daniel), OCMOD (Glenn P.)
*-- G.Patrick  Remove SETUP(CLEAR in RCLSIO, sep. setpu-mount in RMOUNT
*-- O.Schaile  remove FFREAD cards: BEAM, GOPAL (obsolete)
*-- M.Redmond  Fix call to RMOUNT for VAX (remove an extra arg)
*-- G.Patrick  close output units before inputs (ROPFIN)
*-- O.Schaile  set IVGOPA=129
*-- C.Hawkes   RNXTEVU: Fix event writing from DADlist on SHIFT
*-- C.Hawkes   rename MIGNRL,MRGNRL in ROPBAT. Conflict with ODPAR
*-- O.Schaile  remove check on GOPAL version (IVGOPA), but still set it
*-- O.Schaile  update doc for REV: *B.9   DDOU (was DD)
*-- O.Schaile  rename DECKs: ROTRAP => ROTRAPI, ROTRAPH
*-- M.Lehto    RTWOPH: Remove trigger dependance from selection
*-- O.Schaile  EXTERNAL MVBITS for SUN and IBMRT
*-- O.Schaile  remove some spurious refs to AD bank (comments only)
*-- O.Schaile  on IBM check if output file (FZ) exists on A-disk
*-- O.Schaile  Ignore options P and S for shift
*--  the following are cradle fixes to 402
*-- O.Schaile  put back OPEN(4.. in RMAINI for APOLLO
*-- D. Ward    recovery for SUN
*-- O.Schaile  allow 2200 files in Fatmen
*-- J.Banks,   allow sfget from HPUX, KUGETC=>KUGETS
*-- O.Schaile, Disable FM log, IRC from FMOPEN must be 0.
*-- O.Schaile, Put back error recovery on Apollo
*--   Version 4.02 :
*-- O.Schaile  activate Fatmen logging, use Unit 54 (LFATLW) in RFMINI
*--            (argument 3 on *FATMEN card)
*-- O.Schaile  fix event counting in RDADOU on SHIFT, allOw dir nam only
*--            in RIOFAT again, remove msg "Skip duplicate volume..."
*--            fix bankdoc AD=>DD in REV
*-- C.Hawkes   ROPBAT: fix logic of LLBAT and LABAT calls
*-- O.Schaile  ROOFLX: set LBANK explicitly to 0
*-- O.Schaile  fix bug in REPORT, New logic in RIOFAT, stop ROPE if
*--            a data file cant be opened in DAD list processing
*-- O.Schaile  LY => LM
*-- O.Schaile  TIMEL->TIMAL (168 units) on IBM, default TSAFE=20. sec
*-- O.Schaile  put seq HCDIRE really into ROCDES (was in ROCTYPE)
*-- O.Schaile  copy seq MZBITS into ROCDES from ZEBRA
*-- O.Schaile  put calls to USBAT(-1),(-2) into  ROPTPR
*-- O.Schaile  put seq HCDIRE from OC506 into ROCDES (for RHBEND)
*-- C.Hawkes   new ROPBAT, ROPTPR (for LA, LL, LY)
*-- N.Watson   new routine RHBEND, close RZfiles at crash
*-- O.Schaile  condition calls to FMQTMS in RIOFAT
*-- C.Hawkes   additions for LA,LL,LY processors
*-- N.Watson   new RGETCA
*-- O.Schaile  change formats in RNTXEV, RCLSIO (=>I7)
*-- O.Schaile  correct bug in ROOFLX when reading ALPHA mode on IBMRT
*-- C.Hawkes   update LUT in REPORT
*-- N.Watson   new RGETCA
*-- D.Lellouch new user routine USEOF, default pool names to
*--            opaldata.opal, allow ntuples go into pools
*-- A.Buijs    new ROPIKU
*-- O.Schaile  remove loop on CHOPT in RONFLX
*--            move LEOFIN=.FALSE. from RNXTEVU => RNXTNA (was a bug))
*-- O.Schaile  remove OPEN(UNIT= 5 for Apollo
*-- O.Schaile  CALL USBAT(-2) after DDUBAT
*-- A.Buijs    Do REPORT printout only a few times.  (ROPINI,ROPFIN)
*-- N.Watson   allow more than one Cal Dbase
*-- O.Schaile  'FD  '=>'FO  ' in RDDMRK, RDPMRK, RDSMRK  (All Lee)
*-- O.Schaile  Default IVGOPA=128
*-- C.Hawkes   Add RBITFUNC to RVAFLT
*-- C.Hawkes   Delete unreachable code in RPHCON
*-- C.Hawkes   Use RODPAR sequence
*-- C.Hawkes   Add ID processor to  RPRTVS.
*-- O.Schaile  mod tape stage from shift, no more need for opt 'R'/'V'
*-- C.Hawkes   Call RONREP if ONLINE
*-- O.Schaile  Put error recovery stuff into KEEPs
*--            introduce SHIFT and UNIX flag
*-- O.Schaile Pretrigger bits in header IIPRTA, IIPRTB
*-- O.Schaile introduce PATCHY flags for SUN and DECS
*-- assume: SUN=IBMRT, DECS=VAX for file stuff (LRECL,READONLY) else UNI
*-- O.Schaile. Write consts with DDST (if no Unpack done)
*-- T.Mouthuy. Pre seek+new DAD on SGI.
*-- M.DallaValle. New RGETLU for 1991 data.
*-- O.Schaile, fix some non initialized variables
*-- M.Redmond,OS list-dir int read isnt f77, NO Junk Online
*-- O.Schaile ROOFLX, remove statement at label 100, 1240, never used
*-- O.Schaile Floating point exception handling for HP
*-- O.Schaile introduce PATCHY flags for HPUX and IBMRT (RS-6000)
*--
*--  the following are cradle fixes to 401
*-- O.Schaile. Implement call to SUPHYS.
*-- C.Hawkes. New version of ROSTOP.
*-- S.Weisz    Follows "CONSTANT" specs. for COPY output
*-- D.Lellouch Bug fix for multiple file staging.
*-- Al Lee    Error handling on Vax and SGI
*-- C.Hawkes. Change format specifier F6.3 -> F7.3
*-- T.Mouthuy. Fix the last fix.
*-- T.Mouthuy. Stageing on SGI.
*-- K.Riles  Add call to USKEY in RFUSER
*-- C.Hawkes. Reformat REV doc.
*-- C.Hawkes. New code. Subroutine ROSTOP. New REV doc.
*-- S.Weisz Bug on IVGOPA update for MC (D)DST events.
*-- S.Weisz Interactive Event List on shift.
*-- S.Weisz DZDOC compatible introduction of SCRA doc.
*-- S.Weisz Specify filemode A for default HISTO file.
*-- S.Weisz Close properly Copy and Overflow streams.
*-- S.Weisz Interactive Event List on shift.
*-- CMH. Inhibit private version of RZOPEN on VAX.
*-- S.Weisz Bug on event writing on SHIFT.
*-- Install GOPAL127
*-- S.Weisz Variable name metafile on UNIX too ...
*-- S.Weisz Stage non standard record length ....
*-- S.Weisz Reset top directory to //CERN before FATMEN
*-- Enable RCFDBS on VAX
*--
*--   Version 4.01 :
*-- DAD list, Event list, NanoDst on Shift.
*-- Add RDDATA function : = 0 --> No Dense Data.
*--                       = 1 --> Dense Data for outer detectors
*--                       = 2 --> Dense Data for all detectors
*-- Add LA and BT processor in CRVER and RPRTVS.
*-- Reset FZ log level to zero on output.
*-- Declare BTEST and Co. with RBITFUNC sequence.
*-- UHTOC and UCTOH called with ROWORD parameters.
*-- Correct bugs and implement previous cradle fixes.
*--
*--   Version 4.00 :
*-- Dummy routine now in DUMMY library; Forces some loading with RDUMLD.
*-- Change CJ calls to JC calls.
*-- Direct Access to Data: full interface on input and output.
*-- Implement FATMEN file access.
*-- Access data by file name or cartridge name.
*-- Implement DX,SI and CS calls.
*-- Add SGI Patchy flags to work on Silicon Graphic stations.
*-- Implement On-line version to run on DN10k reading from memory.
*--
*--   Version 3.12 :
*-- Monitor OPCAL and Data expension/compression.
*-- Implement DDST stream (Seq ROCPAR,Routine RIOFIL,RGETCA,
*-- RIOSEL,RIOSET,ROOFLX,ROOPEN,ROWOUT,RDDMRK).
*-- First prototype installation of DAD with VAX,DAD selection.
*-- Fill GNCT banks in RFGNCT from information in SUBEAM.
*-- Call CX after CA: Temporary fix for fall 1990 re-rope.
*-- Add calls to MAW steering routine if VAX flag selected.
*-- 'IMPLICIT NONE' command now accepted on Apollo.
*-- Update of event selection routines.
*-- Correct bugs and implement previous cradle fixes.
*--
*--   Version 3.11 :
*-- Special calls to OPCAL in on-line mode (ROEVNT in ROEVNTA).
*-- Multiple file reading on Vax for MAW (RONFLX).
*-- Set non zero return code : time limit           --> 2
*--                            crash call to REPORT --> 3
*--                            FZIN problem         --> 4
*--                            FZOUT problem        --> 5
*-- Constant record retrieval version (+USE,ROPECONR).
*-- Implement calls to the SU (Status Update) library.
*-- Implement calls to new DD (Dense Data).
*--
*--   Version 3.10 :
*-- Implement specials for On-line Roping in DN10000.
*-- (RMAINB,RMAINI,ROTRAP,ROEVNT,ZEND,ZTELUS)
*-- Keep LUMI condense information (ROPAR,ROCPAR,ROSPAR,RDSMRK).
*-- Redesign monitoring of processor for DN10000 (ROPBAT,ROMONI).
*-- Extend header to 40 words (Seq CRO,ROPAR,routine RGETDA).
*-- Packing of CJ data in JCPACK ( ROEVNT,ROWOUT).
*-- Default initialisation of undeclared input (RIOSET).
*-- More efficient access to OPCAL on VAX,APOLLO and CRAY(RIOFIL,ROOFLX)
*-- DST writing for DN10000: drop banks and call MZGARB (ROEVNT).
*-- Introduce Low Multiplicity event selection (ROEVTY,RLLSEL).
*-- Introduce Heavy Lepton, Single Photon selection (ROEVTY,RHLSEL,RGAM).
*-- Introduce Dense Data processor, remove AD,AS ...
*--
*--   Version 3.09 :
*-- Implement treatment of lumi events(ROINIT,ROPBAT).
*-- Change HB->HT,HE->HS for STAT and CALR routines, but not
*-- for INIT, BAT ..etc (messy is not it?).
*-- Skip junk events from DAQ when IIDAT=7-13 (RGETDA)
*-- Get/check Beam energy and fill No. with RGETEB (RGETDA)
*-- Mag. field set to 4.326 KGauss (SCBAT)
*-- Update status words in IUHEAD and REV (ROPBAT)
*-- Implement UPDATE ffread card to allow updates of the event
*-- header (RGETDA,ROPBAT,ROWOUT)
*-- Expand IUHEAD and REV bank to 25 words (add IIFILL,IITAPE)
*-- Header word IIDAQS obsolete, replaced by IITRGS (Status word for
*-- detector participating to the trigger)
*-- Implement NODROP ffread card to keep results banks when
*-- reprocessing (Warning: only for test purpose)
*-- Mods for FFREAD: Rename FFUSER to RFUSER (ROPPAK)
*-- Add link in FO (Forward detector) for condensed record.
*-- Stop processing if problem with FZOUT (ZTELUS)
*--
*--   Version 3.08 :
*-- Mag. field in MAGF bank (Seq RCNTRL,RGETCA,ROINIT,ROPBAT,SCBAT)
*-- Modification for OC401 (Seq OCFLAG,ROPPAK,ROOPEN)
*-- Introduce some close statement (RIOSET,ROOFLX,ROOPEN,ROPFIN,ROWDAO)
*-- Introduce *GET card (Seq RCNTRL,FFUSER,RSELDA,RSLGEF,RSLSET).
*-- Mods. to ROSIZE to take IO caracteristic into account.
*-- Mark bank to be written (ROWDAO,USMARK,RDGMRK,RDPMRK,RDSMRK).
*-- Implement SCAN stream (Seq ROCPAR,RCNTRL,Routine RIOFIL,RGETCA,
*-- RIOSEL,RIOSET,ROOFLX,ROOPEN,ROWOUT).
*-- Interactive file opening (RINPUT,ROIKU).
*-- Interactive facility to fetch events (Seq RCNTRL,RSELDA,ROEVSL).
*-- Reporting in ZTELUS (Seq RCNTLR,ZTELUS,ROWOUT,REPORT).
*-- Report message tallied in separate store (Seq REBANK,RECNTL,ROSPAR,
*-- Routine RGINIT,REINIT,RECREP,RENREP,REPORT,REPREP).
*-- Add IOCCRV to flag whenever a new constant structure is retrieved
*-- (Seq OCFLAG,ROEVNTI,ROEVNT,RGETCA,ROGOKU,ROWOUT).
*-- Rearrange ZEBRA store/division configuration (ROPPAK).
*--
*--   Version 3.07 :
*-- Print out event No up to 999999 (REPORT)
*-- Introduce CRAY hooks for OPEN statement (ROOFLX)
*-- Get rid of RFKINE, RPKINE and RPVERT
*-- Use RODAT instead of CALDAT to avoid GENLIB (RGETDA)
*-- Opening of RZ calibration file: / encoded in ROOFLX (ROOFLX)
*-- Add JC in the version Nb. table (ROINIT,RPRTVS and Seq CRVER)
*-- Open the calibration database with file name (ROOFLX)
*-- Skip calibration retrieval if DST are read in (RGETDA)
*-- Modify interactive event loop and GOTO command (ROEVNT,CDF)
*-- New header :Update in ROPBAT (ROPBAT,ROWOUT)
*--             Julian date/time conversion (RGETDA)
*-- Update bank documentation + links for HB->HT,HE->HS.
*-- Interactive version calls ROPE KUMAC file.
*-- Output stream expanding over multiple files (ROOPEN,ROWDAO).
*-- FATAL error always reported (RGINIT).
*-- REWIND interactive command added (ROIKU + CDF,ROGOKU).
*-- Multiple name for metafile on Apollo (ROOFLX).
*-- Remove OD related routines (ODGRPR,RODBLK) and KUIP commands (CDF).
*-- Bits in On-line version of ROEVNT.
*-- ROWOUT called in ROEVNT in batch mode only (ROEVNT,ROWOUT,ROWDAO).
*--    ROWOUT erase part of REV to handle DST writing, and this
*--    is not suited for interactive processing.
*--    The KUIP command ROWOUT is the way to write results in this case.
*-- Always retrieve Calib. constant in interactive mode (RGETCA).
*-- Do not drop DST banks if Raw data are not there (ROPBAT).
*-- Add some dummies for OPCAL and GROPE.
*-- Put total ECAL and HCAL energy in the header (ROWOUT).
*-- Make some compatibility with old header type.
*--   (Temporary bodge in RGETDA,RGETCO and RGETCN)
*-- Print unknown type header (IDENT=0) only once (RGETDA).
*-- 2 word arrays for IOREV,IOHEAD needed for new header (ROINIT).
*-- Set hooks to connect to the On-line DAQ through CAT:
*--   Patchy selected with flag ONLINE, mods in ROEVNT.
*--   Initialisation in ONSETR, end in ONFIN (ROPINIT,ROPSET,ROPFIN).
*-- Run FLOPPY and tidy the code.
*-- Define cards TTBAT,TRBAT and FIBAT to steer trigger and filter proc.
*-- Strong typing option selected in DECLARE sequence.
*-- Set hooks for filter and trigger code (Seq CRVER,ROPINI,ROPSET,
*--                                        ROPBAT,ROPFIN,RPRTVS)
*-- Add dummies for GR.
*-- Set hooks if OPAL Start and End-of-Run used (RGETDA,RGETST,RGETED).
*-- Add interactive commands (ROIKU,ROCENT,ROECAL,ROFORW,ROHCAL,ROMUON)
*-- Monitor US routines (ROPBAT,ROSUMF).
*-- Keep links to Monitor banks in a link area(Seq ROSLNK,ROPPAK,RBKREV).
*-- Patchy flag KUWAG to get graphic KUIP version in interactive mode.
*-- Clear links for new events (RBKREV,RGETDA).
*-- Introduce TR,TT,SC and FI in database (Seq RCHTOP,RCASET,ROINIT).
*-- Implement General Constants in link 19 of DAC (Seq ROCPAR).
*-- Modify OCINI and OCMAK calling sequences (ROOPEN).
*-- Implement OCFLAG keep sequence.
*-- Handle constant structure on INPUT (RGETCN).
*-- Handle constant structure on OUTPUT (RGETCO,RGETCN,RGETCA).
*-- Rename REPORT banks in event structure.
*-- Retrieve GOPAL version from input (RBKREV).
*-- Implement new event header (RGETCO,RGETDA,ROINIT,ROWOUT).
*-- Fill ROPE Processing version, No. of CT tracks,
*-- No. of muon segments, No. of vertices (ROWOUT).
*-- Total EM energy, Total hadronic energy (ROWOUT).
*** Still to do :ROPE Event streams.
*-- Continue processing on run time error (/RCNTRL/,ROEVNT,ROTRAP).
*-- Call ROWOUT during event recovery (ZTELUS).
*-- Implement 'PROD' stream (RGETCA,RIOFIL,RIOSEL,RIOSET,ROOPEN).
*-- Modify booking of OD top banks (RBKREV and RBKRCO).
*-- Always call ODBAT (ROPBAT).
*-- Modification of OPEN statement on Apollo (ROOFLX).
*-- Creation of new RZ calibration file (ROOPEN).
*-- Set OPCAL logging level (call OCSETR in ROPSET).
*-- Allows reading of Alpha FZ files (ROOFLX).
*-- Read FFREAD cards on unit 5 in batch mode on Apollo (RMAINB).
*-- Do not print Histo at the end, must be done by user (ROPFIN).
*-- Expt. numbers go up to 9999 (REPORT).
*--
*--   Version 3.06 :
*-- Further modification for OPCAL.
*-- Introduce a dummy OCPUT.
*-- More on bank documentation.
*-- Modify ROSUMM for new FD processor.
*-- Reduce printing in interactive mode.
*-- Add 2 links to the Raw Data bank DA :LLTTRA (track trigger),
*--                                      LLFIRA (filter)
*-- Zero steering bank in RFLSET.
*-- Update documentation.
*-- Add routine ROPTPR to print event loop.
*-- CENTRAL, ECAL, ... CARDS accept 'ALL '.
*-- Add CE and CA statistics in summary.
*-- Set proper unit for FFREAD cards for batch mode on Apollo.
*-- Mod. in RPTREE for new LUND particle code.
*-- Remove call to OCEND in REPORT; Handling of 'FATAL' and 'CRASH'
*-- calls now done in ZTELUS.
*-- Modify REPORT summary lay out, sort in alphabetical order.
*-- Modify version printout, add OPUTIL and OPCAL.
*-- Compatible with OD302, remove all OD routines from ROPE,
*-- Modify ROCPAR for new DST.
*-- Remove sequence GOPAR, now in GOPAL118.
*-- Add 4th parameter to DEBUG Ffread card for log level
*-- Book top calibration constant bank DAC in RBKRCO if not there:
*-- this is now  needed to have hooks to hang structure retrieved
*-- with OPCAL.
*-- Complete revamp of routine/chaining .....
*-- Full up-to-date documentation of all banks lifted in kernel.
*-- Mods to ease up ROPE initialization in GOPAL.
*-- RZ file opened with no name (no FILE=..) on IBM.
*-- Implementation for OPCAL101, multiple database definition:
*-- (*FILE 'CAL ' 'OPT1' LUN LREC 'OPT2' 'NAME').
*-- Processors can select their database for reading and writing
*-- constants with CALREAD/CALWRITE ffread cards.
*-- Get constant structure independantly from data (*FILE 'CONS' ..).
*--        This is negotiable, just commented in RGETCN:
*-- Do not update constant structure if constant record found on input.
*-- Event selection improved (TRIGGER, *READ, *EVENT).
*-- Multiple tape reading on same logical input unit (see RONFLX).
*-- Improve run time error handling (see ROTRAP).
*-- Implement run time error handling on VAX too.
*-- Unprocessed events saved on special stream (*FILE 'OVER' ..).
*-- Monitor time/space used by each processor (MONITOR card).
*-- Verify ZEBRA after each process (ZVERIFY card).
*-- Ffread set of No trials for event reading (READTRY card).
*-- Ffread set of No printings in REPORT (REPORT card, 6 arg).
*-- Common RCNTRL for specific ROPE kernel control words.
*-- Default file format is now implemented:
*--        Exchange mode -> RECFM=U  ,LRECL=8100,BLOCK=32400
*--        Native mode   -> RECFM=VBS,LRECL=2440,BLOCK=32400
*-- Same control for MC or BEAM/COSMICS data.
*-- Hbook RZ file opening (*FILE 'HISTO' 'OPT ' LUN ),
*--                         with 'OPT ' = 'IN  ','OUT ' or 'UPD '.
*-- Rename DI calls to GR.
*-- Rename all XXDA reference to XXRA (LLXXDA still defined temporarily)
*-- Rename all XXDC reference to XXCT (LLXXDA still defined temporarily)
*--
*--   Version 3.05 :
*-- Option ERRECO to handle IBM error conditions.
*-- Implement new OD Sequences.
*-- Limit output set with FZLIMIT card.
*-- Modification in RBKREV to set all links.
*-- New FFREAD cards to rerun some processors.
*-- Add calls to XXDROP.
*-- "Fatal" and "Crash" calls to REPORT skips event and abends job.
*-- Small mod in RECTOH (used in REPORT).
*-- Activate calls to OPCAL (OCINI,OCEND and XXCALR).
*--
*--   Version 3.04 :
*-- Version to run on GOPAL116 events.
*-- Modify ROPAR Keep sequence for new header.
*-- Update bank documentation according to Dorothee/Otto S.
*-- Modify ROSUMMF for new Moun code.
*-- Install initialisation of OPCAL (Still comment it).
*-- Declare FFUSER,ZTELUS and QEND externals in RMAINB/I.
*-- RBKRCO,RBKREV: Set all permanent links.
*--
*--   Version 3.03 :
*-- Mods. for GOPAL115: Structure RCO read from GOPAL output.
*-- Incorporate reading of DST in ROPE.
*-- Incorporate steering of DST block creation in ROPE.
*-- Modify steering of data reading, selection in RSELDA
*-- allows fast skipping of events.
*--
*--   Version 3.02 :
*--
*-- OD top level bank booked in RBKREV.
*-- Implement IO facilities.
*-- Interactive version with KUIP.
*-- Add calls to MMINIT,MMSETR and MMFIN in ROPINI,ROPSET and ROPFIN.
*-- Enable FD processor.(Changed link area)
*--
*--   Version 3.01 :
*--
*-- GOPAL/ROPE compatibility -> Change ROBANK,
*--                          -> NZMEM = Size of ZEBRA in ROMAINB/I
*--                          -> Ceate divisions in ROPPAK,
*-- Order of division 20=G_CONSTA,19=R_CONSTA,18=R_STATIS,
*--                   17=G_EVENTS, 2=R_EVENTS
*-- Add call to DIBAT.
*-- Replace call to CEBAT(I) (I=1,2) by CEBAT and CABAT;
*--                                     Control with CENTRAL card
*-- Rename LMEC to LMECO in RCLINK, Clash with GCTRAK.
*-- Add LCE,LCA,LCEC,LCAC,LCES,LCAS in RCLINK, add corresponding links.
*-- Add summary routine ROSUM.
*-- Patchy flag APOLLO in ROMAIN.
*-- Size of ZEBRA store, HBOOK memory set through default self material.
*-- Remove known bugs
*--
*--   Version 2.13 :
*--
*-- ZEBRA trouble handled by ZTELUS.
*-- Implementation of a Statistical ZEBRA Division.
*-- Framework for merging processes.
*-- Implementation of CE process.
*-- Output from ROPE,implementation of OD process.
*-- Initialisation of GKS,remodeling of CDI sequence.
*-- Patchy flag HBOOK4 to initialise new HBOOK.
*-- 8 character for FFREAD cards.
*-- User routine called at each step of event processing.
*-- Use of REPORT facility.
*-- Implementation of Patchy Sequence ROPAR,ROCPAS,ROSPAR,GOPAR,CFPAR.
*-- Documentation of +KEEP sequences.
*-- New defaults for FFREAD inputs.
*-- Type declaration.
*-- Change XXSET to XXSETR.(Pb with CVSET).
*-- Common CXX merged into CRVER.
*-- Bug removal:Time limit,...
*--
*--   Version 2.12 :
*-- Interactive and Batch library are now the same.
*-- This version also allows reading of raw data
*-- structure written with GOPAL112.The FFREAD card
*-- GOPAL is implemented and its argument should
*-- be the version number of the MC program used
*-- to create the events we want to read.The
*-- default is 111 for backward compatibility.
*--                        18 May 1987  S.Weisz
*--
*--   Version 2.11 :
*-- Implementation following january workshop,in  phase with GOPAL111:
*--                + Common /CRO/ now contains more flags.
*--                + Routine ROEVNT steers the reading of events.
*--                  - calls BETRIG if IRBEAM is set.
*--                  - calls GETRIG to read GOPAL events.
*--                    - calls GEGET to get the GOPAL lifted raw
*--                      data structure plus the usual GEANT
*--                      data set ('INIT','KINE','HIT '..) which
*--                      are now selected with FFREAD card ROGET.
*--                + New FFREAD cards to:
*--                    read data from up to 5 files.
*--                    read data in exchange mode.
*--                    read a set of events           (TRIG).
*--                    debug a set of events          (DEBUG).
*--                    set the safety time to finish  (TSAFE).
*--                        9 February 1987  S.Weisz
*--
*--   Version 2.10 :
*-- Proper IBM implementation.
*-- /GCBANK/ and /ROBANK/ size through parameter cards.
*-- Message according to return code of BETRIG.
*-- Check of time left.
*--                        4 December 1986  S.Weisz
*--
*--   Version 2.09 :
*-- Fake filling of CD Track and Vertex banks with routine CDFAKE.
*--                        20 May 1986  S.Weisz
*--
*--   Version 2.08 :
*-- Result of ROPE S.W. starting 12/4/86.
*--                        18 April 1986  A.Mc Pherson,A.Possoz,S.Weisz
*--
*--   Version 2.07 :
*-- Batch Version Implemented.
*--                        20 March 1986  S.Weisz
*--
*--   Version 2.06 :
*-- ROPE Data Structure implemented.
*--                        13 March 1986  S.Weisz
*--
*--   Version 2.04 :
*-- ROPE adapted to ZEBRA3.40 and to GEANT 3.10.
*--                        13 March 1986  R.Brun
*--
*--
+PATCH,ROCDES.
+DECK,RCLINK.
+KEEP,RCLINK.
      INTEGER       LREV ,LRCO ,LRST ,LHEAD,LAA  ,
     +        LEX  ,LUT  ,LDA  ,LCD  ,LEC  ,LHC  ,LMU  ,LFO  ,LDD  ,
     +        LOD  ,LLEP ,LMC  ,LCV  ,LCJ  ,LCZ  ,LCT  ,LDX  ,LCF  ,
     +        LCX  ,LSI  ,LCS  ,LCE  ,LCA  ,LTB  ,LPB  ,LEB  ,LPE  ,
     +        LEE  ,LEM  ,LHB  ,LHE  ,LHP  ,LHM  ,LMB  ,LME  ,LMM  ,
     +        LFD  ,LSW  ,LUS  ,
     +        LEXC ,LUTC ,LDAC ,LCDC ,LECC ,LHCC ,LMUC ,LFOC ,LDDC ,
     +        LODC ,LLEPC,LMCC ,LCVC ,LCJC ,LCZC ,LCTC ,LDXC ,LCFC ,
     +        LCXC ,LSIC ,LCSC ,LCEC ,LCAC ,LTBC ,LPBC ,LEBC ,LPEC ,
     +        LEEC ,LEMC ,LHBC ,LHEC ,LHPC ,LHMC ,LMBC ,LMECO,LMMC ,
     +        LFDC ,LSWC ,LUSC ,
     +        LEXS ,LUTS ,LDAS ,LCDS ,LECS ,LHCS ,LMUS ,LFOS ,LDDS ,
     +        LODS ,LLEPS,LMCS ,LCVS ,LCJS ,LCZS ,LCTS ,LDXS ,LCFS ,
     +        LCXS ,LSIS ,LCSS ,LCES ,LCAS ,LTBS ,LPBS ,LEBS ,LPES ,
     +        LEES ,LEMS ,LHBS ,LHES ,LHPS ,LHMS ,LMBS ,LMES ,LMMS ,
     +        LFDS ,LSWS ,LUSS ,LTE  ,LTEC ,LTES ,LZZ
      COMMON/RCLINK/LREV ,LRCO ,LRST ,LHEAD,LAA  ,
     +        LEX  ,LUT  ,LDA  ,LCD  ,LEC  ,LHC  ,LMU  ,LFO  ,LDD  ,
     +        LOD  ,LLEP ,LMC  ,LCV  ,LCJ  ,LCZ  ,LCT  ,LDX  ,LCF  ,
     +        LCX  ,LSI  ,LCS  ,LCE  ,LCA  ,LTB  ,LPB  ,LEB  ,LPE  ,
     +        LEE  ,LEM  ,LHB  ,LHE  ,LHP  ,LHM  ,LMB  ,LME  ,LMM  ,
     +        LFD  ,LSW  ,LUS  ,
     +        LEXC ,LUTC ,LDAC ,LCDC ,LECC ,LHCC ,LMUC ,LFOC ,LDDC ,
     +        LODC ,LLEPC,LMCC ,LCVC ,LCJC ,LCZC ,LCTC ,LDXC ,LCFC ,
     +        LCXC ,LSIC ,LCSC ,LCEC ,LCAC ,LTBC ,LPBC ,LEBC ,LPEC ,
     +        LEEC ,LEMC ,LHBC ,LHEC ,LHPC ,LHMC ,LMBC ,LMECO,LMMC ,
     +        LFDC ,LSWC ,LUSC ,
     +        LEXS ,LUTS ,LDAS ,LCDS ,LECS ,LHCS ,LMUS ,LFOS ,LDDS ,
     +        LODS ,LLEPS,LMCS ,LCVS ,LCJS ,LCZS ,LCTS ,LDXS ,LCFS ,
     +        LCXS ,LSIS ,LCSS ,LCES ,LCAS ,LTBS ,LPBS ,LEBS ,LPES ,
     +        LEES ,LEMS ,LHBS ,LHES ,LHPS ,LHMS ,LMBS ,LMES ,LMMS ,
     +        LFDS ,LSWS ,LUSS ,LTE  ,LTEC ,LTES ,LZZ
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence RCLINK
*
*******************************************************************
*
*              RCLINK is a permanent link area for the
*                       ROPE top structures.
*
*                  Structural links
* LREV  : Link to the top REV bank for event structure
* LRCO  : Link to the top RCO bank for constants structure
* LRST  : Link to the top RST bank for statistic structure
* LHEAD : Link to the HEAD structure read from GOPAL
*
*                  Reference links in event division
* LEX   : to external devices bank EX
* LUT   : to utility bank UT (eg input/output)
* LDA   : to raw data bank DATR
* LCD   : to central detector bank
* LEC   : to electro-magnetic calorimetry bank
* LHC   : to hadron calorimetry bank
* LMU   : to muon chamber bank
* LFO   : to forward detector bank
* LDD   : to dense data bank
* LOD   : to "DST" bank
* LLEP  : to LEP data
* LMC   : to initial MC data
* LCV   : to vertex chamber processing bank
* LCJ   : to jet chamber processing bank
* LCZ   : to Z chamber processing bank
* LCT   : to CD merging track bank
* LDX   : to DEDX processing bank
* LCF   : to CD "fake" track bank
* LCX   : to CD vertex finding bank
* LSI   : to Silicon Microvertex tracking bank
* LCS   : to CT/SI merging bank
* LCE   : to CD extrapolation bank
* LCA   : to CD association bank
* LTB   : to time-of-flight processing bank
* LPB   : to presampler barrel processing bank
* LEB   : to barrel lead glass processing bank
* LPE   : to presampler end-cap processing bank
* LEE   : to end-cap lead glass processing bank
* LEM   : to E.M. cluster processing bank
* LHB   : to hadron barrel processing bank
* LHE   : to hadron end-cap processing bank
* LHP   : to hadron pole-tip processing bank
* LHM   : to hadron cluster processing bank
* LMB   : to muon barrel processing bank
* LME   : to muon end-cap processing bank
* LMM   : to muon segment processing bank
* LFD   : to forward detector processing bank
* LSW   : to silicon tungsten (SW) processing bank
* LTE   : to TE processing bank
* LUS   : to user bank (not used)
*
*                  Reference links in constant division
* LEXC  : to external devices bank EXC
* LUTC  : to utility bank UTC (eg input/output)
* LDAC  : to calibration data bank
* LCDC  : to central detector constant bank
* LECC  : to electro-magnetic calorimetry constant bank
* LHCC  : to hadron calorimetry constant bank
* LMUC  : to muon chamber constant bank
* LFOC  : to forward detector constant bank
* LDDC  : to dense data constant bank
* LODC  : to "DST" constant bank
* LLEPC : to LEP constant bank
* LMCC  : to initial MC constant bank
* LCVC  : to vertex chamber constant bank
* LCJC  : to jet chamber constant bank
* LCZC  : to Z chamber constant bank
* LCTC  : to CD merging track constant bank
* LDXC  : to DEDX constant bank
* LCFC  : to CD "fake" track constant bank
* LCXC  : to CD vertex finding constant bank
* LSIC  : to Silicon Microvertex constant bank
* LCSC  : to CT/SI merging constant bank
* LCEC  : to CD extrapolation constant bank
* LCAC  : to CD association constant bank
* LTBC  : to time-of-flight constant bank
* LPBC  : to presampler barrel constant bank
* LEBC  : to barrel lead glass constant bank
* LPEC  : to presampler end-cap constant bank
* LEEC  : to end-cap lead glass constant bank
* LEMC  : to E.M. cluster constant bank
* LHBC  : to hadron barrel constant bank
* LHEC  : to hadron end-cap constant bank
* LHPC  : to hadron pole-tip constant bank
* LHMC  : to hadron cluster constant bank
* LMBC  : to muon barrel constant bank
* LMECO : to muon end-cap constant bank
* LMMC  : to muon segment constant bank
* LFDC  : to forward detector constant bank
* LSWC  : to silicon tungsten (SW) constant bank
* LTEC  : to TE constant bank
* LUSC  : to user constant bank (not used)
*
*                  Reference links in statistic division
* LEXS  : to external devices bank EXS
* LUTS  : to utility bank UTS (eg input/output)
* LDAS  : to calibration data bank
* LCDS  : to central detector statistic bank
* LECS  : to electro-magnetic calorimetry statistic bank
* LHCS  : to hadron calorimetry statistic bank
* LMUS  : to muon chamber statistic bank
* LFOS  : to forward detector statistic bank
* LDDS  : to dense data statistic bank
* LODS  : to "DST" statistic bank
* LLEPC : to LEP statistic bank
* LMCC  : to initial MC statistic bank
* LCVS  : to vertex chamber statistic bank
* LCJS  : to jet chamber statistic bank
* LCZS  : to Z chamber statistic bank
* LCTS  : to CD merging track statistic bank
* LDXS  : to DEDX statistic bank
* LCFS  : to CD "fake" track statistic bank
* LCXS  : to CD vertex finding statistic bank
* LSIS  : to Silicon Microvertex statistic bank
* LCSS  : to CT/SI merging statistic bank
* LCES  : to CD extrapolation statistic bank
* LCAS  : to CD association statistic bank
* LTBS  : to time-of-flight statistic bank
* LPBS  : to presampler barrel statistic bank
* LEBS  : to barrel lead glass statistic bank
* LPES  : to presampler end-cap statistic bank
* LEES  : to end-cap lead glass statistic bank
* LEMS  : to E.M. cluster statistic bank
* LHBS  : to hadron barrel statistic bank
* LHES  : to hadron end-cap statistic bank
* LHPS  : to hadron pole-tip statistic bank
* LHMS  : to hadron cluster statistic bank
* LMBS  : to muon barrel statistic bank
* LMES  : to muon end-cap statistic bank
* LMMS  : to muon segment statistic bank
* LFDS  : to forward detector statistic bank
* LSWS  : to silicon tungsten (SW) statistic bank
* LTES  : to TE statistic bank
* LUSS  : to user statistic bank (not used)
******************************************************************
+SEQ ,RCLINK.
+DECK,ROBANK.
+KEEP,ROBANK.
      INTEGER NRODUM
      PARAMETER (NRODUM=50)
      INTEGER  IRODIV, IROCON, IROSTA
      COMMON/ROBANK/IRODIV,IROCON,IROSTA
      INTEGER IQND(NRODUM-29),  IQNS(NRODUM-28),
     +        IQNL(NRODUM-27), IQIDH(NRODUM-26), IQIDN(NRODUM-25)
      EQUIVALENCE (  IQ(1),  IQND(2),  IQNS(3),
     +             IQNL(4), IQIDH(5), IQIDN(6))
      INTEGER LQNEXT(NRODUM-22),  LQUP(NRODUM-23), LQORIG(NRODUM-24)
      EQUIVALENCE (LQ(3), LQORIG(1),  LQUP(2), LQNEXT(3))
+SEQ,RCLINK.
+SEQ,GCBANK.
      EQUIVALENCE (WS(1),IWS(1))
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence ROBANK
*
*******************************************************************
*
*            ZEBRA common for the ROPE store
*
* NRODUM : Dummy dimension
* IXSTOR : Index of the ROPE store
* IRODIV : Index of the Event division
* IROCON : Index of the Constant division
* IROSTA : Index of the Statistic division
*
*          Consider a bank XXXX at address LXXX
* IQND(LXXXX)   = Number of data word in XXXX
* IQNS(LXXXX)   = Number of structural links in XXXX
* IQNL(LXXXX)   = Total number of links in XXXX
* IQIDH(LXXXX)  = Hollerlith bank identifier ( XXXX )
* IQIDN(LXXXX)  = Numeric bank identifier
* LQORIG(LXXXX) = Address of the supporting link for bank XXXX
* LQUP(LXXXX)   = Address of the supporting bank
* LQNEXT(LXXXX) = Address of the next bank in a linear structure
******************************************************************
+SEQ ,ROBANK
+DECK,CRO.
+KEEP,CRO.
      INTEGER      NUHMAX
      PARAMETER   (NUHMAX=64)
      INTEGER      IRDATE,IRTIME,IVGOPA,IRBEAM,IRINTR,
     +             LRIN  ,LROUT ,
     +             IREVNT,IRDEXP,IRDRUN,IRDEVT,IRDEBU,
     +             NUHEAD,IOHEAD,IUHEAD
      REAL         RUHEAD
      DIMENSION    RUHEAD(NUHMAX)
      COMMON/CRO/  IRDATE,IRTIME,IVGOPA,IRBEAM,IRINTR,
     +             LRIN  ,LROUT ,
     +             IREVNT,IRDEXP,IRDRUN,IRDEVT,IRDEBU,
     +             NUHEAD,IOHEAD(2),IUHEAD(NUHMAX)
      EQUIVALENCE (IUHEAD,RUHEAD)
      INTEGER      NHEADR
      REAL         RHEADR(NUHMAX)
      COMMON/RONHDE/NHEADR(NUHMAX)
      EQUIVALENCE (NHEADR,RHEADR)
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence CRO
*
*******************************************************************
*
* NUHMAX    : Maximum number of words in the user header
* IRDATE    : Current date
* IRTIME    : Current time
* IVGOPA    : Version of GOPAL for MC events
* IRBEAM    : Flag set to 1 for beam data (obsolete (at least from 403)
* IRINTR    : Flag set to 1 if ROPE is running in interactive mode
* LRIN      : Input unit for control
* LROUT     : Output unit for messages
* NUHEAD    : Number of words in the USER header (pilot record)
* IOHEAD    : IO format of User header
* IUHEAD    : USER header (pilot record)
* IREVNT    : Internal ROPE event number
* IRDEVT    : External 'experiment' number
* IRDRUN    : External run number
* IRDEVT    : External event number
* IRDEBU    : Flag set to 1 if event to be debugged
* NHEADR    : Header deduced from the nanodst
*
******************************************************************
+SEQ ,CRO.
+DECK,RCNTRL.
+KEEP,RCNTRL.
      INTEGER    IREVPR,IRSTOP,IRTRIG,IRDEBG,IODPBL,IMONIT,IZVERI,
     +           IZLOGL,IRUFST,IEVFST,IRULST,IEVLST,ITRYMX,
     +           NCENT ,NECAL ,NHCAL ,NMUON ,NFORW ,NPACK ,NODBLK,
     +           LCENT ,LECAL ,LHCAL ,LMUON ,LFORW ,LPACK ,LODBLK,
     +           NRERUN,LRERUN,LEVKEY,LREKEY,LGEKEY,LCALRD,LCALWT,
     +           ICMAIN,NEVTRP,NTOTRP,ITTBAT,ITRBAT,IFIBAT,ISCBAT,
     +           IDDBAT,IDUBAT,IFCNST,IFSCAN,IFBOOK,IFDROP,IFUPDT,
     +           INDROP,ICDATE,ICTIME,NSTOP ,KEEPJU,ILLBAT,ILABAT,
     +           ISDATE,ISTIME,IFODSI,IFNOEU,NOWRIT
      INTEGER    NSLCMI,NSLCMA,NSLMMI,NSLMMA,ISLRUN,ISLEVT,IFSLON
      INTEGER    NPFILE,NPFATF,NAMLEN,NAMLWO,NPAFIL,NPAFAT,NPACAT,
     +           NPCATA,NPCFIL,NPACFI,NPGDEV,NPAGDE,NPADAD,NPDADL,
     +           LFITYP,LFIDIR,LFIUNI,LFILRE,LFIFCH,LFIDCH,LFINAM,
     +           LCFTYP,LCFDIR,LCFUNI,LCFLRE,LCFFCH,LCFDCH,LCFNAM,
     +           LFATYP,LFADIR,LFAUNI,LFADCH,LFANAM,LCAUNI,LCANAM,
     +           LDATYP,LDADIR,LDAUN1,LDAUN2,LDAOPT,LDANAM,
     +           LFATLU,LFATLO,LFATLW,LFATL1,LFATL2,
     +           LNADIR,LNAUN1,LNAUN2,LNAOPT,LNANAM,NPANAN,NPNANO,
     +           LEVDIR,LEVUN1,LEVUN2,LEVUN3,LEVOPT,LEVNAM,
     +           NPAEVT,NPEVTL,
     +           LMNDIR,LMNUNI,LMNOPT,LMNNAM,NPAMAS,NPMAST,
     +           LNDEVI,LTYPDE,LDEVNA,
     +           IPHONE,NPHONE,LUFONE,LFOOPT,IUNITU,NUNITU, MAXSEL
      INTEGER    MSHDSL, MSANYS,ISEKEY
      INTEGER NTRYMX,  MSHDVE
      REAL       ESLEMI,ESLEMA,ESLHMI,ESLHMA
      REAL       RTIMST,RTIMSF,RFZLIM,RTIMSI,RTIMSE
      LOGICAL    FATFIL,FFERRO,LMEMIN,LMEMOU
      PARAMETER (NAMLEN = 80,NAMLWO = NAMLEN/4,
     +           NPAFIL =  6,NPFILE = NPAFIL+NAMLWO,
     +           NPACFI =  6,NPCFIL = NPACFI+NAMLWO,
     +           NPAFAT =  4,NPFATF = NPAFAT+NAMLWO,
     +           NPADAD =  5,NPDADL = NPADAD+NAMLWO,
     +           NPACAT =  1,NPCATA = NPACAT+NAMLWO,
     +           NPAGDE =  2,NPGDEV = NPAGDE+NAMLWO,
     +           NPANAN =  4,NPNANO = NPANAN+NAMLWO,
     +           NPAEVT =  5,NPEVTL = NPAEVT+NAMLWO,
     +           NPAMAS =  3,NPMAST = NPAMAS+NAMLWO,
     +           NPHONE = 10,NUNITU = 10, MAXSEL=10)
      COMMON/RCNTRL/IREVPR,IRSTOP,IRTRIG(3),IRDEBG(4),IODPBL(3),
     +       IMONIT,IZVERI,IZLOGL,IRUFST,IEVFST,IRULST,IEVLST,ITRYMX,
     +       NCENT ,NECAL ,NHCAL ,NMUON ,NFORW ,NPACK ,NODBLK,
     +       LCENT(20),LECAL(20),LHCAL(20),LMUON(20),LFORW(20),
     +       LPACK(20),LODBLK(20),NRERUN,LRERUN(20),LEVKEY(4),
     +       LREKEY(3),LGEKEY(2),LCALRD(46),LCALWT(46),ICMAIN,
     +       RTIMST,RTIMSF,RFZLIM,RTIMSI,RTIMSE,NEVTRP,NTOTRP,ITTBAT,
     +       ITRBAT,IFIBAT,ISCBAT,IDDBAT,IDUBAT,IFCNST,IFSCAN,IFBOOK,
     +       IFDROP,IFUPDT,INDROP,NSLCMI,NSLCMA,ESLEMI,ESLEMA,ESLHMI,
     +       ESLHMA,NSLMMI,NSLMMA,ISLRUN,ISLEVT,IFSLON,ICDATE,ICTIME,
     +       NSTOP,FATFIL,FFERRO,LMEMIN,LMEMOU,LFITYP,LFIDIR,LFIUNI,
     +       LFILRE,LFIFCH,LFIDCH,LFINAM(NAMLWO),LCFTYP,LCFDIR,LCFUNI,
     +       LCFLRE,LCFFCH,LCFDCH,LCFNAM(NAMLWO),LFATYP,LFADIR,LFAUNI,
     +       LFADCH,LFANAM(NAMLWO),LDATYP,LDADIR,LDAUN1,LDAUN2,LDAOPT,
     +       LDANAM(NAMLWO),LCAUNI,LCANAM(NAMLWO),LFATLU,LFATLO,
     +       LFATLW,LFATL1,LFATL2,LNADIR,LNAUN1,LNAUN2,LNAOPT,
     +       LNANAM(NAMLWO),LEVDIR,LEVUN1,LEVUN2,LEVUN3,LEVOPT,
     +       LEVNAM(NAMLWO),LMNDIR,LMNUNI,LMNOPT,LMNNAM(NAMLWO),
     +       LNDEVI,LTYPDE,LDEVNA(NAMLWO),IPHONE(NPHONE),LUFONE,LFOOPT,
     +       IUNITU(NUNITU),KEEPJU,ILLBAT,ILABAT,ISDATE,ISTIME,IFODSI
      COMMON/RCNTRL/NTRYMX(2),
     +              MSHDSL(MAXSEL) ,MSANYS, ISEKEY(3), MSHDVE(MAXSEL),
     +              IFNOEU,NOWRIT

+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence RCNTRL
*
*******************************************************************
*
* IREVPR    : Number of processed events
* IRTRIG    : First/last/increment event to process
* IRDEBG    : First/last/increment event to debug
* IODPBL    : First/last/increment event to print OD blocks
* IMONIT    : Flag set to 1 to monitor time/space needed.
* IZVERI    : Flag set to 1 to verify ZEBRA structure.
* IRUFST    : Fisrt Run to process
* IEVFST    : Fisrt Event to process
* IRULST    : Last Run to process
* IEVLST    : Last Event to process
* ITRYMX    : Max. number of FZIN trials in ROTRIG
* NCENT     : Number of modules to process in CD
* LCENT(20) : Name of module to process in CD
* NECAL     : Number of modules to process in EC
* LECAL(20) : Name of module to process in EC
* NHCAL     : Number of modules to process in HC
* LHCAL(20) : Name of module to process in HC
* NMUON     : Number of modules to process in MU
* LMUON(20) : Name of module to process in MU
* NHFORW    : Number of modules to process in FO
* LHFORW(20): Name of module to process in FO
* NPACK     : Number of detector to pack in DD
* LPACK(20) : Name of detector to pack in DD
* NODBLK    : Number of blocks to build in OD
* LODBLK(20): Name of blocks to build in OD
* NRERUN    : Number of modules or block of modules to rerun
* LRERUN(20): Name of module or block of modules to rerun
* LEVKEY    : Array to receive the FFREAD options for *EVENT card
* LREKEY    : Array to receive the FFREAD options for *READ card
* LGEKEY    : Array to receive the FFREAD options for *GET card
* LCALRD(44): Array to receive option for CALREAD card
* LCALWT(44): Array to receive option for CALWRITE card
* ICMAIN    : Flag set to 1 if 'MAIN' database selected on input
* RTIMST    : Starting time for execution (after initialisation)
* RTIMSF    : Safety time to stop the job
* RFZLIM    : Max. number of words (in Mw) to be written out /file
* RTIMSI    : Safe time to open a new input tape
* RTIMSE    : Max. time to be spent in one event
* NEVTRP    : Event run time error counter
* NTOTRP    : Job run time error counter
* ITTBAT    : Flag to run the Track Trigger code
* ITRBAT    : Flag to run the Trigger code
* IFIBAT    : Flag to run the Filter code
* ISCBAT    : Flag to run the Slow control code
* IDDBAT    : Flag to run the packing in DD
* IDUBAT    : Flag to run the unpacking in DD
* IFCNST    : Flag to steer writing of constant record
* IFSCAN    : Flag set to 1 if fast scanning option asked
* IFBOOK    : Flag set to 0 if no bank should be booked
* IFDROP    : Flag set to 0 if no bank should be dropped
* IFUPDT    : Flag set to 0 if the header must not be updated
* IFNOEU    : Flag set to 0 if the beam energy is updated (DEFAULT) 
* INDROP    : Flag set to 0 if results bank to be dropped in reprocessing
* NSLCMI    : Min. number of track in selected event
* NSLCMA    : Max. number of track in selected event
* ESLEMI    : Min. Ecal energy in selected event
* ESLEMA    : Max. Ecal energy in selected event
* ESLHMI    : Min. Hcal energy in selected event
* ESLHMA    : Max. Hcal energy in selected event
* NSLMMI    : Min. number of muon in selected event
* NSLMMA    : Max. number of muon in selected event
* ISLRUN    : RUN# selected with EVENT command
* ISLEVT    : EVENT# selected with EVENT command
* IFSLON    : Flag set=1 if selection in use, =0 otherwise
* ICDATE    : Date of last update of constant used
* ICTIME    : Time of last update of constant used
* NSTOP     : STOP status (0->Ok,2->Time limit....)
* KEEPJU    : Flag to process events classified as junk by SUPHYS
* ILLBAT    : Flag to run lepton pair event selection (LL) code
* ILABAT    : Flag to run lepton pair analysis (LA) code
* ISDATE    : Date of last update of SUDB
* ISTIME    : Time of last update of SUDB
* IFODSI    : Steer call to ODTOSI: 0 dont call, 1 phi only, 2 phi+z
*             + 10 also CX
* NTRYMX(1) : Max. number of FZIN trials in ROTRIG and RGETDA
* NTRYMX(2) : Max. number of files allowed to be missed with DADlists
*
* Variables to receive the FFREAD options for *FILE    cards :
*                                     and for *CATFILE cards:
*     LFITYP  LCFTYP   File type
*     LFIDIR  LCFDIR   File direction
*     LFIUNI  LCFUNI   File unit
*     LFILRE  LCFLRE   File record length
*     LFIFCH  LCFFCH   File option (passed to FZFILE/RZFILE)
*     LFIDCH  LCFDCH   File dependent option
*     LFINAM  LCFNAM   File name
* Variables to receive the FFREAD options for *FATFILE
*     LFATYP   File(s) type
*     LFADIR   File(s) direction
*     LFAUNI   File(s) unit
*     LFADCH   File(s) dependent option
*     LFANAM   Catalog entry name or search path
* Variables to receive the FFREAD options for *CATALOG
*     LCAUNI   Catalog unit
*     LCANAM   Catalog name
* Variables to receive the FFREAD options for *FATMEN
*     LFATLU   Logical unit used by FATMEN
*     LFATLO   Location code used by FATMEN searches
*     LFATLW   Logical unit to update Fatmen
*     LFATL1   Logical unit for Fatmen copy
*     LFATL2   Logical unit for Fatmen copy
* Variables used to receive the FFREAD optiond for *NANODST
*     LNADIR   Nanodst direction 'IN' or 'OUT'
*     LNAUN1   Unit to access the nanodst
*     LNAUN2   Unit to access the data-file from the nanodst
*     LNAOPT   Nanodst processing option
*     LNANAM   Nanodst name
* Variables used to receive the FFREAD optiond for *EVTLIST
*     LEVDIR   Event list direction 'IN' or 'OUT'
*     LEVUN1   Unit to access the event list
*     LEVUN2   Unit to access the nanodst
*     LEVUN3   Unit to access the data-file from the nanodst
*     LEVOPT   Event list processing option
*     LEVNAM   Event list name
* Variables used to receive the FFREAD optiond for *MASTERNANODST
*     LMNDIR   Master nanodst direction 'NEW'='OUT'  or 'UPDA'
*     LMNUN1   Unit to access the master nanodst
*     LMNOPT   Master nanodst processing option
*     LMNNAM   Master nanodst name
* Variables to receive the FFREAD options for *PHONE
*     LUFONE   Logical unit
*     LFOOPT   Option (save or delete)
* Variables to receive the FFREAD options for *AUTOUNIT
*     IUNITU   Logical units reserved by the user
* Various flags
*     FATFIL   We are decoding a *FATFILE card
*     FFERRO   Some error(s) were found in FFREAD cards
*     LMEMIN   Reading ZEBRA data from memory
*     LMEMOU   Writing ZEBRA data to memory
*     NOWRIT   Suppress call to ROWOUT in ZTELUS
* Flag used for info transmission between RIOFAT,RIOCAT and RIOFL
*     ACMOD    Access mode
* Variables to for event selection based on bits in header
*
*     MSHDSL(1)       bunch info
*           (2)       detector status
*                     trigger status
*                     )
*                     trigger bits
*                     )
*                     )
*                     filter type
*                     event type word 1
*                     event type word 2
*     MSANYS          >0 if any bit set
*     ISEKEY(3)       receive input from FFREAD card *EVSEL
*
******************************************************************
+SEQ,RCNTRL.
+DECK,ROBUN.
+KEEP,ROBUN.
      INTEGER        NTRAIN,NBUNCH,IFIBUN,IROBUN,ITRAIN, IETRAI,IPTRAI
      REAL           RBUNTZ(8,8),ROBTZ
      LOGICAL        LBUNMO,LFIBUT,LFIBUS,LROBUT,LROBUS, LLEPVA
      COMMON /ROBUN/ NTRAIN,NBUNCH,IROBUN,IFIBUN,ITRAIN, IETRAI,IPTRAI,
     +               RBUNTZ,ROBTZ,
     +               LBUNMO,LFIBUT,LFIBUS,LROBUT,LROBUS, LLEPVA
+SELF,IF=DOC,RODOC.
**********************************************************************
*
*               Sequence ROBUN
*
* Information needed for running with bunchtrains
*
**********************************************************************
*   NTRAIN      : number of bunch trains
*   NBUNCH      : number of bunches per train
*   IFIBUN      : bunch number as determined by FILTER
*   IROBUN      : bunch number as determined by ROPE
*   ITRAIN      : train number (from LEP)
*   RBUNTZ(T,B) : time offset between bunch 1 and bunch B for train T[ns]
*   ROBTZ       : =RBUNTZ(ITRAIN,IROBUN)
*   LBUNMO      : bunchmode flag, .true. if in bunchmode
*   LFIBUT      : filter tried to determine bunch number
*   LFIBUS      : filter succeeded in determination of bunch number
*   LROBUT      : ROPE tried to determine bunch number
*   LROBUS      : ROPE succeeded in determination of bunch number
**********************************************************************
+SEQ, ROBUN.
      END
+DECK,ROSLNK.
+KEEP,ROSLNK.
      INTEGER       LRSMS,LRTIS,LRSPS,LRTI2,LRSP2
      COMMON/ROSLNK/LRSMS,LRTIS,LRSPS,LRTI2,LRSP2
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence ROSLNK
*
*******************************************************************
*
* LRSMS     : Link to top monitor statistics bank
* LRTIS     : Link to time monitor bank
* LRSPS     : Link to space monitor bank
* LRTI2     : Link to time**2 monitor bank
* LRSP2     : Link to space**2 monitor bank
*
******************************************************************
+SEQ ,ROSLNK.
+KEEP,NRMEM.
      PARAMETER (NRMEM=40000)
+KEEP,REBANK.
      INTEGER    NRMEM
+SEQ,NRMEM.
      INTEGER NREBRA,IRESTO,IREDIV,LREHD,IR,LR
      REAL    FENDR,R
      DIMENSION IR(NRMEM-8),R(NRMEM-8)
      COMMON/REBANK/NREBRA,IRESTO,IREDIV,FENDR(16),LR(NRMEM)
      EQUIVALENCE (R(1),IR(1),LR(9)),(LR(1),LREHD)
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence REBANK
*
*******************************************************************
*
* NREBRA    : Size of the REPORT Zebra store
* IRESTO    : Index of the REPORT Zebra store
* IREDIV    : Index of the REPORT division
* LREHD     : Link to the REPORT header bank
*
******************************************************************
+SEQ ,REBANK.
+DECK,RECNTL.
+KEEP,RECNTL.
      INTEGER       NPRTMX,IFREPO,IORWDS,NCHDUM
      CHARACTER*256 CHDUMM
      COMMON/RECNTL/NPRTMX(6),IFREPO,IORWDS(2),NCHDUM
      COMMON/RCDUMM/CHDUMM
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence RECNTL
*
*******************************************************************
*
* NPRTMX    : Max. number of printing in REPORT
* IFREPO    : Flag to write report messages on event structure
* IORWDS    : IO Characteristic of error banks
* CHDUMM    : Dummy character array for ROPE dummies.
*
******************************************************************
+SEQ ,RECNTL.
+DECK,CRVER.
+KEEP,CRVER.
      INTEGER     IVRO,ISVRO,IDACRO,IDAMRO,IVGR,ISVGR,IDACGR,IDAMGR,
     +            IVUS,ISVUS,IDACUS,IDAMUS,IVCV,ISVCV,IDACCV,IDAMCV,
     +            IVCJ,ISVCJ,IDACCJ,IDAMCJ,IVCZ,ISVCZ,IDACCZ,IDAMCZ,
     +            IVCT,ISVCT,IDACCT,IDAMCT,IVCX,ISVCX,IDACCX,IDAMCX,
     +            IVCE,ISVCE,IDACCE,IDAMCE,IVTB,ISVTB,IDACTB,IDAMTB,
     +            IVPB,ISVPB,IDACPB,IDAMPB,IVEB,ISVEB,IDACEB,IDAMEB,
     +            IVPE,ISVPE,IDACPE,IDAMPE,IVEE,ISVEE,IDACEE,IDAMEE,
     +            IVEM,ISVEM,IDACEM,IDAMEM,IVHB,ISVHB,IDACHB,IDAMHB,
     +            IVHE,ISVHE,IDACHE,IDAMHE,IVHP,ISVHP,IDACHP,IDAMHP,
     +            IVHM,ISVHM,IDACHM,IDAMHM,IVMB,ISVMB,IDACMB,IDAMMB,
     +            IVME,ISVME,IDACME,IDAMME,IVMM,ISVMM,IDACMM,IDAMMM,
     +            IVFD,ISVFD,IDACFD,IDAMFD,IVDD,ISVDD,IDACDD,IDAMDD,
     +            IVOD,ISVOD,IDACOD,IDAMOD,IVOU,ISVOU,IDACOU,IDAMOU,
     +            IVOC,ISVOC,IDACOC,IDAMOC,IVTT,ISVTT,IDACTT,IDAMTT,
     +            IVTR,ISVTR,IDACTR,IDAMTR,IVFI,ISVFI,IDACFI,IDAMFI,
     +            IVON,ISVON,IDACON,IDAMON,IVJC,ISVJC,IDACJC,IDAMJC,
     +            IVSU,ISVSU,IDACSU,IDAMSU,IVOP,ISVOP,IDACOP,IDAMOP,
     +            IVDX,ISVDX,IDACDX,IDAMDX,IVSI,ISVSI,IDACSI,IDAMSI,
     +            IVCS,ISVCS,IDACCS,IDAMCS,IVLL,ISVLL,IDACLL,IDAMLL,
     +            IVLA,ISVLA,IDACLA,IDAMLA,IVBT,ISVBT,IDACBT,IDAMBT
      INTEGER     IVID,ISVID,IDACID,IDAMID,IVLM,ISVLM,IDACLM,IDAMLM,
     +            IVDC,ISVDC,IDACDC,IDAMDC,IVSW,ISVSW,IDACSW,IDAMSW,
     +            IVCU,ISVCU,IDACCU,IDAMCU,IVHI,ISVHI,IDACHI,IDAMHI,
     +            IVGC,ISVGC,IDACGC,IDAMGC,IVSQ,ISVSQ,IDACSQ,IDAMSQ,
     +            IVPX,ISVPX,IDACPX,IDAMPX,IVTE,ISVTE,IDACTE,IDAMTE,
     +            IVWW,ISVWW,IDACWW,IDAMWW
      COMMON/CRVER/IVRO,ISVRO,IDACRO,IDAMRO,IVGR,ISVGR,IDACGR,IDAMGR,
     +            IVUS,ISVUS,IDACUS,IDAMUS,IVCV,ISVCV,IDACCV,IDAMCV,
     +            IVCJ,ISVCJ,IDACCJ,IDAMCJ,IVCZ,ISVCZ,IDACCZ,IDAMCZ,
     +            IVCT,ISVCT,IDACCT,IDAMCT,IVCX,ISVCX,IDACCX,IDAMCX,
     +            IVCE,ISVCE,IDACCE,IDAMCE,IVTB,ISVTB,IDACTB,IDAMTB,
     +            IVPB,ISVPB,IDACPB,IDAMPB,IVEB,ISVEB,IDACEB,IDAMEB,
     +            IVPE,ISVPE,IDACPE,IDAMPE,IVEE,ISVEE,IDACEE,IDAMEE,
     +            IVEM,ISVEM,IDACEM,IDAMEM,IVHB,ISVHB,IDACHB,IDAMHB,
     +            IVHE,ISVHE,IDACHE,IDAMHE,IVHP,ISVHP,IDACHP,IDAMHP,
     +            IVHM,ISVHM,IDACHM,IDAMHM,IVMB,ISVMB,IDACMB,IDAMMB,
     +            IVME,ISVME,IDACME,IDAMME,IVMM,ISVMM,IDACMM,IDAMMM,
     +            IVFD,ISVFD,IDACFD,IDAMFD,IVDD,ISVDD,IDACDD,IDAMDD,
     +            IVOD,ISVOD,IDACOD,IDAMOD,IVOU,ISVOU,IDACOU,IDAMOU,
     +            IVOC,ISVOC,IDACOC,IDAMOC,IVTT,ISVTT,IDACTT,IDAMTT,
     +            IVTR,ISVTR,IDACTR,IDAMTR,IVFI,ISVFI,IDACFI,IDAMFI,
     +            IVON,ISVON,IDACON,IDAMON,IVJC,ISVJC,IDACJC,IDAMJC,
     +            IVSU,ISVSU,IDACSU,IDAMSU,IVOP,ISVOP,IDACOP,IDAMOP,
     +            IVDX,ISVDX,IDACDX,IDAMDX,IVSI,ISVSI,IDACSI,IDAMSI,
     +            IVCS,ISVCS,IDACCS,IDAMCS,IVLL,ISVLL,IDACLL,IDAMLL,
     +            IVLA,ISVLA,IDACLA,IDAMLA,IVBT,ISVBT,IDACBT,IDAMBT
      COMMON/CRVER/IVID,ISVID,IDACID,IDAMID,IVLM,ISVLM,IDACLM,IDAMLM,
     +            IVDC,ISVDC,IDACDC,IDAMDC,IVSW,ISVSW,IDACSW,IDAMSW,
     +            IVCU,ISVCU,IDACCU,IDAMCU,IVHI,ISVHI,IDACHI,IDAMHI,
     +            IVGC,ISVGC,IDACGC,IDAMGC,IVSQ,ISVSQ,IDACSQ,IDAMSQ,
     +            IVPX,ISVPX,IDACPX,IDAMPX,IVTE,ISVTE,IDACTE,IDAMTE,
     +            IVWW,ISVWW,IDACWW,IDAMWW
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence CRVER
*
************************************************************************
*
* IVXX      : Version for processor XX.
* ISVXX     : Sub-version for processor XX.
* IDACXX    : Date of library creation for processor XX.
* IDAMXX    : Date when cradle XX was last modified.
*
*******************************************************************
+SEQ,CRVER.
+DECK,RCHTOP.
+KEEP,RCHTOP.
      CHARACTER*4   CHTRCV,CHTRCJ,CHTRCZ,CHTRTB,CHTRPB,CHTREB,CHTRPE,
     +              CHTREE,CHTRHB,CHTRHE,CHTRHP,CHTRMB,CHTRME,CHTRFD,
     +              CHTRTR,CHTRTT,CHTRSC,CHTRFI,CHTRDX,CHTRSI,CHTRSW,
     +              CHTRRO,CHTRTE,
     +              CHTWCV,CHTWCJ,CHTWCZ,CHTWTB,CHTWPB,CHTWEB,CHTWPE,
     +              CHTWEE,CHTWHB,CHTWHE,CHTWHP,CHTWMB,CHTWME,CHTWFD,
     +              CHTWTR,CHTWTT,CHTWSC,CHTWFI,CHTWDX,CHTWSI,CHTWSW,
     +              CHTWRO,CHTWTE
      COMMON/RCHTOP/CHTRCV,CHTRCJ,CHTRCZ,CHTRTB,CHTRPB,CHTREB,CHTRPE,
     +              CHTREE,CHTRHB,CHTRHE,CHTRHP,CHTRMB,CHTRME,CHTRFD,
     +              CHTRTR,CHTRTT,CHTRSC,CHTRFI,CHTRDX,CHTRSI,CHTRSW,
     +              CHTRRO,CHTRTE,
     +              CHTWCV,CHTWCJ,CHTWCZ,CHTWTB,CHTWPB,CHTWEB,CHTWPE,
     +              CHTWEE,CHTWHB,CHTWHE,CHTWHP,CHTWMB,CHTWME,CHTWFD,
     +              CHTWTR,CHTWTT,CHTWSC,CHTWFI,CHTWDX,CHTWSI,CHTWSW,
     +              CHTWRO,CHTWTE
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence RCHTOP
*
************************************************************************
*
* CHTRXX    : Name of the top directory to read XX constants.
* CHTWXX    : Name of the top directory to write XX constants.
*
*******************************************************************
+SEQ,RCHTOP.
+DECK,MONITO.
+KEEP,MONITO.
      INTEGER       NRECO,MPROC,NSUMF
      REAL          TCPUG,TCPUP
      PARAMETER     (MPROC=29)
      COMMON/MONITO/TCPUG(3),TCPUP(MPROC),NRECO(MPROC),NSUMF
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence MONITO (only used for On-line monitoring)
*
************************************************************************
*
* MPROC     : Number of ROPE processors
* TCPUG     : CPU time spent for general tasks (All, FZIN ans FZOUT)
* TCPUP     : CPU time spent per processor
* NRECO     : Number of item reconstructed per processor (Track,bar,..)
* NSUMF     : Number of events accumulated before summary
*
*******************************************************************
+SEQ,MONITO.
+DECK,DECLARE.
+KEEP,DECLARE,IF=TYPE,IF=-CRAY.
      IMPLICIT NONE
+KEEP,DECLARE,IF=-TYPE,CRAY.
+DECK,RCLINE.
+KEEP,RCLINE.
      CHARACTER*132 CHLINE
      COMMON/RCLINE/CHLINE
+DECK,RCREP.
+KEEP,RCREP.
      CHARACTER*132 CHREP
      COMMON/RCREP/CHREP
+DECK,ROPAR.
+KEEP,ROPAR.
      INTEGER   IIDAT ,IIEXPT,IIRUN ,IIEVT ,IIBUN ,
     +          IIDETS,IITRGS,IITRWD,IITRWC,IITRWB,
     +          IITRWA,IIFITY,IIEVTY,IIEVT2,IIDATE,
     +          IITIME,IIPVER,IINCTR,IIECAL,IIHCAL,
     +          IINMUO,IINVTX,IIEBEA,IIFILL,IITAPE,
     +          IIRECI,IIPROD,IIRECO,IICDAT,IICTIM,
     +          IISULM,IIDAQS,IIFIDD,IIFIST,IIROST
      INTEGER   IITHRU,IICTHR,IIMEPX,IIMEPY,IIMEPZ,
     +          IINCT ,IISCT ,IINEB ,IISEB ,IINEE ,
     +          IISEE ,IINHT ,IISHT ,IINHPT,IISHPT,
     +          IISHS ,IISHPS,IISFE ,IISFK ,IIPRTA,
     +          IIPRTB,IIVERN,IIEVLG,IIDET1,IITRG1,
     +          IITRPU,IIPPSF,IIFXST
      INTEGER   IIPDSF,IIPDSR,IIPDSE,IIPDDF,IIPDDR,IIPDDE
      INTEGER   NLREV ,NSREV ,NDREV ,NIREV ,IOREV ,
     +          LLEX  ,LLUT  ,LLDA  ,LLCD  ,LLEC  ,
     +          LLHC  ,LLMU  ,LLFO  ,LLDD  ,LLOD
      INTEGER   NLEX  ,NSEX  ,NDEX  ,NIEX  ,IOEX  ,
     +          LLTRIG,LLMC  ,LLLEP ,
     +          IIFTRI,IIFMC ,IIFLEP
      INTEGER   NLUT  ,NSUT  ,NDUT  ,NIUT  ,IOUT  ,
     +          LLREHE
      INTEGER   NLDA  ,NSDA  ,NDDA  ,NIDA  ,IODA  ,
     +          LLCVRA,LLCJRA,LLCZRA,LLTBRA,LLPBRA,LLEBRA,LLPERA,
     +          LLEERA,LLHTRA,LLHSRA,LLHPRA,LLMBRA,LLMERA,LLFDRA,
     +          LLTRRA,LLTTRA,LLSCRA,LLFIRA,LLGNRA,LLSIRA,LLSWRA,
     +          LLTERA,
     +          IFCVRA,IFCJRA,IFCZRA,IFTBRA,IFPBRA,IFEBRA,IFPERA,
     +          IFEERA,IFHTRA,IFHSRA,IFHPRA,IFMBRA,IFMERA,IFFDRA,
     +          IFTRRA,IFTTRA,IFSCRA,IFFIRA,IFGNRA,IFSIRA,IFSWRA,
     +          IFTERA
      INTEGER   NLCD  ,NSCD  ,NDCD  ,NICD  ,IOCD  ,
     +          LLCV  ,LLCJ  ,LLCZ  ,LLCT  ,LLDX  ,LLCF  ,LLCX  ,
     +          LLSI  ,LLCS  ,
     +          IIFCV ,IIFCJ ,IIFCZ ,IIFCT ,IIFDX ,IIFCF ,IIFCX ,
     +          IIFSI ,IIFCS ,IIFCE ,IIFCA
      INTEGER   NLEC  ,NSEC  ,NDEC  ,NIEC  ,IOEC  ,
     +          LLTB  ,LLPB  ,LLEB  ,LLTE  ,LLPE  ,LLEE  ,LLEM ,
     +          IIFTB ,IIFPB ,IIFEB ,IIFTE ,IIFPE ,IIFEE ,IIFEM
      INTEGER   NLHC  ,NSHC  ,NDHC  ,NIHC  ,IOHC  ,
     +          LLHB  ,LLHE  ,LLHP  ,LLHM  ,
     +          IIFHB ,IIFHE ,IIFHP ,IIFHM
      INTEGER   NLMU  ,NSMU  ,NDMU  ,NIMU  ,IOMU  ,
     +          LLMB  ,LLME  ,LLMM  ,
     +          IIFMB ,IIFME ,IIFMM
      INTEGER   NLFO  ,NSFO  ,NDFO  ,NIFO  ,IOFO  ,
     +          LLFD  ,LLFDD ,LLSW  ,
     +          IIFFD ,IIFFDD,IIFSW
      INTEGER   NLOD  ,NSOD  ,NDOD  ,NIOD  ,IOOD  ,
     +          LLODGL,LLODCT,LLODPR,LLODEC,LLODUE,LLODHC,
     +          LLODMU,LLODFD,LLODVT,LLODAT,LLODUS,LLODSW,LLODTE
      PARAMETER(IIDAT =  1,IIEXPT=  2,IIRUN =  3,IIEVT =  4,IIBUN =  5,
     +          IIDETS=  6,IITRGS=  7,IITRWD=  8,IITRWC=  9,IITRWB= 10,
     +          IITRWA= 11,IIFITY= 12,IIEVTY= 13,IIEVT2= 14,IIDATE= 15,
     +          IITIME= 16,IIPVER= 17,IINCTR= 18,IIECAL= 19,IIHCAL= 20,
     +          IINMUO= 21,IINVTX= 22,IIEBEA= 23,IIFILL= 24,IITAPE= 25,
     +          IIRECI= 26,IIPROD= 27,IIRECO= 28,IICDAT= 29,IICTIM= 30,
     +          IISULM= 31,IIDAQS= 32,IIFIDD= 33,IIFIST= 34,IIROST= 35)
      PARAMETER(IITHRU= 36,IICTHR= 37,IIMEPX= 38,IIMEPY= 39,IIMEPZ= 40,
     +          IINCT = 41,IISCT = 42,IINEB = 43,IISEB = 44,IINEE = 45,
     +          IISEE = 46,IINHT = 47,IISHT = 48,IINHPT= 49,IISHPT= 50,
     +          IISHS = 51,IISHPS= 52,IISFE = 53,IISFK = 54,IIPRTA= 55,
     +          IIPRTB= 56,IIVERN= 57,IIEVLG= 58,IIDET1= 59,IITRG1= 60,
     +          IITRPU= 61,IIPDDF= 62,IIPPSF= 63,IIFXST= 64 )
      PARAMETER(IIPDSF= 59,IIPDSR= 60,IIPDSE= 61,IIPDDR= 63,
     +          IIPDDE= 64)
      PARAMETER(NLREV = 10,NSREV = 10,NDREV = 64,NIREV = 64,
     +          LLEX  =  1,LLUT  =  2,LLDA  =  3,LLCD  =  4,LLEC  =  5,
     +          LLHC  =  6,LLMU  =  7,LLFO  =  8,LLDD  =  9,LLOD  = 10)
      PARAMETER(NLEX  =  3,NSEX  =  3,NDEX  =  3,NIEX  =  3,IOEX  =  2,
     +          LLTRIG=  1,LLMC  =  2,LLLEP =  3,
     +          IIFTRI=  1,IIFMC =  2,IIFLEP=  3)
      PARAMETER(NLUT  =  1,NSUT  =  1,NDUT  =  0,NIUT  =  0,IOUT  =  2,
     +          LLREHE=  1)
      PARAMETER(NLDA  = 23,NSDA  = 23,NDDA  = 23,NIDA  = 23,IODA  =  2,
     +          LLCVRA=  1,LLCJRA=  2,LLCZRA=  3,LLTBRA=  4,LLPBRA=  5,
     +          LLEBRA=  6,LLPERA=  7,LLEERA=  8,LLHTRA=  9,LLHSRA= 10,
     +          LLHPRA= 11,LLMBRA= 12,LLMERA= 13,LLFDRA= 14,LLTRRA= 15,
     +          LLTTRA= 16,LLSCRA= 17,LLFIRA= 18,LLGNRA= 19,LLSIRA= 20,
     +          LLSWRA= 22,LLTERA= 23,
     +          IFCVRA=  1,IFCJRA=  2,IFCZRA=  3,IFTBRA=  4,IFPBRA=  5,
     +          IFEBRA=  6,IFPERA=  7,IFEERA=  8,IFHTRA=  9,IFHSRA= 10,
     +          IFHPRA= 11,IFMBRA= 12,IFMERA= 13,IFFDRA= 14,IFTRRA= 15,
     +          IFTTRA= 16,IFSCRA= 17,IFFIRA= 18,IFGNRA= 19,IFSIRA= 20,
     +          IFSWRA= 22,IFTERA= 23)
      PARAMETER(NLCD  =  9,NSCD  =  9,NDCD  = 11,NICD  = 11,IOCD  =  2,
     +          LLCV  =  1,LLCJ  =  2,LLCZ  =  3,LLCT  =  4,LLDX  =  5,
     +          LLCF  =  6,LLCX  =  7,LLSI  =  8,LLCS  =  9,
     +          IIFCV =  1,IIFCJ =  2,IIFCZ =  3,IIFCT =  4,IIFDX =  5,
     +          IIFCF =  6,IIFCX =  7,IIFSI =  8,IIFCS =  9,IIFCE = 10,
     +          IIFCA = 11)
      PARAMETER(NLEC  =  7,NSEC  =  7,NDEC  =  7,NIEC  =  7,IOEC  =  2,
     +          LLTB  =  1,LLPB  =  2,LLEB  =  3,LLPE  =  4,LLEE  =  5,
     +          LLEM  =  6,LLTE  =  7,
     +          IIFTB =  1,IIFPB =  2,IIFEB =  3,IIFPE =  4,IIFEE =  5,
     +          IIFEM =  6,IIFTE =  7)
      PARAMETER(NLHC  =  4,NSHC  =  4,NDHC  =  4,NIHC  =  4,IOHC  =  2,
     +          LLHB  =  1,LLHE  =  2,LLHP  =  3,LLHM  =  4,
     +          IIFHB =  1,IIFHE =  2,IIFHP =  3,IIFHM =  4)
      PARAMETER(NLMU  =  3,NSMU  =  3,NDMU  =  3,NIMU  =  3,IOMU  =  2,
     +          LLMB  =  1,LLME  =  2,LLMM  =  3,
     +          IIFMB =  1,IIFME =  2,IIFMM =  3)
      PARAMETER(NLFO  =  3,NSFO  =  3,NDFO  =  3,NIFO  =  3,IOFO  =  2,
     +          LLFD  =  1,LLFDD =  2,LLSW =  3,
     +          IIFFD =  1,IIFFDD=  2,IIFSW =  3)
      PARAMETER(NLOD  = 13,NSOD  = 13,NDOD  =  0,NIOD  =  0,IOOD  =  2,
     +          LLODGL=  1,LLODCT=  2,LLODPR=  3,LLODEC=  4,LLODUE=  5,
     +          LLODHC=  6,LLODMU=  7,LLODFD=  8,LLODVT=  9,LLODAT= 10,
     +          LLODUS= 11,LLODSW= 12,LLODTE= 13)
      COMMON/ROPAR/IOREV(2)
+SELF,IF=DOC,RODOC.
******************************************************************
*
*                  Sequence ROPAR
*
******************************************************************
*
*                  Offsets in the ROPE header record (IUHEAD).
* IIDAT : To data type       1 = OPAL experiment data
*                            2 = calibration event
*                            3 = test beam data
*                            4 = cosmic ray data
*                            5 = monte carlo data
*                            6 = DST or DDST
*                            7 = 'Junk' event
*                            add 1000 for start-of-run
*                            add 2000 for end-of-run
*                            105 is currently used for Calibration Cst.
* IIEXPT: To experiment number
* IIRUN : To run number
* IIEVT : To trigger number
* IIBUN : To bunch number
* IIDETS: To detector status word (Bit string)
* IITRGS: To trigger status word (Bit string)
* IITRWD: To trigger Bits   1 -  32
* IITRWC: To trigger Bits  33 -  64
* IITRWB: To trigger Bits  65 -  96
* IITRWA: To trigger Bits  97 - 128
* IIFITY: To filter type (Bit string)
* IIEVTY: To first Event Type word (ROPE, Bit string)
* IIEVT2: To second Event Type word (ROPE, Bit string)
* IIDATE: To date of event
* IITIME: To time of event
* IIPVER: To processing version number (ROPE)
* IINCTR: To number of CT tracks
* IIECAL: To total Electromagnetic Energy
* IIHCAL: To total Hadronic Energy
* IINMUO: To number of Muon Segments
* IINVTX: To number of Vertices
* IIEBEA: To nominal Beam Energy
* IIFILL: To fill number
* IITAPE: To original Raw data cartridge
* IIRECI: To record no. on original Raw data cartridge
* IIPROD: To pass1 ( DN10K ) PROD cartridge
* IIRECO: To record no. on pass1 PROD cartridge
* IICDAT: To date of last update of constants
* IICTIM: To time of last update of constants
* IISULM: To date of last update of SU (Status Update) routines
* IIDAQS: To data acquisition status word (Bit string)
* IIFIDD: To filter dense data status word (Bit string)
* IIFIST: To filter status word (Bit string)
* IIROST: To ROPE status word (Bit string), used in case of failure
* IITHRU: To thrust
* IICTHR: To cosine of the thrust axis
* IIMEPX: To x-component of missing energy vector
* IIMEPY: To y-component of missing energy vector
* IIMEPZ: To z-component of missing energy vector
* IINCT : To number of good charged tracks
* IISCT : To scalar sum of good charged track momenta
* IINEB : To number of good EB clusters
* IISEB : To sum of good EB cluster energy
* IINEE : To number of good EE clusters
* IISEE : To sum of good EE cluster energy
* IINHT : To number of good HT clusters    (HB+HE towers)
* IISHT : To sum of good HT cluster energy (HB+HE towers)
* IINHPT: To number of good HP tower clusters
* IISHPT: To sum of good HP tower cluster energy
* IISHS : To sum of HS cluster energy      (HB+HE strips)
* IISHPS: To sum of HP strip cluster energy
* IISFE : To sum of FD gamma catchers cluster energy
* IISFK : To sum of FD calorimeters cluster energy
* IIPRTA: To Pretrigger bits 1-32
* IIPRTA: To Pretrigger bits 32-64
* IIEVLG: To event length
* IIDET1: To detector status word (Bit string) 2nd word
* IITRG1: To trigger status word (Bit string) 2nd word
* IITRPU: To trigger pattern unit
* IIPDDF: miscelleneous Pretrigger information
* IIPPSF: Pretrigger Pam Scale Factors (two 16 bit words)
* IIFXST: Fixup Status word (so far TEFX only)
*
*                     Offsets in NHEADR (NANO dst)
* IIPDSF: To pointer to DST file (in NHEADR)
* IIPDSR: To pointer to event record in DST file
* IIPDSE: To pointer to event in record in DST file
* IIPDDR: To pointer to event record in DD file
* IIPDDE: To pointer to event in record in DD file
*
*                  Parameter for top event bank REV
* NLREV : Number of links
* NSREV : Number of structural links
* NDREV : Number of data words
* NIREV : Number of integer data words
* IOREV : Index of IO characteristic
*
*                  Offsets in the link part of REV
* LLEX  : To external data bank EX
* LLUT  : To general utility bank
* LLDA  : To raw data bank
* LLCD  : To central detector top bank CD
* LLEC  : To electro-magnetic calorimeter top bank EC
* LLHC  : To hadron calorimeter top bank HC
* LLMU  : To muon top bank
* LLFO  : To forward detector top bank
* LLDD  : To dense data top bank
* LLOD  : To "DST" bank
*
*                  Offsets in the data part of REV
* IIFILE: Same as offsets in header.
*
*                  Parameter for top external information bank EX
* NLEX  : Number of links
* NSEX  : Number of structural links
* NDEX  : Number of data words
* NIEX  : Number of integer data words
* IOEX  : Index of IO characteristic
*
*                  Offsets in the link part of EX
* LLTRIG: To trigger dependent data
* LLMC  : To GOPAL/GEANT data for MC events
* LLLEP : To machine dependent data
*
*                  Offsets in the data part of EX
* IIFTRI: To flag trigger dependent data
* IIFMC : To flag MC data
* IIFLEP: To flag machine dependent data
*
*                  Parameter for top utility  bank UT
* NLUT  : Number of links
* NSUT  : Number of structural links
* NDUT  : Number of data words
* NIUT  : Number of integer data words
* IOUT  : Index of IO characteristic
*
*                  Offsets in the link part of UT
* LLREHE: To REPORT tallied messages
*
*                  Parameter for top "Raw Data" bank DA
* NLDA  : Number of links
* NSDA  : Number of structural links
* NDDA  : Number of data words
* NIDA  : Number of integer data words
* IODA  : Index of IO characteristic
*
*                  Offsets in the link part of DA
* LLCVRA: To vertex detector raw data
* LLCJRA: To jet chamber raw data
* LLCZRA: To Z chamber raw data
* LLTBRA: To time-of-flight barrel raw data
* LLPBRA: To presampler barrel raw data
* LLEBRA: To barrel lead glass raw data
* LLPERA: To presampler end-cap raw data
* LLEERA: To end-cap lead glass raw data
* LLHTRA: To barrel hadron calorimeter raw data
* LLHSRA: To end-cap hadron calorimeter raw data
* LLHPRA: To poletip hadron calorimeter raw data
* LLMBRA: To barrel muon chamber raw data
* LLMERA: To end-cap muon chamber raw data
* LLFDRA: To forward detector raw data
* LLTRRA: To trigger data
* LLTTRA: To track trigger data
* LLSCRA: To slow control data
* LLFIRA: To filter data
* LLGNRA: To general data (not used)
* LLSIRA: To Silicon Microvertex data
* LLSWRA: To Silicon Tungsten data
* LLTERA: To Tile Endcap data
*
*                  Offsets in the data part of DA
* IFCVRA: To flag for CV raw data
* IFCJRA: To flag for CJ raw data
* IFCZRA: To flag for CZ raw data
* IFTBRA: To flag for TB raw data
* IFPBRA: To flag for PB raw data
* IFEBRA: To flag for EB raw data
* IFPERA: To flag for PE raw data
* IFEERA: To flag for EE raw data
* IFHTRA: To flag for HB raw data
* IFHSRA: To flag for HE raw data
* IFHPRA: To flag for HP raw data
* IFMBRA: To flag for MB raw data
* IFMERA: To flag for ME raw data
* IFFDRA: To flag for FD raw data
* IFTRRA: To flag for trigger data
* IFTTRA: To flag for track trigger data
* IFSCRA: To flag for slow control data
* IFFIRA: To flag for filter data
* IFGNRA: To flag for general data (not used)
* IFSIRA: To flag for Silicon Microvertex data
* IFSWRA: To flag for Silicon Tungsten data
* IFTERA: To flag for Tile Endcap data
*
*                  Parameter for top central detector bank CD
* NLCD  : Number of links
* NSCD  : Number of structural links
* NDCD  : Number of data words
* NICD  : Number of integer data words
* IOCD  : Index of IO characteristic
*
*                  Offsets in the link part of CD
* LLCV  : To vertex detector processing bank
* LLCJ  : To jet chamber processing bank
* LLCZ  : To Z chamber processing bank
* LLCT  : To central detectors merging bank
* LLDX  : To DEDX bank
* LLCF  : To "fake" track bank
* LLCX  : To vertex finding/fitting bank
* LLSI  : To Silicon Microvertex bank
* LLCS  : To CS bank
*
*                  Offsets in the data part of CD
* IIFCV : To flag for CV processing level
* IIFCJ : To flag for CJ processing level
* IIFCZ : To flag for CZ processing level
* IIFCT : To flag for CT processing level
* IIFDX : To flag for DX processing level
* IIFCF : To flag for CF processing level
* IIFCX : To flag for CX processing level
* IIFSI : To flag for SI processing level
* IIFCS : To flag for CS processing level
* IIFCE : To flag for CE processing level
* IIFCA : To flag for CA processing level
*
*                  Parameter for top electro-magnetic calorimeter bank E
* NLEC  : Number of links
* NSEC  : Number of structural links
* NDEC  : Number of data words
* NIEC  : Number of integer data words
* IOEC  : Index of IO characteristic
*
*                  Offsets in the link part of EC
* LLTB  : To time-of-flight barrel processing bank
* LLPB  : To presampler barrel processing bank
* LLEB  : To barrel lead glass processing bank
* LLPE  : To presampler end-cap processing bank
* LLEE  : To end-cap lead glass processing bank
* LLEM  : To E.M. cluster processing bank
* LLTE  : To Tile Endcap processing bank
*
*                  Offsets in the data part of EC
* IIFTB : To flag for TB processing level
* IIFPB : To flag for PB processing level
* IIFEB : To flag for EB processing level
* IIFPE : To flag for PE processing level
* IIFEE : To flag for EE processing level
* IIFEM : To flag for EM processing level
* IIFTE : To flag for TE processing level
*
*                  Parameter for top hadron calorimeter bank HC
* NLHC  : Number of links
* NSHC  : Number of structural links
* NDHC  : Number of data words
* NIHC  : Number of integer data words
* IOHC  : Index of IO characteristic
*
*                  Offsets in the link part of HC
* LLHB  : To barrel hadron calorimeter processing bank
* LLHE  : To end-cap hadron calorimeter processing bank
* LLHP  : To poletip hadron calorimeter processing bank
* LLHM  : To hadronic cluster processing bank
*
*                  Offsets in the data part of HC
* IIFHB : To flag for HB processing level
* IIFHE : To flag for HE processing level
* IIFHP : To flag for HP processing level
* IIFHM : To flag for HM processing level
*
*                  Parameter for top muon bank MU
* NLMU  : Number of links
* NSMU  : Number of structural links
* NDMU  : Number of data words
* NIMU  : Number of integer data words
* IOMU  : Index of IO characteristic
*
*                  Offsets in the link part of MU
* LLMB  : To barrel muon chamber processing bank
* LLME  : To end-cap muon chamber processing bank
* LLMM  : To muon segment processing bank
*
*                  Offsets in the data part of MU
* IIFMB : To flag for MB processing level
* IIFME : To flag for ME processing level
* IIFMM : To flag for MM processing level
*
*                  Parameter for top forward detector bank FO
* NLFO  : Number of links
* NSFO  : Number of structural links
* NDFO  : Number of data words
* NIFO  : Number of integer data words
* IOFO  : Index of IO characteristic
*
*                  Offsets in the link part of FO
* LLFD  : To forward detector header bank
* LLFDD : To forward detector dense data
* LLSW  : To Silicon Tungsten header bank
*
*                  Offsets in the data part of FO
* IIFFD : To flag for FD processing level
* IIFFDD: To flag for FD dense data
* IIFSW  : To flag for Silicon Tungsten processing level
*
*                  Parameter for "DST" bank OD
* NLOD  : Number of links
* NSOD  : Number of structurel links
* NDOD  : Number of data words
* NIOD  : Number of integer data words
* IOOD  : Index of IO characteristic
*
*                  Offsets in the link part of OD
* LLODGL: To the OD GNRL block
* LLODCT: To the OD CTRK block
* LLODPR: To the OD PRES block
* LLODEC: To the OD ECAL block
* LLODUE: To the OD TOF  block
* LLODHC: To the OD HCAL block
* LLODMU: To the OD MUON block
* LLODFD: To the OD FDET block
* LLODVT: To the OD VERT block
* LLODAT: To the OD ATRK block
* LLODUS: To the OD USER block
* LLODSW: To the OD SIW  block
* LLODTE: To the OD DTE  block
*
*                  Offsets in the data part of OD
* See sequence ODPAR
*******************************************************************
+SEQ ,ROPAR.
+DECK,CFPAR.
+KEEP,CFPAR.
      INTEGER   NLCF  ,NSCF  ,NDCF  ,NICF  ,IOCF  ,
     +          LLCFT ,LLCFX
      INTEGER                 NDCFT ,NICFT ,IOCFT ,
     +          ICFTNT,
     +          NLCFTS,NSCFTS,NDCFTS,NICFTS,IOCFTS,
     +          LLCFTX,LLCFTI,LLCFTE,
     +          ICFTTC,ICFTSC,ICFTFC,ICFTNH,ICFTNV,
     +          ICFTNJ,ICFTNZ,ICFTID,ICFTIK,ICFTNP,
     +          ICFTCU,ICFTPH,ICFTD0,ICFTTL,ICFTZ0,
     +          ICFTCR,ICFTCZ,ICFTC3,ICFTPX,ICFTPY,
     +          ICFTPZ,ICFTEE,ICFTPP,ICFTPT,ICFTQQ
      INTEGER   NLCFTX,NSCFTX,NDCFTX,NICFTX,IOCFTX,
     +          LRCFXO,LRCFXD,
     +          ICFTXO,ICFTXD,ICFTXX,ICFTXY,ICFTXZ,
     +          ICFTDX,ICFTDY,ICFTDZ
      INTEGER                 NDCFX ,NICFX ,IOCFX ,
     +          ICFXNV,
     +          NLCFXN,NSCFXN,NDCFXN,NICFXN,IOCFXN,
     +          LLCFXP,ICFXNN
      INTEGER   NLCFXP,NSCFXP,NDCFXP,NICFXP,IOCFXP,
     +          ICFXPX,ICFXPY,ICFXPZ,ICFXPE
      PARAMETER(NLCF  =  2,NSCF  =  2,NDCF  =  2,NICF  =  2,IOCF  =  2,
     +          LLCFT =  1,LLCFX =  2)
      PARAMETER(                      NDCFT =  1,NICFT =  1,IOCFT =  2,
     +          ICFTNT=  1,
     +          NLCFTS=  5,NSCFTS=  5,NDCFTS= 40,NICFTS= 10,
     +          LLCFTX=  3,LLCFTI=  4,LLCFTE=  5,
     +          ICFTTC=  1,ICFTSC=  2,ICFTFC=  3,ICFTNH=  4,ICFTNV=  5,
     +          ICFTNJ=  6,ICFTNZ=  7,ICFTID=  8,ICFTIK=  9,ICFTNP= 10,
     +          ICFTCU= 11,ICFTPH= 12,ICFTD0= 13,ICFTTL= 14,ICFTZ0= 15,
     +          ICFTCR= 31,ICFTCZ= 32,ICFTC3= 33,ICFTPX= 34,ICFTPY= 35,
     +          ICFTPZ= 36,ICFTEE= 37,ICFTPP= 38,ICFTPT= 39,ICFTQQ= 40)
      PARAMETER(NLCFTX=  2,NSCFTX=  0,NDCFTX=  8,NICFTX=  0,IOCFTX=  3,
     +          LRCFXO=  1,LRCFXD=  2,
     +          ICFTXO=  1,ICFTXD=  2,ICFTXX=  3,ICFTXY=  4,ICFTXZ=  5,
     +          ICFTDX=  6,ICFTDY=  7,ICFTDZ=  8)
      PARAMETER(                      NDCFX =  1,NICFX =  1,IOCFX =  2,
     +          ICFXNV=  1,
     +          NLCFXN=  1,NSCFXN=  1,NDCFXN=  1,NICFXN=  1,IOCFXN=  2,
     +          LLCFXP=  1,ICFXNN=  1)
      PARAMETER(NLCFXP=  0,NSCFXP=  0,NDCFXP=  9,NICFXP=  0,IOCFXP=  3,
     +          ICFXPX=  1,ICFXPY=  2,ICFXPZ=  3,ICFXPE=  4)
      COMMON/CFPAR/IOCFTS
+SELF,IF=DOC,RODOC.
******************************************************************
*
*                  Sequence CFPAR
*
******************************************************************
*
*                  Parameters for "Fake" top bank CF
* NLCF  : Number of links
* NSCF  : Number of structural links
* NDCF  : Number of data words
* NICF  : Number of integer data words
* IOCF  : IO characteristic
*
*                  Offsets in the link part of CF
* LLCFT : To track fake bank CFT
* LLCFX : To vertex fake bank CFX
*
*                  Parameters for "Fake" track bank CFT
*         Number of links = Number of tracks
* NDCFT : Number of data words = Number of tracks + NDCFT
* NICFT : Number of integer data words = Number of tracks + NDCFT
* IOCFT : IO characteristic
*
*                  Offsets in the data part of CFT
* ICFTNT: To number of tracks stored in structure CFT
*
*                  Parameters for bank CFTS pointed by LCFTS=LQ(LCFT-KT)
* NLCFTS: Number of links
* NSCFTS: Number of structural links
* NDCFTS: Number of data words
* NICFTS: Number of integer data words
* IOCFTS: IO characteristic
*
*                  Offsets in link part of CFTS
* LLCFTX: To track end points information
* LLCFTI: To track identification
* LLCFTE: To track extrapolation
*
*                  Offsets in data part of CFTS
* ICFTTC: To track code
* ICFTSC: To track subcode
* ICFTFC: To track fit code
* ICFTNH: To number of hits on track
* ICFTNV: To number of hits in CV
* ICFTNJ: To number of hits in CJ
* ICFTNZ: To number of hits in CZ
* ICFTID: To assumed particle type
* ICFTIK: To track number in KINE structure (Cheat word)
* ICFTNP: To number of track parameter
* ICFTCU: To track curvature
* ICFTPH: To PHI0 of track
* ICFTD0: To D0 of track
* ICFTTL: To TAN(LAMBDA) of track
* ICFTZ0: To Z0 of track
* ICFTCR: To CHI/deg. of freedom in R-PHI
* ICFTCZ: To CHI/deg. of freedom in S-Z
* ICFTC3: To CHI/deg. of freedom in 3D fit
* ICFTPX: To PX of track
* ICFTPZ: To PY of track
* ICFTPZ: To PZ of track
* ICFTEE: To Energy of track
* ICFTPP: To Ptot. of track
* ICFTPT: To Pt. of track
* ICFTQQ: To charge of track
*
*                  Parameters for bank CFTX
* NLCFTX: Number of links
* NSCFTX: Number of structural links
* NDCFTX: Number of data words
* NICFTX: Number of integer data words
* IOCFTX: IO characteristic
*
*                  Offsets in link part of CFTX
* LRCFXO: To origin vertex in CFX (Reference link)
* LRCFXD: To decay vertex in CFX (Reference link)
*
*                  Offsets in data part of CFTX
* ICFTXO: To sequential number of origin vertex in CFX
* ICFTXD: To sequential number og decay vertex in CFX
* ICFTXX: To X position of origin vertex
* ICFTXY: To Y position of origin vertex
* ICFTXZ: To Z position of origin vertex
* ICFTDX: To X position of decay vertex
* ICFTDY: To Y position of decay vertex
* ICFTDZ: To Z position of decay vertex
*
*                  Parameters for "Fake" vertex bank CFX
*         Number of links = Number of vertices
* NDCFX : Number of data words = Number of vertices + NDCFX
* NICFX : Number of integer data words = Number of vertices + NDCFX
* IOCFX : IO characteristic
*
*                  Offsets in the data part of CFX
* ICFXNV: To number of vertices stored in structure CFX
*
*                  Parameters for bank CFXN pointed by LCFXN=LQ(LCFX-KV)
* NLCFXN: Number of links
* NSCFXN: Number of structural links
* NDCFXN: Number of data words = Number of tracks from vertex + NDCFXN
* NICFXN: Number of integer data words = Number of tracks + NDCFXN
* IOCFXN: IO characteristic
*
*                  Offsets in link part of CFXN
* LLCFXP: To vertex parameters
*
*                  Offsets in data part of CFXN
* ICFXNN: To number of tracks from vertex
*
*                  Parameters for bank CFXP
* NLCFXP: Number of links
* NSCFXP: Number of structural links
* NDCFXP: Number of data words
* NICFXP: Number of integer data words
* IOCFXP: IO characteristic
*
*                  Offsets in data part of CFXP
* ICFXPX: To X position of vertex
* ICFXPY: To Y position of vertex
* ICFXPZ: To Z position of vertex
* ICFXPE: To position error matrix
*
*******************************************************************
+SEQ ,CFPAR.
+DECK,ROCPAR.
+KEEP,ROCPAR.
      INTEGER   NLRCO ,NSRCO ,NDRCO ,NIRCO ,IORCO ,
     +          LLEXC ,LLUTC ,LLDAC ,LLCDC ,LLECC ,
     +          LLHCC ,LLMUC ,LLFOC ,LLDDC ,LLODC ,
     +          IIFEXC,IIFUTC,IIFDAC,IIFCDC,IIFECC,
     +          IIFHCC,IIFMUC,IIFFOC,IIFDDC,IIFODC
      INTEGER   NLEXC ,NSEXC ,NDEXC ,NIEXC ,IOEXC ,
     +          LLTRIC,LLMCC ,LLLEPC,
     +          IIFTRC,IIFMCC,IIFLEC
      INTEGER   NLUTC ,NSUTC ,NDUTC ,NIUTC ,IOUTC ,
     +          LLREPO,LLGRHD,LLIOHD,LLSLCT,LLMSRN
      INTEGER   NLDAC ,NSDAC ,NDDAC ,NIDAC ,IODAC ,
     +          LLCVCT,LLCJCT,LLCZCT,LLTBCT,LLPBCT,LLEBCT,LLPECT,
     +          LLEECT,LLHTCT,LLHSCT,LLHPCT,LLMBCT,LLMECT,LLFDCT,
     +          LLTRCT,LLTTCT,LLSCCT,LLFICT,LLGNCT,LLSICT,LLDXCT,
     +          LLSWCT,LLTECT,
     +          IFCVCT,IFCJCT,IFCZCT,IFTBCT,IFPBCT,IFEBCT,IFPECT,
     +          IFEECT,IFHTCT,IFHSCT,IFHPCT,IFMBCT,IFMECT,IFFDCT,
     +          IFTRCT,IFTTCT,IFSCCT,IFFICT,IFGNCT,IFSICT,IFDXCT,
     +          IFSWCT,IFTECT
      INTEGER   NLCDC ,NSCDC ,NDCDC ,NICDC ,IOCDC ,
     +          LLCVC ,LLCJC ,LLCZC ,LLCTC ,LLDXC ,LLCFC ,LLCXC ,
     +          LLSIC ,LLCSC ,LLCEC ,LLCAC ,
     +          IIFCVC,IIFCJC,IIFCZC,IIFCTC,IIFDXC,IIFCFC,IIFCXC,
     +          IIFSIC,IIFCSC,IIFCEC,IIFCAC
      INTEGER   NLECC ,NSECC ,NDECC ,NIECC ,IOECC ,
     +          LLTBC ,LLPBC ,LLEBC ,LLPEC ,LLEEC ,LLEMC ,LLTEC,
     +          IIFTBC,IIFTEC,IIFPBC,IIFEBC,IIFPEC,IIFEEC,IIFEMC
      INTEGER   NLHCC ,NSHCC ,NDHCC ,NIHCC ,IOHCC ,
     +          LLHBC ,LLHEC ,LLHPC ,LLHMC ,
     +          IIFHBC,IIFHEC,IIFHPC,IIFHMC
      INTEGER   NLMUC ,NSMUC ,NDMUC ,NIMUC ,IOMUC ,
     +          LLMBC ,LLMECO,LLMMC ,
     +          IIFMBC,IIFMEC,IIFMMC
      INTEGER   NLFOC ,NSFOC ,NDFOC ,NIFOC ,IOFOC ,
     +          LLFDCR,LLFDCL,LLSWC,
     +          IIFFDC,IIFSWC
      INTEGER   NLODC ,NSODC ,NDODC ,NIODC ,IOODC ,
     +          LLODCB,
     +          IIFODG,IIFODT,IIFODP,IIFODE,IIFODU,IIFODH,
     +          IIFODM,IIFODF,IIFODV,IIFODA,IIFODX,IIFODW,
     +          IIFODD
      INTEGER   NLIOHD,NSIOHD,NDIOHD,NIIOHD,IOIOHD,
     +          LLIOII,LLIOCI,LLIODI,LLIODO,LLIODC,LLIOOV,
     +          LLIODS,LLIODD,LLIOCA,LLIOME,LLIOBK,LLIOHB,
     +          LLIODP,LLIODG,LLIOAO,LLIONO,LLIOMS,LLIOEO
      INTEGER   NLSLCT,NSSLCT,NDSLCT,NISLCT,IOSLCT,
     +          LLSLEV,LLSLRE,LLSLGE
      INTEGER   NLIOXX,NSIOXX,NDIOXX,NIIOXX,IOIOXX,
     +          JACTIV,JSELEC,JLUN  ,JLREC ,JFCHOP,
     +          JDCHOP,JFSTAT,JFNTYP,JACMOD,JFLAGS,
     +          JDEVIC,JFKEYS,JFNAME,JFJFIL
      INTEGER   NLSLEV,NSSLEV,NDSLEV,NISLEV,IOSLEV,
     +          JRUFST,JEVFST,JRULST,JEVLST
      INTEGER   NLSLRE,NSSLRE,NDSLRE,NISLRE,IOSLRE,
     +          IREFST,IRELST,IRESTP
      INTEGER   NLSLGE,NSSLGE,NDSLGE,NISLGE,IOSLGE,
     +          IRUGET,IEVGET
      INTEGER   NLGNCT,NSGNCT,NDGNCT,NIGNCT,IOGNCT,
     +          LLMAGF,LLBEAM,LLLIFE,LLBUTZ
      INTEGER   NLMAGF,NSMAGF,NDMAGF,NIMAGF,IOMAGF,
     +          IMEANB
      INTEGER   NLBEAM,NSBEAM,NDBEAM,NIBEAM,IOBEAM,
     +          IXBEAM,IYBEAM,IZBEAM,IDXBEA,IDYBEA,IDZBEA,
     +          IEXBEA,IEYBEA,IEZBEA
      INTEGER   NLBUTZ,NSBUTZ,NDBUTZ,NIBUTZ
      INTEGER   NLLIFE,NSLIFE,NDLIFE,NILIFE,IOLIFE
      PARAMETER(NLRCO = 10,NSRCO = 10,NDRCO = 10,NIRCO = 10,IORCO =  2,
     +          LLEXC =  1,LLUTC =  2,LLDAC =  3,LLCDC =  4,LLECC =  5,
     +          LLHCC =  6,LLMUC =  7,LLFOC =  8,LLDDC =  9,LLODC = 10,
     +          IIFEXC=  1,IIFUTC=  2,IIFDAC=  3,IIFCDC=  4,IIFECC=  5,
     +          IIFHCC=  6,IIFMUC=  7,IIFFOC=  8,IIFDDC=  9,IIFODC= 10)
      PARAMETER(NLEXC =  3,NSEXC =  3,NDEXC =  3,NIEXC =  3,IOEXC =  2,
     +          LLTRIC=  1,LLMCC =  2,LLLEPC=  3,
     +          IIFTRC=  1,IIFMCC=  2,IIFLEC=  3)
      PARAMETER(NLUTC =  5,NSUTC =  5,NDUTC =  0,NIUTC =  0,IOUTC =  0,
     +          LLREPO=  1,LLGRHD=  2,LLIOHD=  3,LLSLCT=  4,LLMSRN=  5)
      PARAMETER(NLDAC = 23,NSDAC = 23,NDDAC = 23,NIDAC = 23,IODAC =  2,
     +          LLCVCT=  1,LLCJCT=  2,LLCZCT=  3,LLTBCT=  4,LLPBCT=  5,
     +          LLEBCT=  6,LLPECT=  7,LLEECT=  8,LLHTCT=  9,LLHSCT= 10,
     +          LLHPCT= 11,LLMBCT= 12,LLMECT= 13,LLFDCT= 14,LLTRCT= 15,
     +          LLTTCT= 16,LLSCCT= 17,LLFICT= 18,LLGNCT= 19,LLSICT= 20,
     +          LLDXCT= 21,LLSWCT= 22,LLTECT= 23,
     +          IFCVCT=  1,IFCJCT=  2,IFCZCT=  3,IFTBCT=  4,IFPBCT=  5,
     +          IFEBCT=  6,IFPECT=  7,IFEECT=  8,IFHTCT=  9,IFHSCT= 10,
     +          IFHPCT= 11,IFMBCT= 12,IFMECT= 13,IFFDCT= 14,IFTRCT= 15,
     +          IFTTCT= 16,IFSCCT= 17,IFFICT= 18,IFGNCT= 19,IFSICT= 20,
     +          IFDXCT= 21,IFSWCT= 22,IFTECT= 23)
      PARAMETER(NLCDC = 11,NSCDC = 11,NDCDC = 11,NICDC = 11,IOCDC =  2,
     +          LLCVC =  1,LLCJC =  2,LLCZC =  3,LLCTC =  4,LLDXC =  5,
     +          LLCFC =  6,LLCXC =  7,LLSIC =  8,LLCSC =  9,LLCEC = 10,
     +          LLCAC = 11,
     +          IIFCVC=  1,IIFCJC=  2,IIFCZC=  3,IIFCTC=  4,IIFDXC=  5,
     +          IIFCFC=  6,IIFCXC=  7,IIFSIC=  8,IIFCSC=  9,IIFCEC= 10,
     +          IIFCAC= 11)
      PARAMETER(NLECC =  7,NSECC =  7,NDECC =  7,NIECC =  7,IOECC =  2,
     +          LLTBC =  1,LLPBC =  2,LLEBC =  3,LLPEC =  4,LLEEC =  5,
     +          LLEMC =  6,LLTEC =  7,
     +          IIFTBC=  1,IIFTEC=  2,IIFPBC=  3,IIFEBC=  4,IIFPEC=  5,
     +          IIFEEC=  6,IIFEMC=  7)
      PARAMETER(NLHCC =  4,NSHCC =  4,NDHCC =  4,NIHCC =  4,IOHCC =  2,
     +          LLHBC =  1,LLHEC =  2,LLHPC =  3,LLHMC =  4,
     +          IIFHBC=  1,IIFHEC=  2,IIFHPC=  3,IIFHMC=  4)
      PARAMETER(NLMUC =  3,NSMUC =  3,NDMUC =  3,NIMUC =  3,IOMUC =  2,
     +          LLMBC =  1,LLMECO=  2,LLMMC =  3,
     +          IIFMBC=  1,IIFMEC=  2,IIFMMC=  3)
      PARAMETER(NLFOC =  3,NSFOC =  3,NDFOC =  3,NIFOC =  3,IOFOC =  2,
     +          LLFDCR=  1,LLFDCL=  2,LLSWC =  3,
     +          IIFFDC=  1,           IIFSWC=  3)
      PARAMETER(NLODC =  1,NSODC =  1,NDODC = 13,NIODC = 13,IOODC =  2,
     +          LLODCB=  1,
     +          IIFODG=  1,IIFODT=  2,IIFODP=  3,IIFODE=  4,IIFODU= 5,
     +          IIFODH=  6,IIFODM=  7,IIFODF=  8,IIFODV=  9,IIFODA= 10,
     +          IIFODX= 11,IIFODW=12,IIFODD=13)
      INTEGER   LLIODT
      PARAMETER(NLIOHD= 19,NSIOHD= 19,NDIOHD=  0,NIIOHD=  0,IOIOHD=  2,
     +          LLIOII=  1,LLIOCI=  2,LLIODI=  3,LLIODO=  4,LLIODC=  5,
     +          LLIOOV=  6,LLIODS=  7,LLIODD=  8,LLIOCA=  9,LLIOME= 10,
     +          LLIOBK= 11,LLIOHB= 12,LLIODP= 13,LLIODG= 14,LLIOAO= 15,
     +          LLIONO= 16,LLIOMS= 17,LLIOEO= 18,LLIODT= 19)
      PARAMETER(NLSLCT=  3,NSSLCT=  3,NDSLCT=  0,NISLCT=  0,IOSLCT=  2,
     +          LLSLEV=  1,LLSLRE=  2,LLSLGE=  3)
      PARAMETER(NLIOXX=  0,NSIOXX=  0,NDIOXX= 42,NIIOXX= 42,IOIOXX=  2,
     +          JACTIV=  1,JSELEC=  2,JLUN  =  3,JLREC =  4,JFCHOP=  5,
     +          JDCHOP=  6,JFSTAT=  7,JFNTYP=  8,JACMOD=  9,JFLAGS= 10,
     +          JDEVIC= 11,JFKEYS= 12,JFNAME= 22,JFJFIL= 23)
      PARAMETER(NLSLEV=  0,NSSLEV=  0,NDSLEV=  4,NISLEV=  4,IOSLEV=  2,
     +          JRUFST=  1,JEVFST=  2,JRULST=  3,JEVLST=  4)
      PARAMETER(NLSLRE=  0,NSSLRE=  0,NDSLRE=  3,NISLRE=  3,IOSLRE=  2,
     +          IREFST=  1,IRELST=  2,IRESTP=  3)
      PARAMETER(NLSLGE=  0,NSSLGE=  0,NDSLGE=  2,NISLGE=  2,IOSLGE=  2,
     +          IRUGET=  1,IEVGET=  2)
      PARAMETER(NLGNCT=  4,NSGNCT=  4,NDGNCT=  0,NIGNCT=  0,IOGNCT=  2,
     +          LLMAGF=  1,LLBEAM=  2,LLLIFE=  3,LLBUTZ=  4)
      PARAMETER(NLMAGF=  0,NSMAGF=  0,NDMAGF=  1,NIMAGF=  0,IOMAGF=  3,
     +          IMEANB=  1)
      PARAMETER(NLBEAM=  0,NSBEAM=  0,NDBEAM=  9,NIBEAM=  0,IOBEAM=  3,
     +          IXBEAM=  1,IYBEAM=  2,IZBEAM=  3,
     +          IDXBEA=  4,IDYBEA=  5,IDZBEA=  6,
     +          IEXBEA=  7,IEYBEA=  8,IEZBEA=  9)
      PARAMETER(NLLIFE=  0,NSLIFE=  0,NDLIFE= 30,NILIFE=  0,IOLIFE=  3)
      PARAMETER(NLBUTZ=  0,NSBUTZ=  0,NDBUTZ= 66,NIBUTZ=  2)
+SELF,IF=DOC,RODOC.
******************************************************************
*
*                  Sequence ROCPAR
*
******************************************************************
*
*                  Parameter for top constants bank RCO
* NLRCO : Number of links
* NSRCO : Number of structural links
* NDRCO : Number of data words
* NIRCO : Number of integer data words
* IORCO : Index of IO characteristic
*
*                  Offsets in the link part of RCO
* LLEXC : To external constants bank EXC
* LLUTC : To general utility constants bank
* LLDAC : To calibration bank
* LLCDC : To central detector constants top bank CDC
* LLECC : To electro-magnetic calorimeter constants top bank ECC
* LLHCC : To hadron calorimeter constants top bank HCC
* LLMUC : To muon constants top bank
* LLFOC : To forward detector constants top bank
* LLDDC : To dense data constants top bank
* LLODC : To "DST" constants bank
* LLIODT: To Compression directory Input
*
*                  Offsets in the data part of RCO
* IIFEXC: To flag for external device data
* IIFUTC: To flag for general utility
* IIFDAC: To flag for calibration data
* IIFCDC: To flag for CD processing
* IIFECC: To flag for EC processing
* IIFHCC: To flag for HC processing
* IIFMUC: To flag for MU processing
* IIFFOC: To flag for FO processing
* IIFDDC: To flag for DD processing
* IIFODC: To flag for OD processing
*
*                  Parameter for top external information bank EXC
* NLEXC : Number of links
* NSEXC : Number of structural links
* NDEXC : Number of data words
* NIEXC : Number of integer data words
* IOEXC : Index of IO characteristic
*
*                  Offsets in the link part of EXC
* LLTRIC: To trigger dependent constants
* LLMCC : To GOPAL/GEANT constants for MC
* LLLEPC: To machine dependant constants
*
*                  Offsets in the data part of EXC
* IIFTRC: To flag trigger dependent constants
* IIFMCC: To flag MC constants
* IIFLEC: To flag machine dependent constants
*
*                  Parameter for top external utility bank UTC
* NLUTC : Number of links
* NSUTC : Number of structural links
* NDUTC : Number of data words
* NIUTC : Number of integer data words
* IOUTC : Index of IO characteristic
*
*                  Offsets in the link part of UTC
* LLREPO: To the REPORT header bank
* LLGRHD: To the Graphics header bank
* LLIOHD: To the IO header bank
* LLSLCT: To the Selection header bank
* LLMSRN: To the list of run and file number of available master NanoDst
*
*                  Parameter for top calibration bank DAC
* NLDAC : Number of links
* NSDAC : Number of structural links
* NDDAC : Number of data words
* NIDAC : Number of integer data words
* IODAC : Index of IO characteristic
*
*                  Offsets in the link part of DAC
* LLCVCT: To vertex detector calibration constants
* LLCJCT: To jet chamber calibration constants
* LLCZCT: To Z chamber calibration constants
* LLTBCT: To time-of-flight barrel calibration constants
* LLPBCT: To presampler barrel calibration constants
* LLEBCT: To barrel lead glass calibration constants
* LLPECT: To presampler end-cap calibration constants
* LLEECT: To end-cap lead glass calibration constants
* LLHTCT: To barrel hadron calorimeter calibration constants
* LLHSCT: To end-cap hadron calorimeter calibration constants
* LLHPCT: To poletip hadron calorimeter calibration constants
* LLMBCT: To barrel muon chamber calibration constants
* LLMECT: To end-cap muon chamber calibration constants
* LLFDCT: To forward detector calibration constants
* LLTRCT: To trigger constants
* LLTTCT: To track trigger constants
* LLSCCT: To slow control constants
* LLFICT: To filter constants
* LLGNCT: To general constants
* LLSICT: To Silicon Microvertex constants
* LLDXCT: To DeDx constants
* LLSWCT: To Silicon Tungsten constants
* LLTECT: To Tile Endcap constants
*
*                  Offsets in the data part of DAC
* IFCVCT: To flag for CV calibration constants
* IFCJCT: To flag for CJ calibration constants
* IFCZCT: To flag for CZ calibration constants
* IFTBCT: To flag for TB calibration constants
* IFPBCT: To flag for PB calibration constants
* IFEBCT: To flag for EB calibration constants
* IFPECT: To flag for PE calibration constants
* IFEECT: To flag for EE calibration constants
* IFHTCT: To flag for HB calibration constants
* IFHSCT: To flag for HE calibration constants
* IFHPCT: To flag for HP calibration constants
* IFMBCT: To flag for MB calibration constants
* IFMECT: To flag for ME calibration constants
* IFFDCT: To flag for FD calibration constants
* IFTRCT: To flag for trigger constants
* IFTTCT: To flag for track trigger constants
* IFSCCT: To flag for slow control constants
* IFFICT: To flag for filter constants
* IFGNCT: To flag for general constants
* IFSICT: To flag for Silicon Microvertex constants
* IFDXCT: To flag for DeDx constants
* IFSWCT: To flag for Silicon Tungsten constants
* IFTECT: To flag for TE constants
*
*                  Parameter for top central detector constants bank CDC
* NLCDC : Number of links
* NSCDC : Number of structural links
* NDCDC : Number of data words
* NICDC : Number of integer data words
* IOCDC : Index of IO characteristic
*
*                  Offsets in the link part of CDC
* LLCVC : To vertex detector constants bank
* LLCJC : To jet chamber constants bank
* LLCZC : To Z chamber constants bank
* LLCTC : To central detector merging constants bank
* LLDXC : To DEDX constants bank
* LLCFC : To "Fake track" constants bank
* LLCXC : To vertex finding/fitting constants bank
* LLSIC : To Silicon Microvertex constants bank
* LLCSC : To Silicon Microvertex merging constants bank
* LLCEC : To central extrapolation constants bank
* LLCAC : To central association constants bank
*
*                  Offsets in the data part of CDC
* IIFCVC: To flag for CV processing
* IIFCJC: To flag for CJ processing
* IIFCZC: To flag for CZ processing
* IIFCTC: To flag for CT processing
* IIFDXC: To flag for DX processing
* IIFCFC: To flag for "FAKE" processing
* IIFCXC: To flag for CX processing
* IIFSIC: To flag for SI processing
* IIFCSC: To flag for CS processing
* IIFCEC: To flag for CE processing
* IIFCAC: To flag for CA processing
*
*                  Parameter for electro-magnetic constants bank ECC
* NLECC : Number of links
* NSECC : Number of structural links
* NDECC : Number of data words
* NIECC : Number of integer data words
* IOECC : Index of IO characteristic
*
*                  Offsets in the link part of ECC
* LLTBC : To time-of-flight barrel constants bank
* LLPBC : To presampler barrel constants bank
* LLEBC : To barrel lead glass constants bank
* LLPEC : To presampler end-cap constants bank
* LLEEC : To end-cap lead glass constants bank
* LLEMC : To E.M. cluster constants bank
* LLTEC : To TE  constants bank
*
*                  Offsets in the data part of ECC
* IIFTBC: To flag for TB processing
* IIFPBC: To flag for PB processing
* IIFEBC: To flag for EB processing
* IIFPEC: To flag for PE processing
* IIFEEC: To flag for EE processing
* IIFEMC: To flag for EM processing
* IIFTEC: To flag for TE processing
*
*                  Parameter for hadron constants bank HCC
* NLHCC : Number of links
* NSHCC : Number of structural links
* NDHCC : Number of data words
* NIHCC : Number of integer data words
* IOHCC : Index of IO characteristic
*
*                  Offsets in the link part of HCC
* LLHBC : To barrel hadron calorimeter constants bank
* LLHEC : To end-cap hadron calorimeter constants bank
* LLHPC : To poletip hadron calorimeter constants bank
* LLHMC : To hadronic cluster constants bank
*
*                  Offsets in the data part of HCC
* IIFHBC: To flag for HB processing
* IIFHEC: To flag for HE processing
* IIFHPC: To flag for HP processing
* IIFHMC: To flag for HM processing
*
*                  Parameter for top muon constants bank MUC
* NLMUC : Number of links
* NSMUC : Number of structural links
* NDMUC : Number of data words
* NIMUC : Number of integer data words
* IOMUC : Index of IO characteristic
*
*                  Offsets in the link part of MUC
* LLMBC : To barrel muon chamber constants bank
* LLMECO: To end-cap muon chamber constants bank
* LLMMC : To muon segment constants bank
*
*                  Offsets in the data part of MUC
* IIFMBC: To flag for MB processing
* IIFMEC: To flag for ME processing
* IIFMMC: To flag for MM processing
*
*                  Parameter for top forward detector constants bank FOC
* NLFOC : Number of links
* NSFOC : Number of structural links
* NDFOC : Number of data words
* NIFOC : Number of integer data words
* IOFOC : Index of IO characteristic
*
*                  Offsets in the link part of FOC
* LLFDCR: To right forward detector constants bank
* LLFDCL: To left forward detector constants bank
* LLSWC : To Silicon Tungsten constants
*
*                  Offsets in the data part of FOC
* IIFFDC: To flag for FD processing
* IIFSWC: To flag for Silicon Tungsten processing
*
*                  Parameter for "DST" constants bank ODC
* NLODC : Number of links
* NSODC : Number of structural links
* NDODC : Number of data words
* NIODC : Number of integer data words
* IOODC : Index of IO characteristic
*
*                  Offsets in the link part of ODC
* LLODCB: To USER OD Common Block definition
*
*                  Offsets in the data part of ODC
* IIFODG: To flag to build the OD GNRL Block
* IIFODT: To flag to build the OD CTRK Block
* IIFODP: To flag to build the OD PRES Block
* IIFODE: To flag to build the OD ECAL Block
* IIFODM: To flag to build the OD Unsplit ecal cluster block
* IIFODH: To flag to build the OD HCAL Block
* IIFODM: To flag to build the OD MUON Block
* IIFODM: To flag to build the OD MUON Block
* IIFODV: To flag to build the OD VERT Block
* IIFODA: To flag to build the OD ATRK Block
* IIFODU: To flag to build the OD USER Block
* IIFODW: To flag to build the OD SIW  Block
* IIFODD: To flag to build the OD DTE  Block
*
*                  Parameter for IO header bank IOHD
* NLIOHD: Number of links
* NSIOHD: Number of structural links
* NDIOHD: Number of data words
* NIIOHD: Number of integer data words
* IOIOHD: Index of IO characteristic
*
*                  Offsets in the link part of IOHD
* LLIOII: To INIT input bank
* LLIOCI: To Constant input bank
* LLIODI: To Data Input bank
* LLIODO: To Data Output bank
* LLIODC: To Data Copy bank
* LLIOOV: To Overflow Output bank
* LLIODS: To DST Output bank
* LLIODD: To DDST Output bank
* LLIOCA: To Calibration bank
* LLIOME: To Metafile Output bank
* LLIOBK: To RZ Bank Documentation Input bank
* LLIOHB: To RZ Histo Output bank
* LLIODP: To Data Production (Raw data + DST) Output bank
* LLIODG: To Scan file (Bank for GROPE) Output bank
* LLIOAO: To Direct Access to Data List output bank
* LLIONO: To Output nanodst output bank
* LLIOMS: To New/Update Master-nanodst bank
* LLIOEO: To Output Event list bank
*
*                  Parameter for Selection header bank SLCT
* NLSLHD: Number of links
* NSSLHD: Number of structural links
* NDSLHD: Number of data words
* NISLHD: Number of integer data words
* IOSLHD: Index of IO characteristic
*
*                  Offsets in the link part of SLCT
* LLSLEV: To selection bank through RUN and EVENT no.(*EVENT)
* LLSLRE: To selection bank through Read no.(*READ)
* LLSLGE: To selection bank through RUN and EVENT no.(*GET)
*
*                  Parameter for IOXX banks (XX=II,CI,GR,DO.....,HB)
* NLIOXX: Number of links
* NSIOXX: Number of structural links
* NDIOXX: Number of data words
* NIIOXX: Number of integer data words
* IOIOXX: Index of IO characteristic
*
*                  Offsets in the data part of IOXX
* JACTIV: Offset to the activation flag
* JSELEC: Offset to the selection flag
* JLUN  : Offset to the logical unit number
* JLREC : Offset to the record length
* JFCHOP: Offset to the FZFILE file option
* JDCHOP: Offset to the FZOUT output option
* JFSTAT: Offset to the FORTRAN File STATus. (NEW or OLD)
* JFNTYP: Offset to the File Name TYPe:
*         0 --> no name given
*         1 --> a file name was given
*         2 --> it is a FATMEN entry
* JFNAME: Offset to the File Name.
* JFJFIL: Offset to index of the file in the catalog.
*
*                  Parameter for Selection header bank SLEV
* NLSLEV: Number of links
* NSSLEV: Number of structural links
* NDSLEV: Number of data words
* NISLEV: Number of integer data words
* IOSLEV: Index of IO characteristic
*
*                  Offsets in the data part of SLEV
* JRUFST: Offset to First Run selected
* JEVFST: Offset to First Event selected
* JRULST: Offset to Last Run selected
* JEVLST: Offset to Last Event selected
*
*                  Parameter for Selection header bank SLRE
* NLSLRE: Number of links
* NSSLRE: Number of structural links
* NDSLRE: Number of data words
* NISLRE: Number of integer data words
* IOSLRE: Index of IO characteristic
*
*                  Offsets in the data part of SLRE
* IREFST: Offset to First Event to read
* IRELST: Offset to Last Event to read
* IRESTP: Offset to Step in event reading
*
*                  Parameter for Selection header bank SLGE
* NLSLGE: Number of links
* NSSLGE: Number of structural links
* NDSLGE: Number of data words
* NISLGE: Number of integer data words
* IOSLGE: Index of IO characteristic
*
*                  Offsets in the data part of SLGE
* IRUGET: Offset to Run selected
* IEVGET: Offset to Event selected
*
*                  Parameter for general constant bank GNCT
* NLGNCT: Number of links
* NSGNCT: Number of structural links
* NDGNCT: Number of data words
* NIGNCT: Number of integer data words
* IOGNCT: Index of IO characteristic
*
*                  Offsets in the link part of GNCT
* LLMAGF: To magnetic field bank
* LLBEAM: To beam position bank
* LLLIFE: To lifetime bank
* LLBUTZ: To bunch T-Zero bank
*
*                  Parameter for the magnetic field bank MAGF
* NLMAGF: Number of links
* NSMAGF: Number of structural links
* NDMAGF: Number of data words
* NIMAGF: Number of integer data words
* IOMAGF: Index of IO characteristic
*
*                  Offsets in the data part of MAGF
* IMEANB: Offset to mean magnetic field  (in kG)
*
*                  Parameter for beam position bank BEAM
* NLBEAM: Number of links
* NSBEAM: Number of structural links
* NDBEAM: Number of data words
* NIBEAM: Number of integer data words
* IOBEAM: Index of IO characteristic
*
*                  Offsets in the data part of BEAM
* IXBEAM: Mean X position of beam crossing point
* IYBEAM: Mean Y position of beam crossing point
* IZBEAM: Mean Z position of beam crossing point
* IDXBEA: LEP intrinsic X extention of beam crossing point
* IDYBEA: LEP intrinsic Y extention of beam crossing point
* IDZBEA: LEP intrinsic Z extention of beam crossing point
* IEXBEA: Error of mean X position of beam crossing point
* IEYBEA: Error of mean Y position of beam crossing point
* IEZBEA: Error of mean Z position of beam crossing point
*
*                  Parameter for the lifetime bank LIFE
* NLLIFE: Number of links
* NSLIFE: Number of structural links
* NDLIFE: Number of data words
* NILIFE: Number of integer data words
* IOLIFE: Index of IO characteristic
*
*                  Parameter for the bunch T-Zero bank BUTZ
* NLBUTZ: Number of links
* NSBUTZ: Number of structural links
* NDBUTZ: Number of data words
* NIBUTZ: Number of integer data words
*
*******************************************************************
+SEQ ,ROCPAR.
      END
+DECK,RODPAR.
+KEEP,RODPAR.
      INTEGER    IIDCV,     IIDCJ,     IIDCZ,     IIDTB,     IIDPB,
     +           IIDEB,     IIDPE,     IIDEE,     IIDHT,     IIDHS,
     +           IIDHP,     IIDMB,     IIDME,     IIDFD,     IIDSI,
     +           IIDSW,
     +           IIDTE
*
      PARAMETER (IIDCV = 0, IIDCJ = 2, IIDCZ = 4, IIDTB = 6, IIDPB = 8,
     +           IIDEB =10, IIDPE =12, IIDEE =14, IIDHT =16, IIDHS =18,
     +           IIDHP =20, IIDMB =22, IIDME =24, IIDFD =26, IIDSI =28,
     +           IIDSW =30,
     +           IIDTE =32)
*
+SELF,IF=DOC,RODOC.
******************************************************************
*
*                  Sequence RODPAR
*
******************************************************************
*
*  Pointers to bits in the status words in the event header
*
* The status words in the event header for detector, IUHEAD(IIDETS),
* and trigger, IUHEAD(IITRGS), each consist of a bit string with two
* adjacent bits assigned to each subdetector.
* With the introduction of TE a second word is needed IIDET1, IITRG1
* The pointers in RODPAR give the number of bits to offset in the words
* to point to the first bit associated with the each subdetector.
* So the bits IIDCJ and IIDCJ+1 contain the CJ status, for example.
* For the meaning of the status values see the ROPE documentation.
*
*******************************************************************
+SEQ ,RODPAR.
      END
+DECK,ROSPAR.
+KEEP,ROSPAR.
      INTEGER   NLRST ,NSRST ,NDRST ,NIRST ,IORST ,
     +          LLEXS ,LLUTS ,LLDAS ,LLCDS ,LLECS ,
     +          LLHCS ,LLMUS ,LLFOS ,LLDDS ,LLODS ,
     +          IIFEXS,IIFUTS,IIFDAS,IIFCDS,IIFECS,
     +          IIFHCS,IIFMUS,IIFFOS,IIFADS,IIFODS
      INTEGER   NLEXS ,NSEXS ,NDEXS ,NIEXS ,IOEXS ,
     +          LLTRIS,LLMCS ,LLLEPS,
     +          IIFTRS,IIFMCS,IIFLES
      INTEGER   NLUTS ,NSUTS ,NDUTS ,NIUTS ,IOUTS ,
     +          LLRSMS
      INTEGER   NLDAS ,NSDAS ,NDDAS ,NIDAS ,IODAS ,
     +          LLCVDS,LLCJDS,LLCZDS,LLTBDS,LLPBDS,LLEBDS,LLPEDS,
     +          LLEEDS,LLHTDS,LLHSDT,LLHPDS,LLMBDS,LLMEDS,LLFDDS,
     +          LLTRDS,LLTTDS,LLSCDS,LLFIDS,LLGNDS,LLSIDS,LLSWDS,
     +          LLTEDS,
     +          IFCVDS,IFCJDS,IFCZDS,IFTBDS,IFPBDS,IFEBDS,IFPEDS,
     +          IFEEDS,IFHTDS,IFHSDT,IFHPDS,IFMBDS,IFMEDS,IFFDDS,
     +          IFTRDS,IFTTDS,IFSCDS,IFFIDS,IFGNDS,IFSIDS,IFSWDS,
     +          IFDXDS,IFTEDS
      INTEGER   NLCDS ,NSCDS ,NDCDS ,NICDS ,IOCDS ,
     +          LLCVS ,LLCJS ,LLCZS ,LLCTS ,LLDXS ,LLCFS ,LLCXS ,
     +          LLSIS ,LLCSS ,LLCES ,LLCAS ,
     +          IIFCVS,IIFCJS,IIFCZS,IIFCTS,IIFDXS,IIFCFS,IIFCXS,
     +          IIFSIS,IIFCSS,IIFCES,IIFCAS
      INTEGER   NLECS ,NSECS ,NDECS ,NIECS ,IOECS ,
     +          LLTBS ,LLPBS ,LLEBS ,LLPES ,LLEES ,LLEMS ,LLTES ,
     +          IIFTBS,IIFPBS,IIFEBS,IIFPES,IIFEES,IIFEMS,IIFTES
      INTEGER   NLHCS ,NSHCS ,NDHCS ,NIHCS ,IOHCS ,
     +          LLHBS ,LLHES ,LLHPS ,LLHMS ,
     +          IIFHBS,IIFHES,IIFHPS,IIFHMS
      INTEGER   NLMUS ,NSMUS ,NDMUS ,NIMUS ,IOMUS ,
     +          LLMBS ,LLMES ,LLMMS ,
     +          IIFMBS,IIFMES,IIFMMS
      INTEGER   NLFOS ,NSFOS ,NDFOS ,NIFOS ,IOFOS ,
     +          LLFDSR,LLFDSL,LLSWS ,
     +          IIFFDS,       IIFSWS
      INTEGER   NLODS ,NSODS ,NDODS ,NIODS ,IOODS
      INTEGER   NLRSMS,NSRSMS,NDRSMS,NIRSMS,IORSMS,
     +          LLRTIS,LLRSPS,LLRTI2,LLRSP2
      INTEGER   NLRTIS,NSRTIS,NDRTIS,NIRTIS,IORTIS
      INTEGER   NLRSPS,NSRSPS,NDRSPS,NIRSPS,IORSPS
      INTEGER   NLRTI2,NSRTI2,NDRTI2,NIRTI2,IORTI2
      INTEGER   NLRSP2,NSRSP2,NDRSP2,NIRSP2,IORSP2
      PARAMETER(NLRST = 10,NSRST = 10,NDRST = 10,NIRST = 10,IORST =  2,
     +          LLEXS =  1,LLUTS =  2,LLDAS =  3,LLCDS =  4,LLECS =  5,
     +          LLHCS =  6,LLMUS =  7,LLFOS =  8,LLDDS =  9,LLODS = 10,
     +          IIFEXS=  1,IIFUTS=  2,IIFDAS=  3,IIFCDS=  4,IIFECS=  5,
     +          IIFHCS=  6,IIFMUS=  7,IIFFOS=  8,IIFADS=  9,IIFODS= 10)
      PARAMETER(NLEXS =  3,NSEXS =  3,NDEXS =  3,NIEXS =  3,IOEXS =  2,
     +          LLTRIS=  1,LLMCS =  2,LLLEPS=  3,
     +          IIFTRS=  1,IIFMCS=  2,IIFLES=  3)
      PARAMETER(NLUTS =  1,NSUTS =  1,NDUTS =  0,NIUTS =  0,IOUTS =  2,
     +          LLRSMS=  1)
      PARAMETER(NLDAS = 23,NSDAS = 23,NDDAS = 23,NIDAS = 23,IODAS =  2,
     +          LLCVDS=  1,LLCJDS=  2,LLCZDS=  3,LLTBDS=  4,LLPBDS=  5,
     +          LLEBDS=  6,LLPEDS=  7,LLEEDS=  8,LLHTDS=  9,LLHSDT= 10,
     +          LLHPDS= 11,LLMBDS= 12,LLMEDS= 13,LLFDDS= 14,LLTRDS= 15,
     +          LLTTDS= 16,LLSCDS= 17,LLFIDS= 18,LLGNDS= 19,LLSIDS= 20,
     +          LLSWDS= 22,LLTEDS= 23,
     +          IFCVDS=  1,IFCJDS=  2,IFCZDS=  3,IFTBDS=  4,IFPBDS=  5,
     +          IFEBDS=  6,IFPEDS=  7,IFEEDS=  8,IFHTDS=  9,IFHSDT= 10,
     +          IFHPDS= 11,IFMBDS= 12,IFMEDS= 13,IFFDDS= 14,IFTRDS= 15,
     +          IFTTDS= 16,IFSCDS= 17,IFFIDS= 18,IFGNDS= 19,IFSIDS= 20,
     +          IFDXDS= 21,IFSWDS= 22,IFTEDS= 23)
      PARAMETER(NLCDS = 11,NSCDS = 11,NDCDS = 11,NICDS = 11,IOCDS =  2,
     +          LLCVS =  1,LLCJS =  2,LLCZS =  3,LLCTS =  4,LLDXS =  5,
     +          LLCFS =  6,LLCXS =  7,LLSIS =  8,LLCSS =  9,LLCES = 10,
     +          LLCAS =  8,
     +          IIFCVS=  1,IIFCJS=  2,IIFCZS=  3,IIFCTS=  4,IIFDXS=  5,
     +          IIFCFS=  6,IIFCXS=  7,IIFSIS=  8,IIFCSS=  9,IIFCES= 10,
     +          IIFCAS= 11)
      PARAMETER(NLECS =  7,NSECS =  7,NDECS =  7,NIECS =  7,IOECS =  2,
     +          LLTBS =  1,LLPBS =  2,LLEBS =  3,LLPES =  4,LLEES =  5,
     +          LLEMS =  6,LLTES =  7,
     +          IIFTBS=  1,IIFPBS=  2,IIFEBS=  3,IIFPES=  4,IIFEES=  5,
     +          IIFEMS=  6,IIFTES=  7)
      PARAMETER(NLHCS =  4,NSHCS =  4,NDHCS =  4,NIHCS =  4,IOHCS =  2,
     +          LLHBS =  1,LLHES =  2,LLHPS =  3,LLHMS =  4,
     +          IIFHBS=  1,IIFHES=  2,IIFHPS=  3,IIFHMS=  4)
      PARAMETER(NLMUS =  3,NSMUS =  3,NDMUS =  3,NIMUS =  3,IOMUS =  2,
     +          LLMBS =  1,LLMES =  2,LLMMS =  3,
     +          IIFMBS=  1,IIFMES=  2,IIFMMS=  3)
      PARAMETER(NLFOS =  3,NSFOS =  3,NDFOS =  3,NIFOS =  3,IOFOS =  2,
     +          LLFDSR=  1,LLFDSL=  2,LLSWS =  3,
     +          IIFFDS=  1           ,IIFSWS=  3)
      PARAMETER(NLODS =  1,NSODS =  1,NDODS =  1,NIODS =  1,IOODS =  2)
      PARAMETER(NLRSMS=  4,NSRSMS=  4,NDRSMS= 31,NIRSMS= 31,IORSMS=  2,
     +          LLRTIS=  1,LLRSPS=  2,LLRTI2=  3,LLRSP2=  4)
      PARAMETER(NLRTIS=  0,NSRTIS=  0,NDRTIS= 31,NIRTIS= 31,IORTIS=  3)
      PARAMETER(NLRSPS=  0,NSRSPS=  0,NDRSPS= 31,NIRSPS= 31,IORSPS=  3)
      PARAMETER(NLRTI2=  0,NSRTI2=  0,NDRTI2= 31,NIRTI2= 31,IORTI2=  3)
      PARAMETER(NLRSP2=  0,NSRSP2=  0,NDRSP2= 31,NIRSP2= 31,IORSP2=  3)
+SELF,IF=DOC,RODOC.
******************************************************************
*
*                  Sequence ROSPAR
*
******************************************************************
*
*                  Parameter for top statistics bank RST
* NLRST : Number of links
* NSRST : Number of structural links
* NDRST : Number of data words
* NIRST : Number of integer data words
* IORST : Index of IO characteristic
*
*                  Offsets in the link part of RST
* LLEXS : To external statistics bank EXS
* LLUTS : To general utility statistics bank
* LLDAS : To data statistics bank
* LLCDS : To central detector statistics top bank CDS
* LLECS : To electro-magnetic calorimeter statistics top bank ECS
* LLHCS : To hadron calorimeter statistics top bank HCS
* LLMUS : To muon statistics top bank
* LLFOS : To forward detector statistics top bank
* LLDDS : To dense data statistics top bank
* LLODS : To "DST" statistics bank
*
*                  Offsets in the data part of RST
* IIFEXS: To flag for external device statistics
* IIFUTS: To flag for general utility statistics
* IIFDAS: To flag for data statistics
* IIFCDS: To flag for CD statistics
* IIFECS: To flag for ES statistics
* IIFHCS: To flag for HS statistics
* IIFMUS: To flag for MU statistics
* IIFFOS: To flag for FO statistics
* IIFADS: To flag for AD statistics (obsolete)
* IIFODS: To flag for OD statistics
*
*                  Parameter for top external statistics bank EXS
* NLEXS : Number of links
* NSEXS : Number of structural links
* NDEXS : Number of data words
* NIEXS : Number of integer data words
* IOEXS : Index of IO characteristic
*
*                  Offsets in the link part of EXS
* LLTRIS: To trigger dependant statistics
* LLMCS : To GOPAL/GEANT statistics for MC
* LLLEPS: To machine dependant statistics
*
*                  Offsets in the data part of EXS
* IIFTRS: To flag trigger dependent statistics
* IIFMCS: To flag MC statistics
* IIFLES: To flag machine dependent statistics
*
*                  Parameter for top utility statistics bank UTS
* NLUTS : Number of links
* NSUTS : Number of structural links
* NDUTS : Number of data words
* NIUTS : Number of integer data words
* IOUTS : Index of IO characteristic
*
*                  Offsets in the link part of UTS
* LLRSMS: To ROPE summary bank
*
*                  Parameter for top data statistics bank DAS
* NLDAS : Number of links
* NSDAS : Number of structural links
* NDDAS : Number of data words
* NIDAS : Number of integer data words
* IODAS : Index of IO characteristic
*
*                  Offsets in the link part of DAS
* LLCVDS: To vertex detector data statistics
* LLCJDS: To jet chamber data statistics
* LLCZDS: To Z chamber data statistics
* LLTBDS: To time-of-flight barrel data statistics
* LLPBDS: To presampler barrel data statistics
* LLEBDS: To barrel lead glass data statistics
* LLPEDS: To presampler end-cap data statistics
* LLEEDS: To end-cap lead glass data statistics
* LLHTDS: To barrel hadron calorimeter data statistics
* LLHSDT: To end-cap hadron calorimeter data statistics
* LLHPDS: To poletip hadron calorimeter data statistics
* LLMBDS: To barrel muon chamber data statistics
* LLMEDS: To end-cap muon chamber data statistics
* LLFDDS: To forward detector data statistics
* LLTRDS: To trigger data statistics
* LLTTDS: To track trigger data statistics
* LLSCDS: To slow control data statistics
* LLFIDS: To filter data statistics
* LLGNDS: To general data statistics (not used)
* LLSIDS: To Silicon Microvertex data statistics
* LLSWDS: To SW data statistics
* LLTEDS: To TE data statistics
*
*                  Offsets in the data part of DAS
* IFCVDS: To flag for CV data statistics
* IFCJDS: To flag for CJ data statistics
* IFCZDS: To flag for CZ data statistics
* IFTBDS: To flag for TB data statistics
* IFPBDS: To flag for PB data statistics
* IFEBDS: To flag for EB data statistics
* IFPEDS: To flag for PE data statistics
* IFEEDS: To flag for EE data statistics
* IFHTDS: To flag for HB data statistics
* IFHSDT: To flag for HE data statistics
* IFHPDS: To flag for HP data statistics
* IFMBDS: To flag for MB data statistics
* IFMEDS: To flag for ME data statistics
* IFMEFD: To flag for FD data statistics
* IFTRDS: To flag for trigger data statistics
* IFTTDS: To flag for track trigger data statistics
* IFSCDS: To flag for slow control data statistics
* IFFIDS: To flag for filter data statistics
* IFGNDS: To flag for general data statistics (not used)
* IFSIDS: To flag for Silicon Microvertex data statistics
* IFSWDS: To flag for SW data statistics
* IFTEDS: To flag for TE data statistics
*
*                  Parameter for top central detector statistics bank CD
* NLCDS : Number of links
* NSCDS : Number of structural links
* NDCDS : Number of data words
* NICDS : Number of integer data words
* IOCDS : Index of IO characteristic
*
*                  Offsets in the link part of CDS
* LLCVS : To vertex detector statistics bank
* LLCJS : To jet chamber statistics bank
* LLCZS : To Z chamber statistics bank
* LLCTS : To central detector merging statistics bank
* LLDXS : To DEDX statistics bank
* LLCFS : To "fake" statistics bank
* LLCXS : To vertex finding/fitting statistics bank
* LLSIS : To Silicon Microvertex statistics bank
* LLCSS : To Silicon Microvertex merging statistics bank
* LLCES : To central extrapolation statistics bank
* LLCAS : To central extrapolation statistics bank
*
*                  Offsets in the data part of CDS
* IIFCVS: To flag for CV statistics
* IIFCJS: To flag for CJ statistics
* IIFCZS: To flag for CZ statistics
* IIFCTS: To flag for CT statistics
* IIFDXS: To flag for DEDX statistics
* IIFCFS: To flag for "FAKE" statistics
* IIFCXS: To flag for CX statistics
* IIFSIS: To flag for Silicon Microvertex statistics
* IIFCSS: To flag for Silicon Microvertex merging statistics
* IIFCES: To flag for CE statistics
* IIFCAS: To flag for CA statistics
*
*                  Parameter for electro-magnetic statistics bank ECS
* NLECS : Number of links
* NSECS : Number of structural links
* NDECS : Number of data words
* NIECS : Number of integer data words
* IOECS : Index of IO characteristic
*
*                  Offsets in the link part of ECS
* LLTBS : To time-of-flight barrel statistics bank
* LLPBS : To presampler barrel statistics bank
* LLEBS : To barrel lead glass statistics bank
* LLPES : To presampler end-cap statistics bank
* LLEES : To end-cap lead glass statistics bank
* LLEMS : To E.M. cluster statistics bank
* LLTES : To TE cluster statistics bank
*
*                  Offsets in the data part of ECS
* IIFTBS: To flag for TB statistics
* IIFPBS: To flag for PB statistics
* IIFEBS: To flag for EB statistics
* IIFPES: To flag for PE statistics
* IIFEES: To flag for EE statistics
* IIFEMS: To flag for EM statistics
* IIFTES: To flag for TE statistics
*
*                  Parameter for hadron statistics bank HCS
* NLHCS : Number of links
* NSHCS : Number of structural links
* NDHCS : Number of data words
* NIHCS : Number of integer data words
* IOHCS : Index of IO characteristic
*
*                  Offsets in the link part of HCS
* LLHBS : To barrel hadron calorimeter statistics bank
* LLHES : To end-cap hadron calorimeter statistics bank
* LLHPS : To poletip hadron calorimeter statistics bank
* LLHMS : To hadronic cluster statistics bank
*
*                  Offsets in the data part of HCS
* IIFHBS: To flag for HB statistics
* IIFHES: To flag for HE statistics
* IIFHPS: To flag for HP statistics
* IIFHMS: To flag for HM statistics
*
*                  Parameter for top muon statistics bank MUS
* NLMUS : Number of links
* NSMUS : Number of structural links
* NDMUS : Number of data words
* NIMUS : Number of integer data words
* IOMUS : Index of IO characteristic
*
*                  Offsets in the link part of MUS
* LLMBS : To barrel muon chamber statistics bank
* LLMES : To end-cap muon chamber statistics bank
* LLMMS : To muon segment statistics bank
*
*                  Offsets in the data part of MUS
* IIFMBS: To flag for MB statistics
* IIFMES: To flag for ME statistics
* IIFMMS: To flag for MM statistics
*
*                  Parameter for top forward detector statistics bank FO
* NLFOS : Number of links
* NSFOS : Number of structural links
* NDFOS : Number of data words
* NIFOS : Number of integer data words
* IOFOS : Index of IO characteristic
*
*                  Offsets in the link part of FOS
* LLFDSR: To right forward detector statistics bank
* LLFDSL: To left forward detector statistics bank
* LLSWS : To Silicon Tungsten statistics bank
*
*                  Offsets in the data part of FOS
* IIFFDS: To flag for FD statistics
* IIFSWS: To flag for Silicon Tungsten statistics
*
*                  Parameter for "DST" statistics bank ODS
* NLODS : Number of links
* NSODS : Number of structurel links
* NDODS : Number of data words
* NIODS : Number of integer data words
* IOODS : Index of IO characteristic
*
*                  Offsets in the link part of ODS
*         ??????
*
*                  Offsets in the data part of ODS
*         ??????
*
*                  Parameter for summary statistics bank RSMS
* NLRSMS: Number of links
* NSRSMS: Number of structural links
* NDRSMS: Number of data words
* NIRSMS: Number of integer data words
* IORSMS: Index of IO characteristic
*
*                  Offsets in the link part of RSMS
* LLRTIS: To time spend per processor
* LLRSPS: To space used per processor
* LLRTI2: To time spend per processor (**2)
* LLRSP2: To space used per processor (**2)
*
*                  Parameter for time summary bank RTIS (RTI2)
* NLRTIS: Number of links
* NSRTIS: Number of structural links
* NDRTIS: Number of data words
* NIRTIS: Number of integer data words
* IORTIS: Index of IO characteristic
*
*                  Parameter for space summary bank RSPS (RSP2)
* NLRSPS: Number of links
* NSRSPS: Number of structural links
* NDRSPS: Number of data words
* NIRSPS: Number of integer data words
* IORSPS: Index of IO characteristic
*
*******************************************************************
+SEQ ,ROSPAR.
      END
+DECK,M.
+KEEP,ROTPARM.
* Mnemonics for event types word 1+2 to make them avaible for FFREAD
* cards and interactive use, for doc see ROTPAR
      INTEGER IDLOOP
      CHARACTER*24 ROTYPM(64)
      DATA (ROTYPM(IDLOOP),IDLOOP=1,16)/
     + 'LUET "Etotbar" cal sel '
     +,'LUEM "Emainbar" cal sel'
     +,'LUCU "CUBED",prop,drift'
     +,'LLLM Low mult presel   '
     +,'LLQQ High mult veto    '
     +,'LLCO Cosmic ray veto   '
     +,'LLIL LL Isolated Lepton'
     +,'GAM  Singl phot presel '
     +,'GCON Conv. phot presel '
     +,'HLPT Heavy lept MissE  '
     +,'HLIS Heavy lept IsolTrk'
     +,'TWOP Tagged two phot   '
     +,'HIGS Higgs high mult   '
     +,'GSTR Valid singl phot  '
     +,'HLCM Heavy lept Close-m'
     +,'TKMH TKMH multihadron  '/
      DATA (ROTYPM(IDLOOP),IDLOOP=17,32)/
     + 'FDTR Validated FD trig '
     +,'LLEE Electron pair     '
     +,'LLMM Muon pair         '
     +,'LLTT Tau pair          '
     +,'LLLL Lepton pair       '
     +,'GVMU S phot muon veto  '
     +,'GVBW S phot beam-wall  '
     +,'GEMT S phot EM ass TOF '
     +,'GTOE S phot EM and TOF '
     +,'GGT0 S phot In-time TOF'
     +,'GEM  S phot EM clus    '
     +,'GGTR S phot High pT trk'
     +,'TRIG special triggers  '
     +,'GHOK S phot no H+MU vet'
     +,'GLLD long-lived decays '
     +,'FYZ1 "Phys1" selection '/
      DATA (ROTYPM(IDLOOP),IDLOOP=33,51)/
     + 'FYZS Z0 type physics   '
     +,'FYZT Lumi type physics '
     +,'PRSC Onl ROPE prescaleb'
     +,'SWIA Lumi SWIA         '
     +,'SWIR Lumi SWIR         '
     +,'SWOR Lumi SWOR         '
     +,'SWIL Lumi SWIL         '
     +,'SWOL Lumi  SWOL        '
     +,'TETR TE stud prescale  '
     +,'GACE Chgino Gen ACop   '
     +,'LMAE Chgino LowMul ACop'
     +,'MONO Chgino MONOJET    '
     +,'GOPL GP Chargino       '
     +,'NELO Neutralino loose  '
     +,'NETI Neutralino tight  '
     +,'UGGE Untagged GG, Excl.'
     +,'IUGG Untagged GG, Incl.'
     +,'WABB Wide Angle Bhabha '
     +,'L2MH LEP2 Multi Hadron '/
      DATA (ROTYPM(IDLOOP),IDLOOP=52,64)/
     + 'XXXX Unused            '
     +,'NGAM N-Gamma           '
     +,'NRH1 Non-Rad. MH sel. 1'
     +,'NRH2 Non-Rad. MH sel. 2'
     +,'WW4Q WW to 4 jets      '
     +,'WWQE WW to 2 jets el&nu'
     +,'WWQM WW to 2 jets mu&nu'
     +,'WWQT WW to 2 jet tau&nu'
     +,'WWLL WW to 4 leptons   '
     +, 4*' '/
+DECK,ROTPAR.
+KEEP,ROTPAR.
* Definition of event type word 1
* remember to update ROTPARM and Command EVTYPE in patch KUIP
      INTEGER    IELUET, IELUEM, IELUCU, IELLLM, IELLQQ
      INTEGER    IELLCO, IELLIL, IEGAM , IEGCON, IEHLPT
      INTEGER    IEHLIS, IETWOP, IEHIGS, IEGSTR, IEHLCM
      INTEGER    IETKMH, IEFDTR, IELLEE, IELLMM, IELLTT
      INTEGER    IELLLL, IEGVMU, IEGVBW, IEGEMT, IEGTOE
      INTEGER    IEGGT0, IEGEM , IEGGTR, IETRIG, IEGHOK
      INTEGER    IEGLLD, IEFYZ1
*
      PARAMETER (IELUET= 1, IELUEM= 2, IELUCU= 3, IELLLM= 4, IELLQQ= 5)
      PARAMETER (IELLCO= 6, IELLIL= 7, IEGAM = 8, IEGCON= 9, IEHLPT=10)
      PARAMETER (IEHLIS=11, IETWOP=12, IEHIGS=13, IEGSTR=14, IEHLCM=15)
      PARAMETER (IETKMH=16, IEFDTR=17, IELLEE=18, IELLMM=19, IELLTT=20)
      PARAMETER (IELLLL=21, IEGVMU=22, IEGVBW=23, IEGEMT=24, IEGTOE=25)
      PARAMETER (IEGGT0=26, IEGEM =27, IEGGTR=28, IETRIG=29, IEGHOK=30)
      PARAMETER (IEGLLD=31, IEFYZ1=32)
*
* For back-compatibility, define some alternative names
      INTEGER    IELUM1, IELUM2, IELUM3
      PARAMETER (IELUM1=IELUEM, IELUM2=IELUET, IELUM3=IELUCU)
      INTEGER    IELEP1,IELEP2,IELEP3,IELEP4,IELEP5,IELEP6,IELEP7,IELEP8
      PARAMETER (IELEP1=IELLLM, IELEP2=IELLQQ, IELEP3=IELLCO)
      PARAMETER (IELEP4=IELLIL, IELEP5=IELLEE, IELEP6=IELLMM)
      PARAMETER (IELEP7=IELLTT, IELEP8=IELLLL)
      INTEGER    IEGAM1,IEGAM2,IESPTR
      PARAMETER (IEGAM1=IEGAM , IEGAM2=IEGCON, IESPTR=IEGSTR)
      INTEGER    IEHLP1,IEHLP2,IEHLP3
      PARAMETER (IEHLP1=IEHLPT, IEHLP2=IEHLIS, IEHLP3=IEHLCM)
      INTEGER    IEPHS1
      PARAMETER (IEPHS1=IEFYZ1)
*
* Definition of event type word 2
* Count as if event type is a 64 bit word for compatibilty with REVTYP
      INTEGER    IEFYZS, IEFYZT, IEPRSC
      INTEGER    IESWIA, IESWIR, IESWOR, IESWIL, IESWOL
      INTEGER    IETETR, IEGACE, IELMAE, IEMONO, IEGOPL
      INTEGER    IENELO, IENETI, IEUGGE, IEIUGG, IEWABB
      INTEGER    IEL2MH, IEXXXX, IEOPTR, IENRH1, IENRH2
      INTEGER    IEWW4Q, IEWWQE, IEWWQM, IEWWQT, IEWWLL
      INTEGER    IETEMP, IESWKP, IESPSS
      PARAMETER (                      IEFYZS=33, IEFYZT=34, IEPRSC=35)
      PARAMETER (IESWIA=36, IESWIR=37, IESWOR=38, IESWIL=39, IESWOL=40)
      PARAMETER (IETETR=41, IEGACE=42, IELMAE=43, IEMONO=44, IEGOPL=45)
      PARAMETER (IENELO=46, IENETI=47, IEUGGE=48, IEIUGG=49, IEWABB=50)
      PARAMETER (IEL2MH=51, IEXXXX=52, IEOPTR=53, IENRH1=54, IENRH2=55)
      PARAMETER (IEWW4Q=56, IEWWQE=57, IEWWQM=58, IEWWQT=59, IEWWLL=60)
      PARAMETER (IETEMP=61, IESWKP=62, IESPSS=63)
+DECK,ROTPARDOC.
+KEEP,ROTPARDOC.
******************************************************************
*
*                  Sequence ROTPAR
*
******************************************************************
*
*  Pointers to bits in the Event Type word in event header
*
* Luminosity and FD selections (RBABFD)
* IELUET: "Etotbar" calorimeter selection
* IELUEM: "Emainbar" calorimeter selection
* IELUCU: "CUBED" calorimeter + prop tubes + drift chamber selection
* IEFDTR: Validated forward detector triggered events (RTRGFD)
*
* Lepton pair preselection and classification. (LLBAT)
* IELLLM: Low multiplicity preselection
* IELLQQ: High multiplicity veto
* IELLCO: Cosmic ray veto
* IELLIL: LL isolated lepton
* IELLEE: Electron pair classification
* IELLMM: Muon pair classification
* IELLTT: Tau pair classification
* IELLLL: Lepton pair classification
*
* Single photon preselection.
* IEGAM : Single photon preselection    (RGAM)
* IEGCON: Converted photon preselection (RPHCON)
* IEGVMU: Single photon muon veto       (RGAM)
* IEGVBW: Single photon beam-wall veto  (RGAM)
* IEGSTR: Validated special single photon triggered events (RSPTRG)
* IEGEMT: EM cluster and associated TOF preselection (RGTOEM)
* IEGTOE: EM and TOF criteria of IEGEMT preselection (RGTOEM)
* IEGGT0: In-time TOF counter                        (RGTOEM)
* IEGEM : EM cluster, N(block)>1, without vetoes, selection  (RGEM)
* IEGGTR: High pT track                               (RGTOEM)
* IEGHOK: Single photon pre-selection with no HCAL or MUON veto
*
* IEGLLD: Track selection for long-lived decays - no d0 cuts.
*
* Heavy lepton selection. (RHLSEL)
* IEHLPT: Missing energy selection
* IEHLIS: Isolated track selection
* IEHLCM: Close-mass heavy lepton selection
*
* IETWOP: Tagged two photon preselection (RTWOPH)
* IEHIGS: Higgs group high multiplicity preselection (RHSEL)
* IETKMH: Tokyo group multihadron selection (RMHSEL)
*
* IETRIG: Selections of other special triggers (RTRIGS)
*
* IEFYZ1: "Phys1" selection of events for the DST farm (ROEVTY)
*
* IEFYZS: Z0 type physics (ROEVTY)
*
* IEFYZT: lumi type physics (ROEVTY)
*
* IEPRSC: event not processed by Online ROPE at the pit (prescaling)
*
* SW event types (RBABSW)
* IESWIA two ADC clusters match with average theta cut
* IESWIR ADC cluster / in-time trigger cluster match, right
* IESWOR ADC cluster / out-of-time trigger cluster match, right
* IESWIL ADC cluster / in-time trigger cluster match, left
* IESWOL ADC cluster / out-of-time trigger cluster match, left
*
* IEGACE: Chargino - General ACoplanar Event
* IELMAE: Chargino - Low Multiplicity Acoplanar Event
* IEMONO: Chargino - MONOJET type event
* IEGOPL: Chargino - gold plated GACE,LMAE or MONO
* IENELO: Neutralino - loose selection
* IENETI: Neutralino - tight selection
* IEUGGE : Exclusive Untagged Gamma Gamma selection
* IEIUGG : Inclusive Untagged Gamma Gamma selection
* IEWABB : Wide Angle BhaBha
* IEL2MH : LEP2 MultiHadron
* IEXXXX : MPrho-rho trigger
* IEOPTR : One in a hundred OPAL triggers
* IENRH1 : Non Radiative multiHadron, simple selection (WWSPRI via RONRMH)
* IENRH2 : Non Radiative multiHadron, complicated selection (WWSPR via RONRMH)
* IEWW4Q : WW -> 4 quarks
* IEWWQE : WW -> 2 quarks + e nu
* IEWWQM : WW -> 2 quarks + mu nu
* IEWWQT : WW -> 2 quarks + tau nu
* IEWWLL : WW -> lepton nu + lepton nu
* IETEMP : TE Mip-Plug trigger 
* IESWKP : ROPE SW Keep selection
* IESPSS : Single Photon Special Selection (DD kept) 
*******************************************************************
+SELF,IF=DOC,RODOC.
+SEQ,ROTPARDOC.
+SEQ ,ROTPAR.
      END
+DECK,ROCEXP.
+KEEP,ROCEXP.
      INTEGER         MAXEXP
      PARAMETER      (MAXEXP=15)
      CHARACTER*4     CHTNOM
*
      COMMON /ROCEXP/ CHTNOM(MAXEXP)
*
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence ROCEXP
*
************************************************************************
*
*
*  MAXEXP   : Maximum no. of 'main' databases that can be attached.
*  CHTNOM   : Top directory names associated with each 'main' database.
*
***********************************************************************
+SEQ ,ROCEXP.
      END
+DECK,OCFLAG.
+KEEP,OCFLAG.
      INTEGER        IOCERR,IOCRRV,IOCURV,IOCCRV,IOCEXP,IOCPRV,IOCPEX
*
      COMMON /OCFLAG/IOCERR,IOCRRV,IOCURV,IOCCRV,IOCEXP,IOCPRV,IOCPEX
*
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence OCFLAG
*
************************************************************************
*
*
*  IOCERR   : Variable to hold result of opcal subroutine calls
*  IOCRRV   : Counter indicating a new retrieval for rope
*  IOCURV   : Counter indicating a new retrieval for user
*  IOCCRV   : Counter indicating a new constant structure
*  IOCEXP   : Flag to allow ROPE to force retrieval (OCGET 'E').
*  IOCPRV   : Alternative flag indicating new constants structure
*  IOCPEX   : Alternative flag to force retrieval (OCGET 'EA')
*
***********************************************************************
+SEQ,OCFLAG.
      END
+DECK,ROLUM.
+KEEP,ROLUM.
      INTEGER NLMSUM,NLMBHA,IBHFRN,IBHFEV,IBHLRN,IBHLEV
      REAL    EBLMIN,EBLMAX,EBLOFF
*-- Double precision needed for large sum of small numbers.
*-- Should be OK to <<.1% total precision for <10**10 lumi events summed
      DOUBLE PRECISION SUMLUM,SUMLM2,SUMLSY,SUMEBL,SUME2L,SUMESY
*
* NLMSUM = total number of luminosity sums allowed in job
      PARAMETER (NLMSUM=50)
      COMMON/ROLUM/NLMBHA(NLMSUM),IBHFRN(NLMSUM),IBHFEV(NLMSUM),
     +                            IBHLRN(NLMSUM),IBHLEV(NLMSUM),
     +             EBLMIN(NLMSUM),EBLMAX(NLMSUM),EBLOFF(NLMSUM),
     +             SUMLUM(NLMSUM),SUMLM2(NLMSUM),SUMLSY(NLMSUM),
     +             SUMEBL(NLMSUM),SUME2L(NLMSUM),SUMESY(NLMSUM)
*
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence ROLUM
*
*  Luminosity sum data for all sums, incremented throughout job
*
************************************************************************
*
*
*  NLMSUM   : Total allowed number of luminosity sums
*  NLMBHA   : Number of Bhabha events included in sum
*  IBHFRN   : Run number of first Bhabha included in sum
*  IBHFEV   : Event number of first Bhabha included in sum
*  IBHLRN   : Run number of last Bhabha included in sum
*  IBHLEV   : Event number of last Bhabha included in sum
*  EBLMIN   : Minimum beam energy of Bhabhas included in sum (GeV)
*  EBLMAX   : Maximum beam energy of Bhabhas included in sum (GeV)
*  EBLOFF   : Beam energy of first event in sum, used as offset (GeV)
*  SUMLUM   : Sum of luminosity (1/nb)
*  SUMLM2   : Sum of luminosity**2 (1/nb**2)
*  SUMLSY   : Systematic error on sum of luminosity (1/nb)
*  SUMEBL   : Sum of luminosity*(beam energy) (GeV/nb)
*  SUME2L   : Sum of luminosity*(beam energy)**2 (GeV**2/nb)
*  SUMESY   : Sum of luminosity*(beam energy systematic error) (GeV/nb)
*
***********************************************************************
+SEQ ,ROLUM.
      END
+DECK,ROLSUM.
+KEEP,ROLSUM.
      INTEGER ILSUM,IFRUN,IFEVT,ILRUN,ILEVT,NLBHAB
      REAL    TOTLUM,DLUMST,DLUMSY,
     +        EBMIN,EBMAX,EBMEAN,DEBMST,DEBMSY,EBSPRD,DEBSST
*
      COMMON/ROLSUM/ILSUM,IFRUN,IFEVT,ILRUN,ILEVT,NLBHAB,
     +              TOTLUM,DLUMST,DLUMSY,
     +              EBMIN,EBMAX,EBMEAN,DEBMST,DEBMSY,EBSPRD,DEBSST
*
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence ROLSUM
*
*  Final luminosity sum results for one luminosity sum at end of job
*
************************************************************************
*
*
*   ILSUM   : Index number of this luminosity sum
*   IFRUN   : Run number of first Bhabha included in this sum
*   IFEVT   : Event number of first Bhabha included in this sum
*   ILRUN   : Run number of last Bhabha included in this sum
*   ILEVT   : Event number of last Bhabha included in this sum
*  NLBHAB   : Number of Bhabha events included in this sum
*  TOTLUM   : Sum of luminosity (1/nb)
*  DLUMST   : Statistical error on sum of luminosity (1/nb)
*  DLUMSY   : Systematic error on sum of luminosity (1/nb)
*   EBMIN   : Minimum beam energy of Bhabhas included in this sum (GeV)
*   EBMAX   : Maximum beam energy of Bhabhas included in this sum (GeV)
*  EBMEAN   : Luminosity weighted mean beam energy of Bhabhas (GeV)
*  DEBMST   : Statistical error on mean beam energy (GeV)
*  DEBMSY   : Systematic error on mean beam energy (GeV)
*  EBSPRD   : 1-sigma spread of beam energies (GeV)
*  DEBSST   : Statistical error on beam energy spread (GeV)
*
***********************************************************************
+SEQ ,ROLSUM.
      END
+DECK,ROCRCM.
+KEEP,ROCRCM.
      INTEGER NMXCNT
      PARAMETER(NMXCNT=50)
      INTEGER NCLAS
      PARAMETER(NCLAS=3)
      INTEGER NLUMI
      PARAMETER(NLUMI=3)
      LOGICAL LCNTUS
      INTEGER NTNUM
      INTEGER NNUM
*     NBHA is a real for (SWITR+SWITL)/2 selection.
      REAL    NBHA
*-- Double precision needed for large sum of small numbers
*-- Should be ok to <<1% total precision for < 10**10 lumi events summed
      DOUBLE PRECISION LU, LU2
      DOUBLE PRECISION SYSLU
      REAL    STALU
      REAL    EBOF
      DOUBLE PRECISION LUEDIF, LUEDF2, LUSYSE
      REAL    EMEAN, SYEMEA, STEMEA
      REAL    ESPRD, STESPR
      LOGICAL LUMDST
*     For (SWITR+SWITL)/2 keep trak of some numbers
      DOUBLE PRECISION L2RL, L2RLBR, L2RBRL
      COMMON/ROCRCM/LU(NLUMI,NCLAS,NMXCNT) ,
     +              LU2(NLUMI,NCLAS,NMXCNT) ,
     +              LUEDIF(NLUMI,NCLAS,NMXCNT) ,
     +              LUEDF2(NLUMI,NCLAS,NMXCNT) ,
     +              LUSYSE(NLUMI,NCLAS,NMXCNT) ,
     +              SYSLU(NLUMI,NCLAS,NMXCNT) ,
     +              L2RL(NCLAS,NMXCNT) ,
     +              L2RLBR(NCLAS,NMXCNT) ,
     +              L2RBRL(NCLAS,NMXCNT) ,
     +              NTNUM(NMXCNT) ,
     +              LCNTUS(NMXCNT) ,
     +              NNUM(NCLAS,NMXCNT) ,
     +              NBHA(NLUMI,NCLAS,NMXCNT) ,
     +              STALU(NLUMI,NCLAS,NMXCNT) ,
     +              EBOF(NLUMI,NCLAS,NMXCNT) ,
     +              EMEAN(NLUMI,NCLAS,NMXCNT) ,
     +              ESPRD(NLUMI,NCLAS,NMXCNT) ,
     +              SYEMEA(NLUMI,NCLAS,NMXCNT) ,
     +              STEMEA(NLUMI,NCLAS,NMXCNT) ,
     +              STESPR(NLUMI,NCLAS,NMXCNT)
      COMMON /ROCRCM/ LUMDST
      SAVE /ROCRCM/
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                   Sequence ROCRCM
*
*   Cross section calculation
*
************************************************************************
*
*     In the following :
*     - IL is the luminosity index:
*                                  IL = 1 for SWITA lumi
*                                  IL = 2 for FD lumi
*                                  IL = 3 for (SWITR+SWITL)/2
*     - ISUM is the sum index
*     - ICL  is the class index:
*                               ICL = 1: SW ok
*                               ICL = 2: SW ok and FD ok
*                               ICL = 3: SW bad and FD ok
*
*     NMXCNT              : Maximum number of simultaneous calculations
*     NCLAS               : Number of classes
*     NLUM                : Number of luminosity calculations
*
*     LCNTUS(ISUM)        : Mask: .TRUE. if sum has been used
*     NTNUM(ISUM)         : Numer of times ROCROS was called for good
*                           numerator event (all det/trig status)
*     NNUM(ICL,ISUM)      : the same, but for a given class
*     NBHA(IL,ICL,ISUM)   : number of bhabha
*     LU(IL,ICL,ISUM)     : integrated luminosity
*     LU2(IL,ICL,ISUM)    : sum of luminosity weight **2
*     SYSLU(IL,ICL,ISUM)  : syst. error on integrated luminosity
*     STALU(IL,ICL,ISUM)  : stat. error on integrated luminosity
*     EBOF(IL,ICL,ISUM)   : beam energy of first event in sum (offset)
*     LUEDIF(IL,ICL,ISUM) : sum of luminosity * beam energy
*     LUEDF2(IL,ICL,ISUM) : sum of luminosity * beam energy **2
*     LUSYSE(IL,ICL,ISUM) : sum of luminosity * sys. err. on beam energy
*     EMEAN(IL,ICL,ISUM)  : luminosity-weighted mean beam energy
*     SYEMEA(IL,ICL,ISUM) : sys. err. on lumi-weighted mean beam energy
*     STEMEA(IL,ICL,ISUM) : sta. err. on lumi-weighted mean beam energy
*     ESPRD(IL,ICL,ISUM)  : lumi-weighted beam energy spread
*     STESPR(IL,ICL,ISUM) : sta. err. on lumi-weighted beam energy sprea
*     L2RL(ICL,ISUM)      : sum of luminosity weight **2 SWITR.AND.SWITL
*     L2RLBR(ICL,ISUM)    : sum of lumi weight **2 SWITR.AND.(.NOT.SWITL)
*     L2RBRL(ICL,ISUM)    : sum of lumi weight **2 (.NOT.SWITR).AND.SWITL
*
************************************************************************
+SEQ, ROCRCM.
      END
+DECK,ROEVIA.
+KEEP,ROEVIA.
      INTEGER IEVTIA, IRUNIA, IFLGIA
      LOGICAL LEVTIA
      COMMON /ROEVIA/ LEVTIA, IRUNIA, IEVTIA, IFLGIA
+DECK,DADRFCDE.
+KEEP,DADRFCDE.
*-- Common to store NBDAD DAD-events of NBPDAD words each
*   08-Dec-94 G.Duckeck Introduce LLOCAL to force local file open
*   28-Nov-94 O.Schaile Add LDACIN for "new" preseek method
*                       change NBDAD to 4000 (G.Duckeck)
      INTEGER NBDAD,NBPDAD,NSIZE
      PARAMETER (NBDAD=4000,NBPDAD=6,NSIZE=NBDAD*NBPDAD)
      INTEGER NUMMEM,LOCMEM,IDAMEM,LCIOLU
      LOGICAL LDACIO,LDACIN,LLOCAL
      COMMON/DADMEM/NUMMEM,LOCMEM,IDAMEM(NBPDAD,NBDAD),
     +       LCIOLU(100),LDACIO,LDACIN,LLOCAL
+DECK,ROSWCT.
+KEEP,ROSWCT.
      REAL RMIN93,RMIN96,RMAX,RZONE,EFRAC,EAFRAC,DPHMX,DRMX
      PARAMETER (RMIN93 = 7.7 )
      PARAMETER (RMIN96 = 9.45)
      PARAMETER (RMAX   = 12.7)
      PARAMETER (RZONE  = 1.0 )
      PARAMETER (EFRAC  = 0.5 )
      PARAMETER (EAFRAC = 0.75)
      PARAMETER (DPHMX  = 0.2 )
      PARAMETER (DRMX   = 2.5 )
*
* Cut values used for SW luminosity selection
*
* RMIN93 minimum radius(cm), LEP1-LEP1.5    acceptance
* RMIN96 minimum radius(cm), LEP1.6 onwards acceptance
* RMAX   maximum radius(cm)
* RZONE  radial zone cut(cm)
* EFRAC  minimum energy fraction on a side
* EAFRAC minimum average energy fraction
* DPHMX  acoplanarity cut(rad)
* DRMX   acolinearity cut(cm)
*
+DECK,ROSWMG.
+KEEP,ROSWMG.
      REAL EFMGR,EFMGL,RMGR,RMGL,PHMGR,PHMGL
      INTEGER NMAX
      PARAMETER(NMAX=7)
      LOGICAL LMGR,LMGL
      COMMON /ROSWMG/EFMGR,EFMGL,RMGR,RMGL,PHMGR,PHMGL,
     +               LMGR(NMAX),LMGL(NMAX)
      SAVE /ROSWMG/
*
* Merged SW cluster information filled in RSWMGR and used in RSWBIT to
* make SW luminosity selection.
*
* EFMGx energy fraction of merged cluster Right/Left
* RMGx  radius(cm) of merged cluster Right/Left
* PHMGx phi(rad) of merged cluster Right/Left
* NMAX  maximum number of clusters, should be the same as MAXCLS in ROSWVA
* LMGx  logical array used as a pointer to the ER or EL array in ROSWVA.
*       set true if this cluster used in merging Right/Left false otherwise
*
+DECK,ROSWVA.
+KEEP,ROSWVA.
      INTEGER MAXCLS,MAXPAD,MLAY,MAXWTC
      PARAMETER (MAXCLS=7,MLAY=15,MAXPAD=MAXCLS*MLAY,MAXWTC=32)
      INTEGER IRUN,  IEVT,  IBUNCH,IBCHLT,IWAGHR,IWAGHL,ITGMOD,IROPE,
     +        IDSTAT,ITSTAT,ISWHBV
      LOGICAL LSSGL, LSSGR, LSLOL, LSLOR, LSWH,  LSSEG, LSSGA, LSSUM,
     +        LSSMA, LFDH,  LFSUM, LFSEG, LFYZ1, LFYZS, LFYZT, LTKMH,
     +        LGPMH, LLUET, LLUEM, LLUCU, LGMHST,LLCAL, LRCAL, LEBTL,
     +        LTBM1, LBXR,  LBXRS, LFGCLT,LFGCRT,LFSGA, LFDSGL,LFDSGR,
     +        LSWITA,LSWITR,LSWOTR,LSWITL,LSWOTL,LHTRO, LHTRE, LHTLO,
     +        LHTLE, LFTR,  LFTL,  LATHR, LATHL, LGPEE, LGPMM, LGPTT,
     +        LGPLL, LSWBH, LFDBH, LEELLO,LEERLO,LEBWG,LEML,LEMR,LTM2,
     +        LLAY
      INTEGER NCLSR, NCLSL
      REAL    ER,    EL,    RADR,  RADL,  PHIR,  PHIL,  THINTR,THINTL,
     +        SHDR,  SHDL,  SHAR,  SHAL,  RERRR, RERRL
      INTEGER NPADR, NPADL, ICTYPR,ICTYPL,NLOFFR,NLOFFL,IBUNR,IBUNL,
     +        IBUDFR,IBUDFL
      REAL    RCENTR,RCENTL,E5TCR, E5TCL, E15CR, E15CL, E5TAR, E5TAL,
     +        E15AR, E15AL, EPKOR, EPKOL, EPKER, EPKEL, EQDOR, EQDOL,
     +        EQDER, EQDEL
      INTEGER NLAYR, NLAYL, ISHBR, ISHBL
      REAL    SHCR,  SHCL, XTRAR, XTRAL
      INTEGER NPR,   NPL,   IPMAXR,IPMAXL,NTRKR, NTRKL
      REAL    ETR,   ETL,   THTR,  THTL,  PHTR,  PHTL
      INTEGER NFCLSR, NFCLSL
      REAL    EFR,   EFL,   THETFR,THETFL,PHIFR, PHIFL, EPREFR,EPREFL
      REAL    EMXR,EMXL,PHITR,PHITL,EMXAR,EMXAL,PHITAR,PHITAL
      INTEGER NPPRET
      REAL    ETADCR,ETADCL,ETSRVR,ETSRVL
      INTEGER ITRATE
      REAL    SEGR,  SEGL,  SEG,   SEGA,  BKG2
      INTEGER NCJTR, NEC
      REAL    PCJTR, THCJTR,PHCJTR,EECAL, THECAL,PHECAL
      REAL    EBEAM, CTHR,  XBEAM, YBEAM, ZBEAM, EVPEDR,EVPEDL,SYSEB
      REAL    ESUMR, ESUML, ZDET
      INTEGER IDATE, ITIME, IFDDST,IBPOS
      INTEGER NWTCH,INLB,ITGLOG,ISTRBR,ISTRBL,ITEXR,ITEXL
      LOGICAL LRNDM,LNOTEX,LTXROK,LTXLOK,LCWROK,LCWLOK,LTGROK,LTGLOK
      INTEGER NWTCRC,NWTCLC,NWTCRA,NWTCLA
      LOGICAL LBDTRC,LBDTLC,LBDTRA,LBDTLA
      INTEGER ITAGRC,ITAGLC,ITAGRA,ITAGLA,ICHNRC,ICHNLC,ICHNRA,ICHNLA
      REAL    EWTTRC,EWTTLC,EWTTRA,EWTTLA,EWTPRC,EWTPLC

      COMMON /ROSWVA/IRUN,  IEVT,  IBUNCH,IBCHLT,IWAGHR,IWAGHL,ITGMOD,
     +        IROPE,IDSTAT,ITSTAT,ISWHBV,
     +        LSSGL, LSSGR, LSLOL, LSLOR, LSWH,  LSSEG, LSSGA, LSSUM,
     +        LSSMA, LFDH,  LFSUM, LFSEG, LFYZ1, LFYZS, LFYZT, LTKMH,
     +        LGPMH, LLUET, LLUEM, LLUCU, LGMHST,LLCAL, LRCAL, LEBTL,
     +        LTBM1, LBXR,  LBXRS, LFGCLT,LFGCRT,LFSGA, LFDSGL,LFDSGR,
     +        LSWITA,LSWITR,LSWOTR,LSWITL,LSWOTL,LHTRO, LHTRE, LHTLO,
     +        LHTLE, LFTR,  LFTL,  LATHR, LATHL, LGPEE, LGPMM, LGPTT,
     +        LGPLL, LSWBH, LFDBH, LEELLO,LEERLO,LEBWG,LEML,LEMR,
     +        LTM2,LLAY(16),NCLSR,
     +        ER(MAXCLS), RADR(MAXCLS),
     +        PHIR(MAXCLS),THINTR(MAXCLS),
     +        SHDR(MAXCLS),SHAR(MAXCLS),
     +        RERRR(MAXCLS),NPADR(MAXCLS),
     +        ICTYPR(MAXCLS),NLOFFR(MAXCLS),
     +        RCENTR(MAXCLS),
     +        E5TCR(MAXCLS),E15CR(MAXCLS),
     +        E5TAR(MAXCLS),E15AR(MAXCLS),
     +        EPKOR(MAXCLS),EPKER(MAXCLS),
     +        EQDOR(MAXCLS),EQDER(MAXCLS)
      COMMON /ROSWVA/NLAYR(MAXCLS),ISHBR(MAXCLS),
     +        SHCR(MAXCLS),IBUNR(MAXCLS),
     +        IBUDFR(MAXCLS),XTRAR(MAXCLS),
     +        NCLSL,EL(MAXCLS),RADL(MAXCLS),PHIL(MAXCLS),
     +        THINTL(MAXCLS),SHDL(MAXCLS),SHAL(MAXCLS),RERRL(MAXCLS),
     +        NPADL(MAXCLS),ICTYPL(MAXCLS),NLOFFL(MAXCLS),
     +        RCENTL(MAXCLS),
     +        E5TCL(MAXCLS),E15CL(MAXCLS),E5TAL(MAXCLS),E15AL(MAXCLS),
     +        EPKOL(MAXCLS),EPKEL(MAXCLS),EQDOL(MAXCLS),EQDEL(MAXCLS),
     +        NLAYL(MAXCLS),ISHBL(MAXCLS),SHCL(MAXCLS), IBUNL(MAXCLS),
     +        IBUDFL(MAXCLS),XTRAL(MAXCLS),
     +        NPR,NPL,IPMAXR(MAXPAD),IPMAXL(MAXPAD),
     +        NTRKR, NTRKL, ETR(MAXCLS),ETL(MAXCLS),THTR(MAXCLS),
     +        THTL(MAXCLS),PHTR(MAXCLS),PHTL(MAXCLS),NFCLSR,NFCLSL,
     +        EFR(MAXCLS),EFL(MAXCLS),THETFR(MAXCLS),THETFL(MAXCLS),
     +        PHIFR(MAXCLS),PHIFL(MAXCLS),EPREFR(MAXCLS),EPREFL(MAXCLS)
      COMMON /ROSWVA/EMXR,EMXL,PHITR,PHITL,EMXAR,EMXAL,PHITAR,PHITAL,
     +        NPPRET,ETADCR,ETADCL,ETSRVR,ETSRVL,ITRATE,SEGR(1),SEGL(1),
     +        SEG(1),SEGA(1),BKG2(1),NCJTR,NEC,PCJTR(1),THCJTR(1),
     +        PHCJTR(1),EECAL(1),THECAL(1),PHECAL(1),
     +        EBEAM, CTHR,  XBEAM, YBEAM, ZBEAM, EVPEDR,EVPEDL,SYSEB,
     +        ESUMR, ESUML, ZDET, IDATE, ITIME, IFDDST,IBPOS,
     +        NWTCH,INLB,ITGLOG,ISTRBR,ISTRBL,ITEXR,ITEXL,
     +        LRNDM,LNOTEX,LTXROK,LTXLOK,LCWROK,LCWLOK,LTGROK,LTGLOK,
     +        NWTCRC,NWTCLC,NWTCRA,NWTCLA,
     +        LBDTRC(MAXWTC),ITAGRC(MAXWTC),ICHNRC(MAXWTC),
     +        EWTTRC(MAXWTC),EWTPRC(MAXWTC),
     +        LBDTLC(MAXWTC),ITAGLC(MAXWTC),ICHNLC(MAXWTC),
     +        EWTTLC(MAXWTC),EWTPLC(MAXWTC),
     +        LBDTRA(MAXWTC),ITAGRA(MAXWTC),ICHNRA(MAXWTC),
     +        EWTTRA(MAXWTC),
     +        LBDTLA(MAXWTC),ITAGLA(MAXWTC),ICHNLA(MAXWTC),
     +        EWTTLA(MAXWTC)
      SAVE /ROSWVA/
+SELF,IF=DOC,RODOC.
*
*   Cluster information filled in RSWCLS, and corrected in RSWCOR.
*
*       MAXCLS    max number of clusters allowed, should be same NMAX ROSWMG
*       MLAY      max number of layers allowed
*       MAXPAD    =MAXCLS*MLAY maximum number of pad maxs allowed
*       IRUN      guess!
*       IEVT      event number
*       IBUNCH    bunch number of event
*       IROPE     rope version number used to produce the DST data.
*       IDSTAT    SW detector status bits
*                 IDSTAT = 0  Status unknown (status words not available)
*                          1  status is bad
*                          2  possible problem, handle with care
*                          3  detector is okay
*       ITSTAT    SW trigger status bits
*                 ITSTAT = 1  Really bad
*                          3  trigger okay
*       LSSGx     logical trigger bit SW back to back Right/Left
*       LSLOx     logical trigger bit SW low threshold Right/Left
*       LSWH      logical trigger bit SWHIOR
*       LSSEG     logical trigger bit SW back to back
*       LSSGA     logical trigger bit SW back to back accidental
*       LSSUM     logical trigger bit SW total energy coincidence
*       LSSMA     logical trigger bit SW total energy coincidence accidental
*       LFDH      logical trigger bit FD left or right FD calorimeter energy
*                                        sum > threshold
*       LFSUM     logical trigger bit FD left and right FD calorimeter energy
*                                        sum > threshold
*       LFSEG     logical trigger bit FD left and right FD calorimeter
*                                        segments in coincidence
*       LFYZ1     logical event bit FYZ1 event
*       LFYZS     logical event bit FYZS
*       LFYZT     logical event bit FYZT
*       LTKMH     logical event bit Tokyo Multi-Hadron
*       LGPMH     logical filter bit Gold Plated Multi-Hadron
*       LLUET     logical event bit ETOTbar calorimeter selection
*       LLUEM     logical event bit EMAINbar calorimeter selection
*       LLUCU     logical event bit Cubed selection
*       LGMHST    logical Good Multi-Hadron STatus bit requires
*                 Detector    detector       trigger           TN025
*                              status        status
*                    CJ         >= 3          >= 0
*                    CV         >= 3          >= 0
*                    EB         >= 2          >= 2
*                    EE         >= 3          >= 3
*       LxCAL     logical trigger bit Right/Left FD calorimeter above threshold
*       LEBTL     logical trigger bit EB total energy above low threshold
*       LTBM1     logical trigger bit >= 1 barrel track
*       LBXR      logical trigger bit random beam crossing
*       LBXRS     logical trigger bit stand alone random trigger
*       LFGCxT    logical trigger bit FD Right/Left gamma catcher tag
*       LFSGA     logical trigger bit FD back to back accidental
*       LFDSGx    logical trigger bit FD seg energy above threshold, Right/Left
*       LSWITA    logical event bit SW in time average theta cut
*       LSWITx    logical event bit SW in time Right/Left
*       LSWOTx    logical event bit SW out of time Right/Left
*       LHTRO     logical trigger bit Half Tower Right Odd
*       LHTRE     logical trigger bit Half Tower Right Even
*       LHTLO     logical trigger bit Half Tower Left  Odd
*       LHTLE     logical trigger bit Half Tower Left  Even
*       LFTR      logical trigger bit Full Tower Right
*       LFTL      logical trigger bit Full Tower Left
*       LATHR     logical trigger bit All  Tower Right High
*       LATHL     logical trigger bit All  Tower Left  High
*       LGPEE     logical filter bit Gold Plated electron
*       LGPMM     logical filter bit Gold Plated muon
*       LGPTT     logical filter bit Gold Plated tau
*       LGPLL     logical filter bit Gold Plated lepton
*       LSWBH     logical filter bit SW bhabba
*       LFDBH     logical filter bit FD bhabba
*       LEELLO    logical trigger bit EE left above low threshold
*       LEERLO    logical trigger bit EE right above low threshold
*       NCLSx         number of em clusters in SW Right/Left calorimeter
*       Ex(NCLSx)     energy(GeV) of cluster in SW Right/Left
*       RADx(NCLSx)   radius(cm) of maximum energy cluster in SW Right/Left
*                     The radius at z = 246.0225 cm. layer 7 counting from 0.
*       PHIx(NCLSx)   phi(rad) of maximum energy cluster in SW Right/Left
*       THINTx(NCLSx) theta(rad) of shower internal to calorimeter Right/Left
*       SHDx(NCLSx)   Phil Hart longitudinal shower profile fit parameter
*                     (D) ratio of the energy in the first 4 layers to the
*                     energy in the rest of the cluster, Right/Left
*       SHAx(NCLSx)   Phil Hart longitudinal shower profile fit parameter
*                     (A) mean shower layer, Right/Left
*       RERRx(NCLSx)  error(cm) in the fit radius Right/Left
*       NPADx(NCLSx)  number of pads used in the cluster
*       ICTYPx(NCLSx) cluster type Right/Left
*                     1 electromagnetic
*                     2 track (should never occur)
*                     3 hadronic
*                     4 blob
*       NLOFFx(NCLSx) number of layers cluster finder shifted by Right/Left
*       RCENTx(NCLSx) z coordinate(rad lengths) of radial measurement
*                     Right/Left
*       E5TCx(NCLSx)  "contentious" 5-tower energy summed over 19 layers
*                     Right/Left
*       E15Cx(NCLSx)  "contentious" 15-pad energy summed over 19 layers
*                     Right/Left
*       E5TAx(NCLSx)  "assigned" 5-tower energy summed over 19 layers
*                     Right/Left
*       E15Ax(NCLSx)  "assigned" 15-pad energy summed over 19 layers
*                     Right/Left
*       EPKOx(NCLSx)  Peakedness for odd layers Right/Left
*       EPKEx(NCLSx)  Peakedness for even layers Right/Left
*       EQDOx(NCLSx)  Peak quadruplet energy sum for odd layers Right/Left
*       EQDEx(NCLSx)  Peak quadruplet energy sum for even layers Right/Left
*       NLAYx(NCLSx)  Number of layers used in theta fit Right/Left
*       ISHBx(NCLSx)  Starting layer of shower Right/Left
*       SHCx(NCLSx)   Shower compactness parameter Right/Left
*       NPx           NCLSx * 15
*       IPMAXx(NPx)   row number of the maximum pulse height pad in cluster
*                     Right/Left minimum of 6 counts on a pad. -1 otherwise
*                     NPx =  1 - 15   layers 0 - 14 highest energy cluster
*                     NPx = 16 - 30   layers 0 - 14 2nd highest energy cluster
*                     NPx = 31 - 45   layers 0 - 14 3rd highest energy cluster
*                     etc to a maximum NPx = 105 or NCLSx = 7
*       NTRKx         number of tracks in Right/Left calorimeter
*       ETx(NTRKx)    energy(GeV) of blob associated to track in
*                     Right/Left calorimeter
*       THTx(NTRKx)   theta(radians) of track in Right/Left calorimeter
*       PHTx(NTRKx)   phi(radians) of track in Right/Left calorimeter
*       NFCLSx         number of calorimeter clusters in FD Right/Left
*       EFx(NFCLSx)    energy(GeV) of cluster in FD Right/Left side
*       THETFx(NFCLSx) theta(rad) of cluster in FD Right/Left side
*       PHIFx(NFCLSx)  phi(rad) of cluster in FD Right/Left side
*       EPREFx(NFCLSx) energy(GeV) in the presampler FD Right/Left side
*       EMXx      energy(GeV) of the trigger cluster from the
*                 current beam crossing, Right/Left.
*       PHITx     phi (rad) associated with cluster EMXx Right/Left
*       EMXAx     energy(GeV) from the trigger cluster from one
*                 LEP revolution ago, Right/Left
*       PHITAx    phi (rad) associated with cluster EMXAx Right/Left
*       NPPRET    Number of BXs from Previous PRETrigger
*                 NPPRET = -1 means this information is not available,
*                             the scalar had not been installed yet,
*                             runs 4283 and before.
*                 NPPRET = -1 no pretriggers before this event, excluding
*                             of course the pretrigger for this event. So
*                             for example if OPAL dropped busy and the next
*                             pretrigger we took the event this would be
*                             0 BX's since last pretrigger (because the scalar
*                             is reset after each event and a pretrigger
*                             starts the scalar) even though it doesn't
*                             mean there were 0 BX's. In this case we set this
*                             variable to -1. In this case our trigger
*                             is probably okay because we had some BX's
*                             to refresh the trigger before OPAL dropped
*                             busy.
*       ETADCx    trigger energy (GeV) summed over all the individual ADC
*                 counts in the whole of one side of the detector, Right/Left
*       ETSRVx    same as ETADCx except measured AFTER the servo correct.
*       ITRATE       = 0 if no trigger rate information is available
*                    = 1 if    trigger rate information is available and
*                        reasonable, that is SEGR rate>0 and SEG rate<10.
*       SEGx(ITRATE) SWSEGR/L trigger rate in Hz
*       SEG(ITRATE)  SWSEG trigger rate in Hz
*       SEGA(ITRATE) SWSEGA trigger rate in Hz
*       BKG2(ITRATE) BKG2 sent to LEP.
*       NCJTR         = 0 if no charged track >  with momentum >0.15 GeV
*                     = 1 if    charged track >  with momentum >0.15 GeV
*       PCJTR(NCJTR)  signed momentum(GeV) of highest mom. charged track
*       THCJTR(NCJTR) theta(radians) of highest momentum charged track
*       PHCJTR(NCJTR) phi(radians) of highest momentum charged track
*       NEC           = 0 if no em cluster in EE or EB with E > 0.3 GeV
*                     =   if    em cluster in EE or EB with E > 0.3 GeV
*       EECAL(NEC)    = energy (GeV) of highest energy ECAL cluster
*       THECAL(NEC)   = theta (radians) of highest energy ECAL cluster
*       PHECAL(NEC)   = phi (radians) of highest energy ECAL cluster
*       EBEAM     beam energy (GeV)
*       CTHR      cosine of the thrust axis
*       XBEAM     x position(cm) of beam
*       YBEAM     y position(cm) of beam
*       ZBEAM     z position(cm) of beam
*       EVPEDx    event pedestal Right/Left
*       SYSEB     systematic error in the beam energy(GeV)
*       ESUMx     sum of energy(GeV) in right/left calorimeter
*       ZDET      The average z (cm) of layer 7 counting from 0 of both
*                 right and left calorimeters. This was determined from
*                 the position monitor readings at the time the batch
*                 job was run to produce the ntuple.
*       IDATE     date of event
*       ITIME     time of event
*       IFDDST    FD detector status
*       IBPOS     beam position quality
*                 ibpos = 0  if an average value has been returned
*                         1  if information specific to this run found
*                         -1 if called for MC data
*************************************************************************
+SEQ,ROSWVA.
+SELF. NKW 980406
+DECK,ROSWRB.
+KEEP,ROSWRB.
*
*-- Common with "rebuilt" cluster quantities
*
      REAL ERBR,ERBL
      REAL E15RBR,E15RBL
      INTEGER NRBR,NRBL
      INTEGER INDRBR,INDRBL
      INTEGER NCORER,NCOREL
      LOGICAL LCORER,LCOREL
      LOGICAL LJOINR,LJOINL
      REAL CUT0,CUT1,CUT2
*
      PARAMETER(CUT0=0.1)
      PARAMETER(CUT1=0.250)
      PARAMETER(CUT2=0.350)
*
      REAL DPJOIN,DRJOIN
      PARAMETER(DPJOIN=0.196350)
      PARAMETER(DRJOIN=3.00)
      REAL RBRMIN,RBRMAX
      PARAMETER(RBRMIN= 9.50)
      PARAMETER(RBRMAX=10.25)
*
*-- ERBx    = Energy of rebuilt clusters
*-- E15RBx  = 15 Pad Energy of rebuilt clusters
*-- NRBx    = Number of rebuilt clusters
*-- LCOREx  = Flag identifying "cores" of rebuilt clusters
*-- LJOINx  = Flag identifying "debris" rejoined to rebuilt clusters
*-- CUT0    = Maximum ratio of contentious / assigned 15pad energies
*-- CUT1    = Minimum peackedness
*-- CUT2    = Minimum ratio of  peak / quadruplet energies
*-- DPJOIN  = DPhi region within which to join busted cluster debris (rad)
*--           NB. DPJOIN = +- PI/16.
*-- DRJOIN  = DR Distance within which to join busted cluster debris (cm.)
*--           NB. DRJOIN = +- 6 PADS
*
      COMMON /ROSWRB/ERBR(MAXCLS),ERBL(MAXCLS),
     +               E15RBR(MAXCLS),E15RBL(MAXCLS),
     +               LCORER(MAXCLS),LCOREL(MAXCLS),
     +               LJOINR(MAXCLS),LJOINL(MAXCLS),
     +               NRBR,NRBL,
     +               INDRBR(MAXCLS),INDRBL(MAXCLS)
      SAVE /ROSWRB/
*
*-- Here store the 4 vectors of up to 7 rebuilt cluster combinations
*-- one each side: the merged clusters will be the right left pair
*-- Store also the PTMIN combo, and the PT for the 2 MAX clusters,
*-- as well as the PTMINO, for combinations other than 2 MAX clusters.
*-- Finally, keep track of the R and Phi for the merged four vectors.
*
      REAL EFTRYR,RTRYR,PHTRYR
      REAL EFTRYL,RTRYL,PHTRYL
      REAL PTMXCL,PTMIN,PTMINO
      REAL RWMGR,PHWMGR
      REAL RWMGL,PHWMGL
      INTEGER NTRYR,ITRYR
      INTEGER NTRYL,ITRYL
*
      COMMON /ROSWTR/EFTRYR(7),RTRYR(7),PHTRYR(7),
     +               EFTRYL(7),RTRYL(7),PHTRYL(7),
     +               PTMXCL,PTMIN,PTMINO,
     +               RWMGR,PHWMGR,
     +               RWMGL,PHWMGL,
     +               NTRYR,ITRYR,
     +               NTRYL,ITRYL
      SAVE /ROSWTR/
*
*-- D+5P    = Distance within which to use 15 pad energies
*--           (rather than total cluster energies) for coordinate
*--           weighting in merging (cm.)
*
      REAL D15P
      PARAMETER(D15P=2.0)
CNigel Watson 19980406+SEQ,ROSWRB.
+DECK,ROSWBM.
+KEEP,ROSWBM.
      REAL BSXMC,BSYMC,BSZMC
      INTEGER IBFL
*
      COMMON / BSCOM /BSXMC,BSYMC,BSZMC,IBFL
*
      LOGICAL LTILTY
      PARAMETER(LTILTY=.FALSE.)
*      SAVE LTILTY
*      DATA    LTILTY /.FALSE./
CNigel Watson 19980406+SEQ,ROSWBM.
+DECK,RODADPAR.
+KEEP,RODADPAR,IF=VAX.
      INCLUDE '($SSDEF)'
      INCLUDE '($SYSSRVNAM)'
      INCLUDE '($FABDEF)/LIST'
      INCLUDE '($RABDEF)/LIST'
      INCLUDE '($XABDEF)/LIST'
      INCLUDE '($XABFHCDEF)/LIST'
      INCLUDE '($NAMDEF)/LIST'
      INCLUDE '($RMSDEF)'
*
      INTEGER NDADBY
      PARAMETER (NDADBY=7*4)
      CHARACTER*(NDADBY) DADHED
      INTEGER MAXLUN
      PARAMETER (MAXLUN=50)
*
      INTEGER IDARUN,IDAEVT,IDAFIL,IDARFA,IDADDT
      COMMON/RDAPOS/IDARUN,IDAEVT,IDAFIL,IDARFA(2),IDADDT(2)
*
+KEEP,RODADPAR,IF=-VAX.
*
      INTEGER NDADBY
      PARAMETER (NDADBY=10*4)
      CHARACTER*(NDADBY) DADHED
*
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence RODADPAR
*
*  System include files  RODADPAR keep sequence.
*
************************************************************************
*
*
*   $SSDEF  : Contains system return codes for the VAX
*   $SYSSRVBAN: Contains system service entry point descriptions.
*   $FABDEF : Defines the FAB block
*   $RABDEF : Defines the RAB block
*   $XABDEF : Define general XAB block and
*                            file header characteristics version.
*   $NAMDEF : Define NAM block.
*   $RMSDEF : Defines the RMS return status codes.
*   NDADBY  : Number of bytes in DAD list record
*   MAXLUN  : Max size of arrays which contain lun's for the DAD,
*                                          DST and MAW DBS files.
*   IDARUN,IDAEVT,IDAFIL,IDARFA,IDADDT:
*     run, event, file index, RFA (record file address), and date and
*     time of file (in MAW$DBS; used to check that RFA applies to
*     current MAW$DBS entry for file index); for the next event to be
*     read; from the DAD list.
*
***********************************************************************
+SEQ,RODADPAR.
+DECK,RCFDBS.
+KEEP,RCFDBS,IF=-VAX.
      INTEGER    IBSEQ,JBSEQ,IBREC,JBREC,LENDBS,MXLFIL
      PARAMETER (IBSEQ=12,JBSEQ=20,IBREC=20,JBREC=0,LENDBS=160
     +          ,MXLFIL=132)
*
      CHARACTER*(MXLFIL) CLINE,CGEN,CFILE
      CHARACTER*20       CHOST
      CHARACTER*20       CTODAY
      INTEGER            ISEQ,IREC,IFSTEV,ILSTEV,IPARTI,IUNIQF
*
      COMMON/RCFDBS/ISEQ,IREC,IFSTEV,ILSTEV,IPARTI,IUNIQF
      COMMON/CCFDBS/CLINE,CGEN,CFILE,CHOST,CTODAY
*
+KEEP,RCFDBS,IF=VAX.
      INTEGER    IBSEQ,JBSEQ,IBREC,JBREC,LENDBS,MXLFIL
      PARAMETER (IBSEQ=12,JBSEQ=20,IBREC=20,JBREC=0,LENDBS=160
     +          ,MXLFIL=132)
*
      CHARACTER*(MXLFIL) CLINE,CGEN,CFILE
      CHARACTER*20       CHOST
      CHARACTER*20       CTODAY
      INTEGER            ISEQ,IREC,IFSTEV,ILSTEV,IPARTI,IUNIQF
*
      COMMON/RCFDBS/ISEQ,IREC,IFSTEV,ILSTEV,IPARTI,IUNIQF
      COMMON/CCFDBS/CLINE,CGEN,CFILE,CHOST,CTODAY
*
+SELF,IF=DOC,RODOC.
************************************************************************
*
*                  Sequence RCFDBS
*
*   ISEQ,IREC,IFSTEV,ILSTEV,IPARTI,IUNIQF
*   CLINE,CGEN,CFILE,CHOST,CTODAY
*   IDARUN,IDAEVT,IDAFIL,IDARFA,IDADDT:
*     run, event, file index, RFA (record file address), and date and
*     time of file (in MAW$DBS; used to check that RFA applies to
*     current MAW$DBS entry for file index); for the next event to be
*     read; from the DAD list.
*
***********************************************************************
+SEQ,RCFDBS.
+DECK,FMPAR.
+KEEP,FMPAR.
      INTEGER         FMLOCA,SELKEY,KEYLEN,MKCLFA,MKLCFA,MKMTFA
      PARAMETER      (KEYLEN=10,MKCLFA=7,MKMTFA=8,MKLCFA=9)
      LOGICAL         FATMEN
      COMMON  /FMPAR/ FATMEN,FMLOCA,SELKEY(KEYLEN)
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence FMPAR (used for FATMEN operation)
*
*******************************************************************
*
* FATMEN    : The FATMEN package has been initialized
* FMLOCA    : The FATMEN location code used for searches
* KEYLEN    : Number of Fatmen keys per entry (10)
* MKCLFA    : offset to copy level (=data type for OPAL) in FM keys
* MKLCFA    : offset to location code
* MKMTFA    : offset to media type
* SELKEY    : Selection keys to access the proper copy
*
******************************************************************
+SEQ,FMPAR.
+DECK,ROUNIT.
+KEEP,ROUNIT.
      INTEGER       NROPEU,NOSTRE,NXDEVI,
     +              VARNAM,ONEONE,DUMPER,NOCONS,ONEEVE,
     +              SAMTAP,CLSQUI,ANYWHE,AUTOPU,NEWTAP,EXPLIC,
     +              PLOTIT,DADLIS,NOSTRU,NANODS,EVTLIS,INDIRF,
     +              NOOPEN,ONLYHE,INDIRN,CPDATA
      PARAMETER    (NROPEU =99,NOSTRE = 9,NXDEVI = 8,
     +              VARNAM = 0,ONEONE = 1,DUMPER = 2,NOCONS = 3,
     +              ONEEVE = 4,SAMTAP = 5,CLSQUI = 6,ANYWHE = 7,
     +              AUTOPU = 8,NEWTAP = 9,EXPLIC =10,PLOTIT =11,
     +              DADLIS =12,NOSTRU =13,NANODS =14,EVTLIS =15,
     +              INDIRF =16,INDIRN =17,NOOPEN =18,ONLYHE =19,
     +              CPDATA=20)
*
      INTEGER       LASTCI,LASTCO,NDUMMY,NFZUSE,NCHAOU,LASTDO,
     +              EXADEV,EXALAS,NINPUT,LUNCAT,UNIOUT,
     +              LUDAIN,LASTDI,NEVDAD,LUNAIN,LUEVIN,
     +              LASTNI,LASTRE,IFCURE,ILCURE,
     +              MSFRUN,MSLRUN,MSNRUN,JFILE,NANREC,NFADAD
      LOGICAL       LEOFIN,LONEOF,LCLOSI,LAUTOU,LDVALL,LCATAL,
     +              LDADL,LNANO,LEVTL,LFZL,LDAOPE,LDADEX,
     +              LNOHEA,LMSOPE,LPACKO
      COMMON/ROUNIT/LASTCI,LASTCO,NDUMMY,LASTDO,LUDAIN,LASTDI,NEVDAD,
     +              LUNAIN,LUEVIN,LASTNI,LASTRE,IFCURE,ILCURE,MSFRUN,
     +              MSLRUN,MSNRUN,JFILE,NANREC,LEOFIN,LONEOF,LCLOSI,
     +              LAUTOU,LCATAL,LDADL,LNANO,LEVTL,LFZL,LDAOPE,LDADEX,
     +              LNOHEA,LMSOPE,NCHAOU(NROPEU),NFZUSE(NROPEU),EXALAS,
     +              LUNCAT,UNIOUT(NOSTRE),NINPUT,
     +              LDVALL(NXDEVI),EXADEV(NXDEVI),LPACKO,NFADAD
      CHARACTER*8   TAPMOU,UNIUSE
      CHARACTER*64  DVNAME
      COMMON/COUNIT/TAPMOU(NXDEVI),UNIUSE(NROPEU),DVNAME(NXDEVI)
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence ROUNIT
*
*******************************************************************
*
* NROPEU    : Maximum number of units known by Rope
* NOSTRE    : Maximum number of output streams in 'automatic unit' mode
* VARNAM    : Bit for flag: 'the name is variable'
* ONEONE    : Bit for flag: 'one input file -> one output file'
* DUMPER    : Bit for flag: 'disk DUMP and ERase'
* NOCONS    : Bit for flag: 'do not write constant records'
* ONEEVE    : Bit for flag: 'one event per file'
* SAMTAP    : Bit for flag: 'next file on same tape'
* CLSQUI    : Bit for flag: 'close file quietly'
* ANYWHE    : Bit for flag: 'take the file even on a different node'
* AUTOPU    : Bit for flag: 'auto put the write cartridge'
* NEWTAP    : Bit for flag: 'this tape is a new one'
* EXPLIC    : Bit for flag: 'take the file name with no node change'
* PLOTIT    : Bit for flag: 'plot this metafile when closed'
* DADLIS    : Bit for flag: 'this is a DADLIST'
* NOSTRU    : Bit for flag: 'unstructured exatape (exchange format)'
* NANODS    : Bit for flag: this is a (sub)-nanodst
* EVTLIS    : Bit for flag: this is an event list
* INDIRF    : Bit for flag: file indirectly opened by DAD or NanoDst
* INDIRN    : Bit for flag: NanoDst indirectly opened by an event list
* NOOPEN    : Bit for flag: Do not reopen, file already opened
* ONLYHE    : Bit for flag: Just read event headers on this file.
* DVNAME    : Name of setup/exabyte devices names
* EXADEV    : Number of the device allocated by the automatic allocation
* EXALAS    : Last device allocated by the automatic allocation
* LASTCI    : Last unit closed in the 'INPU'  stream
* LASTCO    : Last unit closed in one of the output streams
* LASTDO    : Last unit defined for one of the output streams
* LAUTO     : Flag to indicate the automatic unit mode
* LCLOSI    : The user requested to close the current input file
* LDVALL    : Is a device currently allocated ?
* LEOFIN    : Flag to indicate an End of File on input
* LUNCAT    : Logical unit used for CATALOG
* NCHAOU    : Number of times each unit was referrenced in output mode
* NDUMMY    : Counter of dummy files used so far
* NFZUSE    : Number of times each unit was opened
* NINPUT    : Number of input files processed so far.
* LONEOF    : At least one output stream wants to switch on input EOF
* UNIOUT    : Logical units corresponding to output streams
* UNIUSE    : Usage of all logical units
* LCATAL    : The ('User') file CATALOgs package has been initialized
* LDADL     : The current input file is a DADLIST
* LDAOPE    : The 'DATA IN' indirect file has been opened
* LNANO     : The current input file is a sequential nanodst
* LEVTL     : The current input file is an ASCII event list
* LDADEX    : Explain to the poor user what we are doing with DAD
* LUDAIN    : 'DATA IN' logical number when read from DADLIS
* LASTDI    : Index of last 'DATA IN' file read by a DAD list
* NEVDAD    : Number of events read in the current DAD list
* NFADAD    : Number of events skipped in the current DAD list
* LUNAIN    : 'DATA IN' logical number when read from NANODST
* LASTNI    : Index of last nanodst read by an event list
* LFZL      : The current input file is accessed in FZ-L mode
* JFILE     : Index of the current file
* NANREC    : Index of the last record read
* LASTNI    : Last file accessed by nanodst access
* LASTRE    : Last run number accessed by event list
* LUEVIN    : Unit to access the nanodst from the event list
* IFCURE    : First current event in the nanodst
* ILCURE    : Last  current event in the nanodst
* MSNRUN    : Number of runs for Master nanodst access
* MSFRUN    : First run for Master nanodst access
* MSLRUN    : Last run for Master nanodst access
* CPDATA    : The data are to be (un)packed
* LPACKO      Do we want to pack on output?
*
******************************************************************
+SEQ,ROUNIT.
+DECK,RCSYST.
+KEEP,RCSYST.
      INTEGER        SYSRC,LCHNOD,MAILSN,LUPHON,ITIMEO,JOBPID,JENTRY,
     +               JMODE
      LOGICAL        BNOTIF,LPHONE,PHONSA,GOTCMD,TIMSET,LPLOT,LHEPVM
      COMMON /RCSYST/SYSRC,LCHNOD,MAILSN,LUPHON,ITIMEO,JOBPID,JENTRY,
     +               JMODE,
     +               BNOTIF,LPHONE,PHONSA,GOTCMD,TIMSET,LPLOT,LHEPVM
      CHARACTER*132  SYSCOM,BCOMND
      CHARACTER*16   CHNODE,JOBNAM,SENDER,USRNAM
      CHARACTER*40   PLTOPT
      CHARACTER*5    CHENTR
      CHARACTER*20   PLTCMD,PLTTER
      CHARACTER*31   CHQUEU
      COMMON /CCSYST/SYSCOM,BCOMND,
     +               CHNODE,JOBNAM,SENDER,USRNAM,
     +               PLTOPT,
     +               CHENTR,
     +               PLTCMD,PLTTER,
     +               CHQUEU
+SELF,IF=DOC,RODOC.
*******************************************************************
*
*                  Sequence RCSYST: SYSTem parameters
*
*******************************************************************
*
* BCOMND    : Command received from the batch phoning system
* BNOTIF    : This system supports batch notification to submitter
* CHENTR    : Batch Job entry number (Vax only)
* CHNODE    : Name of the (vax)node or (apollo)station or (VM)system
* CHQUEU    : Batch queue name (Vax only)
* GOTCMD    : A new command was received from the batch phoning system
* ITIMEO    : Set to 1 if time-out occured
* JENTRY    : Batch Job Entry number (Vax only)
* JMODE     : Job running mode (Interactive or batch mode) (Vax only)
* JOBNAM    : Name of the batch job
* JOBPID    : Process Identifier of this (batch) job (Vax only)
* LCHNOD    : Visible length of CHNODE
* LHEPVM    : The system is running the HEPVM environment
* LPHONE    : This system supports batch interrogation from submitter
* LPLOT     : A plotter has been defined
* LUPHON    : Logical unit booked for the phone batch interrogation file
* MAILSN    : Number of mails sent so far.
* PHONSA    : Save the vax phoning file (default is delete it)
* PLTCMD    : command to plot
* PLTOPT    : options to be passed to the plot command
* PLTTER    : plotter name
* SENDER    : Name of the job submitter
* SYSCOM    : The command to be passed to the system
* SYSRC     : Return code of the last command
* TIMSET    : An event time-out flag was set
* USRNAM    : Name of the job owner (username)
*
******************************************************************
+SEQ,RCSYST.
+DECK,ROWORD.
+KEEP,ROWORD,IF=-CRAY.
      INTEGER        NBITSW,NBYTEW
      PARAMETER     (NBITSW=32,NBYTEW=4)
+KEEP,ROWORD,IF=CRAY.
      INTEGER        NBITSW,NBYTEW
      PARAMETER     (NBITSW=64,NBYTEW=8)
+DECK,RBITFUNC.
+KEEP,RBITFUN0.
*-- RBITFUN0: declares bit functions for all machines
      LOGICAL   BTEST
      INTEGER   IAND ,    IOR,   IEOR,    NOT
      INTEGER   ISHFT,  IBSET,  IBCLR
      INTEGER   IBITS, ISHFTC
*
+KEEP,RBITFUNC,IF=NOBITFUN.
*-- force all bit functions to be external (without regard to machine)
+SEQ,RBITFUN0.
      EXTERNAL  BTEST
      EXTERNAL  IAND ,    IOR,   IEOR,    NOT
      EXTERNAL  ISHFT,  IBSET,  IBCLR
      EXTERNAL  IBITS, ISHFTC, MVBITS
*
+KEEP,RBITFUNC,IF=IBM.
*--   RBITFUNC: IBM has the ANSI, but not MIL-STD functions.
+SEQ,RBITFUN0.
      INTRINSIC BTEST
      INTRINSIC IAND ,    IOR,   IEOR,    NOT
      INTRINSIC ISHFT,  IBSET,  IBCLR
      EXTERNAL  IBITS, ISHFTC, MVBITS
*
+KEEP,RBITFUNC,IF=VAX,SGI,HPUX,DECS,QMALPH,QMVAOS,PCLINUX.
*-- RBITFUNC: VAX and SGI,HPUX have ANSI and MIL-STD functions
+SEQ,RBITFUN0.
      INTRINSIC BTEST
      INTRINSIC IAND ,    IOR,   IEOR,    NOT
      INTRINSIC ISHFT,  IBSET,  IBCLR
      INTRINSIC IBITS, ISHFTC, MVBITS
*
+KEEP,RBITFUNC,IF=IBMRT,SUN.
*-- RBITFUNC: IBMRT has almost ANSI and MIL-STD functions (no MVBITS)
+SEQ,RBITFUN0.
      INTRINSIC BTEST
      INTRINSIC IAND ,    IOR,   IEOR,    NOT
      INTRINSIC ISHFT,  IBSET,  IBCLR
      INTRINSIC IBITS, ISHFTC
      EXTERNAL  MVBITS
*
+KEEP,RBITFUNC,IF=CRAY.
*-- RBITFUNC: CRAY has all; but MVBITS is a function so can't use it
+SEQ,RBITFUN0.
      INTRINSIC BTEST
      INTRINSIC IAND ,    IOR,   IEOR,    NOT
      INTRINSIC ISHFT,  IBSET,  IBCLR
      INTRINSIC IBITS, ISHFTC
      EXTERNAL  MVBITS
*
+KEEP,RBITFUNC,IF=APOLLO.
*-- RBITFUNC: Apollo is a stupid machine with only one std bit function.
+SEQ,RBITFUN0.
      EXTERNAL  BTEST
      EXTERNAL  IAND ,    IOR,   IEOR
      INTRINSIC NOT
      EXTERNAL  ISHFT,  IBSET,  IBCLR
      EXTERNAL  IBITS, ISHFTC, MVBITS
*
+KEEP,RBITFUNC.
*-- all machines not known have bit functions declared external.
+SEQ,RBITFUN0.
      EXTERNAL  BTEST
      EXTERNAL  IAND ,    IOR,   IEOR,    NOT
      EXTERNAL  ISHFT,  IBSET,  IBCLR
      EXTERNAL  IBITS, ISHFTC, MVBITS
*
+SELF,IF=DOC,RODOC.
******************************************************************
*
*  RBITFUNC  Delares bit functions correctly for each machine.(A M Lee)
*
*           Use only ANSI/ISA-S61.1 and MIL-STD-1753 bit functions.
*           Bits are numbered from 0 (not 1 as is OPAL standard).
*           BTEST,IAND,IOR,IEOR,NOT,ISHFT,IBSET,IBCLR are ANSI STD,
*           while those plus ISHFTC,MVBITS,IBITS are the MIL-STD.
*           All are declared as INTEGER or LOGICAL (BTEST), except
*           MVBITS, which is a subroutine, and all are also declared
*           INTRINSIC or EXTERNAL, depending on what the particular
*           machines compiler has for intrinsic functions/subroutines.
*           EXTERNAL procedures will come from the BITPAK (CERN KERNLIB)
*           library.
*
*           >>>ADVICE TO USERS OF BIT FUNCTIONS<<<
*
*           Use the ANSI standard routines first (most general) and
*           the MIL-STD ones only when necessary; don't use
*           any functions that aren't here, since they will be slower
*           on all machines, while the BITPAK (CERNLIB) versions of
*           these routines will only be slower on some machines.
*           Use FIND BITPAK on CERNVM or HELP FORTRAN INTRINSIC on
*           VAX's to find out the definitions of these functions.
*
*           WARNING: best use these only on standard length integers
*           (type INTEGER; 4 bytes on most machines and 8 bytes
*           on the CRAY), where the destination is also an INTEGER
*           (except for BTEST, of course).
*
******************************************************************
+SEQ,RBITFUNC.
+DECK,RECOVER.
+KEEP,RECOVERDEC,IF=IBM.
      EXTERNAL ROTRAP
+KEEP,RECOVERCODE,IF=IBM.
*--         Handle IBM error conditions at run time.
      CALL ERRSET(118,256,10,0,ROTRAP,119)
      CALL ERRSET(207,256,10,0,ROTRAP,210)
      CALL ERRSET(241,256,10,0,ROTRAP,301)
+KEEP,RECOVERDEC,IF=VAX.
*--   Declare a standard ROPE VAX error handler.  Handles errors
*--   which are not handled "well" otherwise.  If additional
*--   errors need to be handled, the modifications should be made
*--   to ROTRAP, NOT in RMAINx.
      INTEGER ROTRAP
      EXTERNAL ROTRAP
+KEEP,RECOVERCODE,IF=VAX,IF=-QMALPH.
      CALL ERRSET(70,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(71,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(72,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(73,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(74,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(82,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(83,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(84,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(87,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(88,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
      CALL ERRSET(89,.TRUE.,.FALSE.,.FALSE.,.TRUE.,99)
*--   Now establish the ROPE error handler; in principle all the above
*--   ERRSET calls could be replaced by code in ROTRAP, but why bother?
      CALL LIB$ESTABLISH(ROTRAP)
+KEEP,RECOVERCODE,IF=QMALPH.
*--   Now establish the ROPE error handler
      CALL LIB$ESTABLISH(ROTRAP)
+KEEP,RECOVERDEC,IF=ERRECO,IF=QMVAOS.
*
* for OSF use DECS switch as well, so have to put this KEEP before the true
* (null) DECS one
*
      EXTERNAL  ROTRAP,SIGNAL
      INTEGER*4 SIGRET,SIGNAL,SIGNUM
*
+KEEP,RECOVERCODE,IF=ERRECO,IF=QMVAOS.
*
*     can't use REPORT because no RCREP sequence in RMAINB (at the moment)
      PRINT *,'Will initialize OSF/1 exception handler'

*     interrupt process signal
      SIGNUM=2
      SIGRET=SIGNAL(SIGNUM,ROTRAP,-1)
*     arithmetic or floating point error
      SIGNUM=8
      SIGRET=SIGNAL(SIGNUM,ROTRAP,-1)
*     terminate process signal
      SIGNUM=15
      SIGRET=SIGNAL(SIGNUM,ROTRAP,-1)
*
+KEEP,RECOVERDEC,IF=SGI.
*     SGI doesnt need recover declarations
+KEEP,RECOVERCODE,IF=SGI.
*--   produces a traceback on SGI, ERRSET is a C language routine,
*--   and can found in /u/ws/opal/pro/cern_fix/errset.c
      CALL ERRSET
+KEEP,RECOVERDEC,IF=HPUX.
      EXTERNAL ROTRAP,ROTRAO,ROTRAU,ROTRAI
      EXTERNAL ROTRDD,ROTRDO,ROTRDU,ROTRDI
+KEEP,RECOVERCODE,IF=HPUX.
*-- first ignore the signals
      ON REAL*8 OVERFLOW  IGNORE
      ON REAL*8 UNDERFLOW IGNORE
*-- now DLAMCH can check the machine precision
      CALL DLAMCH('S')
*--         Handle HPUX error conditions at run time.
      ON REAL DIV 0     CALL ROTRAP
      ON REAL OVERFLOW  CALL ROTRAO
      ON REAL UNDERFLOW CALL ROTRAU
      ON REAL ILLEGAL   CALL ROTRAI
      ON REAL*8 DIV 0     CALL ROTRDD
      ON REAL*8 OVERFLOW  CALL ROTRDO
      ON REAL*8 UNDERFLOW CALL ROTRDU
      ON REAL*8 ILLEGAL   CALL ROTRDI
+KEEP,RECOVERDEC,IF=APOLLO.
%include '/sys/ins/base.ins.ftn'
%include '/sys/ins/fpp.ins.ftn'
      INTEGER*2  FP_ENAB
      INTEGER*4  STATUS
+KEEP,RECOVERCODE,IF=APOLLO,IF=ONLINE.
      FP_ENAB = 0
      CALL FPP_$SET_TRAP_ENABLES(FP_ENAB,STATUS)
      IF(STATUS.NE.0) THEN
         WRITE(6,1000) STATUS
 1000    FORMAT(' Return code from SET_TRAP_ENABLES = ',Z6)
         CALL END_C(76)
         STOP
      END IF
+KEEP,RECOVERCODE,IF=APOLLO,IF=-ONLINE.
      FP_ENAB = 0
      CALL FPP_$SET_TRAP_ENABLES(FP_ENAB,STATUS)
      IF(STATUS.NE.0) THEN
         WRITE(6,1000) STATUS
 1000    FORMAT(' Return code from SET_TRAP_ENABLES = ',Z6)
         STOP
      END IF
+KEEP,RECOVERDEC,IF=DECS.
*     no error recover (yet)
+KEEP,RECOVERCODE,IF=DECS.
*     no error recover (yet)
+KEEP,RECOVERDEC,IF=IBMRT.
*     no error recover (yet)
+KEEP,RECOVERCODE,IF=IBMRT.
*     no error recover (yet)
+KEEP,RECOVERDEC,IF=ERRECO,IF=SUN.
*
      EXTERNAL ROTRAP
      INTEGER IJKSUN,IEEE_HANDLER,SIGNALF
      INTEGER III,JJJ(20)
      DATA JJJ/1,2,3,4,5,6,7,8,10,11,12,13,21,22,24,25,27,29,30,31/
*
+KEEP,RECOVERCODE,IF=ERRECO,IF=SUN.
*
      CALL STANDARD_ARITHMETIC()
      IJKSUN=IEEE_HANDLER('set','common',ROTRAP)
** 'underflow' occurs frequently, and is generally harmless.
**      IJKSUN=IEEE_HANDLER('set','underflow',ROTRAP)
** likewise 'inexact'
**      IJKSUN=IEEE_HANDLER('set','inexact',ROTRAP)
**      DO 98765 III=1,20
**         IJKSUN=SIGNALF(JJJ(III),ROTRAP,-1)
**98765 CONTINUE
*
+KEEP,RECOVERDEC,IF=CRAY.
*     no error recover (yet)
+KEEP,RECOVERCODE,IF=CRAY.
*     no error recover (yet)
+KEEP,RECOVERDEC.
*     no error recover for unknown machine
+KEEP,RECOVERCODE.
*     no error recover for unknown machine
+DECK,MZBITS.
+KEEP,MZBITS.
*     taken from ZEBRA CAR on CERNLIB 321 on 21-Feb-92, add *decl
*     comment decl since already in EM308 !!!!!
*      INTEGER         IQDROP,    IQMARK,    IQCRIT,    IQSYSX
      PARAMETER      (IQDROP=25, IQMARK=26, IQCRIT=27, IQSYSX=28)
+PATCH,ROCTYPE.
+KEEP,RGAMCM.
*
*       NTRKS   number of tracks with 30 CJ hits
*       NTRKSP  number of tracks with 30 CJ hits pointing at origin
*       PTTRKX  maximum pt of tracks pointing to origin
*       ESUMB   sum of energy near largest energy EB cluster
*       ETSUME  sum of trans. energy near largest trans. energy EE clus
*       NLAYRD  maximum number of HCAL layers hit in 45 degree road
*       MBIT    bit pattern of MB,ME,HB muon segments
*       EBTH    theta of maximum energy EB cluster
*       EBPH    phi of maximum energy EB cluster
*       EETH    theta of maximum transverse energy EE cluster
*       EEPH    phi of maximum transverse energy EE cluster
*
      INTEGER NTRKS,NTRKSP,NLAYRD,MBIT
      REAL PTTRKX,ESUMB,ETSUME,EBTH,EBPH,EETH,EEPH
      COMMON/RGAMCM/NTRKS,NTRKSP,PTTRKX,ESUMB,ETSUME,NLAYRD,MBIT,
     +              EBTH,EBPH,EETH,EEPH
*
+KEEP,RGEMCM.
*
      REAL RGEMMX
*
      COMMON/RGEMCM/RGEMMX
*
+KEEP,RPHCCM.
*
      INTEGER NCONV
      REAL DXYFIR,ETFIR,DXYMIN,ETMAX
*
      COMMON/RPHCCM/NCONV,DXYFIR,ETFIR,DXYMIN,ETMAX
*
+KEEP,HLCUTS.
*
* Control variables for heavy lepton selection
*
      INTEGER NGDMN,GNCJMN
      REAL D0TGHT,Z0TGHT,PTTGHT,GCOSMX,GD0MX,GZ0MX,GPXYMN,EEBTHR,EEETHR,
     +     DPHIMX,DTHEMX,THRKCT,EVISMN,EVISMX,PTOFST,PTFACT,
     +     PISMN1,PISMN2,HLFANG,SUMPMX,EEXTMX,
     +     CSISMX,THRKEC,
     +     ACOLMN,TMSMN
      COMMON/HLCUTS/D0TGHT,Z0TGHT,PTTGHT,
     +  NGDMN,GCOSMX,GD0MX,GZ0MX,GPXYMN,GNCJMN,
     +  EEBTHR,EEETHR,
     +  DPHIMX,DTHEMX,THRKCT,THRKEC,
     +  EVISMN,EVISMX,PTOFST,PTFACT,
     +  PISMN1,PISMN2,HLFANG,SUMPMX,EEXTMX,CSISMX,
     +  ACOLMN,TMSMN
*
* Control parameters in HLCUTS common:
*  Parameter  Default  Meaning
*  ---------  -------  -------
*
*   D0TGHT      0.5    Maximum |dca| in x-y plane | >= 1 track / event
*   Z0TGHT     40.     Maximum |dca| in z         | must satisfy these
*   PTTGHT      0.15   Minimum transverse p       | three requirements
*
*   NGDMN       2      Minimum number of "good" central tracks
*   GCOSMX      0.985  Maximum value of |cos(theta)| allowed
*                      for good track
*   GPXYMN      0.15   Minimum pxy for good track
*   GD0MX       1.     Maximum value (cm) of |d0| for good track
*   GZ0MX      80.     Maximum value (cm) of |z0| for good track
*   GNCJMN     30      Minimum number of CJ hits for good track
*
*   EEBTHR      0.10   Minimum energy for good EB cluster
*   EEETHR      0.20   Minimum energy for good EE cluster
*   DPHIMX      0.05   Maximum difference in phi between ctrk and
*                      an associated ecal cluster
*   DTHEMX      0.15   Maximum difference in theta between ctrk and
*                      an associated ecal cluster
*   THRKCT      0.5    Minimum momentum for ctrk to be included in
*                      4-vector calculations
*   THRKEC      0.5    Minimum energy for ecal cluster to be included in
*                      4-vector calculations
*
*
*    Following parameters are for missing energy / momentum selection
*
*   EVISMN      7.0    Minimum visible energy (charged + neutral)
*   EVISMX     70.0    Maximum    "      "        "        "
*   PTOFST      7.0    Offset in event pperp and
*   PTFACT      0.17   scaling factor used in requirement:
*
*            PPERP >= PTOFST + PTFACT * EVISI
*
*
*    Following parameters used in isolated track / nondilepton selection
*
*   HLFANG      0.524  Half-angle of search cone for isolated tracks
*   PISMN1      5.0    Minimum momentum of isolated track candidate
*   PISMN2      2.0    Minimum momentum of 2nd track in event
*   SUMPMX      1.     Maximum sum of |p| for good tracks in cone
*   CSISMX      0.9    Maximum |cos(theta)| for isolated track
*   EEXTMX      4.     Maximum sum of |E| for good EC clusts in cone
*                      not associated to isolated track itself
*
*   ACOLMN      0.250  Acolineariy cutoff for "dilepton" events
*   TMSMN       2.5    Transverse mass cutoff for "dilepton" events
*
*
+KEEP,HLODCM.
*
* Miscellaneous variables sent to ODBOOK for later filling by ODFILL
* (Variable names correspond directly to those in OD banks)
*
      INTEGER NCTRKM,NECALM,ENCTMX
      PARAMETER (NCTRKM=1000, NECALM=1000, ENCTMX=10)
      INTEGER GNCTR,GNECA,NCTRK,NECAL,CQUAL,CNHCJ,CIECA,ESOUR,EQUAL,
     +        ENCTR,EICTR
      REAL GEBEA,CPX,CPY,CPZ,CPXY,CP,CD0,CZ0,CQ,CPHI0,CPHEC,CTHEC,
     +     EE,ETHET,EPHI,EFRMX,EPX,EPY,EPZ
      COMMON/HLODCM/GNCTR,GNECA,GEBEA,NCTRK,NECAL,
     +  CPX(NCTRKM),CPY(NCTRKM),CPZ(NCTRKM),CPXY(NCTRKM),CP(NCTRKM),
     +  CD0(NCTRKM),CZ0(NCTRKM),CQUAL(NCTRKM),CNHCJ(NCTRKM),
     +  CIECA(NCTRKM),CQ(NCTRKM),CPHI0(NCTRKM),CPHEC(NCTRKM),
     +  CTHEC(NCTRKM),
     +  EE(NECALM),ETHET(NECALM),EPHI(NECALM),ESOUR(NECALM),
     +  EFRMX(NECALM),EPX(NECALM),EPY(NECALM),EPZ(NECALM),
     +  EQUAL(NECALM),ENCTR(NECALM),EICTR(ENCTMX,NECALM)
+KEEP,P4VEC.
*
* Buffer for 4-vector storage
*
      INTEGER N4VMAX
      PARAMETER (N4VMAX=200)
      INTEGER N4VECT
      REAL P4VTOT,P4VECT
      COMMON /P4VEC/ N4VECT,P4VTOT(4),P4VECT(4,N4VMAX)
*
* N4VECT        Total number of 4-vectors created (max=200).
* P4VTOT(4)     Sum of P4VECT.
* P4VECT(4,N4V) 4-momentum of each particle (from CTRK and ECAL).
*
* Local constants
*
+KEEP,HLCONS.
      COMMON/HLCONS/PI,TWOPI,RADIAN
      REAL PI,TWOPI,RADIAN
*
+KEEP,ROCHCU.
      REAL            CHTRQU(9) ,CHECQU(3) ,CHSEL1(10),CHSET1(10),
     +                CHSEL2(13),CHSET2(13),CHSEL3(9) ,CHSET3(9)
      COMMON /ROCHCU/ CHTRQU    ,CHECQU    ,CHSEL1    ,CHSET1    ,
     +                CHSEL2    ,CHSET2    ,CHSEL3    ,CHSET3
+SELF,IF=DOC,RODOC.
*     Selection criteria used in ROCHSE routine:
*            CHTRQU: track quality criteria
*            CHECQU: ECAL quality criteria
*            CHSEL1: cut values for loose general acoplanar selection
*            CHSET1: cut values for tight general acoplanar selection
*            CHSEL2: cut values for loose low multiplicity selection
*            CHSET2: cut values for tight low multiplicity selection
*            CHSEL3: cut values for loose monojet selection
*            CHSET3: cut values for tight monojet selection
*
+KEEP,ROCHVA.
      REAL    EHEM(2),EFDCL1,EFDCL2,EVIS,EBEAM,ACOPLA,COTHTH,
     +        COTHPM,COSJMX,EFRAC,PT,ECONJ1,ECONJ2,EOUT,PCOMB(5)
      INTEGER NGOCTR
      COMMON /ROCHVA/ EHEM,EFDCL1,EFDCL2,EVIS,EBEAM,ACOPLA,COTHTH,
     +        COTHPM,COSJMX,EFRAC,PT,ECONJ1,ECONJ2,EOUT,PCOMB,
     +        NGOCTR
+SELF,IF=DOC,RODOC.
*      Cut quantities used for chargino selection
*          EHEM(2) : Energy in hemispheres
*          EFDCL1/2: FD energy on left/right side
*          EVIS    : Visible energy
*          EBEAM   : Beam energy
*          ACOPLA  : Acoplanarity angle
*          COTHTH  : Cos(theta_thrust)
*          COTHPM  : Cos(theta_p_miss)
*          COSJMX  : Cos(theta_jet_max)
*          EFRAC   : Energy fraction of charged tracks in forward region
*          PT      : Transverse momentum
*          ECONJ1/2: Jet energies (20^o cones)
*          EOUT    : Energy not contained in cones
*          PCOMB(5): Combined momentum
*          NGOTR   : Number of good tracks
*
+PATCH,ROMAIN.
+DECK,RMAINB.
+SELF,IF=-ONLINE.
      PROGRAM RMAINB
+SELF,IF=ONLINE.
      SUBROUTINE ROPE
+SELF.
*.
*...RMAINB Main program for batch running
*.
*.         The size of GEANT and ROPE stores are defined here with
*.         parameters cards.The size of the blank common is also set.
*.
*. COMMON  : GCBANK PAWC BLANK
*. CALLS   : RCNTLB
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-87
*. LAST MOD: 13-Feb-92
*.
*. Modification Log.
*. 13-Feb-92  O.Schaile      remove OPEN(UNIT= 5 for Apollo
*. 29-Nov-91  O.Schaile      Add HPUX error handling
*. 10-Nov-91  A.Lee          Add SGI error handling; only traceback.
*. 10-Nov-91  A.Lee          Add VAX error handler - ROTRAP (like IBM).
*. 23-Jan-91  D.Lellouch     Open GKS error file in GRGKSI.
*. 11-Oct-90  S.Weisz        Modify error recovery on Apollo.
*. 16-Mar-90  S.Weisz        Inplement error recovery on Apollo.
*.  8-Sep-89  S.Weisz        Size of REPORT store defined here.
*.  3-May-89  S.Weisz        FFREAD card to be read on unit 5.
*. 15-Feb-89  S.Weisz        Optionnal run time error recovery on VAX.
*.                           Open FFREAD (unit=4) and GKS error (unit=37)
*. 13-Sep-88  S.Weisz        Optionnal handling of IBM error conditions.
*.  6-Apr-88  S.Weisz        HBOOK4 only.
*. 14-Mar-88  S.Weisz        Set size ZEBRA in NZMEM.
*. 27-Oct-87  S.Weisz        Set size of common PAWC.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      EXTERNAL ZTELUS,QNEXT,ZEND
+SEQ,RECOVERDEC,IF=ERRECO.
      INTEGER NZMEM,NHMEM,NRMEM
      INTEGER IGEANT,MEMOR,IREPOR
+SELF,NZMEM.
      PARAMETER (NZMEM=601000)
+SELF,NHMEM.
      PARAMETER (NHMEM=50000)
+SELF,NRMEM.
      PARAMETER (NRMEM=40000)
+SELF.
      COMMON/GCBANK/IGEANT(NZMEM)
      COMMON/PAWC/MEMOR(NHMEM)
      COMMON/REBANK/IREPOR(NRMEM)
+SELF,IF=APOLLO.
      INTEGER NAME
      COMMON/UQNEXT/NAME
*--         Trick to get proper QNEXT on APOLLO (Pb with inlibs)
      NAME=IADDR(QNEXT)
*--         You must open all files on Apollo (FFREAD and GKS error)
*           no longer needed
*      OPEN(UNIT= 5,FILE='rope.data')
+SELF.
*--         Size of GEANT store.
      IGEANT(1)=NZMEM-1000
*--         Size of HBOOK common block.
      MEMOR(1)=NHMEM
*--         Size of REPORT store.
      IREPOR(1)=NRMEM-100
+SEQ,RECOVERCODE,IF=ERRECO.
      CALL RCNTLB
*
      END
*
      SUBROUTINE QNEXT
*.
*...QNEXT    Get control in case of recoverable ZEBRA troubles.
*.
*. CALLS   : ROEVNT ZEND
*. CALLED  : QNEXTE
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 11-Feb-88
*. LAST MOD: 11-Feb-88
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CALL ROEVNT
      CALL ZEND
      END
+DECK,RMAINI.
      PROGRAM RMAINI
*.
*...RMAINI Main program for interactive running
*.
*.         The size of GEANT and ROPE stores are defined here with
*.         parameters cards.The size of the blank common is also set.
*.
*. COMMON  : GCBANK PAWC BLANK
*. CALLS   : RCNTLI
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-87
*. LAST MOD: 18-May-92
*.
*. Modification Log.
*. 18-May-92  O.Schaile      put back OPEN(UNIT= 4 for Apollo
*. 13-Feb-92  O.Schaile      remove OPEN(UNIT= 4 for Apollo
*. 29-Nov-91  O.Schaile      Add HPUX error handling
*. 10-Nov-91  A.Lee          Add SGI error handling; only traceback.
*. 10-Nov-91  A.Lee          Add VAX error handler - ROTRAP (like IBM).
*. 23-Jan-91  S.Weisz        Open GKS error file in GRGKSI.
*. 11-Oct-90  S.Weisz        Modify error recovery on Apollo.
*. 16-Mar-90  S.Weisz        Inplement error recovery on Apollo.
*.  8-Sep-89  S.Weisz        Size of REPORT store defined here.
*. 15-Feb-89  S.Weisz        Optionnal run time error recovery on VAX.
*.                           Open FFREAD (unit=4) and GKS error (unit=37)
*.  6-Apr-88  S.Weisz        HBOOK4 only; set KUIP size in NKMEM.
*. 14-Mar-88  S.Weisz        Set size ZEBRA in NZMEM.
*. 27-Oct-87  S.Weisz        Set size of common PAWC.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      EXTERNAL ZTELUS,QNEXT,ZEND
+SEQ,RECOVERDEC,IF=ERRECO.
      INTEGER NZMEM,NHMEM,NKMEM,NRMEM
      INTEGER IGEANT,MEMOR,IREPOR
+SELF,NZMEM.
      PARAMETER (NZMEM=601000)
+SELF,NHMEM.
      PARAMETER (NHMEM=50000)
+SELF,NKMEM.
      PARAMETER (NKMEM=10000)
+SELF,NRMEM.
      PARAMETER (NRMEM=40000)
+SELF.
      COMMON/GCBANK/IGEANT(NZMEM)
      COMMON/PAWC/MEMOR(NHMEM)
      COMMON/REBANK/IREPOR(NRMEM)
+SELF,IF=APOLLO,IF=-SGI.
      INTEGER NAME
      COMMON/UQNEXT/NAME
*--         Trick to get proper QNEXT on APOLLO (Pb with inlibs)
      NAME=IADDR(QNEXT)
*--      With this on Apollo: READ 4 will work and read rope.data
      OPEN(UNIT= 4,FILE='rope.data')
+SELF.
*--         Size of GEANT store.
      IGEANT(1)=NZMEM-1000
*--         Size of HBOOK common block.
      MEMOR(1)=NHMEM
      MEMOR(2)=NKMEM
*--         Size of REPORT store.
      IREPOR(1)=NRMEM-100
+SEQ,RECOVERCODE,IF=ERRECO.
      CALL RCNTLI
*
      END
*
      SUBROUTINE QNEXT
*.
*...QNEXT    Get control in case of recoverable ZEBRA troubles.
*.
*. CALLS   : ROPINT ZEND
*. CALLED  : QNEXTE
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 11-Feb-88
*. LAST MOD: 30-Mar-94
*.
*. Modification Log.
*. 30-Mar-94 O.Schaile       Move call to KUINIM to RCNTLI
*.  1-Feb-94  O.Schaile      Add KUIP Motif
*. 13-Jun-89  S.Weisz        Call KUWHAG if Patchy selected.
*.  6-Apr-88  S.Weisz        Call KUWHAT.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SELF,IF=KUWHAM.
*      CALL KUINIM('GRope++')
      CALL KUEXEC('exec grope_panel')
      CALL KUWHAM('GRope++')
+SELF,IF=KUWAG.
      CALL KUWHAG
+SELF,IF=-KUWAG,IF=-KUWHAM.
      CALL KUWHAT
+SELF.
      CALL ZEND
      END
+PATCH,ROKERN.
+DECK,RALLDV,IF=VAX.
      SUBROUTINE RALLDV(DEVPRE,DEVNAM,NDEV,NALL)
*.
*...RALLDV Allocate the first free device(s) which has(ve) a name
*.         starting with the device prefix DEVPRE
*.
*. INPUT     : DEVPRE is the device prefix string: the name ended with
*.                    a ":" means a specific device name, otherwise we
*.                    search for a generic device name.
*.             NDEV is the number of devices with the prefix DEVPRE you
*.                  want to allocate
*.
*. OUTPUT    : DEVNAM is a character vector containing the names of the
*.                     allocated devices
*.             NALL is the number of allocated devices
*.
*. SEQUENCES : DECLARE RCREP
*. CALLS     : REPORT SYS$ALLOC LIB$SIGNAL LENOCC SPACES
*. CALLED    : RGETDV
*.
*. AUTHOR    : F.Odorici
*. VERSION   : 1.00
*. CREATED   :  6-Nov-1990
*. LAST MOD  :  6-Nov-1990
*.
*. Modification log:
*.   6-Nov-90 F.Odorici  Create this routine
*.
*.********************************************************************
+SEQ,DECLARE.
      INTEGER NDEV,NALL
      CHARACTER*(*) DEVPRE,DEVNAM(NDEV)
*
      CHARACTER*63 DVPRFX,SPACES,DVTEMP
      INTEGER I,LENOCC
      INCLUDE '($SSDEF)'
      INTEGER SYS$ALLOC,AINFO,FLAGS
      LOGICAL GENNAM
+SEQ,RCREP.
*-- Set to zero the number of allocated devices and suppose we don't
*-- use a generic device name
      NALL   = 0
      GENNAM = .FALSE.
*-- Remove trailing blanks in device name.
*-- Check also last non-blank character: it must be a ":" !!!
      DVPRFX = SPACES(DEVPRE,1)
      IF(LENOCC(DVPRFX).LT.63) THEN
         IF(DVPRFX(LENOCC(DVPRFX):LENOCC(DVPRFX)).NE.':') THEN
            GENNAM = .TRUE.
            DVPRFX(LENOCC(DVPRFX)+1:LENOCC(DVPRFX)+1) = ':'
         END IF
      END IF
*-- Allocate all the devices.
      FLAGS  = 0
      IF(GENNAM) FLAGS  = 1
      DO 10 I=1,NDEV
      DVTEMP = ' '
      AINFO  = SYS$ALLOC(DVPRFX,,DVTEMP,,%VAL(FLAGS))
      IF(.NOT.AINFO) THEN
         IF(NALL.GT.0) THEN
         ELSE IF(AINFO.EQ.SS$_NODEVAVL) THEN
            CHREP  = 'No devices '//DVPRFX(1:LENOCC(DVPRFX))//
     +               ' available.'
            CALL REPORT('RALLDV',1,'E')
         ELSE IF(AINFO.EQ.SS$_DEVALLOC) THEN
            CHREP  = 'Device '//DVPRFX(1:LENOCC(DVPRFX))//
     +               ' already allocated to another process.'
            CALL REPORT('RALLDV',2,'E')
         ELSE IF(AINFO.EQ.SS$_NOSUCHDEV) THEN
            CHREP  = 'Device '//DVPRFX(1:LENOCC(DVPRFX))//
     +               ' doesn''t exist.'
            CALL REPORT('RALLDV',3,'E')
         ELSE
            CHREP  = 'Devices '//DVPRFX(1:LENOCC(DVPRFX))//
     +               ' not allocated. Please check the name '//
     +               DVPRFX(1:LENOCC(DVPRFX))//'.'
            CALL REPORT('RALLDV',4,'E')
         END IF
                                                               GO TO 999
      ELSE
         NALL   = NALL + 1
         DEVNAM(NALL) = DVTEMP
         CHREP  = 'Device '//DEVNAM(NALL)(1:LENOCC(DEVNAM(NALL)))//
     +            ' allocated.'
         CALL REPORT('RALLDV',5,'I')
      END IF
   10 CONTINUE
*
  999 RETURN
      END
+DECK,RAUTOI.
      SUBROUTINE RAUTOI
*.
*...RAUTOI Handle *AUTOUNIT FFREAD cards
*.
*. SEQUENCE: RCNTRL ROUNIT RCREP
*. CALLS   : REPORT
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED :  8-Jan-91
*. LAST MOD:  8-Jan-91
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
      CHARACTER*8 FORWAT
      INTEGER     I,LU
*
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCREP.
*
      IF(LAUTOU) THEN
         CHREP  = 'Can not call AUTOUNIT twice'
         CALL REPORT('RAUTOI',1,'E')
                                                               GO TO 999
      END IF
      DO 10 I = 1,NUNITU
      LU     = IUNITU(I)
      IF(LU.GE.1.AND.LU.LE.NROPEU) THEN
         FORWAT = UNIUSE(LU)
         IF(FORWAT.NE.' ') THEN
            WRITE(CHREP,1000) LU,FORWAT
            CALL REPORT('RAUTOI',2,'W')
         END IF
         UNIUSE(LU) = 'User use'
      END IF
   10 CONTINUE
      LAUTOU = .TRUE.
      CALL VZERO(IUNITU,NUNITU)
  999 RETURN
*
 1000 FORMAT('Unit',I3,' might be already used for ',A)
      END
+DECK,RBKRCO.
      SUBROUTINE RBKRCO
*.
*...RBKRCO   Book banks in RCO structure.
*.
*. SEQUENCE: ROBANK RCNTRL ROCPAR RCREP
*. COMMON  : QUEST
*. CALLS   : MZBOOK ZSHUNT MZPUSH REPORT
*. CALLED  : ROPSET
*.
*. BANK L  : RCO EXC UTC CDC EEC HCC MUC FOC ADC ODC
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 24-May-88
*. LAST MOD:  28-Mar-96
*.
*. Modification Log.
*. 28-Mar-96  O.Schaile      Introduce TE process.
*.  5-Mar-93  O.Schaile      Introduce SW process.
*. 26-Fev-91  S.Weisz        Check constant structure.
*. 17-Jan-91  S.Weisz        Introduce DX,SI and CS process.
*.  5-Apr-90  S.Weisz        Remove ADC bank treatment.
*. 10-May-89  S.Weisz        Push OD top bank if No links not correct.
*. 22-Feb-89  S.Weisz        Book DAC bank if not there.
*.  9-Sep-88  S.Weisz        Drop OD top bank if No data not correct.
*. 24-Jun-88  S.Weisz        Define all permanent links.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LUTCO,INCNL,INCND,IQUEST
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,RCREP.
*-- Lift ZEBRA structure for ROPE constants.
      IF(LRCO.LT.1) CALL MZBOOK(IROCON,LRCO,LRCO,1,'RCO ',NLRCO,NSRCO,
     +NDRCO,IORCO,0)
      LEXC = LQ(LRCO-LLEXC)
      IF(LEXC.LT.1) THEN
*-- Lift bank for External Devices constants.
         CALL MZBOOK(IROCON,LEXC,LRCO,-LLEXC,'EXC ',NLEXC,NSEXC,NDEXC,
     +   IOEXC,0)
      ELSE
         LMCC  = LQ(LEXC-LLMCC)
         LLEPC = LQ(LEXC-LLLEPC)
      END IF
*-- Utility constants bank (Report,Graphics,Input/Output)
*-- already lifted in ROPINI: just hang it in RCO.
      LUTCO = LQ(LRCO-LLUTC)
      IF(LUTCO .NE. 0) CALL MZDROP(IXSTOR,LUTCO,'.')
      CALL ZSHUNT(IXSTOR,LUTC,LRCO,-LLUTC,1)
      CALL MZDROP(IXSTOR,LHEAD,'.')
      LDAC = LQ(LRCO-LLDAC)
      IF(LDAC.LT.1) THEN
*-- Lift calibration constant banks if not there.
         CALL MZBOOK(IROCON,LDAC,LRCO,-LLDAC,'DAC ',NLDAC,NSDAC,NDDAC,
     +   IODAC,0)
      ELSE
*-- Extend link/data part if needed.
         INCNL = 0
         INCND = 0
         IF(IQNS(LDAC).LT.NSDAC) INCNL = NSDAC - IQNS(LDAC)
         IF(IQND(LDAC).LT.NDDAC) INCND = NDDAC - IQND(LDAC)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LDAC,INCNL,INCND,'.')
            CHREP = 'DAC structure must be expanded'
            CALL REPORT('RBKRCO',1,'W')
         END IF
      END IF
      LCDC = LQ(LRCO-LLCDC)
      IF(LCDC.LT.1) THEN
*-- Lift bank for Central Detector constants.
         CALL MZBOOK(IROCON,LCDC,LRCO,-LLCDC,'CDC ',NLCDC,NSCDC,NDCDC,
     +   IOCDC,0)
      ELSE
*-- Extend link/data part if needed.
         INCNL = 0
         INCND = 0
         IF(IQNS(LCDC).LT.NSCDC) INCNL = NSCDC - IQNS(LCDC)
         IF(IQND(LCDC).LT.NDCDC) INCND = NDCDC - IQND(LCDC)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LCDC,INCNL,INCND,'.')
            CHREP = 'CDC structure must be expanded and link redefined'
            CALL REPORT('RBKRCO',2,'W')
            IF(LQ(LCDC-5).GE.1) THEN
               CALL ZSHUNT(IXSTOR,LQ(LCDC-5),LCDC,-7,1)
            END IF
         END IF
         LCVC  = LQ(LCDC-LLCVC)
         LCJC  = LQ(LCDC-LLCJC)
         LCZC  = LQ(LCDC-LLCZC)
         LCTC  = LQ(LCDC-LLCTC)
         LDXC  = LQ(LCDC-LLDXC)
         LCFC  = LQ(LCDC-LLCFC)
         LCXC  = LQ(LCDC-LLCXC)
         LSIC  = LQ(LCDC-LLSIC)
         LCSC  = LQ(LCDC-LLCSC)
         LCEC  = LQ(LCDC-LLCEC)
         LCAC  = LQ(LCDC-LLCAC)
      END IF
      LECC = LQ(LRCO-LLECC)
      IF(LECC.LT.1) THEN
*-- Lift bank for Electron Calorimeter constants.
         CALL MZBOOK(IROCON,LECC,LRCO,-LLECC,'ECC ',NLECC,NSECC,NDECC,
     +   IOECC,0)
      ELSE
*-- Extend link/data part if needed.
         INCNL = 0
         INCND = 0
         IF(IQNS(LECC).LT.NSECC) INCNL = NSECC - IQNS(LECC)
         IF(IQND(LECC).LT.NDECC) INCND = NDECC - IQND(LECC)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LECC,INCNL,INCND,'.')
            CHREP = 'ECC structure must be expanded and link redefined'
            CALL REPORT('RBKRCO',2,'W')
            IF(LQ(LECC-5).GE.1) THEN
               CALL ZSHUNT(IXSTOR,LQ(LECC-5),LECC,-7,1)
            END IF
         END IF
         LTBC  = LQ(LECC-LLTBC)
         LTEC  = LQ(LECC-LLTEC)
         LPBC  = LQ(LECC-LLPBC)
         LEBC  = LQ(LECC-LLEBC)
         LPEC  = LQ(LECC-LLPEC)
         LEEC  = LQ(LECC-LLEEC)
         LEMC  = LQ(LECC-LLEMC)
      END IF
      LHCC = LQ(LRCO-LLHCC)
      IF(LHCC.LT.1) THEN
*-- Lift bank for Hadron Calorimeter constants.
         CALL MZBOOK(IROCON,LHCC,LRCO,-LLHCC,'HCC ',NLHCC,NSHCC,NDHCC,
     +   IOHCC,0)
      ELSE
         LHBC  = LQ(LHCC-LLHBC)
         LHEC  = LQ(LHCC-LLHEC)
         LHPC  = LQ(LHCC-LLHPC)
         LHMC  = LQ(LHCC-LLHMC)
      END IF
      LMUC = LQ(LRCO-LLMUC)
      IF(LMUC.LT.1) THEN
*-- Lift bank for Muon Detector constants.
         CALL MZBOOK(IROCON,LMUC,LRCO,-LLMUC,'MUC ',NLMUC,NSMUC,NDMUC,
     +   IOMUC,0)
      ELSE
         LMBC  = LQ(LMUC-LLMBC)
         LMECO = LQ(LMUC-LLMECO)
         LMMC  = LQ(LMUC-LLMMC)
      END IF
      LFOC = LQ(LRCO-LLFOC)
      IF(LFOC.LT.1) THEN
*-- Lift bank for Forward Detector constants.
         CALL MZBOOK(IROCON,LFOC,LRCO,-LLFOC,'FOC ',NLFOC,NSFOC,NDFOC,
     +   IOFOC,0)
      ELSE
*-- Check if No of links/words for FOC is correct.
         INCNL = 0
         INCND = 0
         IF(IQNS(LFOC).LT.NSFOC) INCNL = NSFOC - IQNS(LFOC)
         IF(IQND(LFOC).LT.NDFOC) INCND = NDFOC - IQND(LFOC)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LFOC,INCNL,INCND,'.')
            CHREP = 'FOC structure must be expanded'
            CALL REPORT('RBKRCO',3,'W')
         END IF
         LFDC  = LQ(LFOC-LLFDCR)
         LSWC  = LQ(LFOC-LLSWC)
      END IF
      LODC = LQ(LRCO-LLODC)
      IF(LODC.GE.1) THEN
*-- Check if No of links/words for ODC is correct.
         INCNL = 0
         INCND = 0
         IF(IQNS(LODC).LT.NSODC) INCNL = NSODC - IQNS(LODC)
         IF(IQND(LODC).LT.NDODC) INCND = NDODC - IQND(LODC)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LODC,INCNL,INCND,'.')
            CHREP = 'ODC structure must be expanded'
            CALL REPORT('RBKRCO',4,'W')
         END IF
      ELSE
*-- Lift bank for DST constants.
         CALL MZBOOK(IROCON,LODC,LRCO,-LLODC,'ODC ',NLODC,NSODC,NDODC,
     +   IOODC,0)
      END IF
*-- Check the constant division if selected with ZVERIFY.
      IF(IZVERI.EQ.1) THEN
         CALL DZVERI('    ',IROCON,'CLSU')
         IF(IQUEST(1).NE.0) THEN
            WRITE(CHREP,1000)
            CALL REPORT('RBKRCO',5,'F')
         END IF
      END IF
*
      RETURN
 1000 FORMAT('ZEBRA messed-up after calibration retrieval')
      END
+DECK,RBKREV.
      SUBROUTINE RBKREV
*.
*...RBKREV  Book the banks hanging from LREV
*.
*. SEQUENCE  : ROBANK CRO ROPAR ROCPAR RCREP
*. CALLS     : MZBOOK MZPUSH REPORT
*. CALLED    : ROEVNT
*.
*. BANKS L   : UT CD EC HC MU FO DD OD
*.
*. AUTHOR    : A.Buijs
*. VERSION   : 1.01
*. CREATED   : 11-Feb-88
*. LAST MOD  : 13-Jul-97
*.
*. Modification Log.
*. 13-Jul-97 M.Schroder  Check LEC link area before calculating LTE (for 1990)
*. 28-Mar-96  O.Schaile      Introduce TE process.
*. 11-Mar-93  O.Schaile      VZERO(,39),check NS in FOC
*.  3-Mar-93  O.Schaile      Introduce SW process.
*. 26-Jun-92  O.Schaile      restore setting of IVGOPA (dont check)
*.  4-Jun-92  O.Schaile      remove check on IVGOPA
*.  911016    S.Weisz Bug on IVGOPA update for MC (D)DST events.
*. 20-Mar-91  S.Weisz        Add LCS link.
*. 15-Jan-91  S.Weisz        Introduce DX,SI and CS process.
*.  5-Apr-90  S.Weisz        Remove AD bank treatment.
*. 19-Jun-89  S.Weisz        Lift CD,EC,HC,MU,FO,AD,OD in any case.
*. 16-Jun-89  S.Weisz        Lift UT first for REPORT.
*. 13-Jun-89  S.Weisz        Get GOPAL version No from GOPAL events.
*. 12-Jun-89  S.Weisz        Reset all REV permanent links, define LDA.
*. 10-May-89  S.Weisz        Push OD top bank if No links not correct.
*.  7-Sep-88  S.Weisz        Drop OD top bank if No links not correct.
*. 26-Aug-88  S.Weisz        Modify logic to set all links.
*. 24-Jun-88  S.Weisz        Define all permanent links.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER INCNL,INCND
*-- This should go in GOPAR.
      INTEGER    IGOVER
      PARAMETER (IGOVER = 7)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,RCREP.
*-- First reset all permanent links (RCLINK) in event division.
      CALL VZERO(LEX,39)
*-- We lift the various banks hanging from REV only if they are not
*-- already on the input AND there is a processor who will work on them.
*-- Note: if they do exist on input, they are usually not yet known to
*--       the permanent link area. Do that here.
*-- Lift bank for Utility Records (REPORT,..).
      LUT = LQ(LREV-LLUT)
      IF(LUT.LT.1) THEN
         CALL MZBOOK(IRODIV,LUT,LREV,-LLUT,'UT  ',
     +   NLUT,NSUT,NDUT,IOUT,0)
      END IF
      LEX = LQ(LREV-LLEX)
      IF(LEX.GE.1) THEN
         LMC = LQ(LEX-LLMC)
*-- Check GOPAL version for MC events.
         IF(LMC.GE.1) THEN
            IVGOPA = IQ(LMC+IGOVER)
*            IF(IQ(LMC+IGOVER).NE.IVGOPA) THEN
*               WRITE(CHREP,1000) IQ(LMC+IGOVER),IVGOPA
*               CALL REPORT('RBKREV',1,'W')
*               IVGOPA = IQ(LMC+IGOVER)
*            END IF
         END IF
         LLEP = LQ(LEX-LLLEP)
      END IF
*-- Set link for "Raw Data".
      LDA = LQ(LREV-LLDA)
*-- Lift bank for Central Detector.
      LCD = LQ(LREV-LLCD)
      IF(LCD.GE.1) THEN
*-- Extend link/data part if needed.
         INCNL = 0
         INCND = 0
         IF(IQNS(LCD).LT.NSCD) INCNL = NSCD - IQNS(LCD)
         IF(IQND(LCD).LT.NDCD) INCND = NDCD - IQND(LCD)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IRODIV,LCD,INCNL,INCND,'.')
            CHREP = 'CD structure must be expanded and link redefined'
            CALL REPORT('RBKREV',2,'W')
            IF(LQ(LCD-5).GE.1) THEN
               CALL ZSHUNT(IXSTOR,LQ(LCD-5),LCD,-7,1)
            END IF
         END IF
         LCV  = LQ(LCD-LLCV)
         LCJ  = LQ(LCD-LLCJ)
         LCZ  = LQ(LCD-LLCZ)
         LCT  = LQ(LCD-LLCT)
         LDX  = LQ(LCD-LLDX)
         LCF  = LQ(LCD-LLCF)
         LCX  = LQ(LCD-LLCX)
         LSI  = LQ(LCD-LLSI)
         LCS  = LQ(LCD-LLCS)
*-- ** WARNING ** We still have to define LCE and LCA.
      ELSE
         CALL MZBOOK(IRODIV,LCD,LREV,-LLCD,'CD  ',NLCD,NSCD,NDCD,IOCD,
     +   0)
      END IF
*-- Lift bank for Electron Calorimeter.
      LEC = LQ(LREV-LLEC)
      IF(LEC.GE.1 ) THEN
         LTB  = LQ(LEC-LLTB)
         LPB  = LQ(LEC-LLPB)
         LEB  = LQ(LEC-LLEB)
         LPE  = LQ(LEC-LLPE)
         LEE  = LQ(LEC-LLEE)
         LEM  = LQ(LEC-LLEM)
         IF ( IQNS(LEC).LT.7 ) THEN
           INCNL = LLTE-IQNS(LEC)
           INCND = NDEC-IQND(LEC)
           CALL MZPUSH(IRODIV,LEC,INCNL,INCND,'.')
         ENDIF
      ELSE
         CALL MZBOOK(IRODIV,LEC,LREV,-LLEC,'EC  ',NLEC,NSEC,NDEC,IOEC,
     +   0)
      END IF
*-- Lift bank for Hadron Calorimeter.
      LHC = LQ(LREV-LLHC)
      IF(LHC.GE.1) THEN
         LHB  = LQ(LHC-LLHB)
         LHE  = LQ(LHC-LLHE)
         LHP  = LQ(LHC-LLHP)
         LHM  = LQ(LHC-LLHM)
      ELSE
         CALL MZBOOK(IRODIV,LHC,LREV,-LLHC,'HC  ',NLHC,NSHC,NDHC,IOHC,
     +   0)
      END IF
*-- Lift bank for Muon Detector.
      LMU = LQ(LREV-LLMU)
      IF(LMU.GE.1) THEN
         LMB  = LQ(LMU-LLMB)
         LME  = LQ(LMU-LLME)
         LMM  = LQ(LMU-LLMM)
      ELSE
         CALL MZBOOK(IRODIV,LMU,LREV,-LLMU,'MU  ',NLMU,NSMU,NDMU,IOMU,
     +   0)
      END IF
*-- Lift bank for Forward Detector.
      LFO = LQ(LREV-LLFO)
      IF(LFO.GE.1) THEN
*-- Check if No of links/words for FO is correct.
         INCNL = 0
         INCND = 0
         IF(IQNS(LFO).LT.NSFO) INCNL = NSFO - IQNS(LFO)
         IF(IQND(LFO).LT.NDFO) INCND = NDFO - IQND(LFO)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IRODIV,LFO,INCNL,INCND,'.')
            CHREP = 'FO structure must be expanded'
            CALL REPORT('RBKREV',3,'W')
         ELSE
            LFD  = LQ(LFO-LLFD)
            LSW  = LQ(LFO-LLSW)
         END IF
      ELSE
         CALL MZBOOK(IRODIV,LFO,LREV,-LLFO,'FO  ',NLFO,NSFO,NDFO,IOFO,
     +   0)
      END IF
*-- Define Dense Data link.
      LDD = LQ(LREV-LLDD)
*-- Lift ROPE results bank.
      LOD = LQ(LREV-LLOD)
      IF(LOD.GT.0) THEN
*-- Check if No of links/words for OD is correct.
         INCNL = 0
         INCND = 0
         IF(IQNS(LOD).LT.NSOD) INCNL = NSOD - IQNS(LOD)
         IF(IQND(LOD).LT.NDOD) INCND = NDOD - IQND(LOD)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IRODIV,LOD,INCNL,INCND,'.')
            CHREP = 'OD structure must be expanded'
            CALL REPORT('RBKREV',3,'W')
         END IF
      ELSE
         CALL MZBOOK(IRODIV,LOD,LREV,-LLOD,'OD  ',NLOD,NSOD,NDOD,IOOD,
     +   0)
      END IF
*
      RETURN
 1000 FORMAT('GOPAL',I3,' event on input when version ',I3, ' expected')
*
      END
+DECK,RBKSTA.
      SUBROUTINE RBKSTA
*.
*...RBKSTA   Book statistical structure.
*.
*. SEQUENCE: ROBANK ROSPAR ROSLNK
*. CALLS   : MZBOOK
*. CALLED  : ROPINI
*.
*. BANL L  : RST EXS UTS RSMS RTIS RSPS RTI2 RSP2 RDAS
*.           CDS EES HCS MUS FOS ASS ODS
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 20-Dec-88
*. LAST MOD:  5-Apr-90
*.
*. Modification Log.
*.  5-Apr-90 S.Weisz     Remove ADC bank treatment.
*. 13-Jun-89 S.Weisz     Use link area /ROSLNK/.
*. 15-Feb-89 S.Weisz     Book DAS.
*. 25-Jan-89 S.Weisz     Book summary banks.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,ROBANK
+SEQ,ROSPAR
+SEQ,ROSLNK
*-- Lift ZEBRA structure for ROPE statistics.
      CALL MZBOOK(IROSTA,LRST,LRST,1,'RST ',NLRST,NSRST,NDRST,IORST,0)
*-- Lift bank for External Devices statistics.
      CALL MZBOOK(IROSTA,LEXS,LRST,-LLEXS,'EXS ',NLEXS,NSEXS,NDEXS,
     +IOEXS,0)
*-- Lift bank for Utility statistics (REPORT,Summary,..).
      CALL MZBOOK(IROSTA,LUTS,LRST,-LLUTS,'UTS ',NLUTS,NSUTS,NDUTS,
     +IOUTS,0)
*-- Book a bank to hold the ROPE summary information.
      CALL MZBOOK(IROSTA,LRSMS,LUTS,-LLRSMS,'RSMS',NLRSMS,NSRSMS,
     +NDRSMS,IORSMS,0)
*-- Book banks to hold time and space used per processor.
      CALL MZBOOK(IROSTA,LRTIS,LRSMS,-LLRTIS,'RTIS',NLRTIS,NSRTIS,
     +NDRTIS,IORTIS,0)
      CALL MZBOOK(IROSTA,LRSPS,LRSMS,-LLRSPS,'RSPS',NLRSPS,NSRSPS,
     +NDRSPS,IORSPS,0)
      CALL MZBOOK(IROSTA,LRTI2,LRSMS,-LLRTI2,'RTI2',NLRTI2,NSRTI2,
     +NDRTI2,IORTI2,0)
      CALL MZBOOK(IROSTA,LRSP2,LRSMS,-LLRSP2,'RSP2',NLRSP2,NSRSP2,
     +NDRSP2,IORSP2,0)
*-- Lift bank for raw Data statistics.
      CALL MZBOOK(IROSTA,LDAS,LRST,-LLDAS,'DAS ',NLDAS,NSDAS,NDDAS,
     +IODAS,0)
*-- Lift bank for Central Detector statistics.
      CALL MZBOOK(IROSTA,LCDS,LRST,-LLCDS,'CDS ',NLCDS,NSCDS,NDCDS,
     +IOCDS,0)
*-- Lift bank for Electron Calorimeter statistics.
      CALL MZBOOK(IROSTA,LECS,LRST,-LLECS,'ECS ',NLECS,NSECS,NDECS,
     +IOECS,0)
*-- Lift bank for Hadron Calorimeter statistics.
      CALL MZBOOK(IROSTA,LHCS,LRST,-LLHCS,'HCS ',NLHCS,NSHCS,NDHCS,
     +IOHCS,0)
*-- Lift bank for Muon Detector statistics.
      CALL MZBOOK(IROSTA,LMUS,LRST,-LLMUS,'MUS ',NLMUS,NSMUS,NDMUS,
     +IOMUS,0)
*-- Lift bank for Forward Detector statistics.
      CALL MZBOOK(IROSTA,LFOS,LRST,-LLFOS,'FOS ',NLFOS,NSFOS,NDFOS,
     +IOFOS,0)
*-- Lift bank for Dense Data statistics.
C     CALL MZBOOK(IROSTA,LDDS,LRST,-LLDDS,'DDS ',NLDDS,NSDDS,NDDDS,
C    +IODDS,0)
*-- Lift bank for DST statistics.
      CALL MZBOOK(IROSTA,LODS,LRST,-LLODS,'ODS ',NLODS,NSODS,NDODS,
     +IOODS,0)
*
      RETURN
      END
+DECK,RBKTMP.
      SUBROUTINE RBKTMP
*.
*...RBKTMP   Book temporary structure.
*.
*. SEQUENCE: ROBANK ROCPAR
*. CALLS   : MZBOOK
*. CALLED  : ROPINI
*.
*. BANK L  : HEAD UTC IOHD SLCT
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 20-Dec-88
*. LAST MOD: 20-Dec-88
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LIOHD,LSLCT
*
+SEQ,ROBANK
+SEQ,ROCPAR
*-- Lift temporary ZEBRA structure for IO.
      CALL MZBOOK(IROCON,LHEAD,LHEAD,1,'HEAD',1,1,0,0,0)
*-- Lift bank for Utility constants (Input/Output).
      CALL MZBOOK(IROCON,LUTC,LHEAD,-1,'UTC ',NLUTC,NSUTC,NDUTC,IOUTC,
     +0)
*-- Lift IO Header bank.
      CALL MZBOOK(IROCON,LIOHD,LUTC,-LLIOHD,'IOHD',NLIOHD,NSIOHD,
     +NDIOHD,IOIOHD,0)
*-- Lift Selection Header bank.
      CALL MZBOOK(IROCON,LSLCT,LUTC,-LLSLCT,'SLCT',NLSLCT,NSSLCT,
     +NDSLCT,IOSLCT,0)
*
      RETURN
      END
+DECK,RCASET.
      SUBROUTINE RCASET(CHTNAM)
*.
*...RCASET   Associate database names to processors
*.
*. SEQUENCE: RCNTRL RCHTOP RCREP
*. CALLS   : REPORT
*. CALLED  : ROPSET
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED :  8-Fev-89
*. LAST MOD:  2-May-96
*.
*. Modification Log.
*.  2-May-96  M.Schroder     replace hardcoded 21 in CALWRITE part
*. 28-Mar-96  O.Schaile      Introduce TE process.
*.  1-Jun-95  M.Schroder     Only count to NPROC-2 in decode CALWRITE
*. 18-Apr-95  M.Schroder     Introduce RO process for general info.(21=>22)
*.  5-Mar-93  O.Schaile      Introduce SW process. (20=>21)
*. 07-Feb092  N.K.Watson     Use top directory name as in argument.
*. 31-Mai-89  S.Weisz        Treat TR,TT,SC and FI
*. 17-Feb-89  S.Weisz        Properly set defaults for database names
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*(*) CHTNAM
      CHARACTER*2 PRONAM
      CHARACTER*4 CALNAM,CPRNAM
      INTEGER I,I10,I20,I30,I40,NPROCS,NPROC2,NPROCN
C     don not forget to update the size of LCALRD and LCALWT if you change NPROCS !
      PARAMETER (NPROCS=23,NPROC2=2*NPROCS,NPROCN=NPROC2-1)
*
+SEQ,RCNTRL.
+SEQ,RCHTOP.
+SEQ,RCREP.
*
      DIMENSION PRONAM(NPROCS),CALNAM(NPROC2)
      SAVE      PRONAM
      EQUIVALENCE (CALNAM,CHTRCV)
      DATA PRONAM/'CV','CJ','CZ','TB','PB','EB','PE','EE','HB','HE',
     +            'HP','MB','ME','FD','TR','TT','SC','FI','DX','SI',
     +            'SW','RO','TE'/
*
      DO 10 I=1,NPROC2
   10 CALNAM(I) = '    '
      DO 20 I=1,NPROCS
*- NKW mods start.
*-- Use top directory name as requested by user for 'main' database.
         IF(ICMAIN.EQ.1) CALNAM(I) = CHTNAM(1:4)
* NKW mods end.
   20 CONTINUE
*-- First decode CALREAD card.
      DO 40 I10=1,NPROCN,2
         IF(LCALRD(I10).EQ.0)                                   GO TO 40
         CALL UHTOC(LCALRD(I10),4,CPRNAM,4)
         DO 30 I20=1,NPROCS
            IF(CPRNAM(1:2).EQ.PRONAM(I20)) THEN
               CALL UHTOC(LCALRD(I10+1),4,CALNAM(I20),4)
                                                                GO TO 40
            END IF
   30    CONTINUE
         CHREP = 'Unknown '//CPRNAM(1:2)//' process on CALREAD card.'
         CALL REPORT('RCASET',1,'W')
   40 CONTINUE
*-- Now decode CALWRITE card.
      DO 60 I30=1,NPROCN-2,2
         IF(LCALWT(I30).EQ.0)                                   GO TO 60
         CALL UHTOC(LCALWT(I30),4,CPRNAM,4)
         DO 50 I40=1,NPROCS
            IF(CPRNAM(1:2).EQ.PRONAM(I40)) THEN
               CALL UHTOC(LCALWT(I30+1),4,CALNAM(I40+NPROCS),4)
                                                                GO TO 60
            END IF
   50    CONTINUE
         CHREP = 'Unknown '//CPRNAM(1:2)//' process on CALWRITE card.'
         CALL REPORT('RCASET',2,'W')
   60 CONTINUE
*
      RETURN
      END
+DECK,RCATDA.
      SUBROUTINE RCATDA
*.
*...RCATDA  Handle a *DADFILE card when it starts with two slashes (//) ,
*.          i.e. when it refers to a generic DAD list
*. SEQUENCE: ROBANK CRO RCNTRL ROUNIT ROWORD RCSYST RBITFUNC RCREP RCLINE
*. CALLS   : RSCATA RCFILS RIODAD ROFIRL REPORT RMAIL MZWORK
*.
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 28-Feb-91
*. LAST MOD: 27-Aug-91
*.
*. Modification Log.
*. 27-Aug-91  S.Weisz        Use RBITFUNC sequence
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER            MAXLIN
      PARAMETER         (MAXLIN=1000)
      INTEGER            FLAGS,IFC,ILC,IFIRST,ILAST,I,L,IER,
     +                   NFOUND,ACTUAL,INSIDE
      INTEGER            LENOCC
      LOGICAL            LVARI,HERE,QUIET
      CHARACTER*1        OPT
      CHARACTER*4        CFIDCH
      CHARACTER*16       CHCOMP
      CHARACTER*80       DADNAM,SEARCH
      CHARACTER*80       SPACES
      CHARACTER*80       LINES(MAXLIN)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,ROWORD.
+SEQ,RBITFUNC.
+SEQ,RCLINE.
+SEQ,RCREP.
      EQUIVALENCE (WS(1),LINES(1))
*
      IF(LDATYP.EQ.0.OR.LDADIR.EQ.0) THEN
         CHREP  = 'Not enough parameters on *DADFILE card'
         CALL REPORT('RCATDA',1,'E')
                                                                GO TO 30
      END IF
*-- Check if catalog file (MAW$DBS) is accessed, if not, do it ...
      IF(.NOT.LCATAL) THEN
         CALL RSCATA
         IF(.NOT.LCATAL) THEN
           CHREP  = 'The CATALOG package was not initialised'
           CALL REPORT('RCATDA',2,'E')
                                                                GO TO 30
         END IF
      END IF
*-- Set some defaults.
      FLAGS  = 0
      HERE   = .TRUE.
      QUIET  = .FALSE.
*-- What about the Rope processing options?
      CALL UHTOC(LDAOPT,4,CFIDCH,4)
      CALL CLEFT(CFIDCH,1,4)
      CALL CLTOU(CFIDCH)
      DO 10 I=1,4
      OPT    = CFIDCH(I:I)
      IF(OPT.EQ.' ') THEN
      ELSE IF(OPT.EQ.'O') THEN
         FLAGS  = IBSET(FLAGS,ANYWHE)
         HERE   = .FALSE.
      ELSE IF(OPT.EQ.'H') THEN
         FLAGS  = IBCLR(FLAGS,ANYWHE)
         HERE   = .TRUE.
      ELSE IF(OPT.EQ.'Q') THEN
         FLAGS  = IBSET(FLAGS,CLSQUI)
         QUIET  = .TRUE.
      ELSE
         CHREP  = 'Unkonw option: '//OPT
         CALL REPORT('RCATDA',3,'E')
                                                                GO TO 30
      END IF
   10 CONTINUE
*-- Make space to receive all file names
      CALL MZWORK(IXSTOR,WS(1),WS(NAMLWO*MAXLIN),0)
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LDANAM,NBYTEW,DADNAM,NAMLEN)
      DADNAM = SPACES(DADNAM,1)
*-- What about special characters?
      CALL ROVANA(DADNAM,LVARI)
      IF(LVARI) THEN
         CHREP  = 'Variable names not allowed with *DADFILE'
         CALL REPORT('RCATDA',4,'E')
                                                                GO TO 30
      END IF
      DADNAM = SPACES(DADNAM,0)
      IFC    = INDEX(DADNAM,'[')
      ILC    = LENOCC(DADNAM)
      IF(IFC.EQ.0) THEN
         SEARCH = DADNAM(2:ILC)
         IFIRST = 1
         ILAST  = 99999
      ELSE IF(DADNAM(ILC:ILC).EQ.']') THEN
         CALL ROFIRL(DADNAM(IFC+1:ILC-1),IFIRST,ILAST,IER)
         IF(IER.EQ.0) THEN
            SEARCH = DADNAM(2:IFC-1)
         ELSE
            CHREP  = 'Invalid [...] specification'
            CALL REPORT('RCATDA',5,'E')
                                                                GO TO 30
         END IF
      ELSE
         CHREP  = 'Unbalanced "["'
         CALL REPORT('RCATDA',6,'E')
                                                                GO TO 30
      END IF
+SELF,IF=VAX.
      CHCOMP = CHNODE(1:LCHNOD)//'::'
+SELF.
*-- Now call the expansion catalog routine
      CALL RFCLIS(SEARCH,LINES,MAXLIN,NFOUND)
      IF(NFOUND.EQ.0) THEN
         CHREP  = 'No entry satisfies your search criteria'
         CALL REPORT('RCATDA',7,'E')
                                                                GO TO 30
      ELSE IF (NFOUND.EQ.MAXLIN) THEN
         WRITE(CHREP,1010) MAXLIN
         CALL REPORT('RCATDA',8,'W')
      END IF
      ACTUAL = 0
      INSIDE = 0
      DO 20 I=1,NFOUND
      CALL UCTOH(LINES(I),LDANAM,NBYTEW,NAMLEN)
*-- With the 'H' option, check that the file sits here
      IF(HERE) THEN
+SELF,IF=VAX.
         IF(LINES(I)(1:LCHNOD+2).NE.CHCOMP)                     GO TO 20
+SELF.
      END IF
      ACTUAL = ACTUAL + 1
*-- Now check that the occurence number fits the requirements
      IF(ACTUAL.GE.IFIRST.AND.ACTUAL.LE.ILAST) THEN
         INSIDE = 1 + INSIDE
         IF(.NOT.QUIET) THEN
            L      = LENOCC(LINES(I))
            WRITE(CHLINE,1000) INSIDE,LINES(I)(1:L)
            CALL RMAIL(0,0)
         END IF
         CALL RIODAD
      END IF
   20 CONTINUE
      IF(ACTUAL.EQ.0) THEN
         CHREP  = 'No entry sits HERE, on this computer'
         CALL REPORT('RCATDA',9,'E')
                                                                GO TO 30
      ELSE IF(INSIDE.EQ.0) THEN
         CHREP  = 'No entry satisfies your occurence number selection'
         CALL REPORT('RCATDA',10,'E')
                                                                GO TO 30
      END IF
                                                               GO TO 999
   30 FFERRO = .TRUE.
*
  999 RETURN
 1000 FORMAT(26X,I4,' --> ',A)
 1010 FORMAT(' The maximum of',I5,' DADlists has been reached. Some',
     +       ' might have been forgotten')
      END
+DECK,RCATEV.
      SUBROUTINE RCATEV
*.
*...RCATEV  Handle a *EVTFILE card when it starts with two slashes (//),
*.          i.e. when it refers to a generic Event list
*. SEQUENCE:
*. CALLS   : RSCATA RIOFIRL RSEDBS RIONAN
*.
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 28-Feb-91
*. LAST MOD: 28-Feb-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER            FLAGS,IFC,ILC,IFIRST,ILAST,I,L,IER,
     +                   ACTUAL,INSIDE,LENOCC
      LOGICAL            HERE,QUIET,LVARI
      CHARACTER*1        OPT
      CHARACTER*4        CFIDCH
      CHARACTER*16       CHCOMP
      CHARACTER*80       EVLNAM,SEARCH,LINE,SPACES
*
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCLINE
+SEQ,RCREP.
*
      IF(LNADIR.EQ.0) THEN
         CHREP  = 'Not enough parameters on *NANOFILE card'
         CALL REPORT('RCATEV',1,'E')
                                                                GO TO 40
      END IF
*-- Check if catalog file  is accessed, if not, do it ...
      IF(.NOT.LCATAL) THEN
         CALL RSCATA
         IF(.NOT.LCATAL) THEN
           CHREP  = 'The CATALOG package was not initialised'
           CALL REPORT('RCATEV',2,'E')
                                                                GO TO 40
         END IF
      END IF
*-- Set some defaults.
      FLAGS  = 0
      HERE   = .TRUE.
      QUIET  = .FALSE.
*-- What about the Rope processing options?
      CALL UHTOC(LNAOPT,4,CFIDCH,4)
      CALL CLEFT(CFIDCH,1,4)
      CALL CLTOU(CFIDCH)
      DO 10 I=1,4
      OPT    = CFIDCH(I:I)
      IF(OPT.EQ.' ') THEN
      ELSE IF(OPT.EQ.'O') THEN
         FLAGS  = IBSET(FLAGS,ANYWHE)
         HERE   = .FALSE.
      ELSE IF(OPT.EQ.'H') THEN
         FLAGS  = IBSET(FLAGS,ONLYHE)
      ELSE IF(OPT.EQ.'Q') THEN
         FLAGS  = IBSET(FLAGS,CLSQUI)
         QUIET  = .TRUE.
      ELSE
         CHREP  = 'Unknown option: '//OPT
         CALL REPORT('RCATEV',3,'E')
                                                               GO TO 990
      END IF
   10 CONTINUE
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LEVNAM,NBYTEW,EVLNAM,NAMLEN)
      EVLNAM = SPACES(EVLNAM,1)
*-- What about special characters?
      CALL ROVANA(EVLNAM,LVARI)
      IF(LVARI) THEN
         CHREP  = 'Variable names not allowed with *NANOFILE'
         CALL REPORT('RCATEV',4,'E')
                                                               GO TO 990
      END IF
      IFC    = INDEX(EVLNAM,'[')
      ILC    = LENOCC(EVLNAM)
      IF(IFC.EQ.0) THEN
         SEARCH = EVLNAM(1:ILC)
         IFIRST = 1
         ILAST  = 99999
      ELSE IF(EVLNAM(ILC:ILC).EQ.']') THEN
         CALL ROFIRL(EVLNAM(IFC+1:ILC-1),IFIRST,ILAST,IER)
         IF(IER.EQ.0) THEN
            SEARCH = EVLNAM(1:IFC-1)
         ELSE
            CHREP  = 'Invalid [...] specification'
            CALL REPORT('RCATEV',5,'E')
                                                               GO TO 990
         END IF
      ELSE
         CHREP  = 'Unbalanced "["'
         CALL REPORT('RCATEV',6,'E')
                                                               GO TO 990
      END IF
      CHCOMP=' '
+SELF,IF=VAX,UNIX.
      IF(HERE) THEN
         CHCOMP = CHNODE(1:LCHNOD)
      ELSE
         CHCOMP=' '
      END IF
+SELF.
*-- Now call the expansion catalog routine
      ACTUAL = 0
      INSIDE = 0
      DO 20 I=1,99999
         CALL RSEDBS(SEARCH,CHCOMP,I,LINE,IER,JFILE)
         IF(IER.LE.0)                                           GO TO 30
         ACTUAL = ACTUAL + 1
*-- Now check that the occurrence number fits the requirements
         IF(ACTUAL.GE.IFIRST.AND.ACTUAL.LE.ILAST) THEN
            INSIDE = INSIDE + 1
            IF(.NOT.QUIET) THEN
               L      = LENOCC(LINE)
               WRITE(CHLINE,1000) INSIDE,LINE(1:L)
               CALL RMAIL(0,0)
            END IF
            CALL UCTOH(LINE,LEVNAM,NBYTEW,NAMLEN)
            CALL RIOEVL
         END IF
   20 CONTINUE
   30 IF(IER.LT.0)                                              GO TO 40
      IF(ACTUAL.EQ.0) THEN
         IF(HERE) THEN
            CHREP  = 'No entry sits HERE on this computer'
         ELSE
            CHREP  = 'No entry matches '//SEARCH
         END IF
         CALL REPORT('RCATEV',7,'E')
                                                               GO TO 990
      ELSE IF(INSIDE.EQ.0) THEN
         CHREP  = 'No entry satisfies your occurrence number selection'
         CALL REPORT('RCATEV',8,'E')
                                                               GO TO 990
      END IF
                                                               GO TO 999
   40 WRITE(CHREP,1010) IER
      CALL REPORT('RCATEV',9,'E')
  990 FFERRO = .TRUE.
*
  999 RETURN
 1000 FORMAT(26X,I4,' --> ',A)
 1010 FORMAT('Error ',I4,' while scanning the file data base.')
      END
+DECK,RCATNA.
      SUBROUTINE RCATNA
*.
*...RCATNA  Handle a *NANOFILE card when it starts with two slashes (//),
*.          i.e. when it refers to a generic NANODST
*. SEQUENCE:
*. CALLS   : ROFIRL RSEDBS RIONAN
*.
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 28-Feb-91
*. LAST MOD: 28-Feb-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER            FLAGS,IFC,ILC,IFIRST,ILAST,I,L,IER,
     +                   ACTUAL,INSIDE,LENOCC
      LOGICAL            HERE,QUIET,LVARI
      CHARACTER*1        OPT
      CHARACTER*4        CFIDCH
      CHARACTER*16       CHCOMP
      CHARACTER*80       NANNAM,SEARCH,LINE,SPACES
*
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCLINE
+SEQ,RCREP.
*
      IF(LNADIR.EQ.0) THEN
         CHREP  = 'Not enough parameters on *NANOFILE card'
         CALL REPORT('RCATNA',1,'E')
                                                                GO TO 40
      END IF
*-- Check if catalog file  is accessed, if not, do it ...
      IF(.NOT.LCATAL) THEN
         CALL RSCATA
         IF(.NOT.LCATAL) THEN
           CHREP  = 'The CATALOG package was not initialised'
           CALL REPORT('RCATNA',2,'E')
                                                                GO TO 40
         END IF
      END IF
*-- Set some defaults.
      FLAGS  = 0
      HERE   = .TRUE.
      QUIET  = .FALSE.
*-- What about the Rope processing options?
      CALL UHTOC(LNAOPT,4,CFIDCH,4)
      CALL CLEFT(CFIDCH,1,4)
      CALL CLTOU(CFIDCH)
      DO 10 I=1,4
      OPT    = CFIDCH(I:I)
      IF(OPT.EQ.' ') THEN
      ELSE IF(OPT.EQ.'O') THEN
         FLAGS  = IBSET(FLAGS,ANYWHE)
         HERE   = .FALSE.
      ELSE IF(OPT.EQ.'H') THEN
         FLAGS  = IBSET(FLAGS,ONLYHE)
      ELSE IF(OPT.EQ.'Q') THEN
         FLAGS  = IBSET(FLAGS,CLSQUI)
         QUIET  = .TRUE.
      ELSE
         CHREP  = 'Unknown option: '//OPT
         CALL REPORT('RCATNA',3,'E')
                                                               GO TO 990
      END IF
   10 CONTINUE
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LNANAM,NBYTEW,NANNAM,NAMLEN)
      NANNAM = SPACES(NANNAM,1)
*-- What about special characters?
      CALL ROVANA(NANNAM,LVARI)
      IF(LVARI) THEN
         CHREP  = 'Variable names not allowed with *NANOFILE'
         CALL REPORT('RCATNA',4,'E')
                                                               GO TO 990
      END IF
      IFC    = INDEX(NANNAM,'[')
      ILC    = LENOCC(NANNAM)
      IF(IFC.EQ.0) THEN
         SEARCH = NANNAM(1:ILC)
         IFIRST = 1
         ILAST  = 99999
      ELSE IF(NANNAM(ILC:ILC).EQ.']') THEN
         CALL ROFIRL(NANNAM(IFC+1:ILC-1),IFIRST,ILAST,IER)
         IF(IER.EQ.0) THEN
            SEARCH = NANNAM(1:IFC-1)
         ELSE
            CHREP  = 'Invalid [...] specification'
            CALL REPORT('RCATNA',5,'E')
                                                               GO TO 990
         END IF
      ELSE
         CHREP  = 'Unbalanced "["'
         CALL REPORT('RCATNA',6,'E')
                                                               GO TO 990
      END IF
      CHCOMP=' '
+SELF,IF=VAX,UNIX.
      IF(HERE) THEN
         CHCOMP = CHNODE(1:LCHNOD)
      ELSE
         CHCOMP=' '
      END IF
+SELF.
*-- Now call the expansion catalog routine
      ACTUAL = 0
      INSIDE = 0
      DO 20 I=1,99999
      CALL RSEDBS(SEARCH,CHCOMP,I,LINE,IER,JFILE)
      IF(IER.LE.0)                                              GO TO 30
      ACTUAL = ACTUAL + 1
*-- Now check that the occurrence number fits the requirements
      IF(ACTUAL.GE.IFIRST.AND.ACTUAL.LE.ILAST) THEN
         INSIDE = INSIDE + 1
         IF(.NOT.QUIET) THEN
            L      = LENOCC(LINE)
            WRITE(CHLINE,1000) INSIDE,LINE(1:L)
            CALL RMAIL(0,0)
         END IF
         CALL UCTOH(LINE,LNANAM,NBYTEW,NAMLEN)
         CALL RIONAN
      END IF
   20 CONTINUE
   30 IF(IER.LT.0)                                              GO TO 40
      IF(ACTUAL.EQ.0) THEN
         IF(HERE) THEN
            CHREP  = 'No entry sits HERE on this computer'
         ELSE
            CHREP  = 'No entry matches '//SEARCH
         END IF
         CALL REPORT('RCATNA',7,'E')
                                                               GO TO 990
      ELSE IF(INSIDE.EQ.0) THEN
         CHREP  = 'No entry satisfies your occurrence number selection'
         CALL REPORT('RCATNA',8,'E')
                                                               GO TO 990
      END IF
                                                               GO TO 999
   40 WRITE(CHREP,1010) IER
      CALL REPORT('RCATNA',9,'E')
  990 FFERRO = .TRUE.
*
  999 RETURN
 1000 FORMAT(26X,I4,' --> ',A)
 1010 FORMAT('Error ',I4,' while scanning the file data base.')
      END
+DECK,RCLOSC.
      SUBROUTINE RCLOSC
*...RCLOSC Close all calibration files
*.
*. SEQUENCE: ROBANK ROCPAR
*. CALLS   : RCLSIO
*. CALLED  : ROTRIG ROPFIN
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED :  7-Mar-91
*. LAST MOD:  7-Mar-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER LIOHD,LIO
+SEQ,ROBANK.
+SEQ,ROCPAR.
*-- Terminate OPCAL
      CALL OCEND(' ','A')
*-- Now close corresponding files.
      LIOHD  = LQ(LUTC-LLIOHD)
      LIO    = LQ(LIOHD-LLIOCA)
   10 IF(LIO.LE.0)                                             GO TO 999
      IF(IQ(LIO+JACTIV).GE.1) CALL RCLSIO(LIO,.TRUE.)
      LIO   = LQ(LIO)
                                                                GO TO 10
  999 CONTINUE
*
      RETURN
      END
+DECK,RCLOSO.
      SUBROUTINE RCLOSO
*...RCLOSO Close all active output streams
*.
*. SEQUENCE: DECLARE ROUNIT ROBANK ROCPAR RCREP
*. CALLS   : RCLSIO ROMOUN
*. CALLED  : ROPFIN
*.
*. AUTHOR  : D.Lellouch and F.Odorici
*. VERSION : 1.01
*. CREATED : 18-Nov-90
*. LAST MOD: 25-Mar-91
*.
*. Modification Log.
*.    911009  S.Weisz Close properly Copy and Overflow streams.
*.  25-Mar-91 D.Lellouch   Close output DAD list as well.
*.   5-Fev-1991 S.Weisz    Temporary comment of Phone facility.
*.  13-Dec-1990 F.Odorici  Message on the Phone file before closing.
*.  30-Nov-1990 F.Odorici  Close the Phone batch file (VAX only).
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER I,LIOHD,LIO,IER
+SELF,IF=VAX.
C     INTEGER IOSTAT
C     CHARACTER TODAY*9,NOW*8
+SELF.
+SEQ,ROUNIT.
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,RCREP.
*
      LIOHD  = LQ(LUTC-LLIOHD)
      DO 20 I=1,8
*-- Take care of DO,DP,DG and DS
      IF(I.EQ.1) THEN
         LIO    = LQ(LIOHD-LLIODO)
      ELSE IF(I.EQ.2) THEN
         LIO    = LQ(LIOHD-LLIODP)
      ELSE IF(I.EQ.3) THEN
         LIO    = LQ(LIOHD-LLIODG)
      ELSE IF(I.EQ.4) THEN
         LIO    = LQ(LIOHD-LLIODS)
      ELSE IF(I.EQ.5) THEN
         LIO    = LQ(LIOHD-LLIODD)
      ELSE IF(I.EQ.6) THEN
         LIO    = LQ(LIOHD-LLIOAO)
      ELSE IF(I.EQ.7) THEN
         LIO    = LQ(LIOHD-LLIODC)
      ELSE IF(I.EQ.8) THEN
         LIO    = LQ(LIOHD-LLIOOV)
      END IF
*-- Now look at all atcive files
   10 IF(LIO.LE.0)                                              GO TO 20
      IF(IQ(LIO+JACTIV).GE.1) CALL RCLSIO(LIO,.FALSE.)
      LIO   = LQ(LIO)
                                                                GO TO 10
   20 CONTINUE
+SELF,IF=VAX.
*-- Dismount all tapes and deallocate devices
      DO 30 I=1,NXDEVI
      IF(LDVALL(I)) THEN
         IF(TAPMOU(I).NE.'???') THEN
            CALL ROMOUN('D',DVNAME(I),TAPMOU(I),.FALSE.,IER)
            TAPMOU(I) = '???'
         END IF
         CALL ROMOUN('R',DVNAME(I),' ',.FALSE.,IER)
         LDVALL(I) = .FALSE.
      END IF
   30 CONTINUE
CCCCCC Temporary comment of Phone facility
*-- Write a comment (with current date and time) in the Phone batch file
*-- and close it.
C     IF(LPHONE) THEN
C        LPHONE = .FALSE.
C        CALL DATE(TODAY)
C        CALL TIME(NOW)
C  40    WRITE(LUPHON,FMT='(A)',ERR=50,IOSTAT=IOSTAT)
C    +   '! *** ROPE released this file on '//TODAY//' at time '//NOW
C                                                               GO TO 70
*-- Handle locked records only (IOSTAT=52).
C  50    IF(IOSTAT.NE.52)  THEN
C           CHREP  = 'Error writing on the Phone batch file.'
C           CALL REPORT('RCLOSO',1,'E')
C                                                               GO TO 70
C        ELSE
C           UNLOCK(LUPHON,ERR=60,IOSTAT=IOSTAT)
C                                                               GO TO 40
C        END IF
C  60    CHREP  = 'Error unlocking a record on the Phone batch file.'
C        CALL REPORT('RCLOSO',2,'E')
*
C  70    IF(PHONSA) THEN
C           CLOSE(LUPHON,STATUS='KEEP',ERR=80)
C        ELSE
C           CLOSE(LUPHON,STATUS='DELETE',ERR=80)
C        END IF
C     END IF
C                                                              GO TO 999
C  80 CHREP  = 'Error closing the Phone batch file.'
C     CALL REPORT('RCLOSO',3,'E')
C                                                              GO TO 999
CCCCCC End of temporary comment of Phone facility
+SELF.
  999 CONTINUE
*
      RETURN
      END
+DECK,RCLSIO.
      SUBROUTINE RCLSIO(LIO,LREAD)
*.
*...RCLSIO Close a file on input (LREAD=.true.) or OUTPUT(LREAD=.false.)
*.         If the file was called thru FATMEN, drop the disk on which
*.         it was staged
*.         If it was a tape file, detach
*.         It if was a stage tape, drop the staged disk.
*.         Rename variable name files
*.         Disk dump and erase
*.         Plot metafiles
*.
*. SEQUENCE: ROBANK RCNTRL ROUNIT ROCPAR RCSYSY FMPAR RBITFUNC RCREP
*.         : ROWORD
*. CALLS   : FZENDI MZDROP FMCLOS RQSYST LENOCC FMGETK RNWNAM FZENDO
*.           RSBWRD FZLOGL
*. CALLED  : ROOPEN ROPFIN RCLOSO RCLOSC ROWDAO
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD:  9-Oct-95
*.
*. Modification Log.
*.  9-Oct-95    O.Schaile  LASTNI=0 with dad/evt lists
*.  18-Feb-1994 O.Schaile  Suppress report if DADlist
*.   6-Jul-1992 G.Patrick  get rid of SETUP CLEAR - kills output!
*.  18-Feb-1992 O.Schaile  I6=>I7 in 1000.. FORMATs
*.  11-Dec-1991 T.Mouthuy  Change closing of output-dadlist files
*.  10-Dec-1991 O.Schaile  init LEMPTY
*.  13-Sep-1991 S.Weisz    Reset loging level to 0 on output
*.  11-Sep-1991 S.Weisz    Keep counter of event read on Event List
*.  27-Aug-1991 S.Weisz    Use RBITFUNC sequence
*.  23-Aug-1991 D.Lellouch Handle Event lists and NanoDst too
*.  15-Aug-1991 S.Weisz    Handle DADLISTs on SGI.
*.  11-May-1991 D.Lellouch Fix bug for ibm tape detach
*.  25-Mar-1991 D.Lellouch Handle DADLISTs as well
*.   7-Mar-1991 S.Weisz    Handle OPCAL files too.
*.   5-Fev-1991 S.Weisz    Temporary slight alteration.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER      LIO,LUN,TYPE,LBANK,LENOCC,LNEXT,LUNEXT,RC,ACMODE
     +            ,FLAGS,I1,I2,DEVICE
      CHARACTER*3  CHOPT
      CHARACTER*4  FCHOPT,CHID
      CHARACTER*6  STATUS
      CHARACTER*8  CHLUN,CHTAPE
      CHARACTER*80 CFNAME,CFNAM2,CFNAM3
      LOGICAL      LREAD,LSAME,LQUIET,LEMPTY
+SEQ,RCREP.
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
+SEQ,RCSYST.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,FMPAR.
+SELF,IF=SHIFT.
+SEQ,DADRFCDE.
+SELF.
      INTEGER NEVLST
      SAVE    NEVLST
      DATA    NEVLST/0/
*
      CALL UHTOC(IQIDH(LIO),4,CHID,4)
      LUN    = IQ(LIO+JLUN)
      TYPE   = IQ(LIO+JFNTYP)
      ACMODE = IQ(LIO+JACMOD)
      FLAGS  = IQ(LIO+JFLAGS)
      DEVICE = IQ(LIO+JDEVIC)
      CALL UHTOC(IQ(LIO+JFCHOP),4,FCHOPT,4)
      CALL UHTOC(IQ(LIO+JFNAME),NBYTEW,CFNAME,NAMLEN)
      LEMPTY=.TRUE.
*
      IF(CHID.EQ.'IOME') THEN
         LEMPTY = .FALSE.
         STATUS = 'KEEP'
      ELSE IF(CHID.EQ.'IOCA') THEN
         STATUS = 'KEEP'
      ELSE IF(CHID.EQ.'IODI'.AND.BTEST(FLAGS,EVTLIS)) THEN
         LEMPTY = .FALSE.
         STATUS = 'KEEP'
         LASTNI = 0
*-- Increment counter of event read on Event List.
         NEVLST = NEVLST + NEVDAD
         IF(LDADEX) THEN
            WRITE(CHREP,1000) LUN,NEVLST
            CALL REPORT('RCLSIO',11,'I')
         END IF
*-- Next the NanoDst will be closed.
         NEVLST = -NEVDAD
      ELSE IF(CHID.EQ.'IODI'.AND.BTEST(FLAGS,NANODS)) THEN
         LEMPTY = .FALSE.
         STATUS = 'KEEP'
*-- Increment counter of event read on Event List.
         NEVLST = NEVLST + NEVDAD
         IF(LDADEX) THEN
            WRITE(CHREP,1010) LUN,NEVDAD
            CALL REPORT('RCLSIO',8,'I')
         END IF
+SELF,IF=UNIX.
      ELSE IF(CHID.EQ.'IODI'.AND.LDADL
     +                      .AND..NOT.BTEST(FLAGS,INDIRF)) THEN
+SELF,IF=NOUNIX.
      ELSE IF(CHID.EQ.'IODI'.AND.LDADL) THEN
+SELF.
         LEMPTY = .FALSE.
         STATUS = 'KEEP'
         LASTNI = 0
*        the same message is printed br RNXTEV
*         IF(LDADEX) THEN
*            WRITE(CHREP,1020) LUN,NEVDAD
*            CALL REPORT('RCLSIO',1,'I')
*         END IF
      ELSE IF(CHID.EQ.'IOAO') THEN
         LEMPTY = IQ(LIO+JACTIV).LT.2
         IF(LEMPTY) THEN
            STATUS = 'DELETE'
         ELSE
            STATUS = 'KEEP'
         END IF
         IF(LDADEX.OR..NOT.BTEST(FLAGS,CLSQUI)) THEN
            WRITE(CHREP,1030) LUN,IQ(LIO+JACTIV)-1
            CALL REPORT('RCLSIO',2,'I')
         END IF
      ELSE
*-- The following is not for metafiles
         LEMPTY = IQ(LIO+JACTIV).LT.2.AND..NOT.LREAD
         LSAME  = .FALSE.
         CHOPT  = 'T'
*-- If file opened with CFOPEN, then add X to close it properly
         IF(INDEX(FCHOPT,'L').GT.0) CALL RADDOP(CHOPT,'X')
*-- Mark that EOF on INput has occured
         LEOFIN = .TRUE.
*-- Will next file be on same unit?
*-- If yes, dirty trick to please FZ on the IBM only
+SELF,IF=IBM.
         IF(BTEST(FLAGS,VARNAM)) THEN
            LSAME  = .TRUE.
         ELSE
            LNEXT  = LQ(LIO)
            IF(LNEXT.GT.0) THEN
               LUNEXT = IQ(LNEXT+JLUN)
               LSAME  = LUNEXT.EQ.LUN
            END IF
         END IF
         IF(LSAME) THEN
            IF(LREAD) THEN
               CHOPT  = 'I'
            ELSE
               CHOPT  = 'O'
            END IF
         END IF
+SELF.
*-- Close the FZ File
         LQUIET = BTEST(FLAGS,CLSQUI)
         IF(LQUIET) CHOPT  = CHOPT(1:LENOCC(CHOPT))//'Q'
         IF(LREAD) THEN
            LASTCI = LUN
*-- Let FATMEN call FZENDI.
            IF(TYPE.NE.2) CALL FZENDI(LUN,CHOPT)
+SELF,IF=SHIFT.
*     FZFILE was called in channel mode, so FZ doesnt know the file
      IF ( LDACIN ) CALL CFCLOS(LCIOLU(LUN))
+SELF.
         ELSE
            LASTCO = LUN
*-- Reset to normal Log level on output.
            CALL FZLOGL(LUN,0)
*-- Let FATMEN call FZENDO.
            IF(TYPE.NE.2) CALL FZENDO(LUN,CHOPT)
         END IF
         IF(LEMPTY) THEN
            STATUS = 'DELETE'
         ELSE
            STATUS = 'KEEP'
         END IF
      END IF
*-- If file opened with CFOPEN, no need to close it with FORTRAN.
+SELF,IF=-SHIFT.
      IF(INDEX(FCHOPT,'L').EQ.0 .AND. LUN.NE.5)
     +CLOSE(LUN,STATUS=STATUS)
+SELF,IF=SHIFT.
      IF(INDEX(FCHOPT,'L').EQ.0) THEN
        IF(FCHOPT.NE.'DADO') THEN
          IF(LUN.NE.5)CLOSE(LUN,STATUS=STATUS)
        ELSE
*-- Output DADlists are closed with CIO close
          CALL CFCLOS(LCIOLU(LUN),0)
        ENDIF
      ENDIF
+SELF.
*
      IF(CHID.EQ.'IOCA') THEN
*-- Calibration file, simply deactivate and return.
         IQ(LIO+JACTIV) = 0
                                                               GO TO 999
      END IF
      IF(TYPE.EQ.2) THEN
*-- Fatmen file
         WRITE(CHLUN,1040) LUN
         IF(LREAD) THEN
            CHOPT  = 'DE'
         ELSE
            CHOPT  = 'DPE'
         END IF
         CALL UCOPY(IQ(LIO+JFKEYS),SELKEY,KEYLEN)
         CHREP  = 'Fatmen closing of: '//CFNAME(1:LENOCC(CFNAME))
         CALL REPORT('RCLSIO',3,'I')
         CALL RZCDIR('//CERN',' ')
         CALL FMGETK(CFNAME(1:LENOCC(CFNAME)),LBANK,SELKEY,RC)
         IF(RC.EQ.0) THEN
            CALL FMCLOS(CFNAME(1:LENOCC(CFNAME)),CHLUN,LBANK,CHOPT,RC)
            IF(RC.NE.0) THEN
               WRITE(CHREP,1050) 'FMCLOS',RC
               CALL REPORT('RCLSIO',4,'E')
            END IF
         ELSE
            WRITE(CHREP,1050) 'FMGETK',RC
            CALL REPORT('RCLSIO',5,'E')
         END IF
      ELSE
*-- Not Fatmen
         IF(ACMODE.EQ.0.AND..NOT.LEMPTY) THEN
*-- A disk file was used
            IF(BTEST(FLAGS,VARNAM)) THEN
*-- Rename the variable name file
               CALL RNWNAM(LUN,CFNAME,CFNAM2,.TRUE.)
               CALL RNWNAM(LUN,CFNAME,CFNAM3,.FALSE.)
+SELF,IF=IBM.
               SYSCOM = 'RENAME '//CFNAM2(2:LENOCC(CFNAM2))
               SYSCOM = SYSCOM(1:LENOCC(SYSCOM)+1)//CFNAM3(2:)
               CALL RQSYST(.FALSE.)
               CFNAME = CFNAM3
+SELF,IF=VAX.
               CALL LIB$RENAME_FILE(CFNAM2,CFNAM3)
+SELF,IF=UNIX.
               SYSCOM = '/bin/mv '//CFNAM2(1:LENOCC(CFNAM2))//
     +                         ' '//CFNAM3(1:LENOCC(CFNAM3))
               CALL RQSYST(.TRUE.)
+SELF.
            END IF
+SELF,IF=IBM.
            IF(BTEST(FLAGS,DUMPER)) THEN
*-- It has to be disk DUMPed and ERased
               SYSCOM = 'DISK DUMP '//CFNAME(2:LENOCC(CFNAME))
               CALL RQSYST(.NOT.LQUIET)
               SYSCOM = 'ERASE '//CFNAME(2:LENOCC(CFNAME))
               CALL RQSYST(.FALSE.)
            END IF
            IF(BTEST(FLAGS,PLOTIT)) THEN
*-- It has to be disk PLotted and ERased
               SYSCOM = PLTCMD//CFNAME(2:LENOCC(CFNAME)+1)
     +                //PLTOPT(1:1+LENOCC(PLTOPT))//PLTTER
               CALL RQSYST(.NOT.LQUIET)
               SYSCOM = 'ERASE '//CFNAME(2:LENOCC(CFNAME))
               CALL RQSYST(.TRUE.)
            END IF
         ELSE IF(ACMODE.EQ.1) THEN
*-- A tape was mounted . Will we need it again?
            CALL RSBWRD(CFNAME,1,I1,I2)
            CHTAPE = CFNAME(I1:I2)
            LNEXT  = LQ(LIO)
            IF(LNEXT.GT.0) THEN
               CALL UHTOC(IQ(LNEXT+JFNAME),NBYTEW,CFNAM2,NAMLEN)
               CALL RSBWRD(CFNAM2,1,I1,I2)
               LSAME  = CHTAPE.EQ.CFNAM2(I1:I2)
            ELSE
               LSAME  = .FALSE.
            END IF
            IF(LSAME) THEN
*-- Mark next tape.
               IQ(LNEXT+JFLAGS) = IBSET(IQ(LNEXT+JFLAGS),SAMTAP)
               IQ(LNEXT+JDEVIC) = DEVICE
               CHREP  = 'Keeping tape '//CHTAPE//' for further use'
               CALL REPORT('RCLSIO',6,'I')
            ELSE
               CHREP  = 'Detaching tape: '//CHTAPE
               CALL REPORT('RCLSIO',7,'I')
               SYSCOM = 'CP DETACH '//DVNAME(DEVICE)
               CALL RQSYST(.FALSE.)
** get rid of SETUP CLEAR - kills output!
*               SYSCOM = 'SETUP CLEAR'
*               CALL RQSYST(.FALSE.)
               LDVALL(DEVICE) = .FALSE.
            END IF
         ELSE IF(ACMODE.EQ.2.OR.ACMODE.EQ.3) THEN
*-- A tape was staged.
            IF(INDEX(FCHOPT,'X').GT.0) THEN
               WRITE(CHLUN,1060) LUN
            ELSE
*-- Deliberate choice: reopen on same channel.
               WRITE(CHLUN,1070) LUN,1
            END IF
            SYSCOM = 'EXEC STAGE DROP '//CHLUN
            CALL RQSYST(.TRUE.)
+SELF.
         END IF
      END IF
      IF(LREAD) THEN
*-- Drop the bank describing this file (read mode).
         CALL MZDROP(IXSTOR,LIO,'.')
      ELSE
*-- Mark the file as inactive (write mode).
         IQ(LIO+JACTIV) = 0
      END IF
 999  CONTINUE
*
      RETURN
 1000 FORMAT('End of file on event list unit',I3,
     +       ';',I7,' events were read in')
 1010 FORMAT('End of file on Nano DST unit',I3,
     +       ';',I7,' events were read in')
* 1020 FORMAT('EOF on DAD List unit',I3,
*     +       ' it contained',I7,' events')

 1030 FORMAT('Closing output DAD List on unit',I3,
     +       ';',I7,' events were written')
 1040 FORMAT(I2)
 1050 FORMAT('Return code from ',A,' : ',I3)
 1060 FORMAT('IOFILE',I2.2)
 1070 FORMAT('FT',I2.2,'F',I3.3)
      END
+DECK,RCNTLB.
      SUBROUTINE RCNTLB
*.
*...RCNTLB  Batch ROPE control routine
*.
*. SEQUENCE: ROBANK CRO RCNTRL RCREP
*. CALLS   : QNEXTE ROPPAK ROPINI ROPSET FFGO TIMEX ZPHASE FZOUT RDUMLD
*. CALLED  : RMAINB
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-87
*. LAST MOD: 20-May-97
*.
*. Modification Log.
*. 20-May-97 E.Barberio  Report a CRASH if errors in FFREAD cards found
*. 27-Mar-91 S.Weisz     Call RDUMLD to help the linker.
*. 23-Jan-91 D.Lellouch  Notify user in case of FFREAD errors.
*.  6-Jun-90 S.Weisz     Constant retrieval version on Vax.
*. 11-Feb-88 S.Weisz     ZEBRA trouble recovery;calls QNEXTE.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IDUM
      INTEGER LUNCON
      PARAMETER(LUNCON=23)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
*-- Try to avoid linking problems.
      IDUM   = 0
      CALL RDUMLD(IDUM)
*-- Set interactive flag IRINTR <OFF>.
      IRINTR = 0
*-- Initializes ZEBRA,HBOOK and FFREAD.
      CALL ROPPAK
*-- Initialize and set default values for ROPE processors.
      CALL ROPINI
*-- Read data cards.
      CALL FFGO
      IF(FFERRO) THEN
         CHREP = 'Error(s) found when processing FFREAD cards'
         CALL REPORT('RCNTLB',1,'C')
      END IF
*-- Set RUN parameters.
      CALL ROPSET
+SELF,IF=ROPECONR.
*-- Retrieve calibration constants.
      CALL RGETCA
*-- Open FZ file.
      OPEN(UNIT=LUNCON,STATUS='NEW',FORM='FORMATTED',RECL=80,
     +     RECORDTYPE='FIXED',CARRIAGECONTROL='LIST',ERR=999)
      CALL FZFILE(LUNCON,0,'OAP')
*-- Then write out the constant record.
      IUHEAD(IIDAT) = 105
      CALL FZOUT(LUNCON,IROCON,LRCO,1,'.',IOHEAD,NUHMAX,IUHEAD)
      CALL FZENDO(LUNCON,'TQ')
      CLOSE(UNIT=LUNCON)
  999 STOP
+SELF,IF=-ROPECONR.
*-- Set ZEBRA phase to Zero to enable exit to QNEXT.
      CALL ZPHASE(0)
*-- Now ready for the GO step.
      CALL TIMEX(RTIMST)
+SELF,IF=-ROPECONR,IF=-ONLINE.
      CALL QNEXTE
+SELF,IF=-ROPECONR,IF=ONLINE.
      CALL QNEXT
+SELF.
      END
+DECK,RDDMRK.
      SUBROUTINE RDDMRK
*.
*...RDDMRK   Mark banks to be kept as 'DDST' output
*.
*. SEQUENCE  : ROBANK
*. CALLS     : MZMARK
*. CALLED    : ROWOUT
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 23-0ct-1990
*. LAST MOD  : 24-Aug-1994
*.
*. Modification log:
*. 24-Aug-94 M.Redmond   Remove ODEM bank from list
*. 10-Feb-92 O.Schaile   'FD ' =>'FO  ', save CIDHDD
*. 28-Aug-91 S.Weisz     FTN77 does not accept hollerlith in data stat.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER     NIDHDD,IDHDD,I
      LOGICAL     KILROY
      CHARACTER*4 CIDHDD
      PARAMETER   (NIDHDD=13)
      DIMENSION   IDHDD(NIDHDD),CIDHDD(NIDHDD)
      SAVE        IDHDD,KILROY,CIDHDD
*
+SEQ,ROBANK.
*
      DATA KILROY/.FALSE./
      DATA CIDHDD/'UT  ','DA  ',
     +            'CD  ','EC  ','HC  ','MU  ','FO  ',
     +            'TRIG','LEP ','VERH','KINH','CHEA','ODHM'/
*
      IF(.NOT.KILROY) THEN
         KILROY=.TRUE.
         DO 10 I=1,NIDHDD
            CALL UCTOH(CIDHDD(I),IDHDD(I),4,4)
  10     CONTINUE
      ENDIF
*
      CALL MZMARK(IXSTOR,LREV,'-',NIDHDD,IDHDD)
*
  999 RETURN
      END
+DECK,RDGMRK.
      SUBROUTINE RDGMRK
*.
*...RDGMRK   Mark banks to be kept as 'SCAN' output
*.
*. SEQUENCE  : ROBANK
*. CALLS     : MZMARK
*. CALLED    : ROWOUT
*.
*. AUTHOR    : D.Ward
*. VERSION   : 1.01
*. CREATED   : 11-Sep-1989
*. LAST MOD  : 11-Sep-1989
*.
*. Modification log:
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER I
      LOGICAL KILROY
      SAVE    KILROY
      SAVE    IDH
*
+SEQ,ROBANK.
+SEQ,GRNEED.
*
      DATA KILROY/.FALSE./
      IF(.NOT.KILROY) THEN
         KILROY=.TRUE.
         DO 10 I=1,NIDH
            CALL UCTOH(CIDH(I),IDH(I),4,4)
  10     CONTINUE
*
      ENDIF
*
      CALL MZMARK(IXSTOR,LREV,'L',NIDH,IDH)
*
      END
+DECK,RDPMRK.
      SUBROUTINE RDPMRK
*.
*...RDPMRK   Mark banks to be kept as 'PROD' output
*.
*. SEQUENCE  : ROBANK
*. CALLS     : MZMARK
*. CALLED    : ROWOUT
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 11-Sep-1989
*. LAST MOD  : 10-Feb-92
*.
*. Modification log:
*. 10-Feb-92 O.Schaile   'FD ' =>'FO  ', save CIDHDP
*. 28-Aug-91 S.Weisz     FTN77 does not accept hollerlith in data stat.
*.  5-Apr-90 S.Weisz     Keep DD banks.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER     NIDHDP,IDHDP,I
      LOGICAL     KILROY
      CHARACTER*4 CIDHDP
      PARAMETER   (NIDHDP=9)
      DIMENSION   IDHDP(NIDHDP),CIDHDP(NIDHDP)
      SAVE        IDHDP,KILROY,CIDHDP
*
+SEQ,ROBANK.
*
      DATA KILROY/.FALSE./
      DATA CIDHDP/'CD  ','EC  ','HC  ','MU  ','FO  ',
     +            'TRIG','LEP ','VERH','KINH'/
*
      IF(.NOT.KILROY) THEN
         KILROY=.TRUE.
         DO 10 I=1,NIDHDP
            CALL UCTOH(CIDHDP(I),IDHDP(I),4,4)
  10     CONTINUE
      ENDIF
*
      CALL MZMARK(IXSTOR,LREV,'-',NIDHDP,IDHDP)
*
  999 RETURN
      END
+DECK,RDSMRK.
      SUBROUTINE RDSMRK
*.
*...RDSMRK   Mark banks to be dropped on 'DST ' output
*.
*. SEQUENCE  : ROBANK
*. CALLS     : MZMARK
*. CALLED    : ROWOUT
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 11-Sep-1989
*. LAST MOD  : 24-Aug-1994
*.
*. Modification log:
*. 24-Aug-94 M.Redmond   Remove ODEM bank from list
*. 14-May-93 O.Schaile   Add 'DDLU'
*. 21-Sep-92 C.Hawkes    Add 'DDCD' and 'DDOU'
*. 10-Feb-92 O.Schaile   'FD ' =>'FO  ', save CIDHDD
*. 28-Aug-91 S.Weisz     FTN77 does not accept hollerlith in data stat.
*. 23-Oct-90 S.Weisz     Drop DD banks, DDST handled in RDDMRK.
*.  5-Apr-90 S.Weisz     Keep DD banks.
*. 20-Mar-90 A.Lee       Keep condense lumi record.
*. 10-Feb-90 S.Weisz     Drop CHEAT words too.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER     NIDHDS,IDHDS,I
      LOGICAL     KILROY
      CHARACTER*4 CIDHDS
      PARAMETER   (NIDHDS=17)
      DIMENSION   IDHDS(NIDHDS),CIDHDS(NIDHDS)
      SAVE        IDHDS,KILROY,CIDHDS
*
+SEQ,ROBANK.
*
      DATA KILROY/.FALSE./
      DATA CIDHDS/'UT  ','DA  ',
     +            'CD  ','EC  ','HC  ','MU  ','FO  ',
     +            'DD  ','DDCD','DDOU','DDLU',
     +            'TRIG','LEP ','VERH','KINH','CHEA','ODHM'/
*
      IF(.NOT.KILROY) THEN
         KILROY=.TRUE.
         DO 10 I=1,NIDHDS
            CALL UCTOH(CIDHDS(I),IDHDS(I),4,4)
  10     CONTINUE
      ENDIF
*
      CALL MZMARK(IXSTOR,LREV,'-',NIDHDS,IDHDS)
*
  999 RETURN
      END
+DECK,RDUMLD.
      SUBROUTINE RDUMLD(IDUM)
*.
*...RDUMLD   This is a dummy routine to help the linking
*.
*. CALLS     : PROB QNEXT RFUSER ZTELUS ZEND CVDDUT JCCFTI JCCFSZ
*.             ROUPON ROUVER RPTREE
*.             JCPACK JCFNTT CJBRE4 CJDDT4 CJFON4
*.             CTFXJZ CZPNTR CZUDIG
*.             EECAL  HPFMUB HPFNMU
*. CALLED    : RCNTLB RCNTLI
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 27-Mar-1991
*. LAST MOD  : 11-Apr-1994
*.
*. Modification log:
*. 11-Apr-94 M.Redmond   Remove JCFNTP, JCFNTS, EEDDUP, EEDDPK
*. 25-Oct-93 O.Schaile   Add RGETLU, REVTYP, remove CVDDUT
*. 27-Aug-93 M.Redmond   Add RPTREE
*.  3-Oct-92 O.Schaile   Add PROB
*.  3-Sep-91 S.Weisz     Add calls to JCZQER and JCZTIM
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER IDUM
      LOGICAL REVTYP,LDUMMY
      REAL X, PROB
*
      IF(IDUM.LE.1000)                                         GO TO 999
      LDUMMY=REVTYP(1)
      CALL RGETLU
      X=PROB(1.,2)
      CALL QNEXT
      CALL RFUSER
      CALL ZTELUS
      CALL ZEND
      CALL ROUPON
      CALL ROUVER
      CALL RPTREE(0)
      CALL JCZQER
      CALL JCZTIM
      CALL JCCFTI
      CALL JCCFSZ
      CALL JCPACK
      CALL JCFNTT
      CALL CJBRE4
      CALL CJDDT4
      CALL CJFON4
      CALL CTFXJZ
      CALL CZPNTR
      CALL CZUDIG
      CALL EECAL
      CALL HPFMUB
      CALL HPFNMU
*
  999 RETURN
      END
+DECK,RFCINI.
      SUBROUTINE RFCINI(LUN,CATNAM)
*.
*...RFCINI Initialise private catalog routines.
*.
*. SEQUENCE : RCNTRL ROUNIT RCREP
*. CALLS    : REPORT LENOCC
*. CALLED   : RSCATA
*.
*. AUTHOR   : A.Buijs
*. CREATED  : 29-Oct-90
*. LAST MOD :  7-May-99
*.
*. INPUT    : LUN       Logical unit number
*. INPUT    : CATNAM    Catalog name.
*.
*. SEQUENCE : RCREP
*.
*. Modification log:
*.  7-May-99 M.Schroder   Add PCLINUX flag
*. 30-Oct-95 O.Schaile    Use CIO for UNIX
*. 11-Sep-91  S.Weisz     RECL in byte on APOLLO for unformatted files.
*.  2-Sep-91  A.Lee       Only one routine for Vax, Apollo and SGI.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*(*) CATNAM
      INTEGER LUN,IRECL,IOSTAT,LENOCC
*
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCREP.
*
      IRECL  = 40
+SELF,IF=VAX,DECS.
      OPEN(UNIT=LUN,FILE=CATNAM,STATUS='OLD',READONLY,
     +     FORM='UNFORMATTED',RECL=IRECL,ACCESS='DIRECT',
     +     ERR=10,IOSTAT=IOSTAT)
+SELF,IF=APOLLO,SGI,HPUX,IBMRT,SUN,PCLINUX.
      CALL CFOPEN(LUN,0,IRECL,'r',0,CATNAM,IOSTAT)
      IF(IOSTAT.NE.0)GOTO 10
+SELF,IF=VAX,UNIX.
      LUNCAT = LUN
                                                               GO TO 999
   10 WRITE(CHREP,1000) IOSTAT,CATNAM(1:LENOCC(CATNAM))
      CALL REPORT('RFCINI',1,'E')
+SELF.
      FFERRO = .TRUE.
*
 999  RETURN
1000  FORMAT('Error',I4,' while opening catalog:',A)
      END
+DECK,RFCLISV,IF=VAX.
      SUBROUTINE RFCLIS(SEARCH,CFOUND,MAXLIN,NFOUND)
*.
*...RFCLIS Expand and search a user catalog.
*.
*. CALLS    : REPORT RSBWRD LENOCC
*. CALLED   : RIOCAT
*.
*. AUTHOR   : A.Buijs
*. CREATED  : 29-Oct-90
*. LAST MOD :  2-Sep-91
*.
*. INPUT    : SEARCH    The search string
*. OUTPUT   : CFOUND    The strings found
*. INPUT    : MAXLIN    Maximum number of files
*. OUTPUT   : NFOUND    Number of files found
*.
*. SEQUENCE : RCREP
*.
*. Modification log:
*.    2-Sep-91  A.Lee       Catalog now open unformatted.
*.   29-Nov-90  D.Lellouch  Prefix  by //CERN/OPAL if necessary
*.                          Fix bug; make it more vax independent
*.                          Do not remove the node name
*.
*.*********************************************************************
+SEQ,DECLARE.
      CHARACTER*(*) SEARCH
      CHARACTER*(*) CFOUND(*)
      CHARACTER*132 CDBS,CSEAR
      INTEGER       MAXLIN,NFOUND,IREC,I1,I2,LDBS,LENOCC,LSEAR
+SEQ,ROUNIT.
+SEQ,RCREP.
*
      NFOUND = 0
*     Prefix  by  //CERN/OPAL/  if necessary
      CALL CLTOU(SEARCH)
      IF(SEARCH(1:12).EQ.'//CERN/OPAL/') THEN
         CSEAR  = SEARCH
      ELSE IF(SEARCH(1:11).EQ.'/CERN/OPAL/') THEN
         CSEAR  = '/'//SEARCH
      ELSE IF(SEARCH(1:1).EQ.'/')  THEN
         CSEAR  = '//CERN/OPAL'//SEARCH
      ELSE
         CSEAR  = '//CERN/OPAL/'//SEARCH
      END IF
*
      LSEAR  = LENOCC(CSEAR)
      IREC   = 1
   10 READ(UNIT=LUNCAT,REC=IREC,ERR=999) CDBS
      IREC   = IREC + 1
      LDBS   = LENOCC(CDBS)
      IF(LDBS.EQ.0)                                             GO TO 10
*-- Check if the database entry just read is one requested.
      IF(INDEX(CDBS,CSEAR(1:LSEAR)).EQ.0)                       GO TO 10
      CALL RSBWRD(CDBS,2,I1,I2)
      NFOUND = NFOUND + 1
      CFOUND(NFOUND) = CDBS(I1:I2)
*-- Get the next database entry.
      IF(NFOUND.LE.MAXLIN)                                      GO TO 10
*-- The whole database is read. Close the file, do not say a word.
*-- And return.
 999  RETURN
      END
+DECK,RFCLISU,IF=UNIX.
      SUBROUTINE RFCLIS(SEARCH,CFOUND,MAXLIN,NFOUND)
*.
*...RFCLIS Expand and search a user catalog.
*.
*. CALLS    : REPORT RSBWRD LENOCC
*. CALLED   : RIOCAT RCATDA
*.
*. AUTHOR   : A.Buijs
*. CREATED  : 29-Oct-90
*. LAST MOD : 18-Apr-96
*.
*. INPUT    : SEARCH    The search string
*. OUTPUT   : CFOUND    The strings found
*. INPUT    : MAXLIN    Maximum number of files
*. OUTPUT   : NFOUND    Number of files found
*.
*. SEQUENCE : RCREP
*.
*. Modification log:
*.   18-Apr-96 M.Schroder   Add CFSEEK to enable multiple reads of catalog
*.   30-Oct-95 O.Schaile    Use CIO
*.   22-Feb-95  G.Duckeck   Sort and uniq catalog entries
*.   07-Jul-91  S.Weisz     Adapt to SHIFT
*.
*.*********************************************************************
+SEQ,DECLARE.
      CHARACTER*(*) SEARCH
      CHARACTER*(*) CFOUND(*)
      CHARACTER*160 CDBS,CSEAR
      INTEGER       MAXLIN,NFOUND
      INTEGER       NWRD,I1,I2,LDBS,LENOCC,LSEAR,IOS,IDEL
*
      CHARACTER*160 CFLAST
      INTEGER I, NFNEW, CLEN
*
+SEQ,ROUNIT.
+SEQ,RCREP.
*
      NFOUND = 0
*     Prefix  by  //CERN/OPAL/  if necessary
      CALL CLTOU(SEARCH)
      IF(SEARCH(1:12).EQ.'//CERN/OPAL/') THEN
         CSEAR  = SEARCH
      ELSE IF(SEARCH(1:11).EQ.'/CERN/OPAL/') THEN
         CSEAR  = '/'//SEARCH
      ELSE IF(SEARCH(1:1).EQ.'/')  THEN
         CSEAR  = '//CERN/OPAL'//SEARCH
      ELSE
         CSEAR  = '//CERN/OPAL/'//SEARCH
      END IF
*
      LSEAR  = LENOCC(CSEAR)
      CALL CFSEEK(LUNCAT,0, 40, 0, IOS)
      IF (IOS .NE. 0) THEN
         CHREP = 'CFSEEK to start of catalog failed.'
         CALL REPORT ('RFCLIS',1,'E')
         GOTO 999
      ENDIF
10    NWRD=40
      CALL CFGET(LUNCAT,0,40,NWRD,CDBS,IOS)
      IF(IOS.NE.0)                                             GO TO 999
      LDBS   = LENOCC(CDBS)
      IF(LDBS.EQ.0)                                             GO TO 10
*-- Check if the database entry just read is one requested.
      IF(INDEX(CDBS,CSEAR(1:LSEAR)).EQ.0)                       GO TO 10
      CALL RSBWRD(CDBS,2,I1,I2)
      NFOUND = NFOUND + 1
      CFOUND(NFOUND) = CDBS(I1:I2)
*-- Drop node name from file name.
      IDEL  = INDEX(CFOUND(NFOUND),'::')
      IF(IDEL.GE.1.AND.IDEL.LT.I2-I1-1)
     +   CFOUND(NFOUND) = CDBS(I1+IDEL+1:I2)
*-- Get the next database entry.
      IF(NFOUND.LE.MAXLIN)                                      GO TO 10
*-- The whole database is read. Close the file, do not say a word.
*-- And return.
  999 CONTINUE
*
*-- GD: do unique sort
      IF ( NFOUND .GE. 2 ) THEN
         CALL SORCHA(CFOUND,1, 80, NFOUND, 3 )
         CFLAST = CFOUND(1)
         NFNEW = 1
         DO 20 I = 2, NFOUND
            CLEN = LENOCC(CFOUND(I))
            IF ( CFOUND(I)(1:CLEN) .NE. CFLAST(1:CLEN) ) THEN
               NFNEW = NFNEW + 1
               CFOUND(NFNEW) = CFOUND(I)
               CFLAST = CFOUND(I)
            ENDIF
 20      CONTINUE
         NFOUND = NFNEW
      ENDIF
*
      RETURN
+SELF.
      END
+DECK,RFCLIS,IF=-VAX,IF=NOUNIX.
      SUBROUTINE RFCLIS(SEARCH,LINES,MAXLIN,NFOUND)
*.
*...RFCLIS Expand and search a user catalog
*.
*. CALLS   :
*. CALLED  : RIOCAT
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER       MAXLIN,NFOUND
      CHARACTER*(*) SEARCH,LINES(MAXLIN)
      END
+DECK,RFGNCT.
      SUBROUTINE RFGNCT
*.
*...RFGNCT   Fill GNCT bank (Magnetic field and beam position)
*.
*. SEQUENCE  : ROBANK ROPAR ROCPAR RCREP
*. CALLS     : SUBEAM MZBOOK REPORT
*. CALLED    : RGETCA RGETDA
*.
*. BANK L    : GNCT MAGF BEAM
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 10-Oct-1990
*. LAST MOD  : 22-Jun-1994
*.
*. Modification log:
*.   22-Jun-94  C.Hawkes    Don't print beam data until first event
*.   19-May-94  C.Hawkes    REPORT beam width and vertex error also
*.   20-Oct-93  C.Hawkes    REPORT beam spot position also
*.   18-Oct-93  C.Hawkes    REPORT where 'BEAM' bank filled from
*.    7-Oct-93  Kowalewski  Now use on MC data also.  Calls SUBEAM
*.                          on MC unless beam bank already existing
*.   19-Jul-93  M.Redmond   Protect links
*.   27-Mar-91  S.Weisz     Modify call to SUBEAM, expand BEAM bank
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LGNCT ,LMAGF ,LBEAM, LRDTMP
      COMMON /ROTMPL/ LRDTMP(2), LGNCT, LMAGF, LBEAM
      INTEGER INCNL,INCND
      INTEGER INFO
      REAL    BFIELD,XYZ,SIGXYZ,EXYZ
*-- This should go in some database .......
      PARAMETER (BFIELD=4.350)
      DIMENSION XYZ(3),SIGXYZ(3),EXYZ(3)
*
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,RCREP.
      INTEGER I
      LOGICAL FIRST
      SAVE    FIRST
      DATA    FIRST/.TRUE./
*
      CALL MZLINT(IXSTOR,'/ROTMPL/',LRDTMP,LGNCT,LBEAM)
      LGNCT = LQ(LDAC-LLGNCT)
*-- Book GNCT bank if needed.
      IF(LGNCT.LE.0) THEN
         CALL MZBOOK(IROCON,LGNCT,LDAC ,-LLGNCT,'GNCT',
     +               NLGNCT,NSGNCT,NDGNCT,IOGNCT,0)
      ELSE
*-- Extend link/data part if needed.
         INCNL = 0
         INCND = 0
         IF(IQNS(LGNCT).LT.NSGNCT) INCNL = NSGNCT - IQNS(LGNCT)
         IF(IQND(LGNCT).LT.NDGNCT) INCND = NDGNCT - IQND(LGNCT)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LGNCT,INCNL,INCND,'.')
            CHREP = 'GNCT bank must be expanded'
            CALL REPORT('RFGNCT',1,'W')
         END IF
      END IF
      LMAGF = LQ(LGNCT-LLMAGF)
*-- Book MAGF bank if needed.
      IF(IUHEAD(IIEXPT).LT.1000) THEN
       IF(LMAGF.LE.0) THEN
        CALL MZBOOK(IROCON,LMAGF,LGNCT,-LLMAGF,'MAGF',
     +                           NLMAGF,NSMAGF,NDMAGF,IOMAGF,0)
       ENDIF
*-- Fill magnetic field (very crude!)
       Q(LMAGF+IMEANB) = BFIELD
      ENDIF
*
      LBEAM = LQ(LGNCT-LLBEAM)
*-- Book BEAM bank if needed.
      IF(LBEAM.LE.0) THEN
         CALL MZBOOK(IROCON,LBEAM,LGNCT,-LLBEAM,'BEAM',
     +               NLBEAM,NSBEAM,NDBEAM,IOBEAM,0)
      ELSE
*-- Extend link/data part if needed.
         INCNL = 0
         INCND = 0
         IF(IQNS(LBEAM).LT.NSBEAM) INCNL = NSBEAM - IQNS(LBEAM)
         IF(IQND(LBEAM).LT.NDBEAM) INCND = NDBEAM - IQND(LBEAM)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LBEAM,INCNL,INCND,'.')
            CHREP = 'BEAM bank must be expanded'
            CALL REPORT('RFGNCT',2,'W')
         END IF
      END IF
*-- Get beam position from SUBEAM.
      CALL SUBEAM(XYZ,SIGXYZ,EXYZ,INFO)
*-- Store it if real data or if MC info was available from SU;
*-- otherwise, leave the BEAM bank alone, since it might be useful.
      IF(IUHEAD(IIEXPT).LT.1000.OR.INFO.EQ.1) THEN
        CALL UCOPY(XYZ(1),Q(LBEAM+1),3)
        CALL UCOPY(SIGXYZ(1),Q(LBEAM+4),3)
        CALL UCOPY(EXYZ(1),Q(LBEAM+7),3)
        IF(FIRST.AND.IUHEAD(IIEVT).GT.0)THEN
          CHREP = 'BEAM bank filled by SUBEAM'
          CALL REPORT('RFGNCT',3,'I')
        ENDIF
      ELSE
        IF(FIRST.AND.IUHEAD(IIEVT).GT.0)THEN
          CHREP = 'BEAM bank filled from constants record'
          CALL REPORT('RFGNCT',4,'I')
        ENDIF
      ENDIF
      IF(FIRST.AND.IUHEAD(IIEVT).GT.0)THEN
        FIRST=.FALSE.
        WRITE(CHREP,1000) (Q(LBEAM+I),I=1,3)
        CALL REPORT('RFGNCT',5,'I')
        WRITE(CHREP,1001) (Q(LBEAM+I),I=4,6)
        CALL REPORT('RFGNCT',6,'I')
        WRITE(CHREP,1002) (Q(LBEAM+I),I=7,9)
        CALL REPORT('RFGNCT',7,'I')
      ENDIF
*
      LRDTMP(1) = 0
  999 RETURN
*
 1000 FORMAT('Beam vertex, (x,y,z) in cm:',3E10.2)
 1001 FORMAT('Beam width,  (x,y,z) in cm:',3E10.2)
 1002 FORMAT('Vertex error,(x,y,z) in cm:',3E10.2)
*
      END
+DECK,RFLSET.
      SUBROUTINE RFLSET
*.
*...RFLSET   Set processing flags ON.
*.
*. SEQUENCE: ROBANK RCNTRL ROCPAR ODPAR ODCOM1 RCREP
*. CALLS   : VZERO REPORT RGETNB UCTOH
*. CALLED  : ROPSET ROCENT ROECAL ROFORW ROHCAL ROMUON
*.
*. BANKS M : RCO CDC ECC HCC MUC FOC ADC ODC
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 24-May-88
*. LAST MOD: 29-Apr-96
*.
*. Modification Log.
*. 29-Apr-96  M.Schroder      Correct order of ECKEY elements
*. 28-Mar-96  O.Schaile       Introduce TE process.
*. 11-Mar-93  O.Schaile       put SW at position 3 in FOKEY
*. 10-Mar-93  O.Schaile       NFORW=2.
*.  3-Mar-93  O.Schaile       Introduce SW process.
*. 15-Jan-91  S.Weisz         Mods for DX,SI and CS processing
*. 10-Oct-90  S.Weisz         Modify IDBAT defaults
*.  5-Apr-90  S.Weisz         Remove treatment of AD processors
*. 10-Feb-90  S.Weisz         Set IFUPDT according to defaults and cards
*.  5-Apr-89  S.Weisz         Zero top steering banks.
*. 24-Mar-89  S.Weisz         Accept 'ALL ' on processor FFREAD cards.
*. 10-Mar-89  A.Buijs,S.Weisz Move OD steering initialization to ODSETR
*. 29-Aug-88  S.Weisz         Implement "RERUN" of processes.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IUCOMP
      INTEGER NPR,LKEY,LTEST,I,J,IDFLT,IHALL,ICENT,IECAL,IHCAL,
     +IMUON,IFORW
      CHARACTER*4 CDKEY,ECKEY,HCKEY,MUKEY,FOKEY
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,RCREP.
*
      DIMENSION LKEY(20)
      DIMENSION CDKEY(20),ECKEY(20),HCKEY(20),MUKEY(20),FOKEY(20)
      SAVE      CDKEY    ,ECKEY    ,HCKEY    ,MUKEY    ,FOKEY
*
      DATA CDKEY/'CV  ','CJ  ','CZ  ','CT  ','DX  ','CF  ','CX  ',
     +           'SI  ','CS  ','CE  ','CA  ',9*'TRUC'/
      DATA ECKEY/'TB  ','TE  ','PB  ','EB  ','PE  ','EE  ', 'EM  ',
     *            13*'TRUC'/
      DATA HCKEY/'HB  ','HE  ','HP  ','HM  ',16*'TRUC'/
      DATA MUKEY/'MB  ','ME  ','MM  ',17*'TRUC'/
      DATA FOKEY/'FD  ','TRUC','SW  ',17*'TRUC'/
*
      CALL UCTOH('    ',IDFLT,4,4)
      CALL UCTOH('ALL ',IHALL,4,4)
      CALL UCTOH('CD  ',ICENT,4,4)
      CALL UCTOH('EC  ',IECAL,4,4)
      CALL UCTOH('HC  ',IHCAL,4,4)
      CALL UCTOH('MU  ',IMUON,4,4)
      CALL UCTOH('FO  ',IFORW,4,4)
*-- Zero top steering banks (RCO,CDC,ECC,HCC,MUC,FOC,DDC)
      CALL VZERO(IQ(LRCO+1),NDRCO)
      CALL VZERO(IQ(LCDC+1),NDCDC)
      CALL VZERO(IQ(LECC+1),NDECC)
      CALL VZERO(IQ(LHCC+1),NDHCC)
      CALL VZERO(IQ(LMUC+1),NDMUC)
      CALL VZERO(IQ(LFOC+1),IQ(LFOC-1))
*-- Get processes to rerun from FFREAD cards.
      CALL RGETNB (LRERUN,NRERUN)
*-- Get Central Detector processes to run from FFREAD cards.
      CALL RGETNB (LCENT,NCENT)
      IF(NCENT.GE.1) THEN
         CALL UCTOH(CDKEY,LKEY,4,80)
         IF(LCENT(1).EQ.IHALL) THEN
*-- Select all CD processes
            NCENT=11
            J = 0
            DO 10 I=1,NCENT
*-- Skip CF processing.
               IF(I.EQ.6)                                       GO TO 10
               J = J + 1
               CALL UCTOH(CDKEY(I),LCENT(J),4,4)
   10       CONTINUE
            NCENT = NCENT-1
         END IF
         NPR = 0
         DO 30 I=1,NCENT
            LTEST = LCENT(I)
            DO 20 J=1,NDCDC
               IF(LKEY(J).EQ.LTEST) THEN
                  NPR=NPR+1
                  IF(IUCOMP(LTEST,LRERUN,NRERUN).NE.0) THEN
                     IQ(LCDC+J)=-NPR
                  ELSE IF(IUCOMP(ICENT,LRERUN,NRERUN).NE.0) THEN
                     IQ(LCDC+J)=-NPR
                  ELSE IF(IUCOMP(IHALL,LRERUN,NRERUN).NE.0) THEN
                     IQ(LCDC+J)=-NPR
                  ELSE
                     IQ(LCDC+J)=NPR
                  END IF
                                                                GO TO 30
               END IF
   20       CONTINUE
            WRITE(CHREP,1000) LTEST
            CALL REPORT('RFLSET',1,'W')
   30    CONTINUE
         IQ(LRCO+IIFCDC)=NPR
      END IF
*-- Get Electron Calorimeter processes to run from FFREAD cards.
      CALL RGETNB (LECAL,NECAL)
      IF(NECAL.GE.1) THEN
         CALL UCTOH(ECKEY,LKEY,4,80)
         IF(LECAL(1).EQ.IHALL) THEN
            NECAL = 7
            DO 40 I=1,NECAL
   40       CALL UCTOH(ECKEY(I),LECAL(I),4,4)
         END IF
         NPR=0
         DO 60 I=1,NECAL
            LTEST = LECAL(I)
            DO 50 J=1,NDECC
               IF(LKEY(J).EQ.LTEST) THEN
                  NPR=NPR+1
                  IF(IUCOMP(LTEST,LRERUN,NRERUN).NE.0) THEN
                     IQ(LECC+J)=-NPR
                  ELSE IF(IUCOMP(IECAL,LRERUN,NRERUN).NE.0) THEN
                     IQ(LECC+J)=-NPR
                  ELSE IF(IUCOMP(IHALL,LRERUN,NRERUN).NE.0) THEN
                     IQ(LECC+J)=-NPR
                  ELSE
                     IQ(LECC+J)=NPR
                  END IF
                                                                GO TO 60
               END IF
   50       CONTINUE
            WRITE(CHREP,1010) LTEST
            CALL REPORT('RFLSET',2,'W')
   60    CONTINUE
         IQ(LRCO+IIFECC)=NPR
      END IF
*-- Get Hadron Calorimeter processes to run from FFREAD cards.
      CALL RGETNB (LHCAL,NHCAL)
      IF(NHCAL.GE.1) THEN
         CALL UCTOH(HCKEY,LKEY,4,80)
         IF(LHCAL(1).EQ.IHALL) THEN
            NHCAL = 4
            DO 70 I=1,NHCAL
   70       CALL UCTOH(HCKEY(I),LHCAL(I),4,4)
         END IF
         NPR=0
         DO 90 I=1,NHCAL
            LTEST = LHCAL(I)
            DO 80 J=1,NDHCC
               IF(LKEY(J).EQ.LTEST) THEN
                  NPR=NPR+1
                  IF(IUCOMP(LTEST,LRERUN,NRERUN).NE.0) THEN
                     IQ(LHCC+J)=-NPR
                  ELSE IF(IUCOMP(IHCAL,LRERUN,NRERUN).NE.0) THEN
                     IQ(LHCC+J)=-NPR
                  ELSE IF(IUCOMP(IHALL,LRERUN,NRERUN).NE.0) THEN
                     IQ(LHCC+J)=-NPR
                  ELSE
                     IQ(LHCC+J)=NPR
                  END IF
                                                                GO TO 90
               END IF
   80       CONTINUE
            WRITE(CHREP,1020) LTEST
            CALL REPORT('RFLSET',3,'W')
   90    CONTINUE
         IQ(LRCO+IIFHCC)=NPR
      END IF
*-- Get Muon Detector processes to run from FFREAD cards.
      CALL RGETNB (LMUON,NMUON)
      IF(NMUON.GE.1) THEN
         CALL UCTOH(MUKEY,LKEY,4,80)
         IF(LMUON(1).EQ.IHALL) THEN
            NMUON = 3
            DO 100 I=1,NMUON
  100       CALL UCTOH(MUKEY(I),LMUON(I),4,4)
         END IF
         NPR=0
         DO 120 I=1,NMUON
            LTEST = LMUON(I)
            DO 110 J=1,NDMUC
               IF(LKEY(J).EQ.LTEST) THEN
                  NPR=NPR+1
                  IF(IUCOMP(LTEST,LRERUN,NRERUN).NE.0) THEN
                     IQ(LMUC+J)=-NPR
                  ELSE IF(IUCOMP(IMUON,LRERUN,NRERUN).NE.0) THEN
                     IQ(LMUC+J)=-NPR
                  ELSE IF(IUCOMP(IHALL,LRERUN,NRERUN).NE.0) THEN
                     IQ(LMUC+J)=-NPR
                  ELSE
                     IQ(LMUC+J)=NPR
                  END IF
                                                               GO TO 120
               END IF
  110       CONTINUE
            WRITE(CHREP,1030) LTEST
            CALL REPORT('RFLSET',4,'W')
  120    CONTINUE
         IQ(LRCO+IIFMUC)=NPR
      END IF
*-- Get Forward Detector processes to run from FFREAD cards.
      CALL RGETNB (LFORW,NFORW)
      IF(NFORW.GE.1) THEN
         CALL UCTOH(FOKEY,LKEY,4,80)
         IF(LFORW(1).EQ.IHALL) THEN
            NFORW = 2
            CALL UCTOH(FOKEY(1),LFORW(1),4,4)
            CALL UCTOH(FOKEY(3),LFORW(2),4,4)
         END IF
         NPR=0
         DO 150 I=1,NFORW
            LTEST = LFORW(I)
            DO 140 J=1, IQ(LFOC-1)
               IF(LKEY(J).EQ.LTEST) THEN
                  NPR=NPR+1
                  IF(IUCOMP(LTEST,LRERUN,NRERUN).NE.0) THEN
                     IQ(LFOC+J)=-NPR
                  ELSE IF(IUCOMP(IFORW,LRERUN,NRERUN).NE.0) THEN
                     IQ(LFOC+J)=-NPR
                  ELSE IF(IUCOMP(IHALL,LRERUN,NRERUN).NE.0) THEN
                     IQ(LFOC+J)=-NPR
                  ELSE
                     IQ(LFOC+J)=NPR
                  END IF
                                                               GO TO 150
               END IF
  140       CONTINUE
            WRITE(CHREP,1040) LTEST
            CALL REPORT('RFLSET',5,'W')
  150    CONTINUE
         IQ(LRCO+IIFFOC)=NPR
      END IF
*-- Set header update flag ( default = 0 except if OD is called )
      CALL RGETNB (LODBLK,NODBLK)
      IF(NODBLK.GE.1.AND.IFUPDT.LE.-1) IFUPDT = 1
      IF(IFUPDT.LE.0)                  IFUPDT = 0
*-- Set flag to call DDBAT ( default = 0 except if OD is called )
      IF(NODBLK.GE.1.AND.IDDBAT.LE.-1) IDDBAT = 1
      IF(IDDBAT.LE.0)                  IDDBAT = 0
*
      RETURN
 1000 FORMAT('CENTRAL:process ',A4,' not found')
 1010 FORMAT('ECAL:process ',A4,' not found')
 1020 FORMAT('HCAL:process ',A4,' not found')
 1030 FORMAT('MUON:process ',A4,' not found')
 1040 FORMAT('FORWARD:process ',A4,' not found')
      END
+DECK,RFMINI.
      SUBROUTINE RFMINI
*.
*...RFMINI Handle *FATMEN  FFREAD cards
*.
*. SEQUENCE: ROBANK RCNTRL RCSYST FMPAR
*. CALLS   : FMINIT FMLOGL ROGTUN
*. CALLED  : RFUSER RIOFAT
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 10-Apr-92
*.
*. Modification Log.
*. 10-Apr-92 O.Schaile Put LFATLW=0 to deactivate FM logging
*. 27-Mar-92 O.Schaile Put LFATLW=54 to activate FM logging
*.                     disabled if < 0 on FFREAD card
*. 28-Mar-92 O.Schaile Comment CALL ROGTUN (dummy anyway)
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER      RC
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,FMPAR.
+SEQ,RCREP.
+SEQ,RCSYST.
*
      IF(FATMEN) THEN
         CHREP  = 'FATMEN has been previously initialised'
         CALL REPORT('RFMINI',1,'E')
                                                                GO TO 10
      END IF
      IF(LFATLO.LT.0) THEN
+SELF,IF=IBM.
*-- The default Fatmen location code on IBM depends on the country
         IF(CHNODE.EQ.'CERNVM') THEN
            FMLOCA =     1
         ELSE IF(CHNODE.EQ.'UKACRL') THEN
            FMLOCA = 44501
         ELSE IF(CHNODE.EQ.'FRSAC12') THEN
            FMLOCA = 33101
         ELSE
            CHREP  = 'Unknown Vm configuration.'
     +          //' Give the default location code'
            CALL REPORT('RFMINI',2,'E')
                                                                GO TO 10
         END IF
+SELF,IF=VAX.
*-- 101 is default location code on vax
         FMLOCA =   101
*--- THE FOLLOWING NEEDS CLEANUP !!!!
+SELF,IF=UNIX.
*-- 31 is default fatmen location code on Shift.
         FMLOCA =   31
+SELF.
      ELSE
         FMLOCA = LFATLO
      END IF
*-- Get logical unit
*      CALL ROGTUN(LFATLU,'Fatmen')
*      IF(LFATLU.EQ.0)                                           GO TO 10
      IF(LFATLU.LE.0)LFATLU=50
*     enable/disable logging of file access (0 = disable)
*      IF(LFATLW.EQ.0)LFATLW=54
*      IF(LFATLW.LT.0)LFATLW=0
      LFATLW=0
*-- Initialize the FATMEN package
      CALL FMINIT(IXSTOR,LFATLU,LFATLW,'//CERN/OPAL',RC)
      IF(RC.NE.0) THEN
         WRITE(CHREP,1000) RC
         CALL REPORT('RFMINI',3,'E')
                                                                GO TO 10
      END IF
      CALL FMLOGL(0)
      FATMEN=.TRUE.
                                                               GO TO 999
*
   10 FFERRO = .TRUE.
  999 RETURN
*
 1000 FORMAT('Error while initialising FATMEN:',I5)
      END
+DECK,RFUSER.
      SUBROUTINE RFUSER(KEY)
*.
*...RFUSER  Interpret the FFREAD card starting with an asterisk.
*.
*. INPUT     : KEY   Keyword after the * in the FFREAD cards.
*. SEQUENCES : RCNTRL ROWORD RCREP
*. CALLS     : UHTOC  RIOFIL RSLEVF RSLREF RIOFAT RIOCAT RSCATA
*.             RGETDV RTRANS RMULFI RCATDA RIODAD SPACES
*. CALLED    : FFGO
*.
*. AUTHOR    : A.Buijs
*. VERSION   : 1.05
*. CREATED   :  5-Apr-1988
*. LAST MOD  : 16-Apr-96
*.
*. Modification Log.
*. 17-JUN-96 M.Schroder Implement *WW
*. 16-Apr-96 M.Schroder correct arguments for RSLBIT call
*. 22-Sep-95 O.Schaile  implement *EVSEL
*.  1-Feb-94 O.Schaile  treat *GET like *EVENT
*. 20-Jul-93 O.Schaile  new FFREAD card *SUDB
*.   911031  K.Riles    Add call to USKEY in RFUSER
*. 24-May-91 D.Lellouch Handle *EVTFILE, *NANOFILE
*. 16-Apr-91 D.Lellouch *DADFILE can contain wild-carding specifications
*. 14-Mar-91 D.Lellouch Implement the new *DADFILE syntax
*.  5-Fev-91 S.Weisz    Temporary comment of Phone and Autounit
*.  8-Jan-91 D.Lellouch Add *AUTOUNIT
*. 18-Nov-90 D.Lellouch Add *FATFILE,     *CATFILE,
*.                          *FATMEN ,     *CATALOG,
*.                          *GETDEVICE,
*.                          *PHONE,       *USPHONE
*.                          *FILE can contain wildcarding
*. 20-Dec-88 S.Weisz    Add *EVENT and *READIN cards.
*. 18-Nov-88 S.Weisz    Add *GET cards.
*.
*.*********************************************************************
+SEQ,DECLARE.
      CHARACTER*4     CKEY, CHWORD, CPNAME
      CHARACTER*80    CFNAME,SPACES
      INTEGER         KEY(*),I, IBITN1
      INTEGER IKEYRC
      INTEGER ROTYBI, IVETO
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROWORD.
+SEQ,RCREP.
*
      FATFIL = .FALSE.
      JFILE  = 0
      IVETO  = 0
      CALL UHTOC(KEY,4,CKEY,4)
      IF(CKEY.EQ.'FILE') THEN
*-- Card wilding?
         CALL UHTOC(LFINAM,NBYTEW,CFNAME,NAMLEN)
+SELF,IF=IBM.
         CFNAME = SPACES(CFNAME,1)
         IF(CFNAME(1:1).EQ.'[') THEN
            I      = INDEX(CFNAME,']')
         ELSE
            I      = 0
         END IF
*-- IBM wild carding based on LFILE module.
*-- Works with '?', not '%'
         CALL RTRANS(CFNAME,'%','?')
+SELF,IF=-IBM.
         I      = 0
+SELF.
         IF(INDEX(CFNAME,'*').GT.I.OR.INDEX(CFNAME,'?').GT.I) THEN
            CALL RMULFI(1)
         ELSE
            CALL RIOFIL
         END IF
         CALL VZERO(LFITYP,NPAFIL)
         CALL VBLANK(LFINAM,NAMLWO)
      ELSE IF(CKEY.EQ.'SUDB') THEN
*        fake a *FILE FFREAD card
         CALL UCTOH('CAL ',LFITYP,4,4)
         CALL UCTOH('IN  ',LFIDIR,4,4)
         LFIUNI=55
         LCFLRE =0
         CALL UCTOH('P   ',LFIFCH,4,4)
         CALL UCTOH('SUDB',LFIDCH,4,4)
         CALL RIOFIL
         CALL VZERO(LFITYP,NPAFIL)
         CALL VBLANK(LFINAM,NAMLWO)
      ELSE IF(CKEY.EQ.'GETD') THEN
         CALL RGETDV
      ELSE IF(CKEY.EQ.'FATM') THEN
         CALL RFMINI
      ELSE IF(CKEY.EQ.'CATF') THEN
         CALL RIOCAT
      ELSE IF(CKEY.EQ.'FATF') THEN
         CALL RIOFAT
      ELSE IF(CKEY.EQ.'DADF'.OR.CKEY(1:3).EQ.'DAD') THEN
*-- It's a GENERIC dad list when name starts with two slashes.
         CALL UHTOC(LDANAM,NBYTEW,CFNAME,NAMLEN)
         CFNAME = SPACES(CFNAME,1)
         IF(CFNAME(1:2).EQ.'//') THEN
            CALL RCATDA
         ELSE IF(INDEX(CFNAME,'*').GT.0.OR.INDEX(CFNAME,'?').GT.0) THEN
            CALL RMULFI(2)
         ELSE
            CALL RIODAD
         END IF
         CALL VZERO(LDATYP,NPADAD)
         CALL VBLANK(LDANAM,NAMLWO)
      ELSE IF(CKEY.EQ.'MAST') THEN
         CALL RIOMAS
      ELSE IF(CKEY.EQ.'NANO') THEN
         CALL UHTOC(LNANAM,NBYTEW,CFNAME,NAMLEN)
         CFNAME = SPACES(CFNAME,1)
         IF(CFNAME(1:2).EQ.'//') THEN
            CALL RCATNA
         ELSE IF(INDEX(CFNAME,'*').GT.0.OR.INDEX(CFNAME,'?').GT.0) THEN
            CALL RMULFI(3)
         ELSE
            CALL RIONAN
         END IF
         CALL VZERO(LNADIR,NPANAN)
         CALL VBLANK(LNANAM,NAMLWO)
      ELSE IF(CKEY.EQ.'EVTF') THEN
         CALL UHTOC(LEVNAM,NBYTEW,CFNAME,NAMLEN)
         CFNAME = SPACES(CFNAME,1)
         IF(CFNAME(1:2).EQ.'//') THEN
            CALL RCATEV
         ELSE IF(INDEX(CFNAME,'*').GT.0.OR.INDEX(CFNAME,'?').GT.0) THEN
            CALL RMULFI(4)
         ELSE
            CALL RIOEVL
         END IF
         CALL VZERO(LEVDIR,NPAEVT)
         CALL VBLANK(LEVNAM,NAMLWO)
      ELSE IF(CKEY.EQ.'CATA') THEN
         CALL RSCATA
      ELSE IF(CKEY.EQ.'EVEN' .OR. CKEY.EQ.'GET ') THEN
         CALL RSLEVF
      ELSE IF(CKEY.EQ.'READ') THEN
         CALL RSLREF
      ELSE IF(CKEY.EQ.'EVSEL') THEN
         CALL UHTOC(ISEKEY(1),NBYTEW,CHWORD,4)
         CALL CLTOU(CHWORD)
         CALL UHTOC(ISEKEY(2),NBYTEW,CPNAME,4)
         CALL CLTOU(CPNAME)
         IF(CHWORD.EQ.'EVTY')THEN
            IF(CPNAME(1:4).NE.'NONE' .AND. CPNAME(1:4).NE.'    ' )THEN
               IBITN1=ROTYBI(CPNAME(1:4))
            ELSE
               IBITN1=0
            ENDIF
            IF(IBITN1.LE.0)THEN
               IF(ISEKEY(3).LE.0 .OR.ISEKEY(3).GT.64)THEN
                  CHREP='No valid BitNr given in EVSEL'
                  CALL REPORT('RFUSER',2,'E')
                  GOTO 999
               ELSE
                  IBITN1=ISEKEY(3)
               ENDIF
            ENDIF
            IF(IBITN1.GT.32)THEN
               CHWORD='EVT2'
               IBITN1=IBITN1-32
            ENDIF
         ELSE
            IBITN1=ISEKEY(3)
         ENDIF
         CALL RSLBIT(CHWORD,IBITN1,IVETO)
**      ELSE IF(CKEY.EQ.'GET ') THEN
**         CALL RSLGEF
CCCCCC Temporary comment
C     ELSE IF(CKEY.EQ.'USPH') THEN
C        CALL USPHON
C     ELSE IF(CKEY.EQ.'AUTO') THEN
C        CALL RAUTOI
+SELF,IF=VAX.
C     ELSE IF(CKEY.EQ.'PHON') THEN
C        CALL RSPHON
CCCCCC End of temporary comment
+SELF.
      ELSE IF ( CKEY.EQ.'WWDE') THEN
          CALL WWKEY(KEY,IKEYRC)
      ELSE
         CALL USKEY(KEY,IKEYRC)
         IF(IKEYRC.NE.0)THEN
           CHREP  = 'Unknown USER card: '//CKEY
           CALL REPORT('RFUSER',1,'E')
           FFERRO = .TRUE.
         ENDIF
      END IF
*
999   RETURN
      END
+DECK,RCPREP.
      SUBROUTINE RCPREP
*.
*...RCPREP   Set OC retrieval flags and call RCASET if experiment
*.           number changes
*.
*. SEQUENCE  : DECLARE CRO   CRVER  OCFLAG RCNTRL RCREP  ROCEXP
*. CALLS     : RCASET REPORT RFGNCT TRCALR
*. CALLED    : RGETDA
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : Mike Redmond (Most of the code from Nigel Watson)
*. VERSION   : 1.01
*. CREATED   : 14-Mar-94
*. LAST MOD  : 22-Apr-97
*.
*. Modification Log.
*. 22-Apr-97   M.Schroder Initialize LASTEX to appease ftnchek
*.  2-Jul-94:  M.Redmond Clear IOCPEX at end (not IOCEXP)
*.  6-May-94 : M.Redmond Allow for experiment number 0
*. 30-Mar-94:  M.Redmond Remove unused variables
*. 27-Mar-94 : M.Redmond Check IFSCAN
*. 26-Mar-94 : M.Redmond Call TRCALR from here
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,CRO.
+SEQ,CRVER.
+SEQ,OCFLAG.
+SEQ,RCNTRL.
+SEQ,RCREP.
+SEQ,ROCEXP.
      INTEGER LASTEX
      LOGICAL FIRST
*
      SAVE    FIRST, LASTEX
      DATA    FIRST /.TRUE./
      DATA    LASTEX /0/
*-- Set IOCCRV flag on first pass.
      IF(FIRST) THEN
        IOCCRV = 1
        IOCPRV = 1
      ELSE IF (IFSCAN.NE.0) THEN
        GOTO 999
      ENDIF
*-- If a constant structure is found on input, set IOCRRV.
      IF(IOCCRV.NE.0) IOCRRV = 1
*-- Check whether or not the expt. no. has changed since last event.
*-- This is OK unless someone tries to read MC data for 2 different
*-- experiment nos. in the same job + has also made the mistake of
*-- attaching a database. In this case, don't do anything.
*     this should not happen but it does!!!
      IF (IRDEXP.EQ.0) THEN
        IF (FIRST) THEN
          IRDEXP = IRDRUN/1000
        ELSE
          IRDEXP=LASTEX
        ENDIF
        WRITE(CHREP,'(''Experiment number is 0! - setting it to '',I3)')
     +    IRDEXP
        CALL REPORT('RCPREP',4,'ERROR')
      ENDIF
      IF (IRDEXP.NE.LASTEX.OR.FIRST) THEN
        IOCEXP=1
        IOCPEX=1
*-- Set flag to allow OCGET to force retrieval of new record ('E' opt.).
*-- This only works for files with expt. nos. 1--9 at the moment, should
*-- be sufficient for the moment...
        IF (IRDEXP.GE.1.AND.IRDEXP.LE.MAXEXP) THEN
          CALL RCASET(CHTNOM(IRDEXP))
          CHREP='Switching top directory name to '//CHTNOM(IRDEXP)//'.'
          CALL REPORT('RCPREP',3,'SUCCESS')
          LASTEX=IRDEXP
*-- If it's real data, expt. no. > 9 we have to stop to re-write code.
        ELSEIF (IRDEXP.LE.999) THEN
          WRITE(CHREP,1001) IRDEXP
          CALL REPORT('RCPREP',2,'FATAL')
*-- In MC data, any database attached will have top dir. name 'MAIN'.
*-- If it's MC data, note the 'last expt. no.' for subsequent events,
        ELSEIF (FIRST) THEN
          LASTEX=IRDEXP
*-- and if expt. no. changes in processing MC data then tell someone...
        ELSE
          WRITE(CHREP,1002) IRDEXP
          CALL REPORT('RCPREP',2,'WARNING')
          LASTEX=IRDEXP
        ENDIF
      ENDIF
      IF (FIRST) FIRST=.FALSE.
*
      IF (IVTR.GT.0) CALL TRCALR
*
      IOCPRV = 0
      IOCPEX = 0
*
  999 RETURN
 1001 FORMAT('Experiment no. out of bounds. Either corrupted data read',
     +       ' or re-write required! IRDEXP = ',I4,'.')
 1002 FORMAT('Experiment no. change detected for MC data and database',
     +       ' is attached! IRDEXP = ',I4,'.')
      END
+DECK,RGETCA.
      SUBROUTINE RGETCA
*.
*...RGETCA  Retrieve calibration constants for all processes
*.
*. COMMON  : QUEST
*. SEQUENCE: ROBANK ROPAR CRO RCNTRL ROCPAR OCFLAG CRVER RCREP ROCEXP
*. CALLS   : CVCALR JCCALR CZCALR TBCALR PBCALR EBCALR PECALR
*.           EECALR HTCALR HSCALR HPCALR MBCALR MECALR FDCALR
*.           TTCALR FICALR SCCALR DXCALR SICALR SWCALR REPORT
*.           RFGNCT OCMOD
*. CALLED  : RGETDA
*.
*. BANK U  : RCO CDC ECC HCC MUC FOC ASC ODC
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 27-Jun-88
*. LAST MOD: 25-Sep-99
*.
*. Modification Log.
*. 25-Sep-99 E.Barberio Estention of check on the Julian format to be
*.                      Y2K compatible.
*. 28-Mar-96  O.Schaile       Introduce TE process.
*. 14-Mar-94 M.Redmond  Move exp. number related code to RCPREP
*.  5-Feb-94 O.Schaile  Allow output of RCO to DST also
*.  7-Oct-93 Kowalewski Call RFGNCT on MC data also
*.  6-Sep-93 M.Redmond  Prevent cal date/time from being overwritten
*.  2-Jun-93 M.Redmond Call all xxCALR when new constants recon input
*.  5-Apr-93 M.Redmond  Call TRCALR if TR library loaded
*.  3-Mar-93  O.Schaile      Introduce SW process.
*. 20-Jul-92 G.Patrick  CHTNOM(IDREXP) in CALL(OCMOD..
*. 17-Feb-92 N.K.Watson If at 1st you don't succeed...
*. 14-Feb-92 N.K.Watson Fix 'W' message for MC data.
*. 07-Feb-92 N.K.Watson Choose database according to expt. no.
*. 21-JAN-92 O.Schaile  IFCNST might be +1 or -1
*.  6-Sep-91 S.Weisz Call XXCALR only if XX library is linked.
*. 17-Jan-91 S.Weisz Introduce DX and SI process.
*. 10-Jan-91 S.Weisz Do not call RFGNCT for MC data.
*. 10-Jan-91 S.Weisz Do not call OCMOD if no database attached.
*. 25-Oct-90 S.Weisz Write constants on DDST stream if asked.
*. 10-Oct-90 S.Weisz Get mag. field and beam position in RFGNCT.
*.  6-Jun-90 S.Weisz Retrieve date and time of last constants update.
*. 24-Mar-90 S.Weisz Add test on existence of UTC structure for GOPAL.
*.  2-Mar-90 S.Weisz Call HTCALR and HSCALR instead of HB/HE.
*. 10-Feb-90 S.Weisz Set IOCCRV flag on first pass.
*. 16-Oct-89 S.Weisz Call slow control routine.
*. 13-Sep-89 S.Weisz Write constants on SCAN stream too.
*.  7-Sep-89 S.Weisz Write constants according to IFCNST.
*.                   Skip calibration retrieval in SCAN mode.
*. 15-Jul-89 S.Weisz Retrieve all calibration in interactive mode.
*. 19-Jun-89 S.Weisz Verify the constant division if selected,
*.                   Call Trigger and Filter routines.
*. 15-Jun-89 S.Weisz Small trick to output constant records.
*. 12-May-89 S.Weisz Copy RCO to Data and Overflow streams.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER NPR,I,IKDAT,NPSCAN,NPCNST,NPASS,IFHRCA,IKCDAT,IKCTIM
      SAVE    NPSCAN,NPCNST,NPASS
      INTEGER LIOHD,LIODO,LIODP,LIODD,LIODG,LIOOV,LIODS
      INTEGER IQUEST
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,OCFLAG.
+SEQ,CRVER.
+SEQ,ROCEXP.
+SEQ,RCREP.
+SEQ,ROBUN.
*
      DATA NPSCAN,NPCNST,NPASS/0,0,0/
*-- Simply return in 'SCAN' mode, except on 1st pass to initialise.
      IF(IFSCAN.NE.0) THEN
         IF(NPSCAN.NE.0)                                       GO TO 999
         NPSCAN = NPSCAN + 1
      END IF
*-- Get mag. field and beam position.
      CALL RFGNCT
*-- Get timing of bunches
      CALL ROFBUN
*-- Call all calibration retrieval in interactive mode.
      IF(IRINTR.NE.0.OR.NPASS.EQ.0.OR.IOCCRV.GT.0) THEN
         NPASS = NPASS + 1
         IF(IVTT.GT.0) CALL TTCALR
         IF(IVFI.GT.0) CALL FICALR
         IF(ISCBAT.GT.0) CALL SCCALR
         IF(IVCV.GT.0) CALL CVCALR
         IF(IVJC.GT.0) CALL JCCALR
         IF(IVCZ.GT.0) CALL CZCALR
         IF(IVDX.GT.0) CALL DXCALR
         IF(IVSI.GT.0) CALL SICALR
         IF(IVTB.GT.0) CALL TBCALR
         IF(IVTE.GT.0) CALL TECALR
         IF(IVPB.GT.0) CALL PBCALR
         IF(IVEB.GT.0) CALL EBCALR
         IF(IVPE.GT.0) CALL PECALR
         IF(IVEE.GT.0) CALL EECALR
         IF(IVHB.GT.0.OR.IVHE.GT.0) CALL HTCALR
         IF(IVHB.GT.0.OR.IVHE.GT.0) CALL HSCALR
         IF(IVHP.GT.0) CALL HPCALR
         IF(IVMB.GT.0) CALL MBCALR
         IF(IVME.GT.0) CALL MECALR
         IF(IVFD.GT.0) CALL FDCALR
         IF(IVSW.GT.0) CALL SWCALR
                                                                GO TO 60
      END IF
*-- Trigger and Filter constant retrieval.
      IF(ITTBAT.GE.1) CALL TTCALR
      IF(IFIBAT.GE.1) CALL FICALR
      IF(ISCBAT.GE.1) CALL SCCALR
*
      NPR=IQ(LRCO+IIFCDC)
      IF(NPR.GE.1) THEN
*-- Calibration for CD processes selected by CENTRAL card.
         DO 10 I=1,NPR
            IF(IABS(IQ(LCDC+IIFCVC)).EQ.I) CALL CVCALR
            IF(IABS(IQ(LCDC+IIFCJC)).EQ.I) CALL JCCALR
            IF(IABS(IQ(LCDC+IIFCZC)).EQ.I) CALL CZCALR
            IF(IABS(IQ(LCDC+IIFDXC)).EQ.I) CALL DXCALR
            IF(IABS(IQ(LCDC+IIFSIC)).EQ.I) CALL SICALR
   10    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFECC)
      IF(NPR.GE.1) THEN
*-- Calibration for EC processes selected by ECAL card.
         DO 20 I=1,NPR
            IF(IABS(IQ(LECC+IIFTBC)).EQ.I) CALL TBCALR
            IF(IABS(IQ(LECC+IIFTEC)).EQ.I) CALL TECALR
            IF(IABS(IQ(LECC+IIFPBC)).EQ.I) CALL PBCALR
            IF(IABS(IQ(LECC+IIFEBC)).EQ.I) CALL EBCALR
            IF(IABS(IQ(LECC+IIFPEC)).EQ.I) CALL PECALR
            IF(IABS(IQ(LECC+IIFEEC)).EQ.I) CALL EECALR
   20    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFHCC)
      IF(NPR.GE.1) THEN
*-- Calibration for HC processes selected by HCAL card.
*-- IFHRCA is a flag for retrieval of HT/HS calibration.
         IFHRCA = 0
         DO 30 I=1,NPR
            IF(IABS(IQ(LHCC+IIFHBC)).EQ.I.AND.IFHRCA.EQ.0) THEN
               CALL HTCALR
               CALL HSCALR
               IFHRCA = 1
            END IF
            IF(IABS(IQ(LHCC+IIFHEC)).EQ.I.AND.IFHRCA.EQ.0) THEN
               CALL HTCALR
               CALL HSCALR
               IFHRCA = 1
            END IF
            IF(IABS(IQ(LHCC+IIFHPC)).EQ.I) CALL HPCALR
   30    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFMUC)
      IF(NPR.GE.1) THEN
*-- Calibration for MU processes selected by MUON card.
         DO 40 I=1,NPR
            IF(IABS(IQ(LMUC+IIFMBC)).EQ.I) CALL MBCALR
            IF(IABS(IQ(LMUC+IIFMEC)).EQ.I) CALL MECALR
   40    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFFOC)
      IF(NPR.GE.1) THEN
*-- Calibration for FO processes selected by FORWARD card.
         DO 50 I=1,NPR
            IF(IABS(IQ(LFOC+IIFFDC)).EQ.I) CALL FDCALR
            IF(IABS(IQ(LFOC+IIFSWC)).EQ.I) CALL SWCALR
   50    CONTINUE
      END IF
   60 CONTINUE
*- NKW mods start.
*-- Reset the 'changed experiment no.' flag, always.
      IOCEXP=0
*- NKW mods end.
*-- Check the constant division if selected with ZVERIFY.
      IF(IZVERI.EQ.1) THEN
         CALL DZVERI('    ',IROCON,'CLSU')
         IF(IQUEST(1).NE.0) THEN
            WRITE(CHREP,1000)
            CALL REPORT('RGETCA',1,'F')
         END IF
      END IF
*-- Check if we have a new RCO structure.
      IF(IOCRRV.NE.0.OR.IOCCRV.NE.0) THEN
*-- Get date and time of latest update of constants.
         IF(ICMAIN.EQ.1) THEN
            CALL OCMOD(CHTNOM(IRDEXP),ICDATE,ICTIME)
            ICTIME = 100*ICTIME
         ELSE
            ICDATE = IUHEAD(IICDAT)
            ICTIME = IUHEAD(IICTIM)
         END IF
*-- Write this RCO constant structure on Data ,Production and
*-- Overflow output streams according to IFCNST.
         IF(IFCNST.EQ.0)                                       GO TO 999
         IF(IABS(IFCNST).EQ.1) THEN
            IF(NPCNST.NE.0)                                    GO TO 999
            NPCNST = NPCNST + 1
         END IF
         LUTC  = LQ(LRCO-LLUTC)
         IF(LUTC.LE.0)                                         GO TO 999
         LIOHD = LQ(LUTC-LLIOHD)
         IF(LIOHD.LE.0)                                        GO TO 999
*-- Set Record type to 105.
         IKDAT = IUHEAD(IIDAT)
         IKCDAT = IUHEAD(IICDAT)
         IKCTIM = IUHEAD(IICTIM)
         IUHEAD(IIDAT)   = 105
         IUHEAD(IICDAT)  = ICDATE
         IUHEAD(IICTIM)  = ICTIME
         LIODO = LQ(LIOHD-LLIODO)
         CALL ROWDAO(LIODO,IROCON,LRCO,1,'.',IOHEAD,NUHEAD,IUHEAD)
         LIOHD = LQ(LUTC-LLIOHD)
         LIODP = LQ(LIOHD-LLIODP)
         CALL ROWDAO(LIODP,IROCON,LRCO,1,'.',IOHEAD,NUHEAD,IUHEAD)
         LIOHD = LQ(LUTC-LLIOHD)
         LIODD = LQ(LIOHD-LLIODD)
         CALL ROWDAO(LIODD,IROCON,LRCO,1,'.',IOHEAD,NUHEAD,IUHEAD)
         LIOHD = LQ(LUTC-LLIOHD)
         LIODG = LQ(LIOHD-LLIODG)
         CALL ROWDAO(LIODG,IROCON,LRCO,1,'.',IOHEAD,NUHEAD,IUHEAD)
         LIOHD = LQ(LUTC-LLIOHD)
         LIOOV = LQ(LIOHD-LLIOOV)
         CALL ROWDAO(LIOOV,IROCON,LRCO,1,'.',IOHEAD,NUHEAD,IUHEAD)
*-- Write it to DST if requested.
         IF(IFCNST.GE.1)THEN
            LIOHD = LQ(LUTC-LLIOHD)
            LIODS = LQ(LIOHD-LLIODS)
            CALL ROWDAO(LIODS,IROCON,LRCO,1,'.',IOHEAD,NUHEAD,IUHEAD)
         ENDIF
*-- Reset Record type as it was ......
         IUHEAD(IIDAT)  = IKDAT
         IUHEAD(IICDAT) = IKCDAT
         IUHEAD(IICTIM) = IKCTIM
      END IF
*
  999 RETURN
 1000 FORMAT('ZEBRA messed-up after calibration retrieval')
      END
+DECK,RGETCN.
      SUBROUTINE RGETCN(LUN,IER)
*.
*...RGETCN   Do something with the pending record, type 105
*.
*. INPUT     : LUN   Logical input unit, of course.
*. OUTPUT    : IER   Return code, 0 if OK.
*.
*. SEQUENCE  : ROBANK CRO RCNTRL RCREP ROPAR ROCPAR OCFLAG
*. COMMON    : QUEST
*. CALLS     : FZIN MZDROP REPORT ROWDAO ZSHUNT MZPUSH
*. CALLED    : RGETDA
*.
*. BANK U    : IOHD IODO IODC IOOV
*. BANK M    : DAC
*.
*. AUTHOR    : A.Buijs,S.Weisz
*. VERSION   : 1.02
*. CREATED   :  7-Apr-1988
*. LAST MOD  : 26-Mar-1994
*.
*. Modification Log.
*. 26-Mar-94 M.Redmond Set IOCPRV flag too
*. 18-Nov-91  S.Weisz    Follows "CONSTANT" specs. for COPY output
*. 18-Jan-91 S.Weisz Check DAC length, SI link might be missing.
*.  6-Jun-90 S.Weisz Retrieve and store date and time of constants upd.
*. 17-Sep-89 S.Weisz Return in 'SCAN' mode.
*.  7-Sep-89 S.Weisz Read new constant in event division.
*. 12-May-89 S.Weisz Update constant structure, set flag IOCCRV.
*. 15-Feb-89 S.Weisz Do not use new DAC for a while.
*. 12-Jan-89 S.Weisz Copy on overflow units too.
*. 24-May-88 S.Weisz Read and decode RCO structure written by GOPAL115.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LUN,IER,IQUEST,LDACP,INCNL,INCND
      INTEGER LIOHD,LIODC
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,RCREP.
+SEQ,OCFLAG.
*
      INTEGER NPCNST
      SAVE    NPCNST
      DATA    NPCNST/0/
      IER = 0
*-- Simply return in 'SCAN' mode.
      IF(IFSCAN.NE.0)                                          GO TO 999
*
      IF(LHEAD.NE.0) CALL MZDROP(IXSTOR,LHEAD,'.')
      NUHEAD = NUHMAX
      CALL FZIN(LUN,IRODIV,LHEAD,1,'A',NUHEAD,IUHEAD)
      IF(IQUEST(1).NE.0.OR.LHEAD.EQ.0)                          GO TO 10
      CHREP = 'Calibration constants read on data stream.'
      CALL REPORT('RGETCN',1,'I')
*-- extract the used bunchtime from OD/GNRL (if existing...)
      CALL ROBUTI
*-- If a COPY unit exists, write the record to it.
      IF(IFCNST.GE.1.AND.NPCNST.EQ.0) THEN
         IF(IFCNST.EQ.1) NPCNST = NPCNST + 1
         LIOHD = LQ(LUTC-LLIOHD)
         LIODC = LQ(LIOHD-LLIODC)
         CALL ROWDAO(LIODC,IRODIV,LHEAD,1,'.',IOHEAD,NUHEAD,IUHEAD)
      END IF
      LDACP = LQ(LHEAD-LLDAC)
      IF(LDACP.LE.0)                                            GO TO 10
*-- Move the calibration constants from the header bank into the
*-- proper place in the ROPE 'RCO ' structure.
      IF(LDAC.NE.0) CALL MZDROP(IXSTOR,LDAC,'.')
      CALL MZGARB(IROCON,0)
      CALL MZCOPY(IRODIV,LDACP,IROCON,LRCO,-LLDAC,'.')
      LDAC = LQ(LRCO-LLDAC)
*-- Check if DAC has the proper number of link/data words.
      INCNL = 0
      INCND = 0
      IF(IQNS(LDAC).LT.NSDAC) INCNL = NSDAC - IQNS(LDAC)
      IF(IQND(LDAC).LT.NDDAC) INCND = NDDAC - IQND(LDAC)
      IF(INCNL.GE.1.OR.INCND.GE.1) THEN
         CALL MZPUSH(IROCON,LDAC,INCNL,INCND,'.')
         CHREP = 'DAC structure must be expanded'
         CALL REPORT('RGETCN',2,'W')
      END IF
*-- Set IOCCRV flag to write new constant structure.
      IOCCRV = 1
*-- Set IOCPRV flag as well to tell TRCALR about new constants
      IOCPRV = 1
*-- Update date and time of latest constants mod.
      ICDATE = IUHEAD(IICDAT)
      ICTIME = IUHEAD(IICTIM)
*
      CALL MZDROP(IXSTOR,LHEAD,'.')
                                                               GO TO 999
   10 CONTINUE
      IER = 10
      IF(IQUEST(1).NE.0) IER = IQUEST(1)
      CHREP = 'Problem reading constant structure on data stream.'
      CALL REPORT('RGETCN',3,'W')
*
  999 RETURN
      END
+DECK,RGETCO.
      SUBROUTINE RGETCO(LUN,IER)
*.
*...RGETCO   Routine to read in constant data structures
*.
*. INPUT   :  LUN      Logical unit number
*. OUTPUT  :  IER      Error flag
*.
*. SEQUENCE: ROBANK ROPAR ROCPAR CRO RCNTRL RCREP OCFLAG
*. COMMON  : QUEST
*. CALLS   : MZDROP FZIN ROWDAO RGETST
*. CALLED  : RIOSET
*.
*. BANK U    : IOHD IODO IODC IOOV
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED :  9-Jan-1989
*. LAST MOD: 26-Mar-1994
*.
*. Modification log:
*. 26-Mar-94 M.Redmond Set IOCPRV flag too
*. 26-Fev-91 S.Weisz Check constant structure.
*.  6-Jun-90 S.Weisz Retrieve and store date and time of constants upd.
*. 10-Feb-90 S.Weisz Some clean up.
*. 26-Jun-89 S.Weisz Temporary bodge to handle old header type.
*. 15-Jun-89 S.Weisz Start of Run record in range 1000-1006
*. 25-May-89 S.Weisz Switch to new event header
*. 12-May-89 S.Weisz Set IOCCRV flag to write RCO on output streams
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER LUN,IER,IQUEST,I,IDENT
      INTEGER LIOHD,LIODC
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
+SEQ,OCFLAG.
*
      IER = 0
*-- Read in first the pilot record.
   10 NUHEAD = NUHMAX
      CALL FZIN(LUN,IRODIV,0,0,'S',NUHEAD,IUHEAD)
      IF(IQUEST(1).NE.0) THEN
*-- Check if we have a 'Start-of-Run' record.
         IF(IQUEST(1).EQ.1)                                     GO TO 10
*-- We have problems on input.
         CHREP = 'Cannot read first record on Constants input!'
         CALL REPORT('RGETCO',1,'E')
         IER = 1
                                                               GO TO 999
      END IF
      IF(NUHEAD.LT.IIDAT) THEN
*-- Input record useless.
         CHREP = 'First read pilot record is useless!'
         CALL REPORT('RGETCO',3,'E')
         DO 20 I=1,NUHEAD
            WRITE(CHREP,1000) I,IUHEAD(I)
   20    CALL REPORT('RGETCO',0,'I')
         IER = 2
                                                               GO TO 999
      END IF
      IDENT = IUHEAD(IIDAT)
*-- This can still be a 'Start-of-Run' record !
      IF(IDENT.GE.1000.AND.IDENT.LE.1006) THEN
         CHREP = 'Start-of-Run record found on input'
         CALL REPORT('RGETCO',4,'I')
         CALL RGETST(LUN,IER)
                                                                GO TO 10
*-- Check if we have a constant record.
      ELSE IF(IDENT.NE.105) THEN
*-- Unexpected record, write its header.
         CHREP = 'Unexpected record on Constant stream!'
         CALL REPORT('RGETCO',5,'E')
         DO 30 I=1,NUHEAD
            WRITE(CHREP,1000) I,IUHEAD(I)
   30    CALL REPORT('RGETCO',0,'I')
         IER = 3
      ELSE
*-- Read 'RCO ' structure.
         CALL FZIN(LUN,IROCON,LRCO,1,'A',NUHEAD,IUHEAD)
         IF(IQUEST(1).NE.0.OR.LRCO.EQ.0) THEN
*-- Problem getting RCO.
            CHREP = 'Problem getting RCO from input!'
            CALL REPORT('RGETCO',6,'E')
            IER = 4
                                                               GO TO 999
         END IF
*-- Got constants all right.
         CHREP = 'Constant structure RCO read.'
         CALL REPORT('RGETCO',7,'I')
*-- Check the constant division if selected with ZVERIFY.
         IF(IZVERI.EQ.1) THEN
            CALL DZVERI('    ',IROCON,'CLSU')
            IF(IQUEST(1).NE.0) THEN
               WRITE(CHREP,1010)
               CALL REPORT('RGETCO',7,'F')
            END IF
         END IF
*-- If a COPY unit exists, write RCO to it.
         LIOHD = LQ(LUTC-LLIOHD)
         LIODC = LQ(LIOHD-LLIODC)
         CALL ROWDAO(LIODC,IROCON,LRCO,1,'.',IOHEAD,NUHEAD,IUHEAD)
*-- Set flag to write constant structure on Data output streams.
         IOCCRV = 1
         IOCPRV = 1
         ICDATE = IUHEAD(IICDAT)
         ICTIME = IUHEAD(IICTIM)
      END IF
*
  999 RETURN
 1000 FORMAT('First record header: word',I3,' = ',I6)
 1010 FORMAT('ZEBRA messed-up after calibration retrieval')
      END
+DECK,RGETDA.
      SUBROUTINE RGETDA(LUNIT,IER)
*.
*...RGETDA   Routine to read in 'REV' data structures.
*.
*. INPUT     : LUNIT    Logical unit number
*. OUTPUT    : IER      Error flag = IQUEST(1) from FZIN
*.
*. SEQUENCE  : GCFLAG ROBANK RCNTRL CRO ROPAR ROCPAR RCREP ROUNIT CRVER
*. COMMON    : QUEST
*. CALLS     : MZDROP GETHDR FZIN REPORT RGETCN RSELDA USHEAD RGETCA
*.             ROWDAO RGETST RGETED RODATE RGETEB SUSKIP RNXTEV RFGNCT
*.             LOCKI ULOCKI SUPHYS
*. CALLED    : ROTRIG
*.
*. BANK U    : IOHD IODC
*. BANK D    : REV
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.03
*. CREATED   : 13-Nov-87
*. LAST MOD :  10-July-97
*.
*. Modification Log.
*. 10-Jul-97 E.Barberio update the beam energy by default
*.  5-Nov-95 G.Duckeck  Interactive event access (LEVTIA)
*.  5-Nov-95 O.Schaile  if Interactive exit early for chunk events
*. 26-Sep-94 O.Schaile  Check IRSTOP right after RNXTEV
*. 11-Apr-94 M.Redmond  Call RGETCA for new constants or expt. number
*. 26-Mar-94 M.Redmond  Move TRCALR inside RCPREP
*. 14-Mar-94 M.Redmond  Call RCPREP and TRCALR before USHEAD
*. 18-Feb-94 O.Schaile  new counter NFADAD
*.  2-Feb-94 D.Lellouch calls to DCREAD are simplified
*.  1-Feb-94 O.Schaile  Correct Calling of RNXTNA
*. 28-Jan-94 O.Schaile  Implement skipping of unreadable files
*.  7-Oct-93 Kowalewski Call RFGNCT on MC data also
*. 24-Aug-93 O.Schaile   write out headers also if empty d/s
*. 19-Aug-93 O.Schaile   Call USHEAD for all events
*.  7-May-93 O.Schaile   fix bug (if ONLINE)
*.  6-May-93 O.Schaile   Preset RTIMLF (if ONLINE)
*. 19-Apr-93 O.Schaile   Avoid TIMEL if ONLINE
*.  5-Apr-93 M.Redmond  Call RGETCA if TR library loaded
*. 19-Jun-92 D.Lellouch  In case of data compression, calls DCREAD
*. 25-Feb-92 O.Schaile  use TIMAL on IBM (gives 168 units)
*. 10-Feb-92 C.Hawkes   REPORT(,,6,'W')=> 6,'I') beam energy change
*. 21-JAN-92 O.Schaile  Write constants record always if user requested
*.                      also for DST and DDST and no unpacking was done
*. 28-Nov-1991 O.Schaile Call SUPHYS to reject junk events
*. 18-Nov-91   S.Weisz Check time limit before reading header
*. 12-Sep-1991 S.Weisz Implement Event list,NanoDst,DAD list access.
*. 13-Apr-1991 S.Weisz LOCKI, ULOCKI here, further tests for header.
*. 27-Mar-1991 S.Weisz Get beam position for DST too.
*. 14-Mar-1991 D.Lellouch   Handle dadlist.
*. 18-Fev-1991 S.Weisz Modification to read from memory.
*. 10-Jan-1991 S.Weisz Keep bunch number from DAQ.
*. 24-Oct-1990 S.Weisz Monitor OPCAL too.
*. 22-Oct-1990 S.Weisz Reset bunch number, handle tape info.
*. 11-Oct-1990 A.Lee   Position input according to DADlist pointer.
*. 11-Oct-1990 S.Weisz Add call to SUSKIP.
*.  7-Jun-1990 S.Weisz Call Status Update routine.
*.  5-Apr-1990 S.Weisz Call RGETCA for DST with Dense Data unpacked.
*. 22-Mar-1990 S.Weisz Extend data part of REV if necessary.
*. 28-Feb-1990 S.Weisz Skip junk events (IIDAT=7-13).
*.                     Use Beam energy and Fill No. from RGETEB.
*. 10-Feb-1990 S.Weisz Check IFUPDT and some cleanup.
*. 29-Jul-1989 S.Weisz Call RODATE instead of CALDAT.
*. 22-Jul-1989 S.Weisz Skip calibration retrieval for DST event.
*. 19-Jul-1989 S.Weisz Transform date and time if necessary.
*. 26-Jun-1989 S.Weisz Temporary bodge to handle old header type.
*. 26-Jun-1989 S.Weisz Print unknown type header (IDENT=0) only once.
*. 15-Jun-1989 S.Weisz Do something for OPAL Start and End-of-Run.
*. 12-Jun-1989 S.Weisz Set LDA in RBKREV.
*. 25-May-1989 S.Weisz Switch to new event header.
*. 23-Jan-1989 S.Weisz Call RGETCA before reading event.
*. 10-Jan-1989 S.Weisz Check nature of new records.
*.  8-Oct-1988 S.Weisz Get RUN/EVT number from user's words.
*. 24-May-1988 S.Weisz Do not read a new Pilot record on 1st pass.
*. 18-May-1988 S.Weisz Call RSELDA to select event folowing FFREAD opt.
*. 11-Feb-1988 A.Buijs Slight alterations.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER       LUNIT,LUN,IDENT,IER,IOSEL,I,IPASS
      INTEGER       NDUM,HDUM
      INTEGER       NTRY,IOLDF,ISKIPF,IRNXTE,IENXTE,IFNXTE
      SAVE          IPASS,NTRY,IOLDF,ISKIPF
      INTEGER       LIOHD,LIODC
      INTEGER       LRDTMP
      COMMON /ROTMP2/ LRDTMP(2), LIOHD
      INTEGER       IJULD,NNDATE,IEBEAM,LEPFIL
      INTEGER       NHH,NMM,NSS,IHH,IMM,ISS,IOS9T
      REAL          EBEAM,SYSEB
      PARAMETER    (NHH = 360000,NMM = 6000,NSS = 100)
*
      INTEGER      IQUEST
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,CRO.
+SEQ,OCFLAG.
+SEQ,CRVER.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
      LOGICAL PACKED
+SEQ,RBITFUNC.
+SEQ,RCREP.
+SEQ,RCLINE.
*
C GD >
+SEQ,ROEVIA.
C GD <
      DIMENSION HDUM(NUHMAX)
      INTEGER NPASS,MPASS
      PARAMETER (MPASS=100)
      SAVE    NPASS
      REAL    RTIMLF
      LOGICAL ONLINE
      DATA    NPASS/0/
      DATA    IPASS/0/
      DATA    NTRY,IOLDF/0,0/
+SELF,IF=ONLINE.
      DATA    RTIMLF/999999./
+SELF.
*
      ISKIPF=0
      LUN    = LUNIT
      IDENT = 0
      IER   = 0
      IOSEL = 1
*-- Go for next start of event data structure and read the header.
   10 IF(LREV.NE.0) CALL MZDROP(IXSTOR,LREV,'.')
      NPASS  = NPASS + 1
      IF(NPASS.GE.MPASS) THEN
         NPASS  = 0
*-- Check the TIME left.
+SELF,IF=IBM,IF=-ONLINE.
         CALL TIMAL(RTIMLF)
+SELF,IF=-IBM,IF=-ONLINE.
         CALL TIMEL(RTIMLF)
+SELF,IF=-ONLINE.
         IF(RTIMLF.LT.RTIMSF) THEN
            IRSTOP = 2
            WRITE(CHREP,3000) RTIMLF
            CALL REPORT('RGETDA',11,'I')
            NSTOP  = 2
                                                               GO TO 999
         END IF
+SELF.
      END IF
+SELF,IF=UNIX,VAX.
      IF(LEVTIA) THEN
*-- Is it interactive event request?
         CALL RNEVTL(-99,IER)
         IF(IER.NE.0)THEN
            LEVTIA=.FALSE.
            GO TO 999
         ENDIF
         LUN    = LUNAIN
      ELSE IF(LEVTL) THEN
*-- Is it event list acess? to be tested BEFORE nanodst and DADlist
         LUN    = LUNAIN
         CALL RNEVTL(LUNIT,IER)
         IF(IER.NE.0)                                          GO TO 999
+SELF,IF=UNIX.
      ELSE IF(LNANO) THEN
*-- Is it a Nano dst?
         LUN    = LUNAIN
         CALL RNXTNA(LUNIT,0,0,IER)
         IF(IER.NE.0)                                          GO TO 999
+SELF,IF=UNIX,VAX.
      ELSE IF(LDADL) THEN
*-- Read zebra from another logical unit if DADLIST access.
         LUN    = LUDAIN
         CALL RNXTEV(LUNIT,ISKIPF,IRNXTE,IENXTE,IFNXTE,IER)
      IF(IRSTOP.EQ.2)                                           GOTO 999
         ISKIPF=0
         IF(IOLDF.NE.IFNXTE)THEN
            IOLDF=IFNXTE
            NTRY=0
         ENDIF
         IF(IER.NE.0)                                          GO TO 999
      END IF
+SELF.
      NUHEAD = NUHMAX
*-- Check if we read from memory (On-line case).
      IF(LMEMIN) THEN
         IRDRUN =   0
         IRDEVT = -50
         CALL LOCKI
         CALL GETHDR(NUHEAD,IUHEAD)
      ELSE
         CALL FZIN(LUN,IRODIV,0,0,'S',NUHEAD,IUHEAD)
      END IF
      IF(IQUEST(1).NE.0)THEN
         IF(LDADL)THEN
            NFADAD=NFADAD+1
            WRITE(CHREP,'(A,I9)')
     +      'Error from FZIN reading header, IQUEST(1)',IQUEST(1)
            CALL REPORT('RGETDA',12,'E')
            WRITE(CHLINE,'(A,4I8,A)')'*EVENT ',
     +      IRNXTE,IENXTE,IRNXTE,IENXTE,'  s_k_i_p_p_e_d in RGETDA'
            CALL RMAIL(0,0)
            NTRY=NTRY+1
            IF(NTRY.GT.NTRYMX(1))ISKIPF=IFNXTE
            GOTO 10
         ELSE
                                                                GO TO 50
         ENDIF
      ENDIF
      IUHEAD(IIEVLG)=IQUEST(14)
*     wait after USHEAD
*      IF(IQUEST(13).LE.0.OR.IQUEST(14).LE.0) THEN
*         IQUEST(1) = -1
*                                                               GO TO 50
*      END IF
*.    Do we have to unpack?
      PACKED=ISHFT(IUHEAD(1),-24).NE.0
      IF(PACKED) CALL DCREAD(0)
*-- See if we know this record type, the identifier is in word IHDTYP
*-- of the HEADER.
      IF(NUHEAD.GE.IIDAT) IDENT = IUHEAD(IIDAT)
      IF(IRINTR.EQ.1 .AND. IDENT.GE.7.AND.IDENT.LE.13) GOTO 10
      IF(IDENT.EQ.0) THEN
*-- Unexpected record, write its header.
         CHREP = 'Unexpected record on Data stream!'
         CALL REPORT('RGETDA',1,'E')
         IF(IPASS.GE.1)                                         GO TO 40
         IPASS = 1
         DO 20 I=1,NUHEAD
            WRITE(CHREP,1000) I,IUHEAD(I)
   20    CALL REPORT('RGETDA',0,'I')
*-- The pending data are read in any case if the data type IUHEAD(IIDAT)
*-- doesn't exist and if the user wants it (in USHEAD).
                                                                GO TO 40
      END IF
*-- Check if we have a Constants record. If so, go do something with it.
      IF(IDENT.EQ.105) THEN
         IF(LMEMIN) THEN
            CHREP = 'Constants record found on memory, not allowed'
            CALL REPORT('RGETDA',2,'E')
            IQUEST(1) = -5
                                                                GO TO 50
         ELSE
            CHREP = 'Constants record found on input'
            CALL REPORT('RGETDA',3,'I')
            CALL RGETCN(LUN,IER)
                                                                GO TO 10
         END IF
      END IF
*-- Check if we have a Start-of-Run record.
      IF(IDENT.GE.1000.AND.IDENT.LE.1006) THEN
         IF(LMEMIN) THEN
            CHREP = 'Start-of-run record found on memory, not allowed'
            CALL REPORT('RGETDA',4,'E')
            IQUEST(1) = -5
                                                                GO TO 50
         ELSE
            CHREP = 'Start-of-Run record found on input'
            CALL REPORT('RGETDA',5,'I')
            CALL RGETST(LUN,IER)
                                                                GO TO 10
         END IF
      END IF
*-- Check if we have a End-of-Run record.
      IF(IDENT.GE.2000.AND.IDENT.LE.2006) THEN
         IF(LMEMIN) THEN
            CHREP = 'End-of-run record found on memory, not allowed'
            CALL REPORT('RGETDA',6,'E')
            IQUEST(1) = -5
                                                                GO TO 50
         ELSE
            CHREP = 'End-of-Run record found on input'
            CALL REPORT('RGETDA',7,'I')
            CALL RGETED(LUN,IER)
                                                                GO TO 10
         END IF
      END IF
*-- Get relevant information in CRO,RCNTRL.
   40 CONTINUE
      IRDEXP = IUHEAD(IIEXPT)
      IRDRUN = IUHEAD(IIRUN)
      IRDEVT = IUHEAD(IIEVT)
*-- update Beam energy and fill No.
       IF(IFNOEU.EQ.0) THEN
          CALL RGETEB(EBEAM,SYSEB,LEPFIL)
          IEBEAM = INT(EBEAM*1000. + 0.5)
          IUHEAD(IIEBEA) = IEBEAM
          IUHEAD(IIFILL) = LEPFIL
       END IF
*     with DADlists IREVNT gets incremented in RNXTEV
      IF(LEVTL.OR..NOT.LDADL)IREVNT = IREVNT+1
      IJULD  = IUHEAD(IIDATE)
      IOS9T  = IUHEAD(IITIME)
      IF(IFUPDT.EQ.1) THEN
*-- Check if we have to decode the Julian date.
         IF((IJULD.GE.1000000.AND.IJULD.LT.20000000)
     +       .OR.IOS9T.GE.1000000) THEN
            CALL RODATE(IJULD,NNDATE,IER)
            IF(IER.NE.0) THEN
               CHREP = 'We have a problem with RODATE'
               CALL REPORT('RGETDA',5,'W')
               IER = 0
            END IF
            IUHEAD(IIDATE) = NNDATE
            IHH = INT(IOS9T/NHH)
            IMM = INT((IOS9T-IHH*NHH)/NMM)
            ISS = INT((IOS9T-IHH*NHH-IMM*NMM)/NSS)
            IUHEAD(IITIME) = 10000*IHH + 100*IMM + ISS
         END IF
*-- Check/update Beam energy and fill No.
C        CALL RGETEB(EBEAM,SYSEB,LEPFIL)
C        IEBEAM = INT(EBEAM*1000. + 0.5)
C        IF(IEBEAM.NE.IUHEAD(IIEBEA).OR.
C    +      LEPFIL.NE.IUHEAD(IIFILL)) THEN
C           WRITE(CHREP,2000) LEPFIL,IEBEAM,
C    +                        IUHEAD(IIFILL),IUHEAD(IIEBEA)
C           CALL REPORT('RGETDA',6,'I')
C           IUHEAD(IIEBEA) = IEBEAM
C           IUHEAD(IIFILL) = LEPFIL
C        END IF
*-- Update the detector and trigger status words.
         CALL SUALL
         IUHEAD(IISULM) = IDAMSU
      END IF
*-- Do not process junk events.
      IF(IDENT.GE.7.AND.IDENT.LE.13) THEN
         CHREP = 'Junk event on input, skip it'
         CALL REPORT('RGETDA',7,'W')
         IF(LMEMIN) CALL ULOCKI(IRDEVT,IRDRUN)
                                                                GO TO 10
      END IF
*-- Select the event (read pending data) according to FFREAD cards.
      CALL RSELDA(IOSEL)
      IF(IRSTOP.NE.0)                                          GO TO 999
      IF(IOSEL.NE.1) THEN
         IF(LMEMIN) CALL ULOCKI(IRDEVT,IRDRUN)
                                                                GO TO 10
      END IF
*-- Some events need to be skipped because of screw-up!
      CALL SUSKIP(IOSEL)
      IF(IOSEL.NE.1) THEN
         IF(LMEMIN) CALL ULOCKI(IRDEVT,IRDRUN)
                                                                GO TO 10
      END IF
*--  Skip because runs not useful for physics (tests, etc)
      IF(KEEPJU.EQ.0)THEN
         CALL SUPHYS(IOSEL)
         IF(IOSEL.NE.1) THEN
            CALL ROUPON(ONLINE)
            IF(.NOT.ONLINE)THEN
               IF(LMEMIN) CALL ULOCKI(IRDEVT,IRDRUN)
               CHREP='Event skipped by SUPHYS'
               CALL REPORT('RGETDA',10,'W')
                                                                GO TO 10
            END IF
         END IF
      END IF
*-- Set OC flags and update database names if necessary and call TRCALR
      CALL RCPREP
*-- Call LMHEAD for the luminosity analysis
      IF(IVLM.GT.0) CALL LMHEAD
*-- Let the USER decide whether to read pending data structure.
      CALL USHEAD(IOSEL)
*-- If empty d/s look if it should be output, then skip the rest
      IF(IUHEAD(IIEVLG).LE.0) THEN
*-- If we're running interactively, fetch the first non-empty event
         IF (IRINTR.EQ.1 .AND. IRUFST.LE.0) THEN
            CHREP = 'Only header is available. Skipping to next event'
            CALL REPORT('RGETDA',1,'I')
            IRTRIG(2) = IREVNT + 1
         ENDIF
         IF(IOSEL.EQ.1)THEN
*-- Check output streams.
            CALL MZLINT(IXSTOR,'/ROTMP2/',LRDTMP,LIOHD,LRDTMP)
            LIOHD = LQ(LUTC-LLIOHD)
            DO 5 I=1,IQ(LIOHD-3)
               IF( I.EQ.LLIODO .OR. I.EQ.LLIODC .OR.I.EQ.LLIOOV
     +         .OR.I.EQ.LLIODS .OR. I.EQ.LLIODD .OR.I.EQ.LLIODP)THEN
                  IF(LQ(LIOHD-I).NE.0)THEN
                     CALL ROWDAO(LQ(LIOHD-I),IRODIV,0,1,'Z',
     +               IOHEAD,NUHEAD,IUHEAD)
                  END IF
               END IF
 5          CONTINUE
            LRDTMP(1) = 0
         END IF
         IQUEST(1) = -1
                                                                GO TO 50
      END IF
      IF(IOSEL.NE.1) THEN
         IF(LMEMIN) CALL ULOCKI(IRDEVT,IRDRUN)
                                                                GO TO 10
      END IF
*-- Get calibration constants (skipped for DST data reading).
      IF(IUHEAD(IIDAT).NE.6.OR.IDUBAT.GE.1.OR.IFCNST.GE.1
     + .OR.IOCCRV.GE.1.OR.IOCEXP.GE.1) THEN
*-- Get start values for time monitoring of OPCAL.
         CALL ROMONI(0,1)
         CALL RGETCA
         CALL ROMONI(2,0)
      ELSE
*-- Get mag. field and beam position for DST
         CALL RFGNCT
*-- Get bunch info from the header
         CALL RGETBU
      END IF
      IF(IRSTOP.NE.0)                                          GO TO 999
*-- Now get REV structure.
      IF(LMEMIN) THEN
         NDUM   = NUHMAX
         CALL FZIN(LUN,IRODIV,LREV,1,'.',NDUM,HDUM)
      ELSE IF(PACKED) THEN
         CALL DCREAD(LUN)
      ELSE
         CALL FZIN(LUN,IRODIV,LREV,1,'A',0,0)
      END IF

      IF(IQUEST(1).NE.0)                                        GO TO 50
      IF(IQUEST(13).LE.0.OR.IQUEST(14).LE.0) THEN
         IQUEST(1) = -1
                                                                GO TO 50
      END IF
*-- Extend the data part if necessary.
      IF(IQND(LREV).LT.NDREV) THEN
         CALL MZPUSH(IRODIV,LREV,0,NDREV-IQND(LREV),'.')
         NUHEAD = NUHMAX
      END IF
*-- Tape information is in header only.
      IQ(LREV+IITAPE) = IUHEAD(IITAPE)
      IQ(LREV+IIRECI) = IUHEAD(IIRECI)
      IQ(LREV+IIPROD) = IUHEAD(IIPROD)
      IQ(LREV+IIRECO) = IUHEAD(IIRECO)
      IF(IFUPDT.EQ.1) THEN
*-- Reset ROPE status bit.
         IUHEAD(IIROST)  = 0
         IQ(LREV+IIROST) = 0
*-- Get rid of the Julian date!
         IF(IJULD.GE.1000000.OR.IOS9T.GE.1000000) THEN
            IQ(LREV+IIDATE) = IUHEAD(IIDATE)
            IQ(LREV+IITIME) = IUHEAD(IITIME)
         END IF
*-- Stick in correct Beam energy and Fill No.
         IQ(LREV+IIEBEA) = IUHEAD(IIEBEA)
         IQ(LREV+IIFILL) = IUHEAD(IIFILL)
*-- Update detector and trigger status.
         IQ(LREV+IIDETS) = IUHEAD(IIDETS)
         IQ(LREV+IITRGS) = IUHEAD(IITRGS)
         IQ(LREV+IISULM) = IUHEAD(IISULM)
      END IF
*-- If a COPY unit exists, write the record to it.
      LIOHD = LQ(LUTC-LLIOHD)
      LIODC = LQ(LIOHD-LLIODC)
      CALL ROWDAO(LIODC,IRODIV,LREV,1,'.',IOHEAD,NUHEAD,IUHEAD)
*-- Error, EOF,etc.
   50 IER = IQUEST(1)
*
  999 IF(LMEMIN) CALL ULOCKI(IRDEVT,IRDRUN)
      LEVTIA=.FALSE.
      RETURN
 1000 FORMAT('First record header: word',I3,' = ',I6)
 2000 FORMAT('Fill/Beam energy = ',I6,'/',I6,' MeV instead of ',
     +        I6,'/',I6,' Mev')
 3000 FORMAT('Time limit reached, still ',F7.3,
     +       ' sec. left to end the job')
      END
+DECK,ROFBUN.
      SUBROUTINE ROFBUN
*   Extract bunch info from OPCAL
*.
*. SEQUENCE: ROBUN
*. CALLS   : RGETBU
*. CALLED  : RGETDA
*.
*. AUTHOR  : M.Schroder
*. VERSION : 1.00
*. CREATED :  9-Apr-95
*. LAST MOD:  24-Jun-98
*.
*. Modification Log.
*. 24-Jun-98 M.Schroder Reduce severity of report message (1008)
*. 12-Sep-96 E.Barberio  repristinated some checks
*. 11-Jun-96 M.Schroder do NOT update header
*. 18-Feb-96 M.Schroder More protection if not in bunch mode,
*.                      update header word if FILTER disagrees with OPCAL
*.  2-Aug-95 M.Schroder protect against too small IROBUN ans ITRAIN
*. 18-JUL-95 O.SCHAILE  ADD IF(IFILLS.EQ.7) THEN NBUNCH=3
*.  6-Jun-95 M.Schroder call RGETBU after calling OCGET,
*.                      correct ITRAIN if it is bigger than NTRAIN
*. 15-May-95 M.Schroder make sure that IROBUN is not bigger than NBUNCH
*. 11-May-95 M.Schroder check run number change, call OCGET also if
*.                      LBUNMO FALSE (might be wrong...), set LBUTZ
*.  8-May-95 M.Schroder update ROBTZ properly for every event
*.  7-May-95 M.Schroder fix bug which made RBUNTZ values negative
*.  4-May-95 M.Schroder use the LEP bunch word from /ROOF/BUNCHTWO
*. 20-Apr-95 M.Schroder Preset variables to reasonable values
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER LGNCT,INCNL,INCND,LBUTZ,LENOCC,LSTRUN
      CHARACTER*80 CHPATH
      CHARACTER*4  CHOPT
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,ROBUN.
+SEQ,RCREP.
+SEQ,RCHTOP.
+SEQ,OCFLAG.
+SEQ,RCNTRL.
      INTEGER IVP(7),I,J,IFILLS,ILEPWO,NBUCKS,JBYT,JBIT
      REAL    BUCLEN,TBUSEP
      PARAMETER (BUCLEN=2.83886)
      DATA LSTRUN /0/
      ILEPWO = 0
*-- Do we have a new run?
      IF ( IRDRUN.NE.LSTRUN ) THEN
        LSTRUN = IRDRUN
*-- Preset rbuntz
        DO 10 I = 1,8
          DO 20 J = 1,8
            RBUNTZ(J,I) = 0.
   20     CONTINUE
   10   CONTINUE
        IROBUN = 1
        NBUNCH = 1
        ROBTZ  = 0
*-- Do we have a valid database attached?
        IF(CHTRRO.EQ.'    ') THEN
            GOTO 999
        ENDIF
*-- Book GNCT bank if needed.
        LGNCT = LQ(LDAC-LLGNCT)
        IF(LGNCT.LE.0) THEN
          CALL MZBOOK(IROCON,LGNCT,LDAC ,-LLGNCT,'GNCT',
     +               NLGNCT,NSGNCT,NDGNCT,IOGNCT,0)
        ELSE
*-- Extend link/data part if needed.
          INCNL = 0
          INCND = 0
          IF(IQNS(LGNCT).LT.NSGNCT) INCNL = NSGNCT - IQNS(LGNCT)
          IF(IQND(LGNCT).LT.NDGNCT) INCND = NDGNCT - IQND(LGNCT)
          IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LGNCT,INCNL,INCND,'.')
            CHREP = 'GNCT bank has been expanded'
            CALL REPORT('ROFBUN',1,'W')
          END IF
        END IF
        LBUTZ = LQ(LGNCT-LLBUTZ)
        IF( MOD (IUHEAD(IIEXPT),1000) .LT.7 ) THEN
*-- Runs without bunch train mode. We should not keep the BUTZ bank
          IF ( LBUTZ .GT. 0 ) THEN
            CALL MZDROP(IROCON,LBUTZ,' ')
            LBUTZ = 0
          ENDIF
          LBUNMO = .FALSE.
          GOTO 999
        ENDIF
        IVP(1) = IRDEXP
        IVP(2) = IRDRUN
        IVP(3) = IRDEVT
        IVP(7) = 0
        CHOPT  = 'DE'
        CHPATH = '//'//CHTRRO//'/ROOF/BUNCHTWO'
        CALL OCGET(IROCON,LGNCT,-LLBUTZ,CHPATH,IVP,CHOPT)
        IF( IOCERR.NE.0 ) THEN
          WRITE (CHREP,1001) IRDRUN,IOCERR,CHPATH(1:LENOCC(CHPATH))
          CALL REPORT('ROFBUN',1,'E')
          CALL MZDROP(IROCON,LBUTZ,' ')
          LBUTZ = 0
        ELSE
          LBUTZ = LQ(LGNCT-LLBUTZ)
          IF(LBUTZ.LE.0) THEN
            WRITE(CHREP,1002) IRDRUN
            CALL REPORT('ROFBUN',2,'E')
            GOTO 999
          ENDIF
*-- We have to decode the LEP info
          ILEPWO = IQ(LBUTZ+1)
*-- Is it valid?
          IF ( JBIT(ILEPWO,8) .EQ. 0 ) THEN
            LLEPVA = .TRUE.
          ELSE
            LLEPVA = .FALSE.
          ENDIF
          IF ( LLEPVA ) THEN
*-- the bunchlet seperation in RF buckets
            NBUCKS = JBYT(ILEPWO,17,8)
            TBUSEP = NBUCKS*BUCLEN
*-- the number of trains
            NTRAIN = JBYT(ILEPWO,9,8)
*-- the filling sceme (LEP only foresees 4 bunches per train)
            NBUNCH = 0
            IFILLS = JBYT(ILEPWO,1,4)
            IF ( IFILLS .EQ. 0 ) THEN
              NBUNCH = 1
              WRITE(CHREP,1003) IRDRUN, NBUNCH
              CALL REPORT('ROFBUN',3,'E')
            ELSEIF (IFILLS.EQ.1.OR.IFILLS.EQ.2.OR.
     +              IFILLS.EQ.4.OR.IFILLS.EQ.8 ) THEN
*-- only one bunch filled, for OPAL timing it does not matter which
              NBUNCH = 1
            ELSEIF (IFILLS.EQ.10.OR.IFILLS.EQ.5) THEN
*-- two bunches filled, with one empty bunch inbetween
              NBUNCH = 2
              TBUSEP = TBUSEP *2
            ELSEIF (IFILLS.EQ. 7) THEN
              NBUNCH = 3
            ELSEIF (IFILLS.EQ.15) THEN
              NBUNCH = 4
            ELSEIF (IFILLS.EQ.3.OR.IFILLS.EQ.6.OR.IFILLS.EQ.12) THEN
*-- two bunches filled, NO empty bunch inbetween
              NBUNCH = 2
            ELSE
*-- this should never happen...
              WRITE (CHREP,1004) IRDRUN, IFILLS
              CALL REPORT('ROFBUN',4,'E')
            ENDIF
            DO 50 I = 1,NBUNCH
              DO 60 J= 1,NTRAIN
                RBUNTZ(J,I) = (I-1)*TBUSEP
   60         CONTINUE
   50       CONTINUE
          ELSE
            WRITE(CHREP,1005) IRDRUN
            CALL REPORT('ROFBUN',5,'E')
            NBUNCH = 1
            NTRAIN = 4
          ENDIF
        ENDIF
      ENDIF
*-- extract the information from the header
      CALL RGETBU
      IF ( NBUNCH .GT. 1 .AND. .NOT.LBUNMO ) THEN
         WRITE(CHREP,1006) IRDRUN, IRDEVT, NBUNCH
         CALL REPORT('ROFBUN',6,'E')
         LBUNMO = .TRUE.
         IF( IFUPDT .GT. 0 ) THEN
            CALL SBYT(IFIBUN,IUHEAD(IIBUN),21,4)
            CALL SBIT1(IUHEAD(IIBUN),17)
         ENDIF
      ENDIF
      IF ( ITRAIN .GT. NTRAIN .AND. LBUTZ .GT. 0 ) THEN
        WRITE(CHREP,1008) IRDRUN, IRDEVT, NTRAIN, ITRAIN, NTRAIN
        CALL REPORT('ROFBUN',8,'I')
        ITRAIN = NTRAIN
         IF( IFUPDT .GT. 0 ) THEN
           CALL SBYT(ITRAIN,IUHEAD(IIBUN),1,8)
         ENDIF
      ELSEIF ( ITRAIN .LE. 0 .AND. LBUTZ .GT. 0 ) THEN
        WRITE(CHREP,1008) IRDRUN, IRDEVT, NTRAIN, ITRAIN, NTRAIN
        CALL REPORT('ROFBUN',8,'E')
        ITRAIN = 1
      ENDIF
      IF( LBUNMO .AND. IROBUN.GT.0 ) THEN
        IF( IROBUN .GT. NBUNCH .AND. LBUTZ .GT. 0 ) THEN
          WRITE(CHREP,1007) IRDRUN, IRDEVT, NBUNCH, IFIBUN, NBUNCH
          CALL REPORT('ROFBUN',7,'E')
          IROBUN = NBUNCH
           IF ( IFUPDT .GT. 0 ) THEN
* -- update the header info, but not IFIBUN
           CALL SBYT(IROBUN,IUHEAD(IIBUN),21,4)
           CALL SBIT1(IUHEAD(IIBUN),20)
           ENDIF
        ENDIF
        ROBTZ = RBUNTZ(ITRAIN,IROBUN)
      ELSE
        IROBUN = 1
        ROBTZ  = 0.
      ENDIF
  999 CONTINUE
      RETURN
 1001 FORMAT(I4,9X,'Error',I4,' from OCGET, path ',A50)
 1002 FORMAT(I4,9X,'BUTZ bank not lifted.')
 1003 FORMAT(I4,9X,'OPCAL : NBUNCH = 0, set NBUNCH =',I2)
 1004 FORMAT(I4,9X,'LEP bunchlet filling sceme weired: ',I4)
 1005 FORMAT(I4,9X,'LEP bunchword found, but not valid.')
 1006 FORMAT(I4,I7,'  FILTER : NO bunchmode, OPCAL : NBUNCH =',I2)
 1007 FORMAT(I4,I7,'  NBUNCH=',I2,' but IFIBUN=',I6,', set IROBUN=',I2)
 1008 FORMAT(I4,I7,'  NTRAIN=',I2,' but ITRAIN=',I6,', set ITRAIN=',I2)
      END
+DECK,RGETBU.
      SUBROUTINE RGETBU
*   Extract bunch info from the header
*.
*. SEQUENCE: ROBANK CRO ROPAR ROBUN
*. CALLS   :
*. CALLED  : RGETDA ROFBUN
*.
*. AUTHOR  : M.Schroder
*. VERSION : 1.00
*. CREATED :  9-Apr-95
*. LAST MOD: 12-Sep-96
*.
*. Modification Log.
*. 12-Sep-96 E.Barberio  repristinated some checks
*. 11-Jun-96 M.Schroder Do NOT update header word
*. 18-Feb-96 M.Schroder update header word if FILTER disagrees with OPCAL
*. 15-Nov-95 M.Schroder   Protect ITRAIN, sometimes it is just too big
*. 15-May-95 M.Schroder   make sure that IROBUN=1 if not in bunchmode
*.  9-May-95 M.Schroder   preset IROBUN to 1
*.  7-May-95 M.Schroder   do not reset NBUNCH for every event
*.  5-May-95 M.Schroder   change default values, add e+,e- train number
*. 20-Apr-95 M.Schroder   Preset some variables, check for exp number
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,RCREP.
+SEQ,ROBUN.
+SEQ,RCNTRL.
+SEQ,ODPAR.
      INTEGER JBIT,JBYT
*-- Preset to some reasonable values
*-- No bunchmode corresponds to 1 bunch per train
C     NBUNCH = 1
*-- We sometimes had 8 'trains', but that does not matter
      NTRAIN = 4
      ROBTZ  = 0.
      IROBUN = 1
*     no bunchtrains in MC
      IF ( IUHEAD(IIEXPT) .GE. 1000 ) GOTO 9000
*     bunchtrains started with exp. 7
      IF( IUHEAD(IIEXPT) .GE.7 ) THEN
*-- The LEP info
        ITRAIN = JBYT(IUHEAD(IIBUN),1,4)
        IF ( IUHEAD(IIEXPT) .EQ. 7 ) THEN
          IF ( ITRAIN .GT. 4 ) THEN
            WRITE(CHREP,1001) IRDRUN, IRDEVT, ITRAIN
            CALL REPORT('RGETBU',1,'E')
            ITRAIN = 4
             IF( IFUPDT .GT. 0 ) THEN
               CALL SBYT(ITRAIN,IUHEAD(IIBUN),1,8)
             ENDIF
          ENDIF
        ENDIF
        IETRAI = MOD(ITRAIN+2,4)+1
        IPTRAI = MOD(ITRAIN+1,4)+1
*-- The ROPE info
        IF(JBIT(IUHEAD(IIBUN),18).EQ.1) THEN
          LROBUT = .TRUE.
        ELSE
          LROBUT = .FALSE.
        ENDIF
        IF(JBIT(IUHEAD(IIBUN),19).EQ.1) THEN
          LROBUS = .TRUE.
        ELSE
          LROBUS = .FALSE.
        ENDIF
        IROBUN = JBYT(IUHEAD(IIBUN),21,4)
*-- The FILTER info
        IF(JBIT(IUHEAD(IIBUN),25).EQ.1) THEN
          LBUNMO = .TRUE.
        ELSE
          LBUNMO = .FALSE.
        ENDIF
        IF(JBIT(IUHEAD(IIBUN),26).EQ.1) THEN
          LFIBUT = .TRUE.
        ELSE
          LFIBUT = .FALSE.
        ENDIF
        IF(JBIT(IUHEAD(IIBUN),27).EQ.1) THEN
          LFIBUS = .TRUE.
        ELSE
          LFIBUS = .FALSE.
        ENDIF
        IFIBUN = JBYT(IUHEAD(IIBUN),29,4)
      ELSE
*-- There was no bunchmode before 1995
        LROBUT = .FALSE.
        LROBUS = .FALSE.
        LBUNMO = .FALSE.
        LFIBUT = .FALSE.
        LFIBUS = .FALSE.
        ITRAIN = JBYT(IUHEAD(IIBUN),1,8)
        IROBUN = 1
        IFIBUN = 1
*-- The IxTRAIN values did not matter...
        IETRAI = 1
        IPTRAI = 1
        ROBTZ  = 0.
      ENDIF
      IF ( .NOT.LROBUT ) THEN
        IF ( LFIBUS ) THEN
          IROBUN = IFIBUN
        ELSE
          IROBUN = 1
        ENDIF
      ENDIF
 9000 CONTINUE
      RETURN
 1001 FORMAT(I4,I7,'  NTRAIN= 4 but ITRAIN=',I6,', set ITRAIN= 4')
      END
+DECK,ROBUTI.
      SUBROUTINE ROBUTI
*   Extract timing for used bunch from OD/GNRL
*.
*. SEQUENCE: ROBANK CRO ROPAR ROBUN
*. CALLS   :
*. CALLED  : RGETDA
*.
*. AUTHOR  : M.Schroder
*. VERSION : 1.00
*. CREATED : 20-Apr-95
*. LAST MOD:  5-MAY-95
*.
*. Modification Log.
*.  5-May-95 M.Schroder  default for ROBTZ has changed, check for LBUTZ
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROBUN.
+SEQ,ODPAR.
+SEQ,RCREP.
      INTEGER LGNRL, LGNCT, LBUTZ, INCNL, INCND
*-- has it already been filled from header info plus opcal ?
      LGNCT = LQ(LDAC-LLGNCT)
*-- Book GNCT bank if needed.
      IF(LGNCT.LE.0) THEN
         CALL MZBOOK(IROCON,LGNCT,LDAC ,-LLGNCT,'GNCT',
     +               NLGNCT,NSGNCT,NDGNCT,IOGNCT,0)
      ELSE
*-- Extend link/data part if needed.
         INCNL = 0
         INCND = 0
         IF(IQNS(LGNCT).LT.NSGNCT) INCNL = NSGNCT - IQNS(LGNCT)
         IF(IQND(LGNCT).LT.NDGNCT) INCND = NDGNCT - IQND(LGNCT)
         IF(INCNL.GE.1.OR.INCND.GE.1) THEN
            CALL MZPUSH(IROCON,LGNCT,INCNL,INCND,'.')
            CHREP = 'GNCT bank must be expanded'
            CALL REPORT('RFGNCT',1,'W')
         END IF
      END IF
      LBUTZ = LQ(LGNCT-LLBUTZ)
      IF ( LBUTZ .GT. 0 ) GOTO 999
*     bunchtrains started with exp. 7
      IF( MOD( IUHEAD(IIEXPT),1000).LT.7 ) GOTO 999
      IF ( .NOT.LBUNMO ) GOTO 999
      LOD = LQ(LREV-LLOD)
      IF( LOD .GT. 0 ) THEN
        LGNRL = LQ(LOD-LLODGL)
        IF ( LGNRL .LE. 0 ) THEN
          CHREP = 'ROBTZ not filled from OPCAL and no OD/GNRL bank.'
          CALL REPORT('ROBUTI',1,'E')
          GOTO 999
        ENDIF
        ROBTZ = Q(LGNRL+1+JGBTZ)
      ELSE
        CHREP = 'ROBTZ not filled from OPCAL and no OD bank.'
        CALL REPORT('ROBUTI',2,'E')
      ENDIF
  999 CONTINUE
      RETURN
      END
+DECK,RGETDV.
      SUBROUTINE RGETDV
*.
*...RGETDV Allocate devices for the poor user
*.  Card format is:
*.  *GETDEVICE n 'type' 'prefix'
*.   n     is the number of devices to be allocated
*.  'type' can be :
*.     'E' for exabyte. Then 'prefix' is either:
*.        'ppp:'    to allocate devices by name
*.        'generic' to allocate devices by generic name
*.        '(blank)' on standard computers
*.
*.     'P' for plotter  Then 'prefix' is the plotter name
*.
*. SEQUENCE: RCNTRL ROUNIT RCSYST ROWORD RCREP
*. CALLS   : RALLDV CLTOU UHTOC VBLANK CLEFT SPACES LENOCC
*. CALLED  : RFUSER RIOFIL
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 13-Dec-90
*.
*. Modification Log.
*.  13-Dec-1990  F.Odorici  Add Chicago exabyte drives (nodes and names).
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER      NDEV,FIRST,I,LENOCC,NALLO,NPLOT
      CHARACTER*1  TYPE
      CHARACTER*4  DVTYPE
      CHARACTER*80 DEVNAM,SPACES
+SEQ,RCREP.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,ROWORD.
*
+SELF,IF=IBM.
      PARAMETER(NPLOT=3)
      CHARACTER*8  PNODES(NPLOT),PLOTTE(NPLOT)
      DATA        (PNODES(I),PLOTTE(I),I=1,NPLOT)
     +            /'CERNVM','EP28A'
     +            ,'UKACRL','????'
     +            ,'FRSAC12','SAC141A'
     +            /
+SELF,IF=VAX,UNIX.
      PARAMETER(NPLOT=1)
+SELF,IF=VAX.
*     Configuration description
      INTEGER      NCONFIG
      PARAMETER   (NCONFIG=23)
      CHARACTER*8  NODES(NCONFIG),DEVICES(NCONFIG)
      DATA        (NODES(I),DEVICES(I),I=1,NCONFIG)
     +           /'CBHEP1','MUB0:'
     +           ,'CBHEP3','MUB:'
     +           ,'LPSVSD','MKB0:'
     +           ,'LPSVSE','MKB0:'
     +           ,'LPSVSF','MKB0:'
     +           ,'MVXOP2','MKB:'    ! Bologna Vax
     +           ,'UXOPB1','MUA:'    ! Opal offline Vax (Boot node 1)
     +           ,'UXOPB2','TK50'    ! Opal offline Vax (Boot node 2)
     +           ,'UXOPB3','MUB:'    ! Opal offline Vax (Boot node 3)
     +           ,'UCHEPA','MUA:'    ! Chicago Vax
     +           ,'UCHEPC','MUA0:'   ! Chicago Vax
     +           ,'UCHEPD','MUA:'    ! Chicago Vax
     +           ,'UCHEPE','MUA:'    ! Chicago Vax
     +           ,'UCHEPF','MUA0:'   ! Chicago Vax
     +           ,'VSOPP1','MUA0:'
     +           ,'VSOPP2','MUA0:'
     +           ,'VSOPP5','MKA500:'
     +           ,'VSOPZ3','MKB500:'
     +           ,'VSOPZ4','MKB500:'
     +           ,'VS5BO1','MUB:'    ! Bologna Vax
     +           ,'VSOPRC','MKB0:'
     +           ,'VSOPJU','MKB0:'
     +           ,'VSOPJ3','MKB:'
     +           /
+SELF.
      CALL UHTOC(LTYPDE,4,DVTYPE,4)
      CALL CLTOU(DVTYPE)
      CALL CLEFT(DVTYPE,1,4)
      TYPE   = DVTYPE(1:1)
      CALL UHTOC(LDEVNA,NBYTEW,DEVNAM,NAMLEN)
      DEVNAM = SPACES(DEVNAM,1)
      IF(LNDEVI.EQ.0) THEN
         NDEV   = 1
      ELSE
         NDEV   = LNDEVI
      END IF
      IF(TYPE.EQ.'P') THEN
+SELF,IF=IBM.
         IF(DEVNAM.EQ.' ') THEN
            DO 10 I=1,NPLOT
            IF(CHNODE.EQ.PNODES(I)) DEVNAM = PLOTTE(I)
   10       CONTINUE
            IF(DEVNAM.EQ.' ')                                   GO TO 60
         END IF
         PLTTER = DEVNAM
         LPLOT  = .TRUE.
                                                               GO TO 999
+SELF,IF=VAX,UNIX.
         CHREP  = 'Sorry no metafile plotting implemented. It will come'
         CALL REPORT('RGETDV',1,'E')
                                                                GO TO 90
+SELF,IF=VAX.
      ELSE IF(TYPE.EQ.'E') THEN
         DO 20 I=1,NXDEVI
         IF(.NOT.LDVALL(I))                                     GO TO 30
   20    CONTINUE
                                                                GO TO 70
   30    FIRST  = I
         IF(FIRST+NDEV-1.GT.NXDEVI)                             GO TO 70
         IF(DEVNAM.EQ.' ') THEN
            DO 40 I=1,NCONFIG
            IF(CHNODE.EQ.NODES(I)) DEVNAM = DEVICES(I)
   40       CONTINUE
            IF(DEVNAM.EQ.' ')                                   GO TO 80
         END IF
         CALL RALLDV(DEVNAM(1:LENOCC(DEVNAM)),DVNAME(FIRST),NDEV,NALLO)
         IF(NALLO.LT.NDEV) THEN
            WRITE(CHREP,1000) NALLO,TYPE
            CALL REPORT('RGETDV',2,'N')
            IF(NALLO.EQ.0)                                      GO TO 90
         END IF
         DO 50 I=1,NALLO
            EXADEV(I+EXALAS)  = I + FIRST - 1
            LDVALL(I+FIRST-1) = .TRUE.
            TAPMOU(I+FIRST-1) = '???'
   50    CONTINUE
         EXALAS = EXALAS + NALLO
                                                               GO TO 999
+SELF.
      ELSE
         CHREP  = 'Unknown device type :'//TYPE
         CALL REPORT('RGETDV',3,'E')
                                                                GO TO 90
      END IF
+SELF,IF=IBM.
   60 CHREP  = 'No default plotter for this node. Please supply it'
      CALL REPORT('RGETDV',4,'E')
+SELF,IF=VAX.
   70 CHREP  = 'Not enough devices of type: '//TYPE
      CALL REPORT('RGETDV',5,'E')
                                                                GO TO 90
*
   80 CHREP='Rope does not know this node configuration. '//
     +       'Specify the device (generic) name'
      CALL REPORT('RGETDV',6,'E')
+SELF.
*
   90 FFERRO = .TRUE.
  999 LNDEVI = 0
      CALL VBLANK(LTYPDE,1)
      CALL VBLANK(LDEVNA,NAMLWO)
*
      RETURN
 1000 FORMAT('Only',I4,' devices of type ',A,' was allocated')
      END
+DECK,RGETED.
      SUBROUTINE RGETED(LUN,IER)
*.
*...RGETED   Do something with the OPAL End-of-Run record
*.
*. INPUT     : LUN   Logical input unit, of course.
*. OUTPUT    : IER   Return code, 0 if OK.
*.
*. SEQUENCE  : ROBANK
*. COMMON    : QUEST
*. CALLS     :
*. CALLED    : RGETDA
*.
*. BANK U    :
*. BANK M    :
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 15-Jun-1989
*. LAST MOD  : 15-Jun-1989
*.
*. Modification log:
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LUN,IER,IQUEST
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
*
      IER = 0
*
      RETURN
      END
+DECK,RGETIN.
      SUBROUTINE RGETIN(LUN,IER)
*.
*...RGETIN   Routine to read in 'INIT' data structures
*.
*. INPUT   :  LUN      Logical unit number
*. OUTPUT  :  IER      Error flag
*.
*. SEQUENCE: ROBANK GCNUM GCDRAW GCCUTS
*. COMMON  : QUEST
*. CALLS   : MZDROP FZIN
*. CALLED  : RIOSET
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 13-Nov-87
*. LAST MOD:  4-Nov-94
*.
*. Modification Log.
*.  4-Nov-94 M.Redmond   Add call to GGCLOS to define VIRT structure
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LUN,IER,NUH,IUHEAD,LINK,JLINK,IQUEST,NK,I,KS,IL
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK
+SEQ,GCNUM
+SEQ,GCDRAW
+SEQ,GCCUTS
*
      DIMENSION IUHEAD(2)
      DIMENSION LINK(7),JLINK(17)
      SAVE      LINK
      EQUIVALENCE (JLINK(1),JDIGI)
      DATA LINK/7,6,13,16,8,10,2/
*
      IER    = 0
      NUH    = 2
*-- Go for next start of event data structure.
      IF(JRUNG.NE.0)CALL MZDROP(IXSTOR,JRUNG,'.')
      CALL FZIN(LUN,IXCONS,JRUNG,1,'E',NUH,IUHEAD)
      IF(IQUEST(1).GT.2)                                        GO TO 20
*
      NK     = IUHEAD(2)
      IF(NK.LE.0)                                               GO TO 20
      IF(NK.GT.10)                                              GO TO 20
      DO 10 I=1,NK
*-- Read next header.
         NUH    = 2
         CALL FZIN(LUN,IXCONS,0,0,'S',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)                                     GO TO 20
         KS     = IUHEAD(1)
         IF(KS.LE.0)                                            GO TO 10
         IF(KS.GE.8)                                            GO TO 10
         IL     = LINK(KS)
         IF(JLINK(IL).NE.0)CALL MZDROP(IXSTOR,JLINK(IL),'.')
*-- Read pending data structure.
         CALL FZIN(LUN,IXCONS,JLINK(IL),1,'A',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)                                     GO TO 20
   10 CONTINUE
*-- Get some values for GCCUTS,GCNUM and GCDRAW.
      IF(JTMED.NE.0)CALL UCOPY(Q(JTMED+1),CUTGAM,9)
      IF(JVOLUM.GT.0)NVOLUM = IQ(JVOLUM-1)
      IF(JDRAW.GT.0) NKVIEW = IQ(JDRAW-2)
      CALL GGCLOS
*-- Error, EOF,etc.
   20 IER    = IQUEST(1)
      RETURN
      END
+DECK,RGETST.
      SUBROUTINE RGETST(LUN,IER)
*.
*...RGETST   Do something with the OPAL Start-of-Run record
*.
*. INPUT     : LUN   Logical input unit, of course.
*. OUTPUT    : IER   Return code, 0 if OK.
*.
*. SEQUENCE  : ROBANK
*. COMMON    : QUEST
*. CALLS     :
*. CALLED    : RGETDA
*.
*. BANK U    :
*. BANK M    :
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 15-Jun-1989
*. LAST MOD  : 15-Jun-1989
*.
*. Modification log:
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LUN,IER,IQUEST
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
*
      IER = 0
*
      RETURN
      END
+DECK,RGETUN.
      SUBROUTINE RGETUN(WATFOR,LUN)
*.
*...RGETUN Returns a free logical i/o unit to the user
*.
*. CALLS   : ROGTUN
*. CALLED  : <USER>
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED :  8-Jan-91
*. LAST MOD:  8-Jan-91
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER       LUN
      CHARACTER*(*) WATFOR
*
      LUN    = 0
      CALL ROGTUN(LUN,WATFOR)
      RETURN
      END
+DECK,RGIMED,IF=IBM.
      SUBROUTINE RGIMED(DISK,MODE)
*.
*...RGIMED Access the disk DISK (possibly with options) and return the
*.         mode (blank if the access has crashed)
*.
*. CALLS   : RQSYST
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*1   MODE,SEPAR
      CHARACTER*(*) DISK
      INTEGER       L,LENOCC
+SEQ,RCREP.
+SEQ,RCSYST.
*
      L      = LENOCC(DISK)
      IF(INDEX(DISK,'(').EQ.0) THEN
         SEPAR  = '('
      ELSE
         SEPAR  = ' '
      END IF
      SYSCOM = 'EXEC GIME '//DISK(1:L)//SEPAR//'QUIET NONOTICE STACK'
      CALL RQSYST(.FALSE.)
      IF(SYSRC.GT.4) THEN
          CHREP  = 'Could not access the disk '//DISK(1:L)
          CALL REPORT('RGIMED',2,'N')
          MODE   = ' '
                                                               GO TO 999
      END IF
      CALL VMRTRM(MODE,L)
*
  999 RETURN
      END
+DECK,RGINIT.
      SUBROUTINE RGINIT
*.
*...RGINIT   Initialization not to be done in GOPAL/ROPE runs.
*.
*. SEQUENCE: ROBANK CRO
*.           GCUNIT GCONST GCLIST GCFLAG GCNUM GCTIME GCJLOC
*. COMMON  : GCLOCA
*. CALLS   : UCTOH VFILL FFKEY VZERO MZLINK MZLINT
*. CALLED  : ROPINI
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.00
*. CREATED :  9-Feb-89
*. LAST MOD: 18-Fev-91
*.
*. Modification Log.
*. 18-Fev-91 S.Weisz       Cope with new version of GCJLOC in GEANT314.
*.  7-Sep-89 S.Weisz       REPORT Ffread card definition in REINIT
*. 15-Jul-89 S.Weisz       Modify defaulf for FATAL rerror reporting
*. 23-Feb-89 S.Weisz       Define Ffread card REPORT
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IDFLT
      INTEGER NLOCAL,LOCAL
      COMMON/GCLOCA/NLOCAL(2),LOCAL(20)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,GCUNIT,GCLIST,GCONST,GCTIME,GCFLAG,GCNUM,GCVOLU,GCJLOC.
*
      CALL UCTOH('    ',IDFLT,4,4)
*-- Initialize the GEANT related common:
*-- GCUNIT.
      LIN    = LRIN
      LOUT   = LROUT
      CALL VZERO(NUNITS,6)
*-- GCONST.
      PI     = ACOS (-1.)
      TWOPI  = 2. * PI
      PIBY2  = PI / 2.
      DEGRAD = PI / 180.
      RADDEG = 1. / DEGRAD
      CLIGHT = 2.99792458E+10
      BIG    = 1.E+10
      EMASS  = 0.5110034E-03
      EMMU   = 0.105659
      PMASS  = 0.93828
      AVO    = 0.6022045
*-- GCLIST.
      CALL VZERO(NHSTA,9)
      CALL VFILL (LHSTA, 180, IDFLT)
*-- GCFLAG.
      CALL VZERO(IDEBUG,42)
      IEVENT = 0
      IDRUN  = 1
      NEVENT = 10000000
*-- GCNUM.
      NHEAD  = 10
      NTMED  = 100
      NMATE  = 100
      NROTM  = 100
      NPART  = 100
*-- GCTIME.
      TIMINT = 0.
      TIMEND = 1.
      ITIME  = 1
*-- Create a permanent link area for master pointers.
      CALL MZLINK(IXSTOR,'/GCLINK/',JDIGI,JSKLT,JDIGI)
*-- Create a temporary link areas local pointers.
      CALL MZLINT(IXSTOR,'/GCLOCA/',NLOCAL,LOCAL(1),LOCAL(20))
+SELF,IF=GEANT313.
      CALL MZLINT(IXSTOR,'/GCJLOC/',NJLOC ,JTM,JMULS)
+SELF,IF=-GEANT313.
      CALL MZLINT(IXSTOR,'/GCJLOC/',NJLOC ,JTM,JRANG)
+SELF.
*
      RETURN
      END
+DECK,RHBEND.
      SUBROUTINE RHBEND
*.
*...RHBEND  Close all HBOOK RZ files, try to save HBOOK objects to an
*...        RZ file if possible, used during crash error termination.
*.
*. SEQUENCE  : DECLARE RCREP
*. CALLS     : RZCDIR RZMODS HCDIR HROUT RZEND REPORT
*. CALLED    : ROPE
*.
*. BANKS L   :
*. BANKS U   :
*.
*. AUTHOR    : N.K.Watson
*. VERSION   : 1.00
*. CREATED   : 18-Feb-92
*. LAST MOD  :  6-May-94
*.
*. MODIFICATION LOG.
*.  6-May-94 M.Redmond  Use HREND until bug in HRENDC understood
*. 18-Apr-94 O.Schaile  Use new routine HFILES, remove HCDIRE
*. 08-Jul-93 N.K.Watson Another undocmented change in latest /HCDIRE/.
*. 15-Feb-92 N.K.Watson Additional assignment for changes in /HCDIRE/.
*.*********************************************************************
+SEQ,DECLARE.
*
+SEQ,RCREP.
      INTEGER I, MODIFY, ICYCLE, ICONT, MTOP
      PARAMETER (MTOP=5)
      CHARACTER*16 CHTOP(MTOP)
      INTEGER NCHTOP, ICHTOP(MTOP), ICHLUN(MTOP)
*
      MODIFY=0
      ICYCLE=0
      ICONT=0
*
*-- Loop over top directories, save histograms and ntuples in any HBOOK
*-- RZ file that we are able to modify, and close properly all HBOOK
*-- RZ files irrespective of whether or not they can be modified.
 10   CONTINUE
      CALL HFILES(NCHTOP,CHTOP,ICHTOP,ICHLUN,MTOP,ICONT)
      IF(NCHTOP.LE.0)GOTO 30
      DO 20 I=1,NCHTOP
        IF (ICHTOP(I).GT.0.AND.ICHTOP(I).LT.1000)THEN
*
*-- Look at next top directory.
          CALL RZCDIR('//'//CHTOP(I),' ')
*
*-- Can we modify this directory?
          CALL RZMODS('RHBEND',MODIFY)
*
*-- If so, assume we should write all HBOOK objects to it.
          IF (MODIFY.EQ.0) THEN
* (Is it safe to call REPORT once we are in crash/abort situation??)
            CHREP='Writing HBOOK objects to //'//CHTOP(I)//'.'
            CALL REPORT('RHBEND',1,'INFORMATION')
            CALL HCDIR('//PAWC',' ')
            CALL HCDIR('//'//CHTOP(I),' ')
            CALL HROUT(0,ICYCLE,'T')

*-- If not, state that we know we can't do so.
          ELSE
* (Is it safe to call REPORT once we are in crash/abort situation??)
            CHREP='Unauthorised to write to //'//CHTOP(I)//'.'
            CALL REPORT('RHBEND',2,'INFORMATION')
          ENDIF
          CHREP='Closing file //'//CHTOP(I)//'.'
          CALL REPORT('RHBEND',3,'INFORMATION')
          CALL HREND(CHTOP(I))
        ENDIF
  20  CONTINUE
*     is there more to do?
      IF(ICONT.GT.0)GOTO 10
*
*-- Tidy up after ourselves and reset top directory in memory.
  30  CALL HCDIR('//PAWC',' ')
      RETURN
      END
+DECK,RIOCAT.
      SUBROUTINE RIOCAT
*.
*...RIOCAT  Handle *CATFILE FFREAD cards
*.
*. SEQUENCE: ROBANK CRO RCNTRL ROCPAR ROUNIT RCSYST FMPAR RCREP
*. CALLS   : ROVANA RFCLIS RSBWRD RWORDS RIOFIL ROFIRL CLTOU SPACES
*.           LENOCC MZWORK RMAIL
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 28-Aug-91
*.
*. Modification Log.
*. 28-Aug-91 D.Lellouch Clear file parameters at the end.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER      MAXLIN
      PARAMETER   (MAXLIN=1000)
      CHARACTER*1  OPT
      CHARACTER*4  DCHOPT
      CHARACTER*16 CHCOMP
      CHARACTER*80 CFNAME,SEARCH,SPACES
      INTEGER      RWORDS,I,I1,I2,L,NFOUND,LENOCC,
     +             ACTUAL,IFIRST,ILAST,INSIDE,IER
      LOGICAL      HERE,LVARI,QUIET
      EXTERNAL     RWORDS,LENOCC
+SEQ,RCNTRL.
+SEQ,CRO.
+SEQ,ROBANK.
+SEQ,RCREP.
+SEQ,RCLINE.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,ROWORD.
      CHARACTER*(NAMLEN) LINES(MAXLIN)
      EQUIVALENCE (WS(1),LINES(1))
*
      IF(.NOT.LCATAL)CALL RSCATA
      IF(.NOT.LCATAL) THEN
         CHREP  = 'The CATALOG package cannot be initialised'
         CALL REPORT('RIOCAT',1,'E')
                                                                GO TO 30
      END IF
*-- Make space to receive all file names
      CALL MZWORK(IXSTOR,WS(1),WS(NAMLWO*MAXLIN),0)
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LCFNAM,NBYTEW,CFNAME,NAMLEN)
      CFNAME = SPACES(CFNAME,1)
      IF(CFNAME.EQ.' '.OR.LCFTYP.EQ.0.OR.LCFDIR.EQ.0) THEN
         CHREP  = 'Not enough parameters on *CATFILE card'
         CALL REPORT('RIOCAT',2,'E')
                                                                GO TO 30
      END IF
*-- What about special characters?
      CALL ROVANA(CFNAME,LVARI)
      IF(LVARI) THEN
         CHREP  = 'Variable names not allowed with *CATFILE'
         CALL REPORT('RIOCAT',3,'E')
                                                                GO TO 30
      END IF
      CFNAME = SPACES(CFNAME,0)
      I1     = INDEX(CFNAME,'[')
      I2     = LENOCC(CFNAME)
      IF(I1.EQ.0) THEN
         SEARCH = CFNAME
         IFIRST = 1
         ILAST  = 99999
      ELSE IF(CFNAME(I2:I2).EQ.']') THEN
         CALL ROFIRL(CFNAME(I1+1:I2-1),IFIRST,ILAST,IER)
         IF(IER.EQ.0) THEN
            SEARCH = CFNAME(1:I1-1)
         ELSE
            CHREP  = 'Invalid [...] specification'
            CALL REPORT('RIOCAT',4,'E')
                                                                GO TO 30
         END IF
      ELSE
         CHREP  = 'Unbalanced "["'
         CALL REPORT('RIOCAT',5,'E')
                                                                GO TO 30
      END IF
+SELF,IF=VAX.
      CHCOMP = CHNODE(1:LCHNOD)//'::'
+SELF.
*-- Decode the file dependent option
      IF(LCFDCH.EQ.0) THEN
         DCHOPT = '    '
      ELSE
         CALL UHTOC(LCFDCH,4,DCHOPT,4)
      END IF
      CALL CLTOU(DCHOPT)
      QUIET  = .FALSE.
      HERE   = .TRUE.
      DO 10 I = 1,4
      OPT    = DCHOPT(I:I)
      CALL CLTOU(OPT)
      IF(OPT.EQ.' ') THEN
      ELSE IF(OPT.EQ.'H') THEN
         HERE   = .TRUE.
      ELSE IF(OPT.EQ.'O') THEN
         HERE   = .FALSE.
      ELSE IF(OPT.EQ.'Q') THEN
         QUIET  = .TRUE.
      ELSE IF(OPT.EQ.'X') THEN
      ELSE IF(OPT.EQ.'1') THEN
      ELSE IF(OPT.EQ.'C') THEN
      ELSE IF(OPT.EQ.'E') THEN
      ELSE
         CHREP  = 'Invalid RCHOPT option: '//OPT
         CALL REPORT('RIOCAT',6,'E')
                                                                GO TO 30
      END IF
   10 CONTINUE
*-- Now call the expansion catalog routine
      CALL RFCLIS(SEARCH,LINES,MAXLIN,NFOUND)
      IF(NFOUND.EQ.0) THEN
         CHREP  = 'No entry satisfies your search criteria'
         CALL REPORT('RIOCAT',7,'E')
                                                                GO TO 30
      ELSE IF (NFOUND.EQ.MAXLIN) THEN
         WRITE(CHREP,1010) MAXLIN
         CALL REPORT('RIOCAT',8,'W')
      END IF
      ACTUAL = 0
      INSIDE = 0
      DO 20 I=1,NFOUND
      CALL UCTOH(LINES(I),LFINAM,NBYTEW,NAMLEN)
*-- With the 'H' option, check that the file sits here
      IF(HERE) THEN
+SELF,IF=VAX.
         IF(LINES(I)(1:LCHNOD+2).NE.CHCOMP)                     GO TO 20
+SELF.
      END IF
      ACTUAL = ACTUAL + 1
*-- Now check that the occurence number fits the requirements
      IF(ACTUAL.GE.IFIRST.AND.ACTUAL.LE.ILAST) THEN
         INSIDE = 1 + INSIDE
         IF(.NOT.QUIET) THEN
            L      = LENOCC(LINES(I))
            WRITE(CHLINE,1000) INSIDE,LINES(I)(1:L)
            CALL RMAIL(0,0)
         END IF
         LFITYP = LCFTYP
         LFIDIR = LCFDIR
         LFIUNI = LCFUNI
         LFILRE = LCFLRE
         LFIFCH = LCFFCH
         LFIDCH = 0
         CALL RIOFIL
      END IF
   20 CONTINUE
      IF(ACTUAL.EQ.0) THEN
         CHREP  = 'No entry sits HERE, on this computer'
         CALL REPORT('RIOCAT',9,'E')
                                                                GO TO 30
      ELSE IF(INSIDE.EQ.0) THEN
         CHREP  = 'No entry satisfies your occurence number selection'
         CALL REPORT('RIOCAT',10,'E')
                                                                GO TO 30
      END IF
                                                               GO TO 999
   30 FFERRO = .TRUE.
  999 CALL VZERO(LCFTYP,NPACFI)
      CALL VBLANK(LCFNAM,NAMLWO)
      CALL VZERO(LFITYP,NPAFIL)
      CALL VBLANK(LFINAM,NAMLWO)
*
      RETURN
 1000 FORMAT(26X,I4,' --> ',A)
 1010 FORMAT(' The maximum of',I5,' files has been reached. Some',
     +       ' might have been forgotten')
      END
+DECK,RIODAD.
      SUBROUTINE RIODAD
*.
*...RIODAD   Set up banks for DAD list access mode definition
*.
*. SEQUENCES : ROBANK RCNTRL ROUNIT ROCPAR ROWORD RCSYST RBITFUNC RCREP
*. CALLS     : RSCATA ROGTUN MZBOOK LZLAST
*. CALLED    : RFUSER RCATDA
*. AUTHOR    : D. Lellouch
*. VERSION   : 1.00
*. CREATED   : 28-Feb-1991
*. LAST MOD  : 27-Aug-1991
*.   DETAILED DESCRIPTION:
*.  Interpret the new *DADFILE FFREAD card. The format is:
*.  *DADFILE 'stream' 'direction' unit1 unit2 'rchopt' 'name'
*.           'stream' is DATA,DST,DDST,...
*.           'dir'    is IN or OUT
*.           unit1    is the unit to access the dadlist
*.           unit2    is the unit to access the DST or DD file
*.           Rchopt   Rope processing option
*.           name     [generic] name of the Dadlist
*. Modification log:
*. 27-Aug-91 S.Weisz    Use RBITFUNC sequence
*. 26-Mar-91 D.Lellouch Search for DAD list header on output.
***********************************************************************
+SEQ,DECLARE.
      INTEGER            FLAGS,TYPE,LIOHD,LIOBNK,LLIO,I,IARROW
      INTEGER            LZLAST
      LOGICAL            LOUTPU,LVARI
      LOGICAL            RABBRE
      CHARACTER*1        OPT
      CHARACTER*4        CFIDIR,CFITYP,CFIDCH,CHIO,CFSTAT
      CHARACTER*8        WATFOR
      CHARACTER*40       HEADER
      CHARACTER*80       DADNAM,SPACES
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
+SEQ,ROWORD.
+SEQ,RCSYST.
+SEQ,RBITFUNC.
+SEQ,RCREP.
*-- Check there are enough parameters.
      IF(LDATYP.EQ.0)                                           GO TO 20
      IF(LDADIR.EQ.0)                                           GO TO 20
      IF(LDAUN1.EQ.0)                                           GO TO 20
*-- The MAW$DBS or so catalog must have been previoulsy opened
      IF(.NOT.LCATAL) THEN
         CALL RSCATA
         IF(.NOT.LCATAL)                                        GO TO 30
      END IF
*-- Set defaults.
      FLAGS  = IBSET(0,DADLIS)
*-- Check whether a file name was given, and check the name
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LDANAM,NBYTEW,DADNAM,NAMLEN)
      DADNAM = SPACES(DADNAM,1)
      IF(DADNAM.EQ.' ') THEN
         TYPE   = 0
      ELSE IF(DADNAM.EQ.'DUMMY') THEN
                                                                GO TO 40
      ELSE
         TYPE   = 1
      END IF
*-- Check the direction: 'IN' or 'OUT'
      CALL UHTOC(LDADIR,NBYTEW,CFIDIR,4)
      CALL CLEFT(CFIDIR,1,4)
      CALL CLTOU(CFIDIR)
      IF(RABBRE('INPU',CFIDIR,1)) THEN
         LOUTPU = .FALSE.
         LLIO   = LLIODI
         CHIO   = 'IODI'
         CFSTAT = 'OLD'
      ELSE IF(RABBRE('OUTP',CFIDIR,1)) THEN
         LOUTPU = .TRUE.
         LLIO   = LLIOAO
         CHIO   = 'IOAO'
         CFSTAT = 'NEW'
*-- What about the dad title?
         IARROW = INDEX(DADNAM,'->')
         IF(IARROW.EQ.0) THEN
            HEADER = ' '
         ELSE
            HEADER = SPACES(DADNAM(IARROW+2:NAMLEN),1)
            IF(IARROW.EQ.1) THEN
               TYPE   = 0
            ELSE
               DADNAM = DADNAM(1:IARROW-1)
            END IF
         END IF
      ELSE
                                                                GO TO 50
      END IF
*-- Is it a variable name? Allowed on output, but not on input.
      IF(TYPE.EQ.1) THEN
         CALL ROVANA(DADNAM,LVARI)
         IF(LVARI) THEN
            IF(.NOT.LOUTPU)                                    GO TO 110
            FLAGS  = IBSET(FLAGS,VARNAM)
         END IF
      END IF
*-- Now checks the File type: it has to be DATA,DST or DD in input
*-- and blank on output
      CALL UHTOC(LDATYP,NBYTEW,CFITYP,4)
      CALL CLEFT(CFITYP,1,4)
      CALL CLTOU(CFITYP)
      IF(LOUTPU)THEN
         IF(CFITYP.NE.'    ')                                   GO TO 60
      ELSE
         IF(CFITYP.NE.'DD  '.AND.CFITYP.NE.'DDST'.AND.CFITYP.NE.'DATA'
     +                      .AND.CFITYP.NE.'DST ')              GO TO 70
      END IF
*-- Now check the logical unit for the DAD file
      WATFOR = 'DAD '//CFIDIR
      CALL ROGTUN(LDAUN1,WATFOR)
      IF(LDAUN1.EQ.0)                                          GO TO 120
*-- And check the logical unit for the data file
      IF(LOUTPU)THEN
         IF(LDAUN2.NE.0)                                        GO TO 80
      ELSE
         IF(LUDAIN.EQ.0) THEN
            IF(LDAUN2.EQ.0) THEN
               CHREP  = 'Use unit 52 to read DAD accessed '//CFITYP
               LDAUN2 = 52
               CALL REPORT('RIODAD',1,'I')
            END IF
            WATFOR = CFITYP//CFIDIR
            CALL ROGTUN(LDAUN2,WATFOR)
            IF(LDAUN2.EQ.0)                                    GO TO 120
            LUDAIN = LDAUN2
         ELSE
            IF(LDAUN2.EQ.0) THEN
               LDAUN2 = LUDAIN
            ELSE IF(LDAUN2.NE.LUDAIN) THEN
                                                                GO TO 90
            END IF
         END IF
      END IF
*-- What about the Rope processing options?
      IF(LDAOPT.EQ.0) THEN
         CFIDCH = '    '
      ELSE
         CALL UHTOC(LDAOPT,NBYTEW,CFIDCH,4)
      END IF
      CALL CLEFT(CFIDCH,1,4)
      CALL CLTOU(CFIDCH)
      DO 10 I=1,4
      OPT    = CFIDCH(I:I)
      IF(OPT.EQ.' ') THEN
      ELSE IF(OPT.EQ.'O') THEN
         FLAGS  = IBSET(FLAGS,ANYWHE)
      ELSE IF(OPT.EQ.'H') THEN
      ELSE IF(OPT.EQ.'Q') THEN
         FLAGS  = IBSET(FLAGS,CLSQUI)
      ELSE
                                                               GO TO 100
      END IF
   10 CONTINUE
*-- Everything ok, store the file parameters
      LIOHD  = LQ(LUTC-LLIOHD)
      LIOBNK = LQ(LIOHD-LLIO)
      IF(LIOBNK.LT.1) THEN
         CALL MZBOOK(IROCON,LIOBNK,LIOHD,-LLIO,CHIO,
     +               NLIOXX,NSIOXX,NDIOXX,IOIOXX,0)
      ELSE
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIO)
         CALL MZBOOK(IROCON,LIOBNK,LIOBNK,0,CHIO,
     +               NLIOXX,NSIOXX,NDIOXX,IOIOXX,0)
      END IF
      IQ(LIOBNK+JLUN)   = LDAUN1
      IQ(LIOBNK+JLREC)  = 0
      IQ(LIOBNK+JDCHOP) = 1
      IQ(LIOBNK+JACMOD) = 0
      IQ(LIOBNK+JFNTYP) = TYPE
      IQ(LIOBNK+JFLAGS) = FLAGS
      CALL UCTOH(CFSTAT,IQ(LIOBNK+JFSTAT),4,4)
*-- Fill in the DAD header
      CALL UCTOH(HEADER,IQ(LIOBNK+JFKEYS),NBYTEW,40)
*-- Fill in the file name
      CALL UCTOH(DADNAM,IQ(LIOBNK+JFNAME),NBYTEW,NAMLEN)
                                                               GO TO 999
*
   20 CHREP  = 'Not enough parameters on *DADFILE card'
      CALL REPORT('RIODAD',2,'E')
                                                               GO TO 120
   30 CHREP  = 'The CATALOG package can not beinitialised'
      CALL REPORT('RIODAD',3,'E')
                                                               GO TO 120
   40 CHREP  = 'A DAD list can not be dummied'
      CALL REPORT('RIODAD',4,'E')
                                                               GO TO 120
   50 CHREP  = 'The direction has to be "IN" or "OUT"'
      CALL REPORT('RIODAD',5,'E')
                                                               GO TO 120
   60 CHREP  = 'On output, the file type has to be blank'
      CALL REPORT('RIODAD',6,'E')
                                                               GO TO 120
   70 CHREP  = 'In input, the file type has to be DATA, DST, DD or DDST'
      CALL REPORT('RIODAD',7,'E')
                                                               GO TO 120
   80 CHREP  = 'In output, the second logical unit has to be 0'
      CALL REPORT('RIODAD',8,'E')
                                                               GO TO 120
   90 CHREP  = 'Only one logical unit is allowed for data in DAD access'
      CALL REPORT('RIODAD',9,'E')
                                                               GO TO 120
  100 CHREP  = 'Option '//OPT//' is not allowed in a *DADFILE card'
      CALL REPORT('RIODAD',10,'E')
                                                               GO TO 120
  110 CHREP  = 'Variable name other than <NODE> not allowed in input'
      CALL REPORT('RIODAD',11,'E')
  120 FFERRO=.TRUE.
*
  999 RETURN
      END
+DECK,RIOEVL.
      SUBROUTINE RIOEVL
*.
*...RIOEVL Handle *EVTFILE FFREAD cards
*.
*. SEQUENCE: ROBANK CRO RCNTRL RCREP ROWORD
*. CALLS   :
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 24-May-91
*. LAST MOD: 30-Sep-92
*.
*.   DETAILED DESCRIPTION:
*.
*.  Interpret the *EVTFILE card. The format is:
*.  *EVTFILE  'direction' unit1 unit2 unit3 'rchopt' 'name'
*.
*.  'direction'  'in' (could be 'new'='out' later ... )
*.   unit1     logical unit to read                       t
*.   unit2     logical unit to read the nanodst (no longer used)
*.   unit3     logical unit to read the data-file
*.   rchopt    rope processing option
*.   name      nano-dst name (wild-carding/catalog entries accepted)
*.             if name='ffread' or 'input' the event list can be found
*.             after the FFREAD cards, in the input stream.
*. Modification Log.
*. 30-Sep-92  O.Schaile   Access catalog dbs, if not provided
*. 21-Sep-92  O.Schaile   Dont need Masternano anymore, remove check
*.  6-Sep-91  S.Weisz     Slight alteration.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER       TYPE,FLAGS,IARROW,I,LIOHD,LIOBNK,LZLAST
      CHARACTER*1   OPT
      CHARACTER*4   CEVDIR,CEVDCH
      CHARACTER*6   CHTEST
      CHARACTER*8   WATFOR
      CHARACTER*40  HEADER
      CHARACTER*80  EVTLNA,SPACES
      LOGICAL       RABBRE,LVARI
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
+SEQ,ROWORD.
+SEQ,RBITFUNC.
+SEQ,RCREP.
+SEQ,RCLINE.
*-- Check that we have the vital minimum number of parameters
      IF(LEVDIR.EQ.0)                                           GO TO 20
*-- Set the default flag
      FLAGS  = IBSET(0,EVTLIS)
*-- Check the direction: 'IN' or 'OUTP'='NEW'
      CALL UHTOC(LEVDIR,NBYTEW,CEVDIR,4)
      CALL CLEFT(CEVDIR,1,4)
      CALL CLTOU(CEVDIR)
      IF(RABBRE('INPU',CEVDIR,1)) THEN
*         IF(.NOT.LMSOPE) THEN
*            CHREP = 'No *MASTERNA card provided, try with all NANO'
*            CALL REPORT('RIOEVL',1,'I')
*            CALL UCTOH('INPU',LMNDIR,4,4)
*            LMNUNI = 0
*            CALL UCTOH('    ',LMNOPT,4,4)
*            CALL UCTOH('//NANO',LMNNAM,NBYTEW,NAMLEN)
*            CALL RIOMAS
*         END IF
      ELSE IF(RABBRE('OUTP',CEVDIR,1).OR.RABBRE('NEW',CEVDIR,1)) THEN
         CHREP = 'Output of Event list is not yet implemented'
         CALL REPORT('RIOEVL',2,'E')
                                                               GO TO 990
      ELSE
                                                                GO TO 30
      END IF
*-- Check if a file name was given
      TYPE   = 1
      CALL UHTOC(LEVNAM,NBYTEW,EVTLNA,NAMLEN)
      EVTLNA = SPACES(EVTLNA,1)
      CHTEST = EVTLNA(1:6)
      CALL CLTOU(CHTEST)
      IF(EVTLNA.EQ.' ') THEN
         TYPE   = 0
      ELSE IF(CHTEST.EQ.'DUMMY ') THEN
                                                                GO TO 40
      ELSE IF(CHTEST.EQ.'FFREAD'.OR.CHTEST.EQ.'INPUT ') THEN
         LEVUN1 = LRIN
         FLAGS  = IBSET(FLAGS,NOOPEN)
      END IF
      IF(LEVUN1.EQ.0)                                           GO TO 20
*-- What about the event list title?
      IARROW = INDEX(EVTLNA,'->')
      IF(IARROW.EQ.0) THEN
         HEADER = ' '
      ELSE
         HEADER = SPACES(EVTLNA(IARROW+2:NAMLEN),1)
         IF(IARROW.EQ.1) THEN
            TYPE   = 0
         ELSE
            EVTLNA = EVTLNA(1:IARROW-1)
         END IF
      END IF
*-- Is it a variable name? Not allowed.
      IF(TYPE.EQ.1) THEN
         CALL ROVANA(EVTLNA,LVARI)
         IF(LVARI)                                              GO TO 50
      END IF
*-- Now check the logical units given as parameter
      WATFOR = 'EVTL'//CEVDIR
      CALL ROGTUN(LEVUN1,WATFOR)
      IF(LEVUN1.EQ.0)                                          GO TO 990
*-- Check the logical unit for the intermediate nanodst
*     IF(LUEVIN.EQ.0) THEN
*        IF(LEVUN2.EQ.0) THEN
*           CHREP  = 'Use unit 53 to read the intermediate nanodst'
*           LEVUN2 = 53
*           CALL REPORT('RIOEVL',3,'I')
*        END IF
*        WATFOR = 'NANO'//CEVDIR
*        CALL ROGTUN(LEVUN2,WATFOR)
*        IF(LEVUN2.EQ.0)                                       GO TO 990
*        LUEVIN = LEVUN2
*     ELSE
*        IF(LEVUN2.EQ.0) THEN
*           LEVUN2 = LUEVIN
*        ELSE IF(LEVUN2.NE.LUEVIN) THEN
*                                                               GO TO 60
*        END IF
*     END IF
*-- And check the logical unit for the data file
      IF(LUNAIN.EQ.0) THEN
         IF(LEVUN3.EQ.0) THEN
            CHREP  = 'Use unit 52 to read the data file'
            LEVUN3 = 52
            CALL REPORT('RIOEVL',4,'I')
         END IF
         WATFOR = 'DATA'//CEVDIR
         CALL ROGTUN(LEVUN3,WATFOR)
         IF(LEVUN3.EQ.0)                                       GO TO 990
         LUNAIN = LEVUN3
      ELSE
         IF(LEVUN3.EQ.0) THEN
            LEVUN3 = LUNAIN
         ELSE IF(LEVUN3.NE.LUNAIN) THEN
                                                                GO TO 60
         END IF
      END IF
*-- What about the Rope processing options?
      CALL UHTOC(LEVOPT,4,CEVDCH,4)
      CALL CLEFT(CEVDCH,1,4)
      CALL CLTOU(CEVDCH)
      DO 10 I=1,4
         OPT    = CEVDCH(I:I)
         IF(OPT.EQ.' ') THEN
         ELSE IF(OPT.EQ.'Q') THEN
            FLAGS = IBSET(FLAGS,CLSQUI)
         ELSE
                                                                GO TO 70
         END IF
   10 CONTINUE
*-- So far so good, book and fill a bank for this Event File.
      LIOHD  = LQ(LUTC-LLIOHD)
      LIOBNK = LQ(LIOHD-LLIODI)
      IF(LIOBNK.LT.1) THEN
         CALL MZBOOK(IROCON,LIOBNK,LIOHD,-LLIODI,'IODI',
     +               NLIOXX,NSIOXX,NDIOXX,IOIOXX,0)
      ELSE
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIODI)
         CALL MZBOOK(IROCON,LIOBNK,LIOBNK,0,'IODI',
     +               NLIOXX,NSIOXX,NDIOXX,IOIOXX,0)
      END IF
      IQ(LIOBNK+JLUN)   = LEVUN1
      IQ(LIOBNK+JLREC)  = NUHMAX
      IQ(LIOBNK+JDCHOP) = 1
      IQ(LIOBNK+JACMOD) = 0
      IQ(LIOBNK+JFNTYP) = TYPE
      IQ(LIOBNK+JFLAGS) = FLAGS
      CALL UCTOH('OLD ',IQ(LIOBNK+JFSTAT),4,4)
      CALL UCTOH(EVTLNA,IQ(LIOBNK+JFNAME),NBYTEW,NAMLEN)
      CALL UCTOH(HEADER,IQ(LIOBNK+JFKEYS),NBYTEW,40)
                                                               GO TO 999
*--   Error Processing...
   20 CHREP = 'Not enough parameters on *EVTFILE card'
      CALL REPORT('RIOEVL',5,'E')
                                                               GO TO 990
*
   30 CHREP = 'Wrong "direction" parameter: '//CEVDIR
      CALL REPORT('RIOEVL',6,'E')
                                                               GO TO 990
*
   40 CHREP = 'An event list can not be dummied'
      CALL REPORT('RIOEVL',7,'E')
                                                               GO TO 990
*
   50 CHREP = 'Variable name not allowed for event lists'
      CALL REPORT('RIOEVL',8,'E')
                                                               GO TO 990
*
*   60 CHREP = 'Only one logical unit allowed for data or nanodst'
   60 CHREP = 'Only one logical unit allowed for data'
      CALL REPORT('RIOEVL',9,'E')
                                                               GO TO 990
*
   70 CHREP = 'Unknown option:'//OPT
      CALL REPORT('RIOEVL',10,'E')
*
990   FFERRO = .TRUE.
999   RETURN
*
      END
+DECK,RIOFAT.
      SUBROUTINE RIOFAT
*.
*...RIOFAT Handle *FATFILE FFREAD cards
*.
*. SEQUENCE: ROBANK CRO RCNTRL FMPAR RCREP ROWORD
*. CALLS   : RFMINI RWORDS RSBWRD FMEXST FMLFIL FMSELK LENOCC SPACES
*.           MZWORK
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD  : 24-Aug-99
*.
*. Modification Log.
*.  24-Aug-99 E.Barberio  change media preferences for fatmen
*. 19-Jun-96 S.O'Neale  allow fatmen access to SD-tapes 
*.                      (sacrifice EXABYTE and DAT90 for now)
*. 19-Jun-96 S.O'Neale  allow fatmen access to NTP and DAT90
*. 29-Mar-96 O.Schaile  force direction IN if not OUT explicitely
*.  6-Jun-95 G.Duckeck  Allow DLTs on shift
*.  26-Oct-94 O.Schaile Avoid useless calls to FMEXST
*. 22-Sep-94 M.Redmond  Add access to Shift-only cartridges
*.  1-Jun-94 M.Redmond  Ignore 'R' and 'V' options
*. 15-Nov-93 O.Schaile   Ignore option 'P' on non IBM.
*.  1-Sep-93 O.Schaile  Add medium type 6 in wildcard search
*. 22-Jul-93 O.Schaile  medium type 6 = HD for IBM
*.  1-Jun-92 O.Schaile  Ignore options P and S for shift
*.  6-May-92 O.Schaile  allow 2200 files in Fatmen (MAXLIN=2200)
*. 23-Mar-92 O.Schaile  allow for pathname only (add /*),
*.                      remove message "Skip duplicate volume..."
*. 25-Feb-92 O.Schaile  replace FMLIST by FMLFIL, use FMEXST
*. 21-Feb-92 O.Schaile  correct bug in printout for duplicate s
*. 18-Feb-92 O.Schaile  call FMQTMS only if needed and for tapes
*.                      mod printout for duplicate volumes
*.  4-Feb-92 O.Schaile  allow tape stage on shift without R/V option
*.   910923  S.Weisz Reset top directory to //CERN before FATMEN
*.  3-Sep-91 S.Weisz    Refine this IBM cartridge reading from SGI
*. 15-Aug-91 D.Lellouch Allow to read IBM cartridge from SGI
*. 29-Jun-91 D.Lellouch Allow wild carding at the lowest directory level
*. 27-Jun-91 D.Lellouch Add the 'L' option to ignore label processing
*.  3-Apr-91 S.Weisz    Handle full generic name too.
*. 20-Mar-91 S.Weisz    'V' option for vault.
*. 28-Feb-91 S.Weisz    Try to initialise FATMEN if not done.
*. 11-Feb-91 S.Weisz    Select ROBOT/MANUAL cartridges.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER            MVIDFA,LPREF,MAXLIN
      PARAMETER         (MVIDFA=79,LPREF=12,MAXLIN=2200)
      INTEGER            I1,I2,I,J,K,L,LF,IFIRST,ILAST,IZERO,
     +                   LBANK,KEYS,NFOUND,RC,
     +                   INDICE,ACTUAL,INSIDE, INKEYS(10), JCONT
      INTEGER            LENOCC,INDEXB
      INTEGER ISCAN
      CHARACTER*1        OPT,MNTTYP
      CHARACTER*2        CASTER
      CHARACTER*4        CFADIR,CFAFCH,CFADCH,LABTYP
      CHARACTER*6        VID,DENS
      CHARACTER*8        LIB,MODEL
      CHARACTER*80       SEARCH,CFNAME,SPACES,CFNAM2,CHPREV
      CHARACTER*(LPREF)  PREFIX
      LOGICAL            LVARI,LFPHN,LROBOT,LVAULT
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,FMPAR.
+SEQ,RCREP.
+SEQ,RCLINE.
+SEQ,ROWORD.
*
      CHARACTER*(NAMLEN) LINES(MAXLIN)
      DIMENSION          INDICE(MAXLIN),KEYS(KEYLEN,MAXLIN)
      EQUIVALENCE       (INDICE,WS),(KEYS,WS(MAXLIN+1)),
     +                  (LINES,WS(1+(KEYLEN+1)*MAXLIN))
      SAVE               PREFIX, INKEYS
      DATA               PREFIX/'//CERN/OPAL/'/
      DATA               INKEYS/10*-1/
*-- Raise the *FATFILE flag
      FATFIL = .TRUE.
      IF(.NOT.FATMEN) THEN
         CHREP  = 'FATMEN package is not initialised, do it on unit 50'
         CALL REPORT('RIOFAT',1,'I')
         LFATLU = 50
         CALL RFMINI
         IF(.NOT.FATMEN)                                       GO TO 999
      END IF
*-- First try to understand the FATMEN generic name.
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LFANAM,NBYTEW,CFNAME,NAMLEN)
      IF(LFATYP.EQ.0.OR.LFADIR.EQ.0.OR.LFAUNI.EQ.0
     +                             .OR.CFNAME.EQ.' ') THEN
         CHREP  = 'Not enough parameters on *FATFILE card'
         CALL REPORT('RIOFAT',2,'E')
                                                                GO TO 30
      END IF
*-- What about special characters?
      CALL CLTOU(CFNAME)
      CALL ROVANA(CFNAME,LVARI)
      IF(LVARI) THEN
         CHREP  = 'Variable names not allowed in FATMEN'
         CALL REPORT('RIOFAT',3,'E')
                                                                GO TO 30
      END IF
*-- Ignore any blank and add //CERN/OPAL/ if necessary
      CFNAM2 = SPACES(CFNAME,0)
      IF(CFNAM2(1:LPREF).EQ.PREFIX) THEN
         CFNAME = CFNAM2
      ELSE IF(CFNAM2(1:1).EQ.PREFIX(LPREF:LPREF)) THEN
         CFNAME = PREFIX(1:LPREF-1)//CFNAM2
      ELSE
         CFNAME = PREFIX//CFNAM2
      END IF
*-- Check if the path ends with a '[....:....]' pattern
      I1     = INDEX(CFNAME,'[')
      I2     = LENOCC(CFNAME)
      IF(I1.EQ.0) THEN
         SEARCH = CFNAME
         IFIRST = 1
         ILAST  = 99999
      ELSE IF(CFNAME(I2:I2).EQ.']') THEN
         CALL ROFIRL(CFNAME(I1+1:I2-1),IFIRST,ILAST,RC)
         IF(RC.EQ.0) THEN
            SEARCH = CFNAME(1:I1-1)
         ELSE
            CHREP  = 'Invalid [...] specification'
            CALL REPORT('RIOFAT',4,'E')
                                                                GO TO 30
         END IF
      ELSE
         CHREP  = 'Unbalanced "["'
         CALL REPORT('RIOFAT',5,'E')
                                                                GO TO 30
      END IF
*-- Now decode the DIRection field.
      CALL UHTOC(LFADIR,4,CFADIR,4)
      CALL CLTOU(CFADIR)
      IF(INDEX(CFADIR,'OUT').LE.0) THEN
         CFAFCH = 'R'
      ELSE
         CFAFCH = 'W'
      END IF
      LF     = 1
*-- Then decode the FATMEN option, it depend on the system.
      IF(LFADCH.EQ.0) THEN
         CFADCH = '    '
      ELSE
         CALL UHTOC(LFADCH,4,CFADCH,4)
      END IF
+SELF,IF=SHIFT.
      IF(INDEX(CFADCH,'P').EQ.0 .AND. INDEX(CFADCH,'s').EQ.0)THEN
         I=MAX(LENOCC(CFADCH),1)
         IF(I.LT.4)CFADCH(I+1:I+1)='P'
         CALL UCTOH(CFADCH,LFADCH,4,4)
      ENDIF
+SELF.
      CALL CLTOU(CFADCH)
*-- Do not read from ROBOT as default.
      LROBOT = .FALSE.
      LVAULT = .FALSE.
      DO 10 I=1,4
      OPT    = CFADCH(I:I)
      CALL CLTOU(OPT)
      IF(OPT.EQ.' ') THEN
      ELSE IF(LFADCH.EQ.0) THEN
      ELSE IF(OPT.EQ.'R') THEN
      ELSE IF(OPT.EQ.'V') THEN
+SELF,IF=IBM.
      ELSE IF(OPT.EQ.'M') THEN
         LF     = LF + 1
         CFAFCH(LF:LF) = 'T'
+SELF.
      ELSE IF(OPT.EQ.'P') THEN
+SELF,IF=-SHIFT,IF=-IBM.
         CFADCH(I:I)=' '
         CALL UCTOH(CFADCH,LFADCH,4,4)
+SELF.
      ELSE IF(OPT.EQ.'S') THEN
      ELSE IF(OPT.EQ.'Q') THEN
         LF     = LF + 1
         CFAFCH(LF:LF) = 'Q'
      ELSE IF(OPT.EQ.'L') THEN
         LF     = LF + 1
         CFAFCH(LF:LF) = 'N'
      ELSE IF(OPT.EQ.'=') THEN
      ELSE IF(OPT.EQ.'1') THEN
      ELSE IF(OPT.EQ.'C') THEN
      ELSE IF(OPT.EQ.'D') THEN
      ELSE IF(OPT.EQ.'E') THEN
      ELSE IF(OPT.EQ.'U') THEN
      ELSE
         CHREP  = 'Invalid file-dependent option:'//CFADCH
         CALL REPORT('RIOFAT',8,'E')
                                                                GO TO 30
      END IF
   10 CONTINUE
*-- Make space to receive all file keys and names
      CALL MZWORK(IXSTOR,WS(1),WS((1+KEYLEN+NAMLWO)*MAXLIN),0)
      L      = LENOCC(SEARCH)
      NFOUND = 0
      LFPHN  = .FALSE.
      JCONT = 0
      CALL RZCDIR('//CERN',' ')
*
*      CALL FMLOGL(3)

*     full path name given?
      IF(ISCAN(SEARCH(1:L),'*%<>()').EQ.0)THEN
         CALL FMEXST(SEARCH(1:L),RC)
         IF (RC.GT.0) ILAST=1
      ELSE
         RC=-1
      ENDIF
*      CALL FMLIST(SEARCH(1:L),LINES,KEYS,NFOUND,MAXLIN,RC)
      IF(RC.GT.0)THEN
*        yes, get the keys
         LFPHN  = .TRUE.
         CALL FMSELK(SEARCH(1:L),INKEYS,KEYS,NFOUND,MAXLIN,RC)
         IF(RC.NE.0)THEN
            CHREP  = 'Error from FMSELK for: '//SEARCH(1:L)
            CALL REPORT('RIOFAT',9,'E')
                                                                GO TO 30
         ENDIF
      ELSE
*--      no do wild card search
         CASTER='  '
15       CALL FMLFIL(SEARCH(1:L)//CASTER,LINES,KEYS,
     +               NFOUND,MAXLIN,JCONT,RC)
         IF(RC.NE.0) THEN
            IF(RC.EQ.-1)THEN
               CHREP  = 'Too many files, some might have been lost'
               CALL REPORT('RIOFAT',10,'E')
            ELSE
               CHREP  = 'Error from FMLFIL'
               CALL REPORT('RIOFAT',11,'E')
                                                                GO TO 30
            ENDIF
         END IF
         IF(NFOUND.EQ.0) THEN
*           only directory given? Add wild card and try again
            IF(CASTER.EQ.'  ')THEN
               CASTER='/*'
               IF(SEARCH(L:L).EQ.'/')L=L-1
                                                                GO TO 15
            ELSE
               CHREP  = 'No entry satisfies the search : '//SEARCH(1:L)
               CALL REPORT('RIOFAT',12,'E')
                                                                GO TO 30
            ENDIF
         END IF
*-- Sort the files in alphabetic ascending order
         CALL FMSORT(LINES,KEYS,NFOUND,INDICE,RC)
         IF(RC.NE.0) THEN
            CHREP  = 'Internal FATMEN error while sorting the files'
            CALL REPORT('RIOFAT',13,'E')
         END IF
      END IF
*-- Loop on all files, checking they correspond to the proper
*-- location code,occurence criterion and device type
      CHPREV = '???'
      ACTUAL = 0
      INSIDE = 0
      DO 20 J=1,NFOUND
*     if full name was given, no sort was done (not needed)
      IF(LFPHN)THEN
         I      = J
      ELSE
         I      = INDICE(J)
         L      = LENOCC(LINES(I))
      ENDIF
      VID=' '
+SELF,IF=-SHIFT.
*     if it is not SHIFT, location code must point to current machine
      IF(KEYS(MKLCFA,I).NE.FMLOCA)                              GO TO 20
+SELF.
*--   Keep/skip ROBOT cartridges on request.
      IF(LROBOT.OR.LVAULT) THEN
+SELF,IF=SHIFT.
*-- for SHIFT tape must be at IBM in IEEE
*        is location=1 (i.e. IBM)
* I suggest removing all of this moronic ROBOT/VAULT code
* For a time, the 3495 Robot was only accessible to shift
         IF(KEYS(MKLCFA,I).NE.1 .AND. KEYS(MKLCFA,I).NE.31) GO TO 20
         IF(KEYS(MKCLFA,I).NE.1)                                GO TO 20
+SELF.
*        is it a cartridge or tape or DLT ?
         IF(KEYS(MKMTFA,I).NE.2 .AND. KEYS(MKMTFA,I).NE.18
     +   .AND. KEYS(MKMTFA,I).NE.14
     +   .AND. KEYS(MKMTFA,I).NE.6 .AND. KEYS(MKMTFA,I).NE.12)  GO TO 20
*        where is it, need VID, so get bank?
         IF(LFPHN)THEN
            CALL FMGETK(SEARCH(1:L),LBANK,KEYS(1,I),RC)
         ELSE
            CALL FMGETK(LINES(I)(1:L),LBANK,KEYS(1,I),RC)
         ENDIF
         CALL FMGETC(LBANK,VID  ,MVIDFA,6,RC)
         CALL FMQTMS(VID,LIB,MODEL,DENS,MNTTYP,LABTYP,RC)
         IF(LROBOT) THEN
            IF(MNTTYP.NE.'R')                                   GO TO 20
         ELSE
            IF(MNTTYP.EQ.'R')                                   GO TO 20
         END IF
+SELF,IF=SHIFT.
      ELSE
*--      on SHIFT make sure any valid data source is there:
*--      local disc?
         IF      (KEYS(MKLCFA,I).EQ.FMLOCA
     +      .AND. KEYS(MKMTFA,I).EQ.1 )    THEN
*--      is it tape or cartridge in IEEE format on IBM?
         ELSE IF (KEYS(MKLCFA,I).EQ.1
     +      .AND.
     +      (KEYS(MKMTFA,I).EQ.2 .OR.
     +       KEYS(MKMTFA,I).EQ.6 .OR.
     +       KEYS(MKMTFA,I).EQ.14 .OR.
     +       KEYS(MKMTFA,I).EQ.15 .OR.
     +       KEYS(MKMTFA,I).EQ.16 .OR.
     +       KEYS(MKMTFA,I).EQ.17 .OR.
     +       KEYS(MKMTFA,I).EQ.18 .OR.
     +       KEYS(MKMTFA,I).EQ.12)
     +      .AND. KEYS(MKCLFA,I).EQ.1)     THEN
         ELSE IF (KEYS(MKLCFA,I).EQ.31
     +      .AND.
     +      (KEYS(MKMTFA,I).EQ.2 .OR.
     +       KEYS(MKMTFA,I).EQ.6 .OR.
     +       KEYS(MKMTFA,I).EQ.14 .OR.
     +       KEYS(MKMTFA,I).EQ.15 .OR.
     +       KEYS(MKMTFA,I).EQ.16 .OR.
     +       KEYS(MKMTFA,I).EQ.17 .OR.
     +       KEYS(MKMTFA,I).EQ.18 .OR.
     +       KEYS(MKMTFA,I).EQ.12)
     +      .AND. KEYS(MKCLFA,I).EQ.1)     THEN
         ELSE
                                                                GO TO 20
         ENDIF
+SELF
      END IF
*-- Duplicate copies at this level are problematic, skip them
      IF(CHPREV.EQ.LINES(I)) THEN
*         WRITE(CHLINE,1000) LINES(I)(1:L),VID
*         CALL RMAIL(0,0)
                                                                GO TO 20
      END IF
      CHPREV = LINES(I)
*-- Test the occurence specification
      ACTUAL = 1 + ACTUAL
      IF(ACTUAL.GE.IFIRST.AND.ACTUAL.LE.ILAST) THEN
         INSIDE = 1 + INSIDE
         LFITYP = LFATYP
         LFIDIR = LFADIR
         LFIUNI = LFAUNI
         LFILRE = 0
         CALL UCTOH(CFAFCH,LFIFCH,4,4)
         LFIDCH = LFADCH
         IF(LFPHN)THEN
            CALL UCTOH(SEARCH,LFINAM,NBYTEW,NAMLEN)
            WRITE(CHLINE,1010) INSIDE,SEARCH(1:L),VID
            CALL RMAIL(0,0)
         ELSE
            CALL UCTOH(LINES(I),LFINAM,NBYTEW,NAMLEN)
            WRITE(CHLINE,1010) INSIDE,LINES(I)(1:L),VID
            CALL RMAIL(0,0)
         ENDIF
         CALL UCOPY(KEYS(1,I),SELKEY,10)
         CALL RIOFIL
      END IF
20    CONTINUE
      IF(ACTUAL.EQ.0) THEN
         CHREP  = 'No entry found at the proper location '
         CALL REPORT('RIOFAT',14,'E')
                                                                GO TO 30
      ELSE IF(INSIDE.EQ.0) THEN
         CHREP  = 'No entry satisfies your occurence number selection'
         CALL REPORT('RIOFAT',15,'E')
                                                                GO TO 30
      END IF
                                                               GO TO 999
   30 FFERRO = .TRUE.
*
  999 CALL VZERO(LFITYP,NPAFIL)
      CALL VBLANK(LFINAM,NAMLWO)
      CALL VZERO(LFATYP,NPAFAT)
      CALL VBLANK(LFANAM,NAMLWO)
*
      RETURN
* 1000 FORMAT(5X,'Skip duplicate volume for ',A,'  ',A)
 1010 FORMAT(25X,I5,' --> ',A,'  ',A)
      END
+DECK,RIOFIL.
      SUBROUTINE RIOFIL
*.
*...RIOFIL   Set up banks for various INPUT and OUTPUT files.
*.
*. SEQUENCES : ROBANK RCNTRL ROUNIT RCSYST ROWORD ROCPAR FMPAR RCREP
*.             ROCEXP
*. CALLS     : REPORT UHTOC  MZBOOK LZLAST RWORDS LENOCC RTRANS SPACES
*. CALLS     : RADDOP RABBRE ROGTUN RGETDV
*. CALLED    : RFUSER RIOCAT RIOFAT RMULFI
*.
*. BANK U    : IOHD
*. BANK L    : IOII IOCI IODI IODO IODC IOOV IODS IOCA IOME IOBK IOHB
*.             IODP IODG
*.
*. AUTHOR    : A.Buijs,S.Weisz
*. VERSION   : 1.03
*. CREATED   :  5-Apr-1988
*. LAST MOD  : 15-May-1998
*.
*.   DETAILED DESCRIPTION:
*.  Interpret the FFREAD card. The format is:
*.  *FILE 'stream' 'direction' unit lrec 'fchopt' 'dchopt' 'name'
*.   type      = INIT,CONS,DATA,PROD,DST,COPY,OVER,CAL,HIST,META,BANK
*.   direction = IN,OUT (and UPD for HISTO)
*.   unit      = Logical input unit
*.   lrec      = Record length
*.   fchopt    = FZIN option for stream = INIT,CONS,DATA,DST,COPY,OVER
*.   dchopt    = FZOUT option for output stream DATA,DST,COPY,OVER
*.             = No tape on unit for input stream DATA,DST
*.             = Database identifier for stream CAL
*.   name      = File name
*.
*.   If 'name' is given and the file is not a calibration file, dchopt
*.   options may be:
*.     'M'  : the file is a cartridge to be Mounted
*.     'S'  : the file is a cartridge to be Staged
*.     'P'  : stage tape n and Pre-tage tape n+1 while processing tape n
*.     'R'  : FATMEN usage: take cartridges on the Robot.
*.     'D'  : Draw the metafile
*.     'A'  : Autoput output staged tapes (IBM only)
*.     'E'  : the file is an Exabyte cartridge
*.     'U'  : it is an Unstructured Exabite cartridge
*.     'H'  : read header only
*.     'O'  : farm Vaxstation: process files sitting on Other stations
*.     'N'  : on a vax, next file sits on a New foreign tape
*.     '='  : One new output file each time EOF found on input
*.     '1'  : One event per output stram
*.     'F'  : Flush to user RDR and Erase the lastly closed output file
*.     'C'  : do not write Constants records on output streams
*.     'Q'  : Close file quietly
*.     'X'  : Use explicit file names on Vaxes
*.     'V'  : FATMEN usage: take cartridges in Vault.
*.     'L'  : Fatmen usage: ignore the label processing
*.
*. Modification log:
*. 15-May-98 N.K.Watson  Fixes for exp.10 database.
*. 21-Mar-96 O.Schaile   Recognize PU9999.1-5 for SHIFT
*. 02-Feb-94 D.Lellouch  Simplify a lot the compress data stuff.
*.                       Move the flag steering  to the DC package
*. 15-Nov-93 O.Schaile   Ignore option 'P' on non IBM.
*.  8-Sep-93 D.Lellouch  Add stuff for CSDS compression:
*.                       DST is compressed, DD is left intact
*.                       *FILE 'CSDS' 'OUTP/INPU'
*. 18-Jun-92 D.Lellouch  Add stuff for data compression:
*.                       *FILE 'DICT' 'INPU'  load dictionary(ies)
*.                       *FILE 'CDST' 'OUTP/INPU'
*.                       *FILE 'CDD ' 'OUTP/INPU'
*.                       *FILE 'CDDI' 'OUTP/INPU'
*.                       *FILE 'CDDO' 'OUTP/INPU'
*. 07-Feb-92 N.K.Watson Avoid name conflict (INDEXN), allow>1 main db.
*. 18-Nov-01 D.Lellouch Bug fix for multiple file staging.
*. 12-Sep-91 S.Weisz    Need to add Y option in exchange mode on IBM
*. 27-Aug-91 S.Weisz    Use RBITFUNC sequence
*. 27-Jun-91 D.Lellouch Add the 'L' option to ignore label processing
*.                      (in Fatmen access only)
*. 25-May-91 D.Lellouch 'H' has a new meaning
*. 02-May-91 D.Lellouch Add the file index to the bank
*. 24-Apr-91 S.Weisz    Fix bug for named HIST files.
*.  5-Apr-91 S.Weisz    Handle CIO if 'L' ZEBRA option choosen.
*.  2-Apr-91 B.Lorazo   Exatapes: handles 'EU' option.
*. 23-Mar-91 S.Weisz    OPCAL: Forbids 'D' option, handle 'N'.
*. 14-Mar-91 D.Lellouch DADLIST now handled in routine RIODAD
*.  6-Mar-91 S.Weisz    BANK type files where forgotten!
*.  5-Mar-91 T.Mouthuy  Apollo, SGI implementation
*. 28-Fev-91 S.Weisz    Try to get a Plotter if not done with *GETDVICE
*. 18-Fev-91 S.Weisz    Slight alteration, further checks,
*.                      temporary comment of AUTOUNIT.
*.                      Default size of RZ histo file to 65000 rec.
*. 10-Jan-91 D.Lellouch Introduce logical output streams (OUT1..OUT9)
*.  8-Jan-91 D.Lellouch Handle automatic logical unit allocation
*. 18-Nov-90 D.Lellouch File name can be either passed directly
*.                      or be referenced inside a catalog entry
*.                      or come from a FATMEN definition.
*.                      It can refer to a stage/mount volume
*.                      In all above case, the 'DCHOPT' option
*.                      has a different meaning
*.                      Perform a lot of extra checks.
*.                      Data base options rewritten
*.                      Warn the user if the unit is already used
*. 23-Oct-90 S.Weisz    Add 'DDST' input/output stream.
*. 23-Mar-90 RWL Jones  Make the D option  the default for databases.
*.  4-Feb-90 RWL Jones  Change the default LRECL for databases.
*.  7-Sep-89 S.Weisz    Add 'SCAN' input/output stream.
*.  7-Sep-89 RWLJ       Check for blanks
*. 12-Jun-89 S.Weisz    Add 'PROD' input/output stream.
*. 24-Fev-89 S.Weisz    Bug in handling of 'CAL ' 'OUT ' found by M.R.
*. 22-Fev-89 S.Weisz    Change default for new calibration files
*. 17-Fev-89 S.Weisz    Handle flag ICMAIN
*.  7-Fev-89 S.Weisz    Calibration file reading/writing/updating
*.  1-Jan-89 S.Weisz    Set proper default values
*. 20-Dec-88 S.Weisz    Handle Metafile, Bank doc., Histo files too
*.  7-Sep-88 S.Weisz    Reset LIOKEY  to default options
*. 27-Jun-88 S.Weisz    Handle Calibration file too
*.
***********************************************************************
+SEQ,DECLARE.
      INTEGER            IHBLA,I,W,LIOHD,LIOBNK,LLIO,LZLAST
      INTEGER            RWORDS,INDEX,INDXU,INDXS,INDXN,INDXD
      INTEGER            TYPE,ACMODE,FLAGS,LFIDCX
CCCCCC Temporary comment of AUTOUNIT
CCC  +                  ,ISTREA,IC,ICHAR
      CHARACTER*1        OPT
      CHARACTER*4        CFITYP,CFIDIR,CFIFCH,CFIDCX,CHIO,CFSTAT
      CHARACTER*8        WATFOR
      CHARACTER*80       CFNAME,SFNAME,SPACES
      CHARACTER*80 ORGNAM
      LOGICAL            LOUTPU,LFZ,LCAL,LNAME,LVARI
CCC  +                  ,LSTREA
      LOGICAL            LEXCH,LNATIV,LALPHA,LCIO
     +                  ,PACKIT
      LOGICAL            RABBRE
      EXTERNAL           RABBRE
*- NKW mods start.
      EXTERNAL           INDEXN
      INTEGER            INDEXN, IMISC
*- NKW mods end.
      INTEGER MULSTG, MINSTG, MAXSTG, IPDOT, IPMIN,
     +        LNBLNK, ICDECI
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,ROWORD.
+SEQ,ROCPAR.
+SEQ,FMPAR.
+SEQ,CRVER.
+SEQ,RBITFUNC.
+SEQ,ROCEXP.    << Added NKW >>
+SEQ,RCREP.
*-- Set defaults.
      CALL VBLANK(IHBLA,1)
      FLAGS  = 0
      LFIDCX = LFIDCH
      LFZ    = .FALSE.
CCC   LSTREA = .FALSE.
*-- Decode the parameters. For mixed FFREAD cards, the default is 0.
      IF(LFITYP.EQ.0)                                           GO TO 20
      IF(LFIDIR.EQ.0)                                           GO TO 20
      IF(LFIUNI.EQ.0)                                           GO TO 20
*-- Check whether a file name was given
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LFINAM,NBYTEW,CFNAME,NAMLEN)
      CFNAME = SPACES(CFNAME,1)
+SELF,IF=IBM.
      ORGNAM = CFNAME
      CALL RTRANS(CFNAME,'.',' ')
+SELF.
      LNAME  = CFNAME.NE.' '
*-- Check the file type option
      CALL UHTOC(LFITYP,4,CFITYP,4)
      CALL CLEFT(CFITYP,1,4)
      CALL CLTOU(CFITYP)
      PACKIT=.FALSE.
      IF(RABBRE('INIT',CFITYP,3)) THEN
         CFITYP = 'INIT'
      ELSE IF(RABBRE('CALI',CFITYP,3)) THEN
         CFITYP = 'CALI'
      ELSE IF(RABBRE('DATA',CFITYP,3)) THEN
         CFITYP = 'DATA'
CCC      LSTREA = .TRUE.
      ELSE IF(RABBRE('DDST',CFITYP,2)) THEN
         CFITYP = 'DDST'
CCC      LSTREA = .TRUE.
      ELSE IF(RABBRE('DST',CFITYP,3)) THEN
         CFITYP = 'DST'
CCC      LSTREA = .TRUE.
      ELSE IF(RABBRE('PROD',CFITYP,3)) THEN
         CFITYP = 'PROD'
CCC      LSTREA = .TRUE.
      ELSE IF(RABBRE('SCAN',CFITYP,3)) THEN
         CFITYP = 'SCAN'
CCC      LSTREA = .TRUE.
      ELSE IF(RABBRE('OVER',CFITYP,3)) THEN
         CFITYP = 'OVER'
      ELSE IF(RABBRE('CNST',CFITYP,3).OR.
     +        RABBRE('CONS',CFITYP,3).OR.
     +        RABBRE('CST' ,CFITYP,3)) THEN
         CFITYP = 'CONS'
      ELSE IF(RABBRE('HIST',CFITYP,3)) THEN
         CFITYP = 'HIST'
      ELSE IF(RABBRE('BANK',CFITYP,3)) THEN
         CFITYP = 'BANK'
      ELSE IF(RABBRE('META',CFITYP,3)) THEN
         CFITYP = 'META'
      ELSE IF(RABBRE('DICT',CFITYP,3)) THEN
         CFITYP='DICT'
         PACKIT=.TRUE.
      ELSE IF(RABBRE('CDST',CFITYP,3)
     +    .OR.RABBRE('CSDS',CFITYP,3)) THEN
         CFITYP='CDST'
         PACKIT=.TRUE.
      ELSE
                                                                GO TO 30
      END IF
      IF(PACKIT.AND.IVDC.EQ.0) THEN
         CHREP='This can''t work: the DC library is not loaded!'
         CALL REPORT('RIOFIL',1,'E')
         GO TO 150
      END IF
      LCAL = CFITYP.EQ.'CALI'
*-- Check the Direction option
      CALL UHTOC(LFIDIR,4,CFIDIR,4)
      CALL CLEFT(CFIDIR,1,4)
      CALL CLTOU(CFIDIR)
      IF(RABBRE('OUTP',CFIDIR,1).OR.
     +   RABBRE('NEW' ,CFIDIR,3)) THEN
         CFIDIR = 'OUT'
CCC      ISTREA = 1
CCC   ELSE IF(LAUTOU.AND.CFIDIR(1:3).EQ.'OUT') THEN
CCC      IC     = ICHAR(CFIDIR(4:4)) - ICHAR('0')
CCC      IF(IC.GE.1.AND.IC.LE.NOSTRE) THEN
CCC         ISTREA = IC
CCC      ELSE
CCC                                                             GO TO 30
CCC      END IF
      ELSE IF(RABBRE('INPU',CFIDIR,1)) THEN
         CFIDIR = 'INPU'
      ELSE IF(RABBRE('COPY',CFIDIR,1)) THEN
         CFIDIR = 'COPY'
      ELSE IF(RABBRE('UPDA',CFIDIR,1).OR.RABBRE('UPDT',CFIDIR,1)) THEN
         CFIDIR = 'UPDA'
      ELSE
                                                                GO TO 30
      END IF
      LOUTPU = CFIDIR(1:3).EQ.'OUT'.OR.CFIDIR(1:4).EQ.'COPY'
CCC   LSTREA = LSTREA.AND.LOUTPU
*-- Take care of the File option.
      IF(LFIFCH.EQ.0) LFIFCH = IHBLA
      CALL UHTOC(LFIFCH,4,CFIFCH,4)
      CALL CLEFT(CFIFCH,1,4)
      CALL CLTOU(CFIFCH)
*-- A file has to be either Native(default), Exchange or Alpha
      LEXCH  = INDEX(CFIFCH,'X').GT.0
      LALPHA = INDEX(CFIFCH,'A').GT.0
      LNATIV = INDEX(CFIFCH,'N').GT.0
      LCIO   = INDEX(CFIFCH,'L').GT.0
      I      = 0
      IF(LEXCH)  I = I + 1
      IF(LNATIV) I = I + 1
      IF(LALPHA) I = I + 1
      IF(LCIO)   I = I + 1
+SELF,IF=NOUNIX.
*-- CIO yet only implemented on Apollo and SGI.
      IF(LCIO) THEN
         CHREP  = 'CIO option not yet implemented here!'
         CALL REPORT('RIOFIL',1,'C')
                                                               GO TO 999
      END IF
+SELF.
*-- Nativ is default.
      IF(I.EQ.0) LNATIV = .TRUE.
*-- Find and check the stream that the parameters relate to.
      LIOHD  = LQ(LUTC-LLIOHD)
*-- Open file as 'NEW' by default
      CFSTAT = 'NEW '
*-- Handle INIT file
      IF(CFITYP.EQ.'INIT') THEN
         IF(CFIDIR.NE.'INPU')                                   GO TO 30
         LFZ    = .TRUE.
         LLIO   = LLIOII
         CHIO   = 'IOII'
         CFSTAT = 'OLD '
*     Handle INPUT compression directory
      ELSE IF(CFITYP.EQ.'DICT') THEN
         IF(CFIDIR.NE.'INPU')                                   GO TO 30
         CFSTAT='OLD'
         CHIO='IODT'
         LLIO=LLIODT
*-- Handle CNST file
      ELSE IF(CFITYP.EQ.'CONS') THEN
         IF(CFIDIR.NE.'INPU')                                   GO TO 30
         LFZ    = .TRUE.
         LLIO   = LLIOCI
         CHIO   = 'IOCI'
         CFSTAT = 'OLD '
*-- Handle DATA,PROD,DST,DDST,SCAN files
      ELSE IF(CFITYP.EQ.'DATA'.OR.CFITYP.EQ.'PROD'.OR.CFITYP.EQ.'DST'
     +    .OR.CFITYP.EQ.'CDST'
     +    .OR.CFITYP.EQ.'DDST'.OR.CFITYP.EQ.'SCAN'.OR.CFITYP.EQ.'OVER')
     +        THEN
         LFZ    = .TRUE.
*-- No update allowed on these files.
         IF(CFIDIR.EQ.'UPDA') THEN
                                                                GO TO 30
*-- Input streams are all treated the same way ...
         ELSE IF(CFIDIR.EQ.'INPU') THEN
            LLIO   = LLIODI
            CHIO   = 'IODI'
            CFSTAT = 'OLD '
*-- No Overflow type on input.
            IF(CFITYP.EQ.'OVER')                                GO TO 30
*-- Set IFSCAN if a SCAN file is defined on input.
            IF(CFITYP.EQ.'SCAN') IFSCAN = 1
*-- Check if we will read from memory.
            IF(INDEX(CFIFCH,'M').GT.0) LMEMIN = .TRUE.
*-- Copy streams.
         ELSE IF(CFIDIR.EQ.'COPY') THEN
            LLIO   = LLIODC
            CHIO   = 'IODC'
*-- We are now left with output streams.
         ELSE
*-- Check if we will read from memory.
            IF(INDEX(CFIFCH,'M').GT.0) LMEMOU = .TRUE.
            IF(CFITYP.EQ.'DATA') THEN
               LLIO   = LLIODO
               CHIO   = 'IODO'
            ELSE IF(CFITYP.EQ.'PROD') THEN
               LLIO   = LLIODP
               CHIO   = 'IODP'
            ELSE IF(CFITYP.EQ.'SCAN') THEN
               LLIO   = LLIODG
               CHIO   = 'IODG'
*-- Stop dropping of working bank to build a scan file.
               IFDROP = 0
             ELSE IF(CFITYP.EQ.'DST '.OR.CFITYP.EQ.'CDST' )THEN
               LLIO   = LLIODS
               CHIO   = 'IODS'
             ELSE IF(CFITYP.EQ.'DDST') THEN
               LLIO   = LLIODD
               CHIO   = 'IODD'
            ELSE IF(CFITYP.EQ.'OVER') THEN
               LLIO   = LLIOOV
               CHIO   = 'IOOV'
            ELSE
                                                                GO TO 30
            END IF
            IF(PACKIT) THEN
               FLAGS=IBSET(FLAGS,CPDATA)
               IF(CFIDIR.EQ.'OUT') LPACKO=.TRUE.
            END IF
         END IF
*-- Handle calibration.
      ELSE IF(LCAL) THEN
         LLIO   = LLIOCA
         CHIO   = 'IOCA'
         INDXD = INDEX(CFIFCH,'D')
*-- Forbid the D option in ROPE, that is reserved for OPCAL update.
         IF(INDXD.GT.0)                                         GO TO 50
         INDXN = INDEX(CFIFCH,'N')
*-- 'N' option should be replaced by 'U' ....
         IF(INDXN.GT.0) THEN
            CALL RTRANS(CFIFCH,'N',' ')
            CALL RADDOP(CFIFCH,'U')
         END IF
         INDXU = INDEX(CFIFCH,'U')
         INDXS = INDEX(CFIFCH,'S')
+SELF,IF=IBM.
*-- The shared access mode is invalid on the IBM.
         IF(INDXS.GT.0)                                         GO TO 60
+SELF.
*-- Check if we want to output a new calibration file.
         IF(.NOT.LOUTPU) CFSTAT = 'OLD'
*-- Check options for calibration file
*-- Update or new calib file
         IF(LOUTPU.OR.CFIDIR.EQ.'UPDA') THEN
*-- Add the 'U' anyhow
            CALL RADDOP(CFIFCH,'U')
+SELF,IF=-IBM.
*-- If not shared access, add the '1'
            IF(INDXS.EQ.0) CALL RADDOP(CFIFCH,'1')
+SELF.
*-- Read the data-base (OLD)
         ELSE IF(CFIDIR.EQ.'INPU') THEN
*-- Forbids the 'Update option'
            IF(INDXU.GT.0)                                      GO TO 70
         ELSE
                                                                GO TO 30
         END IF
*-- Set default record length LREC to 4096.
         IF(LFILRE.EQ.0) LFILRE = 4096
*-- Handle the HBOOK RZ file.
      ELSE IF(CFITYP.EQ.'HIST') THEN
         LLIO   = LLIOHB
         CHIO   = 'IOHB'
         INDXU = INDEX(CFIFCH,'U')
         INDXN = INDEX(CFIFCH,'N')
*-- Check option for HROPEN.
         IF(LOUTPU) THEN
            CALL RADDOP(CFIFCH,'N')
            CALL RADDOP(CFIFCH,'Q')
            IF(INDXU.GT.0)                                      GO TO 70
         ELSE IF(CFIDIR.EQ.'UPDA') THEN
            CALL RADDOP(CFIFCH,'U')
            IF(INDXN.GT.0)                                      GO TO 70
         ELSE IF(CFIDIR.EQ.'INPU') THEN
            IF(INDXU.GT.0)                                      GO TO 70
            IF(INDXN.GT.0)                                      GO TO 70
         ELSE
                                                                GO TO 30
         END IF
*-- Set default record length LREC to 1024.
         IF(LFILRE.EQ.0) LFILRE = 1024
*-- Set default size of RZ file to 65000 records.
         IF(LFIDCX.EQ.0.OR.LFIDCX.EQ.IHBLA) LFIDCX = 65000
*-- Handle bank documentation file.
      ELSE IF(CFITYP.EQ.'BANK') THEN
         LLIO   = LLIOBK
         CHIO   = 'IOBK'
         IF(CFIDIR.NE.'INPU')                                   GO TO 30
         CFSTAT = 'OLD'
*-- Set default record length LREC to 1024.
         IF(LFILRE.EQ.0) LFILRE = 1024
*-- Handle metafile.
      ELSE IF(CFITYP.EQ.'META') THEN
         LLIO   = LLIOME
         CHIO   = 'IOME'
         IF(CFIDIR(1:3).NE.'OUT')                               GO TO 30
*-- Set default record length LREC to 80.
         IF(LFILRE.EQ.0) LFILRE = 80
*-- Default unit number is 47
         IF(LFIUNI.EQ.0) LFIUNI =47
      ELSE
                                                                GO TO 30
      END IF
*-- File on disk by default.
      ACMODE = 0
*-- Now decode the 'file dependent option'
      IF(LCAL) THEN
         IF(CFSTAT.EQ.'OLD') THEN
*-- Set default name to 'MAIN' for input database
            IF(LFIDCX.EQ.0.OR.LFIDCX.EQ.IHBLA) THEN
               CALL UCTOH('MAIN',LFIDCX,4,4)
            END IF
            CALL UHTOC(LFIDCX,4,CFIDCX,4)
*- NKW mods start.
            IF (CFIDCX.EQ.'MAIN') THEN
*-- Set default top dir. names for expts 1-9. (By the time we get to
*-- expt. 10, we should have an RZ mapping between files available.)
              DO 5 IMISC=1,MAXEXP
*-- Don't overwrite top dir names explicitly set by user.
                IF (CHTNOM(IMISC).EQ.'    ') CHTNOM(IMISC)='MAIN'
    5         CONTINUE
              ICMAIN=1
            ELSEIF (CFIDCX(1:3).EQ.'EXP'.AND.INDEXN(CFIDCX).EQ.4) THEN
              READ(UNIT=CFIDCX,FMT='(3X,I1)') IMISC
              IF (IMISC.GE.1.AND.IMISC.LE.MAXEXP) THEN
                CHTNOM(IMISC)=CFIDCX
                ICMAIN=1
              ENDIF
            ELSEIF (CFIDCX(1:2).EQ.'EX'.AND.INDEXN(CFIDCX).EQ.3) THEN
              READ(UNIT=CFIDCX,FMT='(2X,I2)') IMISC
              IF (IMISC.GE.1.AND.IMISC.LE.MAXEXP) THEN
                CHTNOM(IMISC)=CFIDCX
                ICMAIN=1
              ENDIF
            ENDIF
*- NKW mods end.
         END IF
         TYPE   = 0
         IF(LNAME) TYPE   = 1
      ELSE IF(LNAME) THEN
*-- Check whether this file name contains variable names
         CALL ROVANA(CFNAME,LVARI)
         IF(LVARI) THEN
            IF(.NOT.LOUTPU)                                     GO TO 80
            FLAGS  = IBSET(FLAGS,VARNAM)
         END IF
         IF(CFITYP.EQ.'HIST') THEN
*-- LFIDCX correspond to the original file size for histogramms.
         ELSE IF(LFIDCX.NE.0.AND.LFIDCX.NE.IHBLA) THEN
            CALL UHTOC(LFIDCX,4,CFIDCX,4)
            CALL CLEFT(CFIDCX,1,4)
            CALL CLTOU(CFIDCX)
            DO 10 I=1,4
            OPT    = CFIDCX(I:I)
            IF(OPT.EQ.' ') THEN
            ELSE IF(OPT.EQ.'L') THEN
            ELSE IF(OPT.EQ.'R') THEN
            ELSE IF(OPT.EQ.'V') THEN
+SELF,IF=-IBM.
            ELSE IF(OPT.EQ.'P')THEN
+SELF,IF=SHIFT.
               IF(CFIDIR.NE.'INPU'.OR..NOT.LFZ)                 GO TO 90
               ACMODE = 3
+SELF,IF=-SHIFT,IF=-IBM.
               CFIDCX(I:I)=' '
               CALL UCTOH(CFIDCX,LFIDCX,4,4)
+SELF.
+SELF,IF=IBM.
            ELSE IF(OPT.EQ.'M') THEN
               ACMODE = 1
            ELSE IF(OPT.EQ.'S') THEN
               ACMODE = 2
            ELSE IF(OPT.EQ.'P') THEN
               IF(CFIDIR.NE.'INPU'.OR..NOT.LFZ)                 GO TO 90
               ACMODE = 3
            ELSE IF(OPT.EQ.'F') THEN
               IF((LOUTPU.AND.LFZ).OR.CFITYP.EQ.'META') THEN
                  FLAGS  = IBSET(FLAGS,DUMPER)
               ELSE
                                                                GO TO 90
               END IF
+SELF,IF=VAX.
            ELSE IF(OPT.EQ.'E') THEN
               ACMODE = 1
            ELSE IF(OPT.EQ.'O') THEN
               FLAGS  = IBSET(FLAGS,ANYWHE)
            ELSE IF(OPT.EQ.'N') THEN
               FLAGS  = IBSET(FLAGS,NEWTAP)
            ELSE IF(OPT.EQ.'H') THEN
               FLAGS  = IBSET(FLAGS,ONLYHE)
            ELSE IF(OPT.EQ.'X') THEN
               FLAGS  = IBSET(FLAGS,EXPLIC)
            ELSE IF(OPT.EQ.'U') THEN
               FLAGS  = IBSET(FLAGS,NOSTRU)
+SELF,IF=UNIX.
            ELSE IF(OPT.EQ.'E') THEN
               ACMODE = 1
            ELSE IF(OPT.EQ.'S') THEN
               ACMODE = 2
            ELSE IF(OPT.EQ.'U') THEN
               FLAGS  = IBSET(FLAGS,NOSTRU)
+SELF.
            ELSE IF(OPT.EQ.'A') THEN
               FLAGS  = IBSET(FLAGS,AUTOPU)
            ELSE IF(OPT.EQ.'1') THEN
               IF((LOUTPU.AND.LFZ).OR.CFITYP.EQ.'META') THEN
                  FLAGS  = IBSET(FLAGS,ONEEVE)
               ELSE
                                                                GO TO 90
               END IF
            ELSE IF(OPT.EQ.'=') THEN
               IF(.NOT.LOUTPU.OR..NOT.LFZ)                      GO TO 90
               FLAGS  = IBSET(FLAGS,ONEONE)
               LONEOF = .TRUE.
            ELSE IF(OPT.EQ.'C') THEN
               IF(.NOT.LOUTPU.OR..NOT.LFZ)                      GO TO 90
               FLAGS = IBSET(FLAGS,NOCONS)
            ELSE IF(OPT.EQ.'Q') THEN
               FLAGS = IBSET(FLAGS,CLSQUI)
            ELSE IF(OPT.EQ.'D') THEN
               IF(CFITYP.NE.'META')                             GO TO 90
               IF(.NOT.LPLOT) THEN
                  CALL UCTOH('PLOT',LTYPDE,4,4)
                  CALL RGETDV
                  IF(.NOT.LPLOT)                               GO TO 100
               END IF
               FLAGS = IBSET(FLAGS,PLOTIT)
            ELSE
                                                                GO TO 90
            END IF
   10       CONTINUE
            IF(BTEST(FLAGS,DUMPER).AND.ACMODE.NE.0)            GO TO 110
         END IF
         IF(CFITYP.NE.'HIST') LFIDCX = 1
*-- Set TYPE parameter
         TYPE   = 1
         IF(FATFIL) TYPE   = 2
*-- Now Check that the file name consists of:
         W      = RWORDS(CFNAME)
+SELF,IF=VAX.
*-- On a vax, 'NL:' means 'dummy'
         CALL CLTOU(CFNAME)
         IF(CFNAME.EQ.'DUMMY') CFNAME  = 'NL:'
+SELF,IF=UNIX.
*-- On unix machines, '/dev/null' means 'dummy'
         SFNAME = CFNAME
         CALL CLTOU(SFNAME)
         IF(SFNAME.EQ.'DUMMY') CFNAME='/dev/null'
         IF(ACMODE.GT.0.OR.FATFIL) THEN
         ELSE IF(CFNAME(1:1).EQ.'[') THEN
*-- A Pool name and user has been given
            I      = INDEX(CFNAME,']')
            IF(I.EQ.0)                                         GO TO 120
            W      = RWORDS(CFNAME(I+1:NAMLEN))
         ENDIF
+SELF,IF=-IBM.
*-- One word on a non IBM machine
         IF(W.NE.1)                                            GO TO 120
+SELF,IF=IBM.
*-- Two or three words on an IBM , unless it's 'DUMMY'
*-- might be a tape,stage,or prestage request
*-- Restore the original name for tape mounting and (pre)staging
         IF(ACMODE.GT.0) CFNAME = ORGNAM
         CALL CLTOU(CFNAME)
         IF(ACMODE.GT.0.OR.FATFIL) THEN
         ELSE IF(CFNAME.EQ.'DUMMY') THEN
            TYPE   =-1
         ELSE IF(CFNAME(1:1).EQ.'[') THEN
*-- [user.cuu] given as a file prefix
            I      = INDEX(CFNAME,']')
            IF(I.EQ.0)                                         GO TO 120
            W      = RWORDS(CFNAME(I+1:NAMLEN))
            IF(W.NE.2.AND.W.NE.3)                              GO TO 120
         ELSE IF(W.NE.2.AND.W.NE.3) THEN
                                                               GO TO 120
         END IF
+SELF.
      ELSE
         TYPE   = 0
*-- Set default tape Number to 1
         IF(LFIDCX.EQ.0.OR.LFIDCX.EQ.IHBLA) LFIDCX = 1
      END IF
*-- FZ Files: perfom further checks on the file option
*--           Set default LREC to 8100 in exchange or CIO mode.
*--          (NO check if it comes from a *FATFILE card)
      IF(LFZ) THEN
         IF(LEXCH.AND.LFILRE.EQ.0) LFILRE = 8100
         IF(LCIO.AND.LFILRE.EQ.0)  LFILRE = 8100
         IF(.NOT.FATFIL) THEN
*-- Add the 'T' option if it's a tape, remove it otherwise
            IF(ACMODE.EQ.1) THEN
               CALL RADDOP(CFIFCH,'T')
            ELSE
               CALL RTRANS(CFIFCH,'T',' ')
            END IF
*-- Force the 'O' option when output, 'I' elsewhere
            IF(LOUTPU) THEN
               IF(INDEX(CFIFCH,'I').NE.0)                       GO TO 70
               CALL RADDOP(CFIFCH,'O')
*-- Count the number of output files
               IF(LASTDO.NE.LFIUNI) THEN
*-- Can not redefine the same unit for a new output stream
                  IF(NCHAOU(LFIUNI).NE.0)                      GO TO 130
                  LASTDO = LFIUNI
               ELSE
*-- Can't define a new file after a varaible name was given
                  IF(NCHAOU(LFIUNI).EQ.9999)                   GO TO 140
               END IF
               IF(BTEST(FLAGS,DUMPER)) THEN
                  NCHAOU(LFIUNI) = 9999
               ELSE
                  NCHAOU(LFIUNI) = NCHAOU(LFIUNI) + 1
               END IF
            ELSE
               IF(INDEX(CFIFCH,'O').NE.0)                       GO TO 70
               CALL RADDOP(CFIFCH,'I')
            END IF
         END IF
      END IF
*-- Check the file not already used
      WATFOR = CFITYP//CFIDIR
      CALL ROGTUN(LFIUNI,WATFOR)
      IF(LFIUNI.EQ.0)                                          GO TO 150
CCC   IF(LSTREA) UNIOUT(ISTREA) = LFIUNI
CCCCCC End of temporary comment of AUTOUNIT
*-- Store the file parameters in the bank.
*-- Look if its Stage ACMODE=2 and of the form AA9999.1-9
      MULSTG=0
      IF(ACMODE.EQ.2)THEN
         IPDOT=INDEX(CFNAME,'.')
         IF(IPDOT.NE.0)THEN
            IPMIN=INDEX(CFNAME,'-')
            IF(IPMIN.NE.0)THEN
               MINSTG=ICDECI(CFNAME,IPDOT+1,IPMIN-1)
               MAXSTG=ICDECI(CFNAME,IPMIN+1,LNBLNK(CFNAME))
               IF(MINSTG.GT.0 .AND. MAXSTG.GT.0)THEN
                  IF(MAXSTG.GE.MINSTG)MULSTG=1
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      IF(MULSTG.EQ.0)THEN
         MINSTG=1
         MAXSTG=1
      ENDIF

      DO 15 I=MINSTG,MAXSTG
*     fake 1 FFREAD card/file (sequence)
      IF(MULSTG.NE.0)THEN
         CFNAME(IPDOT+1:)=' '
         WRITE(CFNAME(IPDOT+1:),'(I3)')I
         CALL CLEFT(CFNAME,1,LNBLNK(CFNAME))
      ENDIF
      LIOBNK = LQ(LIOHD-LLIO)
      IF(LIOBNK.LT.1) THEN
         CALL MZBOOK(IROCON,LIOBNK,LIOHD,-LLIO,CHIO, NLIOXX,NSIOXX,
     +   NDIOXX,IOIOXX,0)
      ELSE
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIO)
         CALL MZBOOK(IROCON,LIOBNK,LIOBNK,0,CHIO, NLIOXX,NSIOXX,NDIOXX,
     +   IOIOXX,0)
      END IF
      IQ(LIOBNK+JLUN)  = LFIUNI
      IQ(LIOBNK+JLREC) = LFILRE
+SELF,IF=IBM.
*-- Select IOPACK for exchange mode on IBM.
      IF(LEXCH) CALL RADDOP(CFIFCH,'Y')
+SELF.
      CALL UCTOH(CFIFCH,IQ(LIOBNK+JFCHOP),4,4)
      IQ(LIOBNK+JDCHOP) = LFIDCX
      IQ(LIOBNK+JACMOD) = ACMODE
      IQ(LIOBNK+JFNTYP) = TYPE
      IQ(LIOBNK+JFLAGS) = FLAGS
      IQ(LIOBNK+JFJFIL) = JFILE
      CALL UCTOH(CFSTAT,IQ(LIOBNK+JFSTAT),4,4)
*-- Fill in the file name
      CALL UCTOH(CFNAME,IQ(LIOBNK+JFNAME),NBYTEW,NAMLEN)
*-- And the FATMEN search keys
      IF(FATFIL) CALL UCOPY(SELKEY,IQ(LIOBNK+JFKEYS),KEYLEN)
 15   CONTINUE
                                                               GO TO 999
*
   20 CHREP  = 'Not enough parameters on *FILE card'
      CALL REPORT('RIOFIL',2,'E')
                                                               GO TO 150
*
   30 CHREP  = 'Invalid type and/or direction : '//CFITYP//'  '//CFIDIR
      CALL REPORT('RIOFIL',3,'E')
                                                               GO TO 150
*
   50 CHREP  = '"D" option invalid in ROPE'
      CALL REPORT('RIOFIL',5,'E')
+SELF,IF=IBM.
                                                               GO TO 150
*
   60 CHREP  = '"S" option invalid on IBM'
      CALL REPORT('RIOFIL',6,'E')
+SELF.
                                                               GO TO 150
*
   70 CHREP  = 'Do you want Input or Output? Options mismatch!'
      CALL REPORT('RIOFIL',7,'E')
                                                               GO TO 150
*
   80 CHREP  = 'No variable name allowed on input!'
      CALL REPORT('RIOFIL',8,'E')
                                                               GO TO 150
*
   90 CHREP  = 'DCHOPT "'//OPT//'" not allowed for type/dir : '
     +                                      //CFITYP//'/'//CFIDIR
      CALL REPORT('RIOFIL',9,'E')
                                                               GO TO 150
*
  100 CHREP  = 'You forgot to allocate a plotter by *GETDEVIC'
      CALL REPORT('RIOFIL',10,'E')
                                                               GO TO 150
*
  110 CHREP  = 'Flush option valid for DISK files only'
      CALL REPORT('RIOFIL',11,'E')
                                                               GO TO 150
*
  120 CHREP  = 'Invalid file name : '//CFNAME
      CALL REPORT('RIOFIL',12,'E')
                                                               GO TO 150
*
  130 CHREP  = 'Invalid re-use of the output stream'
      CALL REPORT('RIOFIL',13,'E')
                                                               GO TO 150
*
  140 CHREP  = 'Output unit already used for variable name file'
      CALL REPORT('RIOFIL',14,'E')
  150 FFERRO = .TRUE.
  999 CONTINUE
*
      RETURN
      END
+DECK,RIOMAS.
      SUBROUTINE RIOMAS
*.
*...RIOMAS   Decode the *MASTERNA ffread card.
*.
*.  SEQUENCES :
*.  CALLS     :  REPORT SORTI MZBOOK MZDROP UHTOC LENOCC CLTOU CLEFT
*.  CALLED    :  RFUSER
*.
*.  AUTHORS   :  D.Lellouch
*.  VERSION   :  1.00
*.  CREATED   :   25-May-91
*.  LAST MOD  :   24-Aug-1998
*.
*.
*.  Detailed description:
*.
*.  Decode the FFREAD card: *MASTERNA dir unit 'opt'  'PATTERN'
*.
*.  dir    :  'IN' only for the time being
*.  unit   :   0   only for the time being
*.  opt    :  'O'  or 'L' to list
*.  pattern:  what to look for when initializing the data base
*.
*.  Modification Log.
*.  24-Aug-1998 E.Barberio modify RIOMAS to handle runs >10000
*.  6-Sep-91  S.Weisz     Slight alteration.
*.
*.********************************************************************
+SEQ,DECLARE.
*
      INTEGER      MAXRUN
      PARAMETER   (MAXRUN=90000)
      INTEGER      I,IER,IFILE,L,LENOCC,LMSRN,J,IRUN,NCOL,I1,I2
      LOGICAL      RABBRE,HERE,LIST
      CHARACTER*1  OPT
      CHARACTER*4  DIR,OPTION
      CHARACTER*5  CHRUN
      CHARACTER*16 CHCOMP
      CHARACTER*80 SEARCH,SEARTE,SPACES,FILE,FILR
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
+SEQ,RCREP.
+SEQ,RCSYST.
+SEQ,RCLINE.
+SEQ,ROWORD.
*-- Can't call twice
      IF(LMSOPE)                                                GO TO 70
*-- Check the direction: 'IN'
      CALL UHTOC(LMNDIR,4,DIR,4)
      CALL CLEFT(DIR,1,4)
      CALL CLTOU(DIR)
      IF(.NOT.RABBRE('INPU',DIR,1))                             GO TO 80
*-- Unit has to be zero
      IF(LMNUNI.NE.0)                                           GO TO 80
*-- Only L and O options allowed
      CALL UHTOC(LMNOPT,4,OPTION,4)
      CALL CLEFT(OPTION,1,4)
      CALL CLTOU(OPTION)
      HERE   = .TRUE.
      LIST   = .FALSE.
      DO 10 I=1,4
         OPT    = OPTION(I:I)
         IF(OPT.EQ.' ') THEN
         ELSE IF(OPT.EQ.'L') THEN
            LIST   = .TRUE.
         ELSE IF(OPT.EQ.'O') THEN
            HERE   = .FALSE.
         ELSE
                                                                GO TO 80
         END IF
   10 CONTINUE
*-- Decode the search pattern
      CALL UHTOC(LMNNAM,NBYTEW,SEARTE,NAMLEN)
      SEARTE = SPACES(SEARTE,1)
      IF(SEARTE(1:1).EQ.' ') THEN
                                                                GO TO 90
      ELSE IF(SEARTE(1:2).EQ.'//') THEN
         SEARCH = SEARTE
      ELSE IF(SEARTE(1:1).EQ.'/') THEN
         SEARCH = '/'//SEARTE
      ELSE
         SEARCH = '//'//SEARTE
      END IF
*
      IF(HERE) THEN
         CHCOMP = CHNODE(1:LCHNOD)
      ELSE
         CHCOMP = ' '
      END IF
*-- Check if catalog file  is accessed, if not, do it ...
      IF(.NOT.LCATAL) THEN
         CALL RSCATA
         IF(.NOT.LCATAL)                                       GO TO 100
      END IF
*
      CALL MZBOOK(IROCON,LMSRN,LUTC,-LLMSRN,'MSRN',0,0,2*MAXRUN,2,-1)
      MSNRUN = 0
*-- Scan the data base and decode run number
      DO 30 I=1,MAXRUN
         CALL RSEDBS(SEARCH,CHCOMP,I,FILE,IER,IFILE)
         IF(IER.LT.0)                                          GO TO 110
         IF(IER.EQ.0)                                           GO TO 40
*-- FILE should be like [opaldata.opal]nanodst/pXXrYYYYY.nano_passZ
         L      = LENOCC(FILE)
         J      = INDEX(FILE,'[')
         IF(J.GT.0) THEN
            J      = INDEX(FILE,']')
            IF(J.EQ.0) THEN
               CHREP  = 'Unmatched [ in filename from catalog'
               CALL REPORT('RIOMAS',1,'W')
                                                                GO TO 30
            END IF
         END IF
         FILR   = FILE(J+1:L)
         L      = L - J
         J      = INDEX(FILR,'.')
         IF(J.GT.0) L      = J - 1
         CHRUN  = FILR(L-4:L)
         READ(CHRUN,'(I5)',ERR=20) IRUN
         MSNRUN = MSNRUN + 1
         IQ(LMSRN+MSNRUN*2-1) = IRUN
         IQ(LMSRN+MSNRUN*2  ) = IFILE
                                                                GO TO 30
   20    CHREP  = 'Could not decode the run number in:'//FILE
         CALL REPORT('RIOMAS',1,'W')
   30 CONTINUE
*-- Did we find some runs?
   40 IF(MSNRUN.EQ.0)                                          GO TO 120
*-- Sort in run ascending order
      CALL SORTI(IQ(LMSRN+1),2,MSNRUN,1)
      CALL MZPUSH(IROCON,LMSRN,0,2*(MSNRUN-MAXRUN),'I')
*-- Why not checking for double entries?
      IF(MSNRUN.GT.1) THEN
         DO 50 I=1,MSNRUN-1
            IRUN   = IQ(LMSRN+2*I-1)
            IF(IRUN.EQ.IQ(LMSRN+2*I+1)) THEN
               WRITE(CHREP,1010) IRUN
               CALL REPORT('RIOMAS',2,'W')
            END IF
   50    CONTINUE
      END IF
*-- So far so good
      MSFRUN = IQ(LMSRN+1)
      MSLRUN = IQ(LMSRN-1+2*MSNRUN)
      WRITE(CHREP,1020) MSNRUN,MSFRUN,MSLRUN
      CALL REPORT('RIOMAS',3,'I')
      LMSOPE = .TRUE.
*-- Did the user request a nice printing of the runs table?
      IF(LIST) THEN
         WRITE(CHLINE,1030)
         CALL RMAIL(0,0)
         NCOL   = 0
         I      = 0
         FILE   = ' '
   60    I      = I + 1
*-- The following line fixes a bug in the SGI compiler !!!!
         LMSRN  = LQ(LUTC-LLMSRN)
         IRUN   = IQ(LMSRN+2*I-1)
         NCOL   = NCOL + 1
         IF(NCOL.EQ.11) THEN
            WRITE(CHLINE,1040) FILE
            CALL RMAIL(0,0)
            NCOL   = 1
            FILE   = ' '
         END IF
         I1     = 8*NCOL - 6
         I2     = I1 + 6
         WRITE(FILE(I1:I2),'(I7)') IRUN
         IF(I.LT.MSNRUN)                                        GO TO 60
         WRITE(CHLINE,1040) FILE
         CALL RMAIL(0,0)
         WRITE(CHLINE,1030)
         CALL RMAIL(0,0)
      END IF
                                                               GO TO 999
*
   70 CHREP  = '*MASTERNA cannot be called twice'
      CALL REPORT('RIOMAS',4,'E')
                                                               GO TO 990
*
   80 CHREP  = 'The only valid format is: '//
     +         '*MASTERNA ''IN'' 0 ''opt'' ''pattern'' '
      CALL REPORT('RIOMAS',5,'E')
                                                               GO TO 990
*
   90 CHREP  = 'The search pattern was not given'
      CALL REPORT('RIOMAS',6,'E')
                                                               GO TO 990
*
  100 CHREP  = 'The CATALOG package was not initialised'
      CALL REPORT('RIOMAS',7,'E')
                                                               GO TO 990
*
  110 WRITE(CHREP,1000) IER
      CALL REPORT('RIOMAS',8,'E')
                                                               GO TO 990
*
  120 CHREP  = 'No run was found for the given search pattern'
      CALL REPORT('RIOMAS',9,'E')
      CALL MZDROP(IXSTOR,LMSRN,'.')
*
  990 FFERRO=.TRUE.
  999 RETURN
*
 1000 FORMAT('Unexpected error while scanning the file data base:',I4)
 1010 FORMAT('The run',I5,' appears twice. First occurrence ',
     +       'will be used')
 1020 FORMAT(T30,'Found',I4,' runs. First is',I5,' last is',I5)
 1030 FORMAT(T30,'+',83('-'),'+')
 1040 FORMAT(T30,'|',A,'   |')
      END
+DECK,RIONAN.
      SUBROUTINE RIONAN
*.
*...RIONAN Handle *NANOFILE FFREAD cards
*.
*. SEQUENCE: ROBANK CRO RCNTRL RCREP ROWORD
*. CALLS   :
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 29-Apr-91
*. LAST MOD:  6-Sep-91
*.
*.   DETAILED DESCRIPTION:
*.
*.  Interpret the *NANOFILE card. The format is:
*.  *NANOFILE  'direction' unit1 unit2 'rchopt' 'name'
*.
*.  'direction'  'in' (could be 'new'='out' later ... )
*.   unit1     logical unit to read the NanoDst
*.   unit2     logical unit to read the data-file
*.   rchopt    rope processing option
*.   name      nano-dst name (wild-carding/catalog entries accepted)
*.
*. Modification Log.
*.  6-Sep-91  S.Weisz     Slight alteration.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER      FLAGS,TYPE,I,LIOHD,LIOBNK,LZLAST
      LOGICAL      RABBRE,LVARI
      CHARACTER*1  OPT
      CHARACTER*4  CNADIR,CNADCH
      CHARACTER*8  WATFOR
      CHARACTER*80 NANONA,SPACES
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCREP.
+SEQ,RCLINE.
*-- Check that we have the vital minimum number of parameters
      IF(LNADIR.EQ.0)                                           GO TO 20
      IF(LNAUN1.EQ.0)                                           GO TO 20
*-- Set the default flag
      FLAGS  = IBSET(0,NANODS)
*-- Check the direction
      CALL UHTOC(LNADIR,NBYTEW,CNADIR,4)
      CALL CLEFT(CNADIR,1,4)
      CALL CLTOU(CNADIR)
      IF(RABBRE('INPU',CNADIR,1)) THEN
      ELSE IF(RABBRE('OUTP',CNADIR,1).OR.RABBRE('NEW',CNADIR,1)) THEN
         CHREP = 'Output of NanoDst is not yet implemented'
         CALL REPORT('RIONAN',1,'E')
                                                               GO TO 990
      ELSE
                                                                GO TO 30
      END IF
*-- Check if a file name was given
      CALL UHTOC(LNANAM,NBYTEW,NANONA,NAMLEN)
      NANONA = SPACES(NANONA,1)
      IF(NANONA.EQ.' ') THEN
         TYPE   = 0
      ELSE IF(NANONA.EQ.'DUMMY'.OR.NANONA.EQ.'dummy') THEN
                                                                GO TO 40
      ELSE
         TYPE   = 1
      END IF
*-- Is it a variable name? Not allowed
      IF(TYPE.EQ.1) THEN
         CALL ROVANA(NANONA,LVARI)
         IF(LVARI)                                              GO TO 50
      END IF
*-- Now check the logical unit for the NANODST
      WATFOR = 'NANO'//CNADIR
      CALL ROGTUN(LNAUN1,WATFOR)
      IF(LNAUN1.EQ.0)                                          GO TO 990
*-- And check the logical unit for the data file
      IF(LUNAIN.EQ.0) THEN
         IF(LNAUN2.EQ.0) THEN
            CHREP  = 'Use unit 52 to read the nanodst'
            LNAUN2 = 52
            CALL REPORT('RIONAN',2,'I')
         END IF
         WATFOR = 'DATA'//CNADIR
         CALL ROGTUN(LNAUN2,WATFOR)
         IF(LNAUN2.EQ.0)                                       GO TO 990
         LUNAIN = LNAUN2
      ELSE
         IF(LNAUN2.EQ.0) THEN
            LNAUN2 = LUNAIN
         ELSE IF(LNAUN2.NE.LUNAIN) THEN
                                                                GO TO 60
         END IF
      END IF
*-- What about the Rope processing options?
      CALL UHTOC(LNAOPT,4,CNADCH,4)
      CALL CLEFT(CNADCH,1,4)
      CALL CLTOU(CNADCH)
      DO 10 I=1,4
         OPT    = CNADCH(I:I)
         IF(OPT.EQ.' ') THEN
         ELSE IF(OPT.EQ.'H') THEN
            FLAGS  = IBSET(FLAGS,ONLYHE)
         ELSE IF(OPT.EQ.'Q') THEN
            FLAGS  = IBSET(FLAGS,CLSQUI)
         ELSE
                                                                GO TO 70
         END IF
   10 CONTINUE
*-- So far so good
      LIOHD  = LQ(LUTC-LLIOHD)
      LIOBNK = LQ(LIOHD-LLIODI)
      IF(LIOBNK.LT.1) THEN
         CALL MZBOOK(IROCON,LIOBNK,LIOHD,-LLIODI,'IODI',
     +               NLIOXX,NSIOXX,NDIOXX,IOIOXX,0)
      ELSE
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIODI)
         CALL MZBOOK(IROCON,LIOBNK,LIOBNK,0,'IODI',
     +               NLIOXX,NSIOXX,NDIOXX,IOIOXX,0)
      END IF
      IQ(LIOBNK+JLUN)   = LNAUN1
      IQ(LIOBNK+JLREC)  = NUHMAX
      IQ(LIOBNK+JDCHOP) = 1
      IQ(LIOBNK+JACMOD) = 0
      IQ(LIOBNK+JFNTYP) = TYPE
      IQ(LIOBNK+JFLAGS) = FLAGS
      CALL UCTOH('OLD ',IQ(LIOBNK+JFSTAT),4,4)
      CALL UCTOH(NANONA,IQ(LIOBNK+JFNAME),NBYTEW,NAMLEN)
                                                               GO TO 999
*--   Error Processing...
   20 CHREP='Not enough parameters on *NANOFILE card'
      CALL REPORT('RIONAN',3,'E')
                                                               GO TO 990
*
   30 CHREP='Wrong "direction" parameter: '//CNADIR
      CALL REPORT('RIONAN',4,'E')
                                                               GO TO 990
*
   40 CHREP='A Nanodst can not be dummied'
      CALL REPORT('RIONAN',5,'E')
                                                               GO TO 990
*
   50 CHREP='Variable name not allowed for nanodst'
      CALL REPORT('RIONAN',6,'E')
                                                               GO TO 990
*
   60 CHREP  = 'Only one logical unit allowed for data in NANO access'
      CALL REPORT('RIONAN',7,'E')
                                                               GO TO 990
*
   70 CHREP='Unknown option:'//OPT
      CALL REPORT('RIONAN',8,'E')
*
990   FFERRO=.TRUE.
999   RETURN
*
      END
+DECK,RIOSEL.
      SUBROUTINE RIOSEL(UNIT,IOSEL)
*.
*...RIOSEL   Select one or all units for output.
*.
*. INPUT     : UNIT  Logical output or DST unit. (0=all units)
*. INPUT     : IOSEL Selection flag (1=selected, 0=nonselected)
*.
*. SEQUENCE  : ROBANK ROCPAR ROUNIT RCREP
*. CALLED    : ROEVNT <USER>
*.
*. BANK U    : IOHD IODO IODS IODD IODC IOOV IODP IODG
*. BANK M    : IODO IODS IODD IODC IOOV IODP IODG
*.
*. AUTHOR    : A.Buijs
*. VERSION   : 1.01
*. CREATED   :  7-Apr-1988
*. LAST MOD  : 26-Mar-1991
*.
*. DETAILED DESCRIPTION:
*. This routine will set or reset the selection flag for output
*. units. By default, all units should be selected. Note that for
*. efficiency, no check on IOSEL is done.
*.
*. Modification log:
*. 26-Mar-91 D.Lellouch  Implement DAD list output.
*.  5-Fev-91 S.Weisz     Temporary comment of AUTOUNIT.
*. 24-Jan-91 D.Lellouch  Implement 'auto unit' mode.
*. 23-Oct-90 S.Weisz     DDST file also handled.
*.  7-Sep-89 S.Weisz     SCAN file also handled.
*. 12-Jun-89 S.Weisz     PRODUCTION file also handled.
*. 12-Jan-89 S.Weisz     OVERFLOW file also handled.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER    NOUT
      PARAMETER (NOUT=8)
*
      INTEGER    UNIT,IOSEL,LUN,LLOUT(NOUT),LIOHD,LLIO,LIO,I
      SAVE       LLOUT
*
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
+SEQ,RCREP.
*
      DATA LLOUT/LLIODO,LLIODS,LLIODD,LLIODC,LLIOOV,LLIODP,LLIODG,
     +           LLIOAO/
*
      LUN = -1
      IF(UNIT.EQ.0) THEN
*-- Unit zero: all files
         LUN = 0
      ELSE IF(UNIT.GE.1.AND.UNIT.LE.NROPEU) THEN
*-- UNIT refers to a FORTRAN logical unit number, check if output
         IF(UNIUSE(UNIT)(5:7).EQ.'OUT') THEN
            LUN = UNIT
         ELSE
            WRITE(CHREP,1000) UNIT
            CALL REPORT('RIOSEL',1,'W')
                                                               GO TO 999
         END IF
CCCCCC Temporary comment of AUTOUNIT
C     ELSE IF(UNIT.LE.-1.AND.UNIT.GE.-NOSTRE.AND.LAUTOU) THEN
*-- UNIT refers to a ROPE logical stream
C        IF(UNIOUT(-UNIT).GT.0) THEN
C           LUN=UNIOUT(-UNIT)
C        ELSE
C           WRITE(CHREP,1010) UNIT
C           CALL REPORT('RIOSEL',2,'W')
C                                                              GO TO 999
C        END IF
CCCCCC End of temporary comment of AUTOUNIT
      ELSE
*-- UNIT is an invalid logical stream
         WRITE(CHREP,1020) UNIT
         CALL REPORT('RIOSEL',3,'W')
                                                               GO TO 999
      END IF
*
      LIOHD=LQ(LUTC-LLIOHD)
      DO 20 I = 1,NOUT
         LLIO = LLOUT(I)
         LIO  = LQ(LIOHD-LLIO)
   10    IF(LIO.LT.1)                                           GO TO 20
         IF(LUN.EQ.0)            IQ(LIO+JSELEC)=IOSEL
         IF(LUN.EQ.IQ(LIO+JLUN)) IQ(LIO+JSELEC)=IOSEL
         LIO=LQ(LIO)
                                                                GO TO 10
   20 CONTINUE
  999 RETURN
*
 1000 FORMAT('Unit',I3,' not defined for output')
 1010 FORMAT('Logical stream',I2,' not defined')
 1020 FORMAT('Invalid unit/logical stream:',I7)
*
      END
+DECK,RIOSET.
      SUBROUTINE RIOSET
*.
*...RIOSET  Initialize Input-output streams.
*.
*. SEQUENCE: ROBANK RCNTRL ROPAR ROCPAR CRO ROUNIT RCREP CRVER
*. CALLS   : MZLOGL ROOPEN RGETIN RGETCO FZENDI MZBOOK REPORT ROWDAO
*.           RDADOP ROPUNI ROPREP
*. CALLED  : ROPSET
*.
*. BANK U  : UTC IOHD IOII IOCI IODI IOCA IOHB
*. BANK L  : IODI
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 24-May-88
*. LAST MOD: 30-Mar-94
*.
*. Modification log:
*.
*. 30-Mar-94  T.Smith        New handling of OPCAL for ONLINE.
*.  1-Feb-94  O.Schaile      Allow suppressing of output in RMAIL
*. 31-Aug-93  O.Schaile      Use LURAWD=56 (instead of 21)
*. 26-Jul-93  O.Schaile      SU default didnt work without any CAL
*. 20-Jul-93  O.Schaile      Look if a *SUDB FFREAD has been defined
*. 19-Jun-92  D.Lellouch     Open the data compression dictionary(ies)
*. 25-Mar-91  D.Lellouch     Open output DAD list as well.
*.  5-Fev-91  S.Weisz        Temporary comment of AUTOUNIT.
*. 23-Jan-91  D.Lellouch     Further IO initialisation for automatic
*.                           LUN allocation and output preparation.
*. 29-Oct-90  A.Lee          Open DADlist at beginning of routine.
*. 11-Oct-90  A.Lee          Open DADlist too (only input implemented).
*. 24-Mar-90  S.Weisz        Default JDCHOP for undeclared input file.
*. 13-Oct-89  S.Weisz        Close input files when finished with them.
*.  7-Sep-89  S.Weisz        Handle SCAN stream.
*. 23-Jun-89  S.Weisz        Take care of connection to DAQ case.
*. 12-Jun-89  S.Weisz        Initialize IOCCRV, implement Prod. files.
*. 12-May-89  S.Weisz        Copy RCO structure on Data streams in
*.                           RGETCA, once updated for calibration.
*.  8-Fev-89  S.Weisz        Metafile and bank documentation are open
*.                           by GR whenever needed.
*.  7-Fev-89  S.Weisz        Set ZEBRA log level selected by Ffread
*.                           card ZLOGLEV.
*.                           Handle bank documentation RZ file.
*.  1-Fev-89  S.Weisz        Implement multiple calibration files,
*.                           call to OCINI now in ROOPEN.
*.  6-Jan-89  S.Weisz        Implement constant, overflow, ... files.
*.                           Metafile, Bank doc (DZDOC) still missing!
*. 27-Jun-88  S.Weisz        Open Calibration file, call OCINI.
*.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER LURAWD
      PARAMETER (LURAWD=56)
      INTEGER LIOHD,LIOII,LIOCI,LIODI, LIOCA,LIOHB,LUINIT,LUCNST
C     INTEGER LIOBK,LIOME
      INTEGER IER, IHKEY, ND, LNBLNK
      CHARACTER*4 CHTNAM
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,ROUNIT.
+SEQ,RCREP.
+SEQ,CRVER.
+SEQ,RECNTL.
*
      IF(NPRTMX(1).LT.0)THEN
         WRITE(CHREP,'(A)')
     +   'Suppress printing in RMAIL, change unit to 7'
         CALL REPORT('RIOSET',11,'W')
         LROUT=7
      ENDIF
*-- First set ZEBRA log level.
      CALL MZLOGL(IXSTOR,IZLOGL)
CCCCCC Temporary comment.
*-- Print a nice table if automatic logical unit allocation.
C     IF(LAUTOU) CALL ROPUNI(LROUT)
CCCCCC End of temporary comment.
*-- Multi stream operation: update 'DCHOPT' parameters!
      CALL ROPREP
*-- Start with INIT structure.
      LUINIT = 0
      LIOHD  = LQ(LUTC-LLIOHD)
      LIOII  = LQ(LIOHD-LLIOII)
      IF(LIOII.NE.0) THEN
*-- Open the file. Stop if it fails.
         CALL ROOPEN('INIT',IER)
         IF(IER.NE.0) THEN
            CHREP = 'Could not open INIT file, stop!'
            CALL REPORT('RIOSET',1,'C')
         END IF
*-- Fetch the INIT structure. Stop if it fails.
         LUINIT = IQ(LIOII+JLUN)
         CALL RGETIN(LUINIT,IER)
         IF(IER.NE.0) THEN
            CHREP = 'Could not find INIT structure'
            CALL REPORT('RIOSET',2,'C')
         END IF
         CALL FZENDI(LUINIT,'T')
         CLOSE(LUINIT)
      END IF
      CALL ROOPEN('DICT',IER)
*-- Establish the output, copy, DST and overflow units.
*-- If this fails, go on anyway.
      CALL ROOPEN('OUTPUT',IER)
      CALL ROOPEN('COPY',IER)
      CALL ROOPEN('DST',IER)
      CALL ROOPEN('DDST',IER)
      CALL ROOPEN('OVER',IER)
      CALL ROOPEN('PROD',IER)
      CALL ROOPEN('SCAN',IER)
      CALL ROOPEN('DADOUT',IER)
*-- Now get Constant structure.
      LUCNST = 0
      LIOHD  = LQ(LUTC-LLIOHD)
      LIOCI  = LQ(LIOHD-LLIOCI)
      IF(LIOCI.NE.0) THEN
*-- Open the file. Stop if it fails.
         CALL ROOPEN('CNST',IER)
         IF(IER.NE.0) THEN
            CHREP = 'Could not open Constant file, stop!'
            CALL REPORT('RIOSET',3,'C')
         END IF
*-- Fetch the Constant structure. Stop if it fails.
         LUCNST = IQ(LIOCI+JLUN)
         CALL RGETCO(LUCNST,IER)
         IF(IER.NE.0) THEN
            CHREP = 'Pb. with Constant structure'
            CALL REPORT('RIOSET',4,'C')
         END IF
      END IF
*-- Establish the first input.
      LIOHD = LQ(LUTC-LLIOHD)
      LIODI = LQ(LIOHD-LLIODI)
*-- If linked with On-line code, do not define default input unit.
      IF(LIODI.LE.0.AND.IVON.EQ.0) THEN
*-- Create a default bank for unit LURAWD if none exists.
         CALL MZBOOK(IROCON,LIODI,LIOHD,-LLIODI,'IODI',NLIOXX,NSIOXX,
     +   NDIOXX,IOIOXX,0)
         IQ(LIODI+JLUN) = LURAWD
         CALL UCTOH('I   ',IQ(LIODI+JFCHOP),4,4)
         IQ(LIODI+JDCHOP) = 1
         CALL UCTOH('OLD ',IQ(LIODI+JFSTAT),4,4)
      END IF
      IF(LIODI.LE.0) THEN
*-- End reading of Constant file if any.
         IF(LUCNST.NE.0) THEN
            CALL FZENDI(LUCNST,'T')
            CLOSE(LUCNST)
         END IF
*-- Check if first input file already open (Constant file).
      ELSE IF(IQ(LIODI+JLUN).NE.LUCNST) THEN
*-- End reading of Constant file if any.
         IF(LUCNST.NE.0) THEN
            CALL FZENDI(LUCNST,'T')
            CLOSE(LUCNST)
         END IF
*-- Open first input file.
         CALL ROOPEN('INPUT',IER)
*-- Give up if the input files cannot be opened.
         IF(IER.NE.0) THEN
            CHREP = 'Could not open INPUT file, stop!'
            CALL REPORT('RIOSET',5,'C')
         END IF
      ELSE
*-- Set active flag for this stream.
         IQ(LIODI+JACTIV) = 1
      END IF
*-- Continue with CAL structure.
      LIOHD = LQ(LUTC-LLIOHD)
      LIOCA = LQ(LIOHD-LLIOCA)
*-- Look if a SUDB file is defined, if not do it
10    CONTINUE
      IF(LIOCA.NE.0)THEN
         CALL UHTOC(IQ(LIOCA+JDCHOP),4,CHTNAM,4)
         IF(CHTNAM.EQ.'SUDB')THEN
            IF(IVSU.EQ.0)THEN
               CHREP='SUDB file defined, but SU not loaded'
               CALL REPORT('RIOSET',6,'W')
            ENDIF
                                                                 GOTO 20
         ELSE
            LIOCA=LQ(LIOCA)
                                                                 GOTO 10
         ENDIF
      ELSE
*-- IF SU not loaded continue
         IF(IVSU.EQ.0)THEN
                                                                 GOTO 20
         ELSE
*-- Define a default file name and fake a *SUDB FFREAD card
            CALL VBLANK(LFINAM,NAMLWO)
+SELF,IF=IBM.
            CALL UCTOH('SUDB.RZDATA',LFINAM,4,11)
+SELF,IF=UNIX.
*-- Get value of enviroment variable
            CALL GETENVF('OPAL_P_DB',CHREP)
            ND=LNBLNK(CHREP)
            IF(ND.LE.0)THEN
               CHREP='OPAL_P_DB is not defined'
               CALL REPORT('RIOSET',7,'W')
                                                                 GOTO 20
            ENDIF
            CALL UCTOH(CHREP(1:ND)//'/sudb.rzdata',LFINAM,4,ND+12)
+SELF,IF=VAX,QMALPH.
            CALL UCTOH('O$ROPE:SUDB.RZDATA',LFINAM,4,18)
+SELF.
            CALL UCTOH('SUDB',IHKEY,4,4)
            CALL RFUSER(IHKEY)
         ENDIF
      ENDIF
20    CONTINUE
*-- Open the file. Stop if it fails.
      LIOCA = LQ(LIOHD-LLIOCA)
+SELF,IF=ONLINE.
      CHREP = 'Calibration file will be opened at start-of-run.'
      CALL REPORT('RIOSET',6,'I')
+SELF,IF=-ONLINE.
      IF(LIOCA.NE.0) THEN
         CALL ROOPEN('CAL',IER)
         IF(IER.NE.0) THEN
            CHREP = 'Could not open CALibration file, stop!'
            CALL REPORT('RIOSET',7,'C')
         END IF
      END IF
+SELF.
*-- Open HBOOK RZ file.
      LIOHD = LQ(LUTC-LLIOHD)
      LIOHB = LQ(LIOHD-LLIOHB)
      IF(LIOHB.NE.0) THEN
         CALL ROOPEN('HISTO',IER)
         IF(IER.NE.0) THEN
            CHREP = 'Problem with HBOOK RZ file, go on anyway'
            CALL REPORT('RIOSET',8,'W')
         END IF
      END IF
*-- Bank documentation and metafile are opened in GR, comment code
*-- until further notice.
*-- Open bank documentation RZ file.
C     LIOHD = LQ(LUTC-LLIOHD)
C     LIOBK = LQ(LIOHD-LLIOBK)
C     IF(LIOBK.NE.0) THEN
C        CALL ROOPEN('BANK',IER)
C        IF(IER.NE.0) THEN
C           CHREP = 'Problem with BANK doc RZ file, go on anyway'
C           CALL REPORT('RIOSET',9,'W')
C        END IF
C     END IF
*-- Open metafile.
C     LIOHD = LQ(LUTC-LLIOHD)
C     LIOME = LQ(LIOHD-LLIOME)
C     IF(LIOME.NE.0) THEN
C        CALL ROOPEN('META',IER)
C        IF(IER.NE.0) THEN
C           CHREP = 'Problem with metafile opening, go on anyway'
C           CALL REPORT('RIOSET',10,'W')
C        END IF
C     END IF
*
      RETURN
      END
+DECK,RMOUNTV,IF=VAX.
      SUBROUTINE RMOUNT(CHNAME,LIOBNK,LTAPE,RC)
*.
*...RMOUNT Mounts the tape described at location LIOBNK
*.         and returns the true file name
*.
*. SEQUENCE:  ROBANK ROCPAR RCNTRL ROUNIT RBITFUNC RCREP
*. CALLS   :  ROMOUN SPACES CLTOU RSBWRD LENOCC
*. CALLED  :  ROOFLX
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 5-Nov-97
*.
*. Modification Log.
*.   5-Nov-97 M.Schroder   reduce number of pre-staged files to ten
*.  27-Aug-91  S.Weisz      Use RBITFUNC sequence
*.
*.**********************************************************************
+SEQ,DECLARE.
      LOGICAL       LTAPE,NEWCRT
      CHARACTER*80  CHNAME,SPACES
      CHARACTER*16  DEVICE
      CHARACTER*6   LABEL
      INTEGER       I,I1,I2,I3,I4,I5,RC,LFREE,LIOBNK,LENOCC,N
+SEQ,RCREP.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,RBITFUNC.
*-- Extract the device name, the label name and the true file name
*-- Look for the pattern:  device:[label]file_name
      RC     = 1
      NEWCRT = BTEST(IQ(LIOBNK+JFLAGS),NEWTAP)
      CALL CLTOU(CHNAME)
      CHNAME = SPACES(CHNAME,1)
      CALL RSBWRD(CHNAME,1,I4,I5)
      I1     = INDEX(CHNAME,':')
      I2     = INDEX(CHNAME,'[')
      IF(I1.EQ.0) THEN
                                                                GO TO 30
      ELSE IF(I2.EQ.0) THEN
         I4     = I1 + 1
         LABEL  = ' '
      ELSE
         I3     = INDEX(CHNAME,']')
         IF(I3.EQ.0) THEN
                                                                GO TO 30
         ELSE IF(I3.EQ.I2+1) THEN
            LABEL  = ' '
         ELSE
            LABEL  = CHNAME(I2+1:I3-1)
         END IF
         I4     = I3 + 1
      END IF
      DEVICE = CHNAME(1:I1)
      N      = ICHAR(DEVICE(1:1)) - 48
      IF(I1.EQ.2.AND.N.GE.1.AND.N.LE.NXDEVI) THEN
*-- The device name was given as 'n:'
         I      = EXADEV(N)
         IF(I.EQ.0) THEN
            CHREP  = 'Device '//DEVICE(1:1)
     +               //' not allocated by a *GETDEVICE card'
            CALL REPORT('RMOUNT',1,'E')
                                                               GO TO 999
         END IF
         DEVICE = DVNAME(I)
      ELSE
*-- Device name was hard-coded in the *FILE card
*-- Find a free device
         LFREE  = 0
         DO 10 I=1,NXDEVI
         IF(DVNAME(I).EQ.DEVICE) THEN
                                                                GO TO 20
         ELSE IF(.NOT.LDVALL(I)) THEN
            IF (LFREE.EQ.0) LFREE=I
         END IF
   10    CONTINUE
         IF(LFREE.EQ.0) THEN
            CHREP  = 'Sorry, no free devices!'
                                                                GO TO 40
         END IF
*-- Allocate the device
         I      = LFREE
         LDVALL(LFREE) = .TRUE.
         DVNAME(LFREE) = DEVICE
         TAPMOU(LFREE) = '???'
         CALL ROMOUN('A',DEVICE,' ',LTAPE,RC)
         IF(RC.NE.0)                                           GO TO 999
      END IF
*-- Dismount the previous tape from the current drive?
   20 NEWCRT = NEWCRT.OR.LABEL.NE.TAPMOU(I)
      IF(TAPMOU(I).NE.'???'.AND.NEWCRT) THEN
         CALL ROMOUN('D',DEVICE,TAPMOU(I),LTAPE,RC)
         IF(RC.NE.0)                                           GO TO 999
         TAPMOU(I) = '???'
      END IF
*-- Mount the tape?
      CHNAME = DEVICE(1:LENOCC(DEVICE))//CHNAME(I4:I5)
      IF(NEWCRT) THEN
         CHREP  = 'No operator on this Vax. YOU have to mount tape '//
     +            LABEL//' on device '//DEVICE
         CALL REPORT('RMOUNT',2,'N')
         CALL ROMOUN('M',DEVICE,LABEL,LTAPE,RC)
         IF(RC.NE.0)                                           GO TO 999
      END IF
      TAPMOU(I) = LABEL
      RC     = 0
                                                               GO TO 999
   30 CHREP  = 'Wrong syntax, should be like: device:[label]file.name'
   40 CALL REPORT('RMOUNT',3,'E')
*
  999 RETURN
      END
+DECK,RMOUNT,IF=IBM.
      SUBROUTINE RMOUNT(LIOBNK,CHLUN,DESCRI,LREAD,IER)
*.
*...RMOUNT Mounts the tape described at location LIOBNK
*.         and calls it 'CHLUN'
*.
*. SEQUENCE:  ROBANK RCNTRL ROCPAR ROUNIT RCSYST RBITFUNC ROWORD RCREP
*. CALLS   :  RQSYST LENOCC RSBWRD
*. CALLED  :  ROOFLX
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 20-Aug-92
*.
*. Modification Log.
*. 28-Jun-93  G.Patrick  Mods for RAL tape handling
*. 20-Aug-92  O.Schaile  make mount command site dependent (RAL)
*. 17-Aug-92  O.Schaile  redo previous mod, doesnt work at CERN
*.  6-Jul-92  G.Patrick  Separate setup mount
*. 27-Aug-91  S.Weisz    Use RBITFUNC sequence
*. 14-Fev-91  S.Weisz    Add some return code.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER       LIOBNK,IER,I,I1,I2,L,IDEV,IFLAGS,LENOCC
      CHARACTER*(*) CHLUN,DESCRI
      CHARACTER*1   LASTLT
      CHARACTER*6   RING,FSEQ,TAPE
      CHARACTER*8   FID
      CHARACTER*80  CFNAME
      LOGICAL       LREAD
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCREP.
*
      IFLAGS = IQ(LIOBNK+JFLAGS)
      CALL UHTOC(IQ(LIOBNK+JFNAME),NBYTEW,CFNAME,NAMLEN)
*-- Build the 'SETUP' card unless tape is already mounted
      IF(BTEST(IFLAGS,SAMTAP)) THEN
         IDEV   = IQ(LIOBNK+JDEVIC)
         CHREP  = 'Tape '//TAPE//' already on device '//DVNAME(IDEV)
         CALL REPORT('RMOUNT',0,'I')
      ELSE
*-- Find a free i/o channel
         DO 10 IDEV = 1,NXDEVI
         IF(.NOT.LDVALL(IDEV))                                  GO TO 20
   10    CONTINUE
         CHREP  = 'All cartridge i/o channels are already taken'
         CALL REPORT('RMOUNT',1,'E')
         SYSRC  = 1234
                                                                GO TO 30
   20    IQ(LIOBNK+JDEVIC) = IDEV
         LDVALL(IDEV) = .TRUE.
         SYSCOM = 'SETUP CT1 '//DVNAME(IDEV)
         L      = LENOCC(SYSCOM)
         CALL RSBWRD(CFNAME,1,I1,I2)
         TAPE   = CFNAME(I1:I2)
         SYSCOM = SYSCOM(1:L)//' '//TAPE
         IF(LREAD) THEN
            RING   = 'NORING'
         ELSE
            RING   = 'RING'
         END IF
         L      = LENOCC(SYSCOM)
         IF(CHNODE.EQ.'UKACRL')THEN
            SYSCOM = SYSCOM(1:L)//' '//RING//' SL NOMOUNT (END'
         ELSE
            SYSCOM = SYSCOM(1:L)//' '//RING//' SL (END'
         ENDIF
         CHREP  = 'Mounting tape '//TAPE//' on device '//DVNAME(IDEV)
         CALL REPORT('RMOUNT',0,'I')
         CALL RQSYST(.TRUE.)
         IF(SYSRC.NE.0)                                         GO TO 30
         IF(CHNODE.EQ.'UKACRL')THEN
            SYSCOM = 'MOUNT '//TAPE//' '//DVNAME(IDEV)
            CALL RQSYST(.TRUE.)
            IF(SYSRC.NE.0)                                      GO TO 30
         ENDIF
      END IF
      LASTLT = DVNAME(IDEV)(3:3)
*-- Build the 'FILEDEF' card
*-- Try and find the File Sequence
      I      = INDEX(CFNAME,' FSEQ ')
      IF(I.EQ.0) THEN
         FSEQ   = '1'
      ELSE
         CALL RSBWRD(CFNAME(I:LEN(CFNAME)),2,I1,I2)
         FSEQ   = CFNAME(I+I1-1:I+I2-1)
      END IF
      SYSCOM = 'FILEDEF '//CHLUN//' CLEAR'
      CALL RQSYST(.FALSE.)
      L      = LENOCC(DESCRI)
      IF(CHNODE.EQ.'UKACRL') THEN
         SYSCOM = 'FILEDEF '//CHLUN//' TAP'//LASTLT//' SL '//FSEQ
     +       //' ( '//DESCRI(1:L)//' '
      ELSE
         SYSCOM = 'FILEDEF '//CHLUN//' TAP'//LASTLT//' SL '//FSEQ
     +       //' VOLID '//TAPE//' ( '//DESCRI(1:L)//' '
      ENDIF
      CALL RQSYST(.TRUE.)
      IF(SYSRC.NE.0)                                            GO TO 30
*-- Build the 'LABELDEF' card
*-- Was the FID given?
      I      = INDEX(CFNAME,' FID ')
      IF(I.NE.0) THEN
         CALL RSBWRD(CFNAME(I:LEN(CFNAME)),2,I1,I2)
         FID    = CFNAME(I+I1-1:I+I2-1)
         SYSCOM = 'LABELDEF '//CHLUN//' CLEAR'
         CALL RQSYST(.FALSE.)
         SYSCOM = 'LABELDEF '//CHLUN//' VOLID '//TAPE
     +            //' FID '//FID
         CALL RQSYST(.TRUE.)
         IF(SYSRC.NE.0)                                         GO TO 30
      END IF
*-- Everything went fine
      IER    = 0
                                                               GO TO 999
   30 CHREP  = 'Could not mount the tape:'//CFNAME(1:LENOCC(CFNAME))
      CALL REPORT('RMOUNT',2,'E')
      IER    = SYSRC
*
  999 RETURN
      END
+DECK,RMULFI.
      SUBROUTINE RMULFI(ICASE)
*.
*...RMULFI Handle *FILE FFREAD cards when wild-cards are given
*.
*. SEQUENCE: RCNTRL ROWORD RCSYST RCREP RCLINE
*. CALLS   : SPACES CLTOU LIB$FIND_FILE LIB$FIND_FILE_END REPORT RMAIL
*.           RIOFIL
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch and F.Odorici
*. VERSION : 1.01
*. CREATED : 18-Nov-90
*. LAST MOD :   6-Nov-95
*.
*. Modification Log.
*.  5-Nov-95  O.Schaile  Use sflist instead of sfsh
*.  24-Apr-94 M.Schroder   same sfsh for all UNIX (no rsh)
*.  22-Jul-92 B.Panzer     modif call to sfsh on SHIFT
*.  24-Mar-92 J.Banks      allow sfget from HPUX
*.  14-Feb-92 D.Lellouch Enhance the Unix pool facility
*.  10-Dec-1991 O.Schaile Init NFOUND
* 24-May-91 D.Lellouch   Handle *EVTFILE (ICASE=4), *NANOFILE (ICASE=3)
*   27-Apr-1991 D.Lellouch Vax: allow  ....:[directory]file.spec[n1:n2]
*.  25-Apr-1991 S.Weisz    Sort files on IBM.
*.  16-Apr-1991 D.Lellouch Can be called from RIODAD as well (ICASE=2)
*.   5-Mar-1991 T.Mouthuy  Implement for SHIFT too
*.  13-Dec-1990 F.Odorici  Use LIB$FIND_FILE for wild-card file searching
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER      MAXLIN
      PARAMETER   (MAXLIN=1000)
*
      CHARACTER*1  MODE
      CHARACTER*4  CFIDCH
      CHARACTER*10 POOL,USER
      CHARACTER*80 CFNAME,SPACES,DISK,CFOUND
      CHARACTER*80 FILENA(MAXLIN)
+SELF,IF=VAX.
      INTEGER LIB$FIND_FILE,LIB$FIND_FILE_END,INFO,CONTXT
      INCLUDE '($RMSDEF)'
+SELF.
      INTEGER ICASE,I,I1,I2,J1,J2,N1,N2,L,W,NFOUND,NFILE,ACTUAL,IER
      INTEGER LENOCC,RWORDS
      LOGICAL LVARI,VERBOS,POOLFI
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROWORD.
+SEQ,RCSYST.
+SEQ,RCREP.
+SEQ,RCLINE.
*
      EQUIVALENCE (WS(1),FILENA(1))
*
      NFOUND=0
      IF(ICASE.EQ.1) THEN
         CALL UHTOC(LFINAM,NBYTEW,CFNAME,NAMLEN)
      ELSE IF(ICASE.EQ.2) THEN
         CALL UHTOC(LDANAM,NBYTEW,CFNAME,NAMLEN)
      ELSE IF(ICASE.EQ.3) THEN
         CALL UHTOC(LNANAM,NBYTEW,CFNAME,NAMLEN)
      ELSE IF(ICASE.EQ.4) THEN
         CALL UHTOC(LEVNAM,NBYTEW,CFNAME,NAMLEN)
      ELSE
         CHREP  = 'This case is not handled in RMULFI'
         CALL REPORT('RMULFI',1,'ERROR')
                                                                GO TO 90
      END IF
      CFNAME = SPACES(CFNAME,1)
      CALL ROVANA(CFNAME,LVARI)
      IF(LVARI)                                                 GO TO 50
+SELF,IF=NOUNIX.
      CALL CLTOU(CFNAME)
+SELF,IF=IBM.
      CALL RTRANS(CFNAME,'.',' ')
*-- Now decode disk request [user.cuu]
      MODE   = '*'
      IF(CFNAME(1:1).EQ.'[') THEN
         I1     = INDEX(CFNAME,']')
         IF(I1.LE.1) THEN
            CHREP  = 'Invalid disk specification'
            CALL REPORT('RMULFI',2,'E')
                                                                GO TO 90
         END IF
         DISK   = CFNAME(2:I1-1)
         CFNAME = CFNAME(I1+1:NAMLEN)
         CFNAME = SPACES(CFNAME,1)
         CALL RGIMED(DISK,MODE)
         IF(MODE.EQ.' ')                                        GO TO 90
      END IF
+SELF,IF=UNIX.
      IF(CFNAME(1:1).EQ.'[') THEN
*-- This is a pool file
         POOLFI = .TRUE.
         I      = INDEX(CFNAME(1:NAMLEN),']')
         IF(I.EQ.0) THEN
            CHREP  = 'Invalid pool specification '
            CALL REPORT('RMULFI',3,'E')
                                                                GO TO 90
         ENDIF
         I1     = INDEX(CFNAME(1:I-1),'.')
*   [ ] means opaldata.opal
*   [pool] means pool.opal
*          unless pool=opalcnst --> user=opalcal
*                 pool=opaldata --> user=opal
         POOL=' '
         USER=' '
         IF(I1.EQ.0) THEN
           IF(I.GT.2) POOL=CFNAME(2:I-1)
         ELSE
           IF(I1.GT.2) POOL=CFNAME(2:I1-1)
           IF(I1.LT.I-1) USER=CFNAME(I1+1:I-1)
         END IF
*-- Normally all pools and user names are in lower case.
         CALL CUTOL(POOL)
         CALL CUTOL(USER)
         IF(USER.EQ.' ') THEN
            IF(POOL.EQ.' '.OR.POOL.EQ.'opaldata') THEN
               POOL='opaldata'
               USER='opal'
            ELSEIF(POOL.EQ.'opalcnst') THEN
               USER='opalcal'
            ELSE
               USER='"  "'
            END IF
         END IF
         CFNAME = CFNAME(I+1:NAMLEN)
      ELSE
         POOLFI = .FALSE.
      ENDIF
+SELF.
*-- Now decode occurence specification [n1:n2]
      I1     = INDEX(CFNAME,'[')
      I2     = LENOCC(CFNAME)
+SELF,IF=VAX.
*-- It might be a ...[directory]file.specif[n1:n2] pattern
      J2     = INDEX(CFNAME,']')
      IF(J2.NE.I2.AND.J2.GT.0) THEN
         J1     = INDEX(CFNAME(J2+1:80),'[')
         IF(J1.EQ.0) THEN
            I1     = 0
         ELSE
            I1     = J2 + J1
         END IF
      END IF
+SELF.
      IF(I1.EQ.0) THEN
         N1     =     1
         N2     =  9999
      ELSE IF(CFNAME(I2:I2).EQ.']') THEN
         CALL ROFIRL(CFNAME(I1+1:I2-1),N1,N2,IER)
         IF(IER.EQ.0) THEN
            CFNAME = CFNAME(1:I1-1)
         ELSE
            CHREP  = 'Invalid [...] specification'
            CALL REPORT('RMULFI',4,'E')
                                                                GO TO 90
         END IF
      ELSE
         CHREP  = 'Unbalanced "["'
         CALL REPORT('RMULFI',5,'E')
                                                                GO TO 90
      END IF
+SELF,IF=IBM.
      W      = RWORDS(CFNAME)
      IF(W.LE.1) THEN
                                                                GO TO 70
      ELSE IF(W.EQ.2) THEN
         CFNAME = CFNAME(1:LENOCC(CFNAME))//' '//MODE
      ELSE IF(W.EQ.3) THEN
         IF(MODE.NE.'*')                                        GO TO 70
      ELSE
                                                                GO TO 70
      END IF
      SYSCOM = 'LFILE '//CFNAME(1:LENOCC(CFNAME))//' (FILEC STACK'
      CALL RQSYST(.FALSE.)
      IF(SYSRC.EQ.28) THEN
                                                                GO TO 60
      ELSE IF(SYSRC.NE.0) THEN
         CHREP  = 'Strange error while matching your search criteria'
         CALL REPORT('RMULFI',6,'E')
                                                                GO TO 90
      END IF
+SELF,IF=UNIX.
*-- Now start a system request to obtain a list of files
      IF(POOLFI) THEN
         WRITE(SYSCOM,1000) POOL,USER,CFNAME(1:60)
      ELSE
         WRITE(SYSCOM,1010) CFNAME(1:60)
      ENDIF
+SELF.
*-- Terse or verbose?
      CALL UHTOC(LFIDCH,4,CFIDCH,4)
      VERBOS = INDEX(CFIDCH,'Q').EQ.0
      ACTUAL = 0
+SELF,IF=IBM.
      CALL VMRTRM(CFOUND,L)
      READ(CFOUND,*) NFOUND
+SELF,IF=VAX.
      NFOUND = MAXLIN
      CONTXT =      0
+SELF,IF=UNIX.
      CALL RQSYST(.FALSE.)
      NFOUND = MAXLIN
      OPEN(UNIT=99,FILE='temp.file',STATUS='OLD')
+SELF.
      NFILE  =     0
      IF(NFOUND.LE.0)                                           GO TO 60
      IF(NFOUND.GT.MAXLIN) THEN
         WRITE(CHREP,1020) MAXLIN,MAXLIN
         CALL REPORT('RMULFI',7,'W')
         NFOUND = MAXLIN
      END IF
*-- Make space to receive all file names
      CALL MZWORK(IXSTOR,WS(1),WS(20*MAXLIN),0)
*
      DO 10 I=1,NFOUND
+SELF,IF=IBM.
         CALL VMRTRM(FILENA(I),L)
         NFILE  = NFILE + 1
+SELF,IF=VAX.
         INFO = LIB$FIND_FILE(CFNAME,FILENA(I),CONTXT)
         IF(.NOT.INFO) THEN
            IF(INFO.EQ.RMS$_NMF)                                GO TO 20
                                                                GO TO 80
         END IF
         NFILE = NFILE + 1
+SELF,IF=UNIX.
*-- In all cases, the file temp.file contains the explicit path to
*-- the filename
         READ(99,'(A)',ERR=40,END=20) FILENA(I)
         NFILE = NFILE + 1
+SELF.
   10 CONTINUE
+SELF,IF=UNIX.
   20 CONTINUE
+SELF,IF=NOUNIX.
   20 IF(NFILE .LE.0)                                           GO TO 60
*-- We have to sort the file names on some stupid systems!
+SELF,IF=IBM.
      CALL SORCHA(FILENA,1,80,NFILE,1)
+SELF.
      DO 30 I = 1,NFILE
         IF(I.GE.N1.AND.I.LE.N2) THEN
            ACTUAL = 1 + ACTUAL
+SELF,IF=UNIX.
*-- Reconstruct the full name in case it was a pool file
            IF(POOLFI) THEN
               CFNAME = '['//POOL(1:LENOCC(POOL))//
     +                  '.'//USER(1:LENOCC(USER))//
     +                  ']'//FILENA(I)
               FILENA(I) = CFNAME(1:LENOCC(CFNAME))
            END IF
+SELF.
            IF(VERBOS) THEN
               WRITE(CHLINE,1030) ACTUAL,FILENA(I)(1:LENOCC(FILENA))
               CALL RMAIL(0,0)
            END IF
            IF(ICASE.EQ.1) THEN
               CALL UCTOH(FILENA(I),LFINAM,NBYTEW,NAMLEN)
               CALL RIOFIL
            ELSE IF(ICASE.EQ.2) THEN
               CALL UCTOH(FILENA(I),LDANAM,NBYTEW,NAMLEN)
               CALL RIODAD
            ELSE IF(ICASE.EQ.3) THEN
               CALL UCTOH(FILENA(I),LNANAM,NBYTEW,NAMLEN)
               CALL RIONAN
            ELSE IF(ICASE.EQ.4) THEN
               CALL UCTOH(FILENA(I),LEVNAM,NBYTEW,NAMLEN)
               CALL RIOEVL
            END IF
         END IF
   30 CONTINUE
*
+SELF,IF=VAX.
      INFO = LIB$FIND_FILE_END(CONTXT)
      IF(.NOT.INFO)                                             GO TO 80
+SELF,IF=UNIX.
   40 CLOSE(UNIT=99,STATUS='DELETE')
      IF(NFILE.EQ.0)                                            GO TO 60
+SELF.
      IF(ACTUAL.GT.0)                                          GO TO 999
      CHREP  = 'No file satisfies your occurence criteria'
      CALL REPORT('RMULFI',8,'E')
                                                                GO TO 90
   50 CHREP  = 'This variable name is not allowed'
      CALL REPORT('RMULFI',9,'E')
                                                                GO TO 90
   60 CHREP  = 'No file satisfies your search criteria'
      CALL REPORT('RMULFI',10,'E')
+SELF,IF=IBM.
                                                                GO TO 90
   70 CHREP  = 'Invalid Fn Ft [Fm]: wrong number of words'
      CALL REPORT('RMULFI',11,'E')
+SELF,IF=VAX.
                                                                GO TO 90
   80 CHREP  = 'Internal error while processing wild carding:'//CFNAME
      CALL REPORT('RMULFI',12,'E')
+SELF.
   90 FFERRO = .TRUE.
  999 CONTINUE
*
      RETURN
+SELF,IF=UNIX.
 1000 FORMAT('sflist -p ',A10,' -u ',A10,'''',A,'''|sort>temp.file')
 1010 FORMAT('/bin/ls ',A60,' > temp.file ')
+SELF.
 1020 FORMAT('System found more than ',I4,' files, only ',I4,
     +       ' first kept')
 1030 FORMAT(26X,I4,' --> ',A)
      END
+DECK,RNWNAM.
      SUBROUTINE RNWNAM(LUN,CHFIN,CHFOUT,BEFORE)
*.
*...RNWNAM Change the name of an output according to possible
*.         predefined keywods. So far: <trig> <n> <run>
*.         If BEFORE changes it to some predefined dummy name
*. SEQUENCE: CRO ROUNIT RCSYST
*. CALLS   : RTRANS RWORDS LENOCC RLASPO
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 24-Apr-95
*.
*. Modification Log.
*.  24-Apr-95 M.Schroder  same sfget for IBMRT,HPUX,APOOLO (no rsh)
*.  14-Sep-93 M.Redmond   Use remsh with sfget on Apollos
*.  24-Mar-92 J.Banks      allow sfget from HPUX
*.  11-Dec-91 T.Mouthuy   Modify SFGET call to special interface
*.  12-Mar-1991 T.Mouthuy Implement for SHIFT too
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER        LUN,I,I1,I2
      INTEGER        LENOCC,RLASPO,RWORDS
      CHARACTER*(*)  CHFIN,CHFOUT
      CHARACTER*1    MODE
      CHARACTER*3    CHN
      CHARACTER*5    CHRUN
      CHARACTER*6    CHTRIG
      CHARACTER*10   POOL,USER
      CHARACTER*80   SFNAME
      LOGICAL        BEFORE
+SEQ,CRO.
+SEQ,ROUNIT.
+SEQ,RCSYST.
*
      IF(BEFORE) THEN
+SELF,IF=IBM.
*-- IBM: find in which disk to write the temporary name file
         IF(RWORDS(CHFIN).EQ.2) THEN
            MODE   = 'A'
         ELSE
            CALL RSBWRD(CHFIN,3,I1,I2)
            MODE   = CHFIN(I1:I2)
         END IF
         WRITE(CHFOUT,1000) LUN,NFZUSE(LUN),MODE
+SELF,IF=VAX.
*-- Vax: extract the directory name
         I1     = INDEX(CHFIN,']')
         I2     = RLASPO(CHFIN,':')
         I      = MAX0(I1,I2)
+SELF,IF=UNIX.
*-- Apollo: the directory spans up to last '/'
         I      = RLASPO(CHFIN,'/')
         I2     = RLASPO(CHFIN,']')
         I      = MAX0(I,I2)
+SELF,IF=VAX,UNIX.
         IF(I.EQ.0) THEN
            WRITE(CHFOUT,1010) LUN,NFZUSE(LUN)
         ELSE
            WRITE(CHFOUT,1020) CHFIN(1:I),LUN,NFZUSE(LUN)
         END IF
+SELF.
      ELSE
         CHFOUT = CHFIN
         WRITE(CHN,1030) NFZUSE(LUN)
         CALL RTRANS(CHFOUT,'<N>',CHN)
         WRITE(CHRUN,1040) IRDRUN
         CALL RTRANS(CHFOUT,'<RUN>',CHRUN)
         WRITE(CHTRIG,1050) IRDEVT
         CALL RTRANS(CHFOUT,'<TRIG>',CHTRIG)
+SELF,IF=IBM.
         IF(RWORDS(CHFOUT).EQ.2) CHFOUT = CHFOUT(1:LENOCC(CHFOUT))//' A'
+SELF.
      END IF
+SELF,IF=UNIX,SHIFT.
      IF(CHFOUT(1:1).EQ.'[') THEN
         I = INDEX(CHFOUT(1:80),']')
         I2 = INDEX(CHFOUT(1:I-1),'.')
         IF(I2.EQ.0.OR.I2.EQ.I-1) THEN
*-- Only pool name has been given
            POOL = CHFOUT(2:I-1)
            USER = 'OPALDATA'
         ELSE
            POOL = CHFOUT(2:I2-1)
            USER = CHFOUT(I2+1:I-1)
         ENDIF
         CALL CUTOL(POOL)
         CALL CUTOL(USER)
+SELF,IF=UNIX,IF=-SHIFT.
*** &&&+SELF,IF=APOLLO,HPUX,IBMRT,SUN,DECS.
         SFNAME = CHFOUT(I+1:80)
         WRITE(SYSCOM,1060) POOL,USER,SFNAME
         CALL RQSYST(.FALSE.)
         OPEN(UNIT=99,FILE='temp.file',STATUS='OLD')
         READ(99,'(A80)',ERR=60,END=60) CHFOUT
         SYSCOM = '/bin/rm temp.file'
         CALL RQSYST(.FALSE.)
         CLOSE(UNIT=99)
+SELF,IF=SHIFT.
         CALL OPFPUT(POOL,USER,SFNAME,CHFOUT)
+SELF,IF=UNIX,SHIFT.
      ENDIF
   60 CONTINUE
+SELF.
*
      RETURN
 1000 FORMAT('/FILE',I2.2,' DUM',I5.5,1X,A)
 1010 FORMAT('FILE',I2.2,'.DUM',I5.5)
 1020 FORMAT(A,'FILE',I2.2,'.DUM',I5.5)
 1030 FORMAT(I3.3)
 1040 FORMAT(I5.5)
 1050 FORMAT(I6.6)
+SELF,IF=UNIX,IF=-SHIFT.
 1060 FORMAT('sfget -s 0 -p ',A10,' -u ',A10,A60,' > temp.file ')
+SELF.
      END
+DECK,ROCALL.
      SUBROUTINE ROCALL(CHPROC)
*.
*...ROCALL Call individual processors
*.
*. SEQUENCE: ROBANK RCNTRL CRO RODPAR
*. CALLS   : XXBAT
*. CALLED  : ROPBAT
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 21-Jan-91
*. LAST MOD: 28-Sep-93
*.
*. Modification Log.
*. 28-Sep-93  O.Schaile      Call LMBAT again right after FD
*.  3-Mar-93  O.Schaile      Introduce SW process, move LMBAT=> ROPBAT.
*. 31-Aug-92  C.Hawkes       CALL LMBAT
*. 05-Feb-92  C.Hawkes       Use RODPAR sequence
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*2 CHPROC
      INTEGER     IDETST,ITRGST
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,CRO.
+SEQ,RODPAR.
*
      IF(CHPROC.EQ.'CV') THEN
         CALL CVBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL CVSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDCV)
         END IF
         CALL ROMONI(4,0)
      ELSE IF(CHPROC.EQ.'CJ') THEN
         CALL JCBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL CJSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDCJ)
         END IF
         CALL ROMONI(5,0)
      ELSE IF(CHPROC.EQ.'CZ') THEN
         CALL CZBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL CZSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDCZ)
         END IF
         CALL ROMONI(6,0)
      ELSE IF(CHPROC.EQ.'CT') THEN
         CALL CTBAT
         CALL ROMONI(7,0)
      ELSE IF(CHPROC.EQ.'DX') THEN
         CALL DXBAT
         CALL ROMONI(8,0)
      ELSE IF(CHPROC.EQ.'CX') THEN
         CALL CXBAT
         CALL ROMONI(9,0)
      ELSE IF(CHPROC.EQ.'SI') THEN
         CALL SIBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL SISTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDSI)
         END IF
         CALL ROMONI(10,0)
      ELSE IF(CHPROC.EQ.'CS') THEN
         CALL CSBAT
         CALL ROMONI(11,0)
      ELSE IF(CHPROC.EQ.'CF') THEN
         CALL CFBAT
         CALL ROMONI(0,0)
      ELSE IF(CHPROC.EQ.'CE') THEN
         CALL CEBAT
         CALL ROMONI(12,0)
      ELSE IF(CHPROC.EQ.'CA') THEN
         CALL CABAT
         CALL ROMONI(13,0)
      ELSE IF(CHPROC.EQ.'TB') THEN
         CALL TBBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL TBSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDTB)
         END IF
         CALL ROMONI(14,0)
      ELSE IF(CHPROC.EQ.'PB') THEN
         CALL PBBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL PBSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDPB)
         END IF
         CALL ROMONI(15,0)
      ELSE IF(CHPROC.EQ.'EB') THEN
         CALL EBBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL EBSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDEB)
         END IF
         CALL ROMONI(16,0)
      ELSE IF(CHPROC.EQ.'TE') THEN
         CALL TEBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL TESTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDTE)
         END IF
         CALL ROMONI(31,0)
      ELSE IF(CHPROC.EQ.'PE') THEN
         CALL PEBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL PESTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDPE)
         END IF
         CALL ROMONI(17,0)
      ELSE IF(CHPROC.EQ.'EE') THEN
         CALL EEBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL EESTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDEE)
         END IF
         CALL ROMONI(18,0)
      ELSE IF(CHPROC.EQ.'EM') THEN
         CALL EMBAT
         CALL ROMONI(19,0)
      ELSE IF(CHPROC.EQ.'HB') THEN
         CALL HBBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL HTSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDHT)
         END IF
         CALL ROMONI(20,0)
      ELSE IF(CHPROC.EQ.'HE') THEN
         CALL HEBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL HSSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDHS)
         END IF
         CALL ROMONI(21,0)
      ELSE IF(CHPROC.EQ.'HP') THEN
         CALL HPBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL HPSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDHP)
         END IF
         CALL ROMONI(22,0)
      ELSE IF(CHPROC.EQ.'HM') THEN
         CALL HMBAT
         CALL ROMONI(23,0)
      ELSE IF(CHPROC.EQ.'MB') THEN
         CALL MBBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL MBSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDMB)
         END IF
         CALL ROMONI(24,0)
      ELSE IF(CHPROC.EQ.'ME') THEN
         CALL MEBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL MESTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDME)
         END IF
         CALL ROMONI(25,0)
      ELSE IF(CHPROC.EQ.'MM') THEN
         CALL MMBAT
         CALL ROMONI(26,0)
      ELSE IF(CHPROC.EQ.'FD') THEN
         CALL FDBAT
         CALL LMBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL FDSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDFD)
         END IF
         CALL ROMONI(27,0)
      ELSE IF(CHPROC.EQ.'SW') THEN
         CALL SWBAT
         IF(IFUPDT.EQ.1.AND.IRDEXP.LT.1000) THEN
            CALL SWSTAT(IDETST,ITRGST)
            CALL ROSTAT(IDETST,ITRGST,IIDSW)
         END IF
         CALL ROMONI(28,0)
      ELSE IF(CHPROC.EQ.'OD') THEN
         CALL ODBAT
         CALL ROMONI(29,0)
      END IF
*
      RETURN
      END
+DECK,ROCLRZ.
      SUBROUTINE ROCLRZ(CHPROC)
*.
*...ROCLRZ Clear ZEBRA working banks for each processor
*.
*. SEQUENCE: ROBANK RCNTRL
*. CALLS   : MZDROP
*. CALLED  : ROPBAT
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 21-Jan-91
*. LAST MOD:  3-Mar-93
*.
*. Modification Log.
*.  3-Mar-93  O.Schaile      Introduce SW process.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*2 CHPROC
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
*
      IF(CHPROC.EQ.'CV') THEN
         IF(LCV.NE.0) CALL MZDROP(IXSTOR,LCV,'L')
         IF(INDROP.EQ.0) THEN
            IF(LCT.NE.0) CALL MZDROP(IXSTOR,LCT,'L')
            IF(LCX.NE.0) CALL MZDROP(IXSTOR,LCX,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CJ') THEN
         IF(LCJ.NE.0) CALL MZDROP(IXSTOR,LCJ,'L')
         IF(INDROP.EQ.0) THEN
            IF(LCT.NE.0) CALL MZDROP(IXSTOR,LCT,'L')
            IF(LCX.NE.0) CALL MZDROP(IXSTOR,LCX,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CZ') THEN
         IF(LCZ.NE.0) CALL MZDROP(IXSTOR,LCZ,'L')
         IF(INDROP.EQ.0) THEN
            IF(LCT.NE.0) CALL MZDROP(IXSTOR,LCT,'L')
            IF(LCX.NE.0) CALL MZDROP(IXSTOR,LCX,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CT') THEN
         IF(LCT.NE.0) CALL MZDROP(IXSTOR,LCT,'L')
         IF(INDROP.EQ.0) THEN
            IF(LCX.NE.0) CALL MZDROP(IXSTOR,LCX,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'DX') THEN
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CX') THEN
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'SI') THEN
         IF(LSI.NE.0) CALL MZDROP(IXSTOR,LSI,'L')
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CS') THEN
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CF') THEN
         IF(LCF.NE.0) CALL MZDROP(IXSTOR,LCF,'L')
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CE') THEN
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'CA') THEN
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'TB') THEN
         IF(LTB.NE.0) CALL MZDROP(IXSTOR,LTB,'L')
         IF(INDROP.EQ.0) THEN
            IF(LEM.NE.0) CALL MZDROP(IXSTOR,LEM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'TE') THEN
         IF(LTE.NE.0) CALL MZDROP(IXSTOR,LTE,'L')
         IF(INDROP.EQ.0) THEN
            IF(LEM.NE.0) CALL MZDROP(IXSTOR,LEM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'PB') THEN
         IF(LPB.NE.0) CALL MZDROP(IXSTOR,LPB,'L')
         IF(INDROP.EQ.0) THEN
            IF(LEM.NE.0) CALL MZDROP(IXSTOR,LEM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'EB') THEN
         IF(LEB.NE.0) CALL MZDROP(IXSTOR,LEB,'L')
         IF(INDROP.EQ.0) THEN
            IF(LEM.NE.0) CALL MZDROP(IXSTOR,LEM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'PE') THEN
         IF(LPE.NE.0) CALL MZDROP(IXSTOR,LPE,'L')
         IF(INDROP.EQ.0) THEN
            IF(LEM.NE.0) CALL MZDROP(IXSTOR,LEM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'EE') THEN
         IF(LEE.NE.0) CALL MZDROP(IXSTOR,LEE,'L')
         IF(INDROP.EQ.0) THEN
            IF(LEM.NE.0) CALL MZDROP(IXSTOR,LEM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'EM') THEN
         IF(LEM.NE.0) CALL MZDROP(IXSTOR,LEM,'L')
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'HB') THEN
         IF(LHB.NE.0) CALL MZDROP(IXSTOR,LHB,'L')
         IF(INDROP.EQ.0) THEN
            IF(LHM.NE.0) CALL MZDROP(IXSTOR,LHM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'HE') THEN
         IF(LHE.NE.0) CALL MZDROP(IXSTOR,LHE,'L')
         IF(INDROP.EQ.0) THEN
            IF(LHM.NE.0) CALL MZDROP(IXSTOR,LHM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'HP') THEN
         IF(LHP.NE.0) CALL MZDROP(IXSTOR,LHP,'L')
         IF(INDROP.EQ.0) THEN
            IF(LHM.NE.0) CALL MZDROP(IXSTOR,LHM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'HM') THEN
         IF(LHM.NE.0) CALL MZDROP(IXSTOR,LHM,'L')
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'MB') THEN
         IF(LMB.NE.0) CALL MZDROP(IXSTOR,LMB,'L')
         IF(INDROP.EQ.0) THEN
            IF(LMM.NE.0) CALL MZDROP(IXSTOR,LMM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'ME') THEN
         IF(LME.NE.0) CALL MZDROP(IXSTOR,LME,'L')
         IF(INDROP.EQ.0) THEN
            IF(LMM.NE.0) CALL MZDROP(IXSTOR,LMM,'L')
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'MM') THEN
         IF(LMM.NE.0) CALL MZDROP(IXSTOR,LMM,'L')
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'FD') THEN
         IF(LFD.NE.0) CALL MZDROP(IXSTOR,LFD,'L')
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      ELSE IF(CHPROC.EQ.'SW') THEN
         IF(LSW.NE.0) CALL MZDROP(IXSTOR,LSW,'L')
         IF(INDROP.EQ.0) THEN
            IF(LOD.NE.0) CALL MZDROP(IXSTOR,LOD,'V')
         END IF
      END IF
*
      RETURN
      END
+DECK,RODSWP.
      SUBROUTINE RODSWP
*.
*...RODSWP   Make sure we are using non-SI tracks and drop any extra DST
*.           blocks
*.
*. SEQUENCE  : ROBANK ROPAR
*. CALLS     : MZDROP ODTOSI
*. CALLED    : GUOUT  ROWOUT
*.
*. AUTHOR    : M.Redmond
*. VERSION   : 1.01
*. CREATED   : 18-Nov-93
*. LAST MOD  : 18-Nov-93
*.
*. Modification log:
*.*********************************************************************
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,ROPAR.
      INTEGER LODGL,LODCT,LODVT,LODAT,IFAIL
C
      CALL ODTOSI('  ','  ',IFAIL)
      IF (LOD.LE.0)                                            GO TO 999
      LODGL = LQ(LOD-LLODGL)
      IF (LODGL.GT.0) THEN
        LODGL = LQ(LODGL)
        IF (LODGL.GT.0) CALL MZDROP(IXSTOR,LODGL,'L')
      END IF
      LODCT = LQ(LOD-LLODCT)
      IF (LODCT.GT.0) THEN
        LODCT = LQ(LODCT)
        IF (LODCT.GT.0) CALL MZDROP(IXSTOR,LODCT,'L')
      END IF
      LODVT = LQ(LOD-LLODVT)
      IF (LODVT.GT.0) THEN
        LODVT = LQ(LODVT)
        IF (LODVT.GT.0) CALL MZDROP(IXSTOR,LODVT,'L')
      END IF
      LODAT = LQ(LOD-LLODAT)
      IF (LODAT.GT.0) THEN
        LODAT = LQ(LODAT)
        IF (LODAT.GT.0) CALL MZDROP(IXSTOR,LODAT,'L')
      END IF
*
  999 RETURN
      END
+DECK,ROEVNT.
      SUBROUTINE ROEVNT
*.
*...ROEVNT   ROPE main routine to process one event
*.
*. SEQUENCE  : ROBANK CRO RCNTRL ROPAR ROCPAR OCFLAG ROUNIT RCREP
*. CALLS     : MZBOOK MZWIPE RIOSEL ROTRIG RBKREV ROPBAT
*.             RPHONE ROPHON ROWOUT REPORT TIMEL USBAT
*. CALLED    : QNEXT ROGOKU
*.
*. BANKS L   : REV
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.03
*. CREATED   : 18-May-87
*. LAST MOD :   1-Apr-99
*.
*. Modification Log.
*.  1-Apr-99 E.Barberio  Add call to ODFIX before the call to USBAT
*.  6-Nov-95  O.Schaile  add argument (IERR) in ROTRIG
*. 26-Mar-94 M.Redmond   Zero two additional flags in OCFLAG common
*.  6-May-93 O.Schaile   Preset RTIMLF (if ONLINE)
*. 19-Apr-93 O.Schaile   Avoid TIMEL if ONLINE
*. 24-May-91 D.Lellouch  Implement Header only option.
*.  5-Fev-91 S.Weisz     Temporary comment of Phone facility.
*. 24-Jan-91 D.Lellouch  Time guard for new input file, 'Phone' utility.
*.  7-Jun-90 S.Weisz     Set STOP status
*.  7-Sep-89 S.Weisz     Reset OPCAL flags.
*. 22-Jul-89 S.Weisz     Quiting event loop in interactive mode.
*. 15-Jul-89 S.Weisz     Call ROWOUT in batch mode only.
*. 12-May-89 S.Weisz     Handle run time error counters.
*. 23-Jan-89 S.Weisz     Remove call to RGETCA now done in RGETDA.
*. 12-Jan-89 S.Weisz     Reset error handling conditions if IRSTOP ne 0.
*. 20-Dec-88 S.Weisz     Remove call to BETRIG, calls ROPBAT.
*. 18-May-88 S.Weisz     Selection of Real and MC data in RSELDA.
*. 05-May-88 S.Weisz     Use IRTRIG,IRDEBG instead of IRTMIN....
*. 11-Feb-88 A.Buijs     Slight rearrangement.
*. 02-Oct-87 S.Weisz     Use of bank parameter of ROPAR,use of REPORT.
*.                       No GOPAL111 compatibility.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SELF,IF=ERRECO,IF=IBM.
      EXTERNAL ROTRAP
+SELF.
      REAL     RTIMLF
      INTEGER IERR
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,OCFLAG.
+SEQ,ROUNIT.
+SEQ,RCREP.
+SEQ,GOFLAG.
*
      LOGICAL ONLIN
*
+SELF,IF=ONLINE.
+SEQ,MONITO.
*
      INTEGER NCOUNT
      DATA NCOUNT/0/
      DATA RTIMSF/999999./
+SELF.
*-- Clear ZEBRA event division.
   10 CALL MZWIPE(IRODIV)
*-- Reset flags.
      IRDEBU = 0
      IRSTOP = 0
      IFBOOK = 1
      CALL VZERO(IOCRRV,5)
*-- Select all output streams.
      CALL RIOSEL(0,1)
*-- Check the TIME left.
+SELF,IF=IBM,IF=-ONLINE.
      CALL TIMAL(RTIMLF)
+SELF,IF=-IBM,IF=-ONLINE.
      CALL TIMEL(RTIMLF)
+SELF.
+SELF,IF=-ONLINE.
      IF(RTIMLF.LT.RTIMSF) THEN
         IRSTOP=2
         WRITE(CHREP,1000) RTIMLF
         CALL REPORT('ROEVNT',1,'I')
         NSTOP = 2
                                                               GO TO 999
      END IF
+SELF.
*-- Get a new event.
      CALL ROTRIG(IERR)
*   this can happen only interactively
      IF(IERR.EQ.-33)THEN
         WRITE(CHREP,'(A)')'IERR(ROTRIG)=-33, event not found'
         CALL REPORT('ROEVNT',3,'W')
         GOTO 999
      ENDIF
      GO TO (10,999) IRSTOP
      IF(LNOHEA) THEN
         IREVPR=IREVPR+1
+SELF,IF=-ONLINE.
         CALL ROUPON(ONLIN)
         IF(.NOT.ONLIN)THEN
           IF(IGOEXP.LT.999) CALL ODFIX(-1)
         END IF
+SELF. 
         CALL USBAT(-1)
                                                       GO TO 20
      END IF
      CALL RBKREV
*-- Increment number of processed events.
      IREVPR = IREVPR+1
+SELF,IF=ONLINE.
      NCOUNT = NCOUNT+1
+SELF.
*-- Set debug flag according to the FFREAD card DEBUG.
      IF(IREVPR.GE.IRDEBG(1).AND.IREVPR.LE.IRDEBG(2)) THEN
         IF(MOD(IREVPR-IRDEBG(1),IRDEBG(3)).EQ.0) IRDEBU=IRDEBG(4)
      END IF
*-- Finally run all selected processors.
      CALL ROPBAT
+SELF,IF=ERRECO,IF=IBM.
      IF(NEVTRP.NE.0) THEN
         WRITE(CHREP,1010) NEVTRP
         CALL REPORT('ROEVNT',2,'W')
         NEVTRP = 0
      END IF
+SELF.
      GO TO (10,999) IRSTOP
   20 CONTINUE
*-- Write selected output files in batch mode.
      IF(IRINTR.EQ.0) THEN
         CALL ROWOUT
      ELSE
         IF(IREVNT.GE.IRTRIG(2))                               GO TO 999
      END IF
CCCCCC Temporary comment phone facility
*-- Checks whether queries from the job submitter where accumulated.
C     IF(LPHONE) THEN
C  30    CALL RPHONE
C        IF(GOTCMD) THEN
C           CALL ROPHON
C           GO TO (10,999) IRSTOP
C                                                               GO TO 30
C        END IF
C     END IF
CCCCCC End of temporary comment phone facility
+SELF,IF=ONLINE.
      IF(NCOUNT.GE.NSUMF) THEN
         CALL ROSUMF
         NCOUNT = 0
      END IF
+SELF.
*
                                                                GO TO 10
  999 RETURN
*
 1000 FORMAT('Time limit reached, still ',F7.3,
     +       ' sec. left to end the job')
 1010 FORMAT(I6,' Run time error occured for this event')
*
      END
+DECK,ROEVTY.
      SUBROUTINE ROEVTY
*.
*...ROEVTY  Fills "Event Type" word in event header
*.
*.
*. SEQUENCE: ROBANK RCNTRL CRO ROPAR ROTPAR ODPAR RBITFUNC RCREP LLCLAS
*.           LLGLOB
*. CALLS   : RBABFD RTRGFD RGAM RGEM RHLSEL RTWOPH RHSEL RSPTRG
*.           RMHSEL RGTOEM RTRIGS ROFYZS ROFYZT ODFUNS ODSWRD REPORT
*. CALLED  : ROPBAT
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 2.07
*. CREATED : 23-Mar-90
*. LAST MOD : 26-Mar-99  
*.
*. Modification Log.
*.  26-Mar-99 G.W.Wilson Add IEOPTR to FYZ1. 
*.  16-Aug-98 E.Barberio Add the new te rhorho trigger to fyz1 (evt2)
*.  28-Apr-98 M.Schroder Set IESWKP properly
*.  17-Apr-98 M.Schroder Add ROFUGG (ORed with ROGGSE), and ROPHOT
*.  23-Oct-97 M.Schroder Add SW-keep-selection to phys1
*.   6-Oct-97 E.Barberio Add the new Mip plug trigger to phys1 selection
*.   1-Jul-96  M.Schroder   really avoid overwriting of IUHEAD(IIEVTY)
*.  29-Jun-96  M.Schroder   avoid overwriting of IUHEAD(IIEVTY)
*.  17-Jun-96  M.Schroder   LEP2 MultiHadron-Selection
*.  20-Feb-96  M.Schroder   In- and exclusive gamma gamma selections
*.  26-Oct-95  T.Wyatt      Isolated lepton selection in bit IELLIL
*.   3-Oct-95  O.Schaile    Add HIELIN
*.   3-Oct-95  M.Schroder   Add CHARGINO bits GACE,LMAE and MONO
*.  28-Jul-94  O.Schaile    Add TE trigger study bit
*.  12-Oct-93  M.Redmond    Make sure event type words are consistent
*.                          in both copies of GNRL block
*.  12-Oct-93  O.Schaile    Call RBABSW
*.  23-Aug-93  C.Darling    Remove call to ROFYZ1
*.  18-Aug-93  C.Darling    Implement FYZS/FYZT streaming
*.  04-Oct-92  C.Hawkes     Include new LLGLOB sequence
*.   7-Sep-92  O.Schaile    Changes for RGTOEM (from G.Wilson)
*.  25-Aug-92  C.Hawkes     Changes for RGTOEM (from G.Wilson)
*.  18-Feb-92  C.Hawkes     Remove CALL LLBAT (now called from ROPBAT)
*.  27-Aug-91  S.Weisz      Use RBITFUNC sequence
*.  11-May-91  C.Hawkes     Add RGEM: single photon EM cluster selection
*.  24-Apr-91  C.Hawkes     Move selection of triggers to RTRIGS
*.                          Move definition of Phys1 selection to ROFYZ1
*.  21-Apr-91  C.Hawkes     Add RGTOEM: single photon EM+TOF selection
*.  16-Apr-91  S.Weisz      Checks if OD statement functions can be used.
*.  15-Apr-91  C.Hawkes     Define pointer names in sequence ROTPAR
*.                          Use IAND for FYZ1 selection
*.                          Include vetoes for single photons, RGAM
*.                          New version of RBABFD
*.  14-Apr-91  C.Hawkes     Add call to ODFUNS
*.  13-Apr-91  C.Hawkes     Add LLBAT for enhanced lepton pair selection
*.                          and classification. Remove RLLSEL.
*.                          Remove quark triggers from "Phys1"
*.                          Put FD trigger validation into RTRGFD
*.  02-Apr-91  C.Hawkes     Start version 2.00 for 1991 "Phys1"
*.                          Add photon conversions to "Phys1"
*.  31-Oct-90  C.Hawkes     Remove FDSUM accidental trigs from "Phys1"
*.                          Add FD trigger filter selection to "Phys1"
*.  24-Oct-90  C.Hawkes     Add monopole and quark triggers to "Phys1"
*.  11-Oct-90  S.Weisz      Add Tokyo multihadron selection to "Phys1"
*.  08-Oct-90  C.Hawkes     Add close-mass preselection to heavy
*.                           lepton preselection and to "Phys1"
*.  28-Sep-90  S.Weisz      Add filter flagged GPMH events to "Phys1".
*.  16-Aug-90  G.Wilson     Add single photon trigger events to "Phys1".
*.  09-Jul-90  C.Hawkes     Copy event-type word into GNRL DST block.
*.  19-Jun-90  S.Weisz      Add Higgs preselection in "Phys1".
*.  14-Jun-90  C.Hawkes     Add Higgs high multiplicity preselection.
*.  13-Jun-90  T.R.Wyatt    Add tagged two photon preselection.
*.  07-Jun-90  M.Lehto      Add more FD triggers to Phys1 selection.
*.  21-May-90  C.Hawkes     Add "Phys1" selection stream
*.  06-Apr-90  T.R.Wyatt    Add photon and heavy lepton preselection.
*.  30-Mar-90  C.Hawkes     Add lepton pair preselection.
*.  29-Mar-90  S.Weisz      Do not call RBABFD for EBEAM = 0.
*.  23-Mar-90  C.Hawkes     Count bits 1-32 (OPAL) not 0-31 (FORTRAN).
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROTPAR.
*-- Logical functions to select gamma gamma events
      LOGICAL  ROGGSE, ROUTGG, ROFUGG
      EXTERNAL ROGGSE, ROUTGG, ROFUGG
+SEQ,ODPAR.
+SEQ,LLCLAS.
+SEQ,LLGLOB.
+SEQ,RBITFUNC.
+SEQ,TRMAPS.
+SEQ,RCREP.
*
      LOGICAL  RMHSEL, RL2MHS, ROPHOT
      EXTERNAL RMHSEL, RL2MHS, ROPHOT
      LOGICAL  TETRIG
      LOGICAL  LSWKP
      INTEGER  TRBTST
*-- Return arguments of ODSWRD
      INTEGER NIMOV,NRMOV
      INTEGER ISEL,ISELGP
      INTEGER LODGL
*-- Logical flags returned by RBABFD for lumi event identification.
      LOGICAL FKBABA,FKBABM,FBBABA
*-- Logical flag returned by RTRGFD for FD trigger validation.
      LOGICAL FDTRIG
*-- Logical flags returned by RBABSW for SW events.
      LOGICAL LSWITA, LSWITR, LSWOTR, LSWITL, LSWOTL
*-- Logical flags returned by RGAM for single photon preselection.
      LOGICAL RGAM1,RGAM2,VMUON,VBWALL
*-- Logical flag returned by RSPTRG for single photon triggers
      LOGICAL SPTRIG
*-- Logical flags returned by RGTOEM.
      LOGICAL EMTOF,GOODT0,GOODTR
*-- Logical flag for TOEM Phys1 selection
      LOGICAL RGEMTO
*-- Logical flag returned by RGEM for single photon EM cluster selection
      LOGICAL REGEM
*-- Logical flags returned by RHLSEL for heavy lepton identification.
      LOGICAL HLMISS,HLISOL,HLCLOS
*-- Logical flag returned by RTWOPH for tagged two photon preselection.
      LOGICAL TWOPHO
*-- Logical flag returned by RHSEL for Higgs preselection.
      LOGICAL HBIT
*-- Logical flag returned by RTRIGS for trigger selections.
      LOGICAL TRGSEL
*-- Logical flags returned by RONRMH for non radiative MH selections.
      LOGICAL LNRMH1, LNRMH2
*-- Flag used by WW selection routines
      INTEGER IERR
*-- Logical flag returned by ROOPTR for 1/100 OPAL triggers
      LOGICAL LOPTR
*-- Masks for FYZS selection
      INTEGER MEFYZS,M2FYZS,MFFYZS
*-- Masks for FYZT selection
      INTEGER MEFYZT,M2FYZT,MFFYZT
*-- Flags noting if event goes to FYZS and FYZT streams
      LOGICAL FZSEVT,FZTEVT
*-- Flag for first call to this routine
      LOGICAL FIRST
      SAVE    FIRST,MEFYZS,M2FYZS,MFFYZS,
     +              MEFYZT,M2FYZT,MFFYZT
      DATA    FIRST/.TRUE./
*-- Should header be updated?
      IF(IFUPDT.EQ.1)THEN
*-- Check if we can run this code.
        IF(LOD.LE.0)                                           GO TO 999
        IF(IQIDN(LOD).LT.307) THEN
           CHREP  = 'No valid DST. Event type NOT updated.'
           CALL REPORT('ROEVTY',1,'W')
                                                               GO TO 999
        END IF
*-- Reset event-type words in header
        IUHEAD(IIEVTY)=0
        IQ(LREV+IIEVTY)=0
        IUHEAD(IIEVT2)=0
        IQ(LREV+IIEVT2)=0
*  Set up pointers for OD statement functions
        CALL ODFUNS
*
*-- Define event type for luminosity Bhabha events.
*-- FD Three types:  bit1=Etotbar; bit2=Emainbar; bit3=CUBED
        CALL RBABFD(FKBABA,FKBABM,FBBABA)
*-- (-1 from bit index to go from OPAL 1-32 to FORTRAN 0-31 convention)
        IF(FKBABA)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELUET-1)
        IF(FKBABM)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELUEM-1)
        IF(FBBABA)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELUCU-1)
*-- Define event type for validated FD triggered events.
*-- One type:  bit17=validated FD trigger
        CALL RTRGFD(FDTRIG)
        IF(FDTRIG)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEFDTR-1)
*-- Define event type for SW events.
        CALL RBABSW (LSWITA, LSWITR, LSWOTR, LSWITL, LSWOTL)
        IF(LSWITA)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IESWIA-33)
        IF(LSWITR)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IESWIR-33)
        IF(LSWOTR)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IESWOR-33)
        IF(LSWITL)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IESWIL-33)
        IF(LSWOTL)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IESWOL-33)
*-- Kludge swkp selection into FD trigger as before....
*-- NOTE RSWPRE must be called after RBABSW!!!!!! (otherwise
*                                                  commons will
*                                                  not be filled!!)
*
        CALL RSWPRE(LSWKP)
        IF(LSWKP )IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IESWKP-33)
*-- Define event type for lepton pair preselection and classification.
*-- Set by LLBAT as bits in word LLCODE in sequence LLCLAS.
*-- Eight bits:  bit4=low multiplicity preselection,
*-- bit5=high multiplicity veto, bit6=cosmic veto, bit7=isolated lepton,
*-- bit18=e pair, bit19=mu pair, bit20=tau pair, bit21=lepton pair
        IF (
     +      BTEST(LLCODE,IISCD-1) .OR.
     +      BTEST(LLCODE,IISEC-1) .OR.
     +      BTEST(LLCODE,IISME-1)
     +     ) IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLLM-1)
        IF( BTEST(LLCODE,IIVQQ-1) )
     +       IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLQQ-1)
        IF( BTEST(LLCODE,IIVCO-1) )
     +       IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLCO-1)
        IF( BTEST(LLCODE,IICBH-1) )
     +       IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLEE-1)
        IF( BTEST(LLCODE,IICMP-1) )
     +       IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLMM-1)
        IF( BTEST(LLCODE,IICTP-1) )
     +       IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLTT-1)
        IF( BTEST(LLCODE,IICLL-1) )
     +       IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLLL-1)
        IF( BTEST(LLCODE,IICUS-1) )
     +       IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IELLIL-1)
*-- The Wide Angle BhaBha selection
        IF( BTEST(LLCODE,IICWB-1) )
     +       IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEWABB-33)
*-- Define event type for single photon preselection events.
*-- Two types:  bit8=photon candidate, bit9=converted photon candidate.
*-- Two vetoes: bit22=muon veto, bit23=beam-wall veto.
        CALL RGAM(RGAM1,RGAM2,VMUON,VBWALL)
        IF(RGAM1 )IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGAM -1)
        IF(RGAM2 )IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGCON-1)
        IF(VMUON )IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGVMU-1)
        IF(VBWALL)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGVBW-1)
*-- Define event type for special single photon trigger validated
*-- by filter EB raw energy criterion, using muon veto from RGAM
        CALL RSPTRG(SPTRIG,VMUON)
        IF(SPTRIG)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGSTR-1)
*-- Call RGTOEM for various criteria
        CALL RGTOEM(EMTOF,GOODT0,GOODTR)
*-- Fill bits in event-type word for each logical flag
*-- returned by RGTOEM
        IF(EMTOF)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGTOE-1)
        IF(GOODT0)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGGT0-1)
        IF(GOODTR)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGGTR-1)
*-- Define event type for single photon EM+TOF selection,
*-- using muon and beam-wall vetoes from RGAM
        RGEMTO = EMTOF.AND.(.NOT.VMUON).AND.(.NOT.VBWALL)
        IF(RGEMTO)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGEMT-1)
*-- Define event type for single photon EM cluster selection (no veto)
        CALL RGEM(REGEM)
        IF(REGEM)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGEM-1)
* Define event type for single photon selection which uses
* TOF timing for cosmic rejection and makes no use of the
* muon veto - allowing sensitivity to hadronic energy.
        IF(EMTOF.AND.GOODT0.AND.(.NOT.VBWALL))
     +     IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGHOK-1)
* Define event type for Alan's assorted single photons
        IF( ( REGEM.OR.RGAM1.OR.RGEMTO )
     +       .AND..NOT.BTEST(IUHEAD(IIEVTY),IELLQQ-1)
     +       .AND..NOT.VMUON ) THEN
          IF(ROPHOT())IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IESPSS-33)
        ENDIF
* Define event type for selection which demands a high pT track -
* BUT without any pointing requirements in r-phi. Designed to
* be efficient for long-lived decays. The ECAL and TOF
* criteria are imposed as TPTOEM is the most likely trigger.
        IF(EMTOF.AND.GOODT0.AND.GOODTR)
     +     IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEGLLD-1)
*-- Define event type for heavy lepton preselection events.
*-- Three types:  bit10=missing energy, bit11=isolated track,
*--               bit15=close-mass pair.
        CALL RHLSEL(HLMISS,HLISOL,HLCLOS)
        IF(HLMISS)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEHLPT-1)
        IF(HLISOL)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEHLIS-1)
        IF(HLCLOS)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEHLCM-1)
*-- Define event type for tagged two photon preselection events.
        CALL RTWOPH(TWOPHO)
        IF(TWOPHO)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IETWOP-1)
*-- Define event type for Higgs high multiplicity preselection.
        CALL RHSEL(HBIT)
        IF(HBIT)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEHIGS-1)
*-- Define event type for Tokyo multihadron selection
        IF(RMHSEL(ISEL))IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IETKMH-1)
*-- Define event type for LEP2 multihadron selection
        IF(RL2MHS(ISEL))IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEL2MH-33)
*-- Define event type for other special trigger selections
        CALL RTRIGS(TRGSEL)
        IF(TRGSEL)IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IETRIG-1)
        CALL RTETRG(TETRIG)
        IF(TETRIG)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IETETR-33)
         IF(TRBTST(IUHEAD(IITRWD),IBSIM1) .EQ. 1) THEN
           IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IETEMP-33)
         ENDIF
         IF(TRBTST(IUHEAD(IITRWD),IBMRR) .EQ. 1) THEN
           IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEXXXX-33)
         ENDIF
*-- Define event type for chargino selection
        CALL ROCHSE(ISEL,ISELGP)
        IF(BTEST(ISEL,0)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEGACE-33)
        IF(BTEST(ISEL,1)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IELMAE-33)
        IF(BTEST(ISEL,2)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEMONO-33)
        IF(ISELGP.GT.0)   IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEGOPL-33)
*-- Define event type for neutralino selection
        CALL HIELIN(ISEL)
        IF(ISEL.EQ.1 .OR. ISEL.EQ.2)
     +  IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IENELO-33)
        IF(ISEL.EQ.2)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IENETI-33)
*-- Define event type for inclusive gamma gamma selection
        IF ( ROUTGG() ) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEIUGG-33)
*-- Define event type for exclusive gamma gamma selection
        IF ( ROGGSE() .OR. ROFUGG() ) 
     +       IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEUGGE-33)
*-- Define event type for non-radiative multihadron selections
        CALL RONRMH( LNRMH1, LNRMH2)
        IF ( LNRMH1 ) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IENRH1-33)
        IF ( LNRMH2 ) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IENRH2-33)
*-- The WW selection routine
        CALL ROWWSE(ISEL,IERR)
        IF(BTEST(ISEL,0)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEWW4Q-33)
        IF(BTEST(ISEL,1)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEWWQE-33)
        IF(BTEST(ISEL,2)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEWWQM-33)
        IF(BTEST(ISEL,3)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEWWQT-33)
        IF(BTEST(ISEL,4)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEWWLL-33)
*-- One in a hundred OPAL triggers for trigger development and
*-- FYZ1 monitoring.
        CALL ROOPTR(LOPTR)
        IF(LOPTR)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEOPTR-33)
*
*-- On first call, get the bit masks to define Phys1 selection
*-- Define bit masks for FYZS and FYZT as well
        IF(FIRST)THEN
          FIRST=.FALSE.
          CALL ROFYZS(MEFYZS,M2FYZS,MFFYZS)
          CALL ROFYZT(MEFYZT,M2FYZT,MFFYZT)
        ENDIF
*
*-- Check if event should be sent to the FYZS stream
        FZSEVT = .FALSE.
        IF( IAND (IUHEAD(IIEVTY),MEFYZS).NE.0  .OR.
     +      IAND (IUHEAD(IIEVT2),M2FYZS).NE.0  .OR.
     +      IAND (IUHEAD(IIFITY),MFFYZS).NE.0) THEN
          IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEFYZS-33)
          FZSEVT = .TRUE.
        ENDIF
*
*-- Check if event should be sent to the FYZT stream
        FZTEVT = .FALSE.
        IF( IAND (IUHEAD(IIEVTY),MEFYZT).NE.0  .OR.
     +      IAND (IUHEAD(IIEVT2),M2FYZT).NE.0  .OR.
     +      IAND (IUHEAD(IIFITY),MFFYZT).NE.0)THEN
          IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEFYZT-33)
          FZTEVT = .TRUE.
        ENDIF
*
* New definition of FYZ1; FYZS and FYZT are the only subsets of FYZ1
         IF(FZSEVT.OR.FZTEVT)
     +        IUHEAD(IIEVTY)=IBSET(IUHEAD(IIEVTY),IEFYZ1-1)
*
*-- Copy event-type words into the data part of REV
        IQ(LREV+IIEVTY)=IUHEAD(IIEVTY)
        IQ(LREV+IIEVT2)=IUHEAD(IIEVT2)
*
*-- Copy event-type words into the GNRL block of DST
        CALL ODSWRD('GNRL',1,JGEVTY,IUHEAD(IIEVTY),NIMOV,0,0.,NRMOV)
        IF(NIMOV.NE.1.OR.NRMOV.NE.0)THEN
          WRITE(CHREP,1000) NIMOV,NRMOV
          CALL REPORT('ROEVTY',2,'E')
        END IF
        CALL ODSWRD('GNRL',1,JGEVT2,IUHEAD(IIEVT2),NIMOV,0,0.,NRMOV)
        IF(NIMOV.NE.1.OR.NRMOV.NE.0)THEN
          WRITE(CHREP,1000) NIMOV,NRMOV
          CALL REPORT('ROEVTY',3,'E')
        END IF
*-
*-- If there is another copy of the GNRL block, make sure that it has
*-- the same event type words
*
        IF (LOD.GT.0) THEN
          LODGL = LQ(LOD-LLODGL)
          IF (LODGL.GT.0) THEN
            LODGL = LQ(LODGL)
            IF (LODGL.GT.0) THEN
              IQ(LODGL+1+JGEVTY) = IUHEAD(IIEVTY)
              IQ(LODGL+1+JGEVT2) = IUHEAD(IIEVT2)
            END IF
          END IF
        END IF
*
      END IF
*
  999 RETURN
*
 1000 FORMAT(' Error writing to GNRL block: NIMOV=',I3,' NRMOV=',I3)
*
      END
+DECK,ROOPTR.
      SUBROUTINE ROOPTR(LOPTR)
**********************************************************************
*.
*..ROOPTR   Flag every 100th triggered event for unbiased selection by FYZ1.
*.
*.  SEQUENCES :  DECLARE CRO
*.  CALLS     :  
*.  CALLED    :  ROEVTY
*.
*.  AUTHORS   :  Graham Wilson
*.  VERSION   :  1.00
*.  CREATED   :  26-Mar-99
*.  LAST MOD  : 
*.
************************************************************************
+SEQ,DECLARE.
+SEQ,CRO.
      LOGICAL LOPTR
      LOPTR = .FALSE.
      IF(MOD(IRDEVT,100).EQ.47)LOPTR=.TRUE.
      END
+DECK,ROFDCL.
      SUBROUTINE ROFDCL(SFYZT)
**********************************************************************
*.
*.
*..ROFDCL       Decides whether the event should be sent to the FYZT
*.              stream based purely on SW and FK energy cluster cuts.
*.              Trigger & filter bit reqs for FYZT are done in ROEVTY.
*.                   SFYZT = .TRUE. if event goes to the FYZT stream
*.
*.       Stream selection based on note from Al Lee and Dick Kellogg
*.
*.  SEQUENCES :  RCREP ODPAR RBITFUNC
*.  CALLS     :  ODNBLK ODFBLK REPORT
*.  CALLED    :  RTRGFD
*.
*.  AUTHORS   :  Chris Darling
*.  VERSION   :  1.00
*.  CREATED   :  11-Aug-93
*.  LAST MOD  :  21-Aug-95
*.
*.  Modification Log.
*.
*.  21-AUG-95 M.Schroder  NIFDET, NRFDET instead of undefined NIWD/NRWD.
*.
************************************************************************
+SEQ,DECLARE.
*
+SEQ,ODPAR.
+SEQ,RCREP.
+SEQ,RBITFUNC.
*
      REAL PI
      PARAMETER(PI=3.141592653)
      REAL     SWCSGL,FKCSGL,SWCHI,SWCLO,FKCHI,FKCLO
      PARAMETER (SWCSGL=10., FKCSGL=10., SWCHI=10.,
     +           SWCLO =10., FKCHI =10., FKCLO=10.)
      REAL     SUCSGL,SUCHI,SUCLO
      PARAMETER (SUCSGL=10., SUCHI=10., SUCLO=10.)
      REAL     FKCSOP,SWCSOP
      PARAMETER (FKCSOP=10., SWCSOP=10.)
*
*- SW and FK energies. N=north hemi, S=south hemi, HI=max of N&S, LO=min
      REAL     SWMN,SWMS,SWMHI,SWMLO
      REAL     FKMN,FKMS,FKMHI,FKMLO
*- Sum of SW and FK energies. N,S,HI,LO as defined above
      REAL     SUMN,SUMS,SUMHI,SUMLO
      LOGICAL  SFYZT
*- Cluster energy is for SW and FK detector respectively
      LOGICAL  SWCAL,FKCAL
*- FD data
      INTEGER  NCL,I,NIWD,NRWD,IDAT(NIFDET),NIMOV,NRMOV
      REAL     RDAT(NRFDET)
*
      SFYZT = .FALSE.
      SWMN = 0.
      SWMS = 0.
      FKMN = 0.
      FKMS = 0.
*
*- Get the number of clusters in the event
      CALL ODNBLK('FDET',NCL)
      IF(NCL.LE.0)RETURN
*- Loop over the energy clusters. Make 4 energy sums, one each for SW and FK
*- for each hemisphere
      DO 100 I = 1, NCL
        CALL ODFBLK('FDET',I,NIFDET,IDAT,NIMOV,NRFDET,RDAT,NRMOV)
        IF(NIMOV.LE.0.OR.NRMOV.LE.0)GOTO 100
*- Look only at calorimeter information
        SWCAL = BTEST(IDAT(JFSOUR),19)
        FKCAL = BTEST(IDAT(JFSOUR),4)
        IF(.NOT.SWCAL.AND..NOT.FKCAL)GOTO 100
*- Look for crazy error, where this cluster is assigned to both detectors
        IF(SWCAL.AND.FKCAL)THEN
          CHREP=
     +    'Energy cluster assigned to both SiW and FK. Unpack error?'
          CALL REPORT('ROFDCL',1,'E')
          GOTO 100
        ENDIF
*- Sum cluster energies for each hemisphere for SW and FK separately
        IF(RDAT(JFTHET).LT.PI/2.)THEN
          IF(SWCAL)SWMN = SWMN + RDAT(JFE)
          IF(FKCAL)FKMN = FKMN + RDAT(JFE)
        ELSE
          IF(SWCAL)SWMS = SWMS + RDAT(JFE)
          IF(FKCAL)FKMS = FKMS + RDAT(JFE)
        ENDIF
100   CONTINUE
*- Make some useful comparison variables
        SWMHI = AMAX1(SWMN,SWMS)
        SWMLO = AMIN1(SWMN,SWMS)
        FKMHI = AMAX1(FKMN,FKMS)
        FKMLO = AMIN1(FKMN,FKMS)
        SUMN = SWMN + FKMN
        SUMS = SWMS + FKMS
        SUMHI = AMAX1(SUMN,SUMS)
        SUMLO = AMIN1(SUMN,SUMS)
*- Look for SW hemisphere with energy > SWCSGL
        IF(SWMHI.GE.SWCSGL)SFYZT = .TRUE.
*- Look for FK hemisphere with energy > FKCSGL
        IF(FKMHI.GE.FKCSGL)SFYZT = .TRUE.
*- Look for one SW hemi E > SWCHI and other hemi E > SWCLO
        IF(     SWMHI.GE.SWCHI
     +     .AND.SWMLO.GE.SWCLO)SFYZT = .TRUE.
*- Similarly for FK hemis
        IF(     FKMHI.GE.FKCHI
     +     .AND.FKMLO.GE.FKCLO)SFYZT = .TRUE.
*- Look for SW+FK energy in one hemi > SUCSGL
        IF(SUMHI.GE.SUCSGL)SFYZT = .TRUE.
*- One hemi SW+FK energy > SUCHI; other > SUCLO
        IF(     SUMHI.GE.SUCHI
     +     .AND.SUMLO.GE.SUCLO)SFYZT = .TRUE.
*- FK energy in one hemi > FKCSOP; SW energy in other hemi > SWCSOP
        IF(    (SWMN.GE.SWCSOP.AND.FKMS.GE.FKCSOP)
     +     .OR.(SWMS.GE.SWCSOP.AND.FKMN.GE.FKCSOP))
     +   SFYZT = .TRUE.
*
      RETURN
      END
+DECK,ROFYZS.
      SUBROUTINE ROFYZS(MEFYZS,M2FYZS,MFFYZS)
**********************************************************************
*.
*.
*..ROFYZS       Define the FYZS bit masks, which are essentially the FYZ1 bit
*.              masks without luminosity events
*.
*.  INPUT  :
*. OUTPUT  :        Bit masks for FYZS selection from:
*.           MEFYZS  first event-type word, IUHEAD(IIEVTY)
*.           M2FYZS second event-type word, IUHEAD(IIEVT2)
*.           MFFYZS       filter-type word, IUHEAD(IIFITY)
*.
*.  SEQUENCES :  ROTPAR
*.  CALLS     :  ------
*.  CALLED    :  ROEVTY ROFYZ1
*.
*.  AUTHORS   :  Chris Darling
*.  VERSION   :  1.00
*.  CREATED   :  12-Aug-93
*.  LAST MOD  :  26-Mar-99
*.
*.  Modification Log.
*. 26-Mar-99 G.W.Wilson Add IEOPTR for 1/100 triggered OPAL events
*. 16-Aug-98 E.Barberio Add the rhorho trigger to fyz1
*. 6-Oct-97 E.Barberio add Mip plug selection
*. 18-Jun-96 M.Schroder   Add new selections
*. 20-Feb-96 M.Schroder   Add chargino, neutralino, untagged 2 photon
*.                        and other exotics
*. 28-Jul-94 O.Schaile    Add TE trigger
*. 28-Jul-94 O.Schaile    Add TE trigger study bit
*.
************************************************************************
+SEQ,DECLARE.
*
+SEQ,ROTPAR.
*-- Following comment taken from ROFYZ1 and edited. This defines FYZS
*--   i) the lepton pair preselection     (bit   4 in event-type word 1)
*--  ii) the single photon preselection   (bit   8 in event-type word 1)
*-- iii) the converted photon preselection(bit   9 in event-type word 1)
*--  iv) the special single photon trigger(bit  14 in event-type word 1)
*--   v) the single phot. EM+TOF selection(bit  24 in event-type word 1)
*--  vi) the single phot. EM cluster sel. (bit  27 in event-type word 1)
*--      the sing. photon "hadron-safe" selection (bit 30 e-type word 1)
*--      long-lived decay candidate       (bit  31 in event-type word 1)
*-- vii) the heavy lepton preselections   (bits 10, 11 or 15 in
*--                                                   event-type word 1)
*--viii) the two photon preselection      (bit  12 in event-type word 1)
*--  ix) the higgs preselection           (bit  13 in event-type word 1)
*--   x) the Tokyo multihadron selection  (bit  16 in event-type word 1)
*--  xi) random beam crossing triggers    (bit  29 in event-type word 1)
*-- xii) gold-plated multi-hadrons        (bits 26 in filter word)
*--xiii) gold-plated e+e-/gamma-gamma     (bits 28 in filter word)
*-- xiv) gold-plated mu+mu-               (bits 29 in filter word)
*--  xv) gold-plated tau+tau-             (bits 30 in filter word)
*-- xvi) gold-plated lepton pair        (bits 31 in filter word)
*-- xvii) GACE, LMAE or MONO -loose Chargino selections
*-- xiix) NELO               -  loose neutralino selection
*--  xix) IUGG or UGGE       - in- or exclusive untaged 2 photon selection
*--   xx) IEWABB : Wide Angle BhaBha
*--  xxi) IEL2MH : LEP2 MultiHadron
*-- xxii) IEOPTR : One in a hundred triggered OPAL events
*--xxiii) IENRH1 : Non Radiative multiHadron, simple selection (WWSPRI via RONRMH)
*--       IENRH2 : Non Radiative multiHadron, complicated selection (WWSPR via RONRMH)
*-- xxiv) IEWW4Q : WW -> 4 quarks (WWQQQQ)
*         IEWWQE : WW -> 2 quarks + e nu (WWQQLN)
*         IEWWQM : WW -> 2 quarks + mu nu (WWQQLN)
*         IEWWQT : WW -> 2 quarks + tau nu (WWQQTN)
*         IEWWLL : WW -> lepton nu + lepton nu (WWLNLN)
*
* Masks for FYZS selection
      INTEGER  MEFYZS,M2FYZS,MFFYZS,MEPHYS,M2PHYS,MFPHYS
*
*-- Define a mask for FYZS selection from first event-type word
      PARAMETER ( MEPHYS =
     +   2**(IELLLM-1)
     + + 2**(IEGAM -1) + 2**(IEGCON-1) + 2**(IEGSTR-1) + 2**(IEGEMT-1)
     + + 2**(IEGEM -1) + 2**(IEGHOK-1) + 2**(IEGLLD-1)
     + + 2**(IEHLPT-1) + 2**(IEHLIS-1) + 2**(IEHLCM-1)
     + + 2**(IETWOP-1) + 2**(IEHIGS-1) + 2**(IETKMH-1) + 2**(IETRIG-1))
*-- Define a mask for FYZS selection from second event-type word
      PARAMETER ( M2PHYS = 2**(IETETR-33)
     +  + 2**(IEXXXX-33)
     +  + 2**(IETEMP-33) + 2**(IEOPTR-33)
     +  + 2**(IEGACE-33) + 2**(IELMAE-33) + 2**(IEMONO-33)
     +  + 2**(IENELO-33) + 2**(IEUGGE-33) + 2**(IEIUGG-33)
     +  + 2**(IEWABB-33) + 2**(IEL2MH-33) + 2**(IENRH1-33)
     +  + 2**(IENRH2-33) + 2**(IEWW4Q-33) + 2**(IEWWQE-33)
     +  + 2**(IEWWQM-33) + 2**(IEWWQT-33) + 2**(IEWWLL-33) )
*-- Define a mask for FYZS selection from filter word
      PARAMETER ( MFPHYS =   2**(26-1) + 2**(28-1)
     +                     + 2**(29-1) + 2**(30-1) + 2**(31-1))
*
      MEFYZS=MEPHYS
      M2FYZS=M2PHYS
      MFFYZS=MFPHYS
*
      RETURN
      END
+DECK,ROFYZT.
      SUBROUTINE ROFYZT(MEFYZT,M2FYZT,MFFYZT)
**********************************************************************
*.
*.
*..ROFYZT       Define the FYZT bit masks.
*.
*.  INPUT  :
*. OUTPUT  :        Bit masks for FYZT selection from:
*.           MEFYZT  first event-type word, IUHEAD(IIEVTY)
*.           M2FYZT second event-type word, IUHEAD(IIEVT2)
*.           MFFYZT       filter-type word, IUHEAD(IIFITY)
*.
*.  SEQUENCES :  ROTPAR
*.  CALLS     :  ------
*.  CALLED    :  ROEVTY ROFYZ1
*.
*.  AUTHORS   :  Chris Darling
*.  VERSION   :  1.00
*.  CREATED   :  12-Aug-93
*.  LAST MOD  :  27-Oct-97
*.
*.  Modification Log.
*. 27-Oct-97 D.Strom    drop bits 13 and 14 of filter type word
*.                      (SW keep filter and SW lumi filter),
*.                      add SW keep selection
************************************************************************
+SEQ,DECLARE.
*
+SEQ,ROTPAR.
*-- Following comment taken from ROFYZ1 and edited. This defines FYZT
*--   i) the luminosity selections        (bits 1, 2 or 3 in
*--                                                   event-type word 1)
*--  ii) validated luminosity selection   (bit  17 in event-type word 1)
*--      Also includes radiative Bhabha events found by routine ROFDCL
*-- iii) random beam crossing triggers    (bit  29 in event-type word 1)
*--  iv) the FD lumi filter selection     (bit  5 in filter word)
*--   v) the SW keep filter selection     (bit 13 in filter word) dropped !
*--  vi) the SW lumi filter selection     (bit 14 in filter word) dropped !
*-- vii) the SW tight bhabha selection    (bit 15 in filter word)
*--viii) the FD keep filter selection     (bit 22 in filter word)
*--  ix) gold-plated FD lumi Bhabha       (bit 27 in filter word)
*--   x) ROPE SW Keep selection           (bit IESWKP in event type)
*
* Masks for FYZT selection
      INTEGER  MEFYZT,M2FYZT,MFFYZT,MEPHYS,M2PHYS,MFPHYS
*
*-- Define a mask for FYZT selection from first event-type word
      PARAMETER ( MEPHYS =
     +   2**(IELUET-1) + 2**(IELUEM-1) + 2**(IELUCU-1) + 2**(IEFDTR-1)
     + + 2**(IETRIG-1) )
*-- Define a mask for FYZT selection from second event-type word
      PARAMETER ( M2PHYS = 2**(IESWKP-33) )
*-- Define a mask for FYZT selection from filter word
      PARAMETER ( MFPHYS =   2**( 5-1) +  2**(15-1) + 2**(22-1)
     +                     + 2**(27-1))
*
      MEFYZT=MEPHYS
      M2FYZT=M2PHYS
      MFFYZT=MFPHYS
*
      RETURN
      END
+DECK,ROFIN.
      SUBROUTINE ROFIN
*.
*...ROFIN    Termination step for RO
*.
*. SEQUENCE: CRO RCNTRL RCREP
*. CALLS   : TIMEX ROSUMF VFILL HCDIR HBOOK1 HPAK HOPERA HDELET
*. CALLED  : ROPFIN
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.03
*. CREATED : 18-May-87
*. LAST MOD: 12-May-89
*.
*. Modification Log.
*. 12-May-89 S.Weisz     Print Nb. of run time errors.
*.  5-Apr-89 S.Weisz     Call ROSUMF only in batch mode.
*. 23-Mar-89 S.Weisz     Set IRDEBU if any debug was asked.
*. 19-Mar-88 S.Weisz     Call ROSUMF.
*. 12-Oct-87 S.Weisz     Use of REPORT.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      REAL      RTIME,TMEAN
*
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
*-- Set DEBUG flag for the end level.
      IF(IRDEBG(1).GE.1) IRDEBU = IRDEBG(4)
*
      WRITE (CHREP,1010) IREVPR
      CALL REPORT('ROFIN ',1,'I')
*-- Compute one event processing time
      IF(IREVPR.GT.0)THEN
         CALL TIMEX(RTIME)
         TMEAN=(RTIME-RTIMST)/FLOAT(IREVPR)
         WRITE(CHREP,1020)TMEAN
         CALL REPORT('ROFIN ',2,'I')
      ENDIF
+SELF,IF=ERRECO,IF=IBM.
      IF(NTOTRP.NE.0) THEN
         WRITE (CHREP,1000) NTOTRP
         CALL REPORT('ROFIN ',3,'W')
      END IF
+SELF.
*
*-- Calls ROSUMF to print ROPE summary in batch mode.
      IF(IRINTR.EQ.0) CALL ROSUMF
*
      RETURN
 1000 FORMAT(I6,' Run time error occured for this job')
 1010 FORMAT(' Number of events processed  =',I8)
 1020 FORMAT(' Time to process one event is =',F10.4, ' seconds')
*
      END
+DECK,ROFYZ1.
      SUBROUTINE ROFYZ1(MEFYZ1,M2FYZ1,MFFYZ1)
*.
*...ROFYZ1  Returns masks used to define the Phys1 selection.
*.
*.          This enables the masks to be accessed from any analysis
*.          code, while still allowing them to be modified by means
*.          of PATCHY CRADLEs (not possible if in a KEEP sequence).
*.
*.          These are masks provided for users who rely upon them for
*.          their analyses, but are not used for the FYZ1 stream
*.          selection. This now done via a logical OR of the FYZS
*.          and FYZT masks, which are defined in routines ROFYZS and
*.          ROFYZT.
*.
*. OUTPUT  :        Bit masks for Phys1 selection from:
*.           MEFYZ1  first event-type word, IUHEAD(IIEVTY)
*.           M2FYZ1 second event-type word, IUHEAD(IIEVT2)
*.           MFFYZ1       filter-type word, IUHEAD(IIFITY)
*.
*. SEQUENCE: RBITFUNC
*. CALLS   : ROFYZS ROFYZT
*. CALLED  : utility routine
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.02
*. CREATED : 24-Apr-91
*. LAST MOD: 23-Aug-93
*.
*. Modification Log.
*.  23-Aug-93  C.Darling Redefine FYZ1 in terms of FYZS and FYZT
*.  12-May-93  C.Hawkes  Add SW keep filter selection to Phys1
*.   7-Sep-92  O.Schaile    Changes for RGTOEM (from G.Wilson)
*.  11-May-91  C.Hawkes  Add single photon EM cluster selection
*.  24-Apr-91  C.Hawkes  Define Phys1 masks for 1991 selection.
*.                       Add explicit selection of all
*.                       "gold-plated" filter selections.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RBITFUNC.
*
*-- FYZ1 or Phys1 selection = any of the following
*--   i) the luminosity selections        (bits 1, 2 or 3 in
*--                                                   event-type word 1)
*--  ii) validated FD triggers selection  (bit  17 in event-type word 1)
*-- iii) the lepton pair preselection     (bit   4 in event-type word 1)
*--  iv) the single photon preselection   (bit   8 in event-type word 1)
*--   v) the converted photon preselection(bit   9 in event-type word 1)
*--  vi) the special single photon trigger(bit  14 in event-type word 1)
*-- vii) the single phot. EM+TOF selection(bit  24 in event-type word 1)
*--viii) the single phot. EM cluster sel. (bit  27 in event-type word 1)
*--      the sing. photon "hadron-safe" selection (bit 30 e-type word 1)
*--      long-lived decay candidate       (bit  31 in event-type word 1)
*--  ix) the heavy lepton preselections   (bits 10, 11 or 15 in
*--                                                   event-type word 1)
*--   x) the two photon preselection      (bit  12 in event-type word 1)
*--  xi) the higgs preselection           (bit  13 in event-type word 1)
*-- xii) the Tokyo multihadron selection  (bit  16 in event-type word 1)
*--xiii) the other special triggers       (bit  29 in event-type word 1)
*-- xiv) the luminosity filter selection  (bit   5 in filter word)
*--  xv) the SW keep filter selection     (bit  13 in filter word)
*-- xvi) the gold-plated filter selections(bits 26-31 in filter word)
*
*-- Masks for FYZ1 selection
      INTEGER MEFYZ1,M2FYZ1,MFFYZ1
*
*-- Masks for FYZS & FYZT selections
      INTEGER MEFYZS,M2FYZS,MFFYZS,MEFYZT,M2FYZT,MFFYZT
*
      CALL ROFYZS(MEFYZS,M2FYZS,MFFYZS)
      CALL ROFYZT(MEFYZT,M2FYZT,MFFYZT)
*
      MEFYZ1 = IOR(MEFYZS,MEFYZT)
      M2FYZ1 = IOR(M2FYZS,M2FYZT)
      MFFYZ1 = IOR(MFFYZS,MFFYZT)
*
      RETURN
      END
+DECK,ROGTUN.
      SUBROUTINE ROGTUN(LUN,WATFOR)
*.
*...ROGTUN  Assigns a logical i/o unit
*.
*. CALLS   : REPORT
*. CALLED  : RGETUN RFMINI RIOFIL RSCATA RSPHON
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED :  8-Jan-91
*. LAST MOD:  5-Fev-91
*.
*. Modification Log.
*.  5-Fev-91 S.Weisz     Temporary comment of AUTOUNIT
*.
*.*********************************************************************
+SEQ,DECLARE.
      LOGICAL       OPENED
      INTEGER       LUN,LU
      CHARACTER*(*) WATFOR
      CHARACTER*8   FORWAT
+SEQ,ROUNIT.
+SEQ,RCREP.
*
      IF(LUN.EQ.0) THEN
CCCCCC Temporary comment of AUTOUNIT
CCC      IF(LAUTOU) THEN
CCC         DO 10 LU=1,NROPEU
CCC            IF(UNIUSE(LU).EQ.' '.OR.UNIUSE(LU).EQ.WATFOR) THEN
CCC               INQUIRE(LU,OPENED=OPENED)
CCC               IF(.NOT.OPENED) THEN
CCC                   LUN   = LU
CCC                                                             GO TO 20
CCC               END IF
CCC            END IF
CCC10       CONTINUE
CCC         CHREP  = 'No free logical unit is left'
CCC         CALL REPORT('ROGTUN',1,'E')
CCC                                                            GO TO 999
CCC      ELSE
            CHREP  = 'The ''AUTOUNIT'' facility was not enabled'
            CALL REPORT('ROGTUN',2,'E')
                                                               GO TO 999
CCC      END IF
      ELSE IF(LUN.LT.0.OR.LUN.GT.NROPEU) THEN
         CHREP  = 'Invalid logical unit'
         CALL REPORT('ROGTUN',3,'E')
                                                               GO TO 999
      ELSE
CCC      IF(LAUTOU) THEN
CCC         CHREP  = 'The ''AUTOUNIT'' facility was enabled. '//
CCC  +               'Unit has to be 0'
CCC         CALL REPORT('ROGTUN',4,'E')
CCC                                                            GO TO 999
CCC      ELSE
            FORWAT = UNIUSE(LUN)
            IF(FORWAT.NE.' '.AND.WATFOR.NE.FORWAT) THEN
               CHREP  = 'This unit might already be used by '//FORWAT
               CALL REPORT('ROGTUN',5,'W')
            END IF
CCC      END IF
CCCCCC End of temporary comment of AUTOUNIT
      END IF
   20 UNIUSE(LUN) = WATFOR
*
  999 RETURN
      END
+DECK,ROINIT.
      SUBROUTINE ROINIT
*.
*...ROINIT   Initializes ROPE: Define FFREAD cards
*.                             and sets default values.
*.
*. SEQUENCE: ROBANK CRO RCNTRL ROPAR RCREP CFPAR CRVER
*.           ODPAR ODCOM1 QFTITLE TIMEQQ DATEQQ MONITO ROCEXP
*. COMMON  : ZHEADP
*. CALLS   : VFILL VZERO UCTOH MZIOCH FFKEY RLUINI
*. CALLED  : ROPINI
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.02
*. CREATED : 28-May-87
*. LAST MOD: 15-May-1998
*.
*. Modification Log:
*. 15-May-98 N.K.Watson Update LCALRD/LCALWT for 23 processes.
*. 10-Jul-97 E.Barberio new datacard inhibit update of the beam energy
*. 20-Jun-96 M.Schroder         NRPROC 43 -> 49 (thanks Nige)
*. 22-Sep-95 O.Schaile          implement *EVSEL
*. 26-JUN-95 M.Schroder         zero 44 elements of LCALRD, LCALWT
*. 22-May-95 M.Schroder         len(LCALREAD)=>44
*.  5-May-95 M.Schroder         zero 42 elements of LCALRD, LCALWT
*.  9-Feb-94 M.Redmond          Change default IFODSI=1
*.  1-Feb-94 O.Schaile          treat *GET like *EVENT
*. 28-Jan-93 O.Schaile          Repl ITRYMX NTRYMX(1)
*. 29-Jul-93 T. Smith           Add call to FCGLOB
*. 20-Jul-93 O.Schaile          new FFREAD card *SUDB
*. 11-Oct-92 D.Lellouch  Number of Rope processes is now parametrized
*.                       Technical changes following introduction of DC
*. 26-Jun-92 O.Schaile          remove BEAM + GOPAL FFREAD card
*. 25-Jun-92 O.Schaile          put back setting of IVGOPA (=129)
*.  4-Jun-92 O.Schaile          remove setting of IVGOPA
*. 27-Mar-92 O.Schaile          Init LFATLW
*. 25-Feb-92 O.Schaile          RTIMSF =20. (default TSAFE)
*. 18-Feb-92 C.Hawkes           Define LLBAT and LABAT cards
*. 14-Feb-92 O.Schaile          IVGOPA = 128
*. 07-Feb-92 N.K.Watson         Init top directory names for main dbs
*. 21-JAN-92 O.Schaile          Init IFCNST to -1 (rather then +1)
*. 28-Nov-91 O.Schaile          Init KEEPJU
*. 03-Sep-91 S.Weisz            Clear ROPE and GR versions in ROPINI.
*. 23-Apr-91 D.Lellouch         Implement *EVTFILE,*NANOFILE,*MASTERNA.
*. 14-Mar-91 D.Lellouch         Implement the new *DADFILE card syntax.
*.  8-Mar-91 S.Weisz            Allocate HIGZ,GKS and Metafile if GR.
*.  5-Fev-91 S.Weisz            Comment some facilities (Temporary).
*. 24-Jan-91 D.Lellouch         Define bunch of FATMEN related cards.
*. 11-Oct-90 A.Lee              Add *DADLIST card.
*.  5-Apr-90 S.Weisz            Define DDPACK,DDUNPACK cards.
*. 29-Mar-90 S.Weisz            Initialise NSUMF for on-line monitoring.
*.  9-Mar-90 C.M.Hawkes         Call RLUINI
*. 10-Feb-90 S.Weisz            Initialise IFUPDT,INDROP
*. 16-Oct-89 S.Weisz            Define SCBAT card
*. 17-Sep-89 C.Hawkes,S.Weisz   Initialise common RCNTRL and SCAN flags.
*. 29-Jul-89 S.Weisz            Introduce JC version No.
*. 23-Jun-89 D.Ward             IOREV, IOHEAD are now arrays of 2 words
*. 19-Jun-89 S.Weisz            Define TTBAT,TRBAT and FIBAT cards
*.  7-Jun-89 S.Weisz            Expand LCALRD,LCALWT for TR,TT,SC,FI
*. 25-May-89 S.Weisz            Change IOREV to the new event header
*. 12-May-89 S.Weisz            Initialise run time error counters
*. 10-Mar-89 S.Weisz            REV IO characteristic to *I-F
*. 10-Mar-89 A.Buijs,S.Weisz    Move OD stuff to ODINIT
*. 23-Fev-89 S.Weisz            Define FFREAD card REPORT in RGINIT
*. 17-Fev-89 S.Weisz            Preset flag ICMAIN
*.  9-Fev-89 S.Weisz            Geant initialization now in RGINIT
*.  8-Fev-89 S.Weisz            Add cards CALREAD/CALWRITE.
*.  7-Fev-89 S.Weisz            Add card ZLOGLEV do define ZEBRA logging.
*. 23-Jan-89 S.Weisz            Get version/creation date through
*.                              Patchy title card.
*.                              Ffread card READTRY and REPORT.
*. 12-Jan-89 S.Weisz            Link area for ROPE master pointers
*.                              now declared in ROPPAK.
*. 20-Dec-88 S.Weisz            Initialize some GEANT commons.
*.  7-Sep-88 S.Weisz            OD initialisation now in block data.
*.                              Add "FZLIMIT" Ffread card.
*. 29-Aug-88 S.Weisz            Implement RERUN card.
*. 24-May-88 S.Weisz            Constant structure read from input
*.                              or lifted in RBKRCO.
*.  5-May-88 S.Weisz            Initialize OD steering.
*.  5-Apr-88 A.Buijs            Add utility bank for IO, set up IO cards
*. 14-Mar-88 S.Weisz            Division declared in ROPPAK.
*. 20-Nov-87 S.Weisz            Implementation of a statistical division
*.                              Use of bank parameter from ROCPAR,ROSPAR
*.                              Define FFREAD cards with 8 characters;
*.                              Get IO Characteristics for REV,CFTS.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IV1,IV2,IVERSN,IDFLT,I
      INTEGER IDATQQ
      CHARACTER*6  IOCHAR
*--           ZEBRA system common blocks.
      INTEGER IQHEAD,IQDATE,IQTIME,IQPAGE,NQPAGE
      COMMON/ZHEADP/IQHEAD(20),IQDATE,IQTIME,IQPAGE,NQPAGE(4)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,CRVER.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CFPAR.
+SEQ,FMPAR.
+SEQ,RCREP.
+SEQ,MONITO.
+SEQ,ROCEXP.
*
      INTEGER     NRPROC
      PARAMETER  (NRPROC=49)
      DIMENSION   IVERSN(4,NRPROC)
      EQUIVALENCE(IVERSN,IVUS)
*
      CALL VZERO(IVERSN,4*NRPROC)
*
*-- Get ROPE version from Patchy title card.
      WRITE(CHREP,1000)
      READ(CHREP,1010) IV1,IV2,ISVRO
      IVRO = 100*IV1 + IV2
*-- Get date of library creation (XXGENLIB).
+SEQ,DATEQQ.
      IDACRO = IDATQQ
*-- Get date of last modification of the cradle.
+SELF,LASTMOD.
      READ(CHREP,1020) IDAMRO
+SELF.
*
      IRDATE = IQDATE
      IRTIME = IQTIME
      IVGOPA = 129
      IREVNT =   0
      IREVPR =   0
      NEVTRP =   0
      NTOTRP =   0
      ISDATE =   0
      ISTIME =   0
      IFODSI =   1
*-- Initialize interactive selection common RCNTRL.
      NSLCMI =   0
      NSLCMA =   9999
      ESLEMI =   0.
      ESLEMA =   9999.
      ESLHMI =   0.
      ESLHMA =   9999.
      NSLMMI =   0
      NSLMMA =   9999
      ISLEVT =   0
      ISLRUN =   0
      IFSLON =   0
*-- Sets default values for FFREAD data.
      CALL UCTOH('    ',IDFLT,4,4)
      RTIMSF    =       20.
      RFZLIM    =      -1.
      RTIMSI    =       0.
      RTIMSE    =       0.
      IRBEAM    =       0
      IRTRIG(1) =       0
      IRTRIG(2) =10000000
      IRTRIG(3) =       1
      IRDEBG(1) =       0
      IRDEBG(2) =       0
      IRDEBG(3) =       1
      IRDEBG(4) =       1
      IMONIT    =       0
      IZVERI    =       0
      IZLOGL    =      -2
      ITTBAT    =       0
      ITRBAT    =       0
      IFIBAT    =       0
      ISCBAT    =       0
      IDDBAT    =      -1
      IDUBAT    =       0
      IFCNST    =      -1
      IFSCAN    =       0
      IFDROP    =       1
      IFUPDT    =      -1
      IFNOEU    =       0
      NOWRIT    =       0
      INDROP    =       0
      NSTOP     =      99
      KEEPJU    =       0
      ILLBAT    =       0
      ILABAT    =       0
      CALL VFILL(NCENT,7,0)
      CALL VFILL(LCENT,140,IDFLT)
      NRERUN    =       0
      CALL VFILL(LRERUN,20,IDFLT)
      LCAUNI    =       0
*- NKW mods start.
*-- Initialise default top directory names for various expt. numbers.
      DO 3 ICMAIN=1,MAXEXP
        CHTNOM(ICMAIN)='    '
    3 CONTINUE
*- NKW mods end.
      CALL VBLANK(LCANAM,NAMLWO)
      CALL VZERO(LFITYP,NPAFIL)
      CALL VBLANK(LFINAM,NAMLWO)
      CALL VZERO(LCFTYP,NPACFI)
      CALL VBLANK(LCFNAM,NAMLWO)
      CALL VZERO(LFATYP,NPAFAT)
      CALL VBLANK(LFANAM,NAMLWO)
      CALL VZERO(LDATYP,NPADAD)
      CALL VBLANK(LDANAM,NAMLWO)
      CALL VBLANK(LDEVNA,NAMLWO)
      CALL VZERO(LNADIR,NPANAN)
      CALL VBLANK(LNANAM,NAMLWO)
      CALL VZERO(LEVDIR,NPAEVT)
      CALL VBLANK(LEVNAM,NAMLWO)
      CALL VZERO(LMNDIR,NPAMAS)
      CALL VBLANK(LMNNAM,NAMLWO)
CCC   CALL VZERO(IPHONE,NPHONE)
      CALL VBLANK(LTYPDE,1)
      CALL VBLANK(LFOOPT,1)
CCC   LUFONE    =       0
      LNDEVI    =       0
      NDUMMY    =       0
      CALL VZERO(NCHAOU,NROPEU)
      CALL VZERO(NFZUSE,NROPEU)
      CALL VZERO(IUNITU,NUNITU)
      CALL VZERO(UNIOUT,NOSTRE)
*--   Fill the list of the usage of all logical units
      DO 10 I=1,NROPEU
      UNIUSE(I) = ' '
   10 CONTINUE
*-- Check if we are doing any Graphic.
      IF(IVGR.NE.0) THEN
         UNIUSE(1)='HIGZ'
         DO 20 I=91,93
         UNIUSE(I) = 'Cern_Gks'
   20    CONTINUE
         UNIUSE(41) = 'Gosip'
         UNIUSE(42) = 'Gks_err.'
         DO 30 I=43,49
         UNIUSE(I) = 'Rope_Gks'
   30    CONTINUE
         UNIUSE(47) = 'METAOUT'
      END IF
      DO 40 I=5,7
      UNIUSE(I) = 'System'
   40 CONTINUE
*
      LFATLU    =       0
      LFATLW    =       0
      LFATLO    =      -1
      LASTNI    =       0
      LASTRE    =       0
      LASTCI    =       0
      LASTCO    =       0
      LASTDI    =      -1
      LASTDO    =       0
      NINPUT    =       0
      LUDAIN    =       0
      LMSOPE    = .FALSE.
      LDAOPE    = .FALSE.
      LEOFIN    = .FALSE.
      LAUTOU    = .FALSE.
      LONEOF    = .FALSE.
      FFERRO    = .FALSE.
      LCATAL    = .FALSE.
      LMEMIN    = .FALSE.
      LPACKO=.FALSE.
      LMEMOU    = .FALSE.
      DO 50 I=1,NXDEVI
      TAPMOU(I) =   '???'
      LDVALL(I) = .FALSE.
      EXADEV(I) =       0
   50 CONTINUE
      EXALAS    =       0
      CALL RSSYST
*
      CALL VZERO(LEVKEY,4)
      CALL VZERO(LREKEY,3)
*      CALL VZERO(LGEKEY,2)
      CALL VZERO(LCALRD,46)
      CALL VZERO(LCALWT,46)
      ICMAIN    =       0
      NTRYMX(1)=10
      NTRYMX(2)=5
      NSUMF     =     250
*--   event selection bits
      CALL VZERO(MSHDSL,10)
      MSANYS=0
      CALL VZERO(ISEKEY,3)
*-- Zero LUMI counting arrays.
      CALL RLUINI
*-- Get IO characteristic for bank REV.
      CALL MZIOCH(IOREV,2,'5I 9B -I')
      CALL UCOPY(IOREV,IOHEAD,2)
*-- Get IO characteristic for bank CFTS.
      WRITE(IOCHAR,1030) NICFTS
      CALL MZIOCH(IOCFTS,1,IOCHAR)
*-- Define main data cards.
      CALL FFKEY('TSAFE'   ,RTIMSF,     1,'REAL'   )
CCC   CALL FFKEY('INPUTSAF',RTIMSI,     1,'REAL   ')
CCC   CALL FFKEY('EVENTSAF',RTIMSE,     1,'REAL   ')
      CALL FFKEY('FZLIMIT' ,RFZLIM,     1,'REAL'   )
*      CALL FFKEY('GOPAL'   ,IVGOPA,     1,'INTEGER')
*      CALL FFKEY('BEAM'    ,IRBEAM,     1,'INTEGER')
      CALL FFKEY('TRIGGER' ,IRTRIG,     3,'INTEGER')
      CALL FFKEY('DEBUG'   ,IRDEBG,     4,'INTEGER')
      CALL FFKEY('MONITOR' ,IMONIT,     1,'INTEGER')
      CALL FFKEY('ZVERIFY' ,IZVERI,     1,'INTEGER')
      CALL FFKEY('ZLOGLEV' ,IZLOGL,     1,'INTEGER')
      CALL FFKEY('READTRY' ,NTRYMX,     2,'INTEGER')
      CALL FFKEY('CENTRAL' ,LCENT ,    20,'MIXED'  )
      CALL FFKEY('ECAL'    ,LECAL ,    20,'MIXED'  )
      CALL FFKEY('HCAL'    ,LHCAL ,    20,'MIXED'  )
      CALL FFKEY('MUON'    ,LMUON ,    20,'MIXED'  )
      CALL FFKEY('FORW'    ,LFORW ,    20,'MIXED'  )
      CALL FFKEY('RERUN'   ,LRERUN,    20,'MIXED'  )
      CALL FFKEY('FILE    ',LFITYP,NPFILE,'MIXED  ')
      CALL FFKEY('SUDB    ',LFINAM,NAMLWO,'MIXED  ')
      CALL FFKEY('FATFILE ',LFATYP,NPFATF,'MIXED  ')
      CALL FFKEY('CATFILE ',LCFTYP,NPFILE,'MIXED  ')
      CALL FFKEY('CATALOG ',LCAUNI,NPCATA,'MIXED  ')
      CALL FFKEY('FATMEN  ',LFATLU,     3,'INTEGER')
      CALL FFKEY('GETDEVIC',LNDEVI,NPGDEV,'MIXED  ')
CCC   CALL FFKEY('USPHONE ',IPHONE,NPHONE,'MIXED  ')
CCC   CALL FFKEY('AUTOUNIT',IUNITU,NUNITU,'INTEGER')
+SELF,IF=VAX.
CCC   CALL FFKEY('PHONE   ',LUFONE,     2,'MIXED  ')
+SELF,IF=VAX,UNIX.
      CALL FFKEY('DADFILE ',LDATYP,NPDADL,'MIXED  ')
+SELF,IF=UNIX.
      CALL FFKEY('NANOFILE',LNADIR,NPNANO,'MIXED  ')
      CALL FFKEY('EVTFILE ',LEVDIR,NPEVTL,'MIXED  ')
      CALL FFKEY('MASTERNA',LMNDIR,NPMAST,'MIXED  ')
+SELF.
      CALL FFKEY('EVENT'   ,LEVKEY,     4,'INTEGER')
      CALL FFKEY('READIN'  ,LREKEY,     3,'INTEGER')
      CALL FFKEY('GET'     ,LEVKEY,     4,'INTEGER')
*      CALL FFKEY('GET'     ,LGEKEY,     2,'INTEGER')
      CALL FFKEY('CALREAD' ,LCALRD,    46,'MIXED'  )
      CALL FFKEY('CALWRITE',LCALWT,    46,'MIXED'  )
      CALL FFKEY('TTBAT'   ,ITTBAT,     1,'INTEGER')
      CALL FFKEY('TRBAT'   ,ITRBAT,     1,'INTEGER')
      CALL FFKEY('FIBAT'   ,IFIBAT,     1,'INTEGER')
      CALL FFKEY('SCBAT'   ,ISCBAT,     1,'INTEGER')
      CALL FFKEY('DDPACK'  ,IDDBAT,     1,'INTEGER')
      CALL FFKEY('DDUNPACK',IDUBAT,     1,'INTEGER')
      CALL FFKEY('CONSTANT',IFCNST,     1,'INTEGER')
      CALL FFKEY('SCAN'    ,IFSCAN,     1,'INTEGER')
      CALL FFKEY('UPDATE'  ,IFUPDT,     1,'INTEGER')
      CALL FFKEY('NOEBUPDT',IFNOEU,     1,'INTEGER')
      CALL FFKEY('NODROP'  ,INDROP,     1,'INTEGER')
      CALL FFKEY('KEEPJUNK',KEEPJU,     1,'INTEGER')
      CALL FFKEY('PARTIAL' ,NSUMF ,     1,'INTEGER')
      CALL FFKEY('LLBAT'   ,ILLBAT,     1,'INTEGER')
      CALL FFKEY('LABAT'   ,ILABAT,     1,'INTEGER')
      CALL FFKEY('ODTOSI'  ,IFODSI,     1,'INTEGER')
      CALL FFKEY('EVSEL'   ,ISEKEY,     3,'MIXED  ')
*
      RETURN
 1000 FORMAT(
+SEQ,QFTITLE,N=24.
     +            )
 1010 FORMAT(8X,I1,1X,I2,1X,I2)
 1020 FORMAT(18X,I6)
 1030 FORMAT(I2,'I -F')
      END
+DECK,ROMONI.
      SUBROUTINE ROMONI(JPROC,IRESET)
*.
*...ROMONI   Monitor time and space used in each processor.
*.
*. INPUT     : JPROC  Index of the monitored processor.
*.             IRESET Flag set to one to reset time and space counters.
*.
*. SEQUENCES : ROBANK CRO RCNTRL ROSLNK RCREP MONITO
*. CALLS     : TIMEX ROSIZE REPORT
*. CALLED    : ROPBAT
*.
*. BANK M    : RTIS RSPS RTI2 RSP2
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 21-Mar-1990
*. LAST MOD:   28-Mar-96
*.
*. Modification Log.
*. 28-Mar-96  O.Schaile      Introduce TE process.
*.  3-Mar-93  O.Schaile      Introduce SW process.
*. 16-Apr-91 S.Weisz       Implement LL monitoring.
*. 21-Jan-91 S.Weisz       Implement DX and SI monitoring.
*. 23-Oct-90 S.Weisz       Implement OC and DD monitoring.
*.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER     JPROC,IRESET,NWORST,NWORSP,NBANKS,NLINKS,NDATAS,NPROC
      REAL        BTIMST,BTIMSP,DBTIMS,DNWORS
      PARAMETER   (NPROC=31)
      CHARACTER*2 PROC(NPROC)
      SAVE        NWORST,BTIMST,PROC
      INTEGER      IQUEST
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROSLNK.
+SEQ,RCREP.
*
      DATA PROC/'US','OC','DD','CV','CJ','CZ','CT','DX','CX','SI',
     +          'CS','CE','CA','TB','PB','EB','PE','EE','EM','HB',
     +          'HE','HP','HM','MB','ME','MM','FD','SW','OD','LL',
     +          'TE'/
*
      IF(IMONIT.NE.1)                                           GO TO 10
      IF(IRESET.EQ.1) THEN
*-- Get new start values.
         CALL TIMEX(BTIMST)
*
         CALL ROSIZE(LREV,'    ',NBANKS,NDATAS,NLINKS,NWORST)
*
                                                               GO TO 999
      ELSE IF(JPROC.GE.1) THEN
*-- Monitor process JPROC ( JPROC=1 ---> User's routines)
         CALL TIMEX(BTIMSP)
         DBTIMS = BTIMSP - BTIMST
         Q(LRTIS+JPROC)=Q(LRTIS+JPROC)+DBTIMS
*
         IF(JPROC.GE.4) THEN
            Q(LRTI2+JPROC)=Q(LRTI2+JPROC)+(DBTIMS**2)
*
            CALL ROSIZE(LREV,'    ',NBANKS,NDATAS,NLINKS,NWORSP)
            DNWORS = FLOAT(NWORSP - NWORST)
            Q(LRSPS+JPROC)=Q(LRSPS+JPROC)+DNWORS
            Q(LRSP2+JPROC)=Q(LRSP2+JPROC)+(DNWORS**2)
            NWORST = NWORSP
         END IF
*
      END IF
*
   10 CONTINUE
      IF(IRESET.EQ.1)                                          GO TO 999
*-- Verify ZEBRA structure (Except for USER and OC calls)
      IF(IZVERI.EQ.1.AND.JPROC.NE.1.AND.JPROC.NE.2) THEN
         CALL DZVERI('    ',IRODIV,'CLSU')
         IF(IQUEST(1).NE.0) THEN
            IF(JPROC.GE.3) THEN
               WRITE(CHREP,1000) PROC(JPROC)
            ELSE
               CHREP = 'ZEBRA messed-up after CF process'
            END IF
            CALL REPORT('ROMONI',1,'F')
         END IF
      END IF
*
      IF(IMONIT.EQ.1) CALL TIMEX(BTIMST)
*
  999 RETURN
*
 1000 FORMAT('ZEBRA messed-up after ',A2,' process')
*
      END
+DECK,ROMOUN,IF=VAX.
      SUBROUTINE ROMOUN(ACTION,DEVICE,LABEL,LTAPE,IERR)
*.
*...ROMOUN Allocate devices or mount tapes for multiple reading from vax.
*.
*. INPUT     : ACTION can be
*.                            'A' to allocate device DEVICE
*.                            'R' to release device DEVICE
*.                            'M' to mount tape LABEL on device DEVICE
*.                            'D' to dismount tape LABEL on device DEVICE
*.
*.             DEVICE is the device name string, ended with a ":"
*.             LABEL  is the tape label string; blank mean unlabelled
*.             LTAPE  logical name: if true mount tapes as proper tapes
*.                   (i.e. change the BlockSize to 32400 bytes)
*.
*. OUTPUT    : IERR is an integer : 0 means all right , 1 if an error
*.                  condition has occoured.
*.
*. SEQUENCES : DECLARE RCREP
*. CALLS     : REPORT SYS$ALLOC SYS$DALLOC SYS$MOUNT SYS$DISMOUN LIB$WAIT
*.             LENOCC SPACES
*. CALLED    : ROOFLX ROPFIN
*.
*. AUTHOR    : F.Odorici
*. VERSION   : 1.00
*. CREATED   :  5-Nov-1990
*. LAST MOD  :  2-Apr-1991
*.
*. Modification log:
*.   2-Apr-91 B.Lorazo   Add RECORDSIZE for Unlabelled tapes
*.   5-Nov-90 F.Odorici  Create this routine
*.
*.********************************************************************
+SEQ,DECLARE.
      CHARACTER*1 ACTION
      CHARACTER*(*) DEVICE,LABEL
      LOGICAL LTAPE
      INTEGER IERR
*
      CHARACTER NOW*8,SPACES*63,DEVNAM*63
      INTEGER I,LENOCC
*
      INTEGER AINFO,DINFO,MINFO,MNTOPT,BLKSIZ,RECSIZ
*
      INCLUDE '($SSDEF)'
      INCLUDE '($MNTDEF)'
*
      INTEGER SYS$ALLOC,SYS$DALLOC,SYS$MOUNT,SYS$DISMOU
+SEQ,RCREP.
*-- Definition of one item for the $MOUNT item list.
      STRUCTURE /MITEM/
       UNION
        MAP
         INTEGER*2 BUFLEN
         INTEGER*2 CODE
         INTEGER*4 BUFADR
         INTEGER*4 RLEADR
        END MAP
        MAP
         INTEGER*4 ENDLIS
        END MAP
       END UNION
      END STRUCTURE
      RECORD /MITEM/ MPAR(5)
*-- Set "No error" condition.
      IERR   = 0
*-- Remove trailing blanks in device name.
*-- Check also last non-blank character: it must be a ":" !!!
      DEVNAM = SPACES(DEVICE,1)
      IF(LENOCC(DEVNAM).LT.63) THEN
         IF(DEVNAM(LENOCC(DEVNAM):LENOCC(DEVNAM)).NE.':') THEN
            DEVNAM(LENOCC(DEVNAM)+1:LENOCC(DEVNAM)+1) = ':'
         END IF
      END IF
*-- Allocate action.
      IF(ACTION.EQ.'A') THEN
*
         AINFO  = SYS$ALLOC(DEVNAM, , , , )
         IF(.NOT.AINFO) THEN
            IERR   = 1
            IF(AINFO.EQ.SS$_NODEVAVL) THEN
               CHREP  = 'Device '//DEVNAM(1:LENOCC(DEVNAM))//
     +                  ' not available.'
               CALL REPORT('ROMOUN',1,'E')
            ELSE IF(AINFO.EQ.SS$_DEVALLOC) THEN
               CHREP  = 'Device '//DEVNAM(1:LENOCC(DEVNAM))//
     +                  ' already allocated to another process.'
               CALL REPORT('ROMOUN',2,'E')
            ELSE IF(AINFO.EQ.SS$_NOSUCHDEV) THEN
               CHREP  = 'Device '//DEVNAM(1:LENOCC(DEVNAM))//
     +                  ' doesn''t exist.'
               CALL REPORT('ROMOUN',3,'E')
            ELSE
               CHREP  = 'Devices '//DEVNAM(1:LENOCC(DEVNAM))//
     +                  ' not allocated. Please check the name '//
     +                  DEVNAM(1:LENOCC(DEVNAM))//'.'
               CALL REPORT('ROMOUN',4,'E')
            END IF
         ELSE
            CHREP  = 'Device '//DEVNAM(1:LENOCC(DEVNAM))//
     +               ' allocated.'
            CALL REPORT('ROMOUN',5,'I')
                                                               GO TO 999
         END IF
*-- Release action.
      ELSE IF(ACTION.EQ. 'R') THEN
*
         AINFO  = SYS$DALLOC(DEVNAM, )
         IF(.NOT.AINFO) THEN
            IERR   = 1
            CHREP  = 'Device '//DEVNAM(1:LENOCC(DEVNAM))//
     +               ' not deallocated: stop.'
            CALL REPORT('ROMOUN',7,'E')
C           CALL LIB$SIGNAL(%VAL(AINFO))
         ELSE
            CHREP  = 'Device '//DEVNAM(1:LENOCC(DEVNAM))//
     +               ' deallocated.'
            CALL REPORT('ROMOUN',8,'I')
         END IF
*-- Mount action.
      ELSE IF(ACTION.EQ.'M') THEN
*
         MPAR(1).BUFLEN = LEN(DEVNAM)
         MPAR(1).BUFADR = %LOC(DEVNAM)
         MPAR(1).CODE   = MNT$_DEVNAM
         IF(LABEL.NE.' ') THEN
            MPAR(2).BUFLEN = LEN(LABEL)
            MPAR(2).CODE   = MNT$_VOLNAM
            MPAR(2).BUFADR = %LOC(LABEL)
         ELSE
            MNTOPT         = MNT$M_FOREIGN
            MPAR(2).BUFLEN = 4
            MPAR(2).CODE   = MNT$_FLAGS
            MPAR(2).BUFADR = %LOC(MNTOPT)
         END IF
         IF(LTAPE) THEN
            BLKSIZ         = 32400
            RECSIZ         = BLKSIZ
            MPAR(3).BUFLEN = 4
            MPAR(3).CODE   = MNT$_BLOCKSIZE
            MPAR(3).BUFADR = %LOC(BLKSIZ)
            MPAR(4).BUFLEN = 4
            MPAR(4).CODE   = MNT$_RECORDSIZ
            MPAR(4).BUFADR = %LOC(RECSIZ)
            MPAR(5).ENDLIS = 0
         ELSE
            MPAR(3).ENDLIS = 0
         END IF
         MINFO  = SYS$MOUNT(MPAR)
*-- Get the current time
         CALL TIME(NOW)
         IF(.NOT.MINFO) THEN
            IERR   = 1
            CHREP  = 'Tape '//LABEL(1:LENOCC(LABEL))//
     +               ' not mounted on device '//
     +               DEVNAM(1:LENOCC(DEVNAM))//'. Time: '//NOW
            CALL REPORT('ROMOUN',9,'E')
C           CALL LIB$SIGNAL(%VAL(MINFO))
         ELSE
            CHREP  = 'Tape '//LABEL(1:LENOCC(LABEL))//
     +               ' mounted on device '//
     +               DEVNAM(1:LENOCC(DEVNAM))//'. Time: '//NOW
            CALL REPORT('ROMOUN',10,'I')
         END IF
*--   Dismount action.
      ELSE IF(ACTION.EQ. 'D') THEN
*
         DINFO  = SYS$DISMOU(DEVNAM, )
*-- Get the current time
         CALL TIME(NOW)
         IF(.NOT.DINFO) THEN
            IERR  = 1
            CHREP='Tape '//LABEL(1:LENOCC(LABEL))//
     +            ' not dism. from device '//
     +            DEVNAM(1:LENOCC(DEVNAM))//': stop.'//' Time: '//NOW
            CALL REPORT('ROMOUN',11,'E')
C           CALL LIB$SIGNAL(%VAL(DINFO))
         ELSE
            CHREP='Tape '//LABEL(1:LENOCC(LABEL))//
     +            ' dism. from device '//
     +            DEVNAM(1:LENOCC(DEVNAM))//'. Time: '//NOW
            CALL REPORT('ROMOUN',12,'I')
         END IF
*--   Other actions are not considered from ROMOUN.
      ELSE
         IERR   = 1
         CHREP  = 'Routine argument unknown.'
         CALL REPORT('ROMOUN',13,'E')
      END IF
*
  999 RETURN
      END
+DECK,RONFLX.
      SUBROUTINE RONFLX(LIOBNK)
*.
*...RONFLX   Mount next tape on same logical unit.
*.
*. INPUT     : LIOBNK Link to the bank with file parameters
*.
*. SEQUENCES : ROBANK ROCPAR RCREP
*. CALLS     : REPORT VMCMS
*. CALLED    : ROOPEN
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   :  6-Jan-1989
*. LAST MOD  : 11-Jun-1990
*.
*. Modification log:
*. 14-FEB-92 O.Schaile     remove loop on CHOPT by INDEX..
*. 11-Jun-90 A.Buijs       Implement multiple file reading on Vaxes.
*.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER      LUN,LUNLST,FCHOPT,LIOBNK,K,NF,IER
      CHARACTER*8  DDNAME
      CHARACTER*10 FOR000
      CHARACTER*4  CHOPT
      LOGICAL      LEXCH
      SAVE         LUNLST,NF
*
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,RCREP.
*
      DATA LUNLST/0/
*
      LUN    = IQ(LIOBNK+JLUN)
      FCHOPT = IQ(LIOBNK+JFCHOP)
      CALL UHTOC(FCHOPT,4,CHOPT,4)
      LEXCH  = .FALSE.
      IF(INDEX(CHOPT,'X').GT.0)THEN
         LEXCH  = .TRUE.
      ELSE
         LEXCH  = .FALSE.
      ENDIF
      IF(LUNLST.NE.LUN) THEN
         NF     = 1
         LUNLST = LUN
      END IF
+SELF,IF=UNIX,IF=-SHIFT.
***&&&+SELF,IF=APOLLO,SGI,HPUX,IBMRT,SUN,DECS.
      CHREP = 'No tape yet on Apollo !'
      CALL REPORT('RONFLX',1,'W')
                                                               GO TO 999
+SELF,IF=VAX.
*-- Build the word FORnnn$mmm, where nnn is the unit number, and mmm the
*-- version number of the file in its serie.
      CALL FZENDI(LUN,'QT')
      CLOSE(UNIT=LUN)
      WRITE(FOR000(7:10),2000)1000+NF
      WRITE(FOR000(3:6),2000) 1000+LUN
 2000 FORMAT(I4)
      FOR000(7:7) = '$'
      FOR000(1:3) = 'FOR'
*-- Redefine FORnnn to be FORnnn$mmm and open the file.
      CALL LIB$SET_LOGICAL(FOR000(1:6),FOR000(1:10))
      CALL ROOFLX(LIOBNK)
      CHREP  = 'Opening new file '//FOR000
      CALL REPORT('RONFLX',1,'I')
      NF     = NF + 1
                                                               GO TO 999
+SELF,IF=IBM.
      CALL FZENDI(LUN,'I')
      IF(LEXCH) THEN
         WRITE(DDNAME,1000) LUN
      ELSE
         NF     = NF + 1
         WRITE(DDNAME,1010) LUN,NF
      END IF
      CALL VMCMS('MOUNT DDNAME '//DDNAME,IER)
      IF(IER.NE.0) THEN
         WRITE(CHREP,1020) IER,NF,LUN
         CALL REPORT('RONFLX',1,'E')
                                                               GO TO 999
      END IF
+SELF,IF=CRAY.
      CHREP = 'Multiple tape reading not implemented yet on CRAY'
      CALL REPORT('RONFLX',1,'W')
                                                               GO TO 999
+SELF.
  999 RETURN
 1000 FORMAT('IOFILE',I2.2)
 1010 FORMAT('FT',I2.2,'F',I3.3)
 1020 FORMAT('Error ',I3,' from MOUNT called for file',I3, ' on LUN',I3)
      END
+DECK,RONREP,IF=ONLINE.
      SUBROUTINE RONREP
*.
*...RONREP   Prints REPORT summaries in online ROPE
*.           RONREP is called from ROTRIG every time new partition file
*.           is opened in online ROPE
*.
*. SEQUENCE  : CRO ROPAR RCLINE
*. COMMON    :
*. CALLS     : RMAIL REPREP RECREP
*. CALLED    : ROTRIG
*.
*. AUTHOR    : C.Hawkes
*. VERSION   : 1.10
*. CREATED   : 28-Jan-92
*. LAST MOD  : 22-Sep-93
*.
*. Modification log:
*. 22-Sep-93  M.Jones    Tidied up for 94 online ROPE.
*.  6-Oct-93  T.Smith    Remove condition on IFIRST.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,RCLINE.
*
*-- Print summary of REPORT messages for every partition
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      CALL REPREP('*')
      CALL RECREP('*')
      WRITE(CHLINE,1020)
      CALL RMAIL(0,0)
*
      RETURN
 1010 FORMAT(20('>'),' REPORT summary for partition ',20('<'))
 1020 FORMAT(24('>'),' End of REPORT summary ',24('<'))
      END
+DECK,ROOFLX.
      SUBROUTINE ROOFLX(LIOBNK)
*.
*...ROOFLX   Open the file corresponding to the bank at LIOBNK.
*.
*. INPUT     : LIOBNK Link to the bank with file parameters
*.
*. SEQUENCE  : ROBANK CRO RCNTRL ROUNIT RCSYST ROCPAR FMPAR RBITFUNC
*.           : ROWORD RCREP RCLINE
*. CALLS     : UHTOC REPORT FZFILE MATACH FZLIMI VMREXX RIBMOP LENOCC
*.             SPACES FMOPEN CLEFT RQSYST RSTAGE RMOUNT FMGETK RNWNAM
*.             FMSETK
*. CALLED    : ROOPEN ROWOUT
*.
*. BANK U    : IOII IOCI IODI IODO IODC IOOV IODS IOCA IOME
*.             IOBK IOHB IODP IODG
*.
*. AUTHOR    : A.Buijs,S.Weisz
*. VERSION   : 1.04
*. CREATED   :  6-Apr-1988
*. LAST MOD  : 21-Jan-00
*.
*. Modification log:
*.  21-Jan-00 A.Williamson allow more files to be prestaged in one go
*.  24-Aug-99 E.Barberio  change media preferences for fatmen
*.  19-Jun-96 S.O'Neale    change media preferences for fatmen (new SD-tapes)
*.  19-Jun-96 S.O'Neale    change media preferences for fatmen
*.   1-Aug-95 O.Schaile    reintall dadlist for HP
*.  23-May-95 O.Schaile      Open bank doc with RZOPEN
*.  24-APR-95 M.Schroder   same sfget for IBMRT,HPUX,APOOLO (no rsh)
*.   6-APR-95 M.Schroder   use DCHOPT instead LDACIN to recognize dadl
*.  14-Mar-95 G.Duckeck    add DLT tapes to list of media
*.  22-Feb-95 G.Duckeck    Open dadlists via NFS
*.  13-Jan-95 G.Duckeck    FZFILE for d/a in Channel mode
*.  08-Dec-94 G.Duckeck    Enable forcing of local opening on shift
*.  25-Sep-94 O.Schaile    Use Channel mode with LDACIN
*.  14-Nov-94 M.Redmond    Let FATMEN choose best medium for files
*.  25-Oct-94 G.Duckeck    Enhance multi file prestage with FATMEN
*.  22-Sep-94 M.Redmond    Permit access to Shift-only cartridges
*.  29-Jun-94 M.Redmond    Use C I/O on Shift when user forces FATMEN to
*.                         read data from cartridge
*.  25-May-94 M.Redmond    Only call LFILE for OLD native-mode files on VM
*.  30-Mar-94 T.Smith      Add C option for FZIN in ONLINE mode.
*.  18-Feb-94 O.Schaile    Zero NFADAD
*.  21-Sep-93 M.Redmond    Don't hardcode pathname for sfget on Shift
*.  14-Sep-93 M.Redmond    Use remsh with sfget on the Apollo
*.  12-Aug-93 M.Redmond    set IFC=1 for VAX if retry with node name
*.  22-Jul-93 O.Schaile    medium type 6 = HD cartrigdes
*.  15-APR-93 O.Schaile    Implement @@ (execute shell script)
*.  13-Apr-93 O.Schaile    use RECFM F for IBM (Steve ON)
*.  18-Mar-93 O.Schaile    Fixed length rec if VAX and Xchange mode
*.  19-Jun-92 D.Lellouch   Open the data compression dictionary
*.  22-Sep-92 O.Schaile    CFNAME = SPACES(CFNAME,0) for non shift
*.  20-Jul-92 D.Lellouch   use IOSTAT in call to RSTAGE for IBM
*.  26-Jun-92 M.Redmond    FIX call to RMOUNT for VAX (remove extra arg)
*.   1-Jun-92 O.Schaile    IBM: check if out file (FZ) exists on A-disk
*.  10-Apr-92 O.Schaile    IRC from FMOPEN must be 0.
*.  24-Mar-92 J.Banks      allow sfget from HPUX
*.   9-Mar-92 O.Schaile    set LBANK=0 after MZDROP
*.   7-Mar-92 O.Schaile    move IQUEST(10)=10 right before FMOPEN
*.  17-Feb-92 O.Schaile    fix bug for ALPHA mode on IBMRT
*.  14-Feb-92 D.Lellouch   Enhance the Unix pool facility
*.  14-Feb-92 D.Lellouch   remove LRECL in OPEN for IBMRT at 'all other'
*.   6-Feb-92 O.Schaile    READONLY for DECS at 'all other files'
*.   4-Feb-92 O.Schaile    Let FATMEN decide on shift
*.  11-Dec-91 T.Mouthuy    Mod DADlist access for special RFIO reading
*.                         and CIO-opened DAD file
*.                         Modify SFGET call to special interface
*.  911001   S.Weisz Variable name metafile on UNIX too ...
*.  910927   S.Weisz Stage non standard record length ....
*. 11-Sep-91 S.Weisz       RECL in words for unformatted files on SGI
*.  2-Sep-91 S.Weisz       Do not need READONLY parameter on Apollo/SGI
*. 27-Aug-91 S.Weisz       Use RBITFUNC sequence
*. 15-Aug-91 S.Weisz       Handle DAD list on SGI.
*.                         L opt for fatman access: Block size in catalog
*. 19-Apr-91 S.Weisz       Set IQUEST(10) before calling FMOPEN.
*.  5-Apr-91 S.Weisz       Handle CIO if 'L' ZEBRA option choosen.
*. 25-Mar-91 D.Lellouch    Open output DADLIST's.
*. 19-Mar-91 S.Weisz       Open OPCAL with RZOPEN.
*.  8-Mar-91 D.Lellouch    Open DADLIST's.
*.  5-Mar-91 T.Mouthuy     Apollo, SGI implementation.
*. 18-Fev-91 S.Weisz       Handle On-line case, reading from memory.
*.                         Use FATMEN selection keys.
*.                         Temporary comment PHONE.
*. 18-Nov-90 D.Lellouch    File name may have been given
*.                         Can be a FATMEN entry as well
*.                         Can be a mount,stage or prestage request
*.                         Can be a variable name
*.                         The stage commands modify the SMSG settings,
*.                         we have to reset them!
*.                         On a vax, first try to remove the node name
*. 23-Oct-90 S.Weisz       Add DDST input/output stream.
*. 19-Oct-90 A.Buijs       Open RZ files non shared if read only on Vax.
*. 22-Mar-90 R.W.L.Jones   Change ORGANIZATION to RELATIVE for OC on Vax.
*.  7-Sep-89 S.Weisz       Add SCAN input/output stream.
*. 31-Jul-89 S.W.Oneale    Call FZLIMI for 'PROD' output file.
*. 29-Jul-89 S.Weisz       Encode / in front of RZ file name.
*.                         Introduce hooks for CRAY.
*. 22-Jul-89 S.Weisz       Open RZ with name on IBM (use REXX facility).
*. 17-Jul-89 C.P.Ward      Open RZ input file 'SHARED' on Vaxes.
*. 15-Jul-89 S.Weisz       Increment Metafile output name on Apollo.
*. 16-Jun-89 S.Weisz       Open RZ input file with readonly.
*. 15-Jun-89 S.Weisz       Open statement for ALPHA files need no RECL.
*. 10-May-89 S.Weisz       Open FZ file on Apollo with proper RECL.
*.  9-May-89 B.Holl        Open RZ new RZ files with extended RECL.
*.  3-May-89 S.Weisz       Handle FZ alpha files
*. 28-Fev-89 S.Weisz       Get RECL on IBM for RZ files
*. 27-Fev-89 S.Weisz       Bug for IBM ddname, should be FTnnF001
*. 23-Fev-89 S.Weisz       Open RZ file on IBM with no name (no FILE=..)
*. 22-Fev-89 S.Weisz       Modif for new calibration files
*.  7-Fev-89 S.Weisz       Redefine LREC for Apollo and IBM,
*.                         read it for RZ files.
*.  7-Nov-88 C.P.Ward      Open VAX tape files with large blocksize.
*.  7-Sep-88 S.Weisz       Call FZLIMIT for output files.
*. 27-Jun-88 S.Weisz       Open Calibration file too.
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER      LIOBNK,LIOBN2,LUN,FILRE,ACMODE,TYPE,FLAGS,
     +             IMETA,IBLOCK,IRECL,IOSTAT,IER,LBANK,LUNPTR,
     +             IFC,ILC,IPC,J
      INTEGER      LENOCC, L
      CHARACTER*4  CFIFCH,CFSTAT,CHID
      CHARACTER*6  ROUTIN
      CHARACTER*8  METAXX,CHLUN,DUMMY
      CHARACTER*10 CHCALI,POOL,USER
      CHARACTER*13 ACTION
      CHARACTER*30 DESCRI
      CHARACTER*40 HEADER
      CHARACTER*60 SFNAME
      CHARACTER*80 CFNAME,CXNAME
      CHARACTER*80 SPACES, CRECFM
      LOGICAL      LTAPE,LEXCH,LCIO,LREAD,LALPHA,LMEMOR,LSAME,RETRY
+SELF,IF=IBM.
      LOGICAL LEXIST
+SELF,IF=ONLINE.
      LOGICAL LCHAN
      EXTERNAL ROFZIO
+SELF.
+SELF,IF=SHIFT.
      EXTERNAL ROFGET
+SELF.
*
      INTEGER      IQUEST
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
+SEQ,ROCPAR.
+SEQ,FMPAR.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCREP.
+SEQ,RCLINE.
+SEQ,RODADPAR.
+SELF,IF=SHIFT,HPUX,PCLINUX.
+SEQ,DADRFCDE.
*
      INTEGER      MKEYMA
* Fatmen /FATKEY/ incorrect dimensions limit us to 9 selections
*                 fixed in dev version and 97a (January) release
      PARAMETER    (MKEYMA=14)
      INTEGER KEYMAT(KEYLEN,MKEYMA)
      INTEGER IPREF
      INTEGER MCPLOC
      INTEGER NUMBER,LUNFOR
+SELF.
*
+SELF,IF=SHIFT.
* >> GD
      INTEGER NNAME, NFILES, NTAPES, INAME
      INTEGER NNAMM
      PARAMETER (NNAMM=40)
      CHARACTER*255 GENAME(NNAMM)
      CHARACTER*6 CHOPSG
      INTEGER IPRFST
      SAVE IPRFST, NFILES
+SELF.
+SELF,IF=UNIX.
      CHARACTER*4 DCHOPT
+SELF.
      SAVE      IMETA
      DATA      IMETA/0/
+SELF,IF=SHIFT.
      DATA IPRFST /0/, NFILES /0/
* << GD
+SELF.
*
      CALL UHTOC(IQIDH(LIOBNK),4,CHID,4)
      LUN    = IQ(LIOBNK+JLUN)
      FILRE  = IQ(LIOBNK+JLREC)
      CALL UHTOC(IQ(LIOBNK+JFCHOP),4,CFIFCH,4)
+SELF,IF=UNIX.
      CALL UHTOC(IQ(LIOBNK+JDCHOP),4,DCHOPT,4)
+SELF.
      ACMODE = IQ(LIOBNK+JACMOD)
      TYPE   = IQ(LIOBNK+JFNTYP)
      FLAGS  = IQ(LIOBNK+JFLAGS)
      CALL UHTOC(IQ(LIOBNK+JFSTAT),4,CFSTAT,4)
*
      NFZUSE(LUN) = NFZUSE(LUN) + 1
      LTAPE  = .FALSE.
      LEXCH  = .FALSE.
      LCIO   = .FALSE.
      LREAD  = .TRUE.
      LALPHA = .FALSE.
      LMEMOR = .FALSE.
+SELF,IF=ONLINE.
      LCHAN  = .FALSE.
+SELF.
      RETRY  = .FALSE.
      IF(CFSTAT(1:3).EQ.'NEW') LREAD  = .FALSE.
      DO 10 J = 1,4
      IF(CFIFCH(J:J).EQ.'T') LTAPE  = .TRUE.
      IF(CFIFCH(J:J).EQ.'X') LEXCH  = .TRUE.
      IF(CFIFCH(J:J).EQ.'L') LCIO   = .TRUE.
      IF(CFIFCH(J:J).EQ.'U') LREAD  = .FALSE.
      IF(CFIFCH(J:J).EQ.'A') LALPHA = .TRUE.
      IF(CFIFCH(J:J).EQ.'M') LMEMOR = .TRUE.
+SELF,IF=ONLINE.
      IF(CFIFCH(J:J).EQ.'C') LCHAN = .TRUE.
+SELF.
   10 CONTINUE
*-- Check memory option for Input/Output.
      IF(LMEMOR) THEN
         CALL FZFILE(LUN,FILRE,CFIFCH)
         CALL MATACH(LUN,FILRE,CFIFCH,IOSTAT)
         IF(IOSTAT.EQ.0) IQ(LIOBNK+JACTIV) = 1
                                                               GO TO 999
+SELF,IF=ONLINE.
      ELSE IF ( LCHAN ) THEN
         CALL FZFILE( LUN, FILRE, CFIFCH )
         CALL FZHOOK( LUN, ROFZIO, 0 )
         IQ(LIOBNK+JACTIV) = 1
                                                               GO TO 999
+SELF.
      END IF
      IF(CHID.EQ.'IODI') THEN
         IF(.NOT.BTEST(FLAGS,INDIRF)) THEN
            LDADL  = .FALSE.
            LNANO  = .FALSE.
            IF(.NOT.BTEST(FLAGS,INDIRN)) LEVTL  = .FALSE.
         END IF
         LFZL   = LCIO
         JFILE  = 0
         LNOHEA = BTEST(FLAGS,ONLYHE)
      END IF
+SELF,IF=-IBM.
*-- Do not play the disgusting trick of FZENDI('C') if your
*-- favourite computer happens not to be an IBM!
      LSAME  = .FALSE.
+SELF,IF=IBM.
*-- If same unit is being reused, do not perform the FZFILE
*-- an do NOT increment mmm in FTnnFmmm . (Hard to believe!)
      IF(LREAD) THEN
         LSAME  = LASTCI.EQ.LUN
      ELSE
         LSAME  = LASTCO.EQ.LUN
      END IF
+SELF.
*-- When related to the record length, the blocksize is always in bytes.
      IBLOCK = 4*FILRE
+SELF,IF=APOLLO,HPUX,IBMRT,SUN.
*-- The record size is in bytes when opening files on Apollo.
      IRECL  = 4*FILRE
+SELF,IF=PCLINUX.
*-- The record size is in bytes when opening files on linux?????.
      IRECL  = 4*FILRE
+SELF,IF=SGI.
*-- The record size is in words (4byte) when opening files on SGI.
      IRECL  = FILRE
+SELF,IF=VAX,DECS.
*-- The record size is in words on Vax.
      IRECL  = FILRE
+SELF,IF=IBM.
*-- The record size is in bytes when opening files on IBM.
      IRECL  = 4*FILRE
      IF(LEXCH) THEN
         WRITE(CHLUN,1000) LUN
      ELSE
*-- Deliberate choice: reopen on same channel
         WRITE(CHLUN,1010) LUN,1
      END IF
+SELF.
*-- Was a name given? Is it a Fatmen entry?
      IF(TYPE.EQ.0) THEN
*-- No name was given
         WRITE(CFNAME,1020) LUN
      ELSE IF(TYPE.EQ.1) THEN
*-- A name was given
         CALL UHTOC(IQ(LIOBNK+JFNAME),NBYTEW,CFNAME,NAMLEN)
+SELF,IF=UNIX.
*-- Execute a system command (e.g. to position an exabyte)
         J = INDEX(CFNAME,'@@')
         IF(J.NE.0)THEN
            SYSCOM = CFNAME(J+2:)
            CALL RTRANS(SYSCOM,'@',' ')
            CFNAME(J:)=' '
            CALL RQSYST(.TRUE.)
         ENDIF
+SELF,IF=IBM.
*-- On IBM, some preparation work has to be done!
         IF(ACMODE.EQ.0) THEN
            IF(CHID.EQ.'IOCA') THEN
               CALL RIBMOP(CFNAME,CFSTAT,.TRUE.)
            ELSE
               CALL RIBMOP(CFNAME,CFSTAT,.FALSE.)
            END IF
         END IF
         CALL UCTOH(CFNAME,IQ(LIOBNK+JFNAME),NBYTEW,NAMLEN)
+SELF,IF=UNIX.
*-- For SHIFT some preparation work is also needed.
         CFNAME=SPACES(CFNAME,0)
         IF(CFNAME(1:1).EQ.'[') THEN
*-- This is a pool name - Then try to get the full path name
*-- of it.
            IFC    = INDEX(CFNAME(1:NAMLEN),']')
            IPC    = INDEX(CFNAME(1:IFC-1),'.')
*   [ ] means opaldata.opal
*   [pool] means pool.opal
*           unless pool=opalcnst --> user=opalcal
*                 pool=opaldata --> user=opal
            POOL=' '
            USER=' '
            IF(IPC.EQ.0) THEN
               IF(IFC.GT.2) POOL=CFNAME(2:IFC-1)
            ELSE
               IF(IPC.GT.2) POOL=CFNAME(2:IPC-1)
               IF(IPC.LT.IFC-1) USER=CFNAME(IPC+1:IFC-1)
            END IF
*-- Normally all pools and user names are in lower case.
            CALL CUTOL(POOL)
            CALL CUTOL(USER)
            IF(USER.EQ.' ') THEN
               IF(POOL.EQ.' '.OR.POOL.EQ.'opaldata') THEN
                  POOL='opaldata'
                  USER='opal'
               ELSEIF(POOL.EQ.'opalcnst') THEN
                  USER='opalcal'
               ELSE
                  USER='"  "'
               END IF
            END IF
            SFNAME = CFNAME(IFC+1:NAMLEN)
*-- Now make a system call to find the explicit file name
            IF(BTEST(FLAGS,VARNAM)) SFNAME = 'temp.dummy'
+SELF.
+SELF,IF=UNIX,IF=-SHIFT.
***&&&+SELF,IF=APOLLO,HPUX,IBMRT,SUN,DECS.
            IF(LREAD) THEN
               WRITE(SYSCOM,1030) POOL,USER,SFNAME
            ELSE
               WRITE(SYSCOM,1040) POOL,USER,SFNAME
            ENDIF
            CALL RQSYST(.FALSE.)
*-- The file 'temp.file' should contain the full pathname of the file
            OPEN(UNIT=99,FILE='temp.file',STATUS='OLD')
            READ(99,'(A80)',ERR=60,END=60) CFNAME
            CLOSE(UNIT=99,STATUS='DELETE')
            CFNAME = SPACES(CFNAME,0)
            IF(.NOT.LREAD) THEN
               SYSCOM = '/bin/rm '//CFNAME
               CALL RQSYST(.FALSE.)
            ENDIF
+SELF,IF=SHIFT.
            IF(LREAD) THEN
               CALL OPFGET(POOL,USER,SFNAME,CFNAME)
            ELSE
               CALL OPFPUT(POOL,USER,SFNAME,CFNAME)
* Remove this file as later we use OPEN with 'NEW' flag
               SYSCOM = '/bin/rm '//CFNAME
               CALL RQSYST(.FALSE.)
            ENDIF
+SELF,IF=UNIX.
         ENDIF
+SELF.
      ELSE IF(TYPE.EQ.2) THEN
*-- Fatmen!
*-- IF ACMODE=3, pre-stage the next file
         IF(ACMODE.EQ.3) THEN
+SELF,IF=SHIFT.
* >> GD
* multi-file prestage, run out ?
            IF ( NFILES .GT. 1 ) THEN
               NFILES = NFILES - 1
            ELSE
* << GD
+SELF.
             LIOBN2 = LQ(LIOBNK)
             IF(LIOBN2.GT.0) THEN
*-- Next file does exist
               IF(IQ(LIOBN2+JACMOD).EQ.3) THEN
                  ACTION = 'Pre-staging'
                  CALL UHTOC(IQ(LIOBN2+JFNAME),NBYTEW,CFNAME,NAMLEN)
                  CHREP  = ACTION(1:LENOCC(ACTION)+1)
     +                   //CFNAME(1:LENOCC(CFNAME))
                  CALL REPORT('ROOFLX',1,'I')
                  ROUTIN = 'FMOPEN'
                  IF(INDEX(CFIFCH,'N').NE.0) CALL RADDOP(CFIFCH,'L')
+SELF,IF=SHIFT.
*                 RIOFAT made sure that a valid file is there, but
*                 let FATMEN choose, just give him preferences
*  Code preferences for FATMEN
*  Code preferences for FATMEN
*  See /fatmen/fmopal/fatmen.medtypes
                  MCPLOC=0                         ! MC Pool (for later)
                  IPREF=0
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=   1      ! Disk
                  KEYMAT(MKCLFA,IPREF)=  -1      ! Any Format
                  KEYMAT(MKLCFA,IPREF)=  FMLOCA  ! Where I am
*      the new 9840
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=   18     ! 9840
                  KEYMAT(MKCLFA,IPREF)=   1
                  KEYMAT(MKLCFA,IPREF)=   1
*     SD3S 10 Gb 4 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  15      ! SD3S
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     SD3M 25 Gb 4 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  16      ! SD3M
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     SD3M 50 Gb 4 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  17      ! SD3L
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     NTP 10 Gb 5 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  14      ! NTP
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     then 10 GB DLT
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  12      ! DLT
                  KEYMAT(MKCLFA,IPREF)=   1
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*      then HD cartridge for in Computer Centre
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=   6      ! 3490
                  KEYMAT(MKCLFA,IPREF)=   1
                  KEYMAT(MKLCFA,IPREF)=   1
*      then the MCP Pool (add FFREAD later)
                  IF ( MCPLOC.GT.0) THEN
                     IPREF=IPREF+1
                     KEYMAT(MKMTFA,IPREF)=   1       ! Disk
                     KEYMAT(MKCLFA,IPREF)=   1
                     KEYMAT(MKLCFA,IPREF)=  MCPLOC   ! MCP disk pool
                  END IF
         CALL FMSETK(KEYMAT,IPREF,' ',IER)
                  IF(IER.NE.0)THEN
                     WRITE(CHREP,'(A,I5)')'Error from FMSETK ',IER
                     CALL REPORT('ROOFLX',19,'I')
                  ENDIF
* >> GD
* -- FOR FIRST CALL STAGE FIRST FILE TOO
                  IF ( IPRFST .EQ. 0 ) THEN
                     LIOBN2 = LIOBNK
                     CALL UHTOC(IQ(LIOBN2+JFNAME),NBYTEW,CFNAME,NAMLEN)
                     GENAME(1) = CFNAME(1:LENOCC(CFNAME))
                  ELSE
                     GENAME(1) = CFNAME(1:LENOCC(CFNAME))
                  ENDIF
                  NNAME = 1
                  DO 764 INAME = 2, NNAMM
                     LIOBN2 = LQ(LIOBN2)
                     IF(LIOBN2.LE.0) GOTO 765
                     IF(IQ(LIOBN2+JACMOD).NE.3) GOTO 765
                     CALL UHTOC(IQ(LIOBN2+JFNAME),NBYTEW,CFNAME,NAMLEN)
                     GENAME(INAME) = CFNAME(1:LENOCC(CFNAME))
                     NNAME = NNAME + 1
 764              CONTINUE
 765              CONTINUE
                  CHOPSG  = 'LF'
                  CALL FMPSTG(GENAME,NNAME,NFILES,NTAPES,CHOPSG,IER)
*
* -- first call: do second prestage
                  IF ( IPRFST .EQ. 0 ) THEN
                     IPRFST = 1
                     IF ( NFILES .GT. 0 ) NFILES = NFILES - 1
                     IF ( NFILES .EQ. 0 ) THEN
                        CALL FMPSTG(GENAME(2),NNAME-1,
     +                       NFILES,NTAPES,CHOPSG,IER)
                     ENDIF
                  ENDIF
* -- ignore error code from prestage
CCC               IF(IER.GT.20)                                 GO TO 40
                END IF
               END IF
* << GD
+SELF,IF=-SHIFT.
                  LBANK = 0
                  CALL FMOPEN(CFNAME(1:LENOCC(CFNAME)),'NOWAIT',LBANK
     +                       ,CFIFCH,IER)
                  IF (LBANK.GT.0) THEN
                    CALL MZDROP(IXSTOR,LBANK,'L')
                    LBANK = 0
                  ENDIF
                  IF(IER.GT.20)                                 GO TO 40
                END IF
+SELF.
             END IF
         END IF
*-- Get the name and open the file
         ACTION = 'Staging'
         CALL UHTOC(IQ(LIOBNK+JFNAME),NBYTEW,CFNAME,NAMLEN)
         CHREP  = ACTION(1:LENOCC(ACTION)+1)//CFNAME(1:LENOCC(CFNAME))
         CALL REPORT('ROOFLX',2,'I')
         ROUTIN = 'FMOPEN'
C        IF(.NOT.LSAME) CALL RADDOP(CFIFCH,'F')
         CALL RADDOP(CFIFCH,'F')
         WRITE(CHLUN,1050) LUN
         IF(INDEX(CFIFCH,'N').NE.0) CALL RADDOP(CFIFCH,'L')
+SELF,IF=SHIFT.
*        RIOFAT made sure that a valid file is there, but
*        let FATMEN choose, just give him preferences
*  Code preferences for FATMEN
*  See /fatmen/fmopal/fatmen.medtypes
                  IPREF=0
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=   1      ! Disk
                  KEYMAT(MKCLFA,IPREF)=  -1      ! Any Format
                  KEYMAT(MKLCFA,IPREF)=  FMLOCA  ! Where I am
*      the new 9840
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=   18     ! 9840
                  KEYMAT(MKCLFA,IPREF)=   1
                  KEYMAT(MKLCFA,IPREF)=   1
*     SD3S 10 Gb 4 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  15      ! SD3S
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     SD3M 25 Gb 4 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  16      ! SD3M
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     SD3M 50 Gb 4 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  17      ! SD3L
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     NTP 10 Gb 5 Mb/sec
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  14      ! NTP
                  KEYMAT(MKCLFA,IPREF)=   1      ! IEEE
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*     then 10 GB DLT
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=  12      ! DLT
                  KEYMAT(MKCLFA,IPREF)=   1
                  KEYMAT(MKLCFA,IPREF)=   1      ! Centre
*      then HD cartridge for in Computer Centre
                  IPREF=IPREF+1
                  KEYMAT(MKMTFA,IPREF)=   6      ! 3490
                  KEYMAT(MKCLFA,IPREF)=   1
                  KEYMAT(MKLCFA,IPREF)=   1
*      then the MCP Pool (add FFREAD later)
                  IF ( MCPLOC.GT.0) THEN
                     IPREF=IPREF+1
                     KEYMAT(MKMTFA,IPREF)=   1       ! Disk
                     KEYMAT(MKCLFA,IPREF)=   1
                     KEYMAT(MKLCFA,IPREF)=  MCPLOC   ! MCP disk pool
                  END IF
* Fatmen /FATKEY/ incorrect dimensions limit us to 9 selections
         CALL FMSETK(KEYMAT,IPREF,' ',IER)
         IF(IER.NE.0)THEN
            WRITE(CHREP,'(A,I5)')'Error from FMSETK ',IER
            CALL REPORT('ROOFLX',19,'I')
         ENDIF
+SELF
*-- Small dirty patch to open CIO on shift.
         IQUEST(10) = 0
         IF(FMLOCA.EQ.31) IQUEST(10) = 1
+SELF,IF=SHIFT.
         IF(FMLOCA.EQ.1)  IQUEST(10) = 1
+SELF.
*-- End of patch, let's hope we get rid of it soon!
         LBANK = 0
         CALL FMOPEN(CFNAME(1:LENOCC(CFNAME)),CHLUN(1:2),LBANK
     +              ,CFIFCH,IER)
         IF(LBANK.GT.0) THEN
            CALL MZDROP(IXSTOR,LBANK,'L')
            LBANK = 0
         ENDIF
         IF(IER.NE.0)                                           GO TO 40
         IQ(LIOBNK+JACTIV) = 1
                                                               GO TO 999
      END IF
      IFC    = 1
      ILC    = LENOCC(CFNAME)
+SELF,IF=VAX.
*-- Try to remove the node name, this speeds up data access ???
   20 IF(BTEST(FLAGS,EXPLIC).OR.RETRY) THEN
         RETRY  = .FALSE.
      ELSE
         IFC    = INDEX(CFNAME,'::')
         IF(IFC.EQ.0) THEN
            IFC    = 1
         ELSE
            IFC    = IFC + 2
            RETRY  = .TRUE.
         END IF
      END IF
+SELF,IF=IBM.
      IF(TYPE.EQ.1.AND.ACMODE.EQ.0) THEN
         J      = 2
         IF(CHID.EQ.'IOCA') J      = 1
+SELF,IF=-IBM.
      IF(TYPE.EQ.1) THEN
         J      = 1
+SELF.
*-- Do we have to change the name ?
         IF(BTEST(FLAGS,VARNAM)) THEN
            CXNAME = CFNAME
            CALL RNWNAM(LUN,CXNAME,CFNAME,.TRUE.)
         END IF
*-- Explain to the user what we are doing
         WRITE(CHLINE,1060) CFNAME(J:LENOCC(CFNAME)),LUN,CFSTAT
         CALL RMAIL(0,0)
      END IF
*-- Open calibration file
      IF(CHID.EQ.'IOCA') THEN
+SELF,IF=IBM.
*-- Get filename from the REXX exec if not already given.
         IF(TYPE.EQ.0) THEN
            WRITE(CHCALI,1070) LUN
            CALL VMREXX('F',CHCALI,CFNAME,IOSTAT)
            IF(IOSTAT.NE.0)                                     GO TO 50
*-- Replace blanks by '.' in filename.
            CFNAME = SPACES(CFNAME,1)
            DO 30 J = 1,LENOCC(CFNAME)
            IF(CFNAME(J:J).EQ.' ') CFNAME(J:J) = '.'
   30       CONTINUE
         END IF
+SELF,IF=VAX,DECS.
         IF(CFSTAT.EQ.'NEW ') THEN
            CALL RZOPEN(LUN,' ',CFNAME(IFC:ILC),'N',FILRE,IOSTAT)
         ELSE
            CALL RZOPEN(LUN,' ',CFNAME(IFC:ILC),CFIFCH,FILRE,IOSTAT)
         END IF
         IF(IOSTAT.NE.0)                                        GO TO 60
+SELF,IF=-VAX,IF=-DECS.
         IF(CFSTAT.EQ.'NEW ') THEN
            CALL RZOPEN(LUN,' ',CFNAME,'N',FILRE,IOSTAT)
         ELSE
            CALL RZOPEN(LUN,' ',CFNAME,CFIFCH,FILRE,IOSTAT)
         END IF
         IF(IOSTAT.NE.0)                                        GO TO 50
+SELF.
         IQ(LIOBNK+JACTIV) = 1
*-- Open bank documentation file
      ELSE IF(CHID.EQ.'IOBK') THEN
         CALL RZOPEN(LUN,' ',CFNAME,' ',256,IOSTAT)
         IF(IOSTAT.NE.0)                                        GO TO 50
         IQ(LIOBNK+JACTIV) = 1
*-- Check if we have a DAD list on input.
      ELSE IF(CHID.EQ.'IODI'.AND.BTEST(FLAGS,DADLIS)) THEN
         LDADL  = .TRUE.
         LDADEX = .NOT.BTEST(FLAGS,CLSQUI)
+SELF,IF=IBM.
*-- Soon available.
+SELF,IF=VAX.
*-- Open the DAD list
         OPEN(UNIT=LUN,FILE=CFNAME(IFC:ILC),ACCESS='SEQUENTIAL',
     +        STATUS=CFSTAT,BLOCKSIZE=20000,
     +        READONLY,FORM='UNFORMATTED',IOSTAT=IOSTAT,ERR=60)
*-- Read and print DAD list header.
         READ(UNIT=LUN,ERR=60) DADHED
         IF(LDADEX) THEN
            CHREP  = 'DAD: header comment from list: '//DADHED
            CALL REPORT('ROOFLX',3,'I')
         END IF
*-- Reset number of events read corresponding to this DAD list.
         NEVDAD = 0
         NFADAD = 0
         IQUEST(1) = 0
*-- Open the FZIN file at first DAD list
         IF(.NOT.LDAOPE) THEN
            LDAOPE = .TRUE.
            IF(LDADEX) THEN
               CHREP  = 'Opening the "DATA IN" file for DAD access'
               CALL REPORT('ROOFLX',4,'I')
            END IF
            CALL FZFILE(LUDAIN,0,'NI  ')
         END IF
         IF(IQUEST(1).EQ.0) IQ(LIOBNK+JACTIV) = 1
+SELF,IF=APOLLO,SUN,DECS.
         OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +        ACCESS='SEQUENTIAL',FORM='UNFORMATTED',
     +        IOSTAT=IOSTAT,ERR=50)
+SELF,IF=IBMRT.
              OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +             FORM='UNFORMATTED',ERR=50)
+SELF,IF=UNIX,IF=-SHIFT,IF=-HPUX,IF=-PCLINUX.
***&&&+SELF,IF=APOLLO,HPUX,IBMRT,SUN,DECS.
         READ(UNIT=LUN,ERR=90,END=90,IOSTAT=IOSTAT) DADHED
+SELF,IF=SHIFT,HPUX.
         LUNFOR = LUN
+SELF,IF=SHIFT,PCLINUX.
         LUNFOR = LUN
*
*-- Open DADlist file with CIO routines
*
+SELF,IF=SHIFT.
         CALL CFOPEN(LUN, 0, 6,'r   ',0, 'local:'//CFNAME, IOSTAT)
+SELF,IF=HPUX.
         CALL CFOPEN(LUN, 0, 6,'r   ',0, CFNAME, IOSTAT)
+SELF,IF=PCLINUX.
         CALL CFOPEN(LUN, 0, 6,'r   ',0, CFNAME, IOSTAT)
+SELF,IF=SHIFT,HPUX,PCLINUX.
         IF(LUN.EQ.0.AND.IOSTAT.EQ.0) IOSTAT=7777
         IF(IOSTAT.NE.0)                                        GO TO 50
*-- Store file descriptor for later use (in RNXTEV)
         IQ(LIOBNK+JLUN) = LUNFOR
         LCIOLU(LUNFOR) = LUN
*-- Read header (24 bytes - first ones should be 1234)
         NUMBER=6
         CALL CFGET(LUN,0,6,NUMBER,DADHED,IOSTAT)
         IF(IOSTAT.NE.0)                                        GO TO 50
         LOCMEM=0
         IF(     DADHED(1:4).EQ.'1234') THEN
            LDACIO=.TRUE.
            LDACIN=.FALSE.
         ELSE IF(DADHED(1:4).EQ.'5678') THEN
            LDACIO=.TRUE.
+SELF,IF=SHIFT.
            LDACIN=.TRUE.
+SELF,IF=HPUX.
            LDACIN=.FALSE.
+SELF,IF=PCLINUX.
            LDACIN=.FALSE.
+SELF,IF=SHIFT,HPUX,PCLINUX.
         ELSE
            LDACIO=.FALSE.
            LDACIN=.FALSE.
*-- This is not a CIO DAD file - Close it and re-open with old method
           CALL CFCLOS(LUN,0)
*
           LUN = LUNFOR
*-- Store file descriptor for later use (in RNXTEV)
           IQ(LIOBNK+JLUN) = LUN
           LCIOLU(LUNFOR) = 0
           OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +        ACCESS='SEQUENTIAL',FORM='UNFORMATTED',
     +        IOSTAT=IOSTAT,ERR=50)
           READ(UNIT=LUN,ERR=90,END=90,IOSTAT=IOSTAT) DADHED
*
           LDACIO = .FALSE.
         ENDIF
+SELF.
         IF(LDADEX) THEN
            CHREP  = 'DAD: header comment from list -->'//DADHED
            CALL REPORT('ROOFLX',5,'I')
         END IF
         NEVDAD = 0
         NFADAD = 0
         IQUEST(1) = 0
         IQ(LIOBNK+JACTIV) = 1
+SELF,IF=CRAY.
*-- Soon available.
+SELF.
*-- Open the output DAD list.
      ELSE IF(CHID.EQ.'IOAO') THEN
+SELF,IF=IBM.
*-- Soon available.
+SELF,IF=VAX.
         OPEN(UNIT=LUN,FILE=CFNAME(IFC:ILC),ACCESS='SEQUENTIAL',
     +        STATUS=CFSTAT,BLOCKSIZE=20000,

     +        FORM='UNFORMATTED',IOSTAT=IOSTAT,ERR=60)
         CALL UHTOC(IQ(LIOBNK+JFKEYS),NBYTEW,HEADER,40)
         WRITE(DADHED,1080) IRDATE,IRTIME
         DADHED(15:NDADBY) = HEADER
         WRITE(UNIT=LUN,IOSTAT=IOSTAT,ERR=70) DADHED
         IF(.NOT.BTEST(FLAGS,CLSQUI)) THEN
            WRITE(CHREP,1090,ERR=70) CFNAME(IFC:ILC),
     +      DADHED(1:LENOCC(DADHED))
            CALL REPORT('ROOFLX',6,'I')
         END IF
         IQ(LIOBNK+JACTIV) = 1
+SELF,IF=UNIX,IF=-SHIFT.
****&&&+SELF,IF=APOLLO,HPUX,IBMRT,SUN,DECS.
         OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +        FORM='UNFORMATTED',IOSTAT=IOSTAT,ERR=50)
         CALL UHTOC(IQ(LIOBNK+JFKEYS),NBYTEW,DADHED,NDADBY)
         WRITE(UNIT=LUN,IOSTAT=IOSTAT,ERR=70) DADHED
+SELF,IF=SHIFT.
*
*-- Open DADlist file with CIO routines
*
         LUNFOR = LUN
         CALL CFOPEN(LUN, 0, 6,'w+  ',0, CFNAME, IOSTAT)
         IF(LUN.EQ.0.AND.IOSTAT.EQ.0) IOSTAT=7777
         IF(IOSTAT.NE.0)                                        GO TO 50
*-- Store file descriptor for later use (in RDADOU)
         IQ(LIOBNK+JLUN) = LUNFOR
         LCIOLU(LUNFOR) = LUN
*-- Also remember it was a DADlist (needed to close it properly in RCLSIO)
         CALL UCTOH('DADO',IQ(LIOBNK+JFCHOP),4,4)
*-- Write header (20 characters + first ones are 1234)
         CALL UHTOC(IQ(LIOBNK+JFKEYS),NBYTEW,DADHED,NDADBY)
         IF(DADHED(1:4).NE.'1234') THEN
           DADHED = '1234'//DADHED(1:20)
         ENDIF
         NUMBER=6
         CALL CFPUT(LUN,0,NUMBER,DADHED(1:24),IOSTAT)
         IF(IOSTAT.NE.0)                                        GO TO 70
+SELF,IF=UNIX,SHIFT.
         IF(.NOT.BTEST(FLAGS,CLSQUI)) THEN
            WRITE(CHREP,1090,ERR=70) CFNAME(IFC:ILC),DADHED
            CALL REPORT('ROOFLX',6,'I')
         END IF
         IQ(LIOBNK+JACTIV) = 1
+SELF,IF=CRAY.
*-- Soon available.
+SELF.
*-- Open input NanoDst
      ELSE IF(CHID.EQ.'IODI'.AND.BTEST(FLAGS,NANODS)) THEN
         LNANO  = .TRUE.
         LFZL   = .TRUE.
         NEVDAD = 0
         NANREC = 0
         LDADEX = .NOT.BTEST(FLAGS,CLSQUI)
+SELF,IF=IBM,VAX,CRAY.
*-- Soon available.
+SELF,IF=UNIX.
         OPEN(UNIT=LUN,FILE=CFNAME,ACCESS='DIRECT',STATUS=CFSTAT,
     +        RECL=IRECL,FORM='UNFORMATTED',ERR=50)
         IF(LDADEX) THEN
            CHREP  = 'Nanodst has been successfully opened'
            CALL REPORT('ROOFLX',7,'I')
         END IF
         IQ(LIOBNK+JACTIV) = 1
+SELF.
*     Open the data compression dictionary
      ELSE IF(CHID.EQ.'IODT') THEN
         OPEN(UNIT=LUN,FORM='FORMATTED',STATUS='OLD',FILE=CFNAME
+SELF,IF=VAX.
     +       ,READONLY
+SELF.
     +       ,IOSTAT=IOSTAT,ERR=50)
         CALL DCRDIC(LUN)
*-- Open the input Event List
      ELSE IF(CHID.EQ.'IODI'.AND.BTEST(FLAGS,EVTLIS)) THEN
         LEVTL  = .TRUE.
         LFZL   = .TRUE.
         NEVDAD = 0
         LDADEX = .NOT.BTEST(FLAGS,CLSQUI)
         IF(.NOT.BTEST(FLAGS,NOOPEN)) THEN
            OPEN(UNIT=LUN,FILE=CFNAME,ACCESS='SEQUENTIAL',
     +           STATUS=CFSTAT,FORM='FORMATTED',ERR=50)
            IF(LDADEX) THEN
               CHREP  = 'Event list has been successfully opened'
               CALL REPORT('ROOFLX',8,'I')
            END IF
         ELSE IF(LDADEX) THEN
            CHREP  = 'Event list to be found in the input FFREAD stream'
            CALL REPORT('ROOFLX',9,'I')
         END IF
         IQ(LIOBNK+JACTIV) = 1
      ELSE
*-- Open all other files.
*-- Retrieve the index of the current input file in the catalog
         IF(CHID.EQ.'IODI') JFILE  = IQ(LIOBNK+JFJFIL)
+SELF,IF=UNIX.
*-- Check if we have a DAD list reading mode.
         IF(CHID.EQ.'IODI'.AND.BTEST(FLAGS,INDIRF)) THEN
            LDADL  = .TRUE.
            LDADEX = .NOT.BTEST(FLAGS,CLSQUI)
         END IF
         IF(ACMODE.EQ.0) THEN
            IF(CHID.EQ.'IOME') THEN
               IMETA  = IMETA + 1
               IF(BTEST(FLAGS,VARNAM)) THEN
                  OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,ERR=50)
               ELSE
                  WRITE(METAXX,1100) IMETA
                  OPEN(UNIT=LUN,FILE=METAXX,STATUS=CFSTAT,ERR=50)
               END IF
            ELSE IF(LALPHA) THEN
+SELF,IF=UNIX,IF=-DECS.
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +              FORM='FORMATTED',ERR=50)
+SELF,IF=DECS.
               IF(CFSTAT(1:3).EQ.'OLD') THEN
                  OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +                 READONLY,
     +                 FORM='FORMATTED',ERR=50)
               ELSE
                  OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +                 FORM='FORMATTED',ERR=50)
               ENDIF
+SELF
+SELF,IF=UNIX.
            ELSE IF(LCIO) THEN
               IF(LREAD) THEN
+SELF,IF=SHIFT.
*-- GD for dadlists sometimes reading local/NFS is more efficient
                  IF ( LDADL .AND. LLOCAL ) THEN
                     CALL CFOPEN(LUNPTR,0,FILRE,
     +                        'r   ',0,'local:'//CFNAME//' ',IOSTAT)
                  ELSE
                     CALL CFOPEN(LUNPTR,0,FILRE,
     +                        'r   ',0,CFNAME//' ',IOSTAT)
                  ENDIF
+SELF,IF=-SHIFT,IF=UNIX.
                  CALL CFOPEN(LUNPTR,0,FILRE,
     +                        'r   ',0,CFNAME//' ',IOSTAT)
+SELF,IF=UNIX.
                  IF(LUNPTR.EQ.0.AND.IOSTAT.EQ.0) IOSTAT = 7777
               ELSE
                  CALL CFOPEN(LUNPTR,0,FILRE,
     +                        'w+  ',0,CFNAME//' ',IOSTAT)
               END IF
               IF(IOSTAT.NE.0)                                  GO TO 50
            ELSE
+SELF,IF=UNIX,IF=-DECS,IF=-IBMRT.
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +              RECL=IRECL,FORM='UNFORMATTED',ERR=50)
+SELF,IF=IBMRT.
*   Can't give RECL for SEQUENTIAL access for IBMRT
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT
     +             ,FORM='UNFORMATTED',ERR=50)
+SELF,IF=DECS.
               IF(CFSTAT(1:3).EQ.'OLD') THEN
                  OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +                 READONLY,
     +                 RECL=IRECL,FORM='UNFORMATTED',ERR=50)
               ELSE
                  OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +                 RECL=IRECL,FORM='UNFORMATTED',ERR=50)
               ENDIF
+SELF,IF=UNIX.
            END IF
         ELSE IF(ACMODE.EQ.1) THEN
            IF(LCIO)                                            GO TO 80
*-- Soon available.
         ELSE IF(ACMODE.EQ.2) THEN
*-- Data should be staged.
            CALL RSTAGE(CFNAME,LUN,LREAD,LCIO,LUNPTR,IER)
            IF(IER.NE.0)                                        GO TO 50
         END IF
+SELF,IF=VAX.
         IF(ACMODE.EQ.1) THEN
*-- Read from exabyte
            CALL RMOUNT(CFNAME,LIOBNK,LTAPE,IER)
            IF(IER.NE.0)                                        GO TO 50
         ELSE IF(ACMODE.EQ.0) THEN
*-- Is the user social?
            IF(CHID.EQ.'IODI'.AND..NOT.BTEST(FLAGS,ANYWHE)) THEN
               IPC    = INDEX(CFNAME,'::')
               IF(IPC.NE.0) THEN
                  IF(CHNODE(1:LCHNOD).NE.CFNAME(1:IPC-1)) THEN
                     WRITE(CHLINE,1110)
                     CALL RMAIL(1,0)
                     WRITE(CHLINE,1120)
                     CALL RMAIL(0,0)
                     WRITE(CHLINE,1110)
                     CALL RMAIL(0,1)
                  END IF
               END IF
            END IF
         END IF
*-- On vax open a file with the convention that unit n is FOR00n
         IF(LALPHA) THEN
            IF(CFSTAT(1:3).EQ.'OLD') THEN
               OPEN(UNIT=LUN,FILE=CFNAME(IFC:ILC),STATUS=CFSTAT,
     +              READONLY,
     +              FORM='FORMATTED',IOSTAT=IOSTAT,ERR=60)
            ELSE
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +              FORM='FORMATTED',IOSTAT=IOSTAT,ERR=60)
            END IF
         ELSE
            IF(CFSTAT(1:3).EQ.'OLD') THEN
               OPEN(UNIT=LUN,FILE=CFNAME(IFC:ILC),STATUS=CFSTAT,
     +              READONLY,
     +              FORM='UNFORMATTED',IOSTAT=IOSTAT,ERR=60)
*-- New file; Use FILRE value to define blocksize in exchange mode;
*            ELSE IF(LTAPE.AND.LEXCH) THEN
            ELSE IF(LEXCH) THEN
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +              RECL=IRECL,BLOCKSIZE=IBLOCK,RECORDTYPE='FIXED',
     +              FORM='UNFORMATTED',IOSTAT=IOSTAT,ERR=60)
*-- Use big blocksize in native mode for tapes.
            ELSE IF(LTAPE) THEN
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +              BLOCKSIZE=32400,
     +              FORM='UNFORMATTED',IOSTAT=IOSTAT,ERR=60)
            ELSE IF(CHID.EQ.'IOME') THEN
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +              IOSTAT=IOSTAT,ERR=60)
            ELSE
               OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +              FORM='UNFORMATTED',IOSTAT=IOSTAT,ERR=60)
            END IF
         END IF
+SELF,IF=CRAY.
*-- Soon available.
+SELF,IF=IBM.
*-- On IBM open ONLY named files. The unnamed ones need nothing
         IF(TYPE.EQ.1) THEN
            IF(LEXCH) THEN
               WRITE(DESCRI,1130) IRECL
            ELSE IF(IRECL.NE.0) THEN
               WRITE(DESCRI,1131) IRECL
            ELSE
               IF(LREAD)THEN
                  DESCRI = 'RECFM VBS'
               ELSE
                  DESCRI = 'RECFM VBS BLKSIZE 32400'
               ENDIF
            END IF
            IF(ACMODE.EQ.0) THEN
               IF(.NOT.LREAD)THEN
*                 does output file exist on A-disk?
                  INQUIRE(FILE=CFNAME,EXIST=LEXIST)
                  IF(LEXIST)THEN
                     WRITE(CHREP,'(A,A,A)')'Output file :',
     +               CFNAME(1:LENOCC(CFNAME)),
     +               ' exists already, please RENAME or DELETE it'
                     CALL REPORT('ROOFLX',12,'C')
                                                               GO TO 999
                  ENDIF
               ENDIF
               IF(LALPHA.OR.CHID.EQ.'IOME') THEN
                  OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +                 FORM='FORMATTED',ERR=50)
               ELSE IF(LEXCH) THEN
                  WRITE(SYSCOM,1140) CHLUN
                  CALL RQSYST(.FALSE.)
                  WRITE(SYSCOM,1150) CHLUN,CFNAME(2:LENOCC(CFNAME))
     +                              ,DESCRI
                  CALL RQSYST(.FALSE.)
                  IOSTAT = SYSRC
                  IF(IOSTAT.NE.0)                               GO TO 50
               ELSE
                  IF (LREAD) THEN
                  WRITE (SYSCOM,1250) CFNAME(2:LENOCC(CFNAME))
                  CALL RQSYST(.FALSE.)
                  IOSTAT = SYSRC
                  IF(IOSTAT.NE.0)                               GO TO 50
                  CALL VMRTRM(CRECFM,L)
                  READ (CRECFM,1260,IOSTAT=IOSTAT,ERR=50) IRECL
                  ELSE IF (IRECL.EQ.0) THEN
                    IRECL = 32400
                  ENDIF
                  CALL FILEINF(IOSTAT,'RECFM','VBS','BLKSIZE',IRECL)
                  IF(IOSTAT.NE.0)                               GO TO 50
                  OPEN(UNIT=LUN,FILE=CFNAME,STATUS=CFSTAT,
     +                 FORM='UNFORMATTED',ERR=50)
               END IF
            ELSE IF(ACMODE.EQ.1) THEN
*-- Mount the tape
               CALL RMOUNT(LIOBNK,CHLUN,DESCRI,LREAD,IER)
               IF(IER.NE.0)                                     GO TO 50
            ELSE IF(ACMODE.EQ.2.OR.ACMODE.EQ.3) THEN
*-- Prestage the next tape?
*-- Assume SAME FORMAT !!!
               IF(ACMODE.EQ.3.AND.LREAD) THEN
                  LIOBN2 = LQ(LIOBNK)
                  IF(LIOBN2.GT.0) THEN
                     IF(IQ(LIOBN2+JACMOD).EQ.3) THEN
                        CALL UHTOC(IQ(LIOBN2+JFNAME),NBYTEW,
     +                             CFNAME,NAMLEN)
                        NDUMMY = NDUMMY + 1
                        WRITE(DUMMY,1160) NDUMMY
                        CALL RSTAGE(CFNAME,DUMMY,DESCRI,.TRUE.,
     +                              IQ(LIOBN2+JFLAGS),IER)
                        CALL UHTOC(IQ(LIOBNK+JFNAME),NBYTEW,
     +                             CFNAME,NAMLEN)
                     END IF
                  END IF
               END IF
*-- Stage the tape
               CALL RSTAGE(CFNAME,CHLUN,DESCRI,LREAD,FLAGS,IOSTAT)
               IF(IOSTAT.LT.0 .OR. IOSTAT.GT.1)                 GO TO 50
            END IF
*-- Might be a 'DUMMY' file
         ELSE IF(TYPE.EQ.-1) THEN
            NDUMMY = NDUMMY + 1
            SYSCOM = 'FILEDEF '//CHLUN//' DUMMY'
            CALL RQSYST(.FALSE.)
            IF(IOSTAT.NE.0)                                     GO TO 50
         END IF
+SELF.
         IF(CHID.EQ.'IOME') THEN
            IQ(LIOBNK+JACTIV) = 1
         ELSE
            IQUEST(1) = 0
            IF(LSAME) THEN
+SELF,IF=IBM.
*-- One has to explicitely reopen the file
               IF(.NOT.LEXCH) OPEN(UNIT=LUN,FORM='UNFORMATTED')
+SELF.
            ELSE
+SELF,IF=UNIX,IF=-SHIFT.
***&&&+SELF,IF=APOLLO,HPUX,IBMRT,SUN,DECS.
               IF(LCIO) IQUEST(1) = LUNPTR
+SELF,IF=SHIFT.
               IF(LCIO) THEN
                  LCIOLU(LUN) = LUNPTR
                  IQUEST(1) = LUNPTR
               ENDIF
+SELF.
+SELF,IF=SHIFT.
               IF(DCHOPT(1:4).eq.'5678')THEN
                  CALL FZFILE(LUN,8100,'CIXD')
                  CALL FZHOOK(LUN,ROFGET,0)
               ELSE
                  CALL FZFILE(LUN,FILRE,CFIFCH)
               END IF
+SELF,IF=-SHIFT.
               CALL FZFILE(LUN,FILRE,CFIFCH)
+SELF.
            END IF
            IF(IQUEST(1).EQ.0) IQ(LIOBNK+JACTIV) = 1
*-- Set limit on No words written on output files.
            IF((CHID.EQ.'IODO'.OR.CHID.EQ.'IODC'.OR.CHID.EQ.'IODS'.OR.
     +          CHID.EQ.'IODD'.OR.CHID.EQ.'IOOV'.OR.CHID.EQ.'IODP'.OR.
     +          CHID.EQ.'IODG').AND.(RFZLIM.GT.0.))
     +                                      CALL FZLIMI(LUN,RFZLIM)
         END IF
      END IF
                                                               GO TO 999
   40 WRITE(CHREP,1170) IER,ROUTIN,ACTION(1:LENOCC(ACTION))
      CALL REPORT('ROOFLX',10,'E')
                                                               GO TO 999
   50 WRITE(CHREP,1180) IOSTAT,LUN,CFNAME(1:LENOCC(CFNAME))
      CALL REPORT('ROOFLX',11,'N')
+SELF,IF=VAX.
                                                               GO TO 999
   60 IF(RETRY) THEN
         CHREP  = 'Did not succeed in nodeless opening of '
     +            //CFNAME(1:ILC)//'. Try with node name'
         CALL REPORT('ROOFLX',12,'W')
         IFC=1
                                                                GO TO 20
      END IF
      WRITE(CHREP,1180) IOSTAT,LUN,CFNAME(1:LENOCC(CFNAME))
      CALL REPORT('ROOFLX',13,'N')
      IF(IOSTAT.EQ.29) THEN
         WRITE(CHLINE,1110)
         CALL RMAIL(1,0)
         WRITE(CHLINE,1190)
         CALL RMAIL(0,0)
         IF(ACMODE.EQ.1) THEN
            WRITE(CHLINE,1200)
            CALL RMAIL(0,0)
         END IF
         WRITE(CHLINE,1110)
         CALL RMAIL(0,1)
      END IF
+SELF,IF=UNIX.
                                                               GO TO 999
   60 WRITE(CHREP,1210) POOL,USER,SFNAME
      CALL REPORT('ROOFLX',14,'E')
+SELF,IF=VAX,UNIX.
                                                               GO TO 999
   70 WRITE(CHREP,1220) IOSTAT,LUN
      CALL REPORT('ROOFLX',15,'E')
+SELF,IF=UNIX.
                                                               GO TO 999
   80 CHREP  = 'CIO Not yet handled for tape reading/staging'
      CALL REPORT('ROOFLX',16,'F')
                                                               GO TO 999
   90 WRITE(CHREP,1230) IOSTAT,LUN
      CALL REPORT('ROOFLX',17,'E')
                                                               GO TO 999
*  100 WRITE(CHREP,1240) IOSTAT,LUN
*      CALL REPORT('ROOFLX',18,'E')
+SELF.
*
  999 CONTINUE
+SELF,IF=IBM.
CCCCCC Temporary comment of Phone facility
*-- Reset the SMSG setting
CCC   IF(LPHONE) THEN
CCC      SYSCOM = 'CP SET SMSG IUCV'
CCC      CALL RQSYST(.FALSE.)
CCC   END IF
CCCCCC End of temporary comment of Phone facility
+SELF.
*
      RETURN
 1000 FORMAT('IOFILE',I2.2)
 1010 FORMAT('FT',I2.2,'F',I3.3)
 1020 FORMAT('FOR',I3.3)
+SELF,IF=UNIX.
 1030 FORMAT('sfget -k -p ',A10,' -u ',A10,A60,' > temp.file ')
 1040 FORMAT('sfget -s 0 -p ',A10,' -u ',A10,A60,' > temp.file ')
+SELF.
 1050 FORMAT(I2)
 1060 FORMAT(' ROOFLX: Processing file ',A,' on unit',I3,' as ',A)
 1070 FORMAT('DATABASE',I2.2)
 1080 FORMAT(I6,'/',I4,' *')
 1090 FORMAT(' Opening output DAD list ',A,' header is:',A)
 1100 FORMAT('META_',I3.3)
 1110 FORMAT(10X,80('*'))
 1120 FORMAT(10X,'* You are pulling out input files over the network.',
     +       ' This is considered VERY antisocial',T90,'*')
 1130 FORMAT('RECFM F BLOCK',I7)
 1140 FORMAT('FILEDEF ',A,' CLEAR')
+SELF,IF=IBM.
 1131 FORMAT('RECFM VBS BLKSIZE',I7)
+SELF
 1150 FORMAT('FILEDEF ',A,' DISK ',A,' (',A)
 1160 FORMAT('DUMMY',I3.3)
 1170 FORMAT('Error code',I4,' from ',A,' while ',A)
 1180 FORMAT('Error',I6,' when opening unit',I3,' for file:',A)
 1190 FORMAT(10X,'* This error code means: file not found',T90,'*')
 1200 FORMAT(10X,'* You are using a tape so please make',
     +       ' sure that all files are declared in order',T90,'*')
 1210 FORMAT('Pool ',A10,' Owner ',A10,' does not contain ',A60)
 1220 FORMAT('Write error',I4,' on DAD list unit',I3)
 1230 FORMAT('Error',I3,' reading title of dadlist on unit',I3)
* 1240 FORMAT('Error',I3,' while write the event list title unit',I3)
 1250 FORMAT('LFILE ',A,' ( FORMAT STACK NF 1')
 1260 FORMAT(28X,I5)
      END
+DECK,ROFZIO,IF=ONLINE.
      SUBROUTINE ROFZIO( IBUF, IOWAY )
*.
*...ROFZIO   is hooked to FZIN/FZOUT using FZHOOK in ROOFLX.
*.
*. SEQUENCE  :
*. COMMON    :
*. CALLS     : ROFZO ROFZI
*. CALLED    : FZIN/FZOUT
*.
*. AUTHOR    : M.Jones
*. VERSION   : 1.0
*. CREATED   : 22-Sep-93
*. LAST MOD  : 22-Sep-93
*.
*. Modification log:
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
*
      INTEGER IBUF(*), IOWAY
*
      EXTERNAL ROFZO
      EXTERNAL ROFZI
      INTEGER ROFZO, ROFZI
      INTEGER I, ICHECK
      REAL FCHECK
      EQUIVALENCE (ICHECK,FCHECK)
*
      INTEGER IQUEST(100)
      COMMON /QUEST/IQUEST
*
      IF ( IOWAY .EQ. 1 ) THEN
*
*  Process the output buffer...
*
        IF ( ROFZO( IBUF, IQUEST ) .NE. 0 ) THEN
          CHREP = 'Error calling ROFZO'
          CALL REPORT('ROFZIO',1,'W')
          IQUEST(1) = 1
        ELSE
          IQUEST(1) = 0
        ENDIF
      ELSE
*
*  Read the event into the input buffer...
*
        IF ( ROFZI( IBUF, IQUEST ) .NE. 0 ) THEN
          CHREP = 'Error calling ROFZI'
          CALL REPORT('ROFZIO',2,'W')
          IQUEST(1) = 1
        ELSE
          IQUEST(1) = 0
        ENDIF
      ENDIF
      RETURN
      END
+DECK,ROOPEN.
      SUBROUTINE ROOPEN(CHFILE,IER)
*.
*...ROOPEN   Open the various files in ROPE
*.
*. INPUT     : CHFILE Option indicating the file to be opened
*.                    Allowed are:INIT,CNST,INPUT,OUTPUT,COPY,DST,
*.                                OVER,CAL,HISTO
*. OUTPUT    : IER    Return status, IER=0 for success.
*.
*. COMMON    : QUEST
*. SEQUENCE  : ROBANK RCNTRL ROCPAR ROUNIT RCREP OCERR OCPARM OCCOM
*.           : RBITFUNC ROWORD
*. CALLS     : ROOFLX RONFLX OCMAK OCINI HROPEN REPORT MZDROP
*.             RCLSIO
*. CALLED    : RIOSET ROTRIG GRDZGO UPDVW2
*.
*. BANK U    : IOHD IOII IOCI IODI IODO IODC IOOV IODS IOCA IOME
*.             IOBK IOHB IODP IODG
*. BANK D    : IODI
*.
*. AUTHOR    : A.Buijs,S.Weisz
*. VERSION   : 1.02
*. CREATED   : 10-Feb-88
*. LAST MOD  : 10-Jan-00
*.
*. Modification log:
*. 10-Jan-00 M.Schroder  Fix format 1003 for dates
*. 02-Feb-94 D.Lellouch  Remove the DDSI business (now in DC)
*.  9-Oct-93 O.Schaile   Get last Update of SUDB
*.  3-Aug-93 O.Schaile   Bug fix LIO => LIODI before DDSI=0
*. 20-Jul-93 O.Schaile   If CAL file is SUDB only REPORT it, dont stop
*. 19-Jun-92 D.Lellouch  Open the data compression dictionary(ies)
*.                       Get uncompress flag
*. 12-Feb-92 D.Lellouch    Unix [v.large]ntuples can be opened on pools
*.  911009   S.Weisz Specify filemode A for default HISTO file.
*. 15-Aug-91 S.Weisz     Handle DAD lists on SGI.
*. 25-Mar-91 D.Lellouch  Open output DAD list as well.
*. 18-Fev-91 S.Weisz     Open Histo file with larger size.
*. 18-Nov-90 D.lellouch  Rewrite pieces of code to be more legible
*.                       Can open HISTO file with user given name
*.                       Handle variable name output files (DCHOPT=9999)
*. 23-Oct-90 S.Weisz     Handle DDST stream.
*. 11-Jun-90 S.Weisz     Call to FZENDI( ,'I') moved in RONFLX.
*.  7-Jun-90 S.Weisz     Set STOP status.
*.  2-Mar-90 S.Weisz     Allow for logical HBOOK RZ filename on VAX.
*. 13-Oct-89 S.Weisz     Close files when multiple reading is done.
*.  7-Sep-89 S.Weisz     Handle SCAN stream.
*. 15-Jul-89 S.Weisz     Output expanding on multiple files.
*. 12-Jun-89 S.Weisz     Handle Production stream.
*. 19-May-89 S.Weisz     Remove Expt Nb. in OCINI call,
*.                       Initial Nb. of record = NRECI (5000) in OCMAK
*.  3-May-89 R.W.L.Jones CALL OCINI for 'NEW' option too.
*.  8-Apr-89 S,Weisz     Modif for OPCAL
*. 24-Feb-89 S,Weisz     Pass record length to OCMAK.
*. 22-Feb-89 S.Weisz     Call OCMAK if calibration file is new.
*.  7-Feb-89 S.Weisz     Modification for OPCAL101.
*.  1-Jan-89 S.Weisz     Implement multiple calibration files.
*.  6-Jan-89 S.Weisz     Handle Constant, Overflow, HBOOK files.
*.                       Handle multiple tape reading on same LUN.
*. 27-Jun-88 S.Weisz     Open Calibration file too.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER IER,LIOHD,LIOII,LIOCI,LIODI,LIOCA,LIOHB,LIOBK,LIOME,FLAGS,
     +        LLIO,LIO,LUNCAL,LUNHIS,LRECHB,NRECI,NFIOUT,NTYP
     +      ,LIODT
      CHARACTER*(*) CHFILE
      CHARACTER*80  CFNAME
      CHARACTER*10 POOL,USER
      CHARACTER*80 SPACES
      EXTERNAL     SPACES
      INTEGER      IPC,IFC,LENOCC
      EXTERNAL     LENOCC
      CHARACTER*4   CHTNAM,CHOPTC,CFSTAT,CHOPTH
      PARAMETER (NRECI = 5000)
*
      INTEGER      IQUEST
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
+SEQ,RCREP.
+SEQ,OCFLAG.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCSYST.
*
      IER    = 1
      LIOHD  = LQ(LUTC-LLIOHD)
      IF(CHFILE.EQ.'INIT') THEN
*-- Open the Initialization file.
         LIOII  = LQ(LIOHD-LLIOII)
         CALL ROOFLX(LIOII)
         IF(IQ(LIOII+JACTIV).EQ.1) IER = 0
*     Take care of the Data compression directory(ies)
      ELSE IF(CHFILE.EQ.'DICT') THEN
         LIODT=LQ(LIOHD-LLIODT)
1        CONTINUE
         IF(LIODT.GT.0) THEN
            CALL ROOFLX(LIODT)
            LIODT=LQ(LIODT)
            GO TO 1
         END IF
      ELSE IF(CHFILE.EQ.'CNST') THEN
*-- Open the Constant file.
         LIOCI  = LQ(LIOHD-LLIOCI)
         CALL ROOFLX(LIOCI)
         IF(IQ(LIOCI+JACTIV).EQ.1) IER = 0
      ELSE IF(CHFILE.EQ.'INPUT') THEN
*-- Open a new input file. Check if there is an active input file;
*-- If so, check if more data are expected on this logical unit,
*-- otherwise close it and drop the corresponding bank.
*-- Then find and open the next file.
   10    LIODI  = LQ(LIOHD-LLIODI)
         IF(LIODI.LT.1) THEN
            CHREP  = 'No more input files'
            CALL REPORT('ROOPEN',1,'I')
            NSTOP  = 0
         ELSE IF(IQ(LIODI+JACTIV).GE.1) THEN
            FLAGS  = IQ(LIODI+JFLAGS)
            IQ(LIODI+JDCHOP) = IQ(LIODI+JDCHOP) - 1
            IF(IQ(LIODI+JDCHOP).GE.1) THEN
               CALL RONFLX(LIODI)
               IF(IQ(LIODI+JACTIV).EQ.1) IER = 0
            ELSE
               CALL RCLSIO(LIODI,.TRUE.)
                                                                GO TO 10
            END IF
         ELSE
+SELF,IF=UNIX.
            FLAGS  = IQ(LIODI+JFLAGS)
            IF(BTEST(FLAGS,INDIRF)) THEN
               CHREP  = 'No more input files'
               CALL REPORT('ROOPEN',2,'I')
               NSTOP  = 0
                                                               GO TO 999
            END IF
+SELF.
            LCLOSI = .FALSE.
            NINPUT = NINPUT + 1
            CALL ROOFLX(LIODI)
            IF(IQ(LIODI+JACTIV).EQ.1) IER = 0
         END IF
      ELSE IF(CHFILE.EQ.'CAL') THEN
*-- Open Calibration data base.
         LIOCA = LQ(LIOHD-LLIOCA)
   20    IF(LIOCA.LE.0)                                        GO TO 999
         IER   = 1
         CALL ROOFLX(LIOCA)
         CALL UHTOC(IQ(LIOCA+JDCHOP),4,CHTNAM,4)
         IF(IQ(LIOCA+JACTIV).NE.1)THEN
            IF(CHTNAM.EQ.'SUDB')THEN
               CHREP='Cannot OPEN SU data base'
               CALL REPORT('ROOPEN',13,'E')
                                                                 GOTO 25
            ELSE
                                                               GO TO 999
            ENDIF
         ENDIF
*-- Initialize OPCAL for this data base.
         LUNCAL = IQ(LIOCA+JLUN)
         CALL UHTOC(IQ(LIOCA+JFCHOP),4,CHOPTC,4)
         CALL UHTOC(IQ(LIOCA+JFSTAT),4,CFSTAT,4)
         IF(CFSTAT(1:3).EQ.'NEW') THEN
            CALL OCMAK(LUNCAL,CHTNAM,NRECI,' ')
*
            CALL RZEND(CHTNAM)
            CLOSE(LUNCAL)
            CFSTAT = 'OLD '
            CALL UCTOH(CFSTAT,IQ(LIOCA+JFSTAT),4,4)
*
            CALL ROOFLX(LIOCA)
         END IF
         CALL OCINI(LUNCAL,CHTNAM,'ROPE','DUMMY',CHOPTC)
         IF(IOCERR.NE.0)THEN
            IF(CHTNAM.EQ.'SUDB')THEN
               CHREP='Problem from OCINI with SU data base'
               CALL REPORT('ROOPEN',14,'E')
               IOCERR=0
            ELSE
                                                               GO TO 999
            ENDIF
         ENDIF
*--      for SUDB get data/time of last update
         IF(CHTNAM.EQ.'SUDB')THEN
            CALL OCMOD(CHTNAM,ISDATE,ISTIME)
            ISTIME = 100*ISTIME
            WRITE(CHREP,1003)ISDATE,ISTIME
            CALL REPORT('ROOPEN',15,'I')
         ENDIF
*-- Look for next file
25       LIOCA  = LQ(LIOCA)
         IER    = 0
                                                                GO TO 20
      ELSE IF(CHFILE.EQ.'HISTO') THEN
*-- Open HBOOK RZ file.
         LIOHB  = LQ(LIOHD-LLIOHB)
         IF(LIOHB.LT.1) THEN
            CHREP  = 'Problem with HBOOK RZ file'
            CALL REPORT('ROOPEN',3,'W')
         ELSE
            LUNHIS = IQ(LIOHB+JLUN)
            LRECHB = IQ(LIOHB+JLREC)
            CALL UHTOC(IQ(LIOHB+JFCHOP),4,CHOPTH,4)
            IQUEST(10) = IQ(LIOHB+JDCHOP)
            NTYP   = IQ(LIOHB+JFNTYP)
            IF(NTYP.EQ.0) THEN
*-- Histogram file name not given, take a reasonnable default.
+SELF,IF=VAX.
               CFNAME = 'ROPEHIST'
+SELF,IF=IBM.
      CFNAME = 'ROPE.HISTO.A'
+SELF,IF=-VAX,IF=-IBM.
               CFNAME = 'ROPE.HISTO'
+SELF.
            ELSE IF(NTYP.EQ.1) THEN
*-- Use the histogram file name
               CALL UHTOC(IQ(LIOHB+JFNAME),NBYTEW,CFNAME,NAMLEN)
+SELF,IF=IBM.
*-- On ibm, some preparation work has to be done!
               CALL RIBMOP(CFNAME,CFSTAT,.TRUE.)
+SELF.
+SELF,IF=UNIX.
            CFNAME=SPACES(CFNAME,0)
            IF(CFNAME(1:1).EQ.'[') THEN
               IFC=INDEX(CFNAME(1:NAMLEN),']')
               IPC=INDEX(CFNAME(1:IFC-1),'.')
               POOL='ntup'
               USER='" "'
               IF(IPC.EQ.0) THEN
                  IF(IFC.GT.2) POOL=CFNAME(2:IFC-1)
               ELSE
                  IF(IPC.GT.2) POOL=CFNAME(2:IPC-1)
                  IF(IPC.LT.IFC-1) USER=CFNAME(IPC+1:IFC-1)
               END IF
               CALL CUTOL(POOL)
               CALL CUTOL(USER)
               WRITE(SYSCOM,1001) POOL,USER,CFNAME(IFC+1:NAMLEN)
               CALL RQSYST(.FALSE.)
               OPEN(UNIT=99,FILE='temp.file',STATUS='OLD')
               READ(99,'(A80)',ERR=999,END=999) CFNAME
               CLOSE(UNIT=99,STATUS='DELETE')
            END IF
            IF(INDEX(CHOPTH,'N').GT.0) THEN
               CHREP='Trying to delete the histogram file: '//CFNAME
               CALL REPORT('ROOPEN',12,'I')
               SYSCOM='rm '//CFNAME(1:LENOCC(CFNAME))//' 2>/dev/null'
               CALL RQSYST(.FALSE.)
            END IF
+SELF
            ELSE IF(NTYP.EQ.2) THEN
               CHREP  = 'Histograms file can not be a FATMEN entry'
               CALL REPORT('ROOPEN',4,'E')
                                                               GO TO 999
            ELSE IF(NTYP.GE.3.AND.NTYP.LE.5) THEN
               CHREP  = 'Histograms file can not be on tape'
               CALL REPORT('ROOPEN',5,'E')
                                                               GO TO 999
            END IF
            CALL HROPEN(LUNHIS,'HISTO',CFNAME,CHOPTH,LRECHB,IER)
            CHREP='Opening the histogram file: '//CFNAME
            CALL REPORT('ROOPEN',11,'I')
         END IF
      ELSE IF(CHFILE.EQ.'BANK')  THEN
*-- Open Bank documentation RZ file.
         LIOBK  = LQ(LIOHD-LLIOBK)
         CALL ROOFLX(LIOBK)
         IF(IQ(LIOBK+JACTIV).EQ.1) IER = 0
      ELSE IF(CHFILE.EQ.'META') THEN
*-- Open metafile.
         LIOME  = LQ(LIOHD-LLIOME)
         CALL ROOFLX(LIOME)
         IF(IQ(LIOME+JACTIV).EQ.1) IER = 0
      END IF
*-- So far for non-output files . Now Open all output files at once.
*-- The OUPUT, COPY , DST and Overflow files are all treated in the
*-- same way. Make them selected by default
      IF(CHFILE.EQ.'OUTPUT') THEN
         LLIO   = LLIODO
      ELSE IF(CHFILE.EQ.'COPY') THEN
         LLIO   = LLIODC
      ELSE IF(CHFILE.EQ.'DST') THEN
         LLIO   = LLIODS
      ELSE IF(CHFILE.EQ.'DDST') THEN
         LLIO   = LLIODD
      ELSE IF(CHFILE.EQ.'OVER') THEN
         LLIO   = LLIOOV
      ELSE IF(CHFILE.EQ.'PROD') THEN
         LLIO   = LLIODP
      ELSE IF(CHFILE.EQ.'SCAN') THEN
         LLIO   = LLIODG
      ELSE IF(CHFILE.EQ.'DADOUT') THEN
         LLIO   = LLIOAO
      ELSE
*-- It is not an output file, the case has been processed above.
                                                               GO TO 999
      END IF
      LIO    = LQ(LIOHD-LLIO)
      NFIOUT = 0
   30 IF(LIO.LE.0)                                              GO TO 40
      IF(NFIOUT.GE.1) THEN
*-- This file is supposed to complete the previous one, make some check.
         IF(IQ(LIO+JDCHOP).GE.2) THEN
            WRITE(CHREP,1000) CHFILE
            CALL REPORT('ROOPEN',6,'W')
         END IF
         NFIOUT = NFIOUT - 1
*-- Mark it with DCHOP parameter.
         IQ(LIO+JDCHOP) = 0
      ELSE
*-- This file should be activated now.
         IER    = 1
         CALL ROOFLX(LIO)
         IF(IQ(LIO+JACTIV).EQ.1) IER = 0
         IQ(LIO+JSELEC) = 1
         WRITE(CHREP,1010) CHFILE,IQ(LIO+JLUN)
         CALL REPORT('ROOPEN',7,'I')
         NFIOUT = IQ(LIO+JDCHOP)
         IF(CHFILE.EQ.'DADOUT') THEN
            IQ(LIO+JDCHOP) = 1
*-- Test if this stream expands over several files.
         ELSE IF(NFIOUT.GE.2) THEN
            WRITE(CHREP,1020) NFIOUT
            CALL REPORT('ROOPEN',8,'I')
         ELSE
            CHREP = 'Only 1 file requested for this stream'
            CALL REPORT('ROOPEN',9,'I')
            IQ(LIO+JDCHOP) = 1
         END IF
*-- Set up counter for file to be appended.
         IF(NFIOUT.GE.1) NFIOUT = NFIOUT - 1
      END IF
      LIO    = LQ(LIO)
                                                                GO TO 30
*-- It might be worth making a consistency check.
   40 IF(NFIOUT.GE.1.AND.NFIOUT.NE.9999) THEN
         WRITE(CHREP,1000) CHFILE
         CALL REPORT('ROOPEN',10,'W')
      END IF
*
  999 RETURN
 1000 FORMAT('I guess you messed up the output stream ',A,' !!!')
 1001 FORMAT('sfget -k -p ',A,' -u ',A,1X,A,' >temp.file')
 1003 FORMAT(' SUDB database last updated',I9,I7)
 1010 FORMAT('Stream ',A,' open on logical unit ',I3)
 1020 FORMAT(I4,' files are requested for this stream')
      END
+DECK,ROPBAT.
      SUBROUTINE ROPBAT
*.
*...ROPBAT   Run ROPE processes selected by FFREAD cards.
*.
*. COMMON  : QUEST
*. SEQUENCE: ROBANK RCNTRL CRO ROPAR ROCPAR ROSPAR RCREP ODPAR CRVER
*.           CXCNTL
*. CALLS   : USBAT GRBAT DDRBAT TTBAT TRBAT FIBAT SCBAT XXDROP XXSTAT
*.           ROSTAT ODPEVT ODFILL ROSUMM REPORT ODFBLK ROEVTY
*.           ROMONI DDUBAT MWBAT LLBAT LABAT CXBAT
*. CALLED  : ROEVNT
*.
*. BANK U  : RCO CDC ECC HCC MUC FOC ASC ODC
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 19-Apr-88
*. LAST MOD:  9-Mar-00
*.
*. Modification Log.
*.  9-Mar-00  M.Schroder Move the call to ODFIX(0) in front of LLBAT
*.  7-Apr-99  M.Schroder Remove superfluous calls to ROUPON
*.  1-Apr-99  E.Barberio Add call to ODFIX before each call to USBAT
*. 14-Aug-97  M.Schroder Restrict range for restoring the TERA bank
*.  4-Aug-96  M.Schroder     Restore TERA bank (ROTERS)
*. 28-Mar-96  O.Schaile       Introduce TE process.
*. 31-Mar-94  O.Schaile      Add Call USBAT(OOFODC) after OD
*. 16-Feb-94  M.Redmond      Call CSBAT for OD-based analyses before OD
*. 12-Oct-93  O.Schaile      Make ODTOSI dependent on FFREAD card
*. 11-Oct-93  O.Schaile      CALL CXBAT after OD only if FFREAD 'CX'
*.                           take into account if no LDA bank there
*. 28-Sep-93  O.Schaile      call LMBAT again from ROCALL after FD
*. 16-Sep-93  M.Redmond      Remove 'CX' from argument list of ODTOSI
*. 19-Aug-93  M.Redmond      Make ODTOSI default
*.  3-Mar-93  O.Schaile      Introduce SW process, call LMBAT from here
*. 27-Oct-92  C.Hawkes       CALL CXBAT for DST-only analysis
*. 19-Jun-92  D.Lellouch     Call DCBAT
*. 31-Aug-92  C.Hawkes       CALL LMDST (twice)
*. 05-Jun-92  C.Hawkes       Rename MIGNRL,MRGNRL to MIGMOV,MRGMOV
*.                           to avoid confict with ODPAR in OD400
*. 15-Mar-92  C.Hawkes       Fix logic of LLBAT and LABAT calls
*.  7-Mar-92  O.Schaile      add IF(IRSTOP... after CALL USBAT(-2)
*. 20-Feb-92  C.Hawkes       Implement LLBAT and LABAT
*. 12-Feb-92  O.Schaile      CALL USBAT(-2) after DDUBAT
*.  2-Sep-91  S.Weisz        Call XXDROP only if XX library is loaded
*. 20-Jul-91  C.M.Hawkes     Filter word copied to header for MC events
*. 23-Apr-91  S.Weisz        Drop all CD links after DD unpacking.
*. 23-Apr-91  C.M.Hawkes     Fill more header/REV words.
*. 20-Mar-91  S.Weisz        Call CX regardless of presence of CX banks.
*. 21-Jan-91  S.Weisz        Call ROCALL instead of XXBAT.
*. 25-Oct-90  S.Weisz        Do not call XXSTAT for MC events.
*. 23-Oct-90  S.Weisz        Monitor DD too.
*. 10-Oct-90  S.Weisz        Add call to MWBAT and call CX after CA.
*. 20-Jun-90  S.Weisz        Modify steering for DDRBAT.
*.  7-May-90  S.Weisz        Implement calls to DDRBAT.
*.  5-Apr-90  S.Weisz        Remove ASBAT, call DDBAT,DDUBAT.
*. 21-Mar-90  S.Weisz        Monitoring and verification in ROMONI.
*.  9-Mar-90  C.M.Hawkes     Call ROEVTY
*.  2-Mar-90  S.Weisz        Call HT/HSSTAT instead of HB/HE.
*. 10-Feb-90  S.Weisz        Update status words.
*. 16-Oct-89  S.Weisz        Call SCBAT according to ISCBAT flag.
*. 12-Sep-89  S.Weisz        Call XXDROP according to IFDROP flag.
*. 18-Jul-89  S.Weisz        Update Header here.
*.  8-Jul-89  S.Weisz        Keep DST results if no Raw data.
*. 16-Jun-89  S.Weisz        Call trigger and filter routines.
*. 13-Jun-89  S.Weisz        Monitor time spendt in USBAT,
*.                           Use link area in ROSLNK.
*. 10-May-89  S.Weisz        Always call ODBAT.
*. 23-Mar-89  S.Weisz        Add CE and CA monitoring.
*. 22-Feb-89  S.Weisz        Bug in time monitoring when ZVERIFY on.
*. 26-Jan-89  S.Weisz        Implement MONITOR and ZVERI Ffread cards.
*. 24-Jan-89  S.Weisz        Call ROSUMM before dropping working banks.
*. 20-Dec-88  S.Weisz        Fill size and timing of processors.
*.                           Remove calls to GEBAT,BEBAT.
*. 29-Aug-88  S.Weisz        Implement rerun option, check input.
*.                           Call to XXDROP after blocks of processors.
*.                           Patchy flag MONITOR to check processors.
*. 27-Jun-88  S.Weisz        Call retrieval of calibration constants.
*. 05-May-88  S.Weisz        Call OD processes.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER NPR,I,NW,LFIRA
      INTEGER IGNRLD,MIGMOV,MRGMOV, IFAIL
      REAL    RGNRLD
      CHARACTER*2 CHODSI, CHODCX
      LOGICAL CALLCS, CALLCX, CALLSI
      INTEGER      IQUEST
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROSPAR.
+SEQ,ODPAR.
+SEQ,CRVER.
+SEQ,RCREP.
+SEQ,CSCXUS.
+SEQ,CXCNTL.
+SEQ,GOFLAG.
*
      LOGICAL ONLINE
*
      DIMENSION IGNRLD(NIGNRL),RGNRLD(NRGNRL)
*-- Call MAW steering routine.
+SELF,IF=VAX.
      CALL MWBAT
+SELF.
*-- Set option for ODTOSI
      IF(MOD(IFODSI,10).EQ.2)THEN
         CHODSI='SI'
      ELSE IF(MOD(IFODSI,10).EQ.1)THEN
         CHODSI='si'
      ELSE IF(MOD(IFODSI,10).EQ.0)THEN
         CHODSI=' '
      ENDIF
      IF(IFODSI.LE.10)THEN
         CHODCX=' '
      ELSE
         CHODCX='CX'
      ENDIF
*-- Set up flags for calling CS and CX for DST analyses
      CALLCS = IVCS.GT.0 .AND. IQ(LCDC+IIFCSC).NE. 0 .AND.
     +(ICSUCX.EQ.0.OR.ICSUCX.EQ.4)
      CALLCX = IVCX.GT.0 .AND. IQ(LCDC+IIFCXC).NE. 0 .AND.
     +(ICXUSE.EQ.0.OR.ICXUSE.EQ.4)
      CALLSI = IVSI.GT.0 .AND. IQ(LCDC+IIFSIC).NE. 0
*-- First call unpacking whenever asked.
      IF(IDUBAT.GE.1.AND.IRINTR.EQ.0) THEN
         IF(LDA.LT.1.AND.LDD.LT.1)                              GO TO 70
         CALL ROMONI(0,1)
         CALL DDUBAT
         CALL ROMONI(3,0)
*-- Drop CJ,CT working banks, they should not be there!
         IF(LCD.GT.0.AND.INDROP.EQ.0) THEN
            LCJ    = LQ(LCD-LLCJ)
            IF(LCJ.GT.0) CALL MZDROP(IXSTOR,LCJ,'.')
            LCJ    = 0
            LCT    = LQ(LCD-LLCT)
            IF(LCT.GT.0) CALL MZDROP(IXSTOR,LCT,'.')
            LCT    = 0
            LCZ    = LQ(LCD-LLCZ)
            IF(LCZ.GT.0) CALL MZDROP(IXSTOR,LCZ,'.')
            LCZ    = 0
         END IF
      END IF
+SELF,IF=-ONLINE.
C     restore the TERA bank (GNRL -> DA) (temporary solution)
      IF ( IRDRUN .GT. 7360 .AND. IRDRUN .LT. 8000 ) THEN
         CALL ROTERS
      ENDIF
+SELF.
*-- Call LMDST for the luminosity analysis (before old DST dropped)
      IF(IVLM.GT.0) CALL LMDST
+SELF,IF=-ONLINE.
      CALL ROUPON(ONLINE)
      IF(.NOT.ONLINE)THEN
        IF(IGOEXP.LT.999) CALL ODFIX(-2)
      END IF
+SELF.
      CALL USBAT(-2)
      IF(IRSTOP.NE.0)                                          GO TO 999
*-- Then call trigger and filter routines.
      IF(ITTBAT.GE.1) CALL TTBAT
      IF(ITRBAT.GE.1) CALL TRBAT
      IF(IFIBAT.GE.1) THEN
         CALL FIBAT
*-- For Monte Carlo events, write filter word into header, if requested
         IF(IRDEXP.GE.1000.AND.IFUPDT.EQ.1.AND.LDA.GE.1) THEN
            LFIRA = LQ(LDA-LLFIRA)
            IF(LFIRA.GE.1) THEN
               IUHEAD(IIFITY) = IQ(LFIRA+8)
               IF(LREV.GE.1) IQ(LREV+IIFITY) = IUHEAD(IIFITY)
            ENDIF
         ENDIF
      ENDIF
      IF(ISCBAT.GE.1) CALL SCBAT
*
      CALL ROMONI(0,1)
+SELF,IF=-ONLINE.
      IF(.NOT.ONLINE)THEN
        IF(IGOEXP.LT.999) CALL ODFIX(IIFDAC)
      END IF
+SELF.
      CALL USBAT(IIFDAC)
      IF(IRSTOP.NE.0)                                          GO TO 999
      CALL ROSUMM(IIFDAC)
      CALL ROMONI(1,0)
*
      NPR=IQ(LRCO+IIFCDC)
      IF(NPR.GE.1) THEN
         IF(LDA.LT.1)                                           GO TO 70
         IF(IFUPDT.EQ.1) THEN
*-- Reset Number of CT track and vertices.
            IUHEAD(IINCTR)  = 0
            IQ(LREV+IINCTR) = 0
            IUHEAD(IINVTX)  = 0
            IQ(LREV+IINVTX) = 0
            CALL VZERO(IUHEAD(IITHRU),7)
            CALL VZERO(IQ(LREV+IITHRU),7)
         END IF
*-- Call CD processes selected by CENTRAL card.
         DO 10 I=1,NPR
            IF(IABS(IQ(LCDC+IIFCVC)).EQ.I) THEN
               IF(LCV.EQ.0.OR.IQ(LCDC+IIFCVC).LT.0) THEN
                  CALL ROCLRZ('CV')
                  CALL ROCALL('CV')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFCJC)).EQ.I) THEN
               IF(LCJ.EQ.0.OR.IQ(LCDC+IIFCJC).LT.0) THEN
                  CALL ROCLRZ('CJ')
                  CALL ROCALL('CJ')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFCZC)).EQ.I) THEN
               IF(LCZ.EQ.0.OR.IQ(LCDC+IIFCZC).LT.0) THEN
                  CALL ROCLRZ('CZ')
                  CALL ROCALL('CZ')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFCTC)).EQ.I) THEN
               IF(LCT.EQ.0.OR.IQ(LCDC+IIFCTC).LT.0) THEN
                  CALL ROCLRZ('CT')
                  CALL ROCALL('CT')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFDXC)).EQ.I) THEN
               IF(LCT.EQ.0) THEN
                  CHREP = 'No CT bank, cannot call DX at this stage!'
                  CALL REPORT('ROPBAT',1,'I')
               ELSE
                  CALL ROCLRZ('DX')
                  CALL ROCALL('DX')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFCFC)).EQ.I) THEN
               IF(LCF.EQ.0.OR.IQ(LCDC+IIFCFC).LT.0) THEN
                  CALL ROCLRZ('CF')
                  CALL ROCALL('CF')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFCXC)).EQ.I .AND.
     +         ICXUSE.NE.0.AND.ICXUSE.NE.4) THEN
               IF(LCT.EQ.0) THEN
                  CHREP = 'No CT bank, cannot call CX at this stage!'
                  CALL REPORT('ROPBAT',2,'I')
               ELSE
                  CALL ROCLRZ('CX')
                  CALL ROCALL('CX')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFSIC)).EQ.I) THEN
               IF(LSI.EQ.0.OR.IQ(LCDC+IIFSIC).LT.0) THEN
                  CALL ROCLRZ('SI')
                  CALL ROCALL('SI')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFCSC)).EQ.I  .AND.
     +         ICSUCX.NE.0 .AND. ICSUCX.NE.4) THEN
               IF(LCT.EQ.0) THEN
                  CHREP = 'No CT bank, cannot call CS at this stage!'
                  CALL REPORT('ROPBAT',3,'I')
               ELSE
                  CALL ROCLRZ('CS')
                  CALL ROCALL('CS')
               END IF
            ELSE IF(IABS(IQ(LCDC+IIFCEC)).EQ.I) THEN
               IF(LCT.EQ.0) THEN
                  CHREP = 'No CT bank, cannot call CE at this stage!'
                  CALL REPORT('ROPBAT',4,'I')
               ELSE
                  CALL ROCLRZ('CE')
                  CALL ROCALL('CE')
               END IF
            END IF
            IF(IRSTOP.NE.0)                                    GO TO 999
   10    CONTINUE
         IF (.NOT.CALLCS .AND. .NOT.CALLCX) CALL ROSUMM(IIFCDC)
+SELF,IF=-ONLINE.
         IF(.NOT.ONLINE)THEN
           IF(IGOEXP.LT.999) CALL ODFIX(IIFCDC)
         END IF
+SELF.
         CALL USBAT(IIFCDC)
         IF(IRSTOP.NE.0)                                       GO TO 999
         CALL ROMONI(1,0)
      END IF
      IF(IDDBAT.GE.1) THEN
         CALL DDRBAT(IIFCDC)
         CALL ROMONI(3,0)
      END IF
      IF(IFDROP.NE.0) THEN
*-- Drop Central Detector working banks.
         IF(IVCV.GT.0) CALL CVDROP
         IF(IVCJ.GT.0) CALL CJDROP
         IF(IVCZ.GT.0) CALL CZDROP
         IF(IVCT.GT.0) CALL CTDROP
         IF(IVDX.GT.0) CALL DXDROP
         IF(IVCX.GT.0) CALL CXDROP
         IF(IVSI.GT.0) CALL SIDROP
         IF(IVCS.GT.0) CALL CSDROP
*-- Get new start values.
         CALL ROMONI(0,1)
      END IF
*
      NPR=IQ(LRCO+IIFECC)
      IF(NPR.GE.1) THEN
         IF(LDA.LT.1)                                           GO TO 70
         IF(IFUPDT.EQ.1) THEN
*-- Reset total ECAL energy in header.
            IUHEAD(IIECAL)  = 0
            IQ(LREV+IIECAL) = 0
            CALL VZERO(IUHEAD(IITHRU),5)
            CALL VZERO(IQ(LREV+IITHRU),5)
            CALL VZERO(IUHEAD(IINEB),4)
            CALL VZERO(IQ(LREV+IINEB),4)
         END IF
*-- Call EC processes selected by ECAL card.
         DO 20 I=1,NPR
            IF(IABS(IQ(LECC+IIFTBC)).EQ.I) THEN
               IF(LTB.EQ.0.OR.IQ(LECC+IIFTBC).LT.0) THEN
                  CALL ROCLRZ('TB')
                  CALL ROCALL('TB')
               END IF
            ELSE IF(IABS(IQ(LECC+IIFPBC)).EQ.I) THEN
               IF(LPB.EQ.0.OR.IQ(LECC+IIFPBC).LT.0) THEN
                  CALL ROCLRZ('PB')
                  CALL ROCALL('PB')
               END IF
            ELSE IF(IABS(IQ(LECC+IIFEBC)).EQ.I) THEN
               IF(LEB.EQ.0.OR.IQ(LECC+IIFEBC).LT.0) THEN
                  CALL ROCLRZ('EB')
                  CALL ROCALL('EB')
               END IF
            ELSE IF(IABS(IQ(LECC+IIFTEC)).EQ.I) THEN
               IF(LTE.EQ.0.OR.IQ(LECC+IIFTEC).LT.0) THEN
                  CALL ROCLRZ('TE')
                  CALL ROCALL('TE')
               END IF
            ELSE IF(IABS(IQ(LECC+IIFPEC)).EQ.I) THEN
               IF(LPE.EQ.0.OR.IQ(LECC+IIFPEC).LT.0) THEN
                  CALL ROCLRZ('PE')
                  CALL ROCALL('PE')
               END IF
            ELSE IF(IABS(IQ(LECC+IIFEEC)).EQ.I) THEN
               IF(LEE.EQ.0.OR.IQ(LECC+IIFEEC).LT.0) THEN
                  CALL ROCLRZ('EE')
                  CALL ROCALL('EE')
               END IF
            ELSE IF(IABS(IQ(LECC+IIFEMC)).EQ.I) THEN
               IF(LEM.EQ.0.OR.IQ(LECC+IIFEMC).LT.0) THEN
                  CALL ROCLRZ('EM')
                  CALL ROCALL('EM')
               END IF
            END IF
*-- Monitor time and space spent in Ecal processors.
            IF(IRSTOP.NE.0)                                    GO TO 999
   20    CONTINUE
         CALL ROSUMM(IIFECC)
+SELF,IF=-ONLINE.
         IF(.NOT.ONLINE)THEN
          IF(IGOEXP.LT.999) CALL ODFIX(IIFECC)
         END IF 
+SELF.
         CALL USBAT(IIFECC)
         IF(IRSTOP.NE.0)                                       GO TO 999
         CALL ROMONI(1,0)
      END IF
      IF(IDDBAT.GE.1) THEN
         CALL DDRBAT(IIFECC)
         CALL ROMONI(3,0)
      END IF
      IF(IFDROP.NE.0) THEN
*-- Drop Electron Calorimeter working banks.
         IF(IVTB.GT.0) CALL TBDROP
         IF(IVTE.GT.0) CALL TEDROP
         IF(IVPB.GT.0) CALL PBDROP
         IF(IVEB.GT.0) CALL EBDROP
         IF(IVPE.GT.0) CALL PEDROP
         IF(IVEE.GT.0) CALL EEDROP
         IF(IVEM.GT.0) CALL EMDROP
*-- Get new start values.
         CALL ROMONI(0,1)
      END IF
*
      NPR=IQ(LRCO+IIFHCC)
      IF(NPR.GE.1) THEN
         IF(LDA.LT.1)                                           GO TO 70
         IF(IFUPDT.EQ.1) THEN
*-- Reset total HCAL energy in header.
            IUHEAD(IIHCAL)  = 0
            IQ(LREV+IIHCAL) = 0
            CALL VZERO(IUHEAD(IITHRU),5)
            CALL VZERO(IQ(LREV+IITHRU),5)
            CALL VZERO(IUHEAD(IINHT),6)
            CALL VZERO(IQ(LREV+IINHT),6)
         END IF
*-- Call HC processes selected by HCAL card.
         DO 30 I=1,NPR
            IF(IABS(IQ(LHCC+IIFHBC)).EQ.I) THEN
               IF(LHB.EQ.0.OR.IQ(LHCC+IIFHBC).LT.0) THEN
                  CALL ROCLRZ('HB')
                  CALL ROCALL('HB')
               END IF
            ELSE IF(IABS(IQ(LHCC+IIFHEC)).EQ.I) THEN
               IF(LHE.EQ.0.OR.IQ(LHCC+IIFHEC).LT.0) THEN
                  CALL ROCLRZ('HE')
                  CALL ROCALL('HE')
               END IF
            ELSE IF(IABS(IQ(LHCC+IIFHPC)).EQ.I) THEN
               IF(LHP.EQ.0.OR.IQ(LHCC+IIFHPC).LT.0) THEN
                  CALL ROCLRZ('HP')
                  CALL ROCALL('HP')
               END IF
            ELSE IF(IABS(IQ(LHCC+IIFHMC)).EQ.I) THEN
               IF(LHM.EQ.0.OR.IQ(LHCC+IIFHMC).LT.0) THEN
                  CALL ROCLRZ('HM')
                  CALL ROCALL('HM')
               END IF
            END IF
*-- Monitor time and space spent in Hcal processors.
            IF(IRSTOP.NE.0)                                    GO TO 999
   30    CONTINUE
         CALL ROSUMM(IIFHCC)
+SELF,IF=-ONLINE.
         IF(.NOT.ONLINE)THEN
           IF(IGOEXP.LT.999) CALL ODFIX(IIFHCC)
         END IF 
+SELF.
         CALL USBAT(IIFHCC)
         IF(IRSTOP.NE.0)                                       GO TO 999
         CALL ROMONI(1,0)
      END IF
      IF(IDDBAT.GE.1) THEN
         CALL DDRBAT(IIFHCC)
         CALL ROMONI(3,0)
      END IF
      IF(IFDROP.NE.0) THEN
*-- Drop Hadron Calorimeter working banks.
         IF(IVHB.GT.0) CALL HBDROP
         IF(IVHE.GT.0) CALL HEDROP
         IF(IVHP.GT.0) CALL HPDROP
         IF(IVHM.GT.0) CALL HMDROP
*-- Get new start values.
         CALL ROMONI(0,1)
      END IF
*
      NPR=IQ(LRCO+IIFMUC)
      IF(NPR.GE.1) THEN
         IF(LDA.LT.1)                                           GO TO 70
         IF(IFUPDT.EQ.1) THEN
*-- Reset Number of Muon in header.
            IUHEAD(IINMUO)  = 0
            IQ(LREV+IINMUO) = 0
         END IF
*-- Call MU processes selected by MUON card.
         DO 40 I=1,NPR
            IF(IABS(IQ(LMUC+IIFMBC)).EQ.I) THEN
               IF(LMB.EQ.0.OR.IQ(LMUC+IIFMBC).LT.0) THEN
                  CALL ROCLRZ('MB')
                  CALL ROCALL('MB')
               END IF
            ELSE IF(IABS(IQ(LMUC+IIFMEC)).EQ.I) THEN
               IF(LME.EQ.0.OR.IQ(LMUC+IIFMEC).LT.0) THEN
                  CALL ROCLRZ('ME')
                  CALL ROCALL('ME')
               END IF
            ELSE IF(IABS(IQ(LMUC+IIFMMC)).EQ.I) THEN
               IF(LMM.EQ.0.OR.IQ(LMUC+IIFMMC).LT.0) THEN
                  CALL ROCLRZ('MM')
                  CALL ROCALL('MM')
               END IF
            END IF
*-- Monitor time and space spent in muon processors.
            IF(IRSTOP.NE.0)                                    GO TO 999
   40    CONTINUE
         CALL ROSUMM(IIFMUC)
+SELF,IF=-ONLINE.
         IF(.NOT.ONLINE)THEN
           IF(IGOEXP.LT.999) CALL ODFIX(IIFMUC)
         END IF
+SELF.
         CALL USBAT(IIFMUC)
         IF(IRSTOP.NE.0)                                       GO TO 999
         CALL ROMONI(1,0)
      END IF
      IF(IDDBAT.GE.1) THEN
         CALL DDRBAT(IIFMUC)
         CALL ROMONI(3,0)
      END IF
      IF(IFDROP.NE.0) THEN
*-- Drop Muon working banks.
         IF(IVMB.GT.0) CALL MBDROP
         IF(IVME.GT.0) CALL MEDROP
         IF(IVMM.GT.0) CALL MMDROP
*-- Get new start values.
         CALL ROMONI(0,1)
      END IF
*
      NPR=IQ(LRCO+IIFFOC)
      IF(NPR.GE.1) THEN
*-- Of course, FD is always special .....
C        IF(LDA.LT.1)                                           GO TO 70
         IF(IFUPDT.EQ.1) THEN
*-- Reset total FDET energy in header.
            CALL VZERO(IUHEAD(IISFE),2)
            CALL VZERO(IQ(LREV+IISFE),2)
         END IF
*-- Call FO processes selected by FORWARD card.
         DO 50 I=1,NPR
            IF(IABS(IQ(LFOC+IIFFDC)).EQ.I) THEN
               IF(LFD.EQ.0.OR.IQ(LFOC+IIFFDC).LT.0) THEN
                  CALL ROCLRZ('FD')
                  CALL ROCALL('FD')
               END IF
            END IF
            IF(IABS(IQ(LFOC+IIFSWC)).EQ.I) THEN
               IF(LSW.EQ.0.OR.IQ(LFOC+IIFSWC).LT.0) THEN
                  CALL ROCLRZ('SW')
                  CALL ROCALL('SW')
               END IF
            END IF
*-- Monitor time and space spent in forward processors.
            IF(IRSTOP.NE.0)                                    GO TO 999
   50    CONTINUE
         CALL ROSUMM(IIFFOC)
+SELF,IF=-ONLINE.
         IF(.NOT.ONLINE)THEN
           IF(IGOEXP.LT.999) CALL ODFIX(IIFFOC)
         END IF
+SELF.
         CALL USBAT(IIFFOC)
         IF(IRSTOP.NE.0)                                       GO TO 999
         CALL ROMONI(1,0)
      END IF
      IF(IDDBAT.GE.1) THEN
         CALL DDRBAT(IIFFOC)
         CALL ROMONI(3,0)
      END IF
      IF(IFDROP.NE.0) THEN
*-- Drop Forward Detector working banks.
         IF(IVFD.GT.0) CALL FDDROP
         IF(IVSW.GT.0) CALL SWDROP
*-- Get new start values.
         CALL ROMONI(0,1)
      END IF
*
*-- Call CA process after all individual detector processing.
      IF(IABS(IQ(LCDC+IIFCAC)).GE.1) THEN
         IF(LCT.EQ.0) THEN
            CHREP = 'No CT bank, cannot call CA at this stage!'
            CALL REPORT('ROPBAT',5,'I')
         ELSE
            CALL ROCLRZ('CA')
            CALL ROCALL('CA')
         END IF
      END IF
      IF(IRSTOP.NE.0)                                          GO TO 999
      IF(IDDBAT.GE.1) THEN
*-- Now fill DD banks from internal array.
         CALL DDRBAT(IIFDDC)
         IF(IRSTOP.NE.0)                                       GO TO 999
         CALL ROMONI(3,0)
+SELF,IF=-ONLINE.
         IF(.NOT.ONLINE)THEN
           IF(IGOEXP.LT.999) CALL ODFIX(IIFDDC)
         END IF
+SELF.
         CALL USBAT(IIFDDC)
         IF(IRSTOP.NE.0)                                       GO TO 999
         CALL ROMONI(1,0)
      END IF
*-- Run DST-only SI-hit association, if requested
      IF (CALLCS) THEN
         IF (.NOT.CALLSI) CALL SIODBU
         CALL CSBAT
         CALL ROMONI(11,0)
      ENDIF
*-- Call ODBAT.
      CALL ROCALL('OD')
      IF(IRSTOP.NE.0)                                          GO TO 999
      CALL ROSUMM(IIFODC)
+SELF,IF=-ONLINE.
      IF(.NOT.ONLINE)THEN
       IF(IGOEXP.LT.999) CALL ODFIX(IIFODC)
      END IF
+SELF.
      CALL USBAT(IIFODC)
      IF(IRSTOP.NE.0)                                          GO TO 999
      IF(ILLBAT.GE.1 .OR. IFUPDT.EQ.1 .AND. CHODSI.NE.' ')
     + CALL ODTOSI(CHODSI,CHODCX,IFAIL)
*-- Fix up the DST
+SELF,IF=-ONLINE.
      IF(.NOT.ONLINE)THEN
       IF(IGOEXP.LT.999) CALL ODFIX(0)
      END IF 
+SELF.
*-- Run lepton pair event selection, if requested
      IF(ILLBAT.GE.1) CALL LLBAT
*-- If ODGNRL block was made, run physics analysis and fill header words
      IF(LODC.GE.1) THEN
         IF(IQ(LODC+IIFODG).NE.0) THEN
            IF(IFUPDT.EQ.1) THEN
               MIGMOV = 0
               CALL ODFBLK('GNRL',0,NIGNRL,IGNRLD,MIGMOV,
     +                              NRGNRL,RGNRLD,MRGMOV)
               IF(MIGMOV.LT.JGNVTX) THEN
                  CHREP = 'Cannot access general DST block!'
                  CALL REPORT('ROPBAT',6,'ERROR')
               ELSE
                  IUHEAD(IINCTR) = IGNRLD(JGNCTR)
                  IUHEAD(IIECAL) = NINT(1000*RGNRLD(JGSECA))
                  IUHEAD(IIHCAL) = NINT(1000*RGNRLD(JGSHCA))
                  IUHEAD(IINMUO) = IGNRLD(JGNMUO)
                  IUHEAD(IINVTX) = IGNRLD(JGNVTX)
                  IUHEAD(IITHRU) = NINT(10000*RGNRLD(JGTHRU))
                  IUHEAD(IICTHR) = NINT(10000*RGNRLD(JGCTHR))
                  IUHEAD(IIMEPX) = NINT(1000*RGNRLD(JGMEPX))
                  IUHEAD(IIMEPY) = NINT(1000*RGNRLD(JGMEPY))
                  IUHEAD(IIMEPZ) = NINT(1000*RGNRLD(JGMEPZ))
                  IUHEAD(IINCT ) = IGNRLD(JGNCT )
                  IUHEAD(IISCT ) = NINT(1000*RGNRLD(JGSCT ))
                  IUHEAD(IINEB ) = IGNRLD(JGNEB )
                  IUHEAD(IISEB ) = NINT(1000*RGNRLD(JGSEB ))
                  IUHEAD(IINEE ) = IGNRLD(JGNEE )
                  IUHEAD(IISEE ) = NINT(1000*RGNRLD(JGSEE ))
                  IUHEAD(IINHT ) = IGNRLD(JGNHBT) + IGNRLD(JGNHET)
                  IUHEAD(IISHT ) = NINT(1000*(RGNRLD(JGSHBT)
     +                                       +RGNRLD(JGSHET)))
                  IUHEAD(IINHPT) = IGNRLD(JGNHPT)
                  IUHEAD(IISHPT) = NINT(1000*RGNRLD(JGSHPT))
                  IUHEAD(IISHS ) = NINT(1000*(RGNRLD(JGSHBS)
     +                                       +RGNRLD(JGSHES)))
                  IUHEAD(IISHPS) = NINT(1000*RGNRLD(JGSHPS))
                  IUHEAD(IISFE ) = NINT(1000*RGNRLD(JGSFE ))
                  IUHEAD(IISFK ) = NINT(1000*RGNRLD(JGSFK ))
*-- Run lepton pair selection, if not already done (needed by ROEVTY)
                  IF(ILLBAT.LT.1) CALL LLBAT
*-- Define the event type.
                  CALL ROEVTY
                  CALL ROMONI(30,0)
               END IF
*-- Copy Header in the data part of REV
               NW = IINVTX-IINCTR+1
               CALL UCOPY(IUHEAD(IINCTR),IQ(LREV+IINCTR),NW)
               NW = IISFK -IITHRU+1
               CALL UCOPY(IUHEAD(IITHRU),IQ(LREV+IITHRU),NW)
            END IF
         END IF
      END IF
*-- Run DST-only vertex analysis, if requested
      IF (CALLCX) THEN
         IF (LCX.GT.0 .AND. IRINTR.EQ.1) THEN
            CALL MZDROP(IXSTOR,LCX,'L')
            LCX = 0
         ENDIF
         CALL CXBAT
         CALL ODVRTX
         CALL ROMONI(9,0)
      ENDIF
      IF (CALLCX .OR. CALLCS) CALL ROSUMM(IIFCDC)
*-- Run lepton pair analysis, if requested
      IF(ILABAT.GE.1.AND.IVLA.GT.0) CALL LABAT
*-- Call LMDST for the luminosity analysis
      IF(IVLM.GT.0) CALL LMDST
*
      IF(ILLBAT.LT.1 .AND. IFUPDT.NE.1 .AND. CHODSI.NE.' ')
     + CALL ODTOSI(CHODSI,CHODCX,IFAIL)
*-- Call DC processor
      IF(IVDC.GT.0) CALL DCBAT
      CALL USBAT(0)
      IF(IRSTOP.NE.0)                                          GO TO 999
      CALL ROMONI(1,0)
                                                                GO TO 80
*
   70 CONTINUE
*-- Run DST-only SI-hit association, if requested
      IF (CALLCS) THEN
         IF (.NOT.CALLSI) CALL SIODBU
         CALL CSBAT
         CALL ROMONI(11,0)
      ENDIF
*-- Run DST-only vertex analysis, if requested
*-- Call ODBAT first.
      CALL ROCALL('OD')
      IF(IRSTOP.NE.0)                                          GO TO 999
      IF (CALLCX) THEN
         IF (LCX.GT.0 .AND. IRINTR.EQ.1) THEN
            CALL MZDROP(IXSTOR,LCX,'L')
            LCX = 0
         ENDIF
         CALL CXBAT
         CALL ODVRTX
         CALL ROMONI(9,0)
      ENDIF
      IF (CALLCX .OR. CALLCS) CALL ROSUMM(IIFCDC)
      CHREP = 'No Raw Data, skip processors needing it'
      CALL REPORT('ROPBAT',7,'W')
      IF(CHODSI.NE.' ')CALL ODTOSI(CHODSI,CHODCX,IFAIL)
+SELF,IF=-ONLINE.
      IF(.NOT.ONLINE)THEN
       IF(IGOEXP.LT.999) CALL ODFIX(0)
      END IF
+SELF.
      CALL USBAT(0)
      IF(IRSTOP.NE.0)                                          GO TO 999
      CALL ROMONI(1,0)
*
   80 CONTINUE
*-- Call plotting routine.
      IF(IVGR.GT.0) CALL GRBAT
*-- Drop CE working banks.
      IF(IFDROP.NE.0.AND.IVCE.GT.0) CALL CEDROP
*
  999 RETURN
      END
+DECK,ROPFIN.
      SUBROUTINE ROPFIN
*.
*...ROPFIN   ROPE Finish routine
*.
*. SEQUENCE: ROBANK CRO RCNTLR ROCPAR CRVER
*. CALLS   : ROFIN GEFIN GRFIN USFIN ODFIN ONFIN CVFIN
*.           JCFIN CZFIN CTFIN CXFIN EXFIN TBFIN PBFIN
*.           EBFIN TEFIN PEFIN EEFIN EMFIN HBFIN HEFIN HPFIN
*.           HMFIN MBFIN MEFIN MMFIN FDFIN DSFIN TTFIN
*.           TRFIN FIFIN SCFIN DXFIN SIFIN CSFIN LLFIN SWFIN
*.           LAFIN GCFIN HIFIN WWFIN FZENDO FZENDI HPDIR HROUT
*.           HREND REPREP
*.           MZEND OCEND MWFIN RCLSIO RCLOSO RCLOSC
*. CALLED  : ZEND
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-87
*. LAST MOD: 17-Jun-96
*.
*. Modification Log.
*. 28-Mar-96 M.Schroder  add GCFIN, HIFIN and WWFIN
*. 28-Mar-96 O.Schaile   Introduce TE process.
*. 10-Aug-94 M.Redmond   Mod to previous mod
*.  9-Aug-94 O.Schaile   Close all input files (DAD+data)
*.  6-May-94 M.Redmond   Use HREND until bug in HRENDC understood
*.  6-May-93 D.Wagner    Avoid blank line when printing dummies (35=>36)
*.  3-Mar-93 O.Schaile   Introduce SW process.
*. 26-Oct-92 O.Schaile   Add 'N' to CALL HROUT(....'NT')
*. 19-Jun-92 D.Lellouch  Call DCFIN
*. 31-Aug-92 C.Hawkes    CALL LMFIN
*. 25-Jun-92 G.Patrick   close output units before inputs
*. 18-Feb-92 C.Hawkes    CALL LAFIN
*. 10-Feb-92 A.Buijs     Print only a summary of the FIN dummies
*.  2-Sep-91 S.Weisz     Call XXFIN only if XX library is loaded
*. 13-Aug-91 T.R.Wyatt   Call HROUT(....'T') and point to //PAWC
*. 13-Apr-91 C.Hawkes    CALL LLFIN
*.  7-Mar-91 S.Weisz     Call RCLOSC to terminate OPCAL.
*. 24-Jan-91 D.Lellouch  New input/output file closing facility.
*. 17-Jan-91 S.Weisz     Introduce DX,SI and CS process.
*. 10-Oct-90 S.Weisz     Call MWFIN, MAW steering routine.
*. 16-Oct-89 S.Weisz     Call SCFIN.
*. 23-Jun-89 S.Weisz     End connection to DAQ.
*. 16-Jun-89 S.Weisz     End trigger and filter processes.
*.  3-May-89 S.Weisz     Comment Histo printing .
*.  5-Apr-89 S.Weisz     Call REPREP in batch mode only.
*. 16-Feb-89 S.Weisz     Close HBOOK RZ file
*. 27-Jun-88 S.Weisz     End OPCAL.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LIOHD,LIODI,LIOHB,ICYCLE,NFIRST
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,CRVER.
+SEQ,ROCPAR.
+SEQ,RECNTL.
+SEQ,RCREP.
*
      CHDUMM=' '
      NCHDUM=1
      IF(IVON.GT.0) CALL ONFIN
      CALL ROFIN
      IF(IVGR.GT.0) CALL GRFIN
      IF(IVTT.GT.0) CALL TTFIN
      IF(IVTR.GT.0) CALL TRFIN
      IF(IVFI.GT.0) CALL FIFIN
      IF(ISCBAT.GT.0) CALL SCFIN
      IF(IVCV.GT.0) CALL CVFIN
      IF(IVJC.GT.0) CALL JCFIN
      IF(IVCZ.GT.0) CALL CZFIN
      IF(IVCT.GT.0) CALL CTFIN
      IF(IVDX.GT.0) CALL DXFIN
      IF(IVCX.GT.0) CALL CXFIN
      IF(IVSI.GT.0) CALL SIFIN
      IF(IVCS.GT.0) CALL CSFIN
      IF(IVTB.GT.0) CALL TBFIN
      IF(IVPB.GT.0) CALL PBFIN
      IF(IVEB.GT.0) CALL EBFIN
      IF(IVPE.GT.0) CALL PEFIN
      IF(IVTE.GT.0) CALL TEFIN
      IF(IVEE.GT.0) CALL EEFIN
      IF(IVEM.GT.0) CALL EMFIN
      IF(IVHB.GT.0) CALL HBFIN
      IF(IVHE.GT.0) CALL HEFIN
      IF(IVHP.GT.0) CALL HPFIN
      IF(IVHM.GT.0) CALL HMFIN
      IF(IVMB.GT.0) CALL MBFIN
      IF(IVME.GT.0) CALL MEFIN
      IF(IVMM.GT.0) CALL MMFIN
      IF(IVFD.GT.0) CALL FDFIN
      IF(IVSW.GT.0) CALL SWFIN
      IF(IVLM.GT.0) CALL LMFIN
      IF(IVCE.GT.0) CALL CEFIN
      IF(IVDD.GT.0) CALL DDFIN
      IF(IVDC.GT.0) CALL DCFIN
      IF(IVOD.GT.0) CALL ODFIN
      IF((IFUPDT.EQ.1.OR.ILLBAT.GE.1).AND.IVLL.GT.0) CALL LLFIN
      IF(ILABAT.GE.1.AND.IVLA.GT.0) CALL LAFIN
      IF(IVGC.GT.0) CALL GCFIN
      IF(IVHI.GT.0) CALL HIFIN
      IF(IVWW.GT.0) CALL WWFIN
      CALL USFIN
*
*-- Print which routines were dummies.
      IF (NCHDUM .GT. 1) THEN
        NFIRST=1
   10   CHREP='Dummies called for '//
     +        CHDUMM(NFIRST:MIN(NFIRST+35,NCHDUM))
        CALL REPORT('ROPFIN',1,'I')
        IF (NFIRST+36 .LT. NCHDUM) THEN
          NFIRST=NFIRST+36
          GOTO 10
        ENDIF
      ENDIF
*-- Close all open output units.
      CALL RCLOSO
*-- Close input unit if still active.
 15   CONTINUE
      LIOHD = LQ(LUTC-LLIOHD)
      LIODI = LQ(LIOHD-LLIODI)
      IF(LIODI.NE.0) THEN
         IF(IQ(LIODI+JACTIV).GE.1) THEN
           CALL RCLSIO(LIODI,.TRUE.)
         ELSE
           CALL MZDROP(IXSTOR,LIODI,'.')
         ENDIF
         GOTO 15
      END IF
*-- End OPCAL and close corresponding files.
      CALL RCLOSC
*-- Print histograms.
C     CALL HPDIR('//PAWC','T')
*-- Output HBOOK RZ file
      LIOHD = LQ(LUTC-LLIOHD)
      IF(LIOHD.GE.1) THEN
         LIOHB = LQ(LIOHD-LLIOHB)
         IF(LIOHB.GE.1) THEN
            CALL HCDIR('//PAWC',' ')
            CALL HCDIR('//HISTO',' ')
            CALL HROUT (0,ICYCLE,'NT')
            CALL HREND ('HISTO')
         END IF
      END IF
*-- Print all REPORT messages in batch mode.
      IF(IRINTR.EQ.0) CALL REPREP('*')
*-- Print ZEBRA statistics.
C     CALL MZEND
*-- Call MAW termination.
+SELF,IF=VAX.
      CALL MWFIN(NSTOP)
+SELF.
*
      RETURN
      END
+DECK,ROPINI.
      SUBROUTINE ROPINI
*.
*...ROPINI   ROPE routine to initialize the processors
*.
*. SEQUENCE: CRO MONITO CRVER
*. CALLS   : RBKTMP RBKSTA REINIT ROINIT RGINIT
*.           GRINIT USINIT ODINIT OCINIT CVINIT JCINIT
*.           CZINIT CTINIT CXINIT EXINIT TBINIT PBINIT
*.           EBINIT TEINIT PEINIT EEINIT EMINIT HBINIT HEINIT
*.           HPINIT HMINIR MBINIT MEINIT MMINIT FDINIT SWINIT
*.           LMINIT DDINIT OUINIT TTINIR TRINIT FIINIT
*.           SCINIT RPRTVS MWINIT LLINIT LAINIT ROCIN HIINIT
*. CALLED  : RCNTLI RCNTLB
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-1987
*. LAST MOD:  1-Oct-96
*.
*. Modification Log.
*.  1-Oct-96 M.Schroder  Add PXINIT.
*. 28-Mar-96 O.Schaile   Introduce TE process.
*.  2-Nov-95 O.Schaile   Call GRINIT after ROINIT
*. 23-Oct-95 O.Schaile   Call ROCHIN, HIINIT
*.  6-May-93 D.Wagner    Avoid blank line when printing dummies (35=>36)
*.  3-Mar-93 O.Schaile   Introduce SW process.
*. 19-Jun-92 D.Lellouch  Call DCINIT
*. 26-Aug-92 C.Hawkes    Call LMINIT
*. 18-Feb-92 C.Hawkes    Call LAINIT
*. 10-Feb-92 A.Buijs     Do REPORT printout only a few times.
*. 03-Sep-91 S.Weisz     Clear ROPE and GR versions.
*. 13-Apr-91 C.Hawkes    Call LLINIT
*. 17-Jan-91 S.Weisz     Introduce DX,SI and CS process.
*. 13-Oct-90 S.Weisz     Call OPINIT
*. 10-Oct-90 S.Weisz     Call MWINIT
*. 16-Oct-89 S.Weisz     Call SCINIT
*.  7-Sep-89 S.Weisz     Call REINIT
*. 23-Jun-89 S.Weisz     Call connection to DAQ initialisation.
*. 16-Apr-89 S.Weisz     Call Trigger and Filter initialisation.
*.  5-Apr-89 S.Weisz     Call RPRTVS only in batch mode.
*. 21-Mar-89 S.Weisz     Call OUINIT,OCINIT.
*.  9-Feb-89 S.Weisz     Call RGINIT
*. 20-Dec-88 S.Weisz     Remove call to GEINIT,BEINIT;
*.                       Calls RBKTMP,RBKSTA.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IVERSN,NFIRST
*
+SEQ,CRO.
+SEQ,CRVER.
+SEQ,RECNTL.
+SEQ,RCREP.
*
      DIMENSION IVERSN(8)
      EQUIVALENCE (IVERSN,IVRO)
*
      NCHDUM=1
      CHDUMM=' '
      CALL VZERO(IVERSN,8)
      CALL RBKTMP
      CALL RBKSTA
*-- Initialize REPORT.
      CALL REINIT
+SELF,IF=VAX.
      CALL MWINIT
+SELF.
*-- This one is to initialize some GEANT commons.
      CALL RGINIT
*-- Now initialize all processes.
      CALL ROINIT
      CALL GRINIT
      CALL ONINIT
      CALL TTINIR
      CALL TRINIT
      CALL FIINIT
      CALL SCINIT
      CALL CVINIT
      CALL JCINIT
      CALL CZINIT
      CALL CTINIT
      CALL DXINIT
      CALL CXINIT
      CALL SIINIT
      CALL CSINIR
      CALL TBINIT
      CALL PBINIT
      CALL EBINIT
      CALL PEINIT
      CALL TEINIT
      CALL EEINIT
      CALL EMINIT
      CALL HBINIT
      CALL HEINIT
      CALL HPINIT
      CALL HMINIR
      CALL MBINIT
      CALL MEINIT
      CALL MMINIT
      CALL FDINIT
      CALL SWINIT
      CALL LMINIT
      CALL CEINIT
      CALL DDINIT
      CALL ODINIT
      CALL LLINIT
      CALL LAINIT
      CALL USINIT
      CALL OUINIT
      CALL OCINIT
      CALL DCINIT
      CALL SUINIT
      CALL OPINIT
      CALL ROCHIN
      CALL IDINIT(' ')
      CALL PXINIT
      CALL BTINIT
      CALL MTINIT
      CALL GCINIT
      CALL HIINIT
      CALL WWINIT
*
      IF(IRINTR.EQ.0) CALL RPRTVS
*
      IF (NCHDUM .GT. 1) THEN
        NFIRST=1
   10   CHREP='Dummies called for '//
     +        CHDUMM(NFIRST:MIN(NFIRST+35,NCHDUM))
        CALL REPORT('ROPINI',1,'I')
        IF (NFIRST+36 .LT. NCHDUM) THEN
          NFIRST=NFIRST+36
          GOTO 10
        ENDIF
      ENDIF
*

*
      RETURN
      END
+DECK,ROPPAK.
      SUBROUTINE ROPPAK
*.
*...ROPPAK   ROPE routine to initialize the CERN Library packages
*.
*. SEQUENCE: ROBANK CRO ROSLNK
*. COMMON  : PAWC CFREAD OCBANK
*. CALLS   : HLIMIT MZEBRA MZSTOR MZDIV MZXREF MZWORK FFINIT FFGET
*.           FFSET FFUSET
*. CALLED  : RCNTLI RCNTLB
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.02
*. CREATED : 18-May-87
*. LAST MOD:  8-Feb-99
*.
*. Modification Log.
*.  8-Mar-99 M.Schroder Change back ZEBRA logging
*.  8-Feb-99 J.Letts    Change ZEBRA logging on SHIFT
*. 21-Apr-97 E.Barberio Set to 12 the maximum number of characters in FFREAD
*.           cards
*. 10-Feb-90  S.Weisz        Addapt to new FFREAD ( call FFUSET)
*. 16-Oct-89  S.Weisz        Modification for OC401.
*.  5-Sep-89  S.Weisz        Rearrange ZEBRA store/division config.
*. 13-Jun-89  S.Weisz        Declare a permanent link in /ROSLNK/.
*. 18-Jan-89  S.Weisz        Declare a permanent link area for
*.                           ROPE master pointers.
*. 20-Dec-88  S.Weisz        Define default working space.
*. 27-Jun-88  S.Weisz        Create division (IXOCD) for OPCAL.
*.  6-Apr-88  S.Weisz        HBOOK4 only; Expand FFREAD memory.
*. 14-Mar-88  S.Weisz        Initialise ZEBRA division.
*. 14-Oct-87  S.Weisz        FFREAD key length set to 8 characters.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      EXTERNAL RFUSER
*
      INTEGER MEMOR,NHMEM,MINCON,MAXCON
      INTEGER IXOCD
      REAL    SPACE
      COMMON/PAWC/MEMOR(2)
      COMMON/CFREAD/SPACE(15000)
      COMMON/OCBANK/IXOCD
*
+SEQ,ROBANK.
+SEQ,ROSLNK.
+SEQ,CRO.
*-- Initialise ZEBRA store.
      CALL MZEBRA(-3)
      CALL MZSTOR(IXSTOR,'/GCBANK/','.',FENDQ,LQ,LR1,WS,
     +            LQ(NZEBRA/3),
     +            LQ(NZEBRA-10))
C      CALL MZLOGL(0,2)
      MINCON=2000
      MAXCON=8*NZEBRA/10
*-- Creates one long range division (reverse) to store ROPE constants.
      CALL MZDIV(IXSTOR,IROCON,'R_CONSTA',MINCON,MAXCON,'LRC')
*-- GOPAL constants are stored there too.
      IXCONS = IROCON
*-- Creates one long range division (reverse) to store ROPE statistics.
      CALL MZDIV(IXSTOR,IROSTA,'R_STATIS',MINCON,MAXCON,'LRC')
*-- Creates OPCAL division (reverse).
      CALL MZDIV(IXSTOR,IXOCD,'R_OPCAL',MINCON,MAXCON,'LR')
*-- The ROPE event structure is in division 2 of the store.
      IRODIV = IXSTOR+2
*-- GOPAL events are stored there too.
      IXDIV  = IRODIV
*-- To gain time we specify to ZEBRA that IRODIV,IROCON,IROSTA and IXOCD
*-- are self contained divisions.
      CALL MZXREF(IRODIV,IXSTOR+22,'C')
C     CALL MZXREF(IXOCD ,IXSTOR+22,'C')
      CALL MZXREF(IROSTA,IXSTOR+22,'C')
      CALL MZXREF(IROCON,IXSTOR+22,'C')
*-- Creates a permanent link area for ROPE master pointers.
      CALL MZLINK(IXSTOR,'/RCLINK/',LREV,LAA,LZZ)
      CALL MZLINK(IXSTOR,'/ROSLNK/',LRSMS,LRSMS,LRSP2)
*-- Define a default work space of 8000 words.
      CALL MZWORK(IXSTOR,WS,WS(8000),0)
*-- Initialise HBOOK.
      NHMEM=MEMOR(1)
      CALL HLIMIT(-NHMEM)
      CALL HCDIR('//PAWC',' ')
*-- Initialise FFREAD.
      CALL FFINIT(15000)
      CALL FFGET('LINP',LRIN )
      CALL FFGET('LOUT',LROUT)
      CALL FFSET('SIZE',12)
      CALL FFUSET(RFUSER)
      RETURN
      END
+DECK,ROPREP.
      SUBROUTINE ROPREP
*.
*...ROPREP Prepare all output files in case of multi-streaming
*.
*. SEQUENCE: ROBANK RCNTRL ROCPAR ROUNIT
*. CALLS   :
*. CALLED  : RIOSET
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER LLIO,I,LUN,LIOHD,LIO
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
*
      LIOHD  = LQ(LUTC-LLIOHD)
      DO 10 I=1,7
      IF(I.EQ.1) THEN
         LLIO   = LLIODO
      ELSE IF(I.EQ.2) THEN
         LLIO   = LLIODC
      ELSE IF(I.EQ.3) THEN
         LLIO   = LLIODP
      ELSE IF(I.EQ.4) THEN
         LLIO   = LLIODD
      ELSE IF(I.EQ.5) THEN
         LLIO   = LLIODS
      ELSE IF(I.EQ.6) THEN
         LLIO   = LLIODG
      ELSE IF(I.EQ.7) THEN
         LLIO   = LLIOOV
      END IF
      LIO    = LQ(LIOHD-LLIO)
      IF(LIO.GT.0) THEN
         LUN    = IQ(LIO+JLUN)
         IF(NCHAOU(LUN).GE.2) IQ(LIO+JDCHOP) = NCHAOU(LUN)
      END IF
   10 CONTINUE
*
      RETURN
      END
+DECK,ROPSET.
      SUBROUTINE ROPSET
*.
*...ROPSET    ROPE routine to initialize the RUN parameters
*.
*. SEQUENCE: CRO RCNTRL CRVER
*. CALLS   : RIOSET RSLSET RBKRCO RFLSET RCASET ROPTPR
*.           GRSETR USSETR ODSETR CVSETR JCSETR CZSETR
*.           CTSETR CXSETR EXSETR TBSETR PBSETR EBSETR
*.           TESETR PESETR EESETR EMSETR HBSETR HESETR HPSETR
*.           HMSETR MBSETR MESETR MMSETR FDSETR DDSETR
*.           OCSETR TTSETR TRSETR FISETR SCSETR ONSETR
*.           DXSETR SISETR CSSETR LLSETR LASETR FDSETR SWSETR LMSETR
*. CALLED  : RCNTLI RCNTLB
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.02
*. CREATED : 18-May-1987
*. LAST MOD  : 17-Jun-96
*.
*. Modification Log.
*. 17-Jun-96 M.Schroder  Calls IDSETR, GCSETR, WWSETR
*. 28-Mar-96 O.Schaile   Introduce TE process.
*. 23-Nov-95 O.Schaile   CALL HISETR
*.  3-Nov-93 O.Schaile   Condition Call to LLSETR on IIFODG
*.  3-Mar-93 O.Schaile   Introduce SW process.
*. 19-Jun-92 D.Lellouch  Call DCSETR
*. 31-Aug-92 C.Hawkes    CALL LMSETR
*. 18-Feb-92 C.Hawkes    CALL LASETR
*. 07-Feb-92 N.K.Watson  Call RCASET with top dir. as argument.
*.  2-Sep-91 S.Weisz     Call XXSETR only if XX library is loaded
*. 13-Apr-91 C.Hawkes    CALL LLSETR
*. 17-Jan-91 S.Weisz     Introduce DX,SI and CS process.
*. 16-Mar-90 S.Weisz     Call ONSETR after IO initialisation.
*. 16-Oct-89 S.Weisz     Call SCSETR.
*. 23-Jun-89 S.Weisz     Set connection with DAQ.
*. 16-Jun-89 S.Weisz     Set trigger and filter processes.
*.  2-May-89 R.W.L.Jones CALL OCSETR to use OC FFREAD cards.
*.  5-Apr-89 S.Weisz     Call ROPTPR only in batch mode.
*. 24-Mar-89 S.Weisz     Call ROPTPR to print event loop.
*.  8-Fev-89 S.Weisz     Call RCASET for calibration constants.
*. 20-Dec-88 S.Weisz     Remove calls to GESETR,BESETR.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,CRVER.
+SEQ,ROBANK.
+SEQ,ROCPAR.
      INTEGER IUPDAG
*
*-- Initialize Input-output streams.
      CALL RIOSET
*-- Initialize event selection.
      CALL RSLSET
*-- Lift 'RCO ' structure if not yet done.
      CALL RBKRCO
*-- Set processing flags.
      CALL RFLSET
*-- Associate database to processors.
*- NKW mods start.
*-- For initialisation purposes, call it with default top dir. name.
      CALL RCASET('MAIN')
*- NKW mods end.
*
      IF(IVOC.GT.0) CALL OCSETR
      IF(IVTT.GT.0) CALL TTSETR
      IF(IVTR.GT.0) CALL TRSETR
      IF(IVFI.GT.0) CALL FISETR
      IF(ISCBAT.GT.0) CALL SCSETR
      IF(IVCV.GT.0) CALL CVSETR
      IF(IVJC.GT.0) CALL JCSETR
      IF(IVCZ.GT.0) CALL CZSETR
      IF(IVCT.GT.0) CALL CTSETR
      IF(IVDX.GT.0) CALL DXSETR
      IF(IVCX.GT.0) CALL CXSETR
      IF(IVSI.GT.0) CALL SISETR
      IF(IVCS.GT.0) CALL CSSETR
      IF(IVTB.GT.0) CALL TBSETR
      IF(IVPB.GT.0) CALL PBSETR
      IF(IVEB.GT.0) CALL EBSETR
      IF(IVTE.GT.0) CALL TESETR
      IF(IVPE.GT.0) CALL PESETR
      IF(IVEE.GT.0) CALL EESETR
      IF(IVEM.GT.0) CALL EMSETR
      IF(IVHB.GT.0) CALL HBSETR
      IF(IVHM.GT.0) CALL HMSETR
      IF(IVHE.GT.0) CALL HESETR
      IF(IVHP.GT.0) CALL HPSETR
      IF(IVMB.GT.0) CALL MBSETR
      IF(IVME.GT.0) CALL MESETR
      IF(IVMM.GT.0) CALL MMSETR
      IF(IVFD.GT.0) CALL FDSETR
      IF(IVSW.GT.0) CALL SWSETR
      IF(IVLM.GT.0) CALL LMSETR
      IF(IVCE.GT.0) CALL CESETR
      IF(IVDD.GT.0) CALL DDSETR
      IF(IVOD.GT.0) CALL ODSETR
      IUPDAG=0
      IF(LODC.NE.0)THEN
         IF(IQ(LODC+IIFODG).NE.0 .AND. IFUPDT.EQ.1)IUPDAG=1
      ENDIF
      IF((IUPDAG.EQ.1.OR.ILLBAT.GE.1).AND.IVLL.GT.0) CALL LLSETR
      IF(IVDC.GT.0) CALL DCSETR
      IF(ILABAT.GE.1.AND.IVLA.GT.0) CALL LASETR
      IF(IVGR.GT.0) CALL GRSETR
      IF(IVID.GT.0) CALL IDSETR
      IF(IVGC.GT.0) CALL GCSETR
      IF(IVHI.GT.0) CALL HISETR
      IF(IVWW.GT.0) CALL WWSETR
      CALL USSETR
*-- Initialize DAQ connection if linked with On-line processor.
      IF(IVON.GT.0) CALL ONSETR
*-- Print Event loop flow in batch mode
      IF(IRINTR.EQ.0) CALL ROPTPR
*
      RETURN
      END
+DECK,ROTRAPA,IF=QMALPH.
      INTEGER FUNCTION ROTRAP(SIGARGS,MECHARGS)
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,CRO.
*
      INTEGER JRDRUN,JRDEVT,NERROR
*.----------------------------------------------------------------------
*--   VAX include files which define useful parameters.
      INCLUDE '($SSDEF)'
      INCLUDE '($MTHDEF)'
      INCLUDE '($FORDEF)'
*--   standard arguments passed to error handlers.
      INTEGER SIGARGS(*), MECHARGS(5),Lib$Match_Cond
*==== PROCEDURE STATEMENTS ====*
      ROTRAP=SS$_RESIGNAL
      IF(LIB$MATCH_COND(SIGARGS(2),SS$_HPARITH).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='High performance arithmetic trap -- default fixup'
         CALL REPORT('ROTRAP',1,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),FOR$_OUTCONERR).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='Output conversion error'
         CALL REPORT('ROTRAP',2,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),MTH$_UNDEXP).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='Undefined exponentiation -- default fixup'
         CALL REPORT('ROTRAP',3,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),MTH$_INVARGMAT).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='Invalid argument to math library -- default fixup'
         CALL REPORT('ROTRAP',4,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),MTH$_LOGZERNEG).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='log of zero or negative value -- default fixup'
         CALL REPORT('ROTRAP',5,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),MTH$_SQUROONEG).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='sqrt of negative value -- default fixup'
         CALL REPORT('ROTRAP',6,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),MTH$_SIGLOSMAT).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='Significance lost in math library-- default fixup'
         CALL REPORT('ROTRAP',7,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),MTH$_FLOOVEMAT).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='Floating overflow in math library -- default fixup'
         CALL REPORT('ROTRAP',8,'E')
      ELSEIF(LIB$MATCH_COND(SIGARGS(2),MTH$_FLOUNDMAT).NE.0) THEN
         ROTRAP=SS$_CONTINUE
         CHREP='Floating underflow in math library -- default fixup'
         CALL REPORT('ROTRAP',9,'E')
      ELSE
         CHREP='Irrecoverable error, I fear'
         CALL REPORT('ROTRAP',99,'E')
      ENDIF
*
      IF(IRDRUN.EQ.JRDRUN .AND. IRDEVT.EQ.JRDEVT) THEN
         NERROR=NERROR+1
         IF(NERROR.GE.1001) THEN
           CHREP='More than 1000 errors fixed up on this event - abort.'
           CALL REPORT('ROTRAP',100,'E')
           CALL QNEXTE
         ENDIF
      ELSE
         JRDEVT=IRDEVT
         JRDRUN=IRDRUN
         NERROR=0
      ENDIF
*
      END
+DECK,ROTRAPOSF,IF=QMVAOS.
      SUBROUTINE ROTRAP(SIGARG)
*.
*...ROTRAP   Handle OSF error conditions
*.           This traps not only floating point and arithmetic exceptions, but
*.           also the SIGTERM signal produced by   KILL pid  and SIGINT
*.           produced by NQS  qdel -k req-id  and  shutdown  commands. If these
*.           signals are sent to the process, ROPE should abort the current
*.           event and stop cleanly with the results of previous events
*.           available.
*.
*. SEQUENCE: RCREP,DECLARE
*. CALLS   : REPORT
*. CALLED  : <SYSTEM>
*.
*. AUTHOR  : A.I.McNab
*. CREATED :  6-Feb-95
*. LAST MOD:  2-Mar-95
*.
*. Modification Log.
*.
*.   2-Mar-95  A.I.McNab  Added SIGINT(2) signal to abort too
*.  14-Feb-95  A.I.McNab  Added SIGTERM(15) signal handling to abort
*.
*.**********************************************************************
*
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,CRO.
*
      INTEGER   SIGARG
      INTEGER   JRDRUN,JRDEVT,NERROR
      SAVE      JRDRUN,JRDEVT,NERROR

      IF     (SIGARG.EQ.8) THEN
       CHREP='Arithmetic or floating point error trapped'
       CALL REPORT('ROTRAP',8,'E')
      ELSEIF (SIGARG.EQ.2) THEN
       CHREP='SIGINT signal received - stop program'
       CALL REPORT('ROTRAP',2,'C')
      ELSEIF (SIGARG.EQ.15) THEN
       CHREP='SIGTERM signal received - stop program'
       CALL REPORT('ROTRAP',15,'C')
      ELSE
       CHREP='Unspecified exception trapped'
       CALL REPORT('ROTRAP',SIGARG,'E')
      ENDIF

      IF(IRDRUN.EQ.JRDRUN .AND. IRDEVT.EQ.JRDEVT) THEN
         NERROR=NERROR+1
         IF(NERROR.GE.1001) THEN
           CHREP='More than 1000 errors fixed up on this event - abort.'
           CALL REPORT('ROTRAP',100,'E')
           CALL QNEXTE
         ENDIF
      ELSE
         JRDEVT=IRDEVT
         JRDRUN=IRDRUN
         NERROR=0
      ENDIF
*
      RETURN
      END
+DECK,ROTRAPV,IF=VAX,IF=-QMALPH. =============================================
      INTEGER FUNCTION ROTRAP(SIGARGS,MECHARGS)
*.----------------------------------------------------------------------
*.-
*.-....   ROTRAP : Top ROPE VAX exception handler.  Calls all other
*--                known ROPE error handlers in turn.  If none can fix
*--                the error, then the error is passed back to the
*--                default error handler.
*.-                VAX ONLY!!!
*.-
*.-   Input    :
*.-   Output   :
*.-   Called   :
*.-   Calls    :
*.-   Seq.     :
*.-
*.-   Author   : Alfred Lee
*.-   Version  : 1.0
*.-   Created  :  5-NOV-1991
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
*.----------------------------------------------------------------------
*--   VAX include files which define useful parameters.
      INCLUDE '($SSDEF)'
*--   standard arguments passed to error handlers.
      INTEGER SIGARGS(*), MECHARGS(5)
*--   local variable which contains the status of handlers;
*--   if the "pass this error to the next error handler" status code
*--   (SS$_RESIGNAL) is returned, then the next one is called.
*--   Otherwise the returned code is returned from this routine.
      INTEGER ISTAT
*--   Known handler routines.  These routines should gracefully handle
*--   errors which they don't know (i.e. return SS$_RESIGNAL).
*--   Handle not-a-number errors (i.e. NANs or reserved operand faults)
      INTEGER RVAFLT
      EXTERNAL RVAFLT
*==== PROCEDURE STATEMENTS ====*
*--   handle the reserved operand floating point exceptions (NANs).
      ISTAT = RVAFLT(SIGARGS,MECHARGS)
      IF (ISTAT.NE.SS$_RESIGNAL) GOTO 900
*--   add other handlers here!!
*--   Jump here is a handler fixes the problem; fall through to here
*--   if none can handle the problem and all give RESIGNAL.
*--   Return last best status as handler status.
  900 CONTINUE
      ROTRAP = ISTAT
  999 RETURN
      END
+DECK,RVAFLT,IF=VAX. ===================================================
      INTEGER FUNCTION RVAFLT(SIGARGS,MECHARGS)
*.----------------------------------------------------------------------
*.-
*.-....   RVAFLT : An error handler to handle not-a-number numbers,
*--                otherwise known as "reserved operand faults".
*--                This changes the not-a-number (NAN) to a zero
*--                (via a run time library routine),
*--                changes the severity of the error from Fatal,
*--                to Warning, and returns the error to default
*--                error handler so that it will print a trace back.
*--                Since the default error handler sees a Warning
*--                instead of a Fatal error, processing continues.
*--                This also calls REPORT; there is a small chance of
*--                danger (infinite loops) in calling REPORT, but
*--                it is worth it.
*.-                VAX ONLY!!!
*.-
*.-
*.-   Input    :
*.-   Output   :
*.-   Called   :
*.-   Calls    :
*.-   Seq.     :
*.-
*.-   Author   : Alfred Lee
*.-   Version  : 1.0
*.-   Created  :  5-NOV-1991
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
*.----------------------------------------------------------------------
*--   declaration of bit functions (MVBITS)
+SEQ,RBITFUNC.
*--   report common block
+SEQ,RCREP.
*--   VAX include files which define useful parameters.
      INCLUDE '($SSDEF)'
*--   standard arguments passed to error handlers; we just pass
*--   them on to LIB$FIXUP_FLT;  if all goes well we change the
*--   status of the error from Fatal to Warning (first three bits
*--   of SIGARGS(2)), and then pass the exception back to the default
*--   handler to generate a trace back. SS$_RESIGNAL does this.
      INTEGER SIGARGS(*), MECHARGS(5)
*--   local variable which contains the status of LIB$FIXUP_FLT;
*--   should return "continue with processing from here" status
*--   (SS$_CONTINUE), which means that the error has been fixed.
*--   If not, return whatever status LIB$FIXUP_FLT gives
*--   as the status of RVAFLT.  For SS$_CONTINUE, we
*--   modify the severity of the error, and return the "pass this
*--   error to the next error handler" status code (SS$_RESIGNAL)
*--   for the status of RVAFLT.  The net effect is that the NAN
*--   is set to 0 (LIB$FIXUP_FLT action), a trace back
*--   warning is printed, and processing continues.
      INTEGER ISTAT
*--   the library routine which actually fixes up the floating point
*--   number by changing it to zero.
      INTEGER LIB$FIXUP_FLT
      EXTERNAL LIB$FIXUP_FLT
*==== PROCEDURE STATEMENTS ====*
      ISTAT = LIB$FIXUP_FLT(SIGARGS,MECHARGS,0.0)
      IF (ISTAT.EQ.SS$_CONTINUE) THEN
         CALL MVBITS(0,0,3,SIGARGS(2),0)
         RVAFLT = SS$_RESIGNAL
         CHREP = 'Not-a-number number (Reserved Operand Fault)'
         CALL REPORT('RVAFLT',1,'ERROR')
      ELSE
         RVAFLT = ISTAT
      END IF
  999 RETURN
      END
+DECK,ROPTPR.
      SUBROUTINE ROPTPR
*.
*...ROPTPR   Print processes selected by FFREAD cards.
*.
*. SEQUENCE: ROBANK ROCPAR RCLINE
*. CALLS   : RMAIL
*. CALLED  : ROPSET
*.
*. BANK U  : RCO CDC ECC HCC MUC FOC ASC ODC
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 24-Mar-89
*. LAST MOD: 29-Apr-96
*.
*. Modification Log.
*. 29-Apr-96 M.Schroder  Make TE process accessible (typo in IIFTEC)
*. 28-Mar-96 O.Schaile   Introduce TE process.
*. 11-Apr-94 M.Redmond   line up printout for ODTOSI
*. 31-Mar-94 O.Schaile   add call to USBAT(IIFODC)
*. 16-Feb-94 M.Redmond   print if CSBAT to be called just before OD
*. 12-Oct-93 O.Schaile   print ODTOSI, CXBAT after OD, check on ICXUSE
*. 2-Jun-93  D.Wagner    Cosmetic changes
*. 11-Mar-93 O.Schaile   print also SW if there
*.  3-Mar-93 O.Schaile   Int. SW process, correct DROP, reorder PROC
*. 11-Oct-92 D.Lellouch  Add calls to DC
*. 20-Feb-92 O.Schaile   add call to USBAT(-1),(-2)
*. 20-Feb-92 C.Hawkes    Introduce LL and LA calls.
*. 16-Apr-91 S.Weisz     Print if Event Type analysis is performed.
*. 21-Jan-91 S.Weisz     Introduce DX,SI and CS calls.
*. 23-Oct-90 S.Weisz     Correct bug in CX printout.
*. 10-Oct-90 S.Weisz     Call CX after CA, special fix for end 1990.
*.  5-Apr-90 S.Weisz     Add calls to DU (DD unpack) and DD.
*. 12-Feb-90 S.Weisz     Treat according to INDROP flag.
*. 16-Oct-89 S.Weisz     Add call to CSBAT.
*. 19-Jun-89 S.Weisz     Add call to TTBAT,TRBAT and FIBAT.
*. 10-May-89 S.Weisz     Add call to USBAT(IIFDAC).
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER NPR,I,NPROC,JPROC
      PARAMETER (NPROC = 35)
      CHARACTER*2   PROC
      CHARACTER*12  DROP
      CHARACTER*8   ARGU
      DIMENSION     PROC(NPROC),DROP(NPROC),ARGU(11)
      SAVE          PROC       ,DROP       ,ARGU
      CHARACTER*8 CPODSI, CPODCX
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,RCLINE.
+SEQ,ROUNIT.
+SEQ,CRVER.
+SEQ,CSCXUS.
+SEQ,CXCNTL.
*
      DATA PROC/'CV','CJ','CZ','CT','DX','CX','SI','CS','CE','CA',
     +          'TB','PB','EB','PE','EE','EM','HB','HE','HP','HM',
     +          'MB','ME','MM','FD','SW','OD','TT','TR','FI','SC',
     +          'DU','DD','LL','LA','TE'/
      DATA DROP/3*'CT,CX,OD.   ','CX,OD.      ',3*'OD.         ',
     +          3*'OD.         ',5*'EM,OD.      ','OD.         ',
     +          3*'HM,OD.      ','OD.         ',2*'MM,OD.      ',
     +          3*'OD.         ',10*'            '/
      DATA ARGU/'IIFDAC  ','IIFCDC  ','IIFECC  ','IIFHCC  ','IIFMUC  ',
     +          'IIFFOC  ','IIFDDC  ','0 (Zero)','-1      ','-2      ',
     +          'IIFODC'/
*
      WRITE(CHLINE,1000)
      CALL RMAIL(1,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1020)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1030)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1040)
      CALL RMAIL(0,0)
      IF(IVDC.GT.0) THEN
        WRITE(CHLINE,1045)
        CALL RMAIL(0,0)
      END IF
      WRITE(CHLINE,1050)
      CALL RMAIL(0,0)
      IF(LNOHEA)THEN
         WRITE(CHLINE,1120) ARGU(9)
         CALL RMAIL(0,0)
      ENDIF
      IF(IDUBAT.GE.1) THEN
         WRITE(CHLINE,1130) PROC(31)
         CALL RMAIL(0,0)
      END IF
*     LMDST
      IF(IVLM.GT.0) THEN
         WRITE(CHLINE,1190)
         CALL RMAIL(0,0)
      END IF
      WRITE(CHLINE,1120) ARGU(10)
      CALL RMAIL(0,0)
*-- Get Trigger and Filter processes.
      IF(ITTBAT.GE.1) THEN
         WRITE(CHLINE,1130) PROC(27)
         CALL RMAIL(0,0)
      END IF
      IF(ITRBAT.GE.1) THEN
         WRITE(CHLINE,1130) PROC(28)
         CALL RMAIL(0,0)
      END IF
      IF(IFIBAT.GE.1) THEN
         WRITE(CHLINE,1130) PROC(29)
         CALL RMAIL(0,0)
      END IF
      IF(ISCBAT.GE.1) THEN
         WRITE(CHLINE,1130) PROC(30)
         CALL RMAIL(0,0)
      END IF
      IF(ITTBAT.GE.1.OR.ITRBAT.GE.1.OR.IFIBAT.GE.1.OR.
     +   ISCBAT.GE.1.OR.IDUBAT.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
      END IF
      WRITE(CHLINE,1120) ARGU(1)
      CALL RMAIL(0,0)
*
      NPR=IQ(LRCO+IIFCDC)
      IF(NPR.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
*-- Get CD processes selected by CENTRAL card.
         DO 10 I=1,NPR
            JPROC = 0
            IF(IABS(IQ(LCDC+IIFCVC)).EQ.I) JPROC = ISIGN(+1,IQ(LCDC
     +      +IIFCVC))
            IF(IABS(IQ(LCDC+IIFCJC)).EQ.I) JPROC = ISIGN(+2,IQ(LCDC
     +      +IIFCJC))
            IF(IABS(IQ(LCDC+IIFCZC)).EQ.I) JPROC = ISIGN(+3,IQ(LCDC
     +      +IIFCZC))
            IF(IABS(IQ(LCDC+IIFCTC)).EQ.I) JPROC = ISIGN(+4,IQ(LCDC
     +      +IIFCTC))
            IF(IABS(IQ(LCDC+IIFDXC)).EQ.I) JPROC = -105
            IF(IABS(IQ(LCDC+IIFCFC)).EQ.I) THEN
               WRITE(CHLINE,1100)
               CALL RMAIL(0,0)
            END IF
            IF(IABS(IQ(LCDC+IIFCXC)).EQ.I .AND.
     +      ICXUSE.NE.0.AND.ICXUSE.NE.4) JPROC = -106
            IF(IABS(IQ(LCDC+IIFSIC)).EQ.I) JPROC = ISIGN(+7,IQ(LCDC
     +      +IIFSIC))
            IF(IABS(IQ(LCDC+IIFCSC)).EQ.I .AND.
     +      ICSUCX.NE.0.AND.ICSUCX.NE.4) JPROC = -108
            IF(IABS(IQ(LCDC+IIFCEC)).EQ.I) JPROC = -109
            IF(JPROC.EQ.0)                                      GO TO 10
            IF(JPROC.GT.0) THEN
               WRITE(CHLINE,1070) PROC(JPROC),PROC(JPROC)
               CALL RMAIL(0,0)
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1080) PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1140) PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            ELSE
               JPROC = -JPROC
               IF(JPROC.LT.100) THEN
                  IF(INDROP.EQ.0) THEN
                     WRITE(CHLINE,1090) PROC(JPROC),PROC(JPROC),
     +                                  DROP(JPROC)
                     CALL RMAIL(0,0)
                  ELSE
                     WRITE(CHLINE,1150) PROC(JPROC),PROC(JPROC)
                     CALL RMAIL(0,0)
                  END IF
               ELSE
                  JPROC = JPROC - 100
                  IF(INDROP.EQ.0) THEN
                     WRITE(CHLINE,1110) PROC(JPROC),DROP(JPROC)
                     CALL RMAIL(0,0)
                  ELSE
                     WRITE(CHLINE,1160) PROC(JPROC)
                     CALL RMAIL(0,0)
                  END IF
               END IF
            END IF
   10    CONTINUE
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1120) ARGU(2)
         CALL RMAIL(0,0)
      END IF
      NPR=IQ(LRCO+IIFECC)
      IF(NPR.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
*-- Get EC processes selected by ECAL card.
         DO 20 I=1,NPR
            JPROC = 0
            IF(IABS(IQ(LECC+IIFTBC)).EQ.I) JPROC = ISIGN(+11,IQ(LECC
     +      +IIFTBC))
            IF(IABS(IQ(LECC+IIFPBC)).EQ.I) JPROC = ISIGN(+12,IQ(LECC
     +      +IIFPBC))
            IF(IABS(IQ(LECC+IIFEBC)).EQ.I) JPROC = ISIGN(+13,IQ(LECC
     +      +IIFEBC))
            IF(IABS(IQ(LECC+IIFTEC)).EQ.I) JPROC = ISIGN(+35,IQ(LECC
     +      +IIFTEC))
            IF(IABS(IQ(LECC+IIFPEC)).EQ.I) JPROC = ISIGN(+14,IQ(LECC
     +      +IIFPEC))
            IF(IABS(IQ(LECC+IIFEEC)).EQ.I) JPROC = ISIGN(+15,IQ(LECC
     +      +IIFEEC))
            IF(IABS(IQ(LECC+IIFEMC)).EQ.I) JPROC = ISIGN(+16,IQ(LECC
     +      +IIFEMC))
            IF(JPROC.EQ.0)                                      GO TO 20
            IF(JPROC.GT.0) THEN
               WRITE(CHLINE,1070) PROC(JPROC),PROC(JPROC)
               CALL RMAIL(0,0)
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1080) PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1140) PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            ELSE
               JPROC = -JPROC
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1090) PROC(JPROC),PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1150) PROC(JPROC),PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            END IF
   20    CONTINUE
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1120) ARGU(3)
         CALL RMAIL(0,0)
      END IF
      NPR=IQ(LRCO+IIFHCC)
      IF(NPR.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
*-- Get HC processes selected by HCAL card.
         DO 30 I=1,NPR
            JPROC = 0
            IF(IABS(IQ(LHCC+IIFHBC)).EQ.I) JPROC = ISIGN(+17,IQ(LHCC
     +      +IIFHBC))
            IF(IABS(IQ(LHCC+IIFHEC)).EQ.I) JPROC = ISIGN(+18,IQ(LHCC
     +      +IIFHEC))
            IF(IABS(IQ(LHCC+IIFHPC)).EQ.I) JPROC = ISIGN(+19,IQ(LHCC
     +      +IIFHPC))
            IF(IABS(IQ(LHCC+IIFHMC)).EQ.I) JPROC = ISIGN(+20,IQ(LHCC
     +      +IIFHMC))
            IF(JPROC.EQ.0)                                      GO TO 30
            IF(JPROC.GT.0) THEN
               WRITE(CHLINE,1070) PROC(JPROC),PROC(JPROC)
               CALL RMAIL(0,0)
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1080) PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1140) PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            ELSE
               JPROC = -JPROC
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1090) PROC(JPROC),PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1150) PROC(JPROC),PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            END IF
   30    CONTINUE
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1120) ARGU(4)
         CALL RMAIL(0,0)
      END IF
      NPR=IQ(LRCO+IIFMUC)
      IF(NPR.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
*-- Get MU processes selected by MUON card.
         DO 40 I=1,NPR
            JPROC = 0
            IF(IABS(IQ(LMUC+IIFMBC)).EQ.I) JPROC = ISIGN(+21,IQ(LMUC
     +      +IIFMBC))
            IF(IABS(IQ(LMUC+IIFMEC)).EQ.I) JPROC = ISIGN(+22,IQ(LMUC
     +      +IIFMEC))
            IF(IABS(IQ(LMUC+IIFMMC)).EQ.I) JPROC = ISIGN(+23,IQ(LMUC
     +      +IIFMEC))
            IF(JPROC.EQ.0)                                      GO TO 40
            IF(JPROC.GT.0) THEN
               WRITE(CHLINE,1070) PROC(JPROC),PROC(JPROC)
               CALL RMAIL(0,0)
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1080) PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1140) PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            ELSE
               JPROC = -JPROC
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1090) PROC(JPROC),PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1150) PROC(JPROC),PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            END IF
   40    CONTINUE
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1120) ARGU(5)
         CALL RMAIL(0,0)
      END IF
      NPR=IQ(LRCO+IIFFOC)
      IF(NPR.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
*-- Get FO processes selected by FORWARD card.
         DO 50 I=1,NPR
            JPROC = 0
            IF(IABS(IQ(LFOC+IIFFDC)).EQ.I) JPROC = ISIGN(+24,IQ(LFOC
     +      +IIFFDC))
            IF(IABS(IQ(LFOC+IIFSWC)).EQ.I) JPROC = ISIGN(+25,IQ(LFOC
     +      +IIFSWC))
            IF(JPROC.EQ.0)                                      GO TO 50
            IF(JPROC.GT.0) THEN
               WRITE(CHLINE,1070) PROC(JPROC),PROC(JPROC)
               CALL RMAIL(0,0)
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1080) PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1140) PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            ELSE
               JPROC = -JPROC
               IF(INDROP.EQ.0) THEN
                  WRITE(CHLINE,1090) PROC(JPROC),PROC(JPROC),DROP(JPROC)
                  CALL RMAIL(0,0)
               ELSE
                  WRITE(CHLINE,1150) PROC(JPROC),PROC(JPROC)
                  CALL RMAIL(0,0)
               END IF
            END IF
   50    CONTINUE
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1120) ARGU(6)
         CALL RMAIL(0,0)
      END IF
*-- Call CA process after all individual detector processing.
      IF(IABS(IQ(LCDC+IIFCAC)).GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         IF(INDROP.EQ.0) THEN
            WRITE(CHLINE,1110) PROC(10),DROP(10)
            CALL RMAIL(0,0)
         ELSE
            WRITE(CHLINE,1160) PROC(10)
            CALL RMAIL(0,0)
         END IF
      END IF
*-- Call DDBAT.
      IF(IDDBAT.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1130) PROC(32)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1120) ARGU(7)
         CALL RMAIL(0,0)
      END IF
*-- Call CSBAT for DST-based SI hit association/track fitting
      IF(IVCS.GT.0 .AND. IQ(LCDC+IIFCSC).NE. 0 .AND.
     +(ICSUCX.EQ.0.OR.ICSUCX.EQ.4)) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         IF (IVSI.EQ.0 .OR. IQ(LCDC+IIFSIC).EQ.0) THEN
           WRITE(CHLINE,1200)
           CALL RMAIL(0,0)
           WRITE(CHLINE,1050)
           CALL RMAIL(0,0)
         ENDIF
         WRITE(CHLINE,1130) PROC(8)
         CALL RMAIL(0,0)
      ENDIF
*-- Call ODBAT.
      WRITE(CHLINE,1050)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1130) PROC(26)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1050)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1120) ARGU(11)
      CALL RMAIL(0,0)
*-- Call ODTOSI.
      IF(IFODSI.GT.0) THEN
         IF(MOD(IFODSI,10).EQ.2)THEN
            CPODSI='Phi, Zed'
         ELSE IF(MOD(IFODSI,10).EQ.1)THEN
            CPODSI='Phi only'
         ENDIF
         IF(IFODSI.GT.10)THEN
            CPODCX=' redo CX'
         ELSE
            CPODCX=' '
         ENDIF
         IF(IFUPDT.EQ.1.OR.ILLBAT.GE.1) THEN
            WRITE(CHLINE,1050)
            CALL RMAIL(0,0)
            WRITE(CHLINE,1180)CPODSI,CPODCX
            CALL RMAIL(0,0)
         END IF
      END IF
*
*-- Call physics analysis code and update header
      IF(IFUPDT.EQ.1.OR.ILLBAT.GE.1.OR.ILABAT.GE.1) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         IF(IFUPDT.EQ.1.OR.ILLBAT.GE.1) THEN
            WRITE(CHLINE,1130) PROC(33)
            CALL RMAIL(0,0)
         END IF
         IF(IFUPDT.EQ.1) THEN
            WRITE(CHLINE,1170)
            CALL RMAIL(0,0)
         END IF
      END IF
*
      IF(IVCX.GT.0 .AND. IQ(LCDC+IIFCXC).NE. 0 .AND.
     +(ICXUSE.EQ.0.OR.ICXUSE.EQ.4)) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1130) PROC(6)
         CALL RMAIL(0,0)
      ENDIF
*     LABAT
      IF(ILABAT.GE.1) THEN
         WRITE(CHLINE,1130) PROC(34)
         CALL RMAIL(0,0)
      END IF
*     LMDST
      IF(IVLM.GT.0) THEN
         WRITE(CHLINE,1190)
         CALL RMAIL(0,0)
      END IF

*-- Call ODTOSI (second case).
      IF(ILLBAT.LT.1 .AND. IFUPDT.NE.1 .AND. IFODSI.GT.0) THEN
         WRITE(CHLINE,1050)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1180)CPODSI,CPODCX
         CALL RMAIL(0,0)
      END IF
      WRITE(CHLINE,1050)
      CALL RMAIL(0,0)
*-- USBAT
      WRITE(CHLINE,1120) ARGU(8)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1050)
      CALL RMAIL(0,0)
      IF(LPACKO) WRITE(CHLINE,1055)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1060)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1000)
      CALL RMAIL(0,0)
*
      RETURN
*
 1000 FORMAT (' ',78('-'))
 1010 FORMAT (' ',5('-'),68X,5('-'))
 1020 FORMAT (' ',5('-'),26X,'ROPE Event loop',27X,5('-'))
 1030 FORMAT (' ',5('-'),26X,'---------------',27X,5('-'))
 1040 FORMAT (' ',5('-'),2X,'|->|',
     +'- Read a new event: call USHEAD for user selection.', 11X,5('-'))
 1045 FORMAT (' ',5('-'),2X,'|->|',
     +'- (unpack the compressed data if necessary)', 19X,5('-'))
 1050 FORMAT (' ',5('-'),2X,'|  |',62X,5('-'))
 1055 FORMAT (' ',5('-'),2X,'|->|',
     +'- Compress the data if necessary', 30X,5('-'))
 1060 FORMAT (' ',5('-'),2X,'|<-|',
     +'- Write event structure to output streams.', 20X,5('-'))
 1070 FORMAT (' ',5('-'),2X,'|  |- ', 'Request ',A2,' results: If ',A2,
     +' bank there, continue;', 13X,5('-'))
 1080 FORMAT (' ',5('-'),2X,'|  |  ', 'Else run ',A2,
     +' processor and drop any banks from ',A12, 2X,5('-'))
 1090 FORMAT (' ',5('-'),2X,'|  |- ', 'Processor ',A2,
     +' forced to run: drop banks from ',A2, ',',A12, 1X,5('-'))
 1100 FORMAT (' ',5('-'),2X,'|  |- ',
     +'Get Fake Tracks banks from MC TREE structure', 16X,5('-'))
 1110 FORMAT (' ',5('-'),2X,'|  |- ', 'Call ',A2,
     +' processor, drop any banks from ',A12, 9X,5('-'))
 1120 FORMAT (' ',5('-'),2X,'|  |- ',
     +'Call user routine USBAT with argument ',A8, 14X,5('-'))
 1130 FORMAT (' ',5('-'),2X,'|  |- ', 'Call ',A2,' processor ', 42X,5(
     +'-'))
 1140 FORMAT (' ',5('-'),2X,'|  |  ', 'Else run ',A2,
     +' processor ', 38X,5('-'))
 1150 FORMAT (' ',5('-'),2X,'|  |- ', 'Processor ',A2,
     +' forced to run: drop banks from ',A2,' if any ', 6X,5('-'))
 1160 FORMAT (' ',5('-'),2X,'|  |- ', 'Call ',A2,
     +' processor ', 42X,5('-'))
 1170 FORMAT (' ',5('-'),2X,'|  |- ',
     +'Perform the Event Type analysis, update header', 14X,5('-'))
 1180 FORMAT (' ',5('-'),2X,'|  |- ',
     +'Call ODTOSI ',2A8, 32X,5('-'))
 1190 FORMAT (' ',5('-'),2X,'|  |- ',
     +'Call LMDST, Luminosity analysis               ', 14X,5('-'))
 1200 FORMAT (' ',5('-'),2X,'|  |- ',
     +'Call SIODBU',49X,5('-'))
      END
+DECK,ROPUNI.
      SUBROUTINE ROPUNI(UNIT)
*.
*...ROPUNI Print a table of potential uses of all logical units
*.
*. CALLS   : RMAIL
*. CALLED  : RCNTLB
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED :  8-Jan-91
*. LAST MOD:  7-Oct-92
*.
*. Modification Log.
*.  7-Oct-92 O.Schaile   remove // from  1000 FORMAT
*. 25-Jan-91 S.Weisz     Use RMAIL.
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER       LU,I,NITEM,UNIT
      PARAMETER    (NITEM=5)
*
+SEQ,ROUNIT.
+SEQ,RCLINE.
*
      WRITE(CHLINE,1000)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      I = 0
      DO 10 LU=1,NROPEU
         IF(I.EQ.0) THEN
            CHLINE        = '* '
            CHLINE(71:72) = ' *'
         END IF
         IF(UNIUSE(LU).NE.' ') THEN
            I = I + 1
            WRITE(CHLINE(14*I-11:14*I),1020) LU,UNIUSE(LU)
         END IF
         IF(I.EQ.NITEM) THEN
            I = 0
            CALL RMAIL(0,0)
         END IF
   10 CONTINUE
*
      IF(I.NE.0) CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
*
      RETURN
1000  FORMAT(9X,'*** Potential use of logical units ***')
1010  FORMAT(72('*'))
1020  FORMAT(I3,':',A)
      END
+DECK,ROSTAT.
      SUBROUTINE ROSTAT(IDETST,ITRGST,INSHFT)
*.
*...ROSTAT   Update detector status words.
*.
*. SEQUENCE: ROBANK CRO ROPAR RBITFUNC
*. CALLS   :
*. CALLED  : ROPBAT
*.
*. BANK U  : REV
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 10-Feb-90
*. LAST MOD: 28-Mar-96
*.
*. Modification Log.
*. 28-Mar-96  O.Schaile     Introduce TE process, IIDET1.
*.  27-Aug-91  S.Weisz      Use RBITFUNC sequence
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER  IDETST,ITRGST,INSHFT,LOCAL,I, IN1
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,RBITFUNC.
*
      IF(INSHFT.LE.31)THEN
         LOCAL = IUHEAD(IIDETS)
         DO 10 I=0,1
         LOCAL = IBCLR(LOCAL,INSHFT+I)
         IF(BTEST(IDETST,I)) LOCAL = IBSET(LOCAL,INSHFT+I)
 10      CONTINUE
         IUHEAD(IIDETS)  = LOCAL
         IF(LREV.GE.1) IQ(LREV+IIDETS) = LOCAL
         LOCAL = IUHEAD(IITRGS)
         DO 20 I=0,1
         LOCAL = IBCLR(LOCAL,INSHFT+I)
         IF(BTEST(ITRGST,I)) LOCAL = IBSET(LOCAL,INSHFT+I)
 20      CONTINUE
         IUHEAD(IITRGS)  = LOCAL
         IF(LREV.GE.1) IQ(LREV+IITRGS) = LOCAL
      ELSE
         LOCAL = IUHEAD(IIDET1)
         IN1=INSHFT-32
         DO 15 I=0,1
         LOCAL = IBCLR(LOCAL,IN1+I)
         IF(BTEST(IIDET1,I)) LOCAL = IBSET(LOCAL,IN1+I)
 15      CONTINUE
         IUHEAD(IIDET1)  = LOCAL
         IF(LREV.GE.1) IQ(LREV+IIDET1) = LOCAL
         LOCAL = IUHEAD(IITRG1)
         DO 25 I=0,1
         LOCAL = IBCLR(LOCAL,IN1+I)
         IF(BTEST(IITRG1,I)) LOCAL = IBSET(LOCAL,IN1+I)
 25      CONTINUE
         IUHEAD(IITRG1)  = LOCAL
         IF(LREV.GE.1) IQ(LREV+IITRG1) = LOCAL
      ENDIF
      RETURN
      END
+DECK,ROSUMF.
      SUBROUTINE ROSUMF
*.
*...ROSUMF prints out the ROPE processor summary.
*.
*. SEQUENCE  : ROBANK RCNTRL ROCPAR ROSPAR RCREP RCLINE ROSLNK
*. CALLS     : REPORT RMAIL
*. CALLED    : ROFIN
*.
*. BANKS U   : UTS RSMS RTIS RSPS RTI2 RSP2
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 13-Mar-88
*. LAST MOD:   28-Mar-96
*.
*. Modification Log.
*. 28-Mar-96  O.Schaile       Introduce TE process.
*. 14-Oct-93  O.Schaile      Modify printout for CE + CA.
*.  3-Mar-93  O.Schaile      Introduce SW process.
*. 16-Apr-91   S.Weisz       Add event type timing.
*. 23-Jan-91   S.Weisz       New DX, SI and CS processors.
*. 23-Oct-90   S.Weisz       Mod to keep statistics for OC and DD.
*. 13-Jun-89   S.Weisz       Add user process, use link area ROSLNK
*.  6-Apr-89   S.Weisz       Protect SQRT's
*. 23-Mar-89   S.Weisz       Add CE and CA statistics
*. 25-Jan-89   S.Weisz       Print time/space needed per processor
*. 27-Apr-88   D.R.Ward      Add MM,FD
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER      NPROC,IOK,NEVT,NUMB,NPR,I
      REAL FRAC,FRACT,FRACS,FRACT2,FRACS2,SIGMAT,SIGMAS, SMTIS,SMSPS
      PARAMETER   (NPROC=27)
      CHARACTER*2  PROC
      CHARACTER*10 UNIT
      DIMENSION    IOK(NPROC),PROC(NPROC),UNIT(NPROC)
      SAVE                    PROC       ,UNIT
*
+SEQ,ROBANK.
+SEQ,ROSLNK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,ROSPAR.
+SEQ,RCLINE.
+SEQ,RCREP.
*
      DATA PROC/'CV','CJ','CZ','CT','DX','CX','SI','CS','CE','CA',
     +          'TB','PB','EB','PE','EE','EM','HB','HE','HP','HM',
     +          'MB','ME','MM','FD','SW','OD','TE'/
      DATA UNIT/5*'Tracks    ',  'Vertices  ',  'Hits      ',
     +          3*'Tracks    ',  'Bars hit  ',9*'Clusters  ',
     +          3*'Segments  ',2*'Clusters  ',  'Banks     ',
     +            'Clusters  '/
*
      IF(LRSMS.LE.0)                                            GO TO 70
*
      NEVT = IQ(LRSMS+1)
      IF(NEVT.LE.0)                                             GO TO 80
      SMTIS = 0
      SMSPS = 0
      CALL VZERO(IOK,NPROC)
*-- Print out summary information.
      WRITE(CHLINE,1010)
      CALL RMAIL(2,0)
      WRITE(CHLINE,1020)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1030)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1040)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1020)
      CALL RMAIL(0,0)
*
      NPR=IQ(LRCO+IIFCDC)
      IF(NPR.GE.1) THEN
*-- Print out for processes selected by CENTRAL card.
         DO 10 I=1,NPR
            IF(IABS(IQ(LCDC+IIFCVC)).EQ.I) IOK(1) = 1
            IF(IABS(IQ(LCDC+IIFCJC)).EQ.I) IOK(2) = 1
            IF(IABS(IQ(LCDC+IIFCZC)).EQ.I) IOK(3) = 1
            IF(IABS(IQ(LCDC+IIFCTC)).EQ.I) IOK(4) = 1
            IF(IABS(IQ(LCDC+IIFDXC)).EQ.I) IOK(5) = 1
            IF(IABS(IQ(LCDC+IIFCXC)).EQ.I) IOK(6) = 1
            IF(IABS(IQ(LCDC+IIFSIC)).EQ.I) IOK(7) = 1
            IF(IABS(IQ(LCDC+IIFCSC)).EQ.I) IOK(8) = 1
            IF(IABS(IQ(LCDC+IIFCEC)).EQ.I) THEN
               IF(LCES.GE.1) IQ(LRSMS+12)  = IQ(LCES+8)
               IOK(9) = 1
            END IF
            IF(IABS(IQ(LCDC+IIFCAC)).EQ.I) THEN
*-- Set it to # tracks CE used, until CA statistics is available!
               IF(LCES.GE.1) IQ(LRSMS+13) = IQ(LCES+1)
               IOK(10) = 1
            END IF
   10    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFECC)
      IF(NPR.GE.1) THEN
*-- Print out for EC processes selected by ECAL card.
         DO 20 I=1,NPR
            IF(IABS(IQ(LECC+IIFTBC)).EQ.I) IOK(11)= 1
            IF(IABS(IQ(LECC+IIFPBC)).EQ.I) IOK(12)= 1
            IF(IABS(IQ(LECC+IIFEBC)).EQ.I) IOK(13)= 1
            IF(IABS(IQ(LECC+IIFTEC)).EQ.I) IOK(27)= 1
            IF(IABS(IQ(LECC+IIFPEC)).EQ.I) IOK(14)= 1
            IF(IABS(IQ(LECC+IIFEEC)).EQ.I) IOK(15)= 1
            IF(IABS(IQ(LECC+IIFEMC)).EQ.I) IOK(16)= 1
   20    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFHCC)
      IF(NPR.GE.1) THEN
*-- Print out for HC processes selected by HCAL card.
         DO 30 I=1,NPR
            IF(IABS(IQ(LHCC+IIFHBC)).EQ.I) IOK(17)= 1
            IF(IABS(IQ(LHCC+IIFHEC)).EQ.I) IOK(18)= 1
            IF(IABS(IQ(LHCC+IIFHPC)).EQ.I) IOK(19)= 1
            IF(IABS(IQ(LHCC+IIFHMC)).EQ.I) IOK(20)= 1
   30    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFMUC)
      IF(NPR.GE.1) THEN
*-- Print out for MU processes selected by MUON card.
         DO 40 I=1,NPR
            IF(IABS(IQ(LMUC+IIFMBC)).EQ.I) IOK(21)= 1
            IF(IABS(IQ(LMUC+IIFMEC)).EQ.I) IOK(22)= 1
            IF(IABS(IQ(LMUC+IIFMMC)).EQ.I) IOK(23)= 1
   40    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFFOC)
      IF(NPR.GE.1) THEN
*-- Print out for FO processes selected by FORWARD card.
         DO 50 I=1,NPR
            IF(IABS(IQ(LFOC+IIFFDC)).EQ.I) IOK(24)= 1
            IF(IABS(IQ(LFOC+IIFSWC)).EQ.I) IOK(25)= 1
   50    CONTINUE
      END IF
      NPR=IQ(LRCO+IIFODC)
*-- Print out for DST process.
      IF(NPR.GE.1) IOK(26)= 1
*-- Loop on selected processes.
      DO 60 I=1,NPROC
         IF(IOK(I).NE.1)                                        GO TO 60
         NUMB = IQ(LRSMS+I+3)
         FRAC = REAL(NUMB)/REAL(NEVT)
         IF(I.NE.9)THEN
            WRITE(CHLINE,1050) PROC(I),NUMB,UNIT(I),FRAC
         ELSE
*           CE processor
            WRITE(CHLINE,1055) PROC(I),NUMB,UNIT(I),FRAC
         ENDIF
         CALL RMAIL(0,0)
         IF(IMONIT.EQ.1) THEN
            SMTIS = SMTIS + Q(LRTIS+I+3)
            FRACT = Q(LRTIS+I+3)/REAL(NEVT)
            SMSPS = SMSPS + Q(LRSPS+I+3)
            FRACS = Q(LRSPS+I+3)/REAL(NEVT)
            WRITE(CHLINE,1060) FRACT,FRACS
            CALL RMAIL(0,0)
            FRACT2= Q(LRTI2+I+3)/REAL(NEVT)
            FRACS2= Q(LRSP2+I+3)/REAL(NEVT)
            SIGMAT=0.
            IF(FRACT2-FRACT**2.GT.0.) SIGMAT=SQRT(FRACT2-FRACT**2)
            SIGMAS=0.
            IF(FRACS2-FRACS**2.GT.0.) SIGMAS=SQRT(FRACS2-FRACS**2)
            WRITE(CHLINE,1070) SIGMAT,SIGMAS
            CALL RMAIL(0,0)
            WRITE(CHLINE,1020)
            CALL RMAIL(0,0)
         END IF
   60 CONTINUE
*
      IF(IMONIT.EQ.1) THEN
         WRITE(CHLINE,1020)
         CALL RMAIL(0,0)
         FRACT = SMTIS/REAL(NEVT)
         FRACS = SMSPS/REAL(NEVT)
         WRITE(CHLINE,1080) FRACT,FRACS
         CALL RMAIL(0,0)
         WRITE(CHLINE,1020)
         CALL RMAIL(0,0)
         FRACT = Q(LRTIS+1)/REAL(NEVT)
         WRITE(CHLINE,1090) FRACT
         CALL RMAIL(0,0)
         WRITE(CHLINE,1020)
         CALL RMAIL(0,0)
         FRACT = Q(LRTIS+2)/REAL(NEVT)
         WRITE(CHLINE,1100) FRACT
         CALL RMAIL(0,0)
         WRITE(CHLINE,1020)
         CALL RMAIL(0,0)
         FRACT = Q(LRTIS+3)/REAL(NEVT)
         WRITE(CHLINE,1110) FRACT
         CALL RMAIL(0,0)
         IF(IFUPDT.EQ.1) THEN
            WRITE(CHLINE,1020)
            CALL RMAIL(0,0)
            FRACT = Q(LRTIS+29)/REAL(NEVT)
            WRITE(CHLINE,1120) FRACT
            CALL RMAIL(0,0)
         END IF
      END IF
*
      WRITE(CHLINE,1020)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,2)
*
                                                                GO TO 80
*
   70 CONTINUE
      WRITE(CHREP,1000)
      CALL REPORT('ROSUMF',1,'E')
*
   80 CONTINUE
*
*
*
      RETURN
 1000 FORMAT ('RSMS bank does not exist')
 1010 FORMAT (' ',78('-'))
 1020 FORMAT (' ',5('-'),68X,5('-'))
 1030 FORMAT (' ',5('-'),21X, 'Monitor of ROPE Processing', 21X,5('-'))
 1040 FORMAT (' ',5('-'),21X, '--------------------------', 21X,5('-'))
 1050 FORMAT (' ',5('-'),5X, A2,' Processor found ',I8,' ',A10,'(',F8.3,
     +' per event)', 5X,5('-'))
 1055 FORMAT (' ',5('-'),5X, A2,'    extrapolated ',I8,' ',A10,'(',F8.3,
     +' per event)', 5X,5('-'))
 1060 FORMAT (' ',5('-'),7X, 'and used on average ',F8.5,' Sec CPU and '
     +,F8.0,' words', 6X,5('-'))
 1070 FORMAT (' ',5('-'),7X, '( with RMS :        ',F8.5,'             '
     +,F8.0,'     )', 6X,5('-'))
 1080 FORMAT (' ',5('-'),2X, ' All processes used ',F8.5,' Sec CPU and '
     +,F8.0,' words', ' per event', 1X,5('-'))
 1090 FORMAT (' ',5('-'),2X, ' The user routine(s) used on average ',F8.
     +5, ' Sec CPU per event', 3X,5('-'))
 1100 FORMAT (' ',5('-'),2X, ' Constants retrieval took on average ',F8.
     +5, ' Sec CPU per event', 3X,5('-'))
 1110 FORMAT (' ',5('-'),2X, ' Data expansion and compression took ',F8.
     +5, ' Sec CPU per event', 3X,5('-'))
 1120 FORMAT (' ',5('-'),2X, '            Event type analysis took ',F8.
     +5, ' Sec CPU per event', 3X,5('-'))
      END
+DECK,ROSUMM.
      SUBROUTINE ROSUMM(ILEVEL)
*.
*...ROSUMM accumulates information for the ROPE summary.
*.
*. INPUT     : ILEVEL   Level of processing.
*.
*. SEQUENCE  : ROBANK ROPAR ROCPAR ROSPAR RCREP ROSLNK MONITO
*. COMMON    :
*. CALLS     : MZBOOK REPORT
*. CALLED    : ROPBAT
*.
*. BANKS M   : RSMS
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.02
*. CREATED   : 13-Mar-88
*.  LAST MOD  :  6-Aug-96
*.
*. Modification Log.
*. 6-Aug-96 E.Barberio   Fix a wrong assumption on a TE bank
*. 28-Mar-96  O.Schaile       Introduce TE process.
*. 16-Feb-94  M.Redmond      Get CS statistics from CS bank
*.  3-Mar-93  O.Schaile      Introduce SW process.
*. 23-Jan-91   S.Weisz       Introduce DX, SI and CS processors.
*. 23-Oct-90   S.Weisz       Mod to keep statistics for OC and DD.
*. 11-Oct-90   S.Weisz       Count number of axial CV tracks.
*.                           Count number of vertices at ILEVEL=0.
*. 22-Mar-90   S.Weisz       Monitor event processing on DN10000.
*. 23-Fev-90   S.Weisz       No. of HM clusters = No. links in HM
*. 13-Jun-89   S.Weisz       Use link area ROSLNK.
*.  5-Apr-89   S.Weisz       Output from FD changed ...
*. 24-Jan-89   S.Weisz       ILEVEL argument to accumulate  before
*.                           dropping working banks in ROPBAT.
*. 28-May-88   S.Weisz       Add MM
*. 25-May-88   D.R.Ward      New CZ data structure (from CZ303)
*. 27-Apr-88   D.R.Ward      Add FD
*. 17-Mar-88   D.R.Ward      Implement more detectors - fix bugs.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER NZBANK
      EXTERNAL NZBANK
      INTEGER NCVT,NCJT,NCZT,NGRP,N,NCTT,NCXV,NCSI,NTBB,NPBC,NEBC,
     +        NPEC,
     +        NEEC,NEMC,NHBC,NHEC,NHPC,NHMC,NMBS,NMES,NMMS,NFDC,NODB,
     +        NSWC,NCCS, NTEC
      INTEGER LCVTT,LCVT,LCJTM,LCZSE,LEEFH,LEMCH,LTBMA,LTBBA, LPBMA,
     +        LPBGC,LPECL,LTECL,LEBFH,LMBTR,LMETR,LMETP, LHBCH,LHECH,
     +        LHPCL,
     +        LFDO,LFDPR,LFDPL,LFKPA, LODHD,LINK,ILEVEL, LSWGC,LTEBA
      INTEGER NCEOLD
      SAVE    NCEOLD
*
+SEQ,ROBANK.
+SEQ,ROSLNK.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROSPAR.
+SEQ,RCREP.
*
      DATA NCEOLD/0/
*
      IF(LRSMS.LE.0)                                            GO TO 30
      IF(ILEVEL.EQ.IIFDAC) THEN
*-- Increments number of events.
         IQ(LRSMS+1)  = IQ(LRSMS+1)  + 1
*-- Accumulate stat. for central detector processes.
      ELSE IF(ILEVEL.EQ.IIFCDC) THEN
         NCVT = 0
         NCJT = 0
         NCZT = 0
         NCTT = 0
         NCXV = 0
         NCSI = 0
         NCCS = 0
*-- Count number of CV final tracks.
         IF(LCV.GT.0) THEN
            LCVTT = LQ(LCV-2)
            IF(LCVTT.GT.0) THEN
               LCVT = LQ(LCVTT-2)
               IF(LCVT.GT.0) THEN
                  NCVT = IQ(LCVT+1)
               END IF
            END IF
         END IF
*-- Count number of CJ tracks.
         IF(LCJ.GT.0) THEN
            LCJTM = LQ(LCJ-4)
            IF(LCJTM.GT.0) THEN
               NCJT = IQ(LCJTM+1)
            END IF
         END IF
*-- Count number of CZ tracks.
         IF(LCZ.GT.0) THEN
            LCZSE = LQ(LCZ-2)
            IF(LCZSE.GT.0) THEN
               NGRP = IQ(LCZSE+4)
               DO 10 N=1,NGRP
                  NCZT = NCZT + IQ(LCZSE+4+N)
   10          CONTINUE
            END IF
         END IF
*-- Count number of CT tracks.
         IF(LCT.GT.0) THEN
            NCTT = IQ(LCT+1)
         END IF
*-- Count number of SI impact.
         IF(LSI.GT.0) THEN
            NCSI   = IQ(LSI+1)
         END IF
*-- Count number of CX vertices.
         IF(LCX.GT.0) THEN
            NCXV = IQ(LCX+1)
         END IF
*-- Count number of CS tracks
         IF (LCS.GT.0) THEN
            NCCS = IQ(LCS+1)
         END IF
*-- Increment counters in bank.
         IQ(LRSMS+4)  = IQ(LRSMS+4)  + NCVT
         IQ(LRSMS+5)  = IQ(LRSMS+5)  + NCJT
         IQ(LRSMS+6)  = IQ(LRSMS+6)  + NCZT
         IQ(LRSMS+7)  = IQ(LRSMS+7)  + NCTT
         IQ(LRSMS+8)  = IQ(LRSMS+8)  + NCTT
         IQ(LRSMS+9)  = IQ(LRSMS+9)  + NCXV
         IQ(LRSMS+10) = IQ(LRSMS+10) + NCSI
         IQ(LRSMS+11) = IQ(LRSMS+11) + NCCS
*
*-- Accumulate stat. for EM Calorimetry processes.
      ELSE IF(ILEVEL.EQ.IIFECC) THEN
         NTBB = 0
         NTEC = 0
         NPBC = 0
         NEBC = 0
         NPEC = 0
         NEEC = 0
         NEMC = 0
*-- Count number of TB bars.
         IF(LEC.GT.0) THEN
            LTBMA = LQ(LEC-1)
            IF(LTBMA.GT.0) THEN
               LTBBA = LQ(LTBMA-1)
               IF(LTBBA.GT.0) THEN
                  NTBB = NZBANK(IXSTOR,LTBBA)
               END IF
            END IF
         END IF
*-- Count number of PB clusters.
         IF(LEC.GT.0) THEN
            LPBMA = LQ(LEC-2)
            IF(LPBMA.GT.0) THEN
               LPBGC = LQ(LPBMA-2)
               IF(LPBGC.GT.0) THEN
                  NPBC = NZBANK(IXSTOR,LPBGC)
               END IF
            END IF
         END IF
*-- Count number of EB fine clusters.
         IF(LEB.GT.0) THEN
            LEBFH = LQ(LEB-4)
            IF(LEBFH.GT.0) THEN
               NEBC =IQ(LEBFH+1)
            END IF
         END IF
*-- Count number of TE clusters.
         IF(LTE.GT.0) THEN
            NTEC = IQ(LTE+1)
         END IF
*-- Count number of PE clusters.
         IF(LPE.GT.0) THEN
            LPECL = LQ(LPE-2)
            IF(LPECL.GT.0) THEN
               NPEC = Q(LPECL+6)
            END IF
         END IF
*-- Count number of EE fine clusters.
         IF(LEE.GT.0) THEN
            LEEFH = LQ(LEE-4)
            IF(LEEFH.GT.0) THEN
               NEEC = Q(LEEFH+1)
            END IF
         END IF
*-- Count number of EM clusters.
         IF(LEC.GT.0) THEN
            LEMCH = LQ(LEC-6)
            IF(LEMCH.GT.0) THEN
               NEMC = IQ(LEMCH-2)
            END IF
         END IF
*-- Increment counters in bank.
         IQ(LRSMS+14) = IQ(LRSMS+14) + NTBB
         IQ(LRSMS+15) = IQ(LRSMS+15) + NPBC
         IQ(LRSMS+16) = IQ(LRSMS+16) + NEBC
         IQ(LRSMS+17) = IQ(LRSMS+30) + NTEC
         IQ(LRSMS+17) = IQ(LRSMS+17) + NPEC
         IQ(LRSMS+18) = IQ(LRSMS+18) + NEEC
         IQ(LRSMS+19) = IQ(LRSMS+19) + NEMC
*-- Accumulate stat. for Hadron Calorimetry processes.
      ELSE IF(ILEVEL.EQ.IIFHCC) THEN
         NHBC = 0
         NHEC = 0
         NHPC = 0
         NHMC = 0
*-- Count number of HB pad clusters.
         IF(LHC.GT.0) THEN
            LHB = LQ(LHC-1)
            IF(LHB.GT.0) THEN
               LHBCH = LQ(LHB-2)
               IF(LHBCH.GT.0) THEN
                  NHBC = IQ(LHBCH+1)
               END IF
            END IF
         END IF
*-- Count number of HE pad clusters.
         IF(LHC.GT.0) THEN
            LHE = LQ(LHC-2)
            IF(LHE.GT.0) THEN
               LHECH = LQ(LHE-2)
               IF(LHECH.GT.0) THEN
                  NHEC = IQ(LHECH+1)
               END IF
            END IF
         END IF
*-- Count number of HP coarse pad clusters.
         IF(LHC.GT.0) THEN
            LHP = LQ(LHC-3)
            IF(LHP.GT.0) THEN
               LHPCL = LQ(LHP-2)
               IF(LHPCL.GT.0) THEN
                  NHPC = Q(LHPCL+1)
               END IF
            END IF
         END IF
*-- Count number of HM pad clusters.
         IF(LHC.GT.0) THEN
            LHM = LQ(LHC-4)
            IF(LHM.GT.0) THEN
               NHMC = IQNL(LHM)
            END IF
         END IF
*-- Increment counters in bank.
         IQ(LRSMS+20) = IQ(LRSMS+20) + NHBC
         IQ(LRSMS+21) = IQ(LRSMS+21) + NHEC
         IQ(LRSMS+22) = IQ(LRSMS+22) + NHPC
         IQ(LRSMS+23) = IQ(LRSMS+23) + NHMC
*-- Accumulate stat. for Muon processes.
      ELSE IF(ILEVEL.EQ.IIFMUC) THEN
         NMBS = 0
         NMES = 0
         NMMS = 0
*-- Count number of MB track segments.
         IF(LMM.GT.0) THEN
            NMBS = IQ(LMM+2)
         ELSE IF(LMU.GT.0) THEN
            LMB = LQ(LMU-1)
            IF(LMB.GT.0) THEN
               LMBTR = LQ(LMB-3)
               IF(LMBTR.GT.0) THEN
                  NMBS = NZBANK(IXSTOR,LMBTR)
               END IF
            END IF
         END IF
*-- Count number of ME track segments.
         IF(LMM.GT.0) THEN
            NMES = IQ(LMM+3)
         ELSE IF(LMU.GT.0) THEN
            LME = LQ(LMU-2)
            IF(LME.GT.0) THEN
               LMETR = LQ(LME-3)
               IF(LMETR.GT.0) THEN
                  LMETP = LQ(LMETR-1)
                  IF(LMETP.GT.0) THEN
                     NMES = IQ(LMETR+1)
                  END IF
               END IF
            END IF
         END IF
*-- Count number of MM track segments.
         IF(LMM.GT.0) THEN
            NMMS = IQ(LMM+1)
         END IF
*-- Increment counters in bank.
         IQ(LRSMS+24) = IQ(LRSMS+24) + NMBS
         IQ(LRSMS+25) = IQ(LRSMS+25) + NMES
         IQ(LRSMS+26) = IQ(LRSMS+26) + NMMS
*-- Accumulate stat. for Forward Detector processes.
      ELSE IF(ILEVEL.EQ.IIFFOC) THEN
         NFDC = 0
         NSWC = 0
*-- Count FD calorimeter clusters.
         LFO = LQ(LREV-8)
         IF(LFO.GT.0) THEN
            LFDO = LQ(LFO-1)
            IF(LFDO.GT.0) THEN
               LFDPR = LQ(LFDO-1)
               IF(LFDPR.GT.0) THEN
                  LFKPA = LQ(LFDPR-5)
                  IF(LFKPA.GT.0) THEN
                     NFDC = NFDC+INT(Q(LFKPA+1))
                  END IF
               END IF
               LFDPL = LQ(LFDO-2)
               IF(LFDPL.GT.0) THEN
                  LFKPA = LQ(LFDPL-5)
                  IF(LFKPA.GT.0) THEN
                     NFDC = NFDC+INT(Q(LFKPA+1))
                  END IF
               END IF
            END IF
*-- Get SW Silicon Tungsten calorimeter clusters.
            LSW = LQ(LFO-LLSW)
            IF(LSW.GT.0) THEN
               LSWGC=LQ(LSW-1)
               IF(LSWGC.GT.0) THEN
                  NSWC = IQ(LSWGC+1)
               END IF
            END IF
         END IF
*-- Increment counters in bank.
         IQ(LRSMS+27) = IQ(LRSMS+27) + NFDC
         IQ(LRSMS+28) = IQ(LRSMS+28) + NSWC
*-- Accumulate stat. for DST process.
      ELSE IF(ILEVEL.EQ.IIFODC) THEN
         NODB = 0
*-- Count number of banks in the OD structure
         LODHD = LQ(LREV-10)
         IF(LODHD.GT.0) THEN
            DO 20 N=1,NSOD
               LINK = LQ(LODHD-N)
               IF(LINK.GT.0) NODB = NODB+NZBANK(IXSTOR,LINK)
   20       CONTINUE
         END IF
*-- Increment counters in bank.
         IQ(LRSMS+29) = IQ(LRSMS+29) + NODB
      END IF
*
                                                               GO TO 999
*
   30 CONTINUE
      WRITE (CHREP,1000)
      CALL REPORT('ROSUMM',1,'E')
*
  999 RETURN
 1000 FORMAT ('UTS bank does not exist')
      END
+DECK,ROTRAPI,IF=ERRECO,IF=IBM.
      SUBROUTINE ROTRAP(IRETCD,IERNO)
*.
*...ROTRAP   Handle IBM error conditions
*.
*. SEQUENCE: RCNTRL
*. CALLS   : REPORT
*. CALLED  : <SYSTEM>
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 13-Sep-88
*. LAST MOD: 12-May-89
*.
*. Modification Log.
*. 12-May-89   S.Weisz   Increment run time error counters.
*. 12-Jan-89   S.Weisz   Stop print out after one pass;
*.                       Will be reset in ROEVNT.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IRETCD,IERNO,IERNOL
      SAVE    IERNOL
*
+SEQ,RCREP.
+SEQ,RCNTRL.
*
      DATA IERNOL/0/
*
      IF(NEVTRP.EQ.0.OR.IERNO.NE.IERNOL) THEN
*-- Write error code.
         WRITE(CHREP,1000) IERNO
         CALL REPORT('ROTRAP',1,'E')
         IERNOL = IERNO
      END IF
*-- Increment Run time error counters.
      NEVTRP = NEVTRP + 1
      NTOTRP = NTOTRP + 1
*
      IRETCD = 0
      RETURN
 1000 FORMAT(' IBM error condition No ',I6)
      END
+DECK,ROTRAPH,IF=ERRECO,IF=HPUX.
      SUBROUTINE ROTRAP(A)
*.
*...ROTRAP   Handle HPUX error conditions
*.
*. SEQUENCE: RCREP,DECLARE
*. CALLS   : REPORT
*. CALLED  : <SYSTEM>
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 29-Nov-91
*. LAST MOD: 29-Nov-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      REAL A
      INTEGER ICODE
      CHREP='Real divide by 0'
      A=0.
      ICODE=1
      GOTO 10

      ENTRY ROTRAO(A)
      CHREP='Real overflow'
      A=1.0E10
      ICODE=2
      GOTO 10

      ENTRY ROTRAU(A)
      CHREP='Real underflow'
      A=0.
      ICODE=3
      GOTO 10

      ENTRY ROTRAX(A)
      ICODE=4
      CHREP='Real inexact'
      GOTO 10

      ENTRY ROTRAI(A)
      CHREP='Illegal real number'
      A=0.
      ICODE=5

10    CONTINUE
      CALL REPORT('ROTRAP',ICODE,'Error')
      RETURN
      END
+DECK,ROTRDDH,IF=ERRECO,IF=HPUX.
      SUBROUTINE ROTRDD(A)
*.
*...ROTRDD   Handle HPUX error conditions for REAL*8 variables
*.
*. SEQUENCE: RCREP,DECLARE
*. CALLS   : REPORT
*. CALLED  : <SYSTEM>
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 22-Jan-96
*. LAST MOD: 22-Apr-97
*.
*. Modification Log.
*. 22-Apr-97 M.Schroder Use proper type for double prec. variables
*. 22-Jan-96 M.Schroder Copy from ROTRAP, change declaration and name
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      DOUBLE PRECISION A
      INTEGER ICODE
      CHREP='Real*8 divide by 0'
      A=0.D0
      ICODE=1
      GOTO 10

      ENTRY ROTRDO(A)
      CHREP='Real*8 overflow'
      A=1.0D40
      ICODE=2
      GOTO 10

      ENTRY ROTRDU(A)
      CHREP='Real*8 underflow'
      A=0.D0
      ICODE=3
      GOTO 10

      ENTRY ROTRDX(A)
      ICODE=4
      CHREP='Real*8 inexact'
      GOTO 10

      ENTRY ROTRDI(A)
      CHREP='Illegal real*8 number'
      A=0.D0
      ICODE=5

10    CONTINUE
      CALL REPORT('ROTRDD',ICODE,'Error')
      RETURN
      END
+DECK,ROTRAPSUN,IF=ERRECO,IF=SUN.
      INTEGER FUNCTION ROTRAP(SIG,CODE,CONTXT)
*.
*...ROTRAP   Handle SUN error conditions
*.
*. SEQUENCE: RCREP,DECLARE
*. CALLS   : REPORT
*. CALLED  : <SYSTEM>
*.
*. AUTHOR  : D.R. Ward
*. VERSION : 1.00
*. CREATED : 6-May-92
*. LAST MOD: 6-May-92
*.
*. Modification Log.
*.
*.**********************************************************************
*
+SEQ,DECLARE.
+SEQ,RCREP.
      CHARACTER*40 OUT
      INTEGER SIG,CODE,CONTXT(5),I,IEEE_FLAGS
*
*     What has happened?
*
      OUT='Unknown'
      IF(LOC(CODE).EQ.208) OUT='Invalid'
      IF(LOC(CODE).EQ.200) OUT='Divide by zero'
      IF(LOC(CODE).EQ.212) OUT='Overflow'
      IF(LOC(CODE).EQ.204) OUT='Underflow'
      IF(LOC(CODE).EQ.196) OUT='Inexact'
*
*     Report the bad news
*
      WRITE(CHREP,'('' IEEE f/p error at PC'',I10,'' :-'')') CONTXT(4)
      CHREP(36:50)=OUT(1:15)
      CALL REPORT('ROTRAP',LOC(CODE),'W')
*
*     And clear it
*
      I=IEEE_FLAGS('CLEAR','EXCEPTION','ALL',OUT)
      ROTRAP=0
*
      END
+DECK,ROTRIG.
      SUBROUTINE ROTRIG(IER)
*.
*...ROTRIG   Read next event
*.
*. SEQUENCE  : ROBANK CRO RCNTRL ROCPAR ROUNIT RCREP
*. COMMON    : ZTELLC
*. CALLS     : RGETDA RONTUP RONREP REPORT ROOPEN RCLOSC ROWOUT ZTELUS
*. CALLED    : ROEVNT
*.
*. BANK U    : IOHD IODI
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.02
*. CREATED   : 18-May-87
*. LAST MOD :   6-Nov-95
*.
*. Modification Log.
*.  5-Nov-95  O.Schaile  add argument (IERR) in ROTRIG
*. 30-Mar-94 T.Smith    Complete change of ONLINE file handling.
*. 28-Jan-93 O.Schaile     Repl ITRYMX NTRYMX(1)
*.  6-Oct-93 T.Smith    Treat BOF and EOF differently (if ONLINE)
*. 20-Aug-93 O.Schaile  Suppress REPORT if no pending d/s
*. 30-Apr-93 T.Smith    ask for IER .EQ. 2
*. 27-Apr-93 O.Schaile  Call JCOPEN (crosser analysis)
*. 27-Apr-93 J.Mildenberger remove CV calibration from ONLINE condition
*. 14-Feb-92 D.Lellouch Introduce a new routine for data managers: USEOF
*. 28-Jan-92 C.Hawkes   Print REPORT summaries online.
*. 18-Apr-91 S.Weisz    Call RONTUP to output Ntuples in On-line mode.
*. 13-Apr-91 S.Weisz    LOCKI,ULOCKI now in RGETDA (Memory option).
*.  7-Mar-91 P.Schenk   Handle switching of OPCAL extract On-line.
*. 18-Fev-91 S.Weisz    Handle reading from memory in On-line case.
*. 23-Jan-91 D.Lellouch Closing input file on user's request and
*.                      one to one cartridge facility.
*. 10-Oct-90 S.Weisz    Call DDUBAT in interactive mode.
*.  7-Jun-90 S.Weisz    Set STOP status.
*. 10-Feb-90 S.Weisz    Jump over ZEBRA EoF.
*. 23-Jun-89 S.Weisz    Add check on LIODI.
*. 25-Jan-89 S.Weisz    No of FZIN trials set by Ffread card READTRY.
*. 10-Jan-89 S.Weisz    Check type of record in RGETDA now.
*. 18-May-88 S.Weisz    Check IRSTOP after RGETDA call.
*. 11-Feb-88 A.Buijs    Slight alterations.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SELF,IF=ONLINE.
      INTEGER ID,MODE
      COMMON/ZTELLC/ID,MODE
+SELF.
*
      INTEGER ITRY,IER,IERX,LUN
      INTEGER LIOHD,LIODI
      CHARACTER*26  CSTATP(15)
+SELF,IF=ONLINE.
      LOGICAL FIRST
      SAVE FIRST
+SELF.
      SAVE          CSTATP
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
+SEQ,RCREP.
+SEQ,JCCLST,IF=ONLINE.
+SEQ,CTUSE.
+SELF,IF=ONLINE.
      DATA FIRST /.TRUE./
+SELF.
*
      DATA CSTATP /                'Start-Of-Run record       ',
     +'End-Of-Run record         ','End-Of-File               ',
     +'End-Of-Data               ','Attempt to read beyond EOD',
     +'No pending data structure ','Block no. out of sequence ',
     +'Bad data                  ','Bad constructs, not FZOUT?',
     +'Read error                ','2 consecutive errors      ',
     +'More than 2 consec. errors',2*'                          ',
     +'File closed by user       '/
*
   10 ITRY = 0
   20 ITRY = ITRY+1
*-- Get a new record from the current input.
*-- Remember that the current input is the first one in the linear chain
      LIOHD = LQ(LUTC-LLIOHD)
      LIODI = LQ(LIOHD-LLIODI)
      IF(LIODI.LE.0) THEN
         CHREP = 'No more input files'
         CALL REPORT('ROTRIG',13,'C')
         NSTOP = 0
                                                               GO TO 999
      END IF
      LUN = IQ(LIODI+JLUN)
      LEOFIN = .FALSE.
*-- Read in a new event.
      CALL RGETDA(LUN,IER)
      IF(IER.EQ.-33)RETURN
      IF(IRSTOP.NE.0)                                          GO TO 999
*-- Close input file on user's request.
      IF(LCLOSI) IER = 15
*
*  This code is executed at the beginning and end of each file,
*  respectively.
*
      IF ( IER .EQ. 1 ) THEN
*-- Do the CV and CJ calibration file opens...
        IF ( KCTCVC .NE. 0 ) CALL CTOCVN
+SELF,IF=ONLINE.
        IF ( KJCOPC .EQ. 1 ) CALL JCOPEN
*-- Open the appropriate calibration database.
        CALL ROCLIN( IERX )
        IF ( IERX .EQ. 1 ) THEN
          IF ( .NOT. FIRST ) THEN
            CALL RCLOSC
          ELSE
            FIRST = .FALSE.
          ENDIF
          CALL ROOPEN('CAL',IERX)
          IF (IERX.EQ.0) THEN
            CHREP= 'Switch of new Calibration extract done.'
            CALL REPORT('ROTRIG',13,'I')
          ELSE
            CHREP = 'Could not open new Calibration extract - stop.'
            CALL REPORT('ROTRIG',14,'E')
            IRSTOP = 2
          ENDIF
        ELSE IF ( IERX .NE. 0 ) THEN
          CHREP = 'Error linking calibration database - stop.'
          CALL REPORT('ROTRIG',15,'E')
          IRSTOP = 2
        ENDIF
      ELSE IF ( IER .EQ. 2 ) THEN
*-- Do the CV and CJ calibration file closes...
        IF ( KCTCVC .NE. 0 ) CALL CTCCVN
        IF ( KJCOPC .EQ. 1 ) CALL JCCLOS
*-- Finish of the REPORT and OPCAL stuff.
        CALL RONREP
        CALL ROENDR( IERX )
        IF ( IERX .NE. 0 ) THEN
          CHREP = 'Error calling ROENDR.'
          CALL REPORT('ROTRIG',15,'E')
          IRSTOP = 2
        ENDIF
+SELF.
      ENDIF
*
      IF(IER.GT.0) THEN
         IERX = IER
         IF(IERX.GT.5) IERX = 5
         WRITE(CHREP,1000) CSTATP(IERX),LUN
         CALL REPORT('ROTRIG',IER,'I')
         IF(IER.GT.3) THEN
*-- ZEBRA  End Of Data is reached. Open the next input file.
            CALL USEOF
*-- If it fails, set the EOD flag and quit.
            CALL ROOPEN('INPUT',IERX)
            IF(IERX.NE.0) THEN
               IRSTOP = 2
                                                               GO TO 999
            END IF
*-- Check if at least one output file want to be switched on input EOF.
            IF(LONEOF) THEN
               LEOFIN = .TRUE.
               CALL ROWOUT
            END IF
         END IF
                                                                GO TO 10
*-- An error occurred. Tally it and try again.
*-- Give up after ITRYMX tries.
      ELSE IF(IER.LT.0) THEN
         IERX = 5-IER
         IF(IERX.GT.12) IERX = 12
         IF(IERX.EQ.6) THEN
*-- No pending data structure can be natural now!
*           WRITE(CHREP,1000) CSTATP(IERX),LUN
*            CALL REPORT('ROTRIG',IERX,'I')
                                                                GO TO 10
         ELSE
            WRITE(CHREP,1000) CSTATP(IERX),LUN
            CALL REPORT('ROTRIG',IERX,'E')
         END IF
         IF(ITRY.LT.NTRYMX(1))                                  GO TO 20
         NSTOP  = 4
         IRSTOP = 2
+SELF,IF=ONLINE.
         ID     = NSTOP
         CALL ZTELUS
+SELF.
                                                               GO TO 999
      END IF
*
  999 IF(IDUBAT.GE.1.AND.IRINTR.EQ.1.AND.IRSTOP.EQ.0) THEN
         CALL RBKREV
         CALL DDUBAT
      END IF
      RETURN
 1000 FORMAT(A,' on unit ',I3)
      END
+DECK,ROVANA.
      SUBROUTINE ROVANA(FNAME,LVARI)
*.
*...ROVANA Analyse a file name or catalog entry and replaces
*.         keywords by values of system known functions
*.         Checks whether the file name depends on the run number,
*.         trigger number or event occurence
*.
*. SEQUENCE: RCNTRL RCSYST ROUNIT RCREP
*. CALLS   : RTRANS LENOCC
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER            INDEX
      CHARACTER*80       FNAME
      LOGICAL            LVARI
+SEQ,RCNTRL.
+SEQ,RCSYST.
+SEQ,ROUNIT.
+SEQ,RCREP.
*
+SELF,IF=VAX.
*-- On a vax, look for string <NODE> or <node> and replace
*-- it by the actual node name
      CALL RTRANS(FNAME,'<node>',CHNODE(1:LCHNOD))
      CALL RTRANS(FNAME,'<NODE>',CHNODE(1:LCHNOD))
+SELF.
      CALL RTRANS(FNAME,'<run>','<RUN>')
      CALL RTRANS(FNAME,'<trig>','<TRIG>')
      CALL RTRANS(FNAME,'<n>','<N>')
      LVARI  = INDEX(FNAME,'<TRIG>').GT.0.OR.INDEX(FNAME,'<N>').GT.0
     +     .OR.INDEX(FNAME,'<RUN>').GT.0
*
      RETURN
      END
+DECK,ROWDAO.
      SUBROUTINE ROWDAO(LIOBNK,IDIV,LENTRY,IEVENT,CHOPT,IOD,NUH,IUH)
*.
*...ROWDAO   Same as FZOUT, but writes to all active units.
*.
*. INPUT     : LIOBNK   top link to first output file description bank
*. INPUT     : IDIV     as IXDIV in FZOUT
*. INPUT     : LENTRY   as in FZOUT
*. INPUT     : IEVENT   as in FZOUT
*. INPUT     : CHOPT    as in FZOUT
*. INPUT     : IOD      as in FZOUT
*. INPUT     : NUH      as in FZOUT
*. INPUT     : IUH      as IUHEAD in FZOUT
*.
*. SEQUENCE  : ROBANK CRO RCNTRL ROPAR ROCPAR RCREP
*. COMMON    : QUEST
*. CALLS     : FZOUT REPORT UHTOC ROOFLX USMARK ROPMRK ROSMRK ROGMRK
*. CALLS     : RCLSIO LOCKO ULOCKO
*. CALLED    : ROWOUT
*.
*. AUTHOR    : A.Buijs,S.Weisz
*. VERSION   : 1.01
*. CREATED   :  7-Apr-1988
*. Last mod  : 22-Feb-95
*.
*. Modification log:
*. 22-Feb-95 G.Duckeck  don't mix up FZLIM IQUEST and DCWRIT problems
*. 15-Sep-94 M.Redmond  Call RDDMRK for packed DDST files in case of
*.                      DC packing failure
*. 16-Aug-94 M.Redmond  Store LIO in (unique) temporary link area
*. 02-Feb-94 D.Lellouch Simplify the call to DCWRIT
*. 14-Sep-93 D.Lellouch Bug fix for normal DD/packed DST stream
*. 24-Aug-93 O.Schaile  Call XXMARK only if non empty d/s
*. 17-Nov-92 D.Lellouch  If data compression fails, save uncompressed
*. 19-Jun-92 D.Lellouch  In case of data compression, calls DCWRIT
*. 27-Aug-91 S.Weisz    Use RBITFUNC sequence
*. 18-Fev-91 S.Weisz    Handle memory option if used Om-line.
*.  8-Jan-91 D.Lellouch The ACTIVE flag is used as an event counter
*.                      0:inactive    1:active and empty    n+1:n events
*. 18-Nov-90 D.Lellouch Handle the case where we were called because
*.                      an eof was detected on input:
*.                      If the volume was staged, copy it to tape.
*.                      If the volume was mounted, detach it
*.                      Do not write the constant record if the
*.                      'nocons' flag was set.
*.                      Can come from an end of file on input stream!
*.                      The file name can be variable
*.                      Can close output file at each event
*. 23-Oct-90 S.Weisz    Handle DDST output stream.
*. 13-Oct-89 S.Weisz    Close output file when successive output.
*. 10-Oct-89 S.Weisz    Mark banks to keep (Done in ROWOURT before).
*. 11-Sep-89 S.Weisz    Add CHOPT parameter (Bank marking facility).
*.  7-Sep-89 S.Weisz    Constant written according to IFCNST flag.
*. 15-Jul-89 S.Weisz    Constant are written on all active streams;
*.                      Events on all active and selected streams.
*.                      Stream expansion on multiple files.
*.  1-Sep-88 S.Weisz    Check if limit set by FZLIMIT is reached.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER       LIO,LIOBNK,IDIV,LENTRY,IEVENT,IOD,NUH,IUH(*),LUN
     +             ,NFIOUT,IKDAT,FLAGS
      INTEGER       LRDTMP
      COMMON /ROTMP1/ LRDTMP(2), LIO
      CHARACTER*(*) CHOPT
      CHARACTER*4   CHID
      LOGICAL       OMITCO,DOIT,ENDIT,NEWEVE,PACKIT
*
      INTEGER IQUEST
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
+SEQ,RBITFUNC.
+SEQ,RCREP.
+SEQ,ODPAR.
+SEQ,ODTPAR.
+SEQ,DCCOM.
*
      CALL MZLINT(IXSTOR,'/ROTMP1/',LRDTMP,LIO,LRDTMP)
      LIO = LIOBNK

   10 IF (LIO.LT.1)                                            GO TO 999
      CALL UHTOC(IQIDH(LIO),4,CHID,4)
*-- Loop over the available files and write out the event. It is
*-- assumed that a selection of banks has been made before. Write
*-- the structure only to units that are active.
*-- What about special flags?
      FLAGS  = IQ(LIO+JFLAGS)
      NEWEVE = .FALSE.
      OMITCO = BTEST(FLAGS,NOCONS)
      PACKIT = BTEST(FLAGS,CPDATA) .AND. LENTRY.EQ.LREV
*-- Do we have to actually write the event?
      DOIT   = .NOT.LEOFIN
*-- Or where we called because of an End Of File on input?
      ENDIT  = BTEST(FLAGS,ONEONE).AND.LEOFIN
      IF(IQ(LIO+JACTIV).GE.1.AND.(DOIT.OR.ENDIT)) THEN
*-- Check that the stream is selected for events structure.
         IF((.NOT.OMITCO.AND.IUHEAD(IIDAT).EQ.105)
     +   .OR.(IQ(LIO+JSELEC).EQ.1).OR.ENDIT) THEN
            IF(DOIT) THEN
               IF(IUHEAD(IIDAT).NE.105 .AND. LENTRY .NE.0) THEN
*-- Let the user marks its favorite banks.
                  IF(CHID.EQ.'IODO') CALL USMARK
*-- Mark banks to be kept on 'PROD' output.
                  IF(CHID.EQ.'IODP') CALL RDPMRK
*-- Mark banks to be kept on 'DST ' output.
                  IF(CHID.EQ.'IODS' .AND. .NOT.PACKIT) CALL RDSMRK
*-- Mark banks to be kept on 'DDST ' output.
                  IF(CHID.EQ.'IODD') CALL RDDMRK
*-- Mark banks to be written on SCAN output.
                  IF(CHID.EQ.'IODG') CALL RDGMRK
*-- Switch tape at each event?
                  NEWEVE = BTEST(FLAGS,ONEEVE)
               END IF
               LUN    = IQ(LIO+JLUN)
*-- Check if memory option on output.
               IF(LMEMOU) CALL LOCKO(IRDRUN,IRDEVT)
               IF(PACKIT) THEN
                 CALL DCWRIT(LUN)
*-- don't mix up FZLIM IQUEST and DCWRIT problems
                 IF(IQUEST(1).NE.0 .AND. IQUEST(1).NE. 1)THEN
                    IQUEST(1) = 0
                    CHREP='compression failed, save it uncompressed'
                    CALL REPORT('ROWDAO',1,'W')
                    IF(DCDD(1).GE.1) THEN
                      CALL RDDMRK
                    ELSE
                      CALL RDSMRK
                    END IF
                    CALL FZOUT(LUN,IDIV,LENTRY,IEVENT,CHOPT,IOD,NUH,IUH)
                 ENDIF
               ELSE
                  CALL FZOUT(LUN,IDIV,LENTRY,IEVENT,CHOPT,IOD,NUH,IUH)
               END IF
               IF(LMEMOU) CALL ULOCKO()
               IF(IQUEST(1).EQ.0.AND.NEWEVE) THEN
                  IQUEST(1) = 1
                  IQ(LIO+JACTIV) = IQ(LIO+JACTIV) + 1
               END IF
            ELSE
               IQUEST(1) = 1
            END IF
            IF(IQUEST(1).EQ.0) THEN
*-- No problem whatsoever
               IQ(LIO+JACTIV) = IQ(LIO+JACTIV) + 1
            ELSE IF(IQUEST(1).EQ.1) THEN
*-- File size limit was reached or file switching
*-- triggered by an end of file on input
               IF(NEWEVE) THEN
                  WRITE(CHREP,1002) LUN
               ELSE IF(DOIT) THEN
                  WRITE(CHREP,1000) LUN
               ELSE
                  WRITE(CHREP,1001) LUN
               END IF
               CALL REPORT('ROWDAO',2,'I')
*-- End that file and deactivate it.
               CALL RCLSIO(LIO,.FALSE.)
*-- Now check if we can continue this stream on another file.
               NFIOUT = IQ(LIO+JDCHOP)
*-- If not a variable name file, loot at the next one
               IF(.NOT.BTEST(FLAGS,VARNAM)) THEN
                  LIO    = LQ(LIO)
                  FLAGS  = IQ(LIO+JFLAGS)
                  IF(NFIOUT.LE.1)                              GO TO 20
               END IF
               IF(LIO.LE.0) THEN
*-- The friendly user wants to continue but did not specify the file!
                  CHREP = 'Did not I tell you that you messed up?'
                  CALL REPORT('ROWDAO',3,'E')
                                                                GO TO 20
               ELSE IF(IQ(LIO+JDCHOP).NE.0
     +            .AND..NOT.BTEST(FLAGS,VARNAM)) THEN
*-- This should not happen but you never know!
                  CHREP = 'Output stream clobbering, I am lost!'
                  CALL REPORT('ROWDAO',4,'E')
                                                                GO TO 20
               ELSE
*-- We might continue this stream on another file.
                  CALL ROOFLX(LIO)
                  IF(IQ(LIO+JACTIV).EQ.0)                       GO TO 20
                  IQ(LIO+JSELEC) = 1
                  IF(.NOT.BTEST(FLAGS,VARNAM))
     +               IQ(LIO+JDCHOP) = NFIOUT - 1
                  IF(LUN.EQ.IQ(LIO+JLUN)) THEN
                     WRITE(CHREP,1011) LUN
                  ELSE
                     WRITE(CHREP,1010) LUN,IQ(LIO+JLUN)
                  END IF
                  CALL REPORT('ROWDAO',5,'I')
*-- Check if we have to write a constant record first.
                  OMITCO = BTEST(FLAGS,NOCONS)
                  IF(CHID.NE.'IODS'.AND.IFCNST.NE.0.AND..NOT.OMITCO)
     +               THEN
*-- Set Record type to 105.
                     IKDAT  = IUHEAD(IIDAT)
                     IUHEAD(IIDAT) = 105
                     LUN    = IQ(LIO+JLUN)
                     CALL FZOUT(LUN,IROCON,LRCO,1,'.',IOHEAD,NUH,IUH)
                     IF(IQUEST(1).EQ.0) THEN
                        IQ(LIO+JACTIV) = IQ(LIO+JACTIV) + 1
                     ELSE
                        WRITE(CHREP,1020)LUN,IQUEST(1)
                        CALL REPORT('ROWDAO',6,'E')
                     END IF
*-- Reset Record type as it was ......
                     IUHEAD(IIDAT) = IKDAT
                  END IF
               END IF
            ELSE
*-- A bad error occured
               WRITE(CHREP,1020)LUN,IQUEST(1)
               CALL REPORT('ROWDAO',7,'E')
            END IF
         END IF
      END IF
      LIO     = LQ(LIO)
                                                                GO TO 10
*
   20 CONTINUE
*-- Here we have to stop the output for the concerned stream.
      WRITE(CHREP,1030) LUN
      CALL REPORT('ROWDAO',8,'I')
                                                                GO TO 10
*
  999 LRDTMP(1) = 0
      RETURN
 1000 FORMAT('Limit set by FZLIMIt reached on unit ',I3)
 1001 FORMAT('EOF on input triggered EOF on output unit ',I3)
 1002 FORMAT('Only one event per file on output unit ',I3)
 1010 FORMAT('Stream outputted to unit ',I3,' now diverted to unit ',I3)
 1011 FORMAT('Stream outputted to unit ',I3,' continued on same unit')
 1020 FORMAT('Error writing output, unit ',I3,' IQUEST(1)=',I8)
 1030 FORMAT('Sorry, stream outputted to unit ',I3,' must be disabled')
      END
+DECK,ROWOUT.
      SUBROUTINE ROWOUT
*.
*...ROWOUT   Write the event record to the various output streams
*.
*. SEQUENCE  : ROBANK CRO RCNTRL ROPAR ROCPAR RCREP
*. CALLS     : ROWDAO JCPACK REPORT ODSWRD ODTOSI MZDROP
*. CALLED    : ROEVNT ZTELUS  ROTRIG
*.
*. AUTHOR    : A.Buijs,S.Weisz
*. VERSION   : 1.01
*. CREATED   : 10-Feb-1988
*. LAST MOD  : 28-May-98
*.
*. DETAILED DESCRIPTION:
*.  Regular output, PROD, SCAN and DST are written here.
*.  Remember that the COPY output was done right after the read.
*.
*. Modification log:
*. 28-May-98 G.W.Wilson  Include pretrigger info in IIPDDF
*. 14-Aug-97 M.Schroder Stop saving the TERA bank (TE packing works)
*. 13-Jul-97 E.Barberio Inhibit DDST and DST writing if ODFIX had been called
*.  4-Aug-96 M.Schroder Save the TERA bank (ROTESV)
*. 11-Jun-96 M.Schroder Disable code to correct bunchlet info
*. 16-Feb-96 M.Schroder Add code to correct bunchlet info
*.  6-Nov-95 M.Schroder Copy the PAM LAYER info into the header
*.  3-Oct-95 M.Schroder Add code to correct SW bunchlet word
*. 18-Nov-93 M.Redmond  Call RODSWP to drop SI-related DST blocks
*. 20-Oct-93 M.Redmond  Move ODTOSI call to before call to ODSWRD
*. 11-Oct-93 O.Schaile  Add 'L' option to MZDROPs
*. 19-Aug-93 M.Redmond  ODTOSI default, Drop extra DST banks with SI
*.  3-Sep-91 S.Weisz    Handle multiple output DAD lists.
*. 25-Mar-91 D.Lellouch Handle output DAD list as well.
*. 18-Nov-90 D.Lellouch In case of EOF on INPUT, do not do useless
*.                         things
*. 23-Oct-90 S.Weisz    Handle 'DDST' file.
*. 16-Oct-90 S.Weisz    Copy overall version number in GNRL block.
*. 10-Oct-90 S.Weisz    Allow writing of header only on DST stream.
*. 24-Mar-90 S.Weisz    Call JCPACK instead of CJPACK (Mod. JC206).
*. 10-Feb-90 S.Weisz    Change version number according to IFUPDT.
*. 10-Oct-89 S.Weisz    Bank marking now done in ROWDAO.
*. 18-Sep-89 S.Weisz    Mark all bank before calling USMARK.
*. 13-Sep-89 S.Weisz    Do not call CJPACK for SCAN stream.
*. 11-Sep-89 S.Weisz    'SCAN' file; Call RDXMRK for various streams.
*.  8-Sep-89 S.Weisz    Do not call CJPACK when called from ZTELUS.
*.  7-Sep-89 S.Weisz    No treatment of constants in interactive mode.
*. 18-Jul-89 S.Weisz    Filling of header words in ROPBAT.
*. 15-Jul-89 S.Weisz    Treatment of constant in interactive mode.
*. 28-Jun-89 S.Weisz    Put total ECAL and HCAL energy in header.
*. 27-Jun-89 S.Weisz    Check output streams.
*. 16-Jun-89 S.Weisz    Copy header in data part of REV.
*. 12-Jun-89 S.Weisz    Fill relevant event header information.
*.                      Implement PROD data stream.
*. 25-May-89 S.Weisz    Switch to new event header.
*. 12-May-89 S.Weisz    Keep REPORT messages on output DATA stream.
*. 10-May-89 S.Weisz    Write production output on DATA stream.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER LSTUPD,IKDAT,LIOHD,LIODO,LIODP,LIODG,LIODS,LIODD,LIOAO,
     +        LODHD,LODGL,LODCT,LODVT,LODAT,IFAIL
*-- Return arguments of ODSWRD
      INTEGER NIMOV,NRMOV
*-- Return argument of FISWBU
      INTEGER ISWBIT
      INTEGER LTRRA, NWTRH
      INTEGER NWCTL, NWDTI, NWPTR
      INTEGER IOFPTR
      INTEGER JNWCTL,JNWDTI,JNWPTR
      PARAMETER (JNWCTL=2,JNWDTI=3,JNWPTR=11)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ODPAR.
+SEQ,RCREP.
+SEQ,ROUNIT.
+SEQ,ODCFIX.
*
*-- Fill some relevant ROPE information in the header.
*-- Event type and event streams still need some thinking.
+SELF,LASTUPD.
      LSTUPD = -1
+SELF.
*-- Check output streams.
      LIOHD = LQ(LUTC-LLIOHD)
      LIODO = LQ(LIOHD-LLIODO)
      LIODP = LQ(LIOHD-LLIODP)
      LIODG = LQ(LIOHD-LLIODG)
      LIODD = LQ(LIOHD-LLIODD)
      LIODS = LQ(LIOHD-LLIODS)
      LIOAO = LQ(LIOHD-LLIOAO)
      IF(LIODO.LE.0.AND.LIODP.LE.0.AND.LIODG.LE.0.AND.LIODD.LE.0.AND.
     +   LIODS.LE.0.AND.LIOAO.LE.0)                            GO TO 999
*-
*-- Drop the extra DST banks with SI hits to save space
      CALL RODSWP
C     save the TERA bank (DA -> GNRL)(temporary solution)
C     IF ( IRDRUN .GT. 7360 ) THEN
C        CALL ROTESV
C     ENDIF
      IF(IFUPDT.EQ.1.AND..NOT.LEOFIN) THEN
*-- Copy the overall version No. in GNRL block.
         CALL ODSWRD('GNRL',1,JGPVER,LSTUPD,NIMOV,0,0.,NRMOV)
         IF(NIMOV.NE.1.OR.NRMOV.NE.0)THEN
            WRITE(CHREP,1000) NIMOV,NRMOV
            CALL REPORT('ROWOUT',1,'E')
         END IF
*-- Write the overall version No.and date/time of last constants upd.
         IUHEAD(IIPVER)  = LSTUPD
         IQ(LREV+IIPVER) = LSTUPD
         IUHEAD(IICDAT)  = ICDATE
         IQ(LREV+IICDAT) = ICDATE
         IUHEAD(IICTIM)  = ICTIME
         IQ(LREV+IICTIM) = ICTIME
*-- update the bunchlet info if FILTER and OPCAL disagreed
*-- in this case the header word had been corrected in ROFBUN/RGETBU
C         IF ( IUHEAD(IIBUN) .NE. IQ (LREV+IIBUN)) THEN
C           IQ(LREV+IIBUN) = IUHEAD(IIBUN)
C           CALL ODSWRD('GNRL',1,JGIBUN,IUHEAD(IIBUN),NIMOV,0,0.,NRMOV)
C           IF(NIMOV.NE.1.OR.NRMOV.NE.0)THEN
C             WRITE(CHREP,1000) NIMOV,NRMOV
C             CALL REPORT('ROWOUT',1,'E')
C           END IF
C         ENDIF
*-- Write the PAM LAYER info into the header
          IF( LDA .GT. 0 ) THEN
            LTRRA = LQ(LDA-15)
            IF( LTRRA .GT. 0 ) THEN
              NWTRH = IQ(LTRRA+1)
              IUHEAD(IIPDDF) = IQ(LTRRA+NWTRH+1)
              IF(IRDEXP.GE.10.AND.IRDEXP.LT.1000)THEN
                 IUHEAD(IIPDDF) = 0
                 CALL SBYT(IQ(LTRRA+NWTRH+1),IUHEAD(IIPDDF),1,16)
* Find pretrigger result word and copy the 10 bits into the
* next 10 bits of this word.
*-- The Central Trigger Logic
                 NWCTL = IQ(LTRRA+JNWCTL)
*-- The DeadTime info
                 NWDTI = IQ(LTRRA+JNWDTI)
* Pretrigger off-set
                 IOFPTR = NWTRH + NWCTL + NWDTI
* Pretrigger word count
                 NWPTR = IQ(LTRRA+JNWPTR)
                 IF(NWTRH.GE.JNWPTR.AND.NWPTR.GT.0)THEN
                    CALL SBYT(IQ(LTRRA+IOFPTR+1),IUHEAD(IIPDDF),17,10)
                 ENDIF
              ENDIF
            ENDIF
          ENDIF
C        this is to update the SW bunchlet header byte which was screwed
C        during most of 1995 running. Correct info is in SW DD block.
         IF( IRDRUN.GE.6000.AND.IRDRUN.LE.6472) THEN
           CALL FISWBU(ISWBIT)
           CALL SBYT(ISWBIT,IUHEAD(IIBUN),9,8)
           IQ(LREV+IIBUN) = IUHEAD(IIBUN)
           CALL ODSWRD('GNRL',1,JGIBUN,IUHEAD(IIBUN),NIMOV,0,0.,NRMOV)
         ENDIF
+SELF.
      END IF
*
*-- Write the SCAN output, if at least one SCAN output is active and
*-- selected.
   10 IF(LIODG.LT.1)                                            GO TO 30
      IF(IQ(LIODG+JSELEC).EQ.1.AND.IQ(LIODG+JACTIV).GE.1)       GO TO 20
      LIODG  = LQ(LIODG)
                                                                GO TO 10
   20 CONTINUE
      CALL ROWDAO(LIODG,IRODIV,LREV,1,'M',IOHEAD,NUHEAD,IUHEAD)
*-- Repack the Jet chamber Raw data for DATA and PROD streams.
*   (unless an eof on input was encountered)
   30 IF(IFBOOK.EQ.1.AND..NOT.LEOFIN) CALL JCPACK('P')
*
      LIOHD  = LQ(LUTC-LLIOHD)
      LIODO  = LQ(LIOHD-LLIODO)
   40 IF(LIODO.LT.1)                                            GO TO 60
      IF(IQ(LIODO+JSELEC).EQ.1.AND.IQ(LIODO+JACTIV).GE.1)       GO TO 50
      LIODO  = LQ(LIODO)
                                                                GO TO 40
   50 CONTINUE
      CALL ROWDAO(LIODO,IRODIV,LREV,1,'M',IOHEAD,NUHEAD,IUHEAD)
*
   60 LIOHD  = LQ(LUTC-LLIOHD)
      LIODP  = LQ(LIOHD-LLIODP)
   70 IF(LIODP.LT.1)                                            GO TO 90
      IF(IQ(LIODP+JSELEC).EQ.1.AND.IQ(LIODP+JACTIV).GE.1)       GO TO 80
      LIODP  = LQ(LIODP)
                                                                GO TO 70
   80 CONTINUE
      CALL ROWDAO(LIODP,IRODIV,LREV,1,'M',IOHEAD,NUHEAD,IUHEAD)
*-- Write the DDST output, if the DDST banks are there, and at least
*-- one DDST output is active and selected.
   90 LIOHD  = LQ(LUTC-LLIOHD)
      LIODD  = LQ(LIOHD-LLIODD)
  100 IF(LIODD.LT.1)                                           GO TO 120
      IF(NAPFIX.GT.0) THEN  
        NOWRIT = 1
        CHREP  = 'ODFIX has been called, CAN NOT WRITE FIXED DATA'        
        CALL REPORT('ROWOUT',3,'C') 
        GO TO 999   
      ENDIF 

      IF(IQ(LIODD+JSELEC).EQ.1.AND.IQ(LIODD+JACTIV).GE.1)      GO TO 110
      LIODD  = LQ(LIODD)
                                                               GO TO 100
*
  110 CONTINUE
*-- change the data type to type 6.
      IKDAT  = IUHEAD(IIDAT)
      IUHEAD(IIDAT)  = 6
      IQ(LREV+IIDAT) = 6
      CALL ROWDAO(LIODD,IRODIV,LREV,1,'M',IOHEAD,NUHEAD,IUHEAD)
      IUHEAD(IIDAT)  = IKDAT
      IQ(LREV+IIDAT) = IKDAT
*-- We can return if it is a constant record.
  120 IF(IUHEAD(IIDAT).GT.10)                                  GO TO 999
*-- Write the DST output, if the DST banks are there, and at least
*-- one DST output is active and selected.
      LIOHD  = LQ(LUTC-LLIOHD)
      LIODS  = LQ(LIOHD-LLIODS)
  130 IF(LIODS.LT.1)                                           GO TO 150
      IF(NAPFIX.GT.0) THEN
        NOWRIT = 1
        CHREP  = 'ODFIX has been called, CAN NOT WRITE FIXED DATA'
        CALL REPORT('ROWOUT',3,'C')
        GO TO 999
      ENDIF 
      IF(IQ(LIODS+JSELEC).EQ.1.AND.IQ(LIODS+JACTIV).GE.1)      GO TO 140
      LIODS  = LQ(LIODS)
                                                               GO TO 130
*
  140 LODHD= LQ(LREV-LLOD)
      IF(LODHD.LT.1) THEN
         CHREP  = 'No valid DST found'
         CALL REPORT('ROWOUT',2,'W')
      END IF
*-- Write out. For now, leave the header and LREV as is, just
*-- change the data type to type 6.
      IKDAT  = IUHEAD(IIDAT)
      IUHEAD(IIDAT)  = 6
      IQ(LREV+IIDAT) = 6
      CALL ROWDAO(LIODS,IRODIV,LREV,1,'M',IOHEAD,NUHEAD,IUHEAD)
      IUHEAD(IIDAT)  = IKDAT
      IQ(LREV+IIDAT) = IKDAT
*
  150 LIOHD  = LQ(LUTC-LLIOHD)
+SELF,IF=VAX,UNIX.
      LIOAO  = LQ(LIOHD-LLIOAO)
  160 IF(LIOAO.LT.1)                                           GO TO 999
*-- Write the DAD list if at least one selected.
      IF(IQ(LIOAO+JSELEC).EQ.1.AND.IQ(LIOAO+JACTIV).GE.1) THEN
*-- Write out DAD event pointer.
         CALL RDADOU(LIOAO)
      END IF
      LIOAO = LQ(LIOAO)
                                                               GO TO 160
+SELF.
*
  999 RETURN
*
 1000 FORMAT(' Error writing to GNRL block: NIMOV=',I3,' NRMOV=',I3)
      END
+DECK,RPRTVS.
      SUBROUTINE RPRTVS
*.
*...RPRTVS   Print version numbers of processes used
*.
*. SEQUENCE: CRO CRVER RCLINE
*. CALLS   : RMAIL
*. CALLED  : ROPINI ROGOKU
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.03
*. CREATED : 18-May-87
*. LAST MOD: 20-Jun-96
*.
*. Modification Log.
*. 20-Jun-96   M.Schroder  Add WW processor, NPRO -> 51 (thanks Nige)
*. 28-Mar-96   O.Schaile   Introduce TE process.
*. 26-Oct-95   M.Schroder  Add HI, GC, SQ
*. 11-Apr-94   M.Redmond   Add CU
*.  3-Mar-93   O.Schaile   Introduce SW process.
*. 11-Oct-92   D.Lellouch  Add DC Processor
*. 04-Feb-92   C.Hawkes    Add ID processor.
*. 30-Aug-91   S.Weisz     Add LA and BT processor.
*. 16-Apr-91   S.Weisz     Add LL processor.
*. 21-Jan-91   S.Weisz     Add DX,SI and CS processors.
*. 12-Oct-90   S.Weisz     Add OP processor versions.
*.  7-Jun-90   S.Weisz     Add SU processor versions.
*. 29-Jul-89   S.Weisz     Add JC processor versions.
*. 16-Jun-89   S.Weisz     Add trigger and filter processor versions.
*. 12-Jun-89   S.Weisz     Print out overall version No. LSTUPD.
*. 21-Mar-89   S.Weisz     Add OPUTIL and OPCAL.
*. 27-Jan-89   S.Weisz     Give extensive information (Version,
*.                         Sub-version,date ..) of libraries used.
*. 07-Dec-87   A.Buijs     Clean up
*. 02-Oct-87   S.Weisz     Use of REPORT facility
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*2 PRONAM
      INTEGER LSTUPD,IVERSN,I,J
*
+SEQ,CRO.
+SEQ,CRVER.
+SEQ,RCLINE.
*
      INTEGER   NPRO
      PARAMETER (NPRO=51)
      DIMENSION PRONAM(NPRO),IVERSN(4,NPRO)
      SAVE      PRONAM
      EQUIVALENCE (IVERSN,IVRO)
      DATA PRONAM/'RO','GR','US','CV','CJ','CZ','CT','CX','CE','TB',
     +            'PB','EB','PE','EE','EM','HB','HE','HP','HM','MB',
     +            'ME','MM','FD','DD','OD','OU','OC','TT','TR','FI',
     +            'ON','JC','SU','OP','DX','SI','CS','LL','LA','BT',
     +            'ID','LM','DC','SW','CU','HI','GC','SQ','PX','TE',
     +            'WW'/
*
+SELF,LASTUPD.
      LSTUPD = -1
+SELF.
      WRITE(CHLINE,1000)
      CALL RMAIL(1,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1020) IVRO,ISVRO
      CALL RMAIL(0,0)
      WRITE(CHLINE,1030) IDACRO,IDAMRO
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1040) LSTUPD
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
*-- Write date and time.
      WRITE(CHLINE,1050) IRTIME,IRDATE
      CALL RMAIL(0,0)
      DO 10 I=2,NPRO
         IF(IVERSN(1,I).EQ.0)                                   GO TO 10
         WRITE(CHLINE,1060) PRONAM(I),(IVERSN(J,I),J=1,4)
         CALL RMAIL(0,0)
   10 CONTINUE
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1000)
      CALL RMAIL(0,1)
*
      RETURN
 1000 FORMAT(' ',78('-'))
 1010 FORMAT(' ',5('-'),68X,5('-'))
 1020 FORMAT(' ',5('-'),18X, 'ROPE Version ',I3,' sub-version ',I3, 18X,
     +5('-'))
 1030 FORMAT(' ',5('-'),5X, ' Library was created on ',I6,
     +', Modifications dated ',I6, 5X,5('-'))
 1040 FORMAT(' ',5('-'),13X, 'The overall ROPE code version is :',I8, 13
     +X,5('-'))
 1050 FORMAT(' ',5('-'),6X, ' It is now ',I4,' on ',I6,
     +', The processors available are:', 6X,5('-'))
 1060 FORMAT(' ',5('-'),5X, A2,I3,'/',I2.2,' ; Library dated ',I6,
     +', Modification dated ',I6, 5X,5('-'))
      END
+DECK,RSCATA.
      SUBROUTINE RSCATA
*.
*...RSCATA Handle *CATALOG FFREAD cards
*.
*. SEQUENCE: RCNTRL ROUNIT ROWORD RCREP
*. CALLS   : ROVANA RFCINI RTRANS ROGTUN
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 20-Mar-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*80 CANAME
      LOGICAL      LVARI
+SEQ,RCNTRL.
+SEQ,RCREP.
+SEQ,ROWORD.
+SEQ,ROUNIT.
*
      IF(LCATAL) THEN
         CHREP  = 'CATALOG has been previously initialised'
         CALL REPORT('RSCATA',1,'E')
                                                               GO TO 998
      END IF
      CANAME = ' '
*-- Watch out! it might be a Cray, packed 8 characters per word
      CALL UHTOC(LCANAM,NBYTEW,CANAME,NAMLEN)
+SELF,IF=VAX.
*-- Default value for catalog name is 'MAW$DBS'
      IF(CANAME.EQ.' ') CANAME='MAW$DBS'
+SELF,IF=UNIX,IF=-IBMRT.
***&&&+SELF,IF=APOLLO,SGI,HPUX.
*-- Default value for catalog name
      IF(CANAME.EQ.' ') CANAME='/u/ws/opal/pro/maw/file.dbs'
+SELF,IF=IBMRT.
*-- Default value for catalog name
      IF(CANAME.EQ.' ') CANAME='home9/fhopal/maw/file.dbs'
+SELF,IF=IBM.
      CALL RTRANS(CANAME,'.',' ')
+SELF.
*-- What about special characters?
      CALL ROVANA(CANAME,LVARI)
      IF(LVARI) THEN
         CHREP  = 'Variable name not allowed for a catalog'
         CALL REPORT('RSCATA',2,'E')
                                                               GO TO 998
      END IF
      IF(LCAUNI.EQ.0) THEN
*-- Default is unit 51.
         CHREP  = 'Read catalog on default unit 51'
         CALL REPORT('RSCATA',3,'I')
         LCAUNI = 51
      END IF
      CALL ROGTUN(LCAUNI,'Catalog')
      IF(LCAUNI.EQ.0)                                          GO TO 998
*-- Call the catalog initialisation routine
      CALL RFCINI(LCAUNI,CANAME)
*-- Everything went OK
      LCATAL  = .TRUE.
                                                               GO TO 999
  998 FFERRO=.TRUE.
  999 LCAUNI    =       0
      CALL VBLANK(LCANAM,NAMLWO)
      RETURN
      END
+DECK,RSELRE.
      SUBROUTINE RSELRE(IOSEL)
*.
*...RSELDA   Select event according to FFREAD cards.
*.
*. OUTPUT    : IOSEL Flag set to 0 to skip the reading of pending data
*.
*. SEQUENCE  : ROBANK ROPAR ROCPAR CRO RCNTRL RCREP
*. CALLS     : MZDROP REPORT
*. CALLED    : RGETDA
*.
*. BANK U    : UTC SLCT SLEV SLRE SLGE
*. BANK D    : SLEV SLRE SLGE
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 18-May-1988
*. LAST MOD  :  8-Nov-95
*.
*. Modification log:
*.  8-Nov-95 O.Schaile split  into RSELRE and RSELDA
*.  4-Oct-95 O.Schaile fix selection on header bits
*. 27-Sep-95 O.Schaile Select on bits in header (EVTY etc) (Label 40!)
*.  7-Jun-90 S.Weisz  Set STOP return code.
*. 11-Oct-89 S.Weisz  Select with *GET card.
*. 17-Sep-89 C.Hawkes Selection on header information.
*. 01-Fev-89 S.Weisz  Modif for interactive version.
*. 12-Jan-89 S.Weisz  Select with *EVENT card too.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IOSEL,LSLCT,LSLEV,LSLRE
*
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
*
      IOSEL = 0
*-- Check if *EVENT card selection to be done.
      IF(IRUFST.LE.0) THEN
   10    CONTINUE
*-- Check if maximum number of events has been reached.
         IF(IREVNT.GT.IRTRIG(2)) THEN
            LSLCT = LQ(LUTC-LLSLCT)
            IF(LSLCT.GE.1.AND.IRINTR.EQ.0) THEN
               LSLRE = LQ(LSLCT-LLSLRE)
               IF(LSLRE.GE.1) THEN
                  IRTRIG(1) = IQ(LSLRE+IREFST)
                  IRTRIG(2) = IQ(LSLRE+IRELST)
                  IRTRIG(3) = IQ(LSLRE+IRESTP)
                  CALL MZDROP(IXSTOR,LSLRE,'.')
                                                                GO TO 10
               END IF
            END IF
            WRITE (CHREP,1000) IRTRIG(2)
            CALL REPORT('RSELRE',1,'I')
            IRSTOP = 2
            NSTOP  = 0
                                                               GO TO 999
         END IF
*-- Check if minimum number of events have been read.
         IF(IREVNT.LT.IRTRIG(1))                               GO TO 999
*-- Check if event is wanted according to TRIGGER card.
         IF(MOD(IREVNT-IRTRIG(1),IRTRIG(3)).NE.0)              GO TO 999
      ELSE
   20    CONTINUE
*-- Check on minimum RUN number.
         IF(IRDRUN.LT.IRUFST)                                  GO TO 999
*-- Check on minimum EVENT number.
         IF(IRDRUN.EQ.IRUFST.AND.IRDEVT.LT.IEVFST)             GO TO 999
*-- Check on maximum RUN number.
         IF(IRDRUN.LT.IRULST)                                   GO TO 30
*-- Check on maximum EVENT number.
         IF(IRDRUN.GT.IRULST.OR.IRDEVT.GT.IEVLST) THEN
*-- Get new selection parameters.
            LSLCT = LQ(LUTC-LLSLCT)
            IF(LSLCT.GE.1.AND.IRINTR.EQ.0) THEN
               LSLEV = LQ(LSLCT-LLSLEV)
               IF(LSLEV.GE.1) THEN
                  IRUFST = IQ(LSLEV+JRUFST)
                  IEVFST = IQ(LSLEV+JEVFST)
                  IRULST = IQ(LSLEV+JRULST)
                  IEVLST = IQ(LSLEV+JEVLST)
                  CALL MZDROP(IXSTOR,LSLEV,'.')
                                                                GO TO 20
               END IF
            END IF
*-- No more events to select.
            CHREP = 'All selected events have been read'
            CALL REPORT('RSELDA',2,'I')
            IRSTOP = 2
            NSTOP  = 0
                                                               GO TO 999
         END IF
      END IF
*
   30 CONTINUE
      IOSEL = 1
 999  CONTINUE
      RETURN
 1000 FORMAT('Events up to #',I8,' have been read')
      END
+DECK,RSELDA.
      SUBROUTINE RSELDA(IOSEL)
*.
*...RSELDA   Select event according to FFREAD cards.
*.
*. OUTPUT    : IOSEL Flag set to 0 to skip the reading of pending data
*.
*. SEQUENCE  : ROBANK ROPAR ROCPAR CRO RCNTRL RCREP
*. CALLS     : MZDROP REPORT
*. CALLED    : RGETDA
*.
*. BANK U    : UTC SLCT SLEV SLRE SLGE
*. BANK D    : SLEV SLRE SLGE
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 18-May-88
*. LAST MOD  : 30-Nov-95
*.
*. Modification log:
*. 30-Nov-95 O.Schaile implement veto
*.  8-Nov-95 O.Schaile move event/run nr selection to RSELRE
*.  4-Oct-95 O.Schaile fix selection on header bits
*. 27-Sep-95 O.Schaile Select on bits in header (EVTY etc) (Label 40!)
*.  7-Jun-90 S.Weisz  Set STOP return code.
*. 11-Oct-89 S.Weisz  Select with *GET card.
*. 17-Sep-89 C.Hawkes Selection on header information.
*. 01-Fev-89 S.Weisz  Modif for interactive version.
*. 12-Jan-89 S.Weisz  Select with *EVENT card too.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IOSEL,LSLCT,LSLGE,I, ITAKE, IVETO
*
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
*
      CALL RSELRE(IOSEL)
      IF(IOSEL.EQ.0 .OR. IFSLON.EQ.0 .OR. IRSTOP.EQ.2)         GO TO 999
*-- Selection based on bits in header words (EVTY, FITY etc)
      IF(MSANYS.GT.0)THEN
         ITAKE=0
         IVETO=0
         DO 35 I=1,10
            IF(MSHDSL(I).NE.0)THEN
*              or - selection
               IOSEL=0
               IF(IAND(MSHDSL(I),IUHEAD(4+I)).NE.0)ITAKE=1
            ENDIF
            IF(MSHDVE(I).NE.0)THEN
*              veto - selection
               IF(IAND(MSHDVE(I),IUHEAD(4+I)).NE.0)THEN
                  IVETO=1
               ENDIF
            ENDIF
35       CONTINUE
         IF(ITAKE.EQ.1)IOSEL=1
         IF(IVETO.EQ.1)IOSEL=0
         GOTO 40
      ENDIF
*-- Apply the event selection cuts specified in COMMON/RCNTRL/
*-- Minimum number of charged tracks
      IF(IUHEAD(IINCTR).LT.NSLCMI) IOSEL=0
*-- Maximum number of charged tracks
      IF(IUHEAD(IINCTR).GT.NSLCMA) IOSEL=0
*****  NOTE:  Energies from header are integers in MeV !!  *****
*-- Minimum energy in electromagnetic calorimeters
      IF(FLOAT(IUHEAD(IIECAL))/1000..LT.ESLEMI) IOSEL=0
*-- Maximum energy in electromagnetic calorimeters
      IF(FLOAT(IUHEAD(IIECAL))/1000..GT.ESLEMA) IOSEL=0
*-- Minimum energy in hadronic calorimeters
      IF(FLOAT(IUHEAD(IIHCAL))/1000..LT.ESLHMI) IOSEL=0
*-- Maximum energy in hadronic calorimeters
      IF(FLOAT(IUHEAD(IIHCAL))/1000..GT.ESLHMA) IOSEL=0
*-- Minimum number of muon segments
      IF(IUHEAD(IINMUO).LT.NSLMMI) IOSEL=0
*-- Maximum number of muon segments
      IF(IUHEAD(IINMUO).GT.NSLMMA) IOSEL=0
*-- Event selection from trigger number and run number
      IF(ISLEVT.GT.0) THEN
         IF(IUHEAD(IIEVT).NE.ISLEVT) IOSEL=0
         IF(IOSEL.NE.0.AND.ISLRUN.GT.0) THEN
            IF(IUHEAD(IIRUN).NE.ISLRUN) IOSEL=0
         ENDIF
*-- If selected event has been found, reset ISLEVT=ISLRUN=0.
         IF(IOSEL.NE.0) THEN
            ISLEVT = 0
            ISLRUN = 0
         ENDIF
      ENDIF
*-- If this event is to be rejected set control pointers for next event
40    CONTINUE
      IF(IOSEL.EQ.0) THEN
         IRTRIG(1) = IREVNT + 1
         IRTRIG(2) = IREVNT + 1
         IRTRIG(3) = 1
      ENDIF
*-- Now do something if an acceptable event has been found.
      IF(IOSEL.EQ.1) THEN
         IF(IRINTR.EQ.1) THEN
*-- Turn off event selection flag in interactive mode.
*   if it is 2 dont reset it
            IF(IFSLON.LE.1)IFSLON = 0
         ELSE
*-- Fetch new Run,Evt No. to find in apprpriate structure.
            LSLCT = LQ(LUTC-LLSLCT)
            IF(LSLCT.GE.1) THEN
               LSLGE = LQ(LSLCT-LLSLGE)
               IF(LSLGE.GE.1) THEN
                  ISLRUN = IQ(LSLGE+IRUGET)
                  ISLEVT = IQ(LSLGE+IEVGET)
                  IRTRIG(1) = IREVNT + 1
                  IRTRIG(2) = IREVNT + 1
                  IRTRIG(3) = 1
                  CALL MZDROP(IXSTOR,LSLGE,'.')
               ELSE
                  IFSLON = 0
                  IRTRIG(1) = IREVNT
                  IRTRIG(2) = IREVNT
                  IRTRIG(3) = 1
                  CHREP = 'This is the last *GET event'
                  CALL REPORT('RSELDA',2,'I')
               END IF
            END IF
         END IF
      END IF
*
  999 RETURN
 1000 FORMAT('Events up to #',I8,' have been read')
      END
+DECK,RSLEVF.
      SUBROUTINE RSLEVF
*.
*...RSLEVF   Set up banks for event selection with *EVENT card
*.
*. SEQUENCES : ROBANK RCNTRL ROCPAR RCREP
*. CALLS     : REPORT VZERO
*. CALLED    : RFUSER
*.
*. BANK U    : SLCT
*. BANK L    : SLEV
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 20-Dec-1988
*. LAST MOD  : 20-Dec-1988
*.
*. Modification log:
*.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER LSLCT,LSLEV
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,RCREP.
*
      LSLCT = LQ(LUTC-LLSLCT)
      IF(LSLCT.LE.0) THEN
         CHREP = 'No selection header bank!'
         CALL REPORT('RSLEVF',1,'W')
                                                               GO TO 999
      END IF
*-- Decode *EVENT cards.
      IF(LEVKEY(1).LE.0) THEN
         CHREP = 'First Run No is mandatory on *EVENT card!'
         CALL REPORT('RSLEVF',2,'W')
                                                               GO TO 999
      END IF
*-- Store the selection parameters in banks.
      LSLEV = LQ(LSLCT-LLSLEV)
      IF(LSLEV.LT.1) THEN
         CALL MZBOOK(IROCON,LSLEV,LSLCT,-LLSLEV,'SLEV',NLSLEV,NSSLEV,
     +   NDSLEV,IOSLEV,0)
      ELSE
         CALL MZBOOK(IROCON,LSLEV,LSLEV,0,'SLEV',NLSLEV,NSSLEV,NDSLEV,
     +   IOSLEV,0)
      END IF
      IQ(LSLEV+JRUFST) = LEVKEY(1)
      IQ(LSLEV+JEVFST) = LEVKEY(2)
      IF(LEVKEY(3).LE.0) THEN
         IQ(LSLEV+JRULST) = LEVKEY(1)
      ELSE
         IQ(LSLEV+JRULST) = LEVKEY(3)
      END IF
      IF(LEVKEY(4).LE.0) THEN
         IQ(LSLEV+JEVLST) = LEVKEY(2)
      ELSE
         IQ(LSLEV+JEVLST) = LEVKEY(4)
      END IF
      CALL VZERO(LEVKEY,4)
*
  999 RETURN
      END
+DECK,RSLGEF.
      SUBROUTINE RSLGEF
*.
*...RSLGEF   Set up banks for event selection with *GET card
*.
*. SEQUENCES : ROBANK RCNTRL ROCPAR RCREP
*. CALLS     : REPORT VZERO
*. CALLED    : RFUSER
*.
*. BANK U    : SLCT
*. BANK L    : SLGE
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 11-Oct-1989
*. LAST MOD  : 11-Oct-1989
*.
*. Modification log:
*.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER LSLCT,LSLGE
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,RCREP.
*
      LSLCT = LQ(LUTC-LLSLCT)
      IF(LSLCT.LE.0) THEN
         CHREP = 'No selection header bank!'
         CALL REPORT('RSLGEF',1,'W')
                                                               GO TO 999
      END IF
*-- Decode *GET cards.
      IF(LGEKEY(1).LE.0) THEN
         CHREP = 'Run No is mandatory on *GET card!'
         CALL REPORT('RSLGEF',2,'W')
                                                               GO TO 999
      END IF
*-- Store the selection parameters in banks.
      LSLGE = LQ(LSLCT-LLSLGE)
      IF(LSLGE.LT.1) THEN
         CALL MZBOOK(IROCON,LSLGE,LSLCT,-LLSLGE,'SLGE',NLSLGE,NSSLGE,
     +   NDSLGE,IOSLGE,0)
      ELSE
*-- Go to the end of the linear chain.
   10    CONTINUE
         IF(LQ(LSLGE).GE.1) THEN
            LSLGE = LQ(LSLGE)
                                                                GO TO 10
         END IF
         CALL MZBOOK(IROCON,LSLGE,LSLGE,0,'SLGE',NLSLGE,NSSLGE,NDSLGE,
     +   IOSLGE,0)
      END IF
      IQ(LSLGE+IRUGET) = LGEKEY(1)
      IQ(LSLGE+IEVGET) = LGEKEY(2)
      CALL VZERO(LGEKEY,2)
*
  999 RETURN
      END
+DECK,RSLREF.
      SUBROUTINE RSLREF
*.
*...RSLREF   Set up banks for various event selection
*.
*. SEQUENCES : ROBANK RCNTRL ROCPAR RCREP
*. CALLS     : REPORT VZERO
*. CALLED    : RFUSER
*.
*. BANK U    : SLCT
*. BANK L    : SLRE
*.
*. AUTHOR    : S.Weisz
*. VERSION   : 1.01
*. CREATED   : 20-Dec-1988
*. LAST MOD  : 20-Dec-1988
*.
*. Modification log:
*.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER LSLCT,LSLRE
*
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,RCREP.
*
      LSLCT = LQ(LUTC-LLSLCT)
      IF(LSLCT.LE.0) THEN
         CHREP = 'No selection header bank!'
         CALL REPORT('RSLREF',1,'W')
                                                               GO TO 999
      END IF
*-- Decode *READ cards.
*-- Store the selection parameters in banks.
      LSLRE = LQ(LSLCT-LLSLRE)
      IF(LSLRE.LT.1) THEN
         CALL MZBOOK(IROCON,LSLRE,LSLCT,-LLSLRE,'SLRE',NLSLRE,NSSLRE,
     +   NDSLRE,IOSLRE,0)
      ELSE
         CALL MZBOOK(IROCON,LSLRE,LSLRE,0,'SLRE',NLSLRE,NSSLRE,NDSLRE,
     +   IOSLRE,0)
      END IF
      IQ(LSLRE+IREFST) = LREKEY(1)
      IF(LREKEY(2).LE.0) THEN
         IQ(LSLRE+IRELST) = LREKEY(1)
      ELSE
         IQ(LSLRE+IRELST) = LREKEY(2)
      END IF
      IF(LREKEY(3).LE.0) THEN
         IQ(LSLRE+IRESTP) = 1
      ELSE
         IQ(LSLRE+IRESTP) = LREKEY(3)
      END IF
      CALL VZERO(LREKEY,3)
*
  999 RETURN
      END
+DECK,ROTNAM.
      SUBROUTINE ROTNAM(IBITNR,CHHBIT,CHNAME)
*.
*...ROETBI  return mnemonic + comment for bit Nr (counting 1-32 !!!).
*.
*. SEQUENCE: ROTPARM
*. CALLS   :
*. CALLED  : various places
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 12-Oct-95
*. LAST MOD:
*.
*. Modification log:
*.
***********************************************************************
+SEQ,DECLARE.
      CHARACTER*4 CHHBIT
      CHARACTER*20 CHNAME
      INTEGER IBITNR
+SEQ,ROTPARM.
*---
      IF(IBITNR.LE.0 .OR. IBITNR.GT.64)THEN
         CHHBIT='XXXX'
         CHNAME='Illegal BitNr'
      ELSE
         CHHBIT=ROTYPM(IBITNR)(1:4)
         CHNAME=ROTYPM(IBITNR)(6:24)//' '
      ENDIF
      RETURN
      END
+DECK,ROTYBI.
      INTEGER FUNCTION ROTYBI(CHHBIT)
*.
*...ROETBI  convert event type mnemonic to bit Nr (counting 1-32 !!!).
*.
*. SEQUENCE: ROTPARM
*. CALLS   :
*. CALLED  : various places
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 26-Sep-95
*. LAST MOD:
*.
*. Modification log:
*.
***********************************************************************
+SEQ,DECLARE.
      CHARACTER*4 CHHBIT
      INTEGER I
+SEQ,ROTPARM.
*---
      DO 10 I=1,64
      IF(CHHBIT.EQ.ROTYPM(I)(1:4))THEN
         ROTYBI=I
         GOTO 999
      ENDIF
10    CONTINUE
      ROTYBI=0
999   RETURN
      END
+DECK,RSLSET.
      SUBROUTINE RSLSET
*.
*...RSLSET  Initialize event selection.
*.
*. SEQUENCE: ROBANK ROCPAR CRO RCNTRL
*. CALLS   : ZSORTI MZDROP
*. CALLED  : ROPSET
*.
*. BANKS U : UTC SLCT SLEV SLRE
*. BANKS D : SLEV SLRE
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 10-Jan-1989
*. LAST MOD: 28-Jan-93
*.
*. Modification log:
*. 28-Jan-93 O.Schaile     Set ITRYMX=NTRYMX(1)
*. 11-Oct-89  S.Weisz        Set selection flag IFSLON + Run,Evt No.
*. 23-Mar-89  S.Weisz        Set IRDEBU if any debug is asked.
*. 23-Jan-89  S.Weisz        Sort selection bank in increasing order.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER LSLCT,LSLEV,LSLRE,LSLGE
*
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
*-- Set DEBUG flag for the set level.
      IF(IRDEBG(1).GE.1) IRDEBU = IRDEBG(4)
*
      LSLCT = LQ(LUTC-LLSLCT)
      IF(LSLCT.LE.0) THEN
         CHREP = 'No selection header bank!'
         CALL REPORT('RSLSET',1,'W')
                                                               GO TO 999
      END IF
*-- Check if events are selected with *READ card.
      LSLRE = LQ(LSLCT-LLSLRE)
      IF(LSLRE.GE.1) THEN
*-- Sort selection bank first.
         CALL ZSORTI(IXSTOR,LSLRE,IREFST)
         IRTRIG(1) = IQ(LSLRE+IREFST)
         IRTRIG(2) = IQ(LSLRE+IRELST)
         IRTRIG(3) = IQ(LSLRE+IRESTP)
         CALL MZDROP(IXSTOR,LSLRE,'.')
      END IF
*-- Check if events are selected with *EVENT card.
      LSLEV = LQ(LSLCT-LLSLEV)
      IF(LSLEV.LE.0) THEN
         IRUFST = 0
         IEVFST = 0
         IRULST = 0
         IEVLST = 0
      ELSE
*-- Sort selection bank first.
         CALL ZSORTI(IXSTOR,LSLEV,JEVFST)
         CALL ZSORTI(IXSTOR,LSLEV,JRUFST)
*-- Initialize selection parameters in RCNTRL.
         IRUFST = IQ(LSLEV+JRUFST)
         IEVFST = IQ(LSLEV+JEVFST)
         IRULST = IQ(LSLEV+JRULST)
         IEVLST = IQ(LSLEV+JEVLST)
         CALL MZDROP(IXSTOR,LSLEV,'.')
      END IF
*-- Check if events are selected with *GET card.
      LSLGE = LQ(LSLCT-LLSLGE)
      IF(LSLGE.GE.1) THEN
         IF(IFSLON.EQ.0)IFSLON = 1
         ISLRUN = IQ(LSLGE+IRUGET)
         ISLEVT = IQ(LSLGE+IEVGET)
         CALL MZDROP(IXSTOR,LSLGE,'.')
      END IF
*-- Preset to zero Exp, Run and Event numbers in CRO.
      IRDEXP = 0
      IRDRUN = 0
      IRDEVT = 0
      ITRYMX=NTRYMX(1)
*
  999 RETURN
      END
+DECK,RSTAGEI,IF=IBM.
      SUBROUTINE RSTAGE(FNAME,CHLUN,DESCRI,LREAD,FLAGS,RC)
*.
*...RSTAGE Stage the tape described as FNAME and call it 'CHLUN'
*.         If CHLUN='DUMMY' , prestage the tape
*.
*. CALLS   :  RQSYST LENOCC
*. CALLED  :  ROOFLX
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 15-Sep-91
*.
*. Modification Log.
*. 15-Sep-91  D.Lellouch     Stage returns 1 if data set already staged.
*. 27-Aug-91  S.Weisz        Use RBITFUNC sequence
*.  8-Fev-91  S.Weisz        Add some ' ' and test presence of (.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*(*) FNAME,CHLUN,DESCRI
      CHARACTER*8   WAIT,DIR
      LOGICAL       LREAD
      INTEGER       LENOCC,RC,FLAGS,ICOMMA
+SEQ,RCREP.
+SEQ,RCSYST.
+SEQ,ROUNIT.
+SEQ,RBITFUNC.
*
      IF(LREAD) THEN
         DIR    = 'INPUT'
         IF(CHLUN(1:5).EQ.'DUMMY') THEN
            WAIT   = '  NOWAIT'
         ELSE
            WAIT   = '  WAIT'
         END IF
      ELSE
         DIR    = 'OUTPUT'
         IF(BTEST(FLAGS,AUTOPU)) THEN
            WAIT   = '  AUTOPU'
         ELSE
            WAIT   = ' '
         END IF
      END IF
      ICOMMA = INDEX(FNAME,'(')
      IF(ICOMMA.EQ.0.AND.WAIT.NE.' ') WAIT(2:2) = '('
      SYSCOM = 'EXEC STAGE '//DIR//CHLUN(1:LENOCC(CHLUN))//' '
     +        //FNAME(1:LENOCC(FNAME))//' '//DESCRI(1:LENOCC(DESCRI))
     +        //WAIT
      CALL RQSYST(.TRUE.)
*-- Return code is 1 if data set already staged.
      IF(RC.EQ.1) RC     = 0
      RC     = SYSRC
*
      RETURN
      END
+DECK,RSTAGEU,IF=SHIFT.
      SUBROUTINE RSTAGE(FNAME,LUN,LREAD,LCIO,LUNPTR,RC)
*.
*...RSTAGE Stage the tape described as FNAME and assign it to LUN
*.
*. CALLS   :  RQSYST LENOCC
*. CALLED  :  ROOFLX
*.
*. AUTHOR  : T.Mouthuy
*. VERSION : 1.00
*. CREATED : 27-Feb-91
*. LAST MOD: 12-May-97
*.
*. Modification Log.a
*. 12-May-97  E.Barberio    Properly set RC
*. 12-Aug-93  O.Schaile     allow for FSEQnn
*.   911102   T.Mouthuy.    Stageing on SGI.
*. 12-Sep-91  B.PANZER      New STAGEIN command
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*(*) FNAME
      CHARACTER*8   CHLUN
      CHARACTER*80  FILENA
      CHARACTER*6   CSEQNR
      CHARACTER*80  SPACES
      LOGICAL       LREAD,LCIO
      INTEGER       LENOCC,RC,LUN,LUNPTR,IOSTAT
      INTEGER       IPFSEQ, IPNUMB, NC, NC1, INDXNC, INDEXN
+SEQ,RCREP.
+SEQ,RCSYST.
+SEQ,ROUNIT.
*
      RC = 0
*
      IF(LUN.LE.9) THEN
         WRITE(CHLUN,1000) LUN
      ELSE IF(LUN.LE.99) THEN
         WRITE(CHLUN,1010) LUN
      ELSE IF(LUN.LE.999) THEN
         WRITE(CHLUN,1020) LUN
      END IF
      IF(LREAD) THEN
         CALL CLTOU(FNAME)
*   get seq nr, allowed format: PQ0881.3 , PQ0881.FSEQ3

          IPFSEQ=INDEX(FNAME,'.FSEQ')
          IF(IPFSEQ.NE.0)THEN
             IPFSEQ=IPFSEQ-1
             IPNUMB=IPFSEQ+6
          ELSE
             IPFSEQ=INDEX(FNAME,'.')
             IF(IPFSEQ.NE.0)THEN
                IPFSEQ=IPFSEQ-1
                IPNUMB=IPFSEQ+2
             ENDIF
          ENDIF
          IF(IPFSEQ.LE.0)THEN
             IPFSEQ=LENOCC(FNAME)
             FILENA='T'//FNAME(1:IPFSEQ)//'.FSEQ1'
             CSEQNR='1'
             NC=1
          ELSE
*   is there a number?
             NC=INDEXN(FNAME(IPNUMB:))
             IF(NC.GT.0)THEN
*   yes, get its length
                IPNUMB=IPNUMB+NC-1
                NC=INDEX(FNAME(IPNUMB:),' ')
                IF(NC.LE.0)THEN
                   NC=LENOCC(FNAME)-IPNUMB+1
                ELSE
                   NC=NC-1
                ENDIF
             ENDIF
*   is t too long?
              IF(NC.GT.LEN(CSEQNR))NC=0
             IF(NC.GT.0)CSEQNR=FNAME(IPNUMB:IPNUMB+NC-1)
*    check if format is NNN or NNN-MMM, i.e. only numbers and 1 "-"
             IPNUMB=0
             IF(NC.GT.0)THEN
                DO 10 NC1=1,NC
                   IF(INDXNC(CSEQNR(NC1:NC1)).GT.0)THEN
                      IF(CSEQNR(NC1:NC1).EQ.'-')THEN
                         IPNUMB=IPNUMB+1
                      ELSE
                         IPNUMB=10
                      ENDIF
                   ENDIF
 10             CONTINUE
             ENDIF
             IF(NC.LE.0 .OR. IPNUMB.GT.1)THEN
                CHREP='No valid number after FSEQ, put to 1'
                CALL REPORT('RSTAGE',1,'E')
                CSEQNR='1'
                NC=1
             ENDIF
*   construct the file name, remove blanks
             FILENA='T'//FNAME(1:IPFSEQ)//'.FSEQ'//CSEQNR(1:NC)
             FILENA=SPACES(FILENA,0)
          ENDIF
*-- Request the stagein of the tape
         IF(.NOT.LCIO) THEN
            SYSCOM='stagein -G -v '//
     +             FNAME(1:IPFSEQ)//' -p opalstage -s 0 -q '
     +             //CSEQNR(1:NC)//' '//
     +             FILENA
         ELSE
            SYSCOM='stagein -G -v '//
     +             FNAME(1:IPFSEQ)//' -q '//CSEQNR(1:NC)//
     +             ' -F F -L 32400 -p opalstage -s 0 '//
     +             FILENA
         ENDIF
         CALL RQSYST(.TRUE.)
*-- Get it associated with CHLUN via a fassign call
* stageing always goes in opalstage pool under opal directory !!
         SYSCOM = '/u/ws/opal/pro/mgr/fassign -p opalstage -u opal '//
     +             FILENA(1:LENOCC(FILENA))//' '//
     +             CHLUN(1:LENOCC(CHLUN))
         CALL RQSYST(.TRUE.)
         IF(LCIO) THEN
            CALL CFOPEN(LUNPTR,0,8100,'r   ',0,CHLUN//' ',IOSTAT)
            IF(LUNPTR.EQ.0.AND.IOSTAT.EQ.0) IOSTAT = 7777
            IF(IOSTAT.GT.0) THEN
              LUNPTR = 0
              RC = 0
            ENDIF
         ENDIF
      ELSE
         FILENA=FNAME(1:LENOCC(FNAME))//'.stagedut'
*-- Create a pool file that will go on tape later (if wanted)
         SYSCOM = '/u/ws/opal/pro/mgr/fassign -c -p opalstage '//
     +             FILENA(1:LENOCC(FILENA))//' '//
     +             CHLUN(1:LENOCC(CHLUN))
         CALL RQSYST(.TRUE.)
      ENDIF
*
      RETURN
 1000 FORMAT('fort.',I1)
 1010 FORMAT('fort.',I2)
 1020 FORMAT('fort.',I3)
      END
+DECK,RSTAGEX,IF=-SHIFT,IF=-IBM.
      SUBROUTINE RSTAGE(FNAME,LUN,LREAD,LCIO,LUNPTR,RC)
*.
*...RSTAGE Dummy for all but shift+ibm
*.
*. CALLED  :  ROOFLX
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 30-Jan-92
*. LAST MOD: 30-Jan-92
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      CHARACTER*(*) FNAME
      LOGICAL       LREAD,LCIO
      INTEGER       RC,LUN,LUNPTR
      CHREP='Staging not supported on this system'
      CALL REPORT('RSTAGE',1,'E')
      END
+DECK,ROSTOP.
      SUBROUTINE ROSTOP(ISTOP)
*.
*...ROSTOP   Allows the user to stop processing of current event, or to
*.           stop the job, by means of word IRSTOP in sequence RCNTRL.
*.           It is safer to call this routine, rather than to change
*.           IRSTOP directly, since some variable names in RCNTRL
*.           clash with variable names in sequence ODSFUN (AB's fault).
*.
*. INPUT     : ISTOP (Input) Controls how the job proceeds:
*.                0  Continue (follow FFREAD card steering)
*.                1  Stop processing current event and read new one.
*                 2  Stop the job.
*.
*. SEQUENCE: RCNTRL
*. CALLED  : user
*.
*. AUTHOR  : C.Hawkes
*. VERSION : 1.00
*. CREATED : 23-Oct-91
*. LAST MOD: 11-Nov-91
*.
*. Modification Log.
*. 11-Nov-91  C.Hawkes       Check for input outside range [0,2]
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCNTRL.
      INTEGER ISTOP
*
      IRSTOP = ISTOP
      IF(IRSTOP.GT.2)IRSTOP=2
      IF(IRSTOP.LT.0)IRSTOP=0
*
      RETURN
      END
+DECK,ZEND.
      SUBROUTINE ZEND
*.
*...ZEND     Termination routine.
*.
*. SEQUENCE: RCNTRL
*. CALLS   : ROPFIN ZPHASE
*. CALLED  : QNEXT <ZEBRA>
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 11-Feb-88
*. LAST MOD:  6-Oct-93
*.
*. Modification Log.
*.  6-Oct-93   T.Smith   NSTOP =  8 (if ONLINE)
*.  7-Jun-90   S.Weisz   STOP with status.
*. 16-Mar-90   S.Weisz   Implement various exit code for Apollo.
*. 21-Jan-89   S.Weisz   It seems there is a bug in ZPHASE ...
*.
*.**********************************************************************
+SEQ,DECLARE.
+SELF,IF=ONLINE.
+SEQ,RCREP.
+SELF.
*
      INTEGER QVERSN,NQPHAS
*
+SEQ,RCNTRL.
*
      COMMON/ZSTATE/QVERSN,NQPHAS
*
      CALL ZPHASE(-3)
*-- Explicitely set the phase to -3 until Julius calls me back!
      NQPHAS = -3
*
      CALL ROPFIN
*
+SELF,IF=ONLINE.
      WRITE(CHREP,1010) NSTOP
      CALL REPORT('ZEND',1,'W')
 1010 FORMAT(' ZEND called with NSTOP = ',I6)
      NSTOP = 8
      CALL END_C(NSTOP)
+SELF,IF=-ONLINE.
      IF(NSTOP.EQ.0) STOP 0
      IF(NSTOP.EQ.2) STOP 2
      IF(NSTOP.EQ.3) STOP 3
      IF(NSTOP.EQ.4) STOP 4
      IF(NSTOP.EQ.5) STOP 5
      IF(NSTOP.EQ.6) STOP 6
      IF(NSTOP.EQ.7) STOP 7
      IF(NSTOP.EQ.8) STOP 8
      IF(NSTOP.EQ.9) STOP 9
      STOP 99
+SELF.
      END
+DECK,ZTELUSA,IF=ONLINE.
      SUBROUTINE ZTELUS
*.
*...ZTELUS   Handle ZEBRA and FATAL/CRASH calls to REPORT .
*.
*. SEQUENCE: CRO RCNTRL RCLINE
*. COMMON  : ZTELLC ZSTATE
*. CALLS   : RMAIL END_C
*. CALLED  : <ZEBRA> REPORT ROTRIG
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.02
*. CREATED :  7-Mar-91
*. LAST MOD:  7-Mar-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER ID,MODE
      INTEGER QVERSN,NQPHAS
*
      COMMON/ZTELLC/ID,MODE
      COMMON/ZSTATE/QVERSN,NQPHAS
*
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCLINE.
*
      WRITE(CHLINE,1000) IREVNT,ID
      CALL RMAIL(0,0)
*-- We always want to stop in On-line mode.
      MODE   = 3
      IF(ID.LE.99) THEN
*-- We have a ZEBRA error.
         IF(ID.EQ.4) THEN
*-- This is a FZIN problem.
            CHLINE = 'Problem with FZIN.'
            CALL RMAIL(0,0)
            NSTOP  = 4
         ELSE IF(ID.GE.11.AND.ID.LE.14) THEN
*-- This is a FZOUT problem.
            CHLINE = 'Problem with FZOUT.'
            CALL RMAIL(0,0)
            NSTOP  = 5
         ELSE IF(ID.EQ.99) THEN
*-- This is a ZEBRA memory problem.
            CHLINE = 'Not enough Memory.'
            CALL RMAIL(0,0)
            NSTOP  = 6
         ELSE
*-- Unknown ZEBRA problem.
            NSTOP  = 7
         END IF
      ELSE
*-- This is a FATAL or CRASH call to REPORT.
         NSTOP  = ID - 90
      END IF
*-- Test NQPHAS: -1(initialisation) --> Give a negative return code
*--             >=1(event loop)     --> Return positive, Ok to restart
*--              -3(termination)    --> Return positive
      IF(NQPHAS.EQ.-1) THEN
         NSTOP  = -NSTOP
      END IF
*
  999 CONTINUE
      CALL END_C(NSTOP)
      RETURN
*
 1000 FORMAT(' ZTELUS called for event ',I5,' with ID = ',I3)
*
      END
+DECK,ZTELUS,IF=-ONLINE.
      SUBROUTINE ZTELUS
*.
*...ZTELUS   Recovers ZEBRA troubles,skip event if no memory left.
*.
*. SEQUENCE: ROBANK ROPAR ROCPAR CRO RCNTRL RCREP RCLINE
*. COMMON  : ZTELLC
*. CALLS   : QNEXTE REPORT RMAIL ROWDAO ROWOUT
*.           FZMEMO RDPMRK RDSMRK FZOUT REVOUT _C_EXIT
*. CALLED  : <ZEBRA>
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 11-Feb-88
*. LAST MOD: 13-Jul-97
*.
*. Modification Log.
*. 13-Jul-97  E.Barberio Suppress call to ROWOUT for ODFIXed events
*. 11-Oct-90   S.Weisz   Proper handling of NQPHAS, new FZOUT pb. ID.
*.  7-Jun-90   S.Weisz   Set STOP return code.
*. 29-Mar-90   S.Weisz   Avoid reintrance in case of FZOUT problem.
*. 16-Mar-90   S.Weisz   Implement various return code for Apollo.
*.  8-Sep-89   S.Weisz   Call REPORT, set flag IFBOOK
*. 12-May-89   S.Weisz   Call ROWOUT in event loop;
*.                       Avoid ZFATAL in interactive mode.
*. 22-Mar-89   S.Weisz   ROWDAO was called with wrong arguments
*. 21-Mar-89   S.Weisz   Handle REPORT calls (ID 101,102)
*. 12-Jan-89   S.Weisz   Dump event on overflow units.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER ID,MODE,LIOHD,LIOOV,IL
      INTEGER QVERSN,NQPHAS
*
      COMMON/ZTELLC/ID,MODE
      COMMON/ZSTATE/QVERSN,NQPHAS
*
+SELF.
*
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
+SEQ,RCLINE.
*-- Set flag IFBOOK to avoid reintrance.
      IF(ID.LE.99) THEN
         IFBOOK = 0
         WRITE (CHREP,1000) IREVNT,ID
         CALL REPORT('ZTELUS',1,'F')
      ELSE
         WRITE (CHLINE,1000) IREVNT,ID
         CALL RMAIL(0,0)
      END IF
*-- Handle output streams when in event loop.
      IF(NQPHAS.GE.0) THEN
*-- If we have a FZOUT problem, stop the processing.
         IF(ID.GE.11.AND.ID.LE.14) THEN
            CHLINE='Problem with FZOUT, better STOP for now'
            CALL RMAIL(0,0)
            MODE  = 3
            NSTOP = 5
                                                               GO TO 999
         END IF
*-- Copy event as is on OVERFLOW units.
         LIOHD = LQ(LUTC-LLIOHD)
         IF(LIOHD.GE.1) THEN
            LIOOV = LQ(LIOHD-LLIOOV)
            IF(LIOOV.GE.1)
     +      CALL ROWDAO(LIOOV,IRODIV,LREV,1,'.',IOREV,NUHEAD,IUHEAD)
         END IF
*-- Copy event on output streams.
         IF ( NOWRIT.EQ.0 ) CALL ROWOUT
      END IF
      IF(ID.EQ.99) THEN
         MODE=1
      ELSE IF(ID.EQ.101) THEN
*-- Test NQPHAS: -1(initialisation) --> Stop the job.
*--             >=1(event loop)     --> Skip event.
*--              -3(termination)    --> Continue, hope it pass through!
         IF(NQPHAS.EQ.-1) THEN
            CHLINE='Fatal call to REPORT during initialisation, STOP!'
            CALL RMAIL(0,0)
*-- STOP processing in interactive mode, else go through ZEND.
            IF(IRINTR.EQ.1) STOP
            MODE = 3
         ELSE IF(NQPHAS.GE.0) THEN
            WRITE(CHLINE,1040) IRDEVT
            CALL RMAIL(0,0)
            MODE = 1
         ELSE
            WRITE(CHLINE,1050) NQPHAS
            CALL RMAIL(0,0)
            MODE = 0
         END IF
      ELSE IF(ID.EQ.102) THEN
*-- Test NQPHAS: -1(initialisation) --> Stop the job.
*--             >=0(event loop)     --> Call ZEND to terminate the job
*--              -3(termination)    --> Continue, hope it pass through!
         IF(NQPHAS.EQ.-1) THEN
            CHLINE='Crash call to REPORT during initialisation, STOP!'
            CALL RMAIL(0,0)
*-- STOP processing in interactive mode, else go through ZEND.
            IF(IRINTR.EQ.1) STOP
            MODE = 3
         ELSE IF(NQPHAS.GE.0) THEN
            WRITE(CHLINE,1060) IRDEVT
            CALL RMAIL(0,0)
            MODE = 3
         ELSE
            WRITE(CHLINE,1070) NQPHAS
            CALL RMAIL(0,0)
            MODE = 0
         END IF
      END IF
*
  999 CONTINUE
      RETURN
*
 1000 FORMAT(' ZTELUS called for event ',I5,' with ID = ',I3)
 1010 FORMAT(' ZTELUS: Prod output: Return code from FZOUT = ',I6)
 1020 FORMAT(' ZTELUS: DST output : Return code from FZOUT = ',I6)
 1030 FORMAT(' ZTELUS: Return code from REVOUT = ',I6)
 1040 FORMAT(' Fatal call to REPORT, skip event ',I6)
 1050 FORMAT(' Fatal call to REPORT, continue in phase ',I4)
 1060 FORMAT(' Crash call to REPORT for event ',I6)
 1070 FORMAT(' Crash call to REPORT, continue in phase ',I4)
*
      END
+DECK,FISWBU.
      SUBROUTINE FISWBU (ISWBIT)
*.
*...FISWBU   SW bunch number determination
*.           This copy of FISWBU is to update the SW part of the SW
*.           bunchlet byte, which was wrong most of 95 pass1.
*.           The original info can be recovered from SW DD.
*.
*. OUTPUT    : ISWBIT - 8 bits of SW bunchlet information
*.
*. SEQUENCE  : RCREP  ROPAR  ROBANK SWDATA SWWBUF SWSURV SWGCPM
*. CALLED    :
*.
*. AUTHOR    : D.Wagner
*. VERSION   : 1.00
*. CREATED   : 24-Apr-95
*. LAST MOD  :  5-Oct-95
*.
*. Modification Log:
*. 5-Oct-95   M.Schroder don't use sequence FILINK
*.31-Aug-1995 SGS Fix bug--error in bank name on IWORDL
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER ISWBIT
+SEQ,ROBANK.
+SEQ,ROPAR.
* local variables:
      INTEGER LLSWSR, LLSWSL
      PARAMETER (LLSWSR=6, LLSWSL=7)
*
*  These are the offsets into the SWSR and SWSL banks for the leading
*  (defined as constants here; oh well)
*
      INTEGER IOFFR, IOFFL
      PARAMETER (IOFFR = 7, IOFFL = 2)
*
*  Offsets to the bunchlet number that was held (both left and right)
*  and to the two-bit mode flag (which can be obtained from either
*  left or right)
*
      INTEGER IBUOFF, IMDOFF
      PARAMETER (IBUOFF = 13, IMDOFF = 17)
*
*  Bit number of flags:
*
      INTEGER IRAOFF
      PARAMETER (IRAOFF = 18)
*
*  These pointers are not in a link area; don't call any ZEBRA routines
*  or these may become invalid!
*
      INTEGER LSWSR, LSWSL
      INTEGER LSWRA
*
      INTEGER IWORDR, IWORDL
      INTEGER ITAGMD, IBUNCH

      ISWBIT = 0
*
*  Find the SWSR and SWSL banks
*
      IF (LDA .LE. 0) GOTO 999
      LSWRA = LQ(LDA-LLSWRA)
      IF (LSWRA .LE. 0) GOTO 999
      LSWSR = LQ(LSWRA-LLSWSR)
      LSWSL = LQ(LSWRA-LLSWSL)
*
*  If either bank is completely missing, then this is a serious error;
*  don't bother doing anything
*
      IF (LSWSR .LE. 0 .OR. LSWSL .LE. 0) GOTO 999
      IWORDR = IQ(LSWSR+IOFFR)
C      IWORDL = IQ(LSWSR+IOFFL)
      IWORDL = IQ(LSWSL+IOFFL)
*
*  Figure out the wagon tagger mode (which depends on whether the random
*  mode bit is set)
*
      IF (BTEST(IWORDR,IRAOFF)) THEN
        ITAGMD = 3
      ELSE
        CALL CBYT(IWORDR, IMDOFF, ITAGMD, 1, 2)
      END IF
*
*  Now extract the tagged bunchlet number (which starts from 0) from the
*  right and left banks
*
      CALL CBYT (IWORDR, IBUOFF, IBUNCH, 1, 4)
      IBUNCH = IBUNCH + 1
      CALL CBYT (IBUNCH, 1, ISWBIT, 1, 3)
*
      CALL CBYT (IWORDL, IBUOFF, IBUNCH, 1, 4)
      IBUNCH = IBUNCH + 1
      CALL CBYT (IBUNCH, 1, ISWBIT, 4, 3)
*
*  And the tagging mode
*
      CALL CBYT (ITAGMD, 1, ISWBIT, 7, 2)

 999  CONTINUE
      RETURN
      END
+PATCH,ROUTIL.
+DECK,HFILES
      SUBROUTINE HFILES(NTOP,CHTOPR,ICHTOR,ICHLUR,MTOP,ICONT)
      CHARACTER*(*) CHTOPR(*)
      INTEGER NTOP,ICHTOR(*),ICHLUR(*),MTOP,ICONT
*.==========>
*.
*.   !!!!!!!!! This routine will go into HBOOK !!!!!!!!!
*.
*.    Return HBOOK top directories to the user
*.
*.    NTOP*    Number of directories returned
*.    CHTOPR*  Directory names
*.    ICHTOR*  Flag for file type
*.    ICHLUR*  Logical unit
*.    *MTOP    The maximum dimension of CHTOPR, ICHTOR, ICHLUR
*.    *ICONT*  On input:  Start returning dir at ICONT
*.             On return: Next non returned dir, 0 if all returned
*.
*..=========> ( O.Schaile )
C  +SEQ,HCDIRE
C  +KEEP,HCDIRE.
*CMZ :  4.20/03 28/07/93  09.33.32  by  Rene Brun
*-- Author :
      PARAMETER (NLPATM=100, MXFILS=50)
      COMMON /HCDIRN/NLCDIR,NLNDIR,NLPAT,ICDIR,NCHTOP,ICHTOP(MXFILS)
     +              ,ICHTYP(MXFILS),ICHLUN(MXFILS)
      CHARACTER*16   CHNDIR,    CHCDIR,    CHPAT    ,CHTOP
      COMMON /HCDIRC/CHCDIR(NLPATM),CHNDIR(NLPATM),CHPAT(NLPATM)
     +              ,CHTOP(NLPATM)
      CHARACTER*80 HFNAME
      COMMON /HCFILE/HFNAME(MXFILS)
*-- end of HCDIRE.
      INTEGER ICONTI, J, I, LASRET
*
      IF(ICONT.GT.2)THEN
         IF(ICONT.GT.NCHTOP)THEN
            ICONT=0
            NTOP=0
            GOTO 20
         ENDIF
         ICONTI=ICONT
      ELSE
         ICONTI=2
      ENDIF
      NTOP=MIN(MTOP,NCHTOP-ICONTI+1)
      IF(NTOP.LE.0)THEN
         NTOP=0
         GOTO 20
      ENDIF
      LASRET=MIN(ICONTI+NTOP-1,NCHTOP)
      IF(LASRET.EQ.NCHTOP)THEN
         ICONT=0
      ELSE
         ICONT=LASRET+1
      ENDIF
      J=0
      DO 10 I=ICONTI,LASRET
         J=J+1
         CHTOPR(J)=CHTOP(I)
         ICHTOR(J)=ICHTOP(I)
         ICHLUR(J)=ICHLUR(I)
 10   CONTINUE
 20   CONTINUE
      RETURN
      END
+DECK,CFBAT.
      SUBROUTINE CFBAT
*.
*...CFBAT    Fake filling of Track and Vertex CF banks
*.
*. SEQUENCE : ROBANK CRO ROPAR CFPAR GOPAR
*. CALLS    : VZERO MZLINT MZBOOK UCOPY
*. CALLED   : ROGOKU ROPBAT
*.
*. BANKS L  : CF CFX CFXN CFXP CFT CFTS CFTX
*. BANKS U  : MC TREE
*.
*. AUTHOR   : S.Weisz
*. VERSION  : 2.01
*. CREATED  :  8-Jul-87
*. LAST MOD.: 17-Nov-88
*.
*. Modification log.
*. 17-Nov-88 S.Weisz    Use TREE structure.
*. 19-Nov-87 S.Weisz    Store KINE track # in word ICFTIK of CFTS.
*. 26-Oct-87 S.Weisz    Work on GOPAL112 events only.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER NVMAX,NTMAX,IPR,IPART,ICH,I41,I43
      PARAMETER(NVMAX=100,NTMAX=200)
*        NVMAX = Max. Number of Vertices to be handled
*        NTMAX = Max. Number of Tracks to be handled
*        IPR   = Flag to send one "overload" warning per event
*        IPART = Particle type ( from GEANT )
*        ICH   = Charge of particle
*        Inn   = Loop indices
      INTEGER NKIN,NTC,NVC,KT,KC,KV,KD,LT,LV
*        NKIN  = Number of tracks in TREE bank
*        NTC   = Counter for fake tracks seen in the central detector
*        NVC   = Counter for fake vertices seen in the central detector
*        KT    = Track indice in loop on TREE tracks
*        KC    = Track indice in loop on TREE tracks
*        KV    = Vertex indice in loop on TREE vertices
*        KD    = Indice of decay vertex
*        LT    = Link to track KT in CF structure
*        LV    = Link to vertex KV in CF structure
      INTEGER NVT,KTO,KTD
      DIMENSION NVT(NVMAX),KTO(NTMAX),KTD(NTMAX)
*        NVT   = Number of fake tracks from vertex KV
*        KTO   = Index of origin vertex for track KT
*        KTD   = Index of decay vertex for track KT
      INTEGER LCFLOC,LGENE,LTREE,LCFX,LCFT,LCFXN,LCFXP,LCFTS,LCFTX
*        LGENE = Link to the top generator bank GENE.
*        LTREE = Link to TREE bank.
*        LCFX  = Link to ROPE fake vertex bank CFX
*        LCFT  = Link to ROPE fake track bank CFT
*        LCFXN = Link to fake vertex information bank
*        LCFXP = Link to fake vertex parameter bank
*        LCFTS = Link to fake track segment bank
*        LCFTX = Link to fake track end point bank
      INTEGER LKTREE,LCTREE
*        LKTREE= Temporary pointer to track parameters in TREE bank
*        LCTREE= Temporary pointer to track parameters in TREE bank
      REAL RMIN,RMAX,ZMAX,CONE,DRMIN
*        RMIN  = Internal radius of the fiducial volume of the CD
*        RMAX  = External radius of the fiducial volume of the CD
*        ZMAX  = Max. |Z| at R=0
*        CONE  = Cone angle at the ends of the CD [= SIN(15 deg.)]
*        DRMIN = Minimal radial extension of track seen in CD [= 10 Cm]
      INTEGER NPTREE
*        NPTREE = Number of track parameters in TREE bank
      PARAMETER(RMIN=25.,RMAX=189.,ZMAX=151.,CONE=0.2588)
      PARAMETER(DRMIN=20.)
      REAL RS,RE,RF,DX2,DY2,DZ2,DR2
*        RS    = Radius of track start point
*        RE    = Radius of track end point
*        RF    = Radius of effective track end point
      REAL CHARGE,SCHARG
      DOUBLE PRECISION PX,PY,PZ,ENERGY,PTOT,PT,P2,PT2,RADIUS,CURV, XV,
     +YV,ZV,XC,YC,D2,D0,SXC,SYC,CPI,PHI0,TANL, XD,YD,SXD,SYD,PHIVTX,
     +SVTX,ZZERO
*        PX,PY,PZ,ENERGY    = Q-Vector of track
*        PTOT,PT,P2,PT2     = Ptot.,Pt and squares
*        RADIUS,CURV        = Radius of curvature,CURV=-SCHARG/2*RADIUS
*        CHARGE,SCHARG      = Charge,sign of charge
*        XV,YV,ZV           = Position of origin vertex
*        XC,YC              = Position of centre of trajectory in (X,Y)
*        D0,PHI0,TANL,ZZERO = Distance from origin,Phi angle,TAN(Lamda)
*                             and Z of point of closest approach
      REAL BFIELD
      INTEGER IPRT,IPRIM
*
      COMMON/PRIMA/IPRIM(NTMAX)
      COMMON/CCFLOC/LCFLOC(2),LGENE,LTREE,LCFX,LCFT, LCFXN(NVMAX),LCFXP
     +(NVMAX), LCFTS(NTMAX),LCFTX(NTMAX)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,GOPAR.
+SEQ,CFPAR.
+SEQ,RCREP.
+SEQ,GCONST.
*
      DATA BFIELD/0.4350/
      CALL VZERO(NVT,NVMAX)
      CALL VZERO(KTO,NTMAX)
      CALL VZERO(KTD,NTMAX)
      NVC=0
      IPR=0
      IPRT=0
*--   Define a temporary link area.
      CALL MZLINT(IXSTOR,'/CCFLOC/',LCFLOC,LGENE,LCFTX(NTMAX))
*--   Get pointer to TREE bank.
      IF(LMC .LE. 0) THEN
         CHREP = 'No Monte-Carlo structure'
         CALL REPORT('CFBAT',1,'W')
                                                               GO TO 130
      END IF
      LGENE = LQ(LMC-LLGENE)
      IF(LGENE .LE. 0) THEN
         CHREP = 'No GENE structure'
         CALL REPORT('CFBAT',2,'W')
                                                               GO TO 130
      END IF
      NKIN   = IQ(LGENE+INGEN )
      NPTREE = IQ(LGENE+ILENT)
      LTREE  = LQ(LGENE-LLTREE)
      IF(LTREE .LE. 0) THEN
         CHREP = 'No TREE structure'
         CALL REPORT('CFBAT',3,'W')
                                                               GO TO 130
      END IF
      IF(NKIN.GT.NTMAX) THEN
         CHREP = 'Too many tracks, first NTMAX used'
         CALL REPORT('CFBAT',4,'W')
         NKIN=NTMAX
                                                               GO TO 130
      END IF
*--   Loop on tracks and flag the one seen in the Central Detector.
      DO 30 KT=1,NKIN
         LKTREE=LTREE+(KT-1)*NPTREE
         RS=SQRT(Q(LKTREE+ITRSX)**2+Q(LKTREE+ITRSY)**2)
*--   Check if start point of KT is inside fiducial volume of CD.
         IF(RS.GT.RMAX)                                         GO TO 30
         IF(ABS(Q(LKTREE+ITRSZ)).GT.ZMAX+CONE*RS)               GO TO 30
*--   Check if this track leaves the Beam pipe.
         RE=SQRT(Q(LKTREE+ITREX)**2+Q(LKTREE+ITREY)**2)
         IF(RE.LT.RMIN)                                         GO TO 30
*--   Check the charge of this track.
         ICH=INT(Q(LKTREE+ITRCH))
         IF(ICH.EQ.0)                                           GO TO 30
*--   Check the radial length of track in CD.
         RF=RE
         IF(ABS(Q(LKTREE+ITREZ)).GT.ZMAX+CONE*RE) RF=RS+(RE-RS)*(ZMAX
     +   /ABS(Q(LKTREE+ITREZ)))
         IF(RS.LT.RMIN) RS=RMIN
         IF(RF.GT.RMAX) RF=RMAX
         IF(RF-RS.LT.DRMIN)                                     GO TO 30
*--   Track should be seen.
         DO 10 KC=1,KT
            IF(KC.EQ.KT)                                        GO TO 10
            LCTREE=LTREE+(KC-1)*NPTREE
            DX2=(Q(LKTREE+ITRSX)-Q(LCTREE+ITRSX))**2
            DY2=(Q(LKTREE+ITRSY)-Q(LCTREE+ITRSY))**2
            DZ2=(Q(LKTREE+ITRSZ)-Q(LCTREE+ITRSZ))**2
            DR2=DX2+DY2+DZ2
            IF(DR2.LT.1.E-6) THEN
               IF(KTO(KC).EQ.0)                                 GO TO 10
*--   Track start at a known vertex.
               KV=KTO(KC)
                                                                GO TO 20
            END IF
            DX2=(Q(LKTREE+ITRSX)-Q(LCTREE+ITREX))**2
            DY2=(Q(LKTREE+ITRSY)-Q(LCTREE+ITREY))**2
            DZ2=(Q(LKTREE+ITRSZ)-Q(LCTREE+ITREZ))**2
            DR2=DX2+DY2+DZ2
            IF(DR2.LT.1.E-6) THEN
               IF(KTD(KC).EQ.0)                                 GO TO 10
*--   Track start at a known vertex.
               KV=KTD(KC)
                                                                GO TO 20
            END IF
   10    CONTINUE
*--   Track start point is a new vertex.
         IF(NVC.GE.NVMAX) THEN
            CHREP='Too many vertices, only first NVMAX are used'
            IF(IPR.EQ.0) CALL REPORT('CFBAT',5,'W')
            IPR=1
                                                                GO TO 30
         END IF
         NVC=NVC+1
         KV=NVC
   20    CONTINUE
         KTO(KT)=KV
         NVT(KV)=NVT(KV)+1
         IF(RE.GT.RMAX)                                         GO TO 30
         IF(ABS(Q(LKTREE+ITRSZ)).GT.ZMAX+CONE*RE)               GO TO 30
*--   Track end point is a new vertex.
         IF(NVC.GE.NVMAX) THEN
            CHREP='Too many vertices, only first NVMAX are used'
            IF(IPR.EQ.0) CALL REPORT('CFBAT',5,'W')
            IPR=1
                                                                GO TO 30
         END IF
         NVC=NVC+1
         KV=NVC
         KTD(KT)=KV
         NVT(KV)=NVT(KV)+1
   30 CONTINUE
      IF(LCD.LE.0) THEN
*--   Book and fill CD bank.
         CALL MZBOOK(IRODIV,LCD,LREV,-LLCD,'CD  ',NLCD,NSCD,NDCD,1,0)
      END IF
*--   Book and fill header fake bank CF.
      CALL MZBOOK(IRODIV,LCF,LCD,-LLCF,'CF  ',NLCF,NSCF,NDCF,IOCF,0)
*--   Book and fill header fake vertex bank CFX.
      CALL MZBOOK(IRODIV,LCFX,LCF,-LLCFX,'CFX ',NVC,NVC,NVC+NDCFX,
     +IOCFX,0)
      IQ(LCFX+ICFXNV)=NVC
      DO 60 KV=1,NVC
*--   Book banks for vertex KV.
         CALL MZBOOK(IRODIV,LCFXN(KV),LCFX,-KV,'CFXN',NLCFXN,NSCFXN,NVT
     +   (KV)+NDCFXN,IOCFXN,0)
         IQ(LCFXN(KV)+ICFXNN)=NVT(KV)
         CALL MZBOOK(IRODIV,LCFXP(KV),LCFXN(KV),-LLCFXP,'CFXP',NLCFXP,
     +   NSCFXP,NDCFXP,IOCFXP,0)
*--   Fill vertex position in CFXP.
         DO 40 KT=1,NKIN
            IF(KTO(KT).EQ.KV) THEN
               LKTREE=LTREE+(KT-1)*NPTREE
               CALL UCOPY(Q(LKTREE+ITRSX),Q(LCFXP(KV)+ICFXPX),3)
                                                                GO TO 60
            END IF
   40    CONTINUE
*--   Vertex KV might still be a decay vertex only.
         DO 50 KT=1,NKIN
            IF(KTD(KT).EQ.KV) THEN
               LKTREE=LTREE+(KT-1)*NPTREE
               CALL UCOPY(Q(LKTREE+ITREX),Q(LCFXP(KV)+ICFXPX),3)
                                                                GO TO 60
            END IF
   50    CONTINUE
   60 CONTINUE
*--   Count tracks to be written in bank CTRK.
      NTC=0
      DO 70 KT=1,NKIN
         IF(KTO(KT).GT.0) NTC=NTC+1
   70 CONTINUE
*--   Book and fill track bank CFT.
      CALL MZBOOK(IRODIV,LCFT,LCF,-LLCFT,'CFT ',NTC,NTC,NTC+NDCFT,
     +IOCFT,0)
      IQ(LCFT+ICFTNT)=NTC
      NTC=0
      DO 120 KT=1,NKIN
         IF(KTO(KT).EQ.0)                                      GO TO 120
         KV=KTO(KT)
         NTC=NTC+1
*--   Fill track reference for vertex KV in bank CFXN.
         DO 80 I41=1,NVT(KV)
            IF(IQ(LCFXN(KV)+NDCFXN+I41).NE.0)                   GO TO 80
            IQ(LCFXN(KV)+NDCFXN+I41)=NTC
                                                                GO TO 90
   80    CONTINUE
   90    CONTINUE
         IF(KTD(KT).EQ.0)                                      GO TO 110
         KD=KTD(KT)
*--   Fill track reference for vertex KD in bank CFXN.
         DO 100 I43=1,NVT(KD)
            IF(IQ(LCFXN(KD)+NDCFXN+I43).NE.0)                  GO TO 100
            IQ(LCFXN(KD)+NDCFXN+I43)=NTC
                                                               GO TO 110
  100    CONTINUE
  110    CONTINUE
         LKTREE=LTREE+(KT-1)*NPTREE
*--   Compute some kinematics.
         PX=Q(LKTREE+ITRPX)
         PY=Q(LKTREE+ITRPY)
         PZ=Q(LKTREE+ITRPZ)
         ENERGY=Q(LKTREE+ITRE)
         PT2=PX**2+PY**2
         P2=PT2+PZ**2
         PTOT=SQRT(P2)
         PT=SQRT(PT2)
*--   CURV (-Sign(Q)/2*R , R = RADIUS OF CURVATURE ).
         RADIUS=PT/(0.003*BFIELD)
         IPART=IQ(LKTREE+ITRTY)
         CHARGE=Q(LKTREE+ITRCH)
         SCHARG=SIGN(+1.,CHARGE)
         RADIUS=SCHARG*RADIUS/CHARGE
         CURV=-0.5*SCHARG/RADIUS
*--   D0 (DISTANCE OF CLOSEST APPROACH).
         XV=Q(LKTREE+ITRSX)
         YV=Q(LKTREE+ITRSY)
         ZV=Q(LKTREE+ITRSZ)
         XC=XV+(SCHARG*RADIUS*PY/PT)
         YC=YV-(SCHARG*RADIUS*PX/PT)
         D2=XC**2+YC**2
         D0=SCHARG*(RADIUS-SQRT(D2))
*--   PHI0   (ANGLE OF TRACK AT POINT OF CLOSEST APPROACH).
         IF(XC.GT.0.) THEN
            SXC=1.
         ELSE
            SXC=-1.
         END IF
         IF(YC.GT.0.) THEN
            SYC=1.
         ELSE
            SYC=-1.
         END IF
         CPI=0.5*(SXC*SYC+SXC*SCHARG)
         PHI0=ATAN(XC/YC)+CPI*PI
*--   TANL   (SLOPE DZ/DS).
         TANL=PZ/PT
*--   PHIVTX (ANGLE OF TRACK AT ORIGIN VERTEX).
         XD=XC-XV
         IF(XD.GT.0.) THEN
            SXD=1.
         ELSE
            SXD=-1.
         END IF
         YD=YC-YV
         IF(YD.GT.0.) THEN
            SYD=1.
         ELSE
            SYD=-1.
         END IF
         CPI=0.5*(SXD*SYD+SXD*SCHARG)
         PHIVTX=ATAN(XD/YD)+CPI*PI
         SVTX=0.5*(PHIVTX-PHI0)/CURV
         ZZERO=ZV-TANL*SVTX
*--   Book banks for track NTC.
         CALL MZBOOK(IRODIV,LCFTS(NTC),LCFT,-NTC,'CFTS',NLCFTS,NSCFTS,
     +   NDCFTS,IOCFTS,0)
         CALL MZBOOK(IRODIV,LCFTX(NTC),LCFTS(NTC),-LLCFTX,'CFTX',
     +   NLCFTX,NSCFTX,NDCFTX,3,0)
C     CALL MZBOOK(IRODIV,LCFTI(NTC),LCFTS(NTC),
C    +            -LLCFTI,'CFTI',NLCFTI,NSCFTI,NDCFTI,3,0)
*--   Fill essential track information.
         LT=LCFTS(NTC)
         IQ(LT+ICFTID) = IPART
         IQ(LT+ICFTIK) = KT
         Q(LT+ICFTCU) = CURV
         Q(LT+ICFTPH) = PHI0
         Q(LT+ICFTD0) = D0
         Q(LT+ICFTTL) = TANL
         Q(LT+ICFTZ0) = ZZERO
         Q(LT+ICFTPX) = PX
         Q(LT+ICFTPY) = PY
         Q(LT+ICFTPZ) = PZ
         Q(LT+ICFTEE) = ENERGY
         Q(LT+ICFTPP) = PTOT
         Q(LT+ICFTPT) = PT
         Q(LT+ICFTQQ) = CHARGE
*--   Fill vertex information.
         LT=LCFTX(NTC)
         Q(LT+ICFTXO)=FLOAT(KV)
         LQ(LT-LRCFXO)=LQ(LCFX-KV)
*--   Fill vertex position.
         LV=LCFXP(KV)
         CALL UCOPY(Q(LV+ICFXPX),Q(LT+ICFTXX),3)
         IF(KTD(KT).EQ.0)                                      GO TO 120
         KD=KTD(KT)
         Q(LT+ICFTXD)=FLOAT(KD)
         LQ(LT-LRCFXD)=LQ(LCFX-KD)
*--   Fill position of decay vertex.
         LV=LCFXP(KD)
         CALL UCOPY(Q(LV+ICFXPX),Q(LT+ICFTDX),3)
  120 CONTINUE
  130 CONTINUE
      LCFLOC(1)=0
      RETURN
      END
+DECK,CFFTRK.
      SUBROUTINE CFFTRK(KT,VXYZ,PXYZE,CHARGE)
*.
*...CFFTRK   Fetch tracks parameters in CF banks for extrapolation
*.
*. INPUT    : KT       track #
*. OUTPUT   : VXYZ(3)  position of origin vertex
*. OUTPUT   : PXYZE(4) 4-vector of track
*. OUTPUT   : CHARGE   charge of track
*.
*. SEQUENCE : ROBANK CFPAR RCREP
*. CALLS    : VZERO CFNTRK UCOPY REPORT
*. CALLED   : <USER>
*.
*. BANKS U  : CFT CFTS CFTX
*.
*. AUTHOR   : S.Weisz
*. VERSION  : 1.01
*. CREATED  : 18-May-87
*. LAST MOD.:  4-Nov-87
*.
*. Modification log.
*.  4-Nov-87 S.Weisz    Use CFPAR sequence
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER KT,NTRACK,LCFT,LCFTS,LCFTX
      REAL VXYZ,PXYZE,CHARGE,CURV
*.
+SEQ,ROBANK
+SEQ,CFPAR
+SEQ,RCREP
*
      DIMENSION VXYZ(3),PXYZE(4)
*
      CALL VZERO(VXYZ,3)
      CALL VZERO(PXYZE,4)
*--   Get number of track.
      CALL CFNTRK(NTRACK,LCFT)
      IF(KT.LE.0.OR.KT.GT.NTRACK)                              GO TO 999
*--   Get pointer to the track parameters.
      LCFTS=LQ(LCFT-KT)
      IF(LCFTS.EQ.0) THEN
         WRITE(CHREP,1000)
         CALL REPORT('CFFTRK',1,'W')
                                                               GO TO 999
      END IF
*--   Get charge (for B field along Z >0) and 4-vector.
      CURV=Q(LCFTS+ICFTCU)
      CHARGE=1.
      IF(CURV.GT.0.) CHARGE=-1.
      CALL UCOPY(Q(LCFTS+ICFTPX),PXYZE(1),4)
*--   Get position of the origin vertex.
      LCFTX=LQ(LCFTS-LLCFTX)
      IF(LCFTX.EQ.0) THEN
         WRITE(CHREP,1010)
         CALL REPORT('CFFTRK',2,'W')
                                                               GO TO 999
      END IF
      CALL UCOPY(Q(LCFTX+ICFTXX),VXYZ(1),3)
  999 RETURN
 1000 FORMAT('Bank CFTS is not there !!!')
 1010 FORMAT('Bank CFTX is not there !!!')
      END
+DECK,CFNTRK.
      SUBROUTINE CFNTRK(NTRACK,LCFT)
*.
*...CFNTRK   Number of fake tracks seen in the Central Detector
*.
*. OUTPUT   : NTRACK   Number of tracks
*. OUTPUT   : LCFT     Pointer to top fake track bank CFT
*.
*. SEQUENCE : ROBANK CFPAR RCREP
*. CALLS    : REPORT
*. CALLED   : <USER>
*.
*. BANKS U  : CTRK
*.
*. AUTHOR   : S.Weisz
*. VERSION  : 1.01
*. CREATED  : 18-May-87
*. LAST MOD.:  4-Nov-87
*.
*. Modification log.
*.  4-Nov-87 S.Weisz    Use CFPAR sequence
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER NTRACK,LCFT
*
+SEQ,ROBANK
+SEQ,CFPAR
+SEQ,RCREP
*
      NTRACK=0
      IF(LCF.EQ.0) THEN
         WRITE(CHREP,1000)
         CALL REPORT('CFNTRK',1,'W')
                                                               GO TO 999
      END IF
      LCFT=LQ(LCF-LLCFT)
      IF(LCFT.EQ.0) THEN
         WRITE(CHREP,1010)
         CALL REPORT('CFNTRK',2,'W')
                                                               GO TO 999
      END IF
      NTRACK=IQ(LCFT+ICFTNT)
  999 RETURN
 1000 FORMAT('Bank CF is not there !!!')
 1010 FORMAT('Bank CFT is not there !!!')
      END
+DECK,JUCOMP.
      INTEGER FUNCTION JUCOMP(CTEST,JLIST,NLIST)
*.
*...JUCOMP  As IUCOMP, but first argument is a character string,
*.  to be compared with JLIST, which is hollerith.
*.
*. INPUT     : CTEST   Character string to be tested
*. INPUT     : JLIST   Array of Holleriths
*. INPUT     : NLIST   Length of JLIST
*. OUTPUT    : JUCOMP  Address of match in JLIST - zero if none.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : UCTOH   CTOH
*. CALLED    : All over the place
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 12-May-87
*. LAST MOD  : 26-Apr-88
*.
*. Modification Log.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 12-May-87   D.R.Ward        First version
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
      CHARACTER *(*) CTEST
      INTEGER ITEST,NLIST,JLIST(*),IUCOMP
      EXTERNAL IUCOMP
      CALL UCTOH(CTEST,ITEST,4,4)
      JUCOMP=IUCOMP(ITEST,JLIST,NLIST)
      RETURN
      END
+DECK,PROB.
      FUNCTION PROB(CHI2,N)
*.
*...PROB     Corrected version of CERNLIB function.
*.           The CERNLIB version has a bug which makes it incorrectly
*.           return PROB=0 when given a very large CHI2 and N=1.
*.           This fixed version (received from Kolbig) will
*.           eventually be released as the production CERNLIB
*.           version, at which time it can be removed from ROPE.
*.
*. SEQUENCE: RCREP
*. CALLS   : REPORT
*.
*. AUTHOR   : M.Jimack
*. VERSION  : 1.01
*. CREATED  : 25-Aug-92
*. LAST MOD.: 30-Aug-93
*.
*. Modification log.
*. 30-Aug-93  O.Schaile      Put UP=169. to avoid FP underflow in ERFC
*. 04-Oct-92  C.Hawkes       Use REPORT rather than MTLPRT
*.
*.**********************************************************************
+SEQ,RCREP.
      CHARACTER NAME*(*)
      CHARACTER*80 ERRTXT
      PARAMETER (NAME = 'PROB')
      PARAMETER (R1 = 1, HF = R1/2, TH = R1/3, F1 = 2*R1/9)
      PARAMETER (C1 = 1.12837 91670 95513D0)
      PARAMETER (UP = 169.)

      X=HF*CHI2
      IF(N .LE. 0) THEN
       H=0
       WRITE(ERRTXT,101) N
C Use REPORT (CMH 921004)
C      CALL MTLPRT(NAME,'G100.1',ERRTXT)
       CHREP = 'G100.1 '//ERRTXT
       CALL REPORT(NAME,1,'E')
      ELSEIF(CHI2 .LT. 0) THEN
       H=0
       WRITE(ERRTXT,102) CHI2
C Use REPORT (CMH 921004)
C      CALL MTLPRT(NAME,'G100.2',ERRTXT)
       CHREP = 'G100.2 '//ERRTXT
       CALL REPORT(NAME,2,'E')
      ELSEIF(CHI2 .GT. UP) THEN
       H=0
      ELSEIF(N .GT. 100) THEN
       S=R1/N
       T=F1*S
       H=HF*ERFC(((CHI2*S)**TH-(1-T))/SQRT(2*T))
      ELSEIF(N .EQ. 1) THEN
       H=ERFC(SQRT(X))
      ELSE
       S=1
       T=1
       M=N/2
       IF(2*M .EQ. N) THEN
        DO 1 I = 1,M-1
        T=X*T/I
    1   S=S+T
        H=S*EXP(-X)
       ELSE
        DO 2 I=1,M-1
        T=T*CHI2/(2*I+1)
    2   S=S+T
        W=SQRT(X)
        H=C1*W*S*EXP(-X)+ERFC(W)
       ENDIF
      ENDIF
      PROB=H
      RETURN
  101 FORMAT('N = ',I6,' < 1')
  102 FORMAT('X = ',1P,E20.10,' < 0')
      END
+DECK,RABBRE.
      FUNCTION RABBRE(OPTION,OPT,L)
*.
*...RABBRE Exact copy of the IBM REXX ABBREV function. Trailing
*.         blanks of OPTION and OPT are ignored
*.
*. CALLS   : LENOCC
*. CALLED  : RIOFIL
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER OPTION*(*),OPT*(*)
      LOGICAL   RABBRE
      INTEGER   LENOCC,L,L1,L2
*
      L1     = LENOCC(OPTION)
      L2     = LENOCC(OPT)
      IF(L2.GE.L.AND.L1.GE.L) THEN
         RABBRE = INDEX(OPTION,OPT(1:L2)).EQ.1
      ELSE
         RABBRE = .FALSE.
      END IF
*
      RETURN
      END
+DECK,RADDOP.
      SUBROUTINE RADDOP(OPTION,OPT)
*.
*...RADDOP Utility function wich adds the one  character 'OPT'
*.         to the string 'OPTION' if not already there
*.
*. CALLS   : LENOCC
*. CALLED  : RIOFIL
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER OPTION*(*),OPT*1
      INTEGER   LENOCC,L
*
      L      = LENOCC(OPTION)
      IF(L.EQ.0) THEN
         OPTION = OPT
      ELSE IF(INDEX(OPTION,OPT).EQ.0) THEN
         OPTION = OPTION(1:L)//OPT
      END IF
*
      RETURN
      END
+DECK,RCLOSA.
      SUBROUTINE RCLOSA(LUN)
*.
*...RCLOSA Close an Alternative output file (for batch queries)
*.
*  SEQUENCE: DECLARE CRO RCSYST RCREP
*. CALLS   : REPORT RQSYST
*. CALLED  : ROPHON
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER LUN
*
+SEQ,CRO.
+SEQ,RCSYST.
+SEQ,RCREP.
*
+SELF,IF=IBM.
      CLOSE(LUN,ERR=10)
      SYSCOM = 'DISK DUMP ROPHONE LISTING'
      CALL RQSYST(.FALSE.)
      IF(SYSRC.NE.0)                                            GO TO 10
      SYSCOM = 'ERASE ROPHONE LISTING'
      CALL RQSYST(.FALSE.)
      IF(SYSRC.NE.0)                                            GO TO 10
                                                               GO TO 999
*
   10 CHREP='Problem while closing alternative output file'
      CALL REPORT('RCLOSA',1,'E')
+SELF.
*
  999 RETURN
      END
+DECK,RDDATA.
      FUNCTION RDDATA(IDUM)
*.
*...RDDATA Utility function to query presence of Dense Data.
*.
*.               RDDATA = 0 --> No Dense Data.
*.                      = 1 --> Dense Data for outer detectors
*.                      = 2 --> Dense Data for all detectors
*.
*. CALLS   :
*. CALLED  : USER
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.00
*. CREATED : 30-Aug-91
*. LAST MOD: 30-Aug-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER RDDATA,IDUM
*
+SEQ,ROBANK.
+SEQ,ROPAR.
*
      RDDATA = 0
      IF(LREV.LE.0)                                            GO TO 999
      LDD    = LQ(LREV-LLDD)
      IF(LDD.LE.0)                                             GO TO 999
      RDDATA = 1
      LDD    = LQ(LDD)
      IF(LDD.LE.0)                                             GO TO 999
      RDDATA = 2
*
  999 RETURN
      END
+DECK,RECREP.
      SUBROUTINE RECREP(CSEVER)
*.
*...RECREP --  Clear all errors of level CSEVER.
*.
*. INPUT   :  CSEVER a character constant, indicating the severity level
*.                   'SUCCESS', 'INFORMATION', 'WARNING', 'ERROR',
*.                   'FATAL', 'CRASH', '*' (clears all levels)
*.
*. SEQUENCE:  RCLINE RCREP REBANK
*. CALLS   :  RMAIL REPORT MZDROP
*.
*. AUTHOR  :  A.Buijs,S.Weisz
*. VERSION :  1.01
*. CREATED :  7-Sep-1987
*. LAST MOD:  8-Sep-1989
*.
*. Modification log:
*.  8-Sep-89  S.Weisz  Use REPORT store.
*. 30-Aug-88  S.Weisz  Add 'CRASH' severity level.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*(*) CSEVER
      INTEGER       LFIRST,INDEXA,LSEVER
*
+SEQ,RCLINE.
+SEQ,RCREP.
+SEQ,REBANK.
*
      IF(LREHD .LT. 1) THEN
         CHLINE = ' Message header bank not found'
         CALL RMAIL(0,0)
                                                               GO TO 999
      END IF
*-- Get the severity level from the first character of CSEVER. If it
*-- is zero, complain.
      LFIRST = MAX(INDEXA(CSEVER),1)
      LSEVER = INDEX('SIWEFC*',CSEVER(LFIRST:LFIRST))
      IF(LSEVER .EQ. 0) LSEVER = INDEX('siwefc',CSEVER(LFIRST:LFIRST))
      IF(LSEVER .EQ. 0) THEN
         CHREP = 'Unknown severity level : '//CSEVER
         CALL REPORT('RECREP',1,'E')
                                                               GO TO 999
      END IF
*-- Drop the header bank if all errors are to be cleared, else only the
*-- specific error banks.
      IF(LSEVER .EQ. 7) THEN
         CALL MZDROP(IRESTO,LREHD,'V')
         DO 10 LSEVER=1,6
   10    IR(LREHD+LSEVER) = 0
      ELSE
         CALL MZDROP(IRESTO,LR(LREHD-LSEVER),'.')
         IR(LREHD+LSEVER) = 0
      END IF
*
  999 RETURN
      END
+DECK,RECTOH.
      SUBROUTINE RECTOH(CROUT,CROUTX,ICROUT)
*.
*...RECTOH    Convert the Character name to a Hollerith variable.
*.
*. INPUT   :  CROUT  Character variable *(*)
*. OUTPUT  :  CROUTX Character variable *8
*. OUTPUT  :  ICROUT Hollerith of subroutine name
*. CALLS   :  UCTOH  INDEXA LENOCC CLTOU
*.
*. AUTHOR  :  A.Buijs
*. VERSION :  1.01
*. CREATED :  27-Mar-1988
*. LAST MOD:  29-Aug-1988
*.
*. Modification log:
*. 29-Aug-88  S.Weisz  Remove trailing characters.
*.  4-Jun-88  A.Buijs  Fill ICROUT with blanks.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*(*) CROUT
      CHARACTER*8   CROUTX
      INTEGER       ICROUT(2),LFIRST,LLAST,I,INDEXA,LENOCC
*
+SEQ,ROWORD.
*
      LFIRST = INDEXA(CROUT)
      LLAST  = LENOCC(CROUT)
      IF(LLAST.GE.8) LLAST=8
      CROUTX = '        '
      DO 10 I = LFIRST,LLAST
   10 CROUTX(I-LFIRST+1:I-LFIRST+1) = CROUT(I:I)
      CALL CLTOU(CROUTX)
      CALL UCTOH(CROUTX,ICROUT,NBYTEW,8)
*
      RETURN
      END
+DECK,REINIT.
      SUBROUTINE REINIT
*.
*...REINIT  Initialise REPORT.
*.
*. SEQUENCE:  REBANK RECNTL
*. CALLS   :  MZSTOR MZBOOK FFKEY
*.
*. AUTHOR  :  S.Weisz
*. VERSION :  1.01
*. CREATED :  8-Sep-1989
*. LAST MOD:  8-Fev-1991
*.
*. Modification log:
*.  8-Fev-91  S.Weisz  Preset IFBOOK to 1.
*.
*.*****************************************************************
+SEQ,DECLARE.
*
+SEQ,RCNTRL.
+SEQ,REBANK.
+SEQ,RECNTL.
*-- Initialize REPORT Zebra store
      CALL MZSTOR(IRESTO,'/REBANK/','.',FENDR,LR(1),LR(2),LR(2),
     +            LR(19990),LR(NREBRA-10))
      IREDIV = IRESTO + 2
*-- Book the header bank and define the format for the error banks.
*-- The format is: 4 Integers, 2 Holleriths, and
*-- then the message which has LCHREP characters (Holleriths).
      CALL MZBOOK(IREDIV,LREHD,LREHD,1,'REHD',6,6,6,2,0)
      CALL MZIOCH(IORWDS,10,'4I - H')
      IFBOOK    =       1
*-- Initialize and define Ffread card to control REPORT
      IFREPO    =       4
      NPRTMX(1) =       0
      CALL VFILL(NPRTMX(2),3,10)
      NPRTMX(5) =  999999
      NPRTMX(6) =       1
      CALL FFKEY('MESSAGE' ,IFREPO,     1,'INTEGER')
      CALL FFKEY('REPORT'  ,NPRTMX,     6,'INTEGER')
*
      RETURN
      END
+DECK,RENREP.
      SUBROUTINE RENREP(CROUT,IDMESS,NOCCUR)
*.
*...RENREP  Return the number of occurences of a message.
*.
*. SEQUENCE:  REBANK
*. CALLS   :  RECTOH
*.
*. AUTHOR  :  A.Buijs,S.Weisz
*. VERSION :  1.01
*. CREATED :  26-Mar-1988
*. LAST MOD:   8-Sep-1989
*.
*. Modification log:
*.  8-Sep-89  S.Weisz  Go to separate REPORT store.
*. 30-Aug-88  S.Weisz  Add 'CRASH' severity level.
*.
*.*****************************************************************
+SEQ,DECLARE.
*
      CHARACTER*(*) CROUT
      CHARACTER*8   CROUTX
      INTEGER       IDMESS,NOCCUR,ICROUT(2),LSEVER,LREC
*
+SEQ,REBANK.
*
      NOCCUR = 0
*-- In case IDMESS = 0 the error wasn't stored, so forget it.
      IF(IDMESS .EQ. 0)                                        GO TO 999
      IF(LREHD .LT. 1)                                         GO TO 999
*-- Remove possible spaces in the CROUT when it is converted to
*-- a hollerith constant. The maximum length should be 8 characters.
      CALL RECTOH(CROUT,CROUTX,ICROUT)
*-- Look in the statistics division whether the message was
*-- issued before; Loop over the severity levels.
      DO 20 LSEVER = 1,6
         LREC = LR(LREHD-LSEVER)
   10    IF(LREC .GT. 1) THEN
            IF(IR(LREC+1).NE.IDMESS.OR.IR(LREC+5).NE.ICROUT(1)
     +      .OR.IR(LREC+6).NE.ICROUT(2)) THEN
               LREC = LR(LREC)
                                                                GO TO 10
            END IF
*-- The message was found. Read the number of times it was issued.
            NOCCUR = IR(LREC+2)
         END IF
   20 CONTINUE
  999 RETURN
      END
+DECK,REPORT.
      SUBROUTINE REPORT(CROUT,IDMESS,CSEVER)
*.
*...REPORT --  message tallying routine.
*.
*. SEQUENCE:  ROBANK ROPAR RCNTRL REBANK RECNTL CRO ROWORD RCREP RCLINE
*. COMMON  :  QUEST ZTELLC
*. CALLS   :  RMAIL MZBOOK MZIOCH CLTOU UCTOH ZTELL ZTELUS
*.
*. AUTHOR  :  A.Buijs,S.Weisz
*. VERSION :  1.02
*. CREATED :  5-Sep-1987
*. LAST MOD:  22-Sept-1998
*.
*. Modification Log.
*. 22-Sept-98 E.Barberio Increase LCHEVT from 17 to 18 (increased run range)
*. 24-Aug-1998 E.Barberio modify REPORT to handle runs >10000
*. 28-Mar-96 O.Schaile Introduce TE process.
*.  3-Mar-93 O.Schaile  Introduce SW process.
*.  6-Mar-92 O.Schaile  RNOTIF did overwrtie CHREP, move call down
*. 17-Feb-92 C.Hawkes   update LUT before checking
*. 12-Dec-91 O.Schaile  define LCHEVT in every case
*. 23-Apr-91 S.Weisz    Severity level always handled in upper case.
*.  8-Mar-91 S.Weisz    Call ZTELUS in On-line mode.
*. 23-Jan-91 D.Lellouch Add 'Notify' severity level.
*.                      Same as 'W' but notify to job initiator.
*.  7-Jun-90 S.Weisz    Set STOP status
*.  8-Sep-89 S.Weisz    Separate store: Book header bank in REINIT.
*. 30-Jul-89 S.Weisz    Event number can go up to 999999.
*. 13-Jun-89 S.Weisz    Change name of REPORT banks.
*.  3-May-89 S.Weisz    Expt. number can go up to 9999.
*. 21-Mar-89 S.Weisz    Remove call to OCEND; Call ZTELL for
*.                      'FATAL' and 'CRASH' calls.
*.  7-Fev-89 S.Weisz    Set NQPHAS=-1 case, call OCEND before stop.
*. 25-Jan-89 S.Weisz    NPRTMX (No of printing) set by Ffread card.
*. 30-Aug-88 S.Weisz    'FATAL' and 'CRASH' will skip event and
*.                      abend the job.
*.  4-Jun-88 A.Buijs    Fix bug in printing CROUT(1:6)
*.  7-May-88 A.Buijs    Add event information and error number.
*.  6-May-88 A.Buijs    Don't book an event bank for SUCCESS and INFO.
*.  7-Dec-87 S.Weisz    Use parameter sequences ROPAR,GOPAR.
*.
*.  To do:
*.         4. Allow for change of severity.
*.
*.*****************************************************************
+SEQ,DECLARE.
*
      CHARACTER*(*) CSEVER
      CHARACTER*(*) CROUT
      CHARACTER*20  CHHEAD,CHEVT
      CHARACTER*8   CROUTX
      CHARACTER*4   CHIDME(6),CHIDMS(6), CHID
      CHARACTER*1   CSEV
      SAVE          CHIDME   ,CHIDMS
      INTEGER       IDMESS,LSEVER,LENOCC,LCHREP,LCHEAD,LCHEVT
      INTEGER       ICROUT(2),I,NDAT,LFIRST,INOTIF
      INTEGER       LREHE,LREC,LREE,INDEXA
*
      INTEGER      IQUEST
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,RCNTRL.
+SEQ,REBANK.
+SEQ,RECNTL.
+SEQ,ROWORD.
+SEQ,CRO.
+SEQ,RCREP.
+SEQ,RCLINE.
*
+SELF,IF=ONLINE.
*
      INTEGER ID,MODE
      COMMON/ZTELLC/ID,MODE
*
      CHARACTER*2 PRONAM
      DIMENSION   PRONAM(40)
      SAVE        PRONAM
      DATA PRONAM/'RO','GR','US','CV','CJ','CZ','CT','CX','CE','TB',
     +            'PB','EB','PE','EE','EM','HB','HE','HP','HM','MB',
     +            'ME','MM','FD','DD','OD','OU','OC','TT','TR','FI',
     +            'ON','JC','SU','OP','DX','SI','CS','LL','SW','TE'/
+SELF.
*
      DATA          CHIDME/'RSUE','RINE','RWAE','RERE','RFAE','RCRE'/
      DATA          CHIDMS/'RSUS','RINS','RWAS','RERS','RFAS','RCRS'/
*-- In case IDMESS = 0, don't tally, but print rightaway.
      IF(IDMESS .EQ. 0) THEN
         CHLINE = ' '//CHREP
         CALL RMAIL(0,0)
                                                               GO TO 999
      END IF
*-- If there is no REPORT top bank, complain and print the message
*-- without tallying.
      LCHREP = LENOCC(CHREP)
      IF(LREHD .LT. 1) THEN
         CHLINE = ' REPORT-E- No REPORT header bank.'
         CALL RMAIL(0,0)
         WRITE(CHLINE,1000)CROUT,IDMESS,CHREP(1:LCHREP)
         CALL RMAIL(0,0)
                                                               GO TO 999
      END IF
*-- Remove possible spaces in the CROUT when it is converted to
*-- a hollerith constant. The maximum length should be 8 characters.
      CALL RECTOH(CROUT,CROUTX,ICROUT)
*-- Get the severity level from the first character of CSEVER. If it
*-- is zero, make it an informational message type. Establish the
*-- number of data words and the bank identifier.
      INOTIF = 0
*-- Transform to upper case, so it gets filtered on-line.
      LFIRST = MAX(INDEXA(CSEVER),1)
      CSEV   = CSEVER(LFIRST:LFIRST)
      CALL CLTOU(CSEV)
      LSEVER = INDEX('SIWEFCN',CSEV)
C     IF(LSEVER .EQ. 0) LSEVER = INDEX('siwefcn',CSEVER(LFIRST:LFIRST))
      IF(LSEVER .EQ. 0) LSEVER = 2
      IF(LSEVER .EQ. 7) THEN
*-- This message will be "Notified".
         INOTIF = 1
         LSEVER = 3
      END IF
      NDAT = 4 + 2 + (LCHREP+NBYTEW-1)/NBYTEW
      CHID = CHIDMS(LSEVER)
*-- Look whether the message was issued before.
      LREC = LR(LREHD-LSEVER)
   10 IF(LREC .GT. 1) THEN
         IF(IR(LREC+1).NE.IDMESS.OR.IR(LREC+5).NE.ICROUT(1).OR.
     +   IR(LREC+6).NE.ICROUT(2)) THEN
            LREC = LR(LREC)
                                                                GO TO 10
         END IF
*-- The message was found. Just increment the counter.
         IR(LREC+2) = IR(LREC+2) + 1
      ELSE
*-- This is a new message, check if we can store it.
         CALL MZNEED(IREDIV,NDAT+10,'G')
         IF(IQUEST(11).LT.0) THEN
            CHLINE = ' REPORT-W- No space to tally the message'
            CALL RMAIL(0,0)
            WRITE(CHLINE,1000)CROUT,IDMESS,CHREP(1:LCHREP)
            CALL RMAIL(0,0)
                                                               GO TO 999
         END IF
         CALL MZBOOK(IREDIV,LREC,LREHD,-LSEVER,CHID,0,0,NDAT,IORWDS,4)
         IR(LREC+1) = IDMESS
         IR(LREC+2) = 1
         IR(LREC+5) = ICROUT(1)
         IR(LREC+6) = ICROUT(2)
         CALL UCTOH(CHREP,IR(LREC+7),NBYTEW,LCHREP)
      END IF
      IR(LREHD+LSEVER) = IR(LREHD+LSEVER) + 1
*-- Decide whether to print the error or not. Issue a message
*-- if it will not be printed anymore.
      IF(IR(LREC+2).EQ.NPRTMX(LSEVER)) THEN
         WRITE(CHLINE,1010) IR(LREC+2)
         CALL RMAIL(0,0)
      END IF
*-- Build a header, check whether everything fits on one line.
*-- If not, write it on two lines. Is IRDEXP in GOPAL?
      IF(IR(LREC+2).LE.NPRTMX(LSEVER)) THEN
         LCHEAD=15
         LCHEVT=4
         CHEVT(1:4)='    '
         WRITE(CHHEAD,1020,ERR=20)CROUTX(1:6),IDMESS,CSEV
         IF(LREV.GT.1) THEN
            WRITE(CHEVT,1030,ERR=20)IRDEXP,IRDRUN,IRDEVT
            LCHEVT=18
         END IF
   20    IF(LCHEAD+LCHEVT+LCHREP .LT. 130) THEN
            CHLINE=CHHEAD(1:LCHEAD)//CHEVT(1:LCHEVT)//'  '// CHREP
     +      (1:LCHREP)
            CALL RMAIL(0,0)
         ELSE
            CHLINE=CHHEAD(1:LCHEAD)//CHEVT(1:LCHEVT)
            CALL RMAIL(0,0)

            CHLINE=' '//CHREP(1:LCHREP)
            CALL RMAIL(0,0)
         END IF
*-- Notify to caller if asked.
         IF(INOTIF.EQ.1) CALL RNOTIF
      END IF
*-- Store the message in event division according to IFREPO and IFBOOK.
      IF(IFBOOK.LE.0)                                          GO TO 999
      IF(LSEVER.LT.IFREPO.OR.IFREPO.LE.0)                       GO TO 50
*-- Check if there is an event, check if it has a utility header.
      IF(LREV.LT.1)                                             GO TO 50
*-- Update LUT before checking (necessary if REPORT called from QNEXT)
      LUT = LQ(LREV-LLUT)
      IF (LUT.LT.1) CALL MZBOOK(IRODIV,LUT,LREV,-LLUT,'UT  ',
     +  NLUT,NSUT,NDUT,IOUT,0)
*-- Check if there is a error header bank hanging from the utility
*-- bank. If not, book it.
      LREHE = LQ(LUT-LLREHE)
      IF(LREHE.LT.1) CALL MZBOOK(IRODIV,LREHE,LUT,-LLREHE,'REHE',6,6,
     +6,2,0)
*-- Look whether the message was issued before.
      LREE = LQ(LREHE-LSEVER)
   30 IF(LREE .GT. 1) THEN
         IF(IQ(LREE+1).NE.IDMESS.OR.IQ(LREE+5).NE.ICROUT(1).OR.
     +   IQ(LREE+6).NE.ICROUT(2)) THEN
            LREE = LQ(LREE)
                                                                GO TO 30
         END IF
*-- The message was found. Just increment the counter.
         IQ(LREE+2) = IQ(LREE+2) + 1
      ELSE
*-- This is a new message, book the error bank and copy the message
*-- from the REPORT division.
         CHID = CHIDME(LSEVER)
         CALL MZBOOK(IRODIV,LREE,LREHE,-LSEVER,CHID,0,0,NDAT,IORWDS,4)
         DO 40 I = 1,NDAT
   40    IQ(LREE+I) = IR(LREC+I)
      END IF
      IQ(LREHE+LSEVER) = IQ(LREHE+LSEVER) + 1
   50 CONTINUE
*-- Now check if we have 'FATAL' or 'CRASH' calls.
+SELF,IF=ONLINE.
      IF(LSEVER.LE.4)                                          GO TO 999
      DO 60 I = 1,39
      IF(CROUT(1:2).EQ.PRONAM(I))                               GO TO 70
   60 CONTINUE
      IF(CROUT(1:1).EQ.'R') I      = 1
   70 ID     = 100 + I
      CALL ZTELUS
+SELF,IF=-ONLINE.
      IF(LSEVER.EQ.5) THEN
         CALL ZTELL(101,0)
      ELSE IF(LSEVER.EQ.6) THEN
         CALL ZTELL(102,0)
         NSTOP = 3
      END IF
+SELF.
*
  999 RETURN
 1000 FORMAT(' ',A,I6,'-',A)
 1010 FORMAT(' REPORT-I- The following message was issued ',I5,
     +' times and will be suppressed : ')
 1020 FORMAT(' ',A6,'-',I4,'- ',A1)
 1030 FORMAT(' ',I4,'/',I5,'/',I6)
      END
+DECK,REPREP.
      SUBROUTINE REPREP(CSEVER)
*.
*...REPREP --  Print a tally of all messages of level CSEVER.
*.
*. INPUT   :  CSEVER a character constant, indicating the severity level
*.                   'SUCCESS', 'INFORMATION', 'WARNING', 'ERROR',
*.                   'FATAL', 'CRASH', '*' (prints all levels)
*.
*. SEQUENCE:  REBANK ROWORD RCREP RCLINE
*. CALLS   :  REPORT RMAIL UHTOC
*.
*. AUTHOR  :  A.Buijs
*. VERSION :  1.01
*. CREATED :  7-Sep-1987
*. LAST MOD: 13-Apr-1991
*.
*. Modification log:
*. 13-Apr-91  S.Weisz  Print more than 52 caracters.
*.  8-Sep-89  S.Weisz  REPORT messages tallied in REPORT store.
*. 21-Mar-89  S.Weisz  Modify output format, sort in alphabetical order.
*. 30-Aug-88  S.Weisz  Add 'CRASH' severity level.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      CHARACTER*(*) CSEVER
      CHARACTER*12  CSEVRX(6)
      SAVE          CSEVRX
      INTEGER       LFIRST,INDEXA,LSEVER,LVL,NTXT,I,LRE
*
+SEQ,REBANK.
+SEQ,ROWORD.
+SEQ,RCREP.
+SEQ,RCLINE.
*
      DATA CSEVRX/'SUCCESSes','INFORMATIONs','WARNINGs', 'ERRORs',
     +'FATALs','CRASHes'/
      IF(LREHD.LT.1) THEN
         CHLINE = 'Message header bank not found'
         CALL RMAIL(0,0)
                                                               GO TO 999
      END IF
*-- Get the severity level from the first character of CSEVER. If it
*-- is zero, complain.
      LFIRST = MAX(INDEXA(CSEVER),1)
      LSEVER = INDEX('SIWEFC*',CSEVER(LFIRST:LFIRST))
      IF(LSEVER.EQ.0) LSEVER = INDEX('siwefc',CSEVER(LFIRST:LFIRST))
      IF(LSEVER.EQ.0) THEN
         CHREP = 'Unknown severity level : '//CSEVER
         CALL REPORT('REPREP',1,'E')
                                                               GO TO 999
      END IF
*-- Print up to a maximum of 60 characters.
      WRITE(CHLINE,1000)
      CALL RMAIL(1,0)
      DO 20 I = 1,6
         LVL = 7-I
         IF(LSEVER.NE.7.AND.LVL.NE.LSEVER)                      GO TO 20
         LRE = LR(LREHD-LVL)
         IF(LRE.GT.1) THEN
            WRITE(CHLINE,1010) CSEVRX(LVL)
*-- Sort messages in alphabetical order of calling routines.
            CALL RMAIL(1,1)
            CALL ZSORVH(IRESTO,LRE,5,2)
         END IF
   10    IF(LRE.GT.1) THEN
            NTXT = MIN((IR(LRE-1)-4)*NBYTEW,132)
            CALL UHTOC(IR(LRE+5),NBYTEW,CHREP,NTXT)
            IF(NTXT.LE.60) THEN
               WRITE(CHLINE,1020)IR(LRE+2),CHREP(1:6),CSEVRX(LVL)(1:1),
     +                                     CHREP(2*NBYTEW+1:NTXT)
               CALL RMAIL(0,0)
            ELSE
               WRITE(CHLINE,1020)IR(LRE+2),CHREP(1:6),CSEVRX(LVL)(1:1),
     +                                     CHREP(2*NBYTEW+1:60)
               CALL RMAIL(0,0)
               WRITE(CHLINE,1030)          CHREP(61:NTXT)
               CALL RMAIL(0,0)
            END IF
            LRE = LR(LRE)
                                                                GO TO 10
         END IF
   20 CONTINUE
      WRITE(CHLINE,1040)IR(LREHD+1),CSEVRX(1)
      CALL RMAIL(1,0)
      DO 30 I = 2,6
         WRITE(CHLINE,1050)IR(LREHD+I),CSEVRX(I)
         CALL RMAIL(0,0)
   30 CONTINUE
      WRITE(CHLINE,1060)
      CALL RMAIL(1,1)
*
  999 RETURN
 1000 FORMAT(' ',27('-'),' Report message summary ',27('-'))
 1010 FORMAT('     ','Messages to REPORT qualified as ',A,':')
 1020 FORMAT(' ',I6,' ',A,' ',A,' ',A)
 1030 FORMAT('                 ',A)
 1040 FORMAT('  Total of     ',I6,' ',A)
 1050 FORMAT('               ',I6,' ',A)
 1060 FORMAT(' ',78('-'))
      END
+DECK,REVTYP.
      LOGICAL FUNCTION REVTYP(IEVTYP)
*.
*...REVTYP   Tests event type
*.
*. INPUT   : IEVTYP  pointer to bits in event type words as defined
*.                   in sequence ROTPAR. Valid range 1-64.
*.
*. SEQUENCE: CRO ROPAR RBITFUNC RCREP
*. CALLED  : user
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.00
*. CREATED : 16-Apr-91
*. LAST MOD: 27-Aug-91
*.
*. Modification Log.
*. 27-Aug-91  S.Weisz        Use RBITFUNC sequence
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,RBITFUNC.
+SEQ,RCREP.
*
      INTEGER IEVTYP,IEVMIN,IEVMAX
*-- Valid range of input argument
      PARAMETER (IEVMIN=1,IEVMAX=64)
*-- Initialise return value
      REVTYP = .FALSE.
*-- Check for valid input argument (index sum within allowed range)
      IF(IEVTYP.LT.IEVMIN.OR.IEVTYP.GT.IEVMAX) THEN
         WRITE(CHREP,1001) IEVTYP,IEVMIN,IEVMAX
         CALL REPORT('REVTYP',1,'E')
      ELSE IF(IEVTYP.LE.32) THEN
*-- Check bit in event type words
         REVTYP = BTEST(IUHEAD(IIEVTY),IEVTYP-1)
      ELSE
         REVTYP = BTEST(IUHEAD(IIEVT2),IEVTYP-33)
      ENDIF
*
  999 RETURN
*
 1001 FORMAT(' Input argument=',I6,' outside valid range',I2,':',I2)
*
      END
+DECK,RGETEB.
      SUBROUTINE RGETEB(EBEAM,SYSEB,LEPFIL)
*.
*...RGETEB  Returns corrected beam energy for an event,
*.          and its systematic error and LEP fill number,
*.          based on OPAL run and event number in header.
*.
*. OUTPUT  : EBEAM  Corrected beam energy for event (GeV)
*.           SYSEB  Absolute systematic error on beam energy (GeV)
*.           LEPFIL LEP fill number
*.
*. SEQUENCE:
*. CALLS   : SUEBEA
*. CALLED  : RGETDA ROLUMI ODGNRL USHEAD USBAT (user)
*.
*. WARNING : This routine may be called from USHEAD.
*.           It can use only data available in the event header.
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 2.01
*. CREATED : 20-Feb-90
*. LAST MOD: 07-Jun-90
*.
*. Modification Log.
*.  07-Jun-90  C.Hawkes     Moved from ROPE310 pam to SU102 pam and
*.                            renamed from RGETEB to SUEBEA.
*.                            RGETEB now calls SUEBEA in SU pam.
*.  06-Jun-90  C.Hawkes     Update for fills up to number 304
*.  04-Jun-90  C.Hawkes     Change 1990 correction factor to -7.0E-4
*.  04-Apr-90  C.Hawkes     Update for 1990 fills up to number 200
*.  26-Mar-90  C.Hawkes     Return LEP fill number from header
*.                           if run number outside range
*.  05-Mar-90  C.Hawkes     Speed up the loop over LEP fills
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      REAL       EBEAM,SYSEB
      INTEGER    LEPFIL
*
*-- Get latest beam energy update from SU pam
      CALL SUEBEA(EBEAM,SYSEB,LEPFIL)
*
      RETURN
      END
+DECK,RGETLU.
      SUBROUTINE RGETLU(EBEAM,EVLUM,SYSLUM,PTPLUM)
*.
*...RGETLU  Returns luminosity for a forward detector Bhabha event
*           and its systematic errors
*.
*.  INPUT  :  EBEAM Beam energy for event (GeV)
*. OUTPUT  :  EVLUM Luminosity for event (1/nb)
*.           SYSLUM Absolute systematic error on luminosity (1/nb)
*.           PTPLUM Point-to-point fractional systematic error on lumi
*.                  (all returned as 0 if not a luminosity event)
*.
*. SEQUENCE: CRO ROPAR ROTPAR RBITFUNC RCREP
*. CALLS   : REPORT
*. CALLED  : ROLUMI
*.
*. WARNING : This routine may be called from USHEAD.
*.           It can use only data available in the event header.
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.00
*. CREATED : 05-Mar-90
*. LAST MOD: 6-May-93
*.
*. Modification Log.
*.  6-May-93  M. thomson       Separate normalization for fills 895-922
*.                             needed becasue of bad calib.
*.  6-May-93  M. Thomson and   Photon-Z0 interference from BHGEN (equiv.
*.            G. Quast         BABAMC) put in for all years; norma-
*.                             lization is for vanishing correction at
*.                             the peak.
*.   5-Feb-93  M.Thomson       Rescale X-sec for preliminary 1992 (51.163 nb).
*.                             NB: Only appropriate for PASS3 calibration.
*.                             Total Error = 0.6 % (includes theory).
*.                             Zg interference correction to BHLUMI is
*.                             valid ONLY at the peak.
*.  20-Jan-93  C.Grandi        rescale X-sec for 1991 (50.816 nb)
*.   7-Dec-91  G.M.DallaValle  Fill by fill corrections to Xsec 91;
*.                             New corrections for EW interference.
*.  27-Aug-91  S.Weisz         Use RBITFUNC sequence
*.  14-Aug-91  C.Grandi        Switch to TOTBAR selection method
*.  14-Feb-91  G.M.Dallavalle  rescale X-sec for pass2 and pass3 data
*.                             and change sys error (0.8%)
*.  21-Nov-90  G.M.Dallavalle  new X-sec for Rope312 lumi (42.933 nb)
*.  21-Nov-90  G.M.Dallavalle  rescale X-sec for 1990 data (43.294 nb)
*.                             and change sys error (1.0%)
*.  01-Nov-90  I. Wingerter    Lumi as a function of ROPE version
*.             C. Hawkes       MC has exp.num.GE.1000 (not .GT.1000)
*.  13-Sep-90  I. Wingerter    add interference effect correction
*.  12-Sep-90  G.M.Dallavalle  more X-secs for 1990
*.  21-Jul-90  G.M.DallaValle  modify X-sec for 1990 data
*.  23-Mar-90  C.Hawkes     Count bits 1-32 (OPAL) not 0-31 (FORTRAN)
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROTPAR.
+SEQ,RBITFUNC.
+SEQ,RCREP.
*
      REAL         EBEAM,EVLUM,SYSLUM,PTPLUM
*
      INTEGER      NBINX,NBINX1,NBINX2,NBINXL
      PARAMETER   (NBINX1=14,NBINX2=10)
*     nbinx is the biggest of the 2 NBINX1,NBINX2
      PARAMETER   (NBINX=NBINX1)
      INTEGER      LRUNX1(NBINX1),LRUNX2(NBINX2),LRUNX(NBINX)
      INTEGER      IBITX1(NBINX1),IBITX2(NBINX2),IBITXL(NBINX)
      REAL         XSECT1(NBINX1),XSECT2(NBINX2),XSECTL(NBINX)
      REAL         XEBEA1(NBINX1),XEBEA2(NBINX2),XEBEAM(NBINX)
      REAL         SYSER1(NBINX1),SYSER2(NBINX2),SYSERR(NBINX)
      REAL         PTPER1(NBINX1),PTPER2(NBINX2),PTPERR(NBINX)
      SAVE         LRUNX,IBITXL,XSECTL,XEBEAM,SYSERR,PTPERR
      SAVE         LRUNX1,IBITX1,XSECT1,XEBEA1,SYSER1,PTPER1
      SAVE         LRUNX2,IBITX2,XSECT2,XEBEA2,SYSER2,PTPER2
      CHARACTER*11 UPDATE
      SAVE         UPDATE
      INTEGER      IRUN,IRVER,IROPIN,IBIN,IBINX,LRUN,LRVER,LROPIN
      INTEGER      IROLIM
      LOGICAL      FIRST
      SAVE         LRUN,IBINX,FIRST,LRVER,LROPIN,IROLIM,NBINXL
* For interference correction
      INTEGER NPOINT,IP,INDEX
      PARAMETER (NPOINT=14)
      REAL EBGEN(NPOINT),CORINT(NPOINT),CORI,A,EBEAMS
      SAVE EBGEN        ,CORINT        ,CORI  ,EBEAMS
* Date of last update to this routine
      DATA         UPDATE/'6-May-1993'/
************************************************************************
*                                                                      *
*                  DATA for Rope 311                                   *
*                (overall version < 571)                               *
*                                                                      *
************************************************************************
* Last OPAL run for which effective cross section in XSECTL applies
      DATA         LRUNX1/   1380,1418,1498,1839,1844,1846,
     +                      1872,1878,1882,1897,1924,1942,
     +                      1974,999999 /
* Cross section for Emainbar FD Bhabha events at EBEAM=46 GeV (nb)
      DATA         XSECT1/40.227,42.909,42.978,42.764,43.065,42.892,
     +                    43.022,42.850,43.327,42.892,43.152,42.806,
     +                    41.925,42.764/
* Beam energy at which cross section in XSECTL is calculated (GeV)
      DATA         XEBEA1/ NBINX1*46.00 /
* Bit number in Event Type word for Bhabha type used for cross section
      DATA         IBITX1/NBINX1*IELUEM/
* Fractional overall systematic error on luminosity calculation
      DATA         SYSER1/0.0220,0.0220,12*0.008/
* Beam energy point-to-point fractional systematic error on luminosity
      DATA         PTPER1/0.0100,0.0100,12*0.001/
************************************************************************
*                                                                      *
*                  DATA for Rope 312                                   *
*                (overall version >=571)                               *
*                                                                      *
************************************************************************
* Last OPAL run for which effective cross section in XSECTL applies
      DATA         LRUNX2/   1380,1418,2204,2460,2468,2475,2584,
     +                    3024,3055,999999/
* Cross section for Emainbar FD Bhabha events at EBEAM=46 GeV (nb)
      DATA         XSECT2/40.227,42.909,42.407,50.816,
     +                    50.104,50.308,50.816,50.816,
     +                    48.690,51.163/
* Beam energy at which cross section in XSECTL is calculated (GeV)
      DATA         XEBEA2/ NBINX2*46.00 /
* Bit number in Event Type word for Bhabha type used for cross section
      DATA         IBITX2/3*IELUEM,7*IELUET/
* Fractional overall systematic error on luminosity calculation
      DATA         SYSER2/0.0220,0.0220,0.008,0.0067,
     +                    0.0067,0.0067,0.0067,0.0067,0.0060,0.0060 /
* Beam energy point-to-point fractional systematic error on luminosity
      DATA         PTPER2/0.0100,0.0100,0.001,0.001,
     +                    0.001,0.001,0.001,0.001,0.001,0.001 /
************************************************************************
*
*        overall rope version number for change
*        from ROPE311 to ROPE312 (Nov-Dec 1990 reROPE)
*
      DATA         IROLIM/571/
      DATA         LROPIN/0/
************************************************************************
*
* For interference correction
*
      DATA EBGEN/40.,43.55,44.05,44.55,45.05,45.25,45.55,
     +               45.75,46.05,46.55,47.05,47.55,50.00,55. /
CX    OLD BHLUMI INTRFERENCE, WRONG!
CX    DATA CORINT/1.,1.003,1.005,1.006,1.007,1.006,1.000,
CX   +               0.995,0.991,0.992,0.994,0.995,0.998,1. /
C BHGEN*1.0024 (HAS A NON-VANISHING CONTRIBUTION AT THE PEAK)
CX    DATA CORINT/1.0000,1.004,1.005,1.0065,1.0077,1.0067,1.0024,
CX   +            0.9984,0.9947,0.9938,0.9947,0.9959,0.9980,1.0000/
C BHGEN, NORMALIZED TO THE PEAK
      DATA CORINT/0.9976,1.0016,1.0026,1.0041,1.0053,1.0043,1.0000,
     +            0.9960,0.9923,0.9914,0.9923,0.9935,0.9956,0.9976 /
*                                               BMC    BHL
      DATA         FIRST/.TRUE./
      DATA EBEAMS,CORI/45.55,1./
*
* For Monte Carlo events just return zero
      IF(IUHEAD(IIEXPT).GE.1000)THEN
        EVLUM=0.
        SYSLUM=0.
        PTPLUM=0.
        RETURN
      ENDIF
*
* On first call print date of last update to this routine
      IF(FIRST)THEN
        FIRST=.FALSE.
        WRITE(CHREP,1000)UPDATE
        CALL REPORT('RGETLU',1,'I')
        LRUN=0
        LRVER=0
        LROPIN=0
      ENDIF
*
*-- Get run number from header
      IRUN=IUHEAD(IIRUN)
*-- Get Rope number from header
      IRVER=IUHEAD(IIPVER)
*-- If ROPE number unchanged since last call, skip the loop
*-- Otherwise, get new cross-sections numbers
      IF(IRVER.NE.LRVER) THEN
       LRVER=IRVER
       IROPIN=2
       IF(IRVER.LT.IROLIM) IROPIN=1
       IF(IROPIN.NE.LROPIN) THEN
        LROPIN=IROPIN
        IF(IROPIN.EQ.1) THEN
         NBINXL=NBINX1
         CALL UCOPY(LRUNX1,LRUNX, NBINX1)
         CALL UCOPY(IBITX1,IBITXL,NBINX1)
         CALL UCOPY(XEBEA1,XEBEAM,NBINX1)
         CALL UCOPY(XSECT1,XSECTL,NBINX1)
         CALL UCOPY(PTPER1,PTPERR,NBINX1)
         CALL UCOPY(SYSER1,SYSERR,NBINX1)
        ELSEIF(IROPIN.EQ.2) THEN
         NBINXL=NBINX2
         CALL UCOPY(LRUNX2,LRUNX, NBINX2)
         CALL UCOPY(IBITX2,IBITXL,NBINX2)
         CALL UCOPY(XEBEA2,XEBEAM,NBINX2)
         CALL UCOPY(XSECT2,XSECTL,NBINX2)
         CALL UCOPY(PTPER2,PTPERR,NBINX2)
         CALL UCOPY(SYSER2,SYSERR,NBINX2)
        ENDIF
        IF(IRUN.NE.LRUN)THEN
         LRUN=IRUN
        ENDIF
*-- Get correct luminosity bin number for this run number
        DO 10 IBIN=1,NBINXL
          IF(IRUN.LE.LRUNX(IBIN))THEN
           IBINX=IBIN
           GOTO 20
          ENDIF
   10   CONTINUE
   20   CONTINUE
       ENDIF
      ENDIF
*
*-- If run number unchanged since last call, skip the loop
*
      IF(IRUN.NE.LRUN)THEN
        LRUN=IRUN
*-- Get correct luminosity bin number for this run number
        DO 50 IBIN=1,NBINXL
          IF(IRUN.LE.LRUNX(IBIN))THEN
            IBINX=IBIN
            GOTO 60
          ENDIF
   50   CONTINUE
   60   CONTINUE
      ENDIF
*
* Compute interference correction if beam energy changed
*
      IF(EBEAM.NE.EBEAMS) THEN
       EBEAMS=EBEAM
       INDEX=0
       CORI=1.
       DO 100 IP=1,NPOINT-1
         IF(EBEAM.GE.EBGEN(IP).AND.EBEAM.LT.EBGEN(IP+1)) THEN
          INDEX=IP
          GOTO 101
         ENDIF
 100   CONTINUE
 101   IF(INDEX.GT.0) THEN
        A=(CORINT(INDEX+1)-CORINT(INDEX))/(EBGEN(INDEX+1)-EBGEN(INDEX))
        CORI=CORINT(INDEX) + A*(EBEAM-EBGEN(INDEX))
       ELSE
        IF(EBEAM.LT.EBGEN(1).OR.EBEAM.GT.EBGEN(NPOINT)) CORI=1.
       ENDIF
       IF(CORI.EQ.0.) THEN
        WRITE(CHREP,1001)
        CALL REPORT('RGETLU',2,'W')
        CORI=1.
       ENDIF
      ENDIF
*-- Check whether this is a luminosity event
*-- (-1 from bit index to go from OPAL 1-32 to FORTRAN 0-31 convention)
      IF(BTEST(IUHEAD(IIEVTY),IBITXL(IBINX)-1))THEN
*-- Get luminosity/event (1/cross section) corrected for beam energy
        EVLUM=(EBEAM/XEBEAM(IBINX))**2/(XSECTL(IBINX)*CORI)
        SYSLUM=EVLUM*SYSERR(IBINX)
        PTPLUM=PTPERR(IBINX)
      ELSE
*-- Not a luminosity event. Return luminosity and error as zero.
        EVLUM=0.
        SYSLUM=0.
        PTPLUM=0.
      ENDIF
*
      RETURN
*
 1000 FORMAT(' Luminosity calculation last updated ',A11)
 1001 FORMAT(' Pb with Interference correction (=0)')
*
      END
+DECK,RGETNB.
      SUBROUTINE RGETNB(LIST,N)
*.
*...RGETNB   Count the number of first non zero elements in array LIST.
*.
*. INPUT   : LIST    Array to count number of non zero elements.
*. OUTPUT  : N       Number of non zero elements.
*.
*. CALLED  : RFLSET
*.
*. AUTHOR  : R.Brun
*. VERSION : 1.01
*. CREATED : ?
*. LAST MOD: 3-Aug-93
*.
*. Modification Log.
*.  3-Aug-93  O.Schaile      SAVE IDFLT
*. 18-May-87  S.Weisz        Also work on array of integer.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LIST(*),IFIRST,IDFLT,N,I
      SAVE IFIRST, IDFLT
      DATA IFIRST/0/
*
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH('    ',IDFLT,4,4)
      ENDIF
*
      N = 0
      DO 10 I=1,20
         IF(LIST(I).EQ.IDFLT)                                  GO TO 999
         IF(LIST(I).EQ.0)                                      GO TO 999
         N=N+1
   10 CONTINUE
*
  999 RETURN
      END
+DECK,RGETNO,IF=VAX.
      SUBROUTINE RGETNO(NODNAM)
*.
*...RGETNO returns the name of the node
*.
*. OUTPUT    : NODNAM is a 15 character string
*.
*. CALLS     : SYS$GETSYI
*. CALLED    : .....
*.
*. AUTHOR    : F.Odorici
*. VERSION   : 1.00
*. CREATED   :  5-Nov-1990
*. LAST MOD  :  5-Nov-1990
*.
*. Modification log:
*.   5-Nov-90 F.Odorici  Create this routine
*.
*.********************************************************************
+SEQ,DECLARE.
*
      INTEGER ITMCOD,NAMLEN,GINFO
      CHARACTER NODNAM*15
      INCLUDE '($SYIDEF)'
      INTEGER SYS$GETSYI
*-- Definition of one item for the $GETSYI item list.
      STRUCTURE /GITEM/
       UNION
        MAP
         INTEGER*2 BUFLEN
         INTEGER*2 CODE
         INTEGER*4 BUFADR
         INTEGER*4 RLEADR
        END MAP
        MAP
         INTEGER*4 ENDLIS
        END MAP
       END UNION
      END STRUCTURE
      RECORD /GITEM/ GPAR(2)
*
      GPAR(1).BUFLEN = 15
      GPAR(1).CODE   = SYI$_NODENAME
      GPAR(1).BUFADR = %LOC(NODNAM)
      GPAR(1).RLEADR = %LOC(NAMLEN)
      GPAR(2).ENDLIS = 0
*
      GINFO  = SYS$GETSYI( , , ,GPAR, , , )
      IF(NAMLEN.LT.15) NODNAM(1+NAMLEN:15) = ' '
*
      RETURN
      END
+DECK,RGTLUN,IF=IBM.
      SUBROUTINE RGTLUN(LUN)
*.
*...RGTLUN returns a free logical unit
*.
*. CALLS   :
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER I,LUN
      LOGICAL OPENED
*
      DO 10 I = 1,99
      INQUIRE(I,OPENED=OPENED)
      IF(.NOT.OPENED)                                           GO TO 20
   10 CONTINUE
      I      = 0
   20 LUN    = I
*
      RETURN
      END
+DECK,RIBMOP,IF=IBM.
      SUBROUTINE RIBMOP(CFNAME,CFSTAT,XXOPEN)
*.
*...RIBMOP Prepare file opening for Ibm.
*.         Access minisdisk if necessary
*.         Return simple fine name
*.
*. SEQUENCE: RCNTRL RCSYST RCREP
*. CALLS   : RGIMED RQSYST SPACES
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*80  CFNAME,COMMAN,SPACES
      CHARACTER*4   CFSTAT
      CHARACTER*1   MODE
      LOGICAL       XXOPEN
      INTEGER       I,W,L
      INTEGER       RWORDS,LENOCC
      EXTERNAL      RWORDS,LENOCC
+SEQ,RCNTRL.
+SEQ,RCREP.
+SEQ,RCSYST.
*-- Does the file name starts with a [user.adr] pattern ?
      IF(CFNAME(1:1).EQ.'[') THEN
         I      = INDEX(CFNAME,']')
         IF(I.EQ.0) THEN
            CHREP  = 'Unbalanced "["'
            CALL REPORT('RIMBOP',1,'E')
                                                               GO TO 999
         END IF
         CALL RGIMED(CFNAME(2:I-1),MODE)
         IF(MODE.EQ.' ')                                       GO TO 999
         COMMAN = CFNAME(I+1:NAMLEN)
         COMMAN = SPACES(COMMAN,1)
         CFNAME = COMMAN
      ELSE
         IF(CFSTAT.EQ.'NEW ') THEN
*-- In write mode, add an 'A' disk mode if necessary
            MODE   = 'A'
         ELSE
*-- If the file is to be opened as 'OLD' or 'UPDATE'
*-- its name must be of the form 'Fname Ftype *' !!!
            MODE   = '*'
         END IF
      END IF
      W      = RWORDS(CFNAME)
      IF(W.LE.1)                                               GO TO 999
      IF(XXOPEN) THEN
*-- Replace ' ' by '.' and add Filemode if not '*'.
         CFNAME = SPACES(CFNAME,1)
         L      = LENOCC(CFNAME)
         DO 10 I=1,L
         IF(CFNAME(I:I).EQ.' ') CFNAME(I:I) = '.'
   10    CONTINUE
         IF(W.EQ.2) CFNAME(L+1:L+2) = '.'//MODE
      ELSE
         IF(CFNAME(1:1).NE.'/') THEN
*-- Add the (in)famous '/' as first character.
            COMMAN = '/'//CFNAME
            CFNAME = COMMAN
         END IF
         IF(W.EQ.2) THEN
            L      = LENOCC(CFNAME)
            CFNAME(L+2:L+2) = MODE
         END IF
      END IF
*
  999 RETURN
      END
+DECK,RJINFO,IF=VAX.
      SUBROUTINE RJINFO
*.
*...RJINFO Inquires the system for general Job information such as
*.         Node name , User name , Job name , batch Entry number ......
*.         It saves all these information in the Common block RCSYST.
*.
*. SEQUENCES : DECLARE RCSYST RCREP
*. CALLS     : SYS$GETSYIW SYS$GETJPIW SYS$GETQUIW LENOCC CLEFT
*. CALLED    : RSSYST
*.
*. AUTHOR    : F.Odorici
*. VERSION   : 1.00
*. CREATED   : 29-Nov-1990
*. LAST MOD  : 03-Jul-1991
*.
*. Modification log:
*.  03-Jul-91 F.Odorici  Handle also spawned sub-processes (i.e. Munch)
*.  29-Nov-90 F.Odorici  Create this routine
*.
**********************************************************************
+SEQ,DECLARE.
*
      INCLUDE '($SYIDEF)'
      INCLUDE '($JPIDEF)'
      INCLUDE '($SSDEF)'
      INCLUDE '($QUIDEF)'
*
      INTEGER SYS$GETSYIW,SYS$GETJPIW,SYS$GETQUIW
      INTEGER INFO,LENOCC
      INTEGER MODE,SRCHFL,ENTRY,JBPID,JBMPID,JBTYP
      CHARACTER NODNAM*15,USNAME*12,JBNAME*100,IMNAME*100,QUENAM*31
      INTEGER*2 NODNAL,USNAML,JBNAML,IMNAML,QUENAL
*
+SEQ,RCSYST.
+SEQ,RCREP.
*
*-- Definition of one item for $GETSYI,$GETJPI and $GETQUI item lists.
      STRUCTURE /ITEM/
       UNION
        MAP
         INTEGER*2 BUFLEN,CODE
         INTEGER*4 BUFADR,RLEADR
        END MAP
        MAP
         INTEGER*4 ENDLIS
        END MAP
       END UNION
      END STRUCTURE
*
      STRUCTURE  /IOSBLK/
       INTEGER*4 STS,ZEROED
      END STRUCTURE
*
      RECORD /ITEM/ SPAR(2)
      RECORD /ITEM/ JPAR(6)
      RECORD /ITEM/ QPAR(5)
      RECORD /IOSBLK/ IOSB
*-- Initialize all the used character variable to blank.
      CHNODE = ' '
      JOBNAM = ' '
      USRNAM = ' '
      CHQUEU = ' '
      CHENTR = ' '
*
      NODNAM = ' '
      USNAME = ' '
      IMNAME = ' '
      JBNAME = ' '
      QUENAM = ' '
*-- Initialize all the used integer variable to zero.
      JOBPID = 0
      JMODE  = 0
      JENTRY = 0
*
      JBPID  = 0
      JBTYP  = 0
      JBMPID = 0
      MODE   = 0
      ENTRY  = 0
*-- Get the node of this system
      SPAR(1).BUFLEN = 15
      SPAR(1).CODE   = SYI$_NODENAME
      SPAR(1).RLEADR = %LOC(NODNAL)
      SPAR(1).BUFADR = %LOC(NODNAM)
      SPAR(2).ENDLIS = 0
*
      INFO   = SYS$GETSYIW ( , , ,SPAR, , , )
      IF(.NOT.INFO)                                             GO TO 20
*
      CHNODE = NODNAM(1:NODNAL)
      LCHNOD = NODNAL
*-- Get the username of the owner of this process, the image name,
*-- the running mode and the process identifier.
      JPAR(1).BUFLEN = 12
      JPAR(1).RLEADR = %LOC(USNAML)
      JPAR(1).BUFADR = %LOC(USNAME)
      JPAR(1).CODE   = JPI$_USERNAME
      JPAR(2).BUFLEN = 100
      JPAR(2).RLEADR = %LOC(IMNAML)
      JPAR(2).BUFADR = %LOC(IMNAME)
      JPAR(2).CODE   = JPI$_IMAGNAME
      JPAR(3).BUFLEN = 4
      JPAR(3).BUFADR = %LOC(MODE)
      JPAR(3).CODE   = JPI$_MODE
      JPAR(4).BUFLEN = 4
      JPAR(4).BUFADR = %LOC(JBPID)
      JPAR(4).CODE   = JPI$_PID
      JPAR(5).BUFLEN = 4
      JPAR(5).BUFADR = %LOC(JBMPID)
      JPAR(5).CODE   = JPI$_MASTER_PID
      JPAR(6).ENDLIS = 0
*
      INFO  = SYS$GETJPIW( , , ,JPAR, , , )
      IF(.NOT.INFO)                                             GO TO 20
*
      USRNAM = USNAME(1:USNAML)
      JMODE  = MODE
      JOBPID = JBPID
*
      IF(MODE.EQ.3.OR.JBPID.NE.JBMPID) THEN
*-- For interactive jobs get only the jobname. Do the same for
*-- spawned sub-process (such as Munch), by requiring the Job PID
*-- to be different from the Master-Job PID
         JBNAME = IMNAME(1:IMNAML)
         JBNAME = JBNAME(INDEX(JBNAME,']')+1:INDEX(JBNAME,'.EXE')-1)
         JBNAML = LENOCC(JBNAME)
      ELSE IF(MODE.EQ.2) THEN
*-- For batch jobs get the jobname, the entry number and the queue name.
         QPAR(1).BUFLEN = 4
         QPAR(1).CODE   = QUI$_SEARCH_FLAGS
         QPAR(1).BUFADR = %LOC(SRCHFL)
         QPAR(1).RLEADR = 0
         QPAR(2).BUFLEN = 39
         QPAR(2).CODE   = QUI$_JOB_NAME
         QPAR(2).BUFADR = %LOC(JBNAME)
         QPAR(2).RLEADR = %LOC(JBNAML)
         QPAR(3).BUFLEN = 4
         QPAR(3).CODE   = QUI$_ENTRY_NUMBER
         QPAR(3).BUFADR = %LOC(ENTRY)
         QPAR(3).RLEADR = 0
         QPAR(4).BUFLEN = 31
         QPAR(4).CODE   = QUI$_QUEUE_NAME
         QPAR(4).BUFADR = %LOC(QUENAM)
         QPAR(4).RLEADR = %LOC(QUENAL)
         QPAR(5).ENDLIS = 0
*
         SRCHFL = QUI$M_SEARCH_THIS_JOB
         INFO   = SYS$GETQUIW( ,%VAL(QUI$_CANCEL_OPERATION),,,,,)
         IF(.NOT.INFO)                                          GO TO 20
         INFO   = SYS$GETQUIW( ,%VAL(QUI$_DISPLAY_JOB),,QPAR,IOSB,,)
         IF(.NOT.INFO)                                          GO TO 20
         INFO   = IOSB.STS
         IF(.NOT.INFO)                                          GO TO 20
*
         CHQUEU = QUENAM(1:QUENAL)
         JENTRY = ENTRY
         WRITE(CHENTR,FMT='(I5)',ERR=10) JENTRY
   10    CONTINUE
         CALL CLEFT(CHENTR,1,5)
      ELSE
         CHREP='Your job is not running in batch or interactive mode'
         CALL REPORT('RJINFO',1,'W')
      END IF
*
      JOBNAM = JBNAME(1:JBNAML)
                                                               GO TO 999
*
   20 CHREP='Problems while getting information from the system'
      CALL REPORT('RJINFO',2,'E')
*
  999 RETURN
      END
+DECK,RLASPO.
      FUNCTION RLASPO(STR,SEARCH)
*.
*...RLASPO Utility function which returns the last occurence of string
*.         SEARCH in the string STR
*.
*. CALLS   : LENOCC
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER        I,RLASPO,N,M,LENOCC
      CHARACTER*(*)  STR,SEARCH
*
      N      = LENOCC(STR)
      M      = LENOCC(SEARCH)
      IF(M.EQ.0) THEN
         RLASPO = LENOCC(STR)
      ELSE IF(M.GT.N) THEN
         RLASPO = 0
      ELSE
         DO 10 I=N-M+1,1,-1
           IF(SEARCH(1:M).EQ.STR(I:I+M-1))                      GO TO 20
   10    CONTINUE
         I      = 0
   20    RLASPO = I
      END IF
*
      RETURN
      END
+DECK,RLUCLR.
      SUBROUTINE RLUCLR(ISUM)
*.
*...RLUCLR  Clears (sets to zero) elements of COMMON/ROLUM/
*           corresponding to luminosity sum number ISUM.
*.
*. INPUT   : ISUM  Luminosity sum number
*. OUTPUT  :
*.
*. SEQUENCE: RCREP ROLUM RCLINE
*. CALLS   : REPORT RMAIL
*. CALLED  : USHEAD USBAT (by user)
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.00
*. CREATED : 27-May-90
*. LAST MOD: 22-Apr-97
*.
*. Modification Log.
*. 22-Apr-97  M.Schroder use appropriate values for double prec.
*. 25-Oct-90  C.Hawkes  Check for input argument within valid range
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,RCREP.
+SEQ,ROLUM.
+SEQ,RCLINE.
*
      INTEGER ISUM
*
*-- Check for valid input argument (index sum within allowed range)
      IF(ISUM.LT.1.OR.ISUM.GT.NLMSUM)THEN
        WRITE(CHREP,1000) ISUM
        CALL REPORT('RLUCLR',1,'E')
        GOTO 999
      ENDIF
*
*-- Zero elements in COMMON/ROLUM/ for sum number ISUM
      NLMBHA(ISUM)=0
      IBHFRN(ISUM)=0
      IBHFEV(ISUM)=0
      IBHLRN(ISUM)=0
      IBHLEV(ISUM)=0
      EBLMIN(ISUM)=0.
      EBLMAX(ISUM)=0.
      EBLOFF(ISUM)=0.
      SUMLUM(ISUM)=0.D0
      SUMLM2(ISUM)=0.D0
      SUMLSY(ISUM)=0.D0
      SUMEBL(ISUM)=0.D0
      SUME2L(ISUM)=0.D0
      SUMESY(ISUM)=0.D0
*
      WRITE(CHLINE,1001)ISUM
      CALL RMAIL(0,0)
*
  999 CONTINUE
      RETURN
*
 1000 FORMAT(' Argument=',I5,' outside valid range')
 1001 FORMAT(' Luminosity sum number',I5,' cleared')
*
      END
+DECK,RLUFIN.
      SUBROUTINE RLUFIN(ISUM)
*.
*...RLUFIN  Evaluates final results from a luminosity sum
*.
*. INPUT   : ISUM  Luminosity sum number
*. OUTPUT  : Luminosity sum results returned through COMMON/ROLSUM/
*.
*. SEQUENCE: ROLUM ROLSUM RCREP
*. CALLS   : REPORT
*. CALLED  : USFIN (by user)
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.00
*. CREATED : 05-Mar-90
*. LAST MOD:
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,ROLUM.
+SEQ,ROLSUM.
+SEQ,RCREP.
*
      INTEGER          ISUM
      DOUBLE PRECISION ESPRSQ
      REAL             ROOT2
      PARAMETER       (ROOT2=1.414214)
*
*-- Check for valid input argument (index sum within allowed range)
      IF(ISUM.LT.1.OR.ISUM.GT.NLMSUM)THEN
        WRITE(CHREP,1001) ISUM
        CALL REPORT('RLUFIN',1,'E')
        GOTO 999
      ENDIF
*
*-- Index number of this luminosity sum
      ILSUM=ISUM
*-- First Bhabha of this luminosity sum
      IFRUN=IBHFRN(ILSUM)
      IFEVT=IBHFEV(ILSUM)
*-- Last Bhabha of this luminosity sum
      ILRUN=IBHLRN(ILSUM)
      ILEVT=IBHLEV(ILSUM)
*-- Number of Bhabha events in this luminosity sum
      NLBHAB=NLMBHA(ILSUM)
*-- Total luminosity and errors
      TOTLUM=SUMLUM(ILSUM)
      DLUMST=DSQRT(SUMLM2(ILSUM))
      DLUMSY=SUMLSY(ILSUM)
*-- Minimum and maximum beam energies
      EBMIN=EBLMIN(ILSUM)
      EBMAX=EBLMAX(ILSUM)
*-- Luminosity weighted mean beam energy
      IF(TOTLUM.GT.0.)THEN
        EBMEAN=EBLOFF(ILSUM)+SUMEBL(ILSUM)/SUMLUM(ILSUM)
*-- Luminosity weighted beam energy spread (standard deviation)
        ESPRSQ=  SUME2L(ILSUM)/SUMLUM(ILSUM)
     +         -(SUMEBL(ILSUM)/SUMLUM(ILSUM))**2
        IF(ESPRSQ.GT.0.)THEN
          EBSPRD=DSQRT(ESPRSQ)
          IF(NLBHAB.GT.1)EBSPRD=EBSPRD*
     +                   DSQRT(1./(1.-SUMLM2(ILSUM)/SUMLUM(ILSUM)**2))
        ELSE
          EBSPRD=0.
        ENDIF
*-- Statistical and systematic error on the mean beam energy
        DEBMST=EBSPRD*DLUMST/TOTLUM
        DEBMSY=SUMESY(ILSUM)/SUMLUM(ILSUM)
*-- Statistical error on the beam energy spread
        DEBSST=DEBMST/ROOT2
      ELSE
*-- No luminosity in this sum. Return energies as zero.
        EBMEAN=0.
        DEBMST=0.
        DEBMSY=0.
        EBSPRD=0.
        DEBSST=0.
      ENDIF
*
  999 CONTINUE
      RETURN
*
 1001 FORMAT(' Argument=',I5,' outside valid range')
*
      END
+DECK,RLUINI.
      SUBROUTINE RLUINI
*.
*...RLUINI  Initialise luminosity sums
*.
*. SEQUENCE: ROLUM
*. CALLS   : VZERO
*. CALLED  : ROINIT
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.00
*. CREATED : 05-Mar-90
*. LAST MOD:
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,ROLUM.
*
*-- Zero everything in COMMON/ROLUM/
      CALL VZERO(NLMBHA,NLMSUM)
      CALL VZERO(IBHFRN,NLMSUM)
      CALL VZERO(IBHFEV,NLMSUM)
      CALL VZERO(IBHLRN,NLMSUM)
      CALL VZERO(IBHLEV,NLMSUM)
      CALL VZERO(EBLMIN,NLMSUM)
      CALL VZERO(EBLMAX,NLMSUM)
      CALL VZERO(EBLOFF,NLMSUM)
      CALL VZERO(SUMLUM,2*NLMSUM)
      CALL VZERO(SUMLM2,2*NLMSUM)
      CALL VZERO(SUMLSY,2*NLMSUM)
      CALL VZERO(SUMEBL,2*NLMSUM)
      CALL VZERO(SUME2L,2*NLMSUM)
      CALL VZERO(SUMESY,2*NLMSUM)
*
      RETURN
      END
+DECK,RLUPRT.
      SUBROUTINE RLUPRT
*.
*...RLUPRT  Evaluates and prints final results from luminosity sums
*.
*. SEQUENCE: ROLUM RCLINE
*. CALLS   : RMAIL
*. CALLED  : USFIN (by user)
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.00
*. CREATED : 05-Mar-90
*. LAST MOD:
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,ROLUM.
+SEQ,RCLINE.
*
      INTEGER          ISUM
      DOUBLE PRECISION ESPRSQ
      REAL             DLUMST,EBMEAN,DEBMST,DEBMSY,EBSPRD,DEBSST
      REAL             ROOT2
      PARAMETER       (ROOT2=1.414214)
*
*-- Table header for luminosity sums
      WRITE(CHLINE,1000)
      CALL RMAIL(2,0)
      WRITE(CHLINE,1001)
      CALL RMAIL(1,0)
*-- Loop over luminosity sums
      DO 100 ISUM=1,NLMSUM
        IF(NLMBHA(ISUM).GT.0)THEN
*-- Statistical error on sum of luminosity
          DLUMST=DSQRT(SUMLM2(ISUM))
          WRITE(CHLINE,1002)ISUM,IBHFRN(ISUM),IBHFEV(ISUM),
     +                      IBHLRN(ISUM),IBHLEV(ISUM),NLMBHA(ISUM),
     +                      SUMLUM(ISUM),DLUMST,SUMLSY(ISUM)
          CALL RMAIL(0,0)
        ENDIF
 100  CONTINUE
*-- Table header for beam energies
      WRITE(CHLINE,1010)
      CALL RMAIL(2,0)
      WRITE(CHLINE,1011)
      CALL RMAIL(1,0)
*-- Loop over luminosity sums again for lumi weighted beam energy
      DO 200 ISUM=1,NLMSUM
        IF(SUMLUM(ISUM).GT.0.)THEN
*-- Luminosity weighted mean beam energy
          EBMEAN=EBLOFF(ISUM)+SUMEBL(ISUM)/SUMLUM(ISUM)
*-- Luminosity weighted beam energy spread (standard deviation)
          ESPRSQ=  SUME2L(ISUM)/SUMLUM(ISUM)
     +           -(SUMEBL(ISUM)/SUMLUM(ISUM))**2
          IF(ESPRSQ.GT.0.)THEN
            EBSPRD=DSQRT(ESPRSQ)
            IF(NLMBHA(ISUM).GT.1)EBSPRD=EBSPRD*
     +                       DSQRT(1./(1.-SUMLM2(ISUM)/SUMLUM(ISUM)**2))
          ELSE
            EBSPRD=0.
          ENDIF
*-- Statistical and systematic error on the mean beam energy
          DEBMST=EBSPRD*DSQRT(SUMLM2(ISUM))/SUMLUM(ISUM)
          DEBMSY=SUMESY(ISUM)/SUMLUM(ISUM)
*-- Statistical error on the beam energy spread
          DEBSST=DEBMST/ROOT2
          WRITE(CHLINE,1012)ISUM,EBLMIN(ISUM),EBLMAX(ISUM),
     +                           EBMEAN,DEBMST,DEBMSY,EBSPRD,DEBSST
          CALL RMAIL(0,0)
        ENDIF
 200  CONTINUE
      RETURN
*
 1000 FORMAT(40X,'LUMINOSITY SUMS (1/nb)')
 1001 FORMAT('  Sum   First Bhabha    Last Bhabha    Bhabhas',
     +       '        Luminosity +- Statistical +-  Systematic')
 1002 FORMAT(I5,2(I8,'/',I6),I11,E18.5,2(' +-',E12.3))
*
 1010 FORMAT(13X,'LUMINOSITY WEIGHTED MEAN BEAM ENERGY',
     +       ' AND BEAM ENERGY SPREAD (standard deviation) (GeV)')
 1011 FORMAT('  Sum   Min E_Beam   Max E_Beam    ',
     +       'Mean E_Beam +- Statistical +-  Systematic  ',
     +       'E_Beam Spread +- Statistical')
 1012 FORMAT(I5,2F13.3,F15.3,2(' +-',E12.3),F15.3,' +-',E12.3)
*
      END
+DECK,RMAIL.
      SUBROUTINE RMAIL(LINBEF,LINAFT)
*.
*...RMAIL    Send a line of text to an output device.
*.
*.            LINBEF : No. of blank lines output before the line.
*.            LINAFT : No. of blank lines output after the line.
*.
*.    Send a line of text to the output device (usually unit LROUT)
*.    The text is in character array CHLINE of /RCLINE/.  The maximum
*.    length is 132 characters.  LINBEF lines are written before
*.    writing the text CHLINE and LINAFT lines are written afterwards.
*.    Trailing blank characters are not written.
*.
*.       This is an analogue of the GEANT GMAIL facility written to
*.    avoid Fortran output on the CERN 3081/E emulators. It is forseen
*.    that there will be other circumstances where it is neccessary to
*.    have control over output which would normally be written directly
*.    to a printing file, for example error reporting within the online
*.    system or while in a graphics application on VM/CMS.
*.
*. COMMON  : CRO,RCLINE
*. CALLED  : <user>,REPORT
*.
*. AUTHOR  : S.O'Neale
*. VERSION : 1.00
*. CREATED : 13-Jul-87
*. LAST MOD:  1-Feb-94
*.
*. Modification Log.
*.  1-Feb-94  O.Schaile  Allow supressing of output
*. 13-Jul-87  S.O'Neale  Place marker.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER I,LINBEF,LINAFT,NCH
*
+SEQ,CRO.
+SEQ,RCLINE.
+SEQ,RECNTL.
*
      IF(NPRTMX(1).LT.0)THEN
         IF(IREVNT.LE.0 .OR. NPRTMX(1).LT.-1)RETURN
      ENDIF
      DO 10 I=1,LINBEF
         WRITE (LROUT,1000)
   10 CONTINUE
      DO 20 NCH=132,1,-1
         IF(CHLINE(NCH:NCH).NE.' ')                             GO TO 30
   20 CONTINUE
      NCH=1
   30 CONTINUE
      WRITE (LROUT,1010) CHLINE(1:NCH)
      DO 40 I=1,LINAFT
         WRITE (LROUT,1000)
   40 CONTINUE
*
      RETURN
 1000 FORMAT (1X)
 1010 FORMAT (A)
      END
+DECK,RNOTIFV,IF=VAX.
      SUBROUTINE RNOTIF
*.
*...RNOTIF Sends to the owner of the process
*.         (if he has an interactive session) the message CHREP
*.
*. SEQUENCES : DECLARE RCSYST RCLINE RCREP
*. CALLS     : SYS$BRKTRHU LENOCC
*. CALLED    : ....
*.
*. AUTHOR    : F.Odorici
*. VERSION   : 1.03
*. CREATED   :  7-Nov-1990
*. LAST MOD  : 29-Nov-1990
*.
*. Modification log:
*.  29-Nov-90 F.Odorici  Send also a prompt like "NODE::USER(ENTRY)>> "
*.  18-Nov-90 D.Lellouch User name has been computed elsewhere
*.                       The message is CHREP
*.  14-Nov-90 F.Odorici  Use SYS$BRKTHRU to send the message.
*.   7-Nov-90 F.Odorici  Create this routine
*.
*.********************************************************************
+SEQ,DECLARE.
      INCLUDE '($BRKDEF)'
      INCLUDE '($SSDEF)'
      INTEGER SYS$BRKTHRU,INFO,SNDTYP,FLAGS,REQID,CARCON,LENOCC,I
      CHARACTER USNAME*12,CHMESS*132,BELL*1
      EQUIVALENCE (I,BELL)
+SEQ,RCSYST.
+SEQ,RCLINE.
+SEQ,RCREP.
*
      DATA I/7/
      STRUCTURE  /IOSBLK/
         INTEGER*4 STS,ZEROED
      END STRUCTURE
      RECORD /IOSBLK/ IOSB
*
      IF(.NOT.BNOTIF) RETURN
*-- Send the message CHMESS to the user SENDER in the cluster
      USNAME = SENDER
      SNDTYP = BRK$C_USERNAME
      REQID  = BRK$C_GENERAL
      FLAGS  = BRK$M_CLUSTER
      CARCON = 15
      CHMESS = BELL//CHNODE(1:LCHNOD)//'::'//USNAME(1:LENOCC(USNAME))
     +         //'('//CHENTR(1:LENOCC(CHENTR))//')>> '//CHREP
      INFO   =SYS$BRKTHRU( ,CHMESS(1:LENOCC(CHMESS)),USNAME,
     +                      %VAL(SNDTYP),IOSB,%VAL(CARCON),%VAL(FLAGS),
     +                      %VAL(REQID), ,   , )
      IF(.NOT.INFO) THEN
         WRITE(CHLINE,1000) INFO
         CALL RMAIL(0,0)
      ELSE
         INFO   = IOSB.STS
         IF(.NOT.INFO) THEN
C           WRITE(CHLINE,1000) INFO
            CALL RMAIL(0,0)
         END IF
      END IF
*
      RETURN
1000  FORMAT(' Error from SYS$BRKTHRU:',I5)
      END
+DECK,RNOTIF,IF=IBM.
      SUBROUTINE RNOTIF
*.
*...RNOTIF Notify a message to the job initiator
*.
*. CALLS   : VMCMS LENOCC CUTOL
*. CALLED  : REPORT
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*8    SENLOW
      CHARACTER*20   FMAIL
      INTEGER        L,M,N,LENOCC,LUN,MXMAIL,L1
      PARAMETER     (MXMAIL=5)
+SEQ,RCSYST.
+SEQ,RCREP.
*
      IF(.NOT.BNOTIF) RETURN
      L      = LENOCC(CHREP)
      M      = LENOCC(SENDER)
      N      = LENOCC(JOBNAM)
      SYSCOM = 'EXEC TELL '//SENDER(1:M)//' ('//JOBNAM(1:N)
     +          //') '//CHREP(1:L)
      CALL VMCMS(SYSCOM,SYSRC)
*-- User absent or disconnected, let's send him a mail
*-- (unless the maximum number of mails has been reached)
      IF(SYSRC.NE.0.AND.MAILSN.LT.MXMAIL) THEN
         MAILSN = MAILSN + 1
         WRITE(FMAIL,1020) MAILSN
         CALL RGTLUN(LUN)
         OPEN(LUN,FILE=FMAIL,FORM='FORMATTED',ERR=999)
         SENLOW = SENDER(1:LENOCC(SENDER))
         CALL CUTOL(SENLOW(2:8))
         L1     = MIN0(79,L)
         WRITE(LUN,1000,ERR=10) SENLOW,CHREP(1:L1),JOBNAM
         IF(MAILSN.EQ.MXMAIL) WRITE(LUN,1010) MXMAIL
         CLOSE(LUN,ERR=20)
         CALL VMCMS('CP SPOOL PUNCH CLASS M',SYSRC)
         SYSCOM = 'PUNCH '//FMAIL(2:)
         CALL VMCMS(SYSCOM,SYSRC)
         CALL VMCMS('CP SPOOL PUNCH CLASS A',SYSRC)
                                                                GO TO 20
   10    CLOSE(LUN,ERR=20)
   20    SYSCOM = 'ERASE '//FMAIL(2:20)
         CALL VMCMS(SYSCOM,SYSRC)
      END IF
*
  999 RETURN
 1000 FORMAT(/,20X,'Dear ',A,//,
     +       'You were not able to receive the following message,',
     +       ' let me mail it:',//,A,//,
     +       'Have a good use of it.',/,T20,'Sincerely yours',/,T20,
     +       'Your faithful: Rope job ',A)
 1010 FORMAT(/,'P.S. The maximum number of',I3,' mails is reached for',
     +       ' this job',/,5X,'This was the last mail.')
 1020 FORMAT('/ROPE',I3.3,' MAIL A')
      END
+DECK,RNOTIFI,IF=IBMRT.
      SUBROUTINE RNOTIF
*.
*...RNOTIF Notify a message to the job initiator
*.
*. CALLS   : RQSYST LENOCC
*. CALLED  : REPORT
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 8-Jan-92
*. LAST MOD: 8-Jan-92
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCSYST.
+SEQ,RCREP.
      INTEGER  LENOCC
      EXTERNAL LENOCC

      SYSCOM='msg "'//CHREP(1:LENOCC(CHREP))//'"'
      CALL RQSYST(.FALSE.)

      RETURN
      END
+DECK,RODATI.
      SUBROUTINE RODATI (NNDATE,IT)
*.
*...RODATI wrapper to DATIME, which will return the date in format YYMMDD
*.          for all years 199X, and in format YYYYMMDD for all years 200X.
*.
*.
*. AUTHOR    : E.Barberio
*. VERSION   : 1.00
*. CREATED   : 27-Set-99
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER ID,IT
*
      INTEGER ISL
      COMMON/SLATE/ISL(40)
*     
      INTEGER NNDATE

      CALL DATIME(ID,IT)
      IF(ISL(1).LT.2000) THEN
        NNDATE = ID
      ELSE  
        NNDATE = ISL(1)*10000 + MOD(ID,10000)
      ENDIF
*     
      RETURN
      END
+DECK,RODATE.
      SUBROUTINE RODATE (IJULD,NNDATE,IER)
*.
*...RODATE transforms between different date representations.
*.
*.      This is a copy of the GENLIB routine CALDAT (Z009).
*.      Only the JULIAN -> Year/Month/Day is kept.
*.      Calling sequence customized to OPAL's need.
*.      Offset of 1721424 days respective to GENLIB!
*.      The following global name changes have been made:
*.             CALDAT --> RODATE
*.             CDMON  --> RODATM
*.             CLEAP  --> RODATL
*.             CYDIY  --> RODATY
*.
*. AUTHOR    : O.Hell
*. VERSION   : 3.01
*. CREATED   : 01-Mar-83
*. LAST MOD  : 25-SET-99
*.
*. Modification Log.
*. 25-SET-99 E.Barberio change NNDATE to run in year 2000
*. 29-Jul-89 S.Weisz    Get rid of 1000 useless lines.
*. 27-Jul-89 S.L.Lloyd  Modified for OPAL use.
*.
*.*********************************************************************
+SEQ,DECLARE.
*
      INTEGER   I,IJULD,IJULO,NNDATE,IER
      PARAMETER (IJULO = 1721424)
*   Important local registers
      INTEGER   LEAP,YEAR,MONTH,DAY,DIY,JULIAN
*   Input date = JULIAN,
*   Originally in CALDAT: Element    6 of BINREP,    IINDEX = 104
      JULIAN = IJULD - IJULO
      IF(JULIAN.LT.1.OR.JULIAN.GT.10000000) THEN
         NNDATE = 0
         IER = 1
      ELSE
         CALL RODATY(JULIAN,YEAR,LEAP,DIY)
         CALL RODATM(LEAP,DIY,MONTH,DAY)
*   YEAR=YYYY, I=YY
         IF(YEAR.LE.1999) THEN 
         I = MOD(YEAR,100)
         ELSE
           I = YEAR
         ENDIF
*   Write date in ROPE format
         NNDATE = 10000*I + 100*MONTH + DAY
*
         IER = 0
      END IF
*
      RETURN
      END
+DECK,RODATL.
      INTEGER  FUNCTION RODATL (YEAR)
C
CC    COMPUTE LEAP
C     I.E. SET FUNCTION VALUE TO THE CORRECT TABLE INDEX
C          = 1 FOR NORMAL, = 2 FOR LEAP YEAR
C
C     DECISION TABLE FOR LEAP YEARS
C     -----------------------+------+------+------+------
C     YEAR DIVISIBLE BY   4  | YES  | YES  | YES  | NO
C     YEAR DIVISIBLE BY 100  | YES  | YES  | NO   |--
C     YEAR DIVISIBLE BY 400  | YES  | NO   |  --  |--
C     -----------------------+------+------+------+------
C     YEAR IS LEAP YEAR      | YES  | NO   | YES  | NO
C     EXAMPLES               | 20000 | 1900 | 1980 | 1981
C     -----------------------+------+------+------+------
C
+SEQ,DECLARE.
      INTEGER  YEAR
C
      IF     ( MOD (YEAR, 4  ) .NE. 0 )   THEN
                                                 RODATL = 1
      ELSEIF ( MOD (YEAR, 100) .NE. 0 )   THEN
                                                 RODATL = 2
      ELSEIF ( MOD (YEAR, 400) .NE. 0 )   THEN
                                                 RODATL = 1
      ELSE
                                                 RODATL = 2
      ENDIF
C
      END
+DECK,RODATM.
      SUBROUTINE RODATM (LEAP, DIY, MONTH, DAY)
C
CC    COMPUTE DAY & MONTH FROM DIY & LEAP
C
+SEQ,DECLARE.
      INTEGER  LEAP, DIY, MONTH, DAY
C
C                                 DAYS IN THE MONTHS ACCUMULATED
C                                 (TABLE COPIED FROM MAIN ROUTINE)
      INTEGER  MONTAB (12,2)
      SAVE     MONTAB
      DATA  MONTAB  /
     *  000, 031, 059, 090, 120, 151, 181, 212, 243, 273, 304, 334,
     *  000, 031, 060, 091, 121, 152, 182, 213, 244, 274, 305, 335 /
C
C
      DO  10, MONTH = 12, 2, -1
         IF  ( DIY .GT. MONTAB (MONTH, LEAP) )                  GO TO 20
   10 CONTINUE
C
      MONTH = 1
C
   20 DAY = DIY - MONTAB (MONTH, LEAP)
C
      END
+DECK,RODATY.
      SUBROUTINE RODATY (JULIAN, YEAR, LEAP, DIY)
C
CC    COMPUTE DIY, YEAR & LEAP FROM JULIAN
C
C     SINCE
C     JULIAN = DIY  +  (YEAR - 1) * 365  +  (YEAR - 1) / 4
C    -              -  (YEAR - 1) / 100  +  (YEAR - 1) / 400
C     WITH INTEGER DIVISION, THE INVERSION WILL NOT BE EXACT, BUT GIVE
C     A GOOD VALUE TO START FROM:
C     JULIAN <= (YEAR - 1) * (365 + 1/4 - 1/100 + 1/400)
C             = (YEAR - 1) * 146097 / 400
C     YEAR  APPROX.= JULIAN * 400 / 146097 + 1
C
C                                      LYEAR IS COPY FROM MAIN ROUTINE
+SEQ,DECLARE.
      INTEGER  LYEAR (2)
      SAVE     LYEAR
      INTEGER  JULIAN, YEAR, LEAP, DIY
      INTEGER  RODATL
      DATA LYEAR / 365, 366 /
C
C
      YEAR = (JULIAN * 400) / 146097 + 1
      DIY  = JULIAN - (YEAR - 1) * 365  -  (YEAR - 1) / 4
     +              + (YEAR - 1) / 100  -  (YEAR - 1) / 400
      IF  ( DIY .LT. 1 )                                       GO TO 200
C
C     ADVANCE YEAR
  100 LEAP = RODATL ( YEAR )
      IF  ( DIY .LE. LYEAR (LEAP) )                            GO TO 900
      DIY  = DIY - LYEAR (LEAP)
      YEAR = YEAR + 1
                                                               GO TO 100
C
C     RETARD YEAR
  200 YEAR = YEAR - 1
      LEAP = RODATL ( YEAR )
      DIY  = DIY + LYEAR (LEAP)
      IF  ( DIY .LT. 1 )                                       GO TO 200
C
  900 CONTINUE
      END
+DECK,ROFIPE.
      INTEGER FUNCTION ROFIPE(IEXP)
C     """""""""""""""""""""""""""""
*--   ROPE utility routine returns first period for given experiment
*.
*. INPUT     : IEXP   - experiment number for which you want first period
*.
*. COMMONS   :
*. SEQUENCE  : DECLARE
*. CALLS     :
*. CALLED    : <user>
*. BANKS U   : none
*.
*. AUTHOR    : M. Oreglia
*. VERSION   : 1.01
*. CREATED   : 23-Jun-94
*. LAST MOD  : 27-Jun-95
*.
*. Modification Log
*. 27-Jun-95 M.Schroder  split into ROFIPE and ROFIRU
*.***********************************************************************
*
+SEQ,DECLARE.
      INTEGER IEXP,MINEXP,MAXEXP
      PARAMETER (MINEXP=1,MAXEXP=7)
      INTEGER ISTPER(MINEXP:MAXEXP)
C---------------------------------------------------------------
      DATA ISTPER /8,20,35,47,59,68,69/
C---------------------------------------------------------------
      IF (IEXP.GE.MINEXP.AND.IEXP.LE.MAXEXP) THEN
        ROFIPE = ISTPER(IEXP)
      ELSE
        ROFIPE = 0
      ENDIF
      END
+DECK,ROFIRU.
      INTEGER FUNCTION ROFIRU(IPERIO)
C     """""""""""""""""""""""""""""""
*--   ROPE utility routine returns first RUN for given period
*.
*. INPUT     : IPERIO   - period number for which you want first run
*.
*. COMMONS   :
*. SEQUENCE  : DECLARE
*. CALLS     :
*. CALLED    : <user>
*. BANKS U   : none
*.
*. AUTHOR    : M. Oreglia
*. VERSION   : 1.01
*. CREATED   : 23-Jun-94
*. LAST MOD  : 27-Jun-95
*.
*. Modification Log
*. 27-Jun-95 M.Schroder  split into ROFIPE and ROFIRU
*.***********************************************************************
*
+SEQ,DECLARE.
      INTEGER IPERIO,MINPER,MAXPER
      PARAMETER (MINPER=8,MAXPER=71)
      INTEGER ISTRUN(MINPER:MAXPER)
C---------------------------------------------------------------
      DATA ISTRUN /1419,1535,1632,1737,1775,1801,1840,1852,1885,1917,
     +             1929,1951,2213,2253,2280,2301,2331,2346,2363,2392,
     +             2407,2461,2500,2528,2535,2566,2583,3000,3076,3100,
     +             3136,3169,3207,3239,3328,3395,3449,3501,3562,4035,
     +             4093,4126,4177,4202,4295,4353,4403,4437,4472,4489,
     +             4540,5014,5120,5195,5226,5291,5361,5411,5487,5518,
     +             5600,6000,6121,6196/
C---------------------------------------------------------------
      IF (IPERIO.GE.MINPER.AND.IPERIO.LE.MAXPER) THEN
        ROFIRU = ISTRUN(IPERIO)
      ELSE
        ROFIRU = 0
      ENDIF
      END
+DECK,ROFIRL.
      SUBROUTINE ROFIRL(A,N1,N2,RC)
*.
*...ROFIRL decode a string according to the pattern  'n1:n2'
*.         defaults values are n1=1  and n2=*
*.         'n' alone means n:n
*.          n1 has to be greater or equal than n2
*. CALLS   : RWORDS LENOCC ICNUM
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.  10-Dec-1991 O.Schaile  Replace list directed internal reads
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*(*) A
      CHARACTER*5 CFORMA
      INTEGER       N1,N2,RC,INDEX,L,LENOCC,I,ICNUM,RWORDS
      EXTERNAL      RWORDS,LENOCC,ICNUM
*-- All blank?
      L      = LENOCC(A)
*-- Is there a column ':' sign?
      I      = INDEX(A,':')
      IF(L.EQ.0) THEN
         N1     =      1
         N2     = 999999
      ELSE IF(I.EQ.0) THEN
         IF(RWORDS(A(1:L)).NE.1)                                GO TO 10
         IF(ICNUM(A,1,L).NE.L+1)                                GO TO 10
         WRITE(CFORMA,1000)L
         READ(A(1:L),CFORMA) N1
         N2     = N1
      ELSE
         IF(I.EQ.1) THEN
            N1     = 1
         ELSE IF(LENOCC(A(1:I-1)).EQ.0) THEN
            N1     = 1
         ELSE
            IF(ICNUM(A,1,I-1).NE.I)                             GO TO 10
            IF(RWORDS(A(1:I-1)).NE.1)                           GO TO 10
            WRITE(CFORMA,1000)I-1
            READ(A(1:I-1),CFORMA) N1
         END IF
         IF(I.EQ.L) THEN
            N2     = 999999
         ELSE
            IF(ICNUM(A,I+1,L).NE.L+1)                           GO TO 10
            IF(RWORDS(A(I+1:L)).NE.1)                           GO TO 10
            WRITE(CFORMA,1000)L-I
            READ(A(I+1:L),CFORMA) N2
         END IF
      END IF
      IF(N1.GT.N2)                                              GO TO 10
      RC     = 0
                                                               GO TO 999
   10 RC     = 1
*
  999 RETURN
1000  FORMAT('(I',I2.2,')')
      END
+DECK,ROLUMI.
      SUBROUTINE ROLUMI(ISUM)
*.
*...ROLUMI  Increments a luminosity sum for a luminosity Bhabha event
*.
*. INPUT   : ISUM  Luminosity sum number
*.
*. SEQUENCE: CRO ROPAR ROLUM RCREP
*. CALLS   : REPORT RGETEB RGETLU
*. CALLED  : USHEAD USBAT (by user)
*.
*. WARNING : This routine may be called from USHEAD.
*.           It can use only data available in the event header.
*.
*. AUTHOR  : Chris Hawkes
*. VERSION : 1.00
*. CREATED : 05-Mar-90
*. LAST MOD:
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROLUM.
+SEQ,RCREP.
*
      REAL    EVLUM,SYSLUM,PTPLUM,EBEAM,EBDIFF,SYSEB
      INTEGER ISUM,LSUM,IRUN,LRUN,IEVT,LEVT,LEPFIL
      SAVE    LSUM,LRUN,LEVT,EBEAM,SYSEB,LEPFIL,EVLUM,SYSLUM,PTPLUM
      DATA    LSUM,LRUN,LEVT/0,0,0/
*
*-- Check for valid input argument (index sum within allowed range)
      IF(ISUM.LT.1.OR.ISUM.GT.NLMSUM)THEN
        WRITE(CHREP,1001) ISUM
        CALL REPORT('ROLUMI',1,'E')
        GOTO 999
      ENDIF
*-- Check that same event not counted twice in same sum
*-- (In fact can only check against this in consecutive calls)
      IRUN=IUHEAD(IIRUN)
      IEVT=IUHEAD(IIEVT)
      IF(IEVT.EQ.LEVT.AND.IRUN.EQ.LRUN.AND.ISUM.EQ.LSUM)THEN
        WRITE(CHREP,1002) IRUN,IEVT,ISUM
        CALL REPORT('ROLUMI',2,'E')
        GOTO 999
      ENDIF
*-- For new event get beam energy in GeV
      IF(IEVT.NE.LEVT.OR.IRUN.NE.LRUN)THEN
        CALL RGETEB(EBEAM,SYSEB,LEPFIL)
      ENDIF
      IF(EBEAM.LE.0.)THEN
        WRITE(CHREP,1003) EBEAM
        CALL REPORT('ROLUMI',3,'E')
        GOTO 998
      ENDIF
*-- For new event get luminosity in 1/nb
      IF(IEVT.NE.LEVT.OR.IRUN.NE.LRUN)THEN
        CALL RGETLU(EBEAM,EVLUM,SYSLUM,PTPLUM)
      ENDIF
*-- If this is luminosity event increment sums
      IF(EVLUM.GT.0.)THEN
*-- Check for first event of this sum
        IF(NLMBHA(ISUM).EQ.0)THEN
*-- Run/Event number of first Bhabha event included in sum
          IBHFRN(ISUM)=IRUN
          IBHFEV(ISUM)=IEVT
*-- Initialise min and max beam energy
          EBLMIN(ISUM)=EBEAM
          EBLMAX(ISUM)=EBEAM
*-- Use beam energy of first event as offset in energy sums to avoid
*-- rounding errors when calculating beam energy spread (in RLUFIN)
          EBLOFF(ISUM)=EBEAM
        ENDIF
*-- Run/Event number of last Bhabha event included in sum
        IBHLRN(ISUM)=IRUN
        IBHLEV(ISUM)=IEVT
*-- Minimum and maximum beam energies
        IF(EBEAM.LT.EBLMIN(ISUM))EBLMIN(ISUM)=EBEAM
        IF(EBEAM.GT.EBLMAX(ISUM))EBLMAX(ISUM)=EBEAM
*-- Total number of Bhabhas included in sum
        NLMBHA(ISUM)=NLMBHA(ISUM)+1
*-- Total luminosity of Bhabhas included in sum
        SUMLUM(ISUM)=SUMLUM(ISUM)+EVLUM
        SUMLM2(ISUM)=SUMLM2(ISUM)+EVLUM**2
*-- Total luminosity systematic error
        SUMLSY(ISUM)=SUMLSY(ISUM)+SYSLUM
*-- Sums for luminosity weighted mean and spread of beam energies.
*-- Offset energy by energy of first event to reduce rounding error.
        EBDIFF=EBEAM-EBLOFF(ISUM)
        SUMEBL(ISUM)=SUMEBL(ISUM)+EVLUM*EBDIFF
        SUME2L(ISUM)=SUME2L(ISUM)+EVLUM*EBDIFF**2
        SUMESY(ISUM)=SUMESY(ISUM)+EVLUM*SYSEB
      ENDIF
*
  998 CONTINUE
*-- Save sum, run and event number for next call
      LSUM=ISUM
      LRUN=IRUN
      LEVT=IEVT
  999 CONTINUE
*
      RETURN
*
 1001 FORMAT(' Argument=',I5,' outside valid range. Event NOT COUNTED')
 1002 FORMAT(' Multiple call for run',I7,' event',I7,' sum',I3,'.',
     +       ' Counted only once.')
 1003 FORMAT(' Beam energy=',F10.3,'. Event NOT COUNTED')
*
      END
+DECK,ROCRHD.
      SUBROUTINE ROCRHD(IOSEL)
*.----------------------------------------------------------------------
*.-
*.-....   ROCRHD : Header routine for ROCORS calculations
*.-                The user should call ROCRHD from USHEAD and
*.-                make the .OR. of this routine's output and
*.-                his personal preselection.
*.-                NOT NEEDED IF READING LUMINOSITY BIT
*.-
*.-
*.-
*.-   Input    : -
*.-   Output   : IOSEL
*.-   Called   : USHEAD
*.-   Calls    : -
*.-   Seq.     : CRO,ROPAR,ROTPAR,ROCRCM.
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.02
*.-   Created  : 27-JAN-1994
*.-   Last mod :  8-APR-1994   C.Grandi
*.-
*.-   Modification log:
*.     8-APR-1994   M.Redmond: Remove TRCALR call and add LUMDST flag
*.-    8-FEB-1994   C.Grandi: Call TRCALR before each new run
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
+SEQ,ROPAR,ROTPAR,CRO.
+SEQ,TRMAPS.
*
      INTEGER IOSEL
*
      INTEGER TRBTST
      EXTERNAL TRBTST
*
      LOGICAL REVTYP
      EXTERNAL REVTYP
*
*.----------------------------------------------------------------------
*
      IOSEL = 0
*
*--   If reading luminosity bit just return
*
*-- If selecting luminosity evts from DST choose events to be read in:
*-- If SWHI or SWSEG trigger bit is set, or if event is FD lumi event,
*-- select the event for processing
*
      IF (LUMDST) THEN
        IF (
     +    TRBTST(IUHEAD(IITRWD),IBSWH ) .EQ. 1 .OR.
     +    TRBTST(IUHEAD(IITRWD),IBSSEG) .EQ. 1 .OR.
     +    REVTYP(IELUET) )THEN
        IOSEL = 1
        END IF
      END IF
*
  999 RETURN
      END
+DECK,ROCRIN.
      SUBROUTINE ROCRIN
*.----------------------------------------------------------------------
*.-
*.-....   ROCRIN : Initialize LUMDST FFREAD card and ROCRCM common
*.-
*.-
*.-
*.-   Input    : -
*.-   Output   : -
*.-   Called   : USINIT
*.-   Calls    : ROCRCL
*.-   Seq.     : ROCRCM
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.00
*.-   Created  : 24-JAN-1994
*.-   Last mod :  8-APR-1994
*.-
*.-   Modification log:
*.     8-APR-1994   M.Redmond: Add LUMDST flag
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
      INTEGER ISUM
*.----------------------------------------------------------------------
*
      LUMDST = .FALSE.
      CALL FFKEY('LUMDST',LUMDST,1,'LOGICAL')
*
      DO 10 ISUM = 1, NMXCNT
        CALL ROCRCL(ISUM)
   10 CONTINUE
*
  999 RETURN
      END
+DECK,ROCRCL.
      SUBROUTINE ROCRCL(ISUM)
*.----------------------------------------------------------------------
*.-
*.-....   ROCRCL : Reset data for sum ISUM in ROCROS calculation
*.-
*.-
*.-
*.-   Input    : ISUM : Index of sum
*.-   Output   : -
*.-   Called   : ROCRIN, USBAT
*.-   Calls    : -
*.-   Seq.     : ROCRCM,RCREP
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.00
*.-   Created  : 25-JAN-1994
*.    Last Mod : 22-Apr-97
*.
*. Modification Log
*.
*. 22-Apr-97 M.Schroder Use correct type for double prec. variables
*.
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
+SEQ,RCREP.
*
      INTEGER ISUM,ICL,IL
*.----------------------------------------------------------------------
*
*--   Check for valid sum index
      IF(ISUM.LT.1.OR.ISUM.GT.NMXCNT)THEN
        WRITE(CHREP,1000)ISUM
        CALL REPORT('ROCLCR',1,'E')
        GOTO 999
      ENDIF
*
      NTNUM(ISUM)  = 0
      LCNTUS(ISUM) = .FALSE.
      DO 10 ICL = 1, NCLAS
        NNUM(ICL,ISUM)   = 0
        DO 20 IL = 1,NLUMI
          NBHA(IL,ICL,ISUM)   = 0.
          LU(IL,ICL,ISUM)     = 0.D0
          LU2(IL,ICL,ISUM)    = 0.D0
          SYSLU(IL,ICL,ISUM)  = 0.D0
          STALU(IL,ICL,ISUM)  = 0.
          EBOF(IL,ICL,ISUM)   = 0.
          LUEDIF(IL,ICL,ISUM) = 0.D0
          LUEDF2(IL,ICL,ISUM) = 0.D0
          LUSYSE(IL,ICL,ISUM) = 0.D0
          EMEAN(IL,ICL,ISUM)  = 0.
          SYEMEA(IL,ICL,ISUM) = 0.
          STEMEA(IL,ICL,ISUM) = 0.
          ESPRD(IL,ICL,ISUM)  = 0.
          STESPR(IL,ICL,ISUM) = 0.
   20   CONTINUE
        L2RL(ICL,ISUM) = 0.D0
        L2RLBR(ICL,ISUM) = 0.D0
        L2RBRL(ICL,ISUM) = 0.D0
   10 CONTINUE
*
 1000 FORMAT(1X,'Argument ',I5,' outside valid range')
*
  999 RETURN
      END
+DECK,ROCRFI.
      SUBROUTINE ROCRFI
*.----------------------------------------------------------------------
*.-
*.-....   ROCRFI : Prints out all ROCROS calculations
*.-                User should call this routine only to print out
*.-                results of his sums. Data are always available in
*.-                common /ROCRCM/
*.-
*.-
*.-
*.-   Input    : -
*.-   Output   : -
*.-   Called   : USFIN
*.-   Calls    : ROCRPR
*.-   Seq.     : ROCRCM
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.00
*.-   Created  : 24-JAN-1994
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
*
      INTEGER ISUM
*.----------------------------------------------------------------------
*
      DO 10 ISUM = 1, NMXCNT
        IF( LCNTUS(ISUM) )CALL ROCRPR(ISUM)
   10 CONTINUE
*
  999 RETURN
      END
+DECK,ROCRPR.
      SUBROUTINE ROCRPR(ISUM)
*.----------------------------------------------------------------------
*.-
*.-....   ROCRPR : Prints results of ROCROS calculations for a given
*.-                sum index
*.-
*.-
*.-
*.-   Input    : ISUM : sum index
*.-   Output   : -
*.-   Called   : ROCRFI, USBAT
*.-   Calls    : RMAIL
*.-   Seq.     : ROCRCM,RCREP,RCLINE
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.00
*.-   Created  : 25-JAN-1994
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
+SEQ,RCREP,RCLINE.
*
      INTEGER TOTNUM, ICL, ISUM
*.----------------------------------------------------------------------
*
*--   Check for valid sum index
      IF(ISUM.LT.1.OR.ISUM.GT.NMXCNT)THEN
        WRITE(CHREP,1000)ISUM
        CALL REPORT('ROCRPR',1,'E')
        GOTO 999
      ENDIF
*--   Check that sum has been filled
      IF(.NOT.LCNTUS(ISUM))THEN
        WRITE(CHREP,1001)ISUM
        CALL REPORT('ROCRPR',2,'E')
        GOTO 999
      ENDIF
*
*--   Write out results
*
      WRITE(CHLINE,110)
      CALL RMAIL(1,0)
      WRITE(CHLINE,100)ISUM
      CALL RMAIL(0,0)
      WRITE(CHLINE,110)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101)NTNUM(ISUM)
      CALL RMAIL(0,0)
      TOTNUM = NNUM(1,ISUM)+NNUM(3,ISUM)
      WRITE(CHLINE,102)TOTNUM
      CALL RMAIL(0,0)
      WRITE(CHLINE,110)
      CALL RMAIL(0,0)
      WRITE(CHLINE,104)'  SW ok            ',
     +                 '  SW ok  and FD ok ',
     +                 '  SW bad and FD ok '
*
*--   Print out numerator results
*
      CALL RMAIL(0,0)
      WRITE(CHLINE,110)
      CALL RMAIL(0,0)
      WRITE(CHLINE,105)'Number of num. events',(NNUM(ICL,ISUM),ICL=1,3)
      CALL RMAIL(0,0)
*
*--   Print out SWITA results
*
      WRITE(CHLINE,110)
      CALL RMAIL(0,0)
      WRITE(CHLINE,105)'Number of SWITA evts ',(INT(NBHA(1,ICL,ISUM)),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'SWITA integrated lumi',(LU(1,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Syst error on SWITA l',(SYSLU(1,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Stat error on SWITA l',(STALU(1,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'SW lumi-w mean ebeam ',(EMEAN(1,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Sy. er. SW l-w mea eb',(SYEMEA(1,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'St. er. SW l-w mea eb',(STEMEA(1,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'SW lumi-w eb spread  ',(ESPRD(1,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'St. er. SW l-w eb spr',(STESPR(1,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
*
*--   Print out (SWITR+SWITL)/2 results
*
      WRITE(CHLINE,110)
      CALL RMAIL(0,0)
      WRITE(CHLINE,107)'Number of SW RL evts ',(NBHA(3,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'SW RL integrated lumi',(LU(3,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Syst error on SW RL l',(SYSLU(3,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Stat error on SW RL l',(STALU(3,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'SW lumi-w mean ebeam ',(EMEAN(3,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Sy. er. SW l-w mea eb',(SYEMEA(3,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'St. er. SW l-w mea eb',(STEMEA(3,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'SW lumi-w eb spread  ',(ESPRD(3,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'St. er. SW l-w eb spr',(STESPR(3,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
*
*--   Print out FD results
*
      WRITE(CHLINE,110)
      CALL RMAIL(0,0)
      WRITE(CHLINE,105)'Number of FD events  ',(INT(NBHA(2,ICL,ISUM)),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'FD integrated lumi   ',(LU(2,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Syst error on FD lumi',(SYSLU(2,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Stat error on FD lumi',(STALU(2,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'FD lumi-w mean ebeam ',(EMEAN(2,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'Sy. er. FD l-w mea eb',(SYEMEA(2,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'St. er. FD l-w mea eb',(STEMEA(2,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'FD lumi-w eb spread  ',(ESPRD(2,ICL,ISUM),ICL=1,
     +  3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,106)'St. er. FD l-w eb spr',(STESPR(2,ICL,ISUM),
     +  ICL=1, 3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,110)
      CALL RMAIL(0,1)
*
  100 FORMAT(19X,'***** Summary of ROCROS, sum number ',I2,' *****')
  101 FORMAT(1X,'Total number of times ROCROS was called with',
     +' .TRUE. argument is:',I9)
  102 FORMAT(1X,'FD or SW were good for ',I9,' events')
  104 FORMAT(9X,'Class',9X,3A19)
  105 FORMAT(1X,A22,3(5X,I9,5X))
  106 FORMAT(1X,A22,3(3X,F13.5,3X))
  107 FORMAT(1X,A22,3(4X,F11.1,4X))
  110 FORMAT(1X,78('*'))
*
 1000 FORMAT(1X,'Argument ',I5,' outside valid range')
 1001 FORMAT(1X,'Sum ',I3,' not filled!')
*
  999 RETURN
      END
+DECK,ROCROS.
      SUBROUTINE ROCROS(ISUM,LNUM)
*.----------------------------------------------------------------------
*.-
*.-....   ROCROS : Calculates cross section for a given process
*.-
*.-
*.-
*.-   Input    : LNUM  : true if good event for the given process
*.-              ISUM: index of sum
*.-   Output   : -
*.-   Called   : USBAT
*.-   Calls    : ROCSUM, SUFD, SUSW
*.-   Seq.     : ROCRCM,ROPAR,ROTPAR,CRO,RCREP
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.02
*.-   Created  : 24-JAN-1994
*.-   Last mod :  7-DEC-1994
*.-
*.- Modification log:
*.     7-DEC-1994   C. Grandi: Allow counting also before 1993
*.     8-APR-1994   M.Redmond: Add LUMDST flag
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
+SEQ,ROPAR,ROTPAR,CRO.
+SEQ,RCREP.
*
      LOGICAL LNUM
      INTEGER ISUM, IRUN, IEVT
      INTEGER FDDST, FDTST
      INTEGER SWDST, SWTST
      LOGICAL SWOK, FDOK
*     Last run/event analyzed for luminosity analysis:
      INTEGER IRUOLD(NMXCNT), IEVOLD(NMXCNT)
      SAVE    IRUOLD, IEVOLD
*     Last run/event called with .TRUE. numerator:
      INTEGER IRUOLN(NMXCNT), IEVOLN(NMXCNT)
      SAVE    IRUOLN,         IEVOLN
*
      LOGICAL LDOLUM, LDONUM, LDSTOK
*
+SEQ,ODSFUN1.
+SEQ,ROBANK.
*
*.----------------------------------------------------------------------
*
      DATA IRUOLD /NMXCNT*0/
      DATA IEVOLD /NMXCNT*0/
      DATA IRUOLN /NMXCNT*0/
      DATA IEVOLN /NMXCNT*0/
*
+SEQ,ODSFUN2.
*
*.----------------------------------------------------------------------
*
      LDONUM = LNUM
*
*--   Check for valid sum index
      IF(ISUM.LT.1.OR.ISUM.GT.NMXCNT)THEN
        WRITE(CHREP,1001)ISUM
        CALL REPORT('ROCROS',2,'E')
        GOTO 999
      ENDIF
*--   This sum has been used!
      LCNTUS(ISUM) = .TRUE.
*
*--   Get run number
      IRUN = IUHEAD(IIRUN)
*
*--   Get event number
      IEVT = IUHEAD(IIEVT)
*
      IF (LUMDST) THEN
*
*--   See if DST is present
        CALL ODFUNS
        LDSTOK = NGNRL .GT. 0
*     If call has been made from USHEAD we don't have DST.
*     Don't do DST lumi analysis
        IF(.NOT.LDSTOK)THEN
          LDOLUM = .FALSE.
*       Don't record this run-event number so that event will be
*       analyzed at next call (from USBAT)
        ELSE
*--     Check if this run/event has been analyzed in this lumisum
          IF(IRUN .EQ. IRUOLD(ISUM) .AND. IEVT .EQ. IEVOLD(ISUM))THEN
*         Event already analyzed. Do only numerator analysis
            LDOLUM = .FALSE.
          ELSE
*         Event not analyzed: do both lumi and numerator analysis
            LDOLUM = .TRUE.
            IRUOLD(ISUM) = IRUN
            IEVOLD(ISUM) = IEVT
          ENDIF
        ENDIF
      ELSE
*--   Check if this run/event has been analyzed in this lumi sum
        IF(IRUN .EQ. IRUOLD(ISUM) .AND. IEVT .EQ. IEVOLD(ISUM))THEN
*       Event already analyzed. Don't do lumi analysis
          LDOLUM = .FALSE.
        ELSE
*       Event not analyzed: do lumi analysis
          LDOLUM = .TRUE.
          IRUOLD(ISUM) = IRUN
          IEVOLD(ISUM) = IEVT
        ENDIF
      ENDIF
*     Check if this run/event has been summed as a numerator event
      IF(LDONUM)THEN
        IF(IRUN .EQ. IRUOLN(ISUM) .AND. IEVT .EQ. IEVOLN(ISUM))THEN
*         Event already summed. Don't sum again
          LDONUM = .FALSE.
          WRITE(CHREP,1002)ISUM
          CALL REPORT('ROCROS',3,'W')
        ELSE
*         Event not yet summed. Let's sum it
          IRUOLN(ISUM) = IRUN
          IEVOLN(ISUM) = IEVT
        ENDIF
      ENDIF
*
*--   Count number of times the event is a good numerator event
      IF(LDONUM)NTNUM(ISUM) = NTNUM(ISUM) + 1
*
*--   Get FD and SW detector and trigger status
*
      CALL SUFD ( FDDST, FDTST )
      CALL SUSW ( SWDST, SWTST )
*--   Require FD detector status = 3 and trigger status = 3 or 0
*--   Require SW detector status = 3 and trigger status = 3

      FDOK = FDDST.EQ.3.AND.(FDTST.EQ.3.OR.FDTST.EQ.0)
      SWOK = SWDST.EQ.3.AND.SWTST.EQ.3
*
      IF(SWOK)THEN
*--     If SW det/trig status is good sum quantities of class 1
*--     Count numerator events
        IF(LDONUM)NNUM(1,ISUM) = NNUM(1,ISUM) + 1
*--     Count SW luminosity events
        IF(LDOLUM)CALL ROCSUM(1,1,ISUM,LDONUM)
        IF(FDOK)THEN
*--       If both SW and FD det/trig status are good sum also class 2
*--       Count numerator events
          IF(LDONUM)NNUM(2,ISUM) = NNUM(2,ISUM) + 1
*--       Count SW and FD luminosity events
          IF(LDOLUM)CALL ROCSUM(2,1,ISUM,LDONUM)
          IF(LDOLUM)CALL ROCSUM(2,2,ISUM,LDONUM)
        ENDIF
      ELSE
        IF(FDOK)THEN
*--       If FD det/trig status is good and SW not, sum class 3
*--       Count numerator events
          IF(LDONUM)NNUM(3,ISUM) = NNUM(3,ISUM) + 1
*--       Count FD luminosity events
          IF(LDOLUM)CALL ROCSUM(3,2,ISUM,LDONUM)
        ELSE
*--       If both SW and FD det/trig status are bad return
          GOTO 999
        ENDIF
      ENDIF
*
 1000 FORMAT(1X,'SW not available before run 4035! Current run=',I5)
 1001 FORMAT(1X,'Argument ',I5,' outside valid range')
 1002 FORMAT(1X,'Called with TRUE arg twice in same event and sum:',I5)
*
  999 RETURN
      END
+DECK,ROCSUM.
      SUBROUTINE ROCSUM(ICL,IL,ISUM,LNUM)
*.----------------------------------------------------------------------
*.-
*.-....   ROCSUM : Sums quantities for ROCROS calculations
*.-
*.-
*.-
*.-   Input    : ICL  : class index
*.-              IL   : luminosity index (1 is SW, 2 is FD)
*.-              ISUM : sum index
*.-              LNUM : .TRUE. if a good numerator event
*.-   Output   : -
*.-   Called   : ROCROS
*.-   Calls    : RGETEB,ROLUFD,ROLUSW
*.-   Seq.     : ROCRCM,RCREP
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.03
*.-   Created  : 26-JAN-1994
*.-   Last mod : 24-JUL-1995   C.Grandi
*.-
*.-   Modification log:
*.-   24-JUL-1995   C.Grandi:   Fix bug in stat. err. determination
*.-    7-DEC-1994   C.Grandi: Count FD Bhabha's from RGETLU (before 1993)
*.    27-APR-1994   M.Redmond: Change **2. to **2
*.-    5-FEB-1994   C.Grandi: Fix stat. error on (SWITR+SWITL)/2
*.-    3-FEB-1994   C.Grandi: Added (SWITR+SWITL)/2 luminosity counting
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
+SEQ,ROPAR,ROTPAR,CRO.
+SEQ,RCREP.
*
      INTEGER ICL,IL,IRUN
      INTEGER ISUM
      LOGICAL LNUM
*
      REAL    ROOT2
      PARAMETER(ROOT2=1.414214)
*
      REAL    EBEAM, SYSEB
      INTEGER LEPFIL
*
      REAL    EVLU(NLUMI), SYSEVL(NLUMI), PTPEVL(NLUMI)
      REAL    SWLU(3), SYSSWL(3), PTPSWL(3)
      REAL    FDLU, SYSFDL, PTPFDL
      REAL    EBDIF
      DOUBLE PRECISION ESPRD2
*
      INTEGER ILUM
*
      LOGICAL LSIW
*
*.----------------------------------------------------------------------
*
*--   Check wether SiW is already present
*
      IRUN = IUHEAD(IIRUN)
      IF(IRUN .LT. 4035)THEN
        LSIW = .FALSE.
      ELSE
        LSIW = .TRUE.
      ENDIF
*
*--   Get beam energy
*
      CALL RGETEB(EBEAM,SYSEB,LEPFIL)
*--   Check for valid beam energy
      IF(EBEAM.LE.0.)THEN
        WRITE(CHREP,1000)EBEAM
        CALL REPORT('ROCSUM',1,'E')
        GOTO 999
      ENDIF
*
*--   Get needed luminosity informations
*
      DO 20 ILUM = 1,NLUMI
        EVLU(ILUM) = 0.
        SYSEVL(ILUM) = 0.
        PTPEVL(ILUM) = 0.
   20 CONTINUE
      IF(LSIW .AND. IL .EQ. 1)THEN
*       Silicon-Tungsten
        CALL ROLUSW(EBEAM, SWLU, SYSSWL, PTPSWL)
*       SWITA events (ILUM = 1)
        EVLU(1) = SWLU(1)
        SYSEVL(1) = SYSSWL(1)
        PTPEVL(1) = PTPSWL(1)
*       (SWITR+SWITL)/2 events (ILUM = 3)
        EVLU(3) = ( SWLU(2) + SWLU(3) )/2.
        SYSEVL(3) = ( SYSSWL(2) + SYSSWL(3) )/2.
        PTPEVL(3) = ( PTPSWL(2) + PTPSWL(3) )/2.
        IF(SWLU(2).GT.0.OR.SWLU(3).GT.0)THEN
          L2RL(ICL,ISUM) = L2RL(ICL,ISUM) + 0.25*(SWLU(2) + SWLU(3))**2
          IF     (SWLU(2).GT.0.AND.SWLU(3).LE.0)THEN
            L2RLBR(ICL,ISUM) = L2RLBR(ICL,ISUM) + 0.25*SWLU(2)**2
          ELSE IF(SWLU(2).LE.0.AND.SWLU(3).GT.0)THEN
            L2RBRL(ICL,ISUM) = L2RBRL(ICL,ISUM) + 0.25*SWLU(3)**2
          ENDIF
          IF(SWLU(2).GT.0)NBHA(3,ICL,ISUM) = NBHA(3,ICL,ISUM) + 0.5
          IF(SWLU(3).GT.0)NBHA(3,ICL,ISUM) = NBHA(3,ICL,ISUM) + 0.5
        ENDIF
      ELSE IF(LSIW .AND. IL .EQ. 2)THEN
*       Forward detector (1993 onwards)
        CALL ROLUFD(EBEAM, FDLU, SYSFDL, PTPFDL)
*       FD events (ILUM = 2)
        EVLU(2) = FDLU
        SYSEVL(2) = SYSFDL
        PTPEVL(2) = PTPFDL
      ELSE IF(.NOT.LSIW .AND. IL .EQ. 2)THEN
*       Forward detector (up to 1992)
        CALL RGETLU(EBEAM, FDLU, SYSFDL, PTPFDL)
*       FD events (ILUM = 2)
        EVLU(2) = FDLU
        SYSEVL(2) = SYSFDL
        PTPEVL(2) = PTPFDL
      ELSE
*       Invalid luminosity index
        WRITE(CHREP,1001)IL
        CALL REPORT('ROCSUM',2,'E')
        GOTO 999
      ENDIF
*     Sum quantities:
      DO 10 ILUM = 1, NLUMI
        IF(EVLU(ILUM) .GT. 0.)THEN
          IF(LU(ILUM,ICL,ISUM).EQ.0.)THEN
*           First lumi event for this class
            EBOF(ILUM,ICL,ISUM) = EBEAM
          ENDIF
          LU(ILUM,ICL,ISUM)    = LU(ILUM,ICL,ISUM) + EVLU(ILUM)
          LU2(ILUM,ICL,ISUM)   = LU2(ILUM,ICL,ISUM) + EVLU(ILUM)**2
          SYSLU(ILUM,ICL,ISUM) = SYSLU(ILUM,ICL,ISUM) + SYSEVL(ILUM)
*         Number of Bhabha's and statistic error is counted in a
*         different way for (SWITA and FD) and (SWITR+SWITL)/2
          IF(ILUM .LE. 2)THEN
*           SWITA or FD lumi:
            NBHA(ILUM,ICL,ISUM)  = NBHA(ILUM,ICL,ISUM) + 1.
            STALU(ILUM,ICL,ISUM) = DSQRT(LU2(ILUM,ICL,ISUM))
          ELSE
*           (SWITR+SWITL)/2 lumi:
            STALU(ILUM,ICL,ISUM) = DSQRT( L2RL(ICL,ISUM) + L2RBRL(ICL,
     +                                  ISUM) + L2RLBR(ICL,ISUM))
          ENDIF
          EBDIF = EBEAM - EBOF(ILUM,ICL,ISUM)
          LUEDIF(ILUM,ICL,ISUM) = LUEDIF(ILUM,ICL,ISUM) + EVLU(ILUM)
     +      *EBDIF
          LUEDF2(ILUM,ICL,ISUM) = LUEDF2(ILUM,ICL,ISUM) + EVLU(ILUM) *
     +                          EBDIF**2
          LUSYSE(ILUM,ICL,ISUM) = LUSYSE(ILUM,ICL,ISUM) + EVLU(ILUM)
     +      *SYSEB
          EMEAN(ILUM,ICL,ISUM)  = EBOF(ILUM,ICL,ISUM) +
     +             LUEDIF(ILUM,ICL,ISUM) / LU(ILUM,ICL,ISUM)
          ESPRD2 = LUEDF2(ILUM,ICL,ISUM) / LU(ILUM,ICL,ISUM) -
     +            (LUEDIF(ILUM,ICL,ISUM) / LU(ILUM,ICL,ISUM))**2
          IF(ESPRD2.GT.0.)THEN
            ESPRD(ILUM,ICL,ISUM)  = DSQRT(ESPRD2) * DSQRT(1. / (1.-
     +             LU2(ILUM,ICL,ISUM) / LU(ILUM,ICL,ISUM)**2 ) )
          ELSE
            ESPRD(ILUM,ICL,ISUM)  = 0.
          ENDIF
          SYEMEA(ILUM,ICL,ISUM) = LUSYSE(ILUM,ICL,ISUM) /
     +             LU(ILUM,ICL,ISUM)
          STEMEA(ILUM,ICL,ISUM) = ESPRD(ILUM,ICL,ISUM) *
     +             STALU(ILUM,ICL,ISUM) / LU(ILUM,ICL,ISUM)
          STESPR(ILUM,ICL,ISUM) = STEMEA(ILUM,ICL,ISUM) / ROOT2
        ENDIF
   10 CONTINUE
*
 1000 FORMAT(1X,'Beam energy =',F10.3,' event not counted')
 1001 FORMAT(1X,'Wrong luminosity index =',I5)
*
  999 RETURN
      END
+DECK,ROLUFD.
      SUBROUTINE ROLUFD(EBEAM,FDLU,SYSFDL,PTPFDL)
*.
*...ROLUFD  Returns the forward detector (FD) luminosity for a Bhabha
*           event and the systematic errors on this luminosity.
*.
*.  INPUT  : EBEAM    Beam energy for event (GeV)
*. OUTPUT  : FDLU     Luminosity for event (1/nb)
*.           SYSFDL   Absolute systematic error on luminosity (1/nb)
*.           PTPFDL   Point-to-point fractional systematic error on lumi
*.                    (all returned as 0 if not a luminosity event)
*.
*. SEQUENCE: CRO ROPAR ROTPAR RBITFUNC RCREP
*. CALLS   : REPORT
*. CALLED  : ROCSUM
*.
*.
*. AUTHOR  : Mark Thomson
*. VERSION : 416.00
*. CREATED : 02-Feb-94
*. LAST MOD: 02-Apr-98
*.
*. Modification Log.
*. 02-Apr-98 J.E.Conboy : Introduce CORE, departure from exact 1/s**2 
*                         dependence
*. 08-May-97 J.E.Conboy : Call SULUDB to get luminosity
*. 25-Feb-97 J.E.Conboy : Remove CORPT correction, ( Ad hoc fix for 1993 )
*.                        Report correction if Ebeam changes by > 1Gev
*. 16-Jan-97 J.E.Conboy : BUG Test for I/f correction was complete Garbage
*.                        Ensure IEPT is initialised
*. 10-Jul-96 J.E.Conboy : Remove parameters to SUFDLU
*. 23-Apr-96 J.E.Conboy : Revise 1995 p3 Xsec = 1.034*Pass 1
*. 22-Apr-96 J.E.Conboy : Allow Xsec as a function of ROPE pass
*.                        Add CUBED lumi for 95 p69-75
*. 29-Jan-96 J.E.Conboy : Revise FD Xsec again, use Bhlumi 4 calc
*. 11-Jan-96 J.E.Conboy : Revise FD Xsec, use mean of 130 & 135 Gev values
*.                        in FD note 95/2 ( Lumi at LEP1.5 )
*. 30-NOV-95 C.Grandi   : Add dummies up to 1995
*.                        Update LEP 1.5 valuse with Jim's numbers
*. 05-Feb-94 C.Grandi   : Add "FD" in reports
*. 04-Feb-94 M Thomson  : PTPERR now handles different error for diff.
*.                        E points.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROTPAR.
+SEQ,RBITFUNC.
+SEQ,RCREP,RCLINE.
*
      REAL         EBEAM,FDLU,PTPFDL, SYSFD,SYSFDL
*
*
      CHARACTER*11 UPDATE
      SAVE         UPDATE
*
      INTEGER      LRUN,LRVER,LROPIN, IERR
      LOGICAL      FIRST, REP, SWFDLU
      SAVE         LRUN,FIRST,LRVER,LROPIN
*
      REAL         XEB, XSEC, DXSEC
*
* For interference correction
      INTEGER      NSCAN, NPOINT
      INTEGER      IP,INDEX, IBITLU, IXOLD
      PARAMETER    (NPOINT=14, NSCAN=3)
      REAL EBGEN(NPOINT),CORINT(NPOINT),CORI,A,EBEAMS
      REAL         CORS, CORE, FCORE, EC
      SAVE EBGEN        ,CORINT        ,CORI  ,EBEAMS, CORE
*
* Date of last update to this routine
      DATA         UPDATE/'02-Apr-98'/
************************************************************************
*
* Data for interference correction
* Interference term for 1993 - inner edge of TOTbar cross section now
* defined by SiW - hence larger angles and effect of Z-gamma int. is
* greater - BHAGEN - normalized to 45.55 point
*
      DATA EBGEN/40.,43.55,44.05,44.55,45.05,45.25,45.55,
     +               45.75,46.05,46.55,47.05,47.55,50.00,55. /
      DATA CORINT/0.9972,1.0016,1.0030,1.0051,1.0066,1.0057,1.0000,
     +            0.9946,0.9896,0.9885,0.9895,0.9906,0.9935,0.9989 /
*
      DATA         FIRST/.TRUE./
*
      DATA    EBEAMS,CORI / -1.  , 1. /
*-    DATA    CORPT       / 1., 1., 0.99915 /
*                                   =======    Why ??  16-Jan-97 JEC
*=    Probably a fixup for 1993 from MT, so now removed ( 12-5-97 414.00, JEC)
*
*==           Statement function -------------------------------------------
*==       Correction to 1/s**2 dependence; see
*         http://www.hep.ucl.ac.uk/~jec/fd/lu97/pass_3.html
*
      FCORE( EC )  =  0.99384 + EC*( 0.44782E-04 + EC*0.19118E-06)
*------------------------------------------------------------------------
*
* For Monte Carlo events just return zero
      IF(IUHEAD(IIEXPT).GE.1000)THEN
        FDLU=0.
        SYSFDL=0.
        PTPFDL=0.
        RETURN
      ENDIF
*
* On first call print date of last update to this routine
      IF(FIRST)THEN
        FIRST=.FALSE.
        WRITE(CHREP,1000) UPDATE
        CALL REPORT('ROLUFD',1,'I')
        REP    =  ABS( EBEAMS-EBEAM) .GT. 1.
        LRUN  =  0
        LRVER =  0
        LROPIN=  0
        IXOLD =  0
      ELSE
        REP   =  .FALSE.
      ENDIF

*
*-- Get parameters from SU
*
      XEB    =  EBEAM
      IBITLU = 0
      CALL SULUDB( 'FD',  IBITLU, XEB, XSEC, DXSEC, IERR )
      SYSFD   =  DXSEC/XSEC
      PTPFDL  =  0.
      IF( IERR .NE. 0 )                                 THEN
*
        CHREP  =  'Error from SULUDB '
        IF( IRDEBU .NE. 0 ) CALL REPORT( 'ROLUFD', IERR, 'I' )
*
*--     Obtain data from SUFDLU if nothing on d/base..
*
        CALL SUFDLU( EBEAM, IBITLU, XEB, XSEC, SYSFD, PTPFDL )
        DXSEC  =  XSEC*SYSFD
*
                                                        ENDIF
*
* Compute interference correction if beam energy changed
*
      IF(EBEAM.NE.EBEAMS)                                     THEN
*1/1
        EBEAMS =  EBEAM
        CORI   =  1.
        INDEX  =  0
*
        IF( EBEAM.GE.EBGEN(1).AND.EBEAM.LE.EBGEN(NPOINT) ) THEN
          DO 100 IP=1,NPOINT-1
*d1
            IF(     EBEAM.GE.EBGEN(IP)
     +        .AND.EBEAM.LT.EBGEN(IP+1))              THEN
*3/1
              INDEX  =  IP
              A =  (CORINT(INDEX+1) - CORINT(INDEX))
     +            /(EBGEN (INDEX+1) - EBGEN (INDEX))
              CORI =  CORINT(INDEX) + A*(EBEAM-EBGEN(INDEX))
+SELF,IF=*DEBUG.
              WRITE(CHLINE,'(A,F10.2,I3,F10.4)')
     +        'EBEAM, INDEX, CCORI = ',EBEAM,INDEX,CORI
              CALL RMAIL(0,0)
+SELF.
                                                      GOTO 101
                                                      ENDIF
*3/-
 100      CONTINUE
*-d1
          WRITE(CHREP,1001)
          CALL REPORT('ROLUFD',91,'W')
          CORI=1.
  101     CONTINUE
*
                                                            ELSE
          WRITE(CHREP,'(A,F10.2)' )
     +        'Setting CORI = 1. for Ebeam = ',EBEAM
          CALL REPORT( 'ROLUFD', 92, 'W' )
          CORI=1.
                                                            ENDIF
*2/-
                                                              ENDIF
*1/-
*-- Check whether this is a luminosity event
*-- (-1 from bit index to go from OPAL 1-32 to FORTRAN 0-31 convention)
*
      SWFDLU  =  BTEST( IUHEAD(IIEVTY), IBITLU-1 )
      IF(SWFDLU .OR. REP )                                    THEN
*-- Get luminosity/event (1/cross section) corrected for beam energy; 
*       CORS  is the Theoretical 1/s**2 dependence
*       CORE  is a parameterization of departure from this, determined from
*       smear MC
*
        CORS   =  (XEB/EBEAM)**2
        CORE   =  FCORE(EBEAM) / FCORE( XEB)
        FDLU   =  1. / (XSEC*CORS*CORI*CORE)
        SYSFDL =  FDLU*SYSFD
                                                              ENDIF
      IF( REP )                                               THEN
        WRITE(CHLINE,1010) EBEAM,FDLU
        CALL RMAIL(0,0)
        WRITE(CHLINE,1011) XSEC, DXSEC, CORS, CORE, CORI
        CALL RMAIL(0,0)
                                                              ENDIF

      IF( .NOT. SWFDLU ) THEN
*-- Not a luminosity event. Return luminosity and error as zero.
        FDLU=0.
        SYSFDL=0.
        PTPFDL=0.
      ENDIF
*
      RETURN
*
 1000 FORMAT(' FD luminosity calculation last updated ',A11)
 1001 FORMAT(' FD Pb with Interference correction (=0)')
 1010 FORMAT( ' ROLUFD-',T22,'Lu/Event at ',F8.3,' :- ',F12.6)
 1011 FORMAT( T22,F10.4,' +- ',F6.4,
     +        ' nb , corrections for s, E, If are ',3F12.6 )
*
      END
+DECK,ROLUSW.
      SUBROUTINE ROLUSW(EBEAM,LUWEIT,ABSERR,RELERR)
*.----------------------------------------------------------------------
*.-
*.-....   ROLUSW : Returns SW lumi weight for a given event
*.-
*.-
*.-
*.-   Input    : EBEAM  : beam energy
*.-   Output   : LUWEIT(IL) : luminosity weight
*.-              ABSERR(IL) : systematic error on lumi
*.-              RELERR(IL) : point to point error on lumi
*.-                           IL = 1 for SWITA lumi
*.-                           IL = 2 for FD lumi
*.-                           IL = 3 for (SWITR+SWITL)/2
*.-
*.-   Called   : ROCROS
*.-   Calls    : RBABSW,TRPFSW
*.-   Seq.     : ROPAR,ROTPAR,CRO,RCREP,ROCRCM
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.08
*.-   Created  : 24-JAN-1994
*.-   Last mod :  7-May-99
*.-
*.-   Modification log:
*.-    7-May-99 M.Schroder    Fix I and L edit descriptors for linux
*.--   3-May-1999   A.Macchiolo: Add xsec and sys error for 1998 189 GeV data
*.-   24-Aug-98     D.Strom   : Change 9999 to 99999 in data statement (lasrun)
*.-   20-Apr-1998   D.Strom   : Give systematic correct error for 1997 data
*.-   16-Apr-1998   D.Strom   : Update SWITA for "mask" acceptance
*.-   25-Mar-1998   D.Strom   : Update for LEP II energies
*.-   11-Oct-1997   D.Strom   : Finalize idea cross sections...
*._   10-Jun-1997   D.Strom   : Add energy to tilt correction call of ROSWTC
*.-   10-Dec-1996   S.Arcelli : Add xsec and sys error for 1996 172 GeV Data.
*.-                 S.Arcelli : Rescale the 161 GeV Xsec by +0.19%
*.-                 S.Arcelli : Update  the 161 GeV hdr and dst
*.-                             lumi sys error to 0.32%.
*.-   23-Aug-1996   G.W.Wilson: Check trigger layer and use prescale
*.-                             factor for SWSEG and not SWHIOR.SWSUM.
*.-   19-JUL-1996   S.Arcelli: Add 2 bins for 1996 peak + 161 GeV Data.
*.-                 S.Arcelli: LEP 1.6 sys. error set to 0.41%.
*.-   30-JAN-1996   C.Grandi : Fix assignment of IBIN inside loop
*.-                 C.Grandi : LEP 1.5 sys. error set to 0.45%
*.-                           (mod on private version dated 29-JAN-1996)
*.-                 C.Grandi : x-secs for 1993 1994 with BHLUMI 4.02
*.-                                  for 1995/LEP 1.5 with BHLUMI 4.03
*.-                           (mod on private version dated 27-NOV-1995)
*.-                 C.Grandi : Add 1995 dummies
*.-                           Include trigger prescale factors
*.-                           Calculate iterf. term only at peak
*.-                           (mod on private version dated 20-NOV-1995)
*.-   22-JUN-1995   C.Grandi : Norm. factor for pass4 1993 header sel.
*.-   23-MAY-1995    C.Grandi : BHLUMI4 X-sec for 1993 and 1994 DST sel.
*.-                           Theory error included in sys. error
*.-    1-FEB-1995   C.Grandi : New 1994 X-sec
*.-    1-FEB-1995   C.Grandi : Fix 1993 X-sec for 2*10**-4 effect (anch.)
*.-    7-DEC-1994   C.Grandi : Change X-sections for new selections
*.-   27-APR-1994   M.Redmond: Change **2. to **2
*.-    8-APR-1994   M.Redmond: Add LUMDST flag
*.-    6-FEB-1994   S.Arcelli,C.Grandi: X-section for DST selection
*.-    5-FEB-1994   S.Arcelli,C.Grandi: Include correction for Z pos.
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
+SEQ,ROPAR,ROTPAR,CRO.
+SEQ,RCREP.
*
      LOGICAL REVTYP
      EXTERNAL REVTYP
*
*     Last update of this routine
      CHARACTER*11 UPDATE
      SAVE         UPDATE
      LOGICAL FIRST
      SAVE    FIRST
*
      INTEGER IBIN
      INTEGER NBIN
      PARAMETER(NBIN=13)
*     Last run to which a given xsec applies
      INTEGER LASRUN(0:NBIN)
      SAVE    LASRUN
*     Cross section and cms energy at which it's given:
      REAL    XSEC0(3), ECMS0
      REAL    XSEC0D(3,NBIN), ECMS0D
      REAL    XSEC0H(3,NBIN), ECMS0H
      SAVE    XSEC0D, ECMS0D, XSEC0H, ECMS0H
*     Systematic and point to point errors on cross section:
      REAL    SYSERR(3), PTPERR(3)
      REAL    SYSERD(3,NBIN),PTPERD(3,NBIN)
      REAL    SYSERH(3,NBIN),PTPERH(3,NBIN)
      SAVE    SYSERH, PTPERH, SYSERD, PTPERD
*     For interference correction:
      REAL    ROSWIC
      EXTERNAL ROSWIC
*     For beam tilt and offset correction:
      REAL    ROSWTC
      EXTERNAL ROSWTC
*
      REAL    EBEAM, LUWEIT(3), ABSERR(3), RELERR(3)
      INTEGER IRUN
      LOGICAL LSWITA,LSWITR,LSWOTR,LSWITL,LSWOTL
*
      REAL    XSEC(3), ECMS
      SAVE    XSEC,    ECMS
      REAL    INTFAC, TLTFAC(3)
      SAVE    INTFAC, TLTFAC
      INTEGER IRUOLD
      SAVE    IRUOLD
      REAL    EBOLD
      SAVE    EBOLD
*
      INTEGER ILUM,IDO
*
      INTEGER ILSWH,IPSWH,ILSSEG,IPSSEG,ILSSGA,IPSSGA
      INTEGER ITLAY
      REAL    TFAC
      SAVE ITLAY,TFAC
*
*
*  Correction for ee -> gamma gamma (real photons)
*  At present this applied to the ideal cross section for
*  the LEP 1.5 and LEP 2.0 data...
*
      REAL EEGG
      PARAMETER (EEGG = 2.0E-4)
      REAL FEEGG
*
*
*.----------------------------------------------------------------------
*     Data statements:
*     X section for old SWITA and SWITR-SWITL + energy
      DATA XSEC,INTFAC,TLTFAC,ECMS/8*0.0/
*     Last update of this routine
      DATA UPDATE,FIRST /'19-APR-1999',.TRUE./
*
      DATA LASRUN/0,4000,5000,5180,5600,
     + 6000,6803,7000,7199,7469,7769,8890,10544,99999/
*     Born cross section (nb) and cms energy (GeV) at which it's given:
*     DST selection:
*
*     these are "four vector" cross sections from bhlumi for all
*     LEP 1 data.  Detector corrections are nearly zero and are put
*     in ROSWTC.   The corrections do not include any beam energy
*     effects (interferance, etc) or the background from gamma gamma
*
*                         SWITA ,SWITR ,SWITL
      DATA XSEC0D,ECMS0D / 3*0.0,
*
* from  [strom.sw94.acc]rolusw_tab.kumac...
* 1993
     +      78.898, 78.898, 78.898,
* 1994a
     +      78.898, 78.898, 78.898,
* 1994b
     +      78.898, 78.898, 78.898,
* 1994c
     +      78.898, 78.898, 78.898,
* 1995
     +      78.898, 78.898, 78.898,
*
* unchanged for now..
*
*                 1995 LEP1.5:
     +                    79.330,78.809,78.809,
*                 1996 Peak:
     +                    36.882,36.484,36.484,
*                 1996 161 GeV:
     +                    36.882,36.484,36.484,
*                 1996 172 GeV:
     +                    36.882,36.484,36.484,
*                 1997 183 GeV:
     +                    36.882,36.484,36.484,
*                 1998 189 GeV:
     +                    36.882,36.484,36.484,
*                 raw   :
     +                    36.882,36.484,36.484,
*                 energy:
     +                    91.1/
*     header selection:
*                         SWITA ,SWITR ,SWITL
      DATA XSEC0H,ECMS0H / 3*0.0,
*
* based SIW TN 72
*
* 1993
     +      78.977, 78.955, 78.955,
* 1994a
     +      78.982, 78.950, 78.950,
* 1994b
     +      78.974, 78.950, 78.950,
* 1994c
     +      78.979, 78.956, 78.956,
* 1995
     +      78.956, 78.951, 78.951,

*
* unchanged for now..
*
*                 1995 LEP1.5:
     +                    79.330,78.809,78.809,
*                 1996 Peak:
     +                    36.882,36.484,36.484,
*                 1996 161 GeV:
     +                    36.882,36.484,36.484,
*                 1996 172 GeV:
     +                    36.882,36.484,36.484,
*                 1997 183 GeV:
     +                    36.882,36.484,36.484,
*                 1998 189 GeV:
     +                    36.882,36.484,36.484,
*                 raw   :
     +                    36.882,36.484,36.484,
*                 energy:
     +                    91.1/
*     Systematic and point to point errors on X-section (DST-header):
*                   SWITA , SWITR , SWITL
      DATA SYSERD / 3*1.0,
*
*
*                 1993  :
     +              0.0012, 0.0012, 0.0012,
*                 1994/A:
     +              0.0012, 0.0012, 0.0012,
*                 1994/B:
     +              0.0012, 0.0012, 0.0012,
*                 1994/C:
     +              0.0012, 0.0012, 0.0012,
*                 1995 LEP1:
     +              0.0012, 0.0012, 0.0012,
*
*                 1995 LEP1.5:
     +              1.0000, 0.0045, 0.0045,
*                 1996 peak:
     +              1.0000, 0.0032, 0.0032,
*                 1996 161 GeV:
     +              1.0000, 0.0032, 0.0032,
*                 1996 172 GeV:
     +              1.0000, 0.0035, 0.0035,
*                 1997 183 GeV:
     +              1.0000, 0.0035, 0.0035,
*                 1998 189 GeV:
     +              1.0000, 0.0020, 0.0020,
*                 raw   :
     +              1.0000, 1.0000, 1.0000/
      DATA PTPERD / 3*1.0,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              1.00000, 1.00000, 1.00000/
*
*   Allow an additional systematic error of 0.0009 for
*   difference between header and dst selection....
*
      DATA SYSERH / 3*1.0,
*                 1993  :
     +              0.0015, 0.0015, 0.0015,
*                 1994/A:
     +              0.0015, 0.0015, 0.0015,
*                 1994/B:
     +              0.0015, 0.0015, 0.0015,
*                 1994/C:
     +              0.0015, 0.0015, 0.0015,
*                 1995 LEP1:
     +              0.0015, 0.0015, 0.0015,
*                 1995 LEP1.5:
     +              1.0000, 0.0045, 0.0045,
*                 1996 peak:
     +              1.0000, 0.0032, 0.0032,
*                 1996 161 GeV:
     +              1.0000, 0.0032, 0.0032,
*                 1996 172 GeV:
     +              1.0000, 0.0035, 0.0035,
*                 1997 183 GeV:
     +              1.0000, 0.0035, 0.0035,
*                 1998 189 GeV:
     +              1.0000, 0.0020, 0.0020,
*                 raw   :
     +              1.0000, 1.0000, 1.0000/
*
      DATA PTPERH / 3*1.0,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              0.00028, 0.00028, 0.00028,
     +              1.00000, 1.00000, 1.00000/

*.
*.  For reference here is the number of events and the luminosity
*.  selected for the final LEP I lineshape paper.  This routine will
*.  give slightly different results due the different treatment of
*.  of the LEP beam energy.  If the routine is called from the header
*.  for PASS7 LEP I data, a different set of cross sections are used
*.  to reflect the difference between the old lumi selection and the
*.  one used for the LEP I publication.  Averaged over a given sample
*.  (see the lumi technical note) the header selection and DST selection
*.  should give almost the save luminosity.  For individual runs, the
*.  the difference could be as large as 1.0e-3.
*.
*.  If the LEP I data is ever reroped again, the header bits will
*.  become identical to the DST selection.
*.
*.  The luminosity of one run in each of the nine samples is given below:
*.
*. sample        run     TKMH      SWITA  SWITR  SWITL      Corrected
*.                                                           Lumi (nb-1)
*.
*. 1993 pk+2      4433   7734      41868  41498  41734          550.84
*. 1993 pk        4343  12383      32647  32346  32411          411.13
*. 1993 pk-2      4424   5220      43698  43405  43433          529.36
*. 1994 A         5051   8867      23659  23457  23534          298.52
*. 1994 B         5555  16952      44788  44343  44646          565.19
*. 1994 C         5659   8497      22710  22598  22523          286.49
*. 1995 pk+2      6551   8394      46099  46093  45536          605.82
*. 1995 pk        6448  14964      39372  39056  39117          497.26
*. 1995 pk-2      6376  5450       45740  45367  45426          553.45
*.
*.----------------------------------------------------------------------
*
*--   Assume it isn't a Bhabha
      DO 10, ILUM = 1,3
        LUWEIT(ILUM) = 0.
        ABSERR(ILUM) = 0.
        RELERR(ILUM) = 0.
   10 CONTINUE
*
*
*--   For Monte Carlo events return
      IF(IUHEAD(IIEXPT).GE.1000)THEN
        GOTO 999
      ENDIF
*
*--   Get run number
      IRUN = IUHEAD(IIRUN)
*
*--   Check if we know about this version of rope...
      IF( LUMDST) THEN
        IF( IUHEAD(IIPVER).LT.1776 .AND. IRUN.LT.7000 ) THEN
          WRITE(CHREP,1006) IUHEAD(IIPVER)
          CALL REPORT('ROLUSW',6,'I')
          GOTO 999
        END IF
      ELSE
*
        IF( IUHEAD(IIPVER) .LT. 1886 .AND.
     +      IRUN           .LT. 7000      ) THEN
          WRITE(CHREP,1007) IUHEAD(IIPVER)
          CALL REPORT('ROLUSW',7,'I')
          GOTO 999
        END IF
*
* Eventually we will have to check that the processing is
* not too new for the header analysis...
*
      END IF
*--   On first call print date of last update to this routine
      IF(FIRST)THEN
        FIRST = .FALSE.
        WRITE(CHREP,1000)UPDATE,LUMDST
        CALL REPORT('ROLUSW',1,'I')
        IRUOLD = 0
        EBOLD = 0.
      ENDIF

*--   If run number changed find new xsec
      IF(IRUN .NE. IRUOLD)THEN
*--     Find bin
        IBIN = 0
        DO 30 IDO = 1, NBIN
          IF(IRUN.GT.LASRUN(IDO-1) .AND. IRUN .LE. LASRUN(IDO))THEN
            IBIN = IDO
            GOTO 31
          ENDIF
   30   CONTINUE
   31   CONTINUE
        DO 35 ILUM = 1,3
          IF(LUMDST)THEN
            XSEC0(ILUM) = XSEC0D(ILUM,IBIN)
            SYSERR(ILUM) = SYSERD(ILUM,IBIN)
            PTPERR(ILUM) = PTPERD(ILUM,IBIN)
          ELSE
            XSEC0(ILUM) = XSEC0H(ILUM,IBIN)
            SYSERR(ILUM) = SYSERH(ILUM,IBIN)
            PTPERR(ILUM) = PTPERH(ILUM,IBIN)
          ENDIF
   35   CONTINUE
*--     Check that run is not before 1993
        IF(IBIN .EQ. 1)THEN
          WRITE(CHREP,1001)IRUN
          CALL REPORT('ROLUSW',2,'E')
          GOTO 999
        ENDIF
        IRUOLD = IRUN
*--     Correct for ee -> photon photon
        IF(IBIN.LE.6) THEN
           FEEGG = 1.0 + EEGG
        ELSE
           FEEGG = 1.0
        END IF
*--     Find beam tilt and offset correction:
*--     (This now includes all other LEP 1.5 and 2 corrections!)
        DO 20 ILUM = 1,3
          TLTFAC(ILUM) = ROSWTC(IRUN,ILUM,EBEAM)
   20   CONTINUE
*--     If LEP 1.5 or later, find trigger layer and prescale factor for SW
        ITLAY = 0
        TFAC = 1.
        IF(IBIN.GE.7)THEN
          IF(IUHEAD(IIPVER).GE.2080)THEN
            CALL TRPFSW(ILSWH,IPSWH,ILSSEG,IPSSEG,ILSSGA,IPSSGA)
* The layer number and the prescale
* factor for the SWSEG trigger
            ITLAY = ILSSEG
            TFAC = FLOAT(IPSSEG)
          ELSE
            WRITE(CHREP,1002)IUHEAD(IIPVER)
            CALL REPORT('ROLUSW',3,'E')
          ENDIF
        ENDIF
      ENDIF
*--   If beam energy changed calculate new interference correction
      IF(EBEAM .NE. EBOLD)THEN
        EBOLD = EBEAM
        ECMS = 2.*EBEAM
        IF((EBEAM .GE. 44.05 .AND. EBEAM .LE. 46.80) .OR.
     +     (EBEAM .GE. 64.00 .AND. EBEAM .LE. 71.00) .OR.
     +     (EBEAM .GE. 78.00 .AND. EBEAM .LE. 83.00) .OR.
     +     (EBEAM .GE. 84.00 .AND. EBEAM .LE. 88.00) .OR.
     +     (EBEAM .GE. 90.00 .AND. EBEAM .LE.100.00)  )THEN
          INTFAC = ROSWIC(ECMS)
        ELSE
          WRITE(CHREP,1003)EBEAM
          CALL REPORT('ROLUSW',4,'E')
          INTFAC = 1.0
        ENDIF
      ENDIF
*
*--   If it's a Bhabha calculate lumi weight
      LSWITA = REVTYP(IESWIA)
      LSWITR = REVTYP(IESWIR)
      LSWITL = REVTYP(IESWIL)
      IF (LUMDST) THEN
*--   If asked update using DST selection
        CALL RBABSW(LSWITA,LSWITR,LSWOTR,LSWITL,LSWOTL)
        WRITE(CHREP,1004) LSWITA,LSWITL,LSWITR,IBIN
        CALL REPORT('ROLUSW',5,'I')
        ECMS0 = ECMS0D
      ELSE
        ECMS0 = ECMS0H
      ENDIF
*--   If LEP 1.5 or later
      IF(IBIN.GE.7)THEN
        IF(ITLAY.GT.0)THEN
          IF(.NOT.BTEST(IUHEAD(IIPDDF),ITLAY-1))THEN
            LSWITA = .FALSE.
            LSWITR = .FALSE.
            LSWITL = .FALSE.
          ENDIF
        ELSE
          GOTO 999
        ENDIF
      ENDIF
*
      WRITE(CHREP,1005) LSWITA,XSEC0(1),ECMS,TLTFAC(1),INTFAC
      CALL REPORT('ROLUSW',6,'I')
      WRITE(CHREP,1005) LSWITR,XSEC0(2),ECMS,TLTFAC(2),INTFAC
      CALL REPORT('ROLUSW',6,'I')
      WRITE(CHREP,1005) LSWITL,XSEC0(3),ECMS,TLTFAC(3),INTFAC
      CALL REPORT('ROLUSW',6,'I')
*
      IF(LSWITA)THEN
        ILUM = 1
        XSEC(ILUM) = XSEC0(ILUM) * (ECMS0/ECMS)**2 * TLTFAC(ILUM) *
     +               INTFAC * FEEGG
        LUWEIT(ILUM)  = 1./XSEC(ILUM)*TFAC
        ABSERR(ILUM) = SYSERR(ILUM)*LUWEIT(ILUM)
        RELERR(ILUM) = PTPERR(ILUM)
      ENDIF
      IF(LSWITR)THEN
        ILUM = 2
        XSEC(ILUM) = XSEC0(ILUM) * (ECMS0/ECMS)**2 * TLTFAC(ILUM) *
     +               INTFAC * FEEGG
        LUWEIT(ILUM)  = 1./XSEC(ILUM)*TFAC
        ABSERR(ILUM) = SYSERR(ILUM)*LUWEIT(ILUM)
        RELERR(ILUM) = PTPERR(ILUM)
      ENDIF
      IF(LSWITL)THEN
        ILUM = 3
        XSEC(ILUM) = XSEC0(ILUM) * (ECMS0/ECMS)**2 * TLTFAC(ILUM) *
     +               INTFAC * FEEGG
        LUWEIT(ILUM)  = 1./XSEC(ILUM)*TFAC
        ABSERR(ILUM) = SYSERR(ILUM)*LUWEIT(ILUM)
        RELERR(ILUM) = PTPERR(ILUM)
      ENDIF
*
 1000 FORMAT(1X,'SW luminosity last updated ',A11,
     +          ' Analysis from DST?',L8)
 1001 FORMAT(1X,'SW not available before run 4035! Current run=',I5)
 1002 FORMAT(1X,'LEP 1.5 needs ROPE ver. 2080 or later! Current ver.=',
     +  I8)
 1003 FORMAT(1X,'Beam energy outside valid range: Ebeam =',F12.5)
 1004 FORMAT(1X,'Flags from RBABSW',3L8,' IBIN (sample):',I8)
 1005 FORMAT(1X,'LSWITx,XSEC,ECMS,TLTFAC,INTFAC',L8,4F12.6)
 1006 FORMAT(1X,'ROPE version wrong for use with DST',I8)
 1007 FORMAT(1X,'ROPE version wrong for use with HEADER',I8)
*
  999 RETURN
      END
+DECK,ROSWTC.
      REAL FUNCTION ROSWTC(IRUN,ILUM,EBM)
*.----------------------------------------------------------------------
*.-
*.-....   ROSWIC : Beam tilt and offset correction for SW X-sec
*.-
*.-
*.-
*.-   Returned value  : Correction factor for SW X-sec
*.-   Input    : IRUN : run number
*.-   Called   : ROLUSW
*.-   Calls    : -
*.-   Seq.     : RCREP
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.03
*.-   Created  : 28-JAN-1994
*.-   Last mod :  3-May-99
*.-
*.-   Modification log:
*.-    3-May-99 A. Macchiolo Include correction for 189 GeV data    
*.-   24-Aug-98 M.Schroder  Increase max run number from 10000 to 99999
*.-   20-APR-1998   D.Strom     Adjusted dst/header difference
*.-   26-Mar-1998   D.Strom     Frist update for dst/header difference
*.-   25-Mar-1998   D.Strom     Include LEP 2 numbers...
*.-   10-Oct-1997   D.Strom:    Parameterize by SW sample
*.-    3-FEB-1995   M.Mannelli: Include better corrections for 1994 (by Steve)
*.-    1-FEB-1995   C.Grandi:   Include corrections for 1994 (by Steve)
*.-   12-DEC-1994   C.Grandi:   Dummy corrections for 1994
*.-
*.     Beam tilt and offset correction per sample
*.     this routine now includes energy effects as well
*.     the difference between SWITA and SWITRL is now given by
*.     x-sec in rolusw
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROTPAR.
+SEQ,ROCRCM.
*
*     Last update of this routine
      CHARACTER*11 UPDATE
      SAVE         UPDATE
      LOGICAL FIRST
      SAVE    FIRST
*
      INTEGER IRUN, ILUM
      REAL    EBM
*
      INTEGER KKK
      INTEGER ISMP
*
      INTEGER NMXS
      PARAMETER(NMXS=20)
*
      REAL    TLTCOR(NMXS,3)
      SAVE    TLTCOR
*
      REAL    DSTCOR(NMXS)
      SAVE    DSTCOR
*
*   correction to xsec is 1+10-4*tltcor
*
* SWITA
*
      DATA (TLTCOR(KKK,1),KKK=   1,  NMXS)/
* 1993
     +       65.15,  64.97,  64.88,
* 1994
     +       64.10,  64.89,  64.74,
* 1995
     +       63.65,  63.84,  63.91,  26.70,
*  1996       (CAL)   (160)    (172)
     +        0.00,  65.90,   71.00,
*  1997       (CAL)   (136)    (182.5)
     +        0.00,  29.99,   70.30,
*  1998       (CAL)  (189)
     +        0.00,   62.25,           
*  1999       (CAL)  (>189)
     +        0.00,   70.00           /
*
*  SWITR
*
      DATA (TLTCOR(KKK,2),KKK=   1,  NMXS)/
* 1995
     +       -0.13,   0.14,  -0.30,
* 1994
     +        2.25,  -1.68,   0.95,
* 1995
     +       -1.11,  -1.13,  -1.00,  26.70,
*  1996       (CAL)   (160)    (172)
     +        0.00,  65.90,   71.00,
*  1997       (CAL)   (136)    (182.5)
     +        0.00,  29.99,   70.30,
*  1998       (CAL)  (189)
     +        0.00,   62.25,           
*  1999       (CAL)  (>189)
     +        0.00,   70.00           /

*  SWITL
*
      DATA (TLTCOR(KKK,3),KKK=   1,  NMXS)/
* 1993
     +     -0.13 , 0.14 , -0.30,
* 1994
     +      2.25, -1.68, 0.95,
* 1995
     +       -1.11,  -1.13,  -1.00,  26.70,
*  1996       (CAL)   (160)    (172)
     +        0.00,  65.90,   71.00,
*  1997       (CAL)   (136)    (182.5)
     +        0.00,  29.99,   70.30,
*  1998       (CAL)  (189)
     +        0.00,   62.25,
*  1999       (CAL)  (>189)
     +        0.00,   70.00           /
*
      DATA (DSTCOR(KKK),KKK=1,NMXS) /
* 1993
     + 0.0, 0.0, 0.0,
* 1994
     + 0.0, 0.0, 0.0,
* 1995
     + 0.0, 0.0, 0.0, 0.0,
* 1996
     +  6.7, 6.7, 6.7,
* 1997
     +  6.7, 6.7, 6.7,
* 1998
     +  0.0, 0.0, 
* 1999
     +  0.0, 0.0 /
*
*     Last update of this routine
      DATA UPDATE,FIRST /'19-Apr-1999',.TRUE./
*
*.----------------------------------------------------------------------
*
*--   Beam tilt and offset correction (one per "sample"):
*
*.----------------------------------------------------------------------
*
*--   Default value for correction
      ROSWTC = 1.
*
*--   Check for valid luminosity index
      IF(ILUM.LT.1.OR.ILUM.GT.3)THEN
        WRITE(CHREP,1001)ILUM
        CALL REPORT('ROSWTC',1,'E')
        GOTO 999
      ENDIF
*--   On first call print date of last update to this routine
      IF(FIRST)THEN
        FIRST = .FALSE.
        WRITE(CHREP,1002)UPDATE
        CALL REPORT('ROSWTC',2,'I')
      END IF
*
*--   Check for valid run number
      IF(IRUN .LT. 4035 )THEN
        WRITE(CHREP,1003)IRUN
        CALL REPORT('ROSWTC',3,'E')
        GOTO 999
      ENDIF
*
*--   Find sample
*
      ISMP = 0
      IF(IRUN.GT. 4035 .AND. IRUN.LT.5000) THEN
        IF( ABS(EBM-44.71).LT. 0.5 ) THEN
          ISMP = 1
        ELSE IF( ABS(EBM-45.61).LT. 0.5 ) THEN
          ISMP = 2
        ELSE IF( ABS(EBM-46.5).LT. 0.5 ) THEN
          ISMP = 3
        END IF
      ELSE IF(IRUN.GE.5000 .AND. IRUN.LE.5180) THEN
        ISMP = 4
      ELSE IF(IRUN.GT.5180 .AND. IRUN.LT.5600) THEN
        ISMP = 5
      ELSE IF(IRUN.GT.5600 .AND. IRUN.LT.6000) THEN
        ISMP = 6
      ELSE IF(IRUN.GE.6000 .AND. IRUN.LT.7000) THEN
        IF( ABS(EBM-44.71).LT. 0.5 ) THEN
          ISMP = 7
        ELSE IF( ABS(EBM-45.61).LT. 0.5 ) THEN
          ISMP = 8
        ELSE IF( ABS(EBM-46.5).LT. 0.5 ) THEN
          ISMP = 9
        ELSE IF( ABS(EBM-65.0).LT. 10.0) THEN
          ISMP = 10
        END IF
      ELSE IF(IRUN.GE.7000 .AND. IRUN.LT.8000) THEN
        IF(ABS(EBM-45.60).LT. 1.0) THEN
          ISMP = 11
        ELSE IF(ABS(EBM-80.5).LT.2.5) THEN
          ISMP = 12
        ELSE IF(ABS(EBM-86.0).LT.2.5) THEN
          ISMP = 13
        END IF
      ELSE IF(IRUN.GE.8000 .AND. IRUN.LT.9000) THEN
        IF(ABS(EBM-45.63).LT. 1.0) THEN
          ISMP = 14
        ELSE IF(ABS(EBM-65.0).LT.10.0) THEN
          ISMP = 15
        ELSE IF(ABS(EBM-91.5).LT. 2.5) THEN
          ISMP = 16
        END IF
      ELSE IF(IRUN.GE.9000 .AND. IRUN.LT.10545) THEN
        IF(ABS(EBM-45.63).LT. 1.0) THEN
          ISMP = 17
        ELSE IF(ABS(EBM-94.5).LT.2.5 ) THEN
          ISMP = 18
        END IF
      ELSE IF(IRUN.GE.10545 .AND. IRUN.LT.99999) THEN
        IF(ABS(EBM-45.63).LT. 1.0) THEN
          ISMP = 19
        ELSE 
          ISMP = 20
        END IF
      END IF
*
      IF(ISMP.GE.1 .AND. ISMP.LE.NMXS) THEN
         ROSWTC = 1. + 1.0E-4*TLTCOR(ISMP,ILUM)
*
* correct for difference between new and old DST process...
*
         IF (IUHEAD(IIPVER).GT.2550.OR.LUMDST) THEN
            ROSWTC = ROSWTC*(1.0 + 1.0E-4*DSTCOR(ISMP))
         END IF
      ELSE
         ROSWTC = 1.
      END IF
*
*--   Write correction for checks:
      WRITE(CHREP,1004)ILUM,IRUN,ISMP,ROSWTC
      CALL REPORT('ROSWTC',4,'I')
*
 1001 FORMAT(1X,'Invalid luminosity index= ',I5)
 1002 FORMAT(1X,'SW luminosity last updated ',A11)
 1003 FORMAT(1X,'Tilt corr. for run ',I5,
     +  ' not yet calculated, Using default')
 1004 FORMAT(1X,'Lum. Tilt corr.',I1,',run/sample: ',2I5,' is: ',F12.8)
  999 RETURN
*
      END

+DECK,ROSWIC.
      REAL FUNCTION ROSWIC(ECMS)
*.----------------------------------------------------------------------
*.-
*.-....   ROSWIC : Interference correction for SW X-sec
*.-
*.-
*.-
*.-   Returned value  : Interference correction factor for SW X-sec
*.-   Input    : ECMS : center of mass energy
*.-   Called   : ROLUSW
*.-   Calls    : -
*.-   Seq.     : RCREP
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.02
*.-   Created  : 28-JAN-1994
*.-   Last mod : 10-Jul-1997
*.-
*.-   Modification log:
*.-   10-JUL-1997   D.Strom  :  Add smoothed fits for 1993-1995
*.-   19-Jul-1996   S.arcelli:  Add LEP 1.6 range
*.-   30-JAN-1996   C.Grandi:  Add LEP 1.5 range
*.-                           (mod on private version dated 26-NOV-1995)
*.-    3-FEB-1994   S.Arcelli: Add linear fits in 'hot' 1993 zones
*.-
*.----------------------------------------------------------------------
*
      REAL ECMS
*
      REAL ROSWIZ
      EXTERNAL ROSWIZ
*.----------------------------------------------------------------------
*
*--   Default value for correction
      ROSWIC = 1.
*
*--   First find if it is in the LEP 1.5 range:
*
*     note: this includes all experimental effects and also
*     the fact that the energy was not necessarily correct....
*
*      IF(ECMS .GE. 128.00 .AND. ECMS .LE. 142.00)THEN
*        ROSWIC = 1.00267
*        GOTO 999
*      ENDIF
*      IF(ECMS .GE. 156.00 .AND. ECMS .LE. 164.00)THEN
*        ROSWIC = 1.00468
*        GOTO 999
*      ENDIF
*
*     now move these corrections to roswtc
*
*--   For points around the 93-95 scan energies use special routine
*
      IF (ECMS.GE. 88.1 .AND. ECMS .LT. 93.6) THEN
         ROSWIC = ROSWIZ(ECMS)*1.0E-4 + 1.0
      ELSE
*         WRITE(CHREP,1000)ECMS
         GOTO 999
      ENDIF
*
 1000 FORMAT(1X,'CMS energy=',F13.5,' out of range. Interf. corr. =1.')
*
  999 RETURN
      END
+DECK,ROSWIZ.
      REAL FUNCTION ROSWIZ(ECMS)
*.----------------------------------------------------------------------
*.-
*.-....   ROSWIC : Interference correction for SW X-sec in zero region.
*.-
*.-
*.-
*.-   Returned value  : Interference correction factor for SW X-sec
*.-   Input    : ECMS : center of mass energy
*.-   Called   : ROSWIC
*.-   Calls    : -
*.-   Seq.     : RCREP
*.-
*.-   Author   : D.STROM
*.-   Version  : 1.02
*.-   Created  : 10-Jul-1997
*.-   Modified : 15-Apr-1998
*.-
*.-   Modification log:
*.-   D.Strom:     Moved parameters before data statements
*.-
*.----------------------------------------------------------------------
*
      REAL ECMS
*
      REAL FDF
      INTEGER IB1,IB2
*
*--------------------from smooth.kumac ---------------------------------
*
      REAL  EMIN,EMAX
      PARAMETER(EMIN =  88.5500)
      PARAMETER(EMAX =  93.4500)
*
      INTEGER NPTS
      PARAMETER (NPTS =   50)
      REAL ZGIZ(NPTS)
      SAVE ZGIZ
*
      DATA ZGIZ  /
     + 14.6, 15.0, 15.5, 16.0, 16.4, 16.8, 17.3, 17.7, 18.1, 18.5,
     + 18.9, 19.3, 19.6, 19.8, 20.0, 20.1, 20.1, 19.9, 19.4, 18.7,
     + 17.6, 16.2, 14.5, 12.6, 10.4,  7.9,  5.2,  2.4, -0.3, -2.9,
     + -5.3, -7.3, -9.2,-10.8,-12.2,-13.4,-14.4,-15.2,-15.8,-16.1,
     +-16.4,-16.5,-16.6,-16.6,-16.5,-16.3,-16.2,-16.0,-15.7,-15.5 /

*
*.----------------------------------------------------------------------
*
*--   Default value for correction
      ROSWIZ = 0.0
*
*     Are we in the Z0 region?
*
      IF(ECMS.LT.EMIN) GOTO 999
      IF(ECMS.GT.EMAX) GOTO 999
*
*--   If so find the two neares bins
*
      IB1 = INT(FLOAT(NPTS-1)*(ECMS - EMIN)/(EMAX - EMIN))
      FDF = FLOAT(NPTS-1)*(ECMS - EMIN)/(EMAX - EMIN) - FLOAT(IB1)
      IB1 = IB1 + 1
      IB2 = IB1 + 1
*
* deal with npoints of plot
*
      IF(IB1.LT.1)    IB1 = 1
      IF(IB2.GT.NPTS) IBS = NPTS
*
      ROSWIZ = ZGIZ(IB1)*(1.0-FDF) + ZGIZ(IB2)*FDF
*
  999 RETURN
      END
+DECK,ROCRST.
      SUBROUTINE ROCRST
*.----------------------------------------------------------------------
*.-
*.-....   ROCRST : Initialize ROCRCM common for X section calc.
*.-
*.-
*.-
*.-   Input    : -
*.-   Output   : -
*.-   Called   : USSETR
*.-   Calls    : REPORT
*.-   Seq.     : ROCRCM,RCREP
*.-
*.-   Author   : C.Grandi
*.-   Version  : 1.00
*.-   Created  :  8-APR-1994
*.-   Last mod :  8-APR-1994
*.-
*.-   Modification log:
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,ROCRCM.
+SEQ,RCREP.
*
      IF (LUMDST) THEN
        WRITE(CHREP,1000)
      ELSE
        WRITE(CHREP,1100)
      ENDIF
      CALL REPORT('ROCRST',1,'I')
*
 1000 FORMAT('SW-lumi selection will be done from DST data')
 1100 FORMAT('SW-lumi selection will be done from header bit data')
*
  999 RETURN
      END
+DECK,ROPENA.
      SUBROUTINE ROPENA(LUN)
*.
*...ROPENA Open an Alternative output file (for batch queries)
*.
*. CALLS   : RGTLUN RQSYST
*. CALLED  : ROPHON
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER LUN
*
+SEQ,CRO.
+SEQ,RCSYST.
+SEQ,RCREP.
*
+SELF,IF=VAX,UNIX.
      LUN=LROUT
+SELF,IF=IBM.
      CALL RGTLUN(LUN)
      IF(LUN.EQ.0)                                              GO TO 10
      WRITE(SYSCOM,1000) LUN
      CALL RQSYST(.FALSE.)
      IF(SYSRC.NE.0)                                            GO TO 10
      WRITE(SYSCOM,1010) LUN
      CALL RQSYST(.FALSE.)
      IF(SYSRC.NE.0)                                            GO TO 10
      OPEN(LUN,FORM='FORMATTED',ERR=10)
                                                               GO TO 999
*
   10 CHREP='Problem while opening alternative output file'
      CALL REPORT('ROPENA',1,'E')
      LUN   = 0
+SELF.
*
  999 RETURN
+SELF,IF=IBM.
 1000 FORMAT('FILEDEF',I3,' CLEAR')
 1010 FORMAT('FILEDEF',I3,' DISK ROPHONE LISTING A (RECFM F LRECL 133')
+SELF.
      END
+DECK,ROPHON.
      SUBROUTINE ROPHON
*.
*...ROPHON React to queries from batch sender
*.
*. CALLS   : RNOTIF USPHON REPORT CLTOU  RSBWRD LENOCC SPACES RWORDS
*.           TIMEX  REPREP ROPENA RCLOSA ROSUMF RPHONE RIBMOP
*. CALLED  : ROEVNT
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 13-Dec-90
*.
*. Modification Log.
*.  13-Dec-1990  F.Odorici  Commands starting with a "!" are comments
*.
*.*********************************************************************
+SEQ,DECLARE.
      CHARACTER*1   LEVEL
      CHARACTER*4   COMM
      CHARACTER*5   CSEVRX(6)
      CHARACTER*50  FFREAD
      CHARACTER*132 SPACES
      LOGICAL       OPENED
      INTEGER       I1,I2,I3,L,LENOCC,NERROR(6),LRE,I,W,RWORDS,LUN,LKEEP
     +             ,J1,J2
      REAL          TMEAN,TNOW
      EXTERNAL      RWORDS,LENOCC
*
+SEQ,RCSYST.
+SEQ,RCREP.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,CRO.
+SEQ,REBANK.
*
      DATA CSEVRX/'Succ.','Info.','Warn.','Error','Fatal','Crash'/
*-- The command is identified by the first 4 characters
*-- (case insensitive)
      BCOMND = SPACES(BCOMND,1)
      L      = LENOCC(BCOMND)
      CALL RSBWRD(BCOMND,1,I1,I2)
      I3     = MIN0(4,I2)
      COMM   = BCOMND(1:I3)
      CALL CLTOU(COMM)
      CALL RSBWRD(BCOMND,2,J1,J2)
*
      LEVEL  = ' '
      GOTCMD = .FALSE.
*-- Now react !
      IF(COMM(1:1).EQ.'!') THEN
*-- Do nothing, this is a comment line.
         CHREP  = ' '
      ELSE IF(COMM.EQ.'AYT') THEN
         CHREP  = 'Yes I am'
      ELSE IF(COMM.EQ.'LREP') THEN
*-- Do nothing, just resend last report.
      ELSE IF(COMM.EQ.'HPRI'.OR.COMM.EQ.'HLIS'.OR.COMM.EQ.'HIND') THEN
         CALL ROPENA(LUN)
         IF(LUN.GT.0) THEN
            CALL HOUTPU(LUN)
            IF(COMM.EQ.'HPRI') THEN
               CALL HPDIR('//PAWC','T')
            ELSE IF(COMM.EQ.'HIND') THEN
               CALL HINDEX
            ELSE
               CALL HLDIR('//PAWC','T')
            END IF
            CALL HOUTPU(LROUT)
            CALL RCLOSA(LUN)
         END IF
         CHREP  = ' '
+SELF,IF=IBM.
      ELSE IF(COMM.EQ.'SHEL'.OR.COMM.EQ.'CMS'.OR.COMM.EQ.'CP') THEN
         IF(J1.EQ.0) THEN
            CHREP  = 'No command given'
            LEVEL  = 'E'
         ELSE
            IF(COMM.EQ.'CP') THEN
               SYSCOM = 'CP '//BCOMND(J1:)
            ELSE
               SYSCOM = BCOMND(J1:)
            END IF
            CALL RQSYST(.FALSE.)
            WRITE(CHREP,1000) SYSRC
         END IF
+SELF.
      ELSE IF(COMM.EQ.'WAY') THEN
         CALL TIMEX(TNOW)
         IF(IREVPR.EQ.0) THEN
            TMEAN  = 0.
         ELSE
            TMEAN  = (TNOW-RTIMST)/IREVPR
         END IF
         WRITE(CHREP,1010) NINPUT,IREVNT,IRDRUN,IRDEVT,TMEAN
      ELSE IF(COMM.EQ.'STOP') THEN
         CHREP  = 'Closing the job on user''s request'
         IRSTOP = 2
         NSTOP  = 9
         LEVEL  = 'I'
      ELSE IF(COMM.EQ.'LERR'.OR.COMM.EQ.'SUMM') THEN
         CALL ROPENA(LUN)
         IF(LUN.GT.0) THEN
            LKEEP  = LROUT
            LROUT  = LUN
            IF(COMM.EQ.'LERR') THEN
               CALL REPREP('*')
            ELSE
               CALL ROSUMF
            END IF
            LROUT  = LKEEP
            CALL RCLOSA(LUN)
         END IF
         CHREP  = ' '
      ELSE IF(COMM.EQ.'ABOR') THEN
         CHREP  = 'Stopping the job IMMEDIATELY and DRASTICALLY'
         CALL RNOTIF
         STOP 99
      ELSE IF(COMM(1:3).EQ.'FFR') THEN
         FFREAD = BCOMND(J1:)
         L      = LENOCC(FFREAD)
         W      = RWORDS(FFREAD)
+SELF,IF=IBM.
         IF(W.LT.2.OR.W.GT.3) THEN
+SELF,IF=-IBM.
         IF(W.NE.1) THEN
+SELF.
             LEVEL  = 'W'
             CHREP  = 'Bad FFREAD file name : '//BCOMND
         ELSE
+SELF,IF=IBM.
             CALL RIBMOP(FFREAD,'OLD',.FALSE.)
+SELF.
             CHREP  = 'Now FFREADing file: '//FFREAD
             INQUIRE(5,OPENED=OPENED)
             IF(OPENED) CLOSE(5)
             OPEN(5,FILE=FFREAD,ERR=30,STATUS='OLD')
             CALL FFGO
             CLOSE(5)
         END IF
      ELSE IF(COMM.EQ.'NIF') THEN
         LCLOSI = .TRUE.
         CHREP  = 'Skipping to next input file on user''s request'
         LEVEL  = 'W'
      ELSE IF(COMM.EQ.'SNF') THEN
         RTIMSI = 999999.
         CHREP  = 'Will stop at next end-of-(input)-file'
      ELSE IF(COMM.EQ.'ERR') THEN
         DO 20 I = 1,6
         NERROR(I) = 0
         LRE    = LR(LREHD-I)
   10    IF(LRE.GT.1) THEN
            NERROR(I) = NERROR(I)+IR(LRE+2)
            LRE    = LR(LRE)
                                                                GO TO 10
         END IF
   20    CONTINUE
         WRITE(CHREP,1020) (NERROR(I),CSEVRX(I),I=1,6)
      ELSE
         CHREP  = 'Unknown command:'//BCOMND(1:L)
         LEVEL  = 'E'
      END IF
*
      IF(CHREP.NE.' ') CALL RNOTIF
      IF(LEVEL.NE.' ') CALL REPORT('ROPHON',1,LEVEL)
                                                               GO TO 999
   30 CHREP  = 'Can not process FFREAD file '//FFREAD(1:20)
      CALL RNOTIF
      CALL REPORT('ROPHON',2,'E')
*
  999 RETURN
*
 1000 FORMAT('So far ',6(I5,1X,A))
 1010 FORMAT('File',I3,' Event',I5, ' Now run:',I5,
     +       ' trigger:',I6,' time/evt:',F8.4)
 1020 FORMAT('Done,rc=',I4)
      END
+DECK,ROQUIT.
      SUBROUTINE ROQUIT
*.
*...ROQUIT   Brings the program out of the event loop.
*.
*. SEQUENCE: RCNTRL
*. CALLED  : <USER>
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-87
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCNTRL.
*
      IRSTOP = 2
*
      RETURN
      END
+DECK,ROSIZE.
      SUBROUTINE ROSIZE(JLINK,CNAME,NBANKS,NDATAS,NLINKS,NWORDS)
*.
*...ROSIZE   Obtain the size of a Zebra structure.
*.
*. INPUT   : JLINK Address of the structure
*. INPUT   : CNAME Name of the structure (only needed for printing)
*. OUTPUT  : NBANKS Total number of banks in the structure.
*. OUTPUT  : NDATAS Total number of data words in the structure.
*. OUTPUT  : NLINKS Total number of links in the structure.
*. OUTPUT  : NWORDS Total number of words in the structure.
*.
*. SEQUENCE: ROBANK RCREP
*. CALLS   : REPORT
*. CALLED  : ROPBAT ROGOKU
*.
*. AUTHOR  : S.Oneale,S.Weisz
*. VERSION : 1.00
*. CREATED : 16-Jul-1987
*. LAST MOD: 17-Oct-1990
*.
*. Modification Log.
*. 17-Oct-90  S.Weisz    Get more information in case on failure.
*. 12-Sep-89  S.Oneale   Take IO characteristic into account.
*. 26-Jan-89  S.Weisz    Do not print if CNAME is blank.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER JBYT
      EXTERNAL JBYT
      INTEGER JLINK,NBANKS,NDATAS,NLINKS,NWORDS,NLEVEL,MAXLVL,
     +        NIOWDS
      INTEGER JSS,NSS,LSS,JS,NS,LS
      CHARACTER*4 CNAME,CBLANK,CLOCAL
      INTEGER IPRINT,I
      SAVE    IPRINT
      SAVE    CBLANK
      PARAMETER (MAXLVL=500)
*
+SEQ,ROBANK.
+SEQ,RCREP.
*
      DIMENSION JSS(MAXLVL),NSS(MAXLVL),LSS(MAXLVL)
      DATA CBLANK/'    '/
      DATA IPRINT/0/
*--   Scan zebra banks to find the amount of space in use.
*--   Special IO words are taken into account.
      NBANKS=0
      NDATAS=0
      NLINKS=0
      NIOWDS=0
      NWORDS=0
      IF(JLINK .NE.0) THEN
         NLEVEL=1
         JSS(NLEVEL)=0
         LSS(NLEVEL)=JLINK
         NSS(NLEVEL)=IQ(JLINK-2)
         NDATAS=NDATAS+IQ(JLINK-1)
         NLINKS=NLINKS+IQ(JLINK-3)
         NBANKS=1
         NIOWDS=JBYT(IQ(JLINK),19,5)
*--   There is room for improvement here, e.g. don't stack the bottom
*--   level or horizontal links !
   10    JS=JSS(NLEVEL)
         NS=NSS(NLEVEL)
         IF(JS.GT.NS)                                           GO TO 40
         LS=LSS(NLEVEL)
*--   If there is a bank on this link, count the words and
*--   put it on the stack.
   20    IF(LQ(LS-JS).EQ.0)                                     GO TO 30
         LS =LQ(LS-JS)
         NDATAS=NDATAS+IQ(LS-1)
         NLINKS=NLINKS+IQ(LS-3)
         NIOWDS=NIOWDS+JBYT(IQ(LS),19,5)
         NBANKS=NBANKS+1
         JSS(NLEVEL)=JSS(NLEVEL)+1
         NLEVEL=NLEVEL+1
         IF(NLEVEL.GT.MAXLVL) THEN
            IF(CNAME.NE.CBLANK) THEN
               CLOCAL = CNAME
            ELSE
               CALL UHTOC(IQIDH(JLINK),4,CLOCAL,4)
            END IF
            WRITE(CHREP,1000) CLOCAL,JLINK,NLEVEL
            CALL REPORT('ROSIZE',1,'W')
            IF(IPRINT.NE.0)                                    GO TO 999
            IPRINT = 1
            DO 50 I=1,MAXLVL/10
            CALL UHTOC(IQIDH(LSS(I)),4,CLOCAL,4)
            WRITE(CHREP,1001) I,CLOCAL,LSS(I),NSS(I),JSS(I)-1
            CALL REPORT('ROSIZE',0,'I')
   50       CONTINUE
                                                               GO TO 999
         ENDIF
         JSS(NLEVEL)=0
         NSS(NLEVEL)=IQ(LS-2)
         LSS(NLEVEL)=LS
                                                                GO TO 10
   30    JS=JS+1
         JSS(NLEVEL)=JS
         IF(JS.LE.NS)                                           GO TO 20
*--  If there are no more structural links, go up one level.
   40    NLEVEL=NLEVEL-1
         IF(NLEVEL.NE.0)                                        GO TO 10
      ENDIF
      NWORDS=NBANKS*10 + NDATAS + NLINKS + NIOWDS
      IF(CNAME.NE.CBLANK) THEN
         WRITE(CHREP,1010) CNAME,NBANKS,NDATAS,NWORDS
         CALL REPORT('ROSIZE',0,'I')
      END IF
*
  999 RETURN
 1000 FORMAT('Bank ',A,' at ',I8,' exceeds dependant capacity of ',I4)
 1001 FORMAT('Level',I4,': Bank ',A,' at ',I8,' has ',I4,
     +                  ' links, follow offset -',I4)
 1010 FORMAT(A,' Supports',I5,' banks with ',I6,' data words and' ,I7,
     +' words in total')
      END
+DECK,ROUPON.
      SUBROUTINE ROUPON(ONLINE)
*.
*...ROUPON Returns .TRUE. whenever On-line version is used
*.
*. CALLED  : Any
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.00
*. CREATED :  8-Apr-90
*. LAST MOD:  8-Apr-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      LOGICAL ONLINE
+SELF,IF=ONLINE.
      ONLINE = .TRUE.
+SELF,IF=-ONLINE.
      ONLINE = .FALSE.
+SELF.
*
      RETURN
      END
+DECK,ROUVER.
      SUBROUTINE ROUVER(IAVERS)
*.
*...ROUVER   Returns Overall Rope version Number (-1 for developement)
*.
*. CALLED  : ANY
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.00
*. CREATED :  4-Apr-91
*. LAST MOD:  4-Apr-91
*.
*. Modification Log.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER LSTUPD,IAVERS
*
+SELF,LASTUPD.
      LSTUPD = -1
+SELF.
      IAVERS = LSTUPD
*
      RETURN
      END
+DECK,RPHINI,IF=VAX.
      SUBROUTINE RPHINI
*.
*...RPHINI Initialize the phone batch interrogation file.
*.
*. SEQUENCES : DECLARE RCSYST RCREP
*. CALLS     : REPORT LENOCC LIB$SPAWN
*. CALLED    : RSPHON
*.
*. AUTHOR    : F.Odorici
*. VERSION   : 1.00
*. CREATED   : 29-Nov-1990
*. LAST MOD  : 29-Nov-1990
*.
*. Modification log:
*.  29-Nov-90 F.Odorici  Create this routine
*.
*.********************************************************************
+SEQ,DECLARE.
      INTEGER LENOCC,IOSTAT,INFO,LIB$SPAWN
      CHARACTER PHFILE*20
*
+SEQ,RCSYST.
+SEQ,RCREP.
*-- Open the phone batch file.
      PHFILE = 'ROPE'//CHENTR(1:LENOCC(CHENTR))//'.PHONE'
      OPEN (LUPHON,FILE=PHFILE,STATUS='NEW',SHARED,
     +                                      ERR=10,IOSTAT=IOSTAT)
      CHREP  = 'Phone-file '//PHFILE(1:LENOCC(PHFILE))//' created.'
      CALL REPORT('RPHINI',1,'I')
*-- Set the file protection against hacking attempt: only the owner can
*-- read, write or delete the file.
      INFO   = LIB$SPAWN ('SET PROT=(S,O:RWD,G,W) '//PHFILE)
      IF(.NOT.INFO)                                             GO TO 20
                                                               GO TO 999
   10 CHREP  = 'Error opening the file '//PHFILE(1:LENOCC(PHFILE))//
     +                                          '. Phoning disabled.'
      CALL REPORT('RPHINI',2,'N')
      LPHONE = .FALSE.
                                                               GO TO 999
   20 CHREP  = 'Error changing the protection of the file '
     +        //PHFILE(1:LENOCC(PHFILE))//'. Phoning disabled.'
      CALL REPORT('RPHINI',3,'N')
      LPHONE = .FALSE.
*
  999 CONTINUE
      RETURN
      END
+DECK,RPHONE,IF=IBM.
      SUBROUTINE RPHONE
*.
*...RPHONE Check whether the batch submitter sent a request
*.         Receive all files in the reader
*.         It filetype='FFREAD' process it!
*.
*. CALLS   : RQSYST VMRTRM REPORT LENOCC
*. CALLED  : ROEVNT
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
      INTEGER       L,NF,I,LENOCC
      CHARACTER*132 LINE
      CHARACTER*8   AUTHOR
      CHARACTER*4   SPOOL,HOLD
*
+SEQ,RCSYST.
+SEQ,RCREP.
*
      GOTCMD = .FALSE.
      LINE   = ' '
      SYSCOM = 'WAKEUP +0 (SMSG RDR QUIET'
      CALL RQSYST(.FALSE.)
*
      IF(SYSRC.EQ.2) THEN
*-- Nothing happenned
      ELSE IF(SYSRC.EQ.1) THEN
*-- A special message was received
         CALL VMRTRM(LINE,L)
         AUTHOR = LINE(9:16)
         IF(AUTHOR.NE.SENDER(1:LENOCC(SENDER))) THEN
            CHREP  = 'Hacking attempt from user:'//AUTHOR
            CALL REPORT('RPHONE',1,'N')
                                                               GO TO 999
         END IF
         BCOMND = LINE(18:132)
         GOTCMD = .TRUE.
      ELSE IF(SYSRC.EQ.4) THEN
*-- A file arrived in the reader
*-- How many files have been actually received?
         SYSCOM = 'CPSTACK QUERY FILES'
         CALL RQSYST(.FALSE.)
         IF(SYSRC.NE.0)                                         GO TO 20
         CALL VMRTRM(LINE,L)
         READ(LINE(8:11),'(I4)') NF
         IF(NF.EQ.0)                                            GO TO 20
*-- Handle the first one
         SYSCOM = 'CPSTACK QUERY READER ALL'
         CALL RQSYST(.FALSE.)
         IF(SYSRC.NE.0)                                         GO TO 20
         CALL VMRTRM(LINE,L)
         CALL VMRTRM(LINE,L)
         IF(LINE(54:71).EQ.' ') LINE(54:71) = 'UNNAMED FILE'
*-- Let's receive it anyhow
         HOLD  = LINE(34:37)
         IF (HOLD.NE.'NONE') THEN
            SPOOL  = LINE(10:13)
            SYSCOM = 'CP CHANGE READER '//SPOOL//' NOHOLD CLASS A'
            CALL RQSYST(.FALSE.)
         END IF
         CHREP  = 'Receiving '//LINE(54:71)
         CALL RNOTIF
         SYSCOM = 'EXEC RECEIVE (REPLACE'
         CALL RQSYST(.FALSE.)
         IF(SYSRC.NE.0)                                         GO TO 20
*-- Process the file if Filetype='FFREAD'
         IF(LINE(64:69).EQ.'FFREAD') THEN
            GOTCMD = .TRUE.
            BCOMND = 'FFR '//LINE(54:71)
         END IF
*-- Empty the stack if necessary
         IF(NF.GT.1) THEN
            DO 10 I=2,NF
               CALL VMRTRM(LINE,L)
   10       CONTINUE
         END IF
      END IF
*
                                                               GO TO 999
   20 LPHONE = .FALSE.
      CHREP  = 'Very bad error detected. Phoning disabled'
      CALL REPORT('RPHONE',2,'N')
*
  999 RETURN
      END
+DECK,RPHONEV,IF=VAX.
      SUBROUTINE RPHONE
*.
*...RPHONE Check whether the batch submitter sent a request
*.
*. SEQUENCES : DECLARE RCSYST RCREP
*. CALLS     : REPORT LENOCC CLEFT
*. CALLED    : ROEVNT
*.
*. AUTHOR    : F.Odorici
*. VERSION   : 1.00
*. CREATED   : 29-Nov-1990
*. LAST MOD  : 29-Nov-1990
*.
*. Modification log:
*.  29-Nov-90 F.Odorici  Create this routine
*.
**********************************************************************
+SEQ,DECLARE.
      INTEGER IOSTAT,LENOCC
      CHARACTER*132 PHMESS,SPACES
      CHARACTER*(*) RFMT
      PARAMETER (RFMT='(A132)')
*
+SEQ,RCSYST.
+SEQ,RCREP.
*
      GOTCMD = .FALSE.
      BCOMND = ' '
*-- Now get the messages from ROPE
      READ(LUPHON,FMT=RFMT,END=999,ERR=10,IOSTAT=IOSTAT) PHMESS
      BCOMND = SPACES(PHMESS,1)
      GOTCMD = .TRUE.
                                                               GO TO 999
   10 CHREP='Error reading the phone batch file. Phoning disabled.'
      CALL REPORT('RPHONE',1,'N')
      LPHONE=.FALSE.
*
  999 RETURN
      END
+DECK,RPTREE.
      SUBROUTINE RPTREE(IT)
*.
*...RPTREE   Print TREE Bank transmitted to ROPE.
*.      Prints kinematics  for track number IT
*.      If IT=0 prints kinematics for all TREE tracks.
*.
*. SEQUENCE: ROPAR GOPAR RCLINE ROBANK
*. CALLS   : RMAIL
*. CALLED  : <USER>
*.
*. BANK U  : MC GENE TREE
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 15-Nov-88
*. LAST MOD:  2-Apr-90
*.
*. Modification Log.
*.  2-Apr-90  A.Buijs         Avoid break in GROPE for strange tracks.
*. 24-Mar-89  S.Weisz         Mod. for new LUND particle code.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER     LGENE ,LTREE
      INTEGER     NGEN,NPTREE
      INTEGER     IT,NFIRST,NLAST,N,LNTREE,ISQ,IC,K
      REAL        SX,SY,SZ,SE
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,GOPAR.
+SEQ,RCLINE.
+SEQ,RCREP.
*
      SX=0
      SY=0
      SZ=0
      SE=0
      ISQ=0
C
      IF(LMC .LE. 0) THEN
         CHREP = 'No Monte-Carlo structure'
         CALL REPORT('RPTREE',1,'W')
                                                               GO TO 999
      END IF
      LGENE = LQ(LMC-LLGENE)
      IF(LGENE .LE. 0) THEN
         CHREP = 'No GENE structure'
         CALL REPORT('RPTREE',2,'W')
                                                               GO TO 999
      END IF
      NGEN   = IQ(LGENE+1)
      NPTREE = IQ(LGENE+5)
      LTREE  = LQ(LGENE-LLTREE)
      IF(LTREE .LE. 0) THEN
         CHREP = 'No TREE structure'
         CALL REPORT('RPTREE',3,'W')
                                                               GO TO 999
      END IF
*
      IF(IT.EQ.0) THEN
         NFIRST = 1
         NLAST  = NGEN
      ELSE IF(IT.LE.NGEN) THEN
         NFIRST = IT
         NLAST  = IT
      ELSE
         CHREP = 'No TREE information for track IT'
         CALL REPORT('RPTREE',4,'W')
                                                               GO TO 999
      END IF
      WRITE(CHLINE,1000) IRDEVT
      CALL RMAIL(2,1)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
*
      DO 10 N=NFIRST,NLAST
         LNTREE = LTREE + (N-1)*NPTREE
         IC = INT(Q(LNTREE+16))
         WRITE(CHLINE,1020,ERR=2001)N,(IQ(K),K=LNTREE+1,LNTREE+10),
     +    (Q(K),K=LNTREE+11,LNTREE+15),IC,(Q(K),K=LNTREE+17,LNTREE+22)
 2001    CALL RMAIL(0,0)
         IF(IQ(LNTREE+2).NE.0)                                  GO TO 10
         SX=SX+Q(LNTREE+11)
         SY=SY+Q(LNTREE+12)
         SZ=SZ+Q(LNTREE+13)
         SE=SE+Q(LNTREE+14)
         ISQ=ISQ+IC
   10 CONTINUE
*
      IF(IT.EQ.0) WRITE(CHLINE,1030,ERR=2002)SX,SY,SZ,SE,ISQ
 2002 CALL RMAIL(1,0)
*
*
  999 RETURN
 1000 FORMAT(' HISTORY OF GENERATED PARTICLES - EVENT NUMBER',I5)
 1010 FORMAT(1X, '  N   CODE PAR SEC NUM  PV JT E C F1 F2',
     +'      PX      PY      PZ      ENERGY   MASS  Q',
     +'      START POINT           END POINT')
*
 1020 FORMAT(1X,I3,I6,1X,I4,2I4,I4,I3,2I2,2I3,4F9.3,F8.3,I3,6F7.2)
 1030 FORMAT(1X,31X,'TOTALS',4F9.3,8X,I3)
      END
+DECK,RQSYSTI,IF=IBM.
      SUBROUTINE RQSYST(REP)
*.
*...RQSYST Performs a call to the system (VMCMS)
*.         if it has not worked.
*.
*. CALLS   :  VMCMS LENOCC
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 15-Sep-91
*.
*. Modification Log.
*. 15-Sep-91  D.Lellouch     Stage returns 1 if data set already staged.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*132 SPACES
      INTEGER       LENOCC
      LOGICAL       REP
+SEQ,RCREP.
+SEQ,RCSYST.
*
      SYSCOM = SPACES(SYSCOM,1)
      CALL VMCMS(SYSCOM,SYSRC)
      IF(SYSRC.EQ.4.AND.SYSCOM(1:9).EQ.'EXEC GIME') THEN
      ELSE IF(SYSCOM(1:10).EQ.'EXEC STAGE'.AND.SYSRC.EQ.1) THEN
      ELSE IF(SYSCOM(1:6).EQ.'WAKEUP') THEN
      ELSE IF(SYSCOM(1:8).EQ.'NUCXLOAD'.AND.SYSRC.EQ.1) THEN
      ELSE IF(SYSRC.NE.0) THEN
         WRITE(CHREP,1000) SYSRC,SYSCOM(1:LENOCC(SYSCOM))
         CALL REPORT('RQSYST',1,'E')
      ELSE IF(REP) THEN
         CHREP  = 'Executing: '//SYSCOM
         CALL REPORT('RQSYST',2,'I')
      END IF
*
      RETURN
 1000 FORMAT('Rc',I4,' from:', A)
      END
+DECK,RQSYSTU,IF=UNIX.
      SUBROUTINE RQSYST(REP)
*.
*...RQSYST Performs a call to the system (Unix)
*.
*. CALLS   :  SYSTEM SPACES
*. CALLED  :
*.
*. AUTHOR  : T.Mouthuy
*. VERSION : 1.00
*. CREATED : 27-Feb-91
*. LAST MOD: 27-Feb-91
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*132 SPACES
      LOGICAL       REP
+SEQ,RCREP.
+SEQ,RCSYST.
*
      SYSCOM = SPACES(SYSCOM,1)
      CALL SYSTEM(SYSCOM)
      IF(REP) THEN
         CHREP  = 'Executing: '//SYSCOM
         CALL REPORT('RQSYST',2,'I')
      END IF
*
      RETURN
      END
+DECK,RSBWRD.
      SUBROUTINE RSBWRD(STR,IW,I1,I2)
*.
*...RSBWRD Utility function wich extracks the iw'th word
*.         in a string
*.
*. CALLS   :
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IWORDS,IW,I1,I2,I
      CHARACTER*(*) STR
      LOGICAL SWITCH
*
      SWITCH = .FALSE.
      I1     = 0
      I2     = 0
      IWORDS = 0
      DO 10 I=1,LEN(STR)
         IF(STR(I:I).NE.' ') THEN
            IF(.NOT.SWITCH) THEN
               SWITCH = .TRUE.
               IWORDS = IWORDS + 1
               IF(IWORDS.EQ.IW) I1     = I
            END IF
         ELSE
            IF(SWITCH.AND.I1.NE.0) THEN
               I2     = I - 1
                                                               GO TO 999
            END IF
            SWITCH = .FALSE.
         END IF
   10 CONTINUE
*
  999 RETURN
      END
+DECK,RSPHON,IF=VAX.
      SUBROUTINE RSPHON
*.
*...RSPHON Handle *PHONE FFREAD cards
*.
*. SEQUENCE: DECLARE RCREP RCNTRL ROUNIT RCSYST
*. CALLS   : UHTOC RABBRE RPHINI ROGTUN
*. CALLED  : RFUSER
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.01
*. CREATED : 18-Nov-90
*. LAST MOD: 30-Nov-90
*.
*. Modification Log.
*.  30-Nov-1990  F.Odorici  Initialize the Phone batch stuff (RPHINI)
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*4  OPTION
      LOGICAL      RABBRE
      EXTERNAL     RABBRE
*
+SEQ,RCREP.
+SEQ,RCNTRL.
+SEQ,ROUNIT.
+SEQ,RCSYST.
*-- Only batch Jobs can PHONING
      IF(JMODE.NE.2) THEN
         CHREP  = 'Only batch Jobs can Phoning. Phone not enabled.'
         CALL REPORT('RSPHON',1,'N')
      END IF
*-- Only one PHONE card can be present
      IF(LPHONE) THEN
         CHREP  = 'Phone stuff already initialized.'
         CALL REPORT('RSPHON',2,'W')
      END IF
*-- Get the logical unit to open the phone batch file
*-- and the option to save it or not.
      CALL ROGTUN(LUFONE,'Phoning')
      IF(LUFONE.EQ.0) THEN
         FFERRO = .TRUE.
      ELSE
         CALL UHTOC(LFOOPT,4,OPTION,4)
         PHONSA = RABBRE('SAVE',OPTION,1)
         LUPHON = LUFONE
         LPHONE = .TRUE.
         CALL RPHINI
      END IF
*
      RETURN
      END
+DECK,RSSYST.
      SUBROUTINE RSSYST
*.
*...RSSYST Set System paramters
*.
*. CALLS   : JOB$VM LENOCC RQSYST RJINFO
*. CALLED  : ROINIT
*.
*. AUTHOR  : D.Lellouch and F.Odorici
*. VERSION : 1.01
*. CREATED : 18-Nov-90
*. LAST MOD:  7-May-99
*.
*. Modification Log.
*.  7-May-99 M.Schroder     Add PCLINUX flag
*.   18-May-91   D.Lellouch On shift, the system is called SHIFT
*.   29-Nov-90   F.Odorici  Call RJINFO (VAX only) to get job information
*.   18-Nov-90   D.Lellouch Create this routine.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER        LENOCC
+SELF,IF=IBM.
      CHARACTER*8    INFO(10)
      INTEGER        SPACE(32)
      EQUIVALENCE   (INFO,SPACE)
      LOGICAL        BATCH,JOB$VM
+SELF.
*
+SEQ,ROUNIT.
+SEQ,RCSYST.
*-- Initialize all the used common variable.
      SENDER = ' '
      JOBNAM = ' '
      MAILSN = 0
      LPLOT  = .FALSE.
*
+SELF,IF=IBM.
      BATCH  = JOB$VM(SPACE)
      SENDER = INFO(1)
      JOBNAM = INFO(5)
      CHNODE = INFO(8)
      IF(CHNODE.EQ.'CERNVM'.OR.CHNODE.EQ.'UKACRL'
     +                     .OR.CHNODE.EQ.'FRSAC12') THEN
         LHEPVM = .TRUE.
         PLTCMD = 'EXEC GRPLOT'
         PLTOPT = ' (SPOOL YES PR'
      ELSE
         LHEPVM = .FALSE.
         PLTCMD = '???'
      END IF
*-- If running in batch, enable message exchange by the SMSG mechanism
      BNOTIF = .TRUE.
      LPHONE = JOBNAM.NE.'INTERAC'
      IF(LPHONE) THEN
         SYSCOM = 'CP SET SMSG IUCV'
         CALL RQSYST(.FALSE.)
      END IF
*-- Default device names for cartrdige set-up
      DVNAME(1) = '288'
      DVNAME(2) = '289'
      DVNAME(3) = '28A'
      DVNAME(4) = '28B'
      DVNAME(5) = '28C'
      DVNAME(6) = '28D'
      DVNAME(7) = '28E'
      DVNAME(8) = '28F'
*
+SELF,IF=VAX.
*-- Get all the system Job information
      CALL RJINFO
      SENDER = USRNAM
*-- NOTIF works for batch jobs only (mode 2)
      BNOTIF = JMODE.EQ.2
      LPHONE = .FALSE.
+SELF,IF=SHIFT.
      CHNODE = 'SHIFT'
+SELF,IF=APOLLO.
      CHNODE = 'APOLLO'
+SELF,IF=HPUX.
      CHNODE = 'HPUX'
+SELF,IF=PCLINUX.
      CHNODE = 'PCLX'
+SELF,IF=IBMRT.
      CHNODE = 'IBMRT'
+SELF,IF=SGI,IF=-SHIFT.
      CHNODE = 'SGI'
+SELF,IF=SUN.
      CHNODE = 'SUN'
+SELF,IF=DECS.
      CHNODE = 'DECS'
+SELF.
*
      LCHNOD = LENOCC(CHNODE)
*-- Event time out not yet set
      TIMSET = .FALSE.
*
      RETURN
      END
+DECK,RTRANS.
      SUBROUTINE RTRANS(A,SI,SO)
*.
*...RTRANS Modify a string replacing 'SI' by 'SO' in each occurence.
*.
*. CALLS   :
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      CHARACTER*(*) A,SI,SO
      INTEGER       I,J,L,INDEX,LI,LO,K
      CHARACTER*132 B
*
      I      = 1
      L      = LEN(A)
      LI     = LEN(SI)
      LO     = LEN(SO)
      IF(LI.EQ.0)                                              GO TO 999
      B      = ' '
      K      = 1
   10 IF(I.GT.L)                                                GO TO 20
      J      = INDEX(A(I:L),SI)
      IF(J.EQ.0) THEN
         B(K:132) = A(I:L)
      ELSE
         IF(J.GT.1) THEN
            B(K:132) = A(I:I+J-1)
            K      = K + J - 1
         END IF
         B(K:132) = SO
         K      = K + LO
         I      = I + J + LI - 1
         IF(K.LE.132)                                           GO TO 10
      END IF
   20 A      = B
*
  999 RETURN
      END
+DECK,RWORDS.
      FUNCTION RWORDS(STR)
*.
*...RWORDS Utility function wich returns the number of words
*.        in a string
*.
*. CALLS   :
*. CALLED  :
*.
*. AUTHOR  : D.Lellouch
*. VERSION : 1.00
*. CREATED : 18-Nov-90
*. LAST MOD: 18-Nov-90
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER       RWORDS,I,LEN
      CHARACTER*(*) STR
      LOGICAL       SWITCH
*
      SWITCH = .FALSE.
      RWORDS = 0
      DO 10 I=1,LEN(STR)
         IF(STR(I:I).NE.' ') THEN
            IF(.NOT.SWITCH) THEN
               SWITCH = .TRUE.
               RWORDS = RWORDS + 1
            END IF
         ELSE
            SWITCH = .FALSE.
         END IF
   10 CONTINUE
*
      RETURN
      END
+DECK,ROTERS.
      SUBROUTINE ROTERS
************************************************************************
*.
*...ROTESV    Restore the saved TE raw data from LQ(LGNRL - LLODTR)
*.            ODTR and this routine will become obsolete once DDTE works
*.
*. SEQUENCES :
*. CALLS     : ZSHUNT
*. CALLED    : ROPBAT
*.
*. AUTHORS   : M.Schroder
*. VERSION   : 4.12
*. CREATED   :  3-Aug-96
*. LAST MOD  :  1-Oct-96
*.
*. Modification Log.
*.  1-Oct-96 M.Schroder Change ODTE to ODTR to avoid conflict with TE bank
************************************************************************
+SEQ,DECLARE.
+SEQ,ROBANK,ROPAR,RCREP.
+SEQ,ODPAR.
      INTEGER LTERA, LODTR, LGNRL, NLGNRL
      LOD = LQ(LREV-LLOD)
      IF ( LOD .LE. 1 ) THEN
         CHREP = 'No OD bank found'
         CALL REPORT('ROTERS',1,'W')
         RETURN
      ENDIF
      LGNRL = LQ(LOD-LLODGL)
      IF ( LGNRL .LE. 1 ) THEN
         CHREP = 'No GNRL bank found'
         CALL REPORT('ROTERS',2,'W')
         RETURN
      ENDIF
      NLGNRL = IQNL(LGNRL)
      IF ( NLGNRL .LT. LLODTR ) THEN
         CHREP = 'No link to ODTR bank from GNRL.'
         CALL REPORT('ROTERS',3,'W')
         RETURN
      ENDIF
      LODTR = LQ(LGNRL-LLODTR)
      IF ( LODTR .LT. 1 ) THEN
         CHREP = 'No ODTR bank hanging from GNRL.'
         CALL REPORT('ROTERS',4,'W')
         RETURN
      ENDIF
      IF ( LDA .LE. 1 ) THEN
        CHREP = 'No DA bank found, booking it.'
        CALL REPORT('ROTERS',4,'W')
        CALL MZBOOK(IRODIV,LDA,LREV,-LLDA,'DA  ', NLDA,NSDA,NDDA,IODA,0)
      ENDIF
      IF ( IQNL(LDA) .LT. LLTERA ) THEN
         CHREP = 'No link for TE raw data bank, extent DA link section'
         CALL REPORT('ROTERS',1,'I')
         CALL MZPUSH(IXSTOR,LDA,LLTERA-IQNL(LDA),0,' ')
      ELSE
         LTERA = LQ(LDA-LLTERA)
         IF ( LTERA .GT. 1 ) THEN
            IF (IQND(LTERA).EQ.IQND(LODTR).AND.
     +          IQNL(LTERA).EQ.IQNL(LODTR)) THEN
               CHREP = 'TERA bank exists, do not overwrite it.'
               CALL REPORT('ROTERS',2,'I')
               RETURN
            ELSE
               CHREP = 'Existing TERA and ODTR banks not identical.'
               CALL REPORT('ROTERS',1,'E')
               RETURN
            ENDIF
         ENDIF
      ENDIF
      LODTR = LQ(LGNRL-LLODTR)
      CALL ZSHUNT(IXSTOR,LODTR,LDA,-LLTERA,0)
      RETURN
      END
+DECK,ROTESV.
      SUBROUTINE ROTESV
************************************************************************
*.
*...ROTESV    Save the TE raw data by hanging in onto LQ(LGNRL - LLODTR)
*.            ODTR and this routine will become obsolete once DDTE works
*.
*. SEQUENCES :
*. CALLS     : ZSHUNT
*. CALLED    : ROWOUT
*.
*. AUTHORS   : M.Schroder
*. VERSION   : 4.12
*. CREATED   :  3-Aug-96
*. LAST MOD  :  1-Oct-96
*.
*. Modification Log.
*.  1-Oct-96 M.Schroder Change ODTE to ODTR to avoid conflict with TE bank
************************************************************************
+SEQ,DECLARE.
+SEQ,ROBANK,ROPAR,RCREP.
+SEQ,ODPAR.
      INTEGER LTERA, LODTR, NDTERA, NDODTR, LGNRL, NLGNRL
      CHARACTER*4 CHID
      IF ( LDA .LE. 1 ) THEN
        CHREP = 'No DA bank found'
        CALL REPORT('ROTESV',1,'W')
        RETURN
      ENDIF
      LTERA = LQ(LDA-LLTERA)
      IF ( LTERA .LE. 1 ) THEN
         CHREP = 'No TE raw data bank found'
         CALL REPORT('ROTESV',2,'W')
         RETURN
      ENDIF
C     check if there is a copy of the TERA bank already
      LOD = LQ(LREV-LLOD)
      IF ( LOD .LE. 1 ) THEN
         CHREP = 'No OD bank found'
         CALL REPORT('ROTESV',3,'W')
         RETURN
      ENDIF
      LGNRL = LQ(LOD-LLODGL)
      IF ( LGNRL .LE. 1 ) THEN
         CHREP = 'No GNRL bank found'
         CALL REPORT('ROTESV',4,'W')
         RETURN
      ENDIF
      NLGNRL = IQNL(LGNRL)
      IF ( NLGNRL .LT. LLODTR ) THEN
         CHREP = 'Expanding links in GNRL block'
         CALL REPORT ('ROTESV ', 1, 'I')
         CALL MZPUSH(IXSTOR,LGNRL,LLODTR-IQNL(LGNRL),0,' ')
      ELSE
         LODTR = LQ(LGNRL-LLODTR)
         IF ( LODTR .GT. 1 ) THEN
            CALL UHTOC(IQIDH(LODTR),4,CHID,4)
            IF ( CHID .NE. 'TERA' ) THEN
               CHREP = 'Bank on LGNRL-5 is '//CHID//', should be TERA'
               CALL REPORT('ROTESV',1,'E')
               RETURN
            ENDIF
            NDODTR = IQND(LODTR)
            NDTERA = IQND(LTERA)
            IF ( NDODTR .NE. NDTERA ) THEN
               WRITE(CHREP,1001) NDODTR, NDTERA
               CALL REPORT('ROTESV',2,'E')
               RETURN
            ENDIF
C            same ID, same size ? No do not copy the TERA bank
            RETURN
         ENDIF
      ENDIF
      CALL ZSHUNT(IXSTOR,LTERA,LGNRL,-LLODTR,0)
      RETURN
 1001 FORMAT(' ODTR bank has ',I6,' data words, but TERA bank has ',I6)
      END
+PATCH,ROOPERA.
+DECK,RDADDT,IF=VAX.
      SUBROUTINE RDADDT(MAWREC,IMAWDT,IERR)
*.
*..RDADDT      puts the date/time from MAWREC in integer format and
*.             returns the result in IMAWDT.
*.             returns IERR not equal to 0 on error.
*.
*.  SEQUENCES :  RCREP
*.  CALLS     :  STR$UPCASE REPORT
*.  CALLED    :  RDAFIL
*.
*.  AUTHORS   :  A M Lee
*.  VERSION   :  1.00
*.  CREATED   :  26-Aug-1990
*.  LAST MOD  :
*.
*.  Modification Log.
*.
**********************************************************************
+SEQ,DECLARE.
*
+SEQ,RCREP.
*--   passed MAW$DBS record
      CHARACTER*(*) MAWREC
*--   returned non-zero if error.
      INTEGER IERR
*--   VAX format date
      CHARACTER*132 MAWDAT
*--   VAX format time
      CHARACTER*132 MAWTIM
*--   returned MAW$DBS date and time array; formatted decimal
*--   (date=1, time=2; yyyymmdd and hhmmss)
      INTEGER IMAWDT(2)
*--   points to first and second "-" or ":" in the strings
      INTEGER IFIRST,ISEC
*--   temporary variable for parsing the date and time
      INTEGER ITEMP
*--   local loop index
      INTEGER IMON
*--   used to convert months to numbers
      CHARACTER*3 MONTHS(12)
      SAVE MONTHS
      DATA MONTHS /'JAN','FEB','MAR','APR','MAY','JUN',
     +             'JUL','AUG','SEP','OCT','NOV','DEC'/
*====>   PROCEDURE STATMENTS <====
*--   assume the worst
      IERR = 1
      IMAWDT(1) = 0
      IMAWDT(2) = 0
*--   get date and time from MAW$DBS record.  Counting from
*--   zero, the date and time are the second and third items
*--   in MAWREC (space delimitted).  They may appear as third
*--   and fourth due to dates like " 1-JAN-1990".
      CALL STR$ELEMENT(MAWDAT,2,' ',MAWREC)
      CALL STR$ELEMENT(MAWTIM,3,' ',MAWREC)
      IF (MAWDAT(1:1).EQ.' ') THEN
         CALL STR$ELEMENT(MAWDAT,3,' ',MAWREC)
         CALL STR$ELEMENT(MAWTIM,4,' ',MAWREC)
      END IF
      IF (MAWTIM(1:1).EQ.' ' .OR. MAWTIM(1:1).EQ.'?'
     +.OR.MAWDAT(1:1).EQ.' ' .OR. MAWDAT(1:1).EQ.'?') GOTO 999
*--   will parse the following based on "-" and ":"; will assume
*--   that there are no spaces within the date and time strings.
*--   (e.g. "21- JUN- 1990" is no, " 21-JUN-1990  " is ok)
*--   first make string upper case (just in case)
      CALL STR$UPCASE(MAWDAT,MAWDAT)
*--   get position of first and second dash
      IFIRST = INDEX(MAWDAT,'-')
      ISEC =   INDEX(MAWDAT(IFIRST+1:50),'-')
      IF (ISEC.NE.4) GOTO 999
      ISEC = IFIRST + ISEC
*--   first year
      READ(MAWDAT(ISEC+1:ISEC+4),'(BZ,I4.4)',ERR=999) ITEMP
      IMAWDT(1) = 10000*ITEMP
*--   then month
      ITEMP = 0
      DO 100 IMON = 1,12
         IF (MAWDAT(IFIRST+1:IFIRST+3).EQ.MONTHS(IMON)) ITEMP = IMON
 100  CONTINUE
      IF (ITEMP .EQ. 0) GOTO 999
      IMAWDT(1) = IMAWDT(1) + 100*ITEMP
*--   then day (date) (watch out 1st to 9th)
      IF (IFIRST.EQ.2) THEN
         READ(MAWDAT(IFIRST-1:IFIRST-1),'(BZ,I1.1)',ERR=999) ITEMP
      ELSE
         READ(MAWDAT(IFIRST-2:IFIRST-1),'(BZ,I2.2)',ERR=999) ITEMP
      END IF
      IMAWDT(1) = IMAWDT(1) + ITEMP
*--   now get the time
      IFIRST = INDEX(MAWTIM,':')
      ISEC = INDEX(MAWTIM(IFIRST+1:50),':')
      IF (ISEC.NE.3) GOTO 999
      ISEC =   IFIRST + ISEC
      READ(MAWTIM(IFIRST-2:IFIRST-1),'(BZ,I2.2)',ERR=999) ITEMP
      IMAWDT(2) = 10000*ITEMP
      READ(MAWTIM(IFIRST+1:IFIRST+2),'(BZ,I2.2)',ERR=999) ITEMP
      IMAWDT(2) = IMAWDT(2) + 100*ITEMP
      READ(MAWTIM(ISEC+1:ISEC+2),'(BZ,I2.2)',ERR=999) ITEMP
      IMAWDT(2) = IMAWDT(2) + ITEMP
*--   normal return
      IERR = 0
      RETURN
*--   return on error
 999  CONTINUE
      IERR = 1
      IMAWDT(1) = 0
      IMAWDT(2) = 0
      CHREP = 'DAD: problem with date/time in maw$dbs'
      CALL REPORT('RDADDT',1,'E')
      CHREP = MAWREC
      CALL REPORT('RDADDT',2,'E')
      RETURN
      END
+DECK,RDADOUV,IF=VAX,IF=-QMALPH.
      SUBROUTINE RDADOU(LIOBNK)
*.
*...RDADOU    Write a DAD record to file described by LIOBNK
*.
*.  SEQUENCES :  ROBANK ROUNIT RODADPAR ROCPAR RCREP
*.  CALLS     :  REPORT
*.  CALLED    :  ROWOUT
*.
*.  AUTHORS   :  D.Lellouch
*.  VERSION   :  1.00
*.  CREATED   :   21-Mar-91
*.  LAST MOD  :   21-Mar-91
*.
*.  Modification Log.
*.
*.********************************************************************
+SEQ,DECLARE.
      INTEGER LUN,LIOBNK
*
+SEQ,ROBANK.
+SEQ,ROUNIT.
+SEQ,RODADPAR.
+SEQ,ROCPAR.
+SEQ,RCREP.
*
      IF(.NOT.LDADL) THEN
         CHREP  = 'No DAD list on input, cannot write one on output'
         CALL REPORT('RDADOU',1,'E')
         CALL RCLSIO(LIOBNK,.FALSE.)
                                                               GO TO 999
      END IF
      LUN    = IQ(LIOBNK+JLUN)
      WRITE(LUN,ERR=10) IDARUN,IDAEVT,IDAFIL,IDARFA,IDADDT
      IQ(LIOBNK+JACTIV) = IQ(LIOBNK+JACTIV) + 1
                                                               GO TO 999
*
   10 WRITE(CHREP,1000) LUN
      CALL REPORT('RDADOU',2,'E')
      CALL RCLSIO(LIOBNK,.FALSE.)
*
  999 RETURN
 1000 FORMAT('DAD list write error on unit',I3)
      END
+DECK,RDADOUU,IF=UNIX.
      SUBROUTINE RDADOU(LIOBNK)
*.
*...RDADOU    Write a DAD record to file described by LIOBNK
*.
*.  SEQUENCES : ROBANK CRO ROUNIT ROCPAR ROPAR RCREP
*.  CALLS     :  REPORT
*.  CALLED    :  ROWOUT
*.
*.  AUTHORS   :  D.Lellouch
*.  VERSION   :  1.00
*.  CREATED   :  21-May-91
*.  LAST MOD  :  19-Aug-93
*.
*.  Modification Log.
*.  19-Aug-93 O.Schaile   Bug fix, inc counter for non shift
*.  23-Mar-92 O.Schaile   Fix event counting on SHIFT
*.  11-Dec-91 T.Mouthuy   Write DADlist in CIO format
*.
*.********************************************************************
+SEQ,DECLARE.
      INTEGER LIOBNK,LUN,IO
+SELF,IF=SHIFT.
      INTEGER IDAD(6)
+SELF.
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
+SEQ,ROPAR.
+SEQ,RCREP.
+SELF,IF=SHIFT.
+SEQ,DADRFCDE.
+SELF.
*
      IF(.NOT.LFZL) THEN
         CHREP  = 'No information on pointers. Can''t write DADlist'
         CALL REPORT('RDADOU',1,'E')
         CALL RCLSIO(LIOBNK,.FALSE.)
*
      ELSE IF(NHEADR(IIPDSF).EQ.0.OR.NHEADR(IIPDSR).EQ.0
     +                           .OR.NHEADR(IIPDSE).EQ.0) THEN
         CHREP  = 'One of the pointers is wrong. Can''t write DADLIST'
         CALL REPORT('RDADOU',2,'E')
*
      ELSE
         LUN    = IQ(LIOBNK+JLUN)
+SELF,IF=-SHIFT.
         WRITE(LUN,ERR=10,IOSTAT=IO) IRDRUN,IRDEVT,
     +   NHEADR(IIPDSF),NHEADR(IIPDSR),NHEADR(IIPDSE)
+SELF,IF=SHIFT.
*-- Dadlist should be written in CIO format.
         IDAD(1) = IRDRUN
         IDAD(2) = IRDEVT
         IDAD(3) = NHEADR(IIPDSF)
         IDAD(4) = NHEADR(IIPDSR)
         IDAD(5) = NHEADR(IIPDSE)
         IDAD(6) = NHEADR(IIEVLG)
         CALL CFPUT(LCIOLU(LUN),0,6,IDAD,IO)
         IF(IO.NE.0)                                            GO TO 10
+SELF.
         IQ(LIOBNK+JACTIV) = IQ(LIOBNK+JACTIV) + 1
      END IF
                                                               GO TO 999
*
   10 WRITE(CHREP,1000) IO,LUN
      CALL REPORT('RDADOU',3,'E')
      CALL RCLSIO(LIOBNK,.FALSE.)
*
  999 RETURN
 1000 FORMAT('DAD list write error',I3,' on unit',I3)
      END
+DECK,RDAFIL,IF=VAX,IF=-QMALPH.
      SUBROUTINE RDAFIL(IFILE,ILUN,FILNAM,IMAWDT)
*.
*..RDAFIL        takes input file number and file name database unit
*.               number, and returns a file name.
*.
*.  SEQUENCES :  RCREP
*.  CALLS     :  REPORT STR$ELEMENT RDADDT
*.  CALLED    :  RDADOP
*.
*.  AUTHORS   :  A M Lee
*.  VERSION   :  1.00
*.  CREATED   :   9-May-90
*.  LAST MOD  :   2-Sep-91
*.
*.  Modification Log.
*.    2-Sep-91  A.Lee       Catalog now open unformatted.
*.
*.    A M Lee      for ROPE; add checking of MAW$DBS date and time
*.
**********************************************************************
+SEQ,DECLARE.
*
+SEQ,RCREP.
*--   passed number indicating which file to use (index into MAW$DBS)
      INTEGER IFILE
*--   unit number of file name database to be used (passed)
      INTEGER ILUN
*--   returned file name
      CHARACTER*(*) FILNAM
*--   returned date and time are packed yyyymmdd and hhmmss as integers.
*--   these will be compared with date and time in DADlist to make
*--   sure the DADlist/MAW$DBS combination is valid.
      INTEGER IMAWDT(2)
*--   local character strings for reading/parsing MAW$DBS
      CHARACTER*132 MAWFILE,MAWREC
*--   first and last characters in file name in the maw record
      INTEGER ISTART,IEND
*--   i/o status returned by read
      INTEGER IOS
*--   length of passed character variable for name
      INTEGER MAXLEN
*--   fortran function for getting length of string
      INTEGER LEN
      INTRINSIC LEN
*=====> PROCEDURE STATEMENTS <=====
*--   read record requested; what follow is a yucky DO WHILE loop.
*--   keep trying if record is locked (ios=52)
  30  CONTINUE
         READ(UNIT=ILUN,ERR=50,IOSTAT=IOS,REC=IFILE) MAWREC
         IOS = 0
  50     CONTINUE
      IF (IOS.EQ.52) GOTO 30
*--   check to see if read was successful; if not, puke.
      IF (IOS.NE.0) THEN
         WRITE(CHREP,*) 'DAD: error reading filename database:',IFILE
         CALL REPORT('RDAFIL',1,'E')
         IFILE = -1
         RETURN
      END IF
*--   assume file name is first "word" after the first space.
      CALL STR$ELEMENT(MAWFILE,1,' ',MAWREC)
*--   drop the VSOPXX:: from the file name, if present.
      ISTART = INDEX(MAWFILE,'::')
      IF (ISTART.NE.0) THEN
          ISTART = ISTART + 2
      ELSE
         ISTART = 1
      END IF
*--   get the end of the name (assume it ends in a space)
      IEND = INDEX(MAWFILE(ISTART:LEN(MAWFILE)),' ')
      IF (IEND.NE.0) THEN
         IEND = IEND + ISTART - 2
      ELSE
         WRITE (CHREP,*) 'DAD: unable to get filename!!!',IFILE
         CALL REPORT('RDAFIL',1,'E')
         CHREP = MAWREC
         CALL REPORT('RDAFIL',2,'E')
         IFILE = -1
         RETURN
      END IF
*--   flag more name problems.
      MAXLEN = LEN(FILNAM)
      IF (IEND-ISTART.GE.MAXLEN .OR. IEND-ISTART.LT.1) THEN
         WRITE(CHREP,*) 'DAD: problem with filename length',IFILE
         CALL REPORT('RDAFIL',3,'E')
         CHREP = MAWREC
         CALL REPORT('RDAFIL',4,'E')
         WRITE(CHREP,*)'IEND,ISTART,MAXLEN',IEND,ISTART,MAXLEN
         CALL REPORT('RDAFIL',5,'E')
         IFILE = -1
         RETURN
      END IF
*--   finally have the file name
      FILNAM = MAWFILE(ISTART:IEND)
*--   now call routine to check that date and time are o.k.
      CALL RDADDT(MAWREC,IMAWDT,IOS)
      IF (IOS.NE.0) IFILE = -1
      RETURN
      END
+DECK,RDASET,IF=VAX,IF=-QMALPH.
      SUBROUTINE RDASET(RABIN,IRFAW)
*.
*..RDASET        sets next record to one indicated by passed RFA;
*.               passed RABIN is an integer with a file's RAB
*.               location; it is passed by value, making it appear
*.               as a RAB here.
*.
*.  SEQUENCES :  RODADPAR RCREP
*.  CALLS     :  REPORT LIB$STOP
*.  CALLED    :  RNXTEV
*.
*.  AUTHORS   :  A M Lee
*.  VERSION   :  1.00
*.  CREATED   :   9-May-90
*.  LAST MOD  :   9-May-90
*.
*.  Modification Log.
*.
*.********************************************************************
+SEQ,DECLARE.
*
+SEQ,RCREP.
*--   standard RAB, FAB parameters.
+SEQ,RODADPAR.
*--   Declare passed RAB records.
      RECORD /RABDEF/ RABIN
*--   define passed RFA pointers
      INTEGER*2 IRFAW(4)
*--   status returned by system call
      INTEGER ISTAT
*--   local loop index
      INTEGER I
*=====> PROCEDURE STATEMENTS <=====
*--   set up RAB block with pointer to event; indicate RFA access
      RABIN.RAB$B_RAC    = RAB$C_RFA
      RABIN.RAB$W_RFA(1) = IRFAW(1)
      RABIN.RAB$W_RFA(2) = IRFAW(2)
      RABIN.RAB$W_RFA(3) = IRFAW(3)
*--   find the desired record; fatal puke if fails.
      ISTAT = SYS$FIND(RABIN)
      IF (ISTAT.NE.RMS$_NORMAL) THEN
         WRITE (CHREP,*) 'DAD: error positioning record ',ISTAT
         CALL REPORT('RDASET',2,'F')
         CALL LIB$STOP(ISTAT)
      END IF
*--   reset record access mode to sequential mode.
      RABIN.RAB$B_RAC = RAB$C_SEQ
      RETURN
      END
+DECK,RGTDBS,IF=UNIX.
      SUBROUTINE RGTDBS(IDXFIL,FILNAM,LUSED)
*.----------------------------------------------------------------------
*.-
*.-....   RGTDBS : Gets entry pointed to by IDXFIL from filedbs.
*--                Returns machine specific name as a parameter,
*--                and more info in RCFDBS common block.
*--
*.-
*.-
*.-
*.-   Input    :
*.-   Output   :
*.-   Called   :
*.-   Calls    :
*.-   Seq.     :
*.-
*.-   Author   : Alfred Lee
*.-   Version  : 1.01
*.-   Created  : 17-May-1991
*. LAST MOD :  30-Oct-95
*.-
*.-   Modification log:
*. 30-Oct-95 O.Schaile    Use CIO for UNIX
*.-    3-JUL-1991   Alfred Lee:   handle newlines (LF) in the db.
*.    18-May-1991   D.Lellouch    Customise for ROPE400
*.-
*.----------------------------------------------------------------------
+SEQ,DECLARE.
*.----------------------------------------------------------------------
*--   munch parameters; comment delimiters.
+SEQ,RCFDBS.
+SEQ,RBITFUNC.
+SEQ,ROUNIT.
*--   passed file index for DADlists or nanodst.
      INTEGER IDXFIL
*--   returned filename; length of storage space for filename
      CHARACTER*(*) FILNAM
*--   returned length used for filename or error if negative
      INTEGER LUSED
*--   current direct access record in dbs
      INTEGER IDX
*--   local storage of lines from dbs
      CHARACTER*(LENDBS) DBLINE,SPACES
*--   iostatus returned by read statements
      INTEGER IOS
*--   temporary variables
      INTEGER ITEMP,I1,I2
      INTEGER NWRD
*==== PROCEDURE STATEMENTS ====*
*--   assume no entry
      LUSED = 0
      FILNAM = ' '
*--   get offset for read
      IDX = IBITS(IDXFIL,JBREC,IBREC)
      CALL CFSEEK(LUNCAT,0,40,IDX-1,IOS)
      NWRD=40
      IF(IOS.EQ.0)CALL CFGET(LUNCAT,0,40,NWRD,DBLINE,IOS)
*--   ran off the end of the dbs, return with no file.
      IF (IOS .NE. 0) THEN
         LUSED = -2
         FILNAM = ' '
         GO TO 999
      END IF
*--   now get data from the line; drop newline character
      DBLINE(160:160) = ' '
      DBLINE=SPACES(DBLINE,1)
*--   store useful info from filedbs in RCFDBS common,
*--   and get stuff to return as arguments.
*--   get full generic name and file name
      CALL RSBWRD(DBLINE,1,I1,I2)
      IF (I2.LE. 0) THEN
         LUSED = -3
                                                               GO TO 999
      ELSE
         CGEN=DBLINE(I1:I2)
      END IF
*--   get file and node name
      CALL RSBWRD(DBLINE,2,I1,I2)
      IF (I1 .LE. 0) THEN
         LUSED = -4
                                                               GO TO 999
      ELSE
         FILNAM=DBLINE(I1:I2)
         LUSED=I2-I1+1
      END IF
*--   get node name.
      ITEMP = INDEX(FILNAM(1:LUSED),'::')
      IF (ITEMP .LE. 0) THEN
         LUSED = -5
                                                               GO TO 999
      END IF
      IF (ITEMP.GT.1) THEN
         CHOST = FILNAM(1:ITEMP-1)
      ELSE
         CHOST = ' '
      END IF
*--   now drop node name from file name.
      CFILE = FILNAM(ITEMP+2:)
      FILNAM = CFILE
      LUSED = LUSED - (ITEMP+1)
*--   get the date/time string
      CALL RSBWRD(DBLINE,3,I1,I2)
      CTODAY = DBLINE(I1:I2)
*--   set ITEMP as pointer to put next word (leave a space)
      ITEMP=I2-I1+3
      CALL RSBWRD(DBLINE,4,I1,I2)
      CTODAY(ITEMP:)=DBLINE(I1:I2)
*--   get record sequence number
      CALL RSBWRD(DBLINE,5,I1,I2)
      IF (I2.LE.0) THEN
         LUSED=-6
                                                               GO TO 999
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS) ISEQ
         IF (IOS .NE. 0) THEN
            LUSED=-7
                                                               GO TO 999
         END IF
      END IF
*--   get record number
*--   if no record number stored, then put in read record number.
      CALL RSBWRD(DBLINE,6,I1,I2)
      IF (I2 .LE. 0) THEN
         IREC = IDX
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS)IREC
         IF (IOS .NE. 0) THEN
            LUSED = -8
                                                               GO TO 999
         END IF
      END IF
*--   construct unique file index
      IUNIQF = IREC
      CALL MVBITS(ISEQ,0,IBSEQ,IUNIQF,JBSEQ)
*--   check we have the correct file entry
      IF (IDXFIL.NE.IUNIQF) THEN
         LUSED = -9
                                                               GO TO 999
      END IF
*--   get first and last event number (if present)
      CALL RSBWRD(DBLINE,7,I1,I2)
      IF (I2.LE. 0) THEN
         IFSTEV = 0
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS) IFSTEV
         IF (IOS .NE. 0) IFSTEV = 0
      END IF
      CALL RSBWRD(DBLINE,8,I1,I2)
      IF (I1.LE. 0) THEN
         ILSTEV = 0
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS) ILSTEV
         IF (IOS .NE. 0) ILSTEV = 0
      END IF
*--   and the number of partitions
      CALL RSBWRD(DBLINE,9,I1,I2)
      IF (I2 .LE. 0) THEN
         IPARTI = 0
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS) IPARTI
         IF (IOS .NE. 0) IPARTI = 0
      END IF
*--   all done.
  999 RETURN
      END
+DECK,RIRFIOS,IF=SHIFT.
      SUBROUTINE RIRFIO(IUNIT,IFILE)
*.
*..RIRFIO    Scan DADLIST buffer and call special RFIO routine to
*            buffer readout
*.
*.
*.  SEQUENCES :
*.  CALLS     :  RNXTEV
*.  CALLED    :
*.
*.  AUTHORS   :  T.Mouthuy
*.  VERSION   :  1.00
*.  CREATED   :  11-Dec-91
*.  LAST MOD  :  08-Dec-94
*.
*.  Modification Log.
*.  25-Sep-94   O.Schaile  Transmit exact event location + length
*.                         with new DAD lists
*.  08-Dec-94   G.Duckeck  don't preseek if events have 0 length
*.                         (ROPE produced dadlists)
*.
**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IFILE
      INTEGER NUMBER,I,IEVLEN,IUNIT
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
+SEQ,ROWORD.
+SEQ,RBITFUNC.
+SEQ,RCREP.
+SEQ,DADRFCDE.
      INTEGER IOV(2,NBDAD)
*
      NUMBER=0
      DO 10 I=LOCMEM,NUMMEM
        IF(IDAMEM(3,I).EQ.IFILE) THEN
          NUMBER=NUMBER+1

*-- GD: rope dadlists look like CIO but have no length, don't preseek
          IF ( IDAMEM(6,I) .LE. 0 ) GOTO 999

          IF(LDACIN)THEN
*            request only the needed data
*            Byte offset to event in file
             IOV(1,NUMBER) = (IDAMEM(4,I)-1)*32400 + IDAMEM(5,I)*4
*            number of bytes needed
             IOV(2,NUMBER) = IDAMEM(6,I)*4
          ELSE
*            request complete physical records
*            Byte offset to beginning of record
             IOV(1,NUMBER) = (IDAMEM(4,I)-1)*32400
*            Length of event (in words)  + pointer to beginning of event
*            (in multiple of 32400) and add some safety factor
             IEVLEN = (IDAMEM(6,I) + 100 + IDAMEM(5,I)) *4
             IEVLEN = (IEVLEN / 32400)
             IOV(2,NUMBER) = (IEVLEN+1) * 32400
          ENDIF
        ELSE
          GOTO 20
        ENDIF
   10 CONTINUE
*
*-- Call now special routine
*
   20 CONTINUE
      CALL PRESEE(LCIOLU(IUNIT),IOV,NUMBER)
 999  RETURN
      END
+DECK,RIRFIOU,IF=-SHIFT.
      SUBROUTINE RIRFIO(IUNIT,IFILE)
*.
*..RIRFIO    Dummy for non shift
*.  SEQUENCES :
*.  CALLS     :  REPORT
*.  CALLED    :  RNXTEV
*.
*.  AUTHORS   :  O.Schaile
*.  VERSION   :  1.00
*.  CREATED   :  1-Feb-94
*.  LAST MOD  :
*.
*.  Modification Log.
*.
*.
**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IFILE,IUNIT
+SEQ,RCREP.
      CHREP='CIO Dadlists are only supported on SHIFT'
      CALL REPORT('RIRFIO',1,'C')
      END
+DECK,RLOCA,IF=UNIX.
      FUNCTION IRLOCA(ARRAY,LENGTH,NC,OBJECT)
*.
*...IRLOCA    Locate OBJECT in ARRAY
*.
*.  SEQUENCES :
*.  CALLS     :
*.  CALLED    :  RNEVTL
*.
*.  AUTHORS   :  F.James
*.  VERSION   :  2.00
*.  CREATED   :     -Sep-74 (!)
*.  LAST MOD  :   25-May-91
*.
*.  Detailed description
*.        binary search thru 'array'  to find  'object'
*.        'array' is assumed to be sorted prior to call
*.        if match is found, function returns position of element
*.        if no match found, function gives negative of nearest element
*.                               smaller than object
*.
*.  Modification Log.
*.  25-May-91 D.Lellouch adds a dim and change routine name (LOCATI)
*.********************************************************************
+SEQ,DECLARE.
*
      INTEGER LENGTH,NC,NABOVE,NBELOW,MIDDLE,IRLOCA
      INTEGER ARRAY(NC,LENGTH),OBJECT
      NABOVE = LENGTH + 1
      NBELOW = 0
   10 IF(NABOVE-NBELOW.LE.1)                                    GO TO 50
      MIDDLE = (NABOVE+NBELOW)/2
      IF(OBJECT-ARRAY(1,MIDDLE)) 20,40,30
   20 NABOVE = MIDDLE
                                                                GO TO 10
   30 NBELOW = MIDDLE
                                                                GO TO 10
   40 IRLOCA = MIDDLE
                                                               GO TO 999
   50 IRLOCA = -NBELOW
  999 RETURN
      END
+DECK,RNEVTLU,IF=UNIX,VAX.
      SUBROUTINE RNEVTL(LUNIT,IER)
*.
*...RNEVTL    Reads an event from the event list
*.
*.  SEQUENCES :  ROBANK CRO ROUNIT ROPAR ROCPAR RCNTRL RCFDBS ROWORD
*.            :  RBITFUNC RCREP
*.  CALLS     :  REPORT MZBOOK LZLAST IRLOCA
*.  CALLED    :  RGETDA
*.
*.  Detailed description
*.
*.  Read a new entry for the event list. Format is:
*.
*.   [run] [trigger] [command]
*.
*.   Command may be:
*.   --------------
*.   * comment    : just read the comment field
*.   + comment    : print the comment field
*.   STOP EOF END : fake an eof
*.
*.  AUTHORS   :  D.Lellouch
*.  VERSION   :  1.00
*.  CREATED   :  25-May-91
*.  LAST MO   :  2-Jun-97
*.
*.  Modification Log.
*.   2-Jun-97   M.Schroder Correct number of arguments in closing ROCGEP call
*.   5-Nov-95   G.Duckeck  Interactive event access (LEVTIA)
*.   2-Feb-94   M.Redmond     Don't transfer into middle of IF THEN ELSE
*.  28-Jan-93   O.Schaile     Repl ITRYMX NTRYMX(1)
*.  12-Aug-93   O.Schaile if event cant be found try next
*.  22-Sep-92   B.Panzer  no more reading from the nanodst, instead
*.                         using the new dad-database
*.   911008   S.Weisz Interactive Event List on shift.
*.  29-Aug-91 S.Weisz    Slight alteration
*.
*.********************************************************************
      IMPLICIT NONE
*
      INTEGER       LUNIT,IER,ITRY,IOS,IPLUS,ISTAR,I1,I2,IRUN,IEVT,
     +              IOSEL,MODE,TYPE,
     +              DCHOPT
      SAVE          ITRY
      INTEGER       LENOCC,LZLAST,IRLOCA
      EXTERNAL      LENOCC,LZLAST,IRLOCA
      CHARACTER*80  LINE,SPACES
      CHARACTER*4   COMM,STATUS,CHIO
*
      PARAMETER     (MODE=0,TYPE=1,DCHOPT=1,STATUS='OLD ',CHIO='IODI')
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROUNIT.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,RCNTRL.
+SEQ,RCFDBS.
+SEQ,ROWORD.
+SEQ,RBITFUNC.
+SEQ,RCREP.
C
C GD >
+SEQ,ROEVIA.
      INTEGER IFLAG, IFINF(5), LFZ, IFLDEF
      LOGICAL LFZCHN
      EXTERNAL ROFGET
*
      SAVE LFZ, LFZCHN, IFLDEF

      DATA LFZCHN/.FALSE./, IFLDEF/-1/
* GD
      DATA ITRY/0/

      IF(IRINTR.EQ.1.AND.LUNIT.EQ.LRIN) THEN
         IRUN   = ISLRUN
         IEVT   = ISLEVT
                                                                GO TO 30
      ENDIF

 10   CONTINUE

      IF ( LEVTIA ) THEN
         IRUN  = IRUNIA
         IEVT  = IEVTIA
         IFLAG = IFLGIA
      ELSE
*-- Read a new line
         READ(UNIT=LUNIT,FMT='(A)',IOSTAT=IOS,END=40,ERR=50) LINE
*-- Decode the line
         LINE   = SPACES(LINE,1)
         IPLUS  = INDEX(LINE,'+')
         ISTAR  = INDEX(LINE,'*')
         IF(IPLUS.GT.0) THEN
            CHREP  = 'Event list:'//LINE
            CALL REPORT('RNEVTL',1,'I')
         END IF
C > GD
         IF ( IFLDEF .EQ. -1 ) THEN
            CALL CLTOU(LINE)
            IFLDEF  = INDEX(LINE,'MC')
            IF(IFLDEF .GT. 0) THEN
               IFLDEF = 1
               CHREP  = 'Event list for MC'
            ELSE
               IFLDEF = 0
               CHREP  = 'Event list for data'
            ENDIF
            CALL REPORT('RNEVTL',1,'I')
         END IF
         COMM   = LINE(1:4)
         CALL CLTOU(COMM)
         IF(LENOCC(LINE).EQ.0.OR.ISTAR.EQ.1.OR.IPLUS.GT.0)      GO TO 10
         IF(COMM.EQ.'STOP'.OR.COMM.EQ.'EOF '.OR.COMM.EQ.'END ') GO TO 40
*
         CALL RSBWRD(LINE,1,I1,I2)
         IF(I2.EQ.0)                                            GO TO 60
         READ(LINE(I1:I2),*,ERR=60) IRUN
         CALL RSBWRD(LINE,2,I1,I2)
         IF(I2.EQ.0)                                            GO TO 60
         READ(LINE(I1:I2),*,ERR=60) IEVT
         CALL RSBWRD(LINE,3,I1,I2)
         IF(I1.GT.0 .AND. I2.GE. I1 ) THEN
            READ(LINE(I1:I2),*,ERR=31) IFLAG
            GOTO 30
 31         IFLAG = IFLDEF
         ELSE
            IFLAG = IFLDEF
         ENDIF
      END IF
      IF(.NOT. LEVTIA)THEN
         IREVNT=IREVNT+1
         IRDEVT=IEVT
         IRDRUN=IRUN
         CALL RSELRE(IOSEL)
         IF(IRSTOP.EQ.2)GOTO 999
         IF(IOSEL.EQ.0)GOTO 10
         IREVNT=IREVNT-1
      END IF
   30 CONTINUE
*-- Real action starts. First of all, make sure that the current
*-- run is in use
      CALL ROCGEP(IRUN,IEVT,IFLAG,IER,
     +     IFINF(1),IFINF(2),IFINF(3),IFINF(4),IFINF(5))
      IF(IER.GT.0) then
*-- set it to a value which allows another try
         IER = -33
         IF ( LEVTIA ) THEN
                                                               GO TO 999
         ELSE
                                                                GO TO 10
         ENDIF
      ENDIF
      IF(IER.NE.0)                                             GO TO 999

C -- must be reset here to be able to continue with other channel
C--  moved up to RGETDA
*-- Open FZ channel mode if not yet done
      IF ( .NOT. LFZCHN ) THEN
         LFZ = -99
         LFZCHN = .TRUE.
         IF ( LUNAIN .LE. 0 ) THEN
            LUNAIN = 52
         ENDIF
         CALL FZFILE(LUNAIN,8100,'CIXD')
         CALL FZHOOK(LUNAIN,ROFGET,0)
      ENDIF

      CALL ROFPOS(IFINF,LFZ)
      CALL FZINXT(LUNAIN,IFINF(1),IFINF(2))

CCC      CALL RNXTNA(0,IRUN,IEVT,IER)
CCC*--   event not found, try next
CCC      IF(IER.EQ.5)                                          GO TO 10
CCC      IF(IER.NE.0)                                          GO TO 999
*-- Vital check: did we get the expected run and trigger numbers?
CCC      IF(IEVT.NE.NHEADR(IIEVT).OR.IRUN.NE.NHEADR(IIRUN))    GO TO 130
*-- So far so good!
                                                               GO TO 999
*-- End of file
*-- Close connection
 40   IFLAG = -1
      CALL ROCGEP(IRUN,IEVT,IFLAG,IER,
     +     IFINF(1),IFINF(2),IFINF(3),IFINF(4),IFINF(5))
      LFZCHN = .FALSE.
      IER = 5
                                                               GO TO 999
*-- Read error
   50 WRITE(CHREP,1000) IOS,LUNIT
      CALL REPORT('RNEVTL',2,'E')
                                                               GO TO 140
*-- Decoding error
   60 CHREP  = 'Decoding error for line:'//LINE
      CALL REPORT('RNEVTL',3,'E')
CCC                                                               GO TO 140
CCC*-- We did not get the expected event.
CCC  130 WRITE(CHREP,1040) IRUN,IEVT,IUHEAD(IIRUN),IUHEAD(IIEVT)
CCC      CALL REPORT('RNEVTL',10,'E')
*-- Let's try again, up to NTRYMX(1) times ....
  140 IER    = -5
      ITRY   = ITRY+1
      IF(ITRY.GT.NTRYMX(1)) THEN
         CHREP  = 'Too many errors in event list access. '//
     +            'Stop before it is too late'
         CALL REPORT('RNEVTL',5,'C')
      END IF
*
  999 RETURN
 1000 FORMAT('Read error:',I5,'  on event list unit',I3)
 1040 FORMAT('Serious mismatch: expected run',I5,' trigger',I7
     +      ,'  found run',I5,' trigger',I7)
      END
+DECK,RNXTEVV,IF=VAX,IF=-QMALPH.
      SUBROUTINE RNXTEV(IUNIT,JSKIPF,IRNXTE,IENXTE,IFNXTE,IER)
*     JSKIPF,IRNXTE,IENXTE,IFNXTE are not used here (only for SHIFT)
*.
*..RNXTEV    Positions next event to be read based on a DAD lists.
*.           If FFREAD card such as *FILE or *DADFILE is present for
*.           this unit, then this gets the next event desired for the
*.           corresponding DAD list,  opening and closing data files
*.           as is necessary.  All the data in one DAD file is treated
*.           by ROPE as existing in one file.
*.
*.
*.  SEQUENCES :  RODADPAR ROBANK ROPAR CRO RCREP
*.  CALLS     :  REPORT RDADLU RDAFIL RDASET RDAEND
*.  CALLED    :  RGETDA
*.
*.  AUTHORS   :  A M Lee
*.  VERSION   :  1.01
*.  CREATED   :  10-Mar-91
*.  LAST MOD  :   6-Sep-90
*.
*.  Modification Log.
*.
*.    10-Mar-91  D Lellouch  Substantial rewrite for Rope 400
*.    10-Jul-90  A M Lee     Standard version for ROPE 311.
*.     5-Sep-90  A M Lee     Fix bug in INDX initialization (1 not 0)
*.                           use DO WHILE where appropriate.
*.     6-Sep-90  A M Lee     open MAW$DBS not shared
*.
**********************************************************************
+SEQ,DECLARE.
*
+SEQ,ROBANK,ROPAR,CRO,RCREP.
+SEQ,ROUNIT.
*--   standard RAB, FAB parameters.
+SEQ,RODADPAR.
*--   I/O unit number of current FZIN call, passed parameter.
      INTEGER IUNIT
*--   memory location of RAB for current unit.
      INTEGER IRABLOC
      SAVE    IRABLOC
      INTEGER*2 ILRFAW(4)
      EQUIVALENCE (IDARFA,ILRFAW)
*--   date and time are packed yyyymmdd and hhmmss as integers.
*--   used to compare date and time in MAW$DBS with one in
*--   DADlist to make sure the combination is valid.
      INTEGER IMAWDT(2)
*--   file name for next file to open
      CHARACTER*132 FILNAM
*--   status returned true by RDADLU if able it initialize DAD luns
      LOGICAL GOOD
*--   local index
      INTEGER I,IOSTAT,IER
      INTEGER JSKIPF,IRNXTE,IENXTE,IFNXTE
*--   system function to get location of RAB block for a unit.
      INTEGER  FOR$RAB
      EXTERNAL FOR$RAB
*=====> PROCEDURE STATEMENTS <=====
*--   read next entry in list; jump to finish up on end of file
      READ (UNIT=IUNIT,IOSTAT=IOSTAT,ERR=700,END=800)
     +      IDARUN,IDAEVT,IDAFIL,IDARFA,IDADDT
      NEVDAD = NEVDAD + 1
*--   see if we need to open a new data file; if so quietly close and
*--   open a new data file, without telling ROPE; what it doesn't
*--   know can't hurt it.
      IF (IDAFIL.NE.LASTDI) THEN
*--      pass file index and lun; get new data file name and date
*--      and time of file in MAW$DBS;
*--      close steam if bad.
         CALL RDAFIL(IDAFIL,LUNCAT,FILNAM,IMAWDT)
         IF (IDAFIL.LT.0) THEN
            WRITE (CHREP,*) 'DAD: error getting data file name'
            CALL REPORT('RNXTEV',4,'E')
            GOTO 800
*--      check that date/time in MAW$DBS and DADlist agree
         ELSE IF (IMAWDT(1).NE.IDADDT(1)
     +        .OR.IMAWDT(2).NE.IDADDT(2)) THEN
            CHREP = 'DAD: date/time of list and maw$dbs don''t agree'
            CALL REPORT('RNXTEV',3,'E')
            WRITE(CHREP,*) IDADDT,IMAWDT
            CALL REPORT('RNXTEV',4,'E')
            GOTO 800
         END IF
         LASTDI = IDAFIL
*--      open new DST file; for now, sequential, variable length,
*--      unformatted is assumed for the data (checked by RDADLU).
         CLOSE (LUDAIN)
         OPEN(UNIT=LUDAIN,FILE=FILNAM,STATUS='OLD',
     +        FORM='UNFORMATTED',READONLY)
*--      inform user that RFAs are being used
         IF(LDADEX) THEN
             CHREP = 'DAD: data file is now: '//FILNAM
             CALL REPORT('RNXTEV',5,'I')
         END IF
*--      new file, get the RAB location using FOR$RAB.
         IRABLOC = FOR$RAB(LUDAIN)
      END IF
*--   pass location of RAB and RFA to routine which will
*--   set the next event to be read to the desired one.
      CALL RDASET(%VAL(IRABLOC),IDARFA)
*--   everything OK, return
      RETURN
*--   Error
700   WRITE(CHREP,1000) IUNIT,IOSTAT
      CALL REPORT('RNXTEV',6,'E')
      IER=-5
      GO TO 810
*--   Jump here on end of file for list file; set next event to
*--   the zebra end of file, close DAD list file, mark this
*--   FFREAD card as used, and return.
*--   This may puke if no DST file has been opened
*--   successfully; such is life.
 800  IER=5
 810  CONTINUE
*--   Daniel prefers not to fake an end-of-run
*     CALL RDAEN(%VAL(IRABLOC))
      RETURN
1000  FORMAT('Error while reading DAD List on unit',I3,' :',I3)
      END
+DECK,RNXTEV,IF=UNIX.
      SUBROUTINE RNXTEV(IUNIT,JSKIPF,IRNXTE,IENXTE,IFNXTE,IER)
*.
*..RNXTEV    Positions next event to be read based on a DAD lists.
*.
*.
*.  SEQUENCES :
*.  CALLS     :  REPORT ROOFLX
*.  CALLED    :  RGETDA
*.
*.  AUTHORS   :  D.Lellouch
*.  VERSION   :  1.00
*.  CREATED   :  22-May-91
*.  LAST MOD  :   7-May-99
*.
*.  Modification Log.
*.  7-May-99 M.Schroder Add PCLINUX flags
*.   3-Nov-95   G.Duckeck  Reshuffle code to close files correctly
*.  6-Nov-95  O.Schaile  CALL RSELDA only if IFSLON=0
*.   6-Oct-95   M.Schroder also reset LDACIN when closing dadlist file
*.   1-Aug-95   O.Schaile  reinstall dadlist for HP
*.  19-APR-95   G.Duckeck  get correct LIOBNK instead of using outdated
*.  11-APR-95   G.Duckeck  close last input file at end of dadlist
*.   4-APR-95   M.Schroder reset LDACIO when closing dadlist file
*.  22-Feb-95   G.Duckeck  Change reading of the dadlist
*.  13-Jan-95   G.Duckeck  call FZINXT also for channel mode
*.  08-Dec-94   G.Duckeck  Read ahead for old dadlist, don't use
*.                         RFIO for few events per file
*.  30-Nov-94   G.Duckeck  Mod preseek logic
*.  25-Sep-94   O.Schaile  Replace FZINXT by ROFPOS if LDACIN
*.  18-Fec-94   O.Schaile  Count and print NFADAD
*.  28-Jan-94   O.Schaile  Implement skipping of unreadable files
*.  15-Jun-92   C.Hawkes   fix event writing from DADlists on SHIFT
*.   7-Mar-92   O.Schaile  terminate ROPE if OPEN fails in ROOFLX
*.  18-Feb-92   O.Schaile  I5=>I7 in 1000,1010 FORMAT
*.  14-Feb-92   O.Schaile   remove (unreachable) LEOFIN=.FALSE.
*.  11-Dec-91 T.Mouthuy   Change DADlist reading for PRESEEK and CIO
*.   911002   S.Weisz Bug on event writing on SHIFT.
*.  6-Jul-91  S.Weisz     Slight alteration.
*.
*.
**********************************************************************
      IMPLICIT NONE
*
      INTEGER      IUNIT,IER,
     +             ISKIPF,IRNXTE,IENXTE,IFNXTE,NSKIPF,JSKIPF,IOLDSK
      INTEGER      IRUN,IEVENT,IFILE,IRECOR,IOFFSE,ISEL
      INTEGER      IOS,LNAME,FLAGS,LIOHD,LIOBNK
      INTEGER      LZLAST
      INTEGER      LNBLNK
      CHARACTER*4  ZOPT
      CHARACTER*80 CFNAME
      SAVE NSKIPF,ISKIPF,IOLDSK
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
+SEQ,ROWORD.
+SEQ,RCNTRL.
+SEQ,RBITFUNC.
+SEQ,RCREP.
+SEQ,RCLINE.
+SEQ,DADRFCDE.
      INTEGER NUMBER,ILENGT
* GD
      INTEGER NEVFIL, NUMMT, NPRMIN
      PARAMETER ( NPRMIN = 20 )
      SAVE NUMMT
      LOGICAL LPRES, LEDADF
      INTEGER LARUN, LAEV, LAFIL, LAREC, LAOFF
      SAVE LARUN, LAEV, LAFIL, LAREC, LAOFF, LEDADF
      INTEGER I,K
      DATA LAFIL /0/
* GD
      DATA NSKIPF,ISKIPF,IOLDSK/0,0,0/
*
      IF(JSKIPF.NE.0)THEN
         ISKIPF=JSKIPF
      ENDIF
*     come here when skipping events
    5 CONTINUE
      IF(LDACIO) THEN
*
* If DAD is in CIO format, keep some events in memory
*
        IF(LOCMEM.EQ.0.OR.LOCMEM.GE.NUMMEM) THEN
*-- Needed to read DADlist and store events in memory
*
*-- Process dadlist only for one data-file
*-- Then move remaining events to start of buffer IDAMEM
*-- and fill rest of buffer with new events.
*
*-- old dadlist and still events in buffer IDAMEM
          IF ( LOCMEM .NE. 0 .AND. NUMMEM .LT. NUMMT ) THEN
             CALL UCOPY2(IDAMEM(1,NUMMEM+1),IDAMEM(1,1),
     +            (NUMMT-NUMMEM)*NBPDAD)
             NUMMT  = NUMMT-NUMMEM
             NUMBER = (NBDAD - NUMMT)  * NBPDAD
          ELSE
*-- For a new dadlist (LOCMEM = 0)
             NUMMEM = 0
             NUMMT  = 0
             NUMBER = NBDAD * NBPDAD
             LEDADF = .TRUE.
          ENDIF
*-- Now reset LOCMEM
          LOCMEM = 0
*--     read new events in memory if still events in file
          IF ( LEDADF ) THEN
             CALL CFGET(LCIOLU(IUNIT),0,NUMBER,NUMBER,
     +            IDAMEM( 1, NUMMT + 1), IOS)

*--         EOF ?
             IF(IOS.EQ.-1) THEN
                LEDADF = .FALSE.

*--         Error ?
             ELSE IF(IOS.NE.0) THEN
                                                              GO TO 200
             ELSE
*--         Number of events actually read
                NUMMT  = NUMMT + NUMBER / NBPDAD
             ENDIF
          ENDIF

          NUMMEM = NUMMT
          IF(NUMMEM.EQ.0)                                     GO TO 100

+SELF,IF=-HPUX,IF=-PCLINUX.
* GD
*-- How many events in one file ?
          IFILE = IDAMEM(3,1)
          NEVFIL = 1
 111      CONTINUE
          NEVFIL = NEVFIL + 1
          IF ( NEVFIL .LE. NUMMEM .AND.
     +         IDAMEM(3,NEVFIL) .EQ. IFILE )                  GO TO 111
          NEVFIL = NEVFIL - 1
          NUMMEM = NEVFIL
          IF  ( NEVFIL .GT. NPRMIN ) THEN
             LPRES = .TRUE.
          ELSE
             LPRES = .FALSE.
          ENDIF
          LLOCAL = .NOT. LPRES
+SELF,IF=HPUX. No preseek on SnOpal
         LPRES=.FALSE.
+SELF,IF=PCLINUX. No preseek on LXOPAL
         LPRES=.FALSE.
+SELF.
* GD
        ENDIF
*
*-- End of storing events in memory - either ERROR or EOF or NUMMEM events
*-- Start handling part
*
        LOCMEM = LOCMEM + 1
        IRUN   = IDAMEM(1,LOCMEM)
        IEVENT = IDAMEM(2,LOCMEM)
        IFILE  = IDAMEM(3,LOCMEM)
        IRECOR = IDAMEM(4,LOCMEM)
        IOFFSE = IDAMEM(5,LOCMEM)
        ILENGT = IDAMEM(6,LOCMEM)
        NEVDAD = NEVDAD + 1
*
      ELSE
*
* Non CIO DAD-list
*
         IF(LOCMEM.EQ.0.OR.LOCMEM.GE.NUMMEM) THEN
*-- Needed to read DADlist and store events in memory
            NUMMEM = 0
            LOCMEM = 0
            DO 11 I=1,NBDAD
*-- LAFIL is 0 if start or if > NBDAD events in one file,
*-- else it contains event in next file
               IF ( I.EQ. 1 .AND. LAFIL .GT. 0 ) THEN
                  IDAMEM(1,I) = LARUN
                  IDAMEM(2,I) = LAEV
                  IDAMEM(3,I) = LAFIL
                  IDAMEM(4,I) = LAREC
                  IDAMEM(5,I) = LAOFF
                  LAFIL = 0
               ELSE
 10               READ(IUNIT,ERR=200,END=12,IOSTAT=IOS)
     +                 (IDAMEM(K,I),K=1,5)

*-- Do the pointers make sense?
                  IF(IDAMEM(3,I).EQ.0.AND.IDAMEM(4,I).EQ.0.
     +                 AND.IDAMEM(5,I).EQ.0.)
     +                                                          GO TO 10
*-- same file ?
                  IF ( IDAMEM(3,I) .NE. IDAMEM(3,1) ) THEN
                     LARUN = IDAMEM(1,I)
                     LAEV  = IDAMEM(2,I)
                     LAFIL = IDAMEM(3,I)
                     LAREC = IDAMEM(4,I)
                     LAOFF = IDAMEM(5,I)
                                                                GO TO 12
                  ENDIF
               ENDIF
               NUMMEM = NUMMEM + 1
 11         CONTINUE

 12         CONTINUE

*-- more events ?
            IF ( NUMMEM .LE. 0 )                               GO TO 100

*-- few events per file, open it locally (no rfio)
            IF  ( NUMMEM .GT. NPRMIN ) THEN
               LLOCAL = .FALSE.
            ELSE
               LLOCAL = .TRUE.
            ENDIF
         ENDIF
         LOCMEM = LOCMEM + 1
         IRUN   = IDAMEM(1,LOCMEM)
         IEVENT = IDAMEM(2,LOCMEM)
         IFILE  = IDAMEM(3,LOCMEM)
         IRECOR = IDAMEM(4,LOCMEM)
         IOFFSE = IDAMEM(5,LOCMEM)
         ILENGT = 0
         NEVDAD = NEVDAD + 1
*
      ENDIF

*
*-- Do we have to skip events?
  15  CONTINUE
      IF(ISKIPF.NE.0)THEN
         IF(IOLDSK.EQ.0)THEN
            IOLDSK=ISKIPF
            IF(LNAME.LE.0)CFNAME='?????????????????'
            LNAME=MIN(LNBLNK(CFNAME),80)
            WRITE(CHREP,'(A,Z9,A,A)')'Skip file Nr:',ISKIPF,' Name: '
     +      ,CFNAME(1:LNAME)
            CALL  REPORT('RNXTEV',7,'E')
            CHLINE=CHREP
            CALL RMAIL(0,0)
         ENDIF
         IF(IFILE.EQ.ISKIPF)THEN
            NFADAD=NFADAD+1
            WRITE(CHREP,'(A)')
     +      'Skipping event in unreadable file'
            CALL  REPORT('RNXTEV',13,'E')
            WRITE(CHLINE,'(A,4I8,A)')'*EVENT ',IRUN,IEVENT,IRUN,IEVENT,
     +       '  s_k_i_p_p_e_d by RNXTEV'
            CALL RMAIL(0,0)
*           loop until File Nr changes
                                                                  GOTO 5
         ELSE
            NSKIPF=NSKIPF+1
            IF(NSKIPF.GT.NTRYMX(2))THEN
*            IF(NSKIPF.GE.MSKIPF)THEN
               WRITE(CHLINE,'(A,I8,A)')'DAD list contained '
     +         ,NEVDAD,' events'
               CALL RMAIL(0,0)
               IF(NFADAD.GT.0)THEN
                  WRITE(CHLINE,'(A,I8,A)')'off which',NFADAD,
     +            ' have been skipped'
                  CALL RMAIL(0,0)
               ENDIF
               CHREP='Max allowed files skipped, terminate'
               CALL  REPORT('RNXTEV',6,'C')
*              dont return from this call
            ELSE
               IOLDSK=0
            ENDIF
            ISKIPF=0
         ENDIF
      ENDIF
*     return IRUN etc.
      IRNXTE=IRUN
      IENXTE=IEVENT
      IFNXTE=IFILE
*     apply possible selection already here to avoid reading d/s
      IREVNT=IREVNT+1
      IF(IRUFST.NE.0 .OR. IRTRIG(1).NE.0 .OR.
     +IRTRIG(2).NE.10000000 .OR.IRTRIG(3).NE.1
     +.AND.IFSLON.EQ.0)THEN
*      IF(IRUFST.NE.0)THEN
         IRDEVT=IEVENT
         IRDRUN=IRUN
         CALL RSELRE(ISEL)
         IF(IRSTOP.EQ.2)RETURN
         IF(ISEL.LE.0)                                            GOTO 5
      ENDIF
*-- Is this particular file already opened?
      IF(LASTNI.NE.IFILE) THEN
*-- Open the new one. First of all, get its name
         CALL RGTDBS(IFILE,CFNAME,LNAME)
         IF(LNAME.LE.0) THEN
            WRITE(CHREP,'(A,Z9,2I6)')
     +      'DAD list inconsistent, File, Run, Event:',
     +      IFILE,IRUN,IEVENT
            IF(NTRYMX(2).GT.0)THEN
*            IF(MSKIPF.GT.0)THEN
               CALL REPORT('RNXTEV',8,'E')
               ISKIPF=IFILE
                                                                 GOTO 15
            ELSE
               CALL REPORT('RNXTEV',1,'C')
               IER    = -5
                                                               GO TO 999
            END IF
         END IF
*-- We will have to book a bank for it
   20    LIOHD  = LQ(LUTC-LLIOHD)
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIODI)
         IF(LIOBNK.LE.0) THEN
            CHREP  = 'IO Bank inconsistency ... Expert problem!'
            CALL REPORT('RNXTEV',2,'C')
            IER    = -5
                                                               GO TO 999

         END IF
*-- Close the previous one?
         IF(LASTNI.GT.0) THEN
          CALL RCLSIO(LIOBNK,.TRUE.)
            LASTNI = 0
                                                                GO TO 20
         END IF
         LASTNI = IFILE
         FLAGS  = IBSET(0,INDIRF)
         IF(LDADEX) THEN
            ZOPT   = 'LD'
         ELSE
            ZOPT   = 'LQD'
            FLAGS  = IBSET(FLAGS,CLSQUI)
         END IF
         CALL MZBOOK(IROCON,LIOBNK,LIOBNK,0,'IODI',NLIOXX,NSIOXX,
     +               NDIOXX,IOIOXX,0)
         IQ(LIOBNK+JLUN)   = LUDAIN
         IQ(LIOBNK+JLREC)  = 8100
         CALL UCTOH(ZOPT,IQ(LIOBNK+JFCHOP),4,4)
         IQ(LIOBNK+JDCHOP) = 1
* tell ROOFLX how to open the files
         IF( LDACIO .AND. LDACIN ) THEN
           CALL UCTOH('5678',IQ(LIOBNK+JDCHOP),4,4)
         ENDIF
         IQ(LIOBNK+JACMOD) = 0
         IQ(LIOBNK+JFNTYP) = 1
         IQ(LIOBNK+JFLAGS) = FLAGS
         CALL UCTOH('OLD ',IQ(LIOBNK+JFSTAT),4,4)
         CALL UCTOH(CFNAME,IQ(LIOBNK+JFNAME),NBYTEW,80)
         CALL ROOFLX(LIOBNK)
+SELF,IF=SHIFT.
*-- reset JDCHOP, only needed for ROOFLX
         IQ(LIOBNK+JDCHOP) = 1
+SELF.
         LEOFIN = .FALSE.
         IF(IQ(LIOBNK+JACTIV).EQ.0) THEN
            LNAME=MIN(LNBLNK(CFNAME),80)
            CHREP  = 'Could not open: '//CFNAME(1:LNAME)
            IF(NTRYMX(2).GT.0)THEN
*            IF(MSKIPF.GT.0)THEN
               CALL REPORT('RNXTEV',9,'E')
               ISKIPF=IFILE
                                                                 GOTO 15
            ELSE
               CALL REPORT('RNXTEV',5,'C')
               IER    = -5
                                                               GO TO 999
            ENDIF
         ENDIF
*-- Send list of events to special RFIO routine to read them by bunches
         IF(LDACIO.AND.IRUFST.LE.0.AND.IRTRIG(3).EQ.1
     +        .AND. LPRES)
     +     CALL RIRFIO(LUDAIN,LASTNI)
      ELSE
*-- In the case the file is already opened but LOCMEM=1 (which means
*-- that a new bunch of events from SAME file), send the list if RFIO
*-- routine. This is only valid in the case of CIO DAD-list
        IF(LOCMEM.EQ.1.AND.LDACIO.AND.IRUFST.LE.0.AND.IRTRIG(3).EQ.1
     +        .AND. LPRES)
     +    CALL RIRFIO(LUDAIN,LASTNI)
         LEOFIN = .FALSE.
      END IF
*-- Fill pointers values in NHEADR for DAD list output
      NHEADR(IIPDSF) = IFILE
      NHEADR(IIPDSR) = IRECOR
      NHEADR(IIPDSE) = IOFFSE
      NHEADR(IIEVLG) = ILENGT
*-- Position file to requested event
      IF(LDACIN)THEN
         CALL ROFPOS(IDAMEM(4,LOCMEM),LCIOLU(LUDAIN))
         CALL FZINXT(LUDAIN,IRECOR,IOFFSE)
      ELSE
         CALL FZINXT(LUDAIN,IRECOR,IOFFSE)
      ENDIF
      IER    = 0
                                                               GO TO 999
*
  100 IER    = 5
      IF(NFADAD.LE.0)THEN
         WRITE(CHREP,1000) IUNIT,NEVDAD
         CALL REPORT('RNXTEV',3,'I')
      ELSE
         WRITE(CHREP,1010) IUNIT,NEVDAD,NFADAD
         CALL REPORT('RNXTEV',5,'E')
      ENDIF
*-- EOF in reading DAD list. As opened with CIO, CIO_CLOSE it!
* GD
+SELF,IF=SHIFT.
      IF(LASTNI.GT.0) THEN
         LIOHD  = LQ(LUTC-LLIOHD)
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIODI)
         IF(LIOBNK.GT.0) THEN
             CALL RCLSIO(LIOBNK,.TRUE.)
         ENDIF
       LASTNI = 0
      END IF
+SELF.
      IF(LDACIO) THEN
         LDACIO = .FALSE.
         LDACIN = .FALSE.
         CALL CFCLOS(LCIOLU(IUNIT),0)
         NUMMT = 0
      ENDIF
      LAFIL  = 0
      NUMMEM = 0
      LOCMEM = 0
* GD
                                                               GO TO 999
*
  200 IER=-5
      IF(NFADAD.LE.0)THEN
         WRITE(CHREP,1020) IOS,IUNIT,NEVDAD
         CALL REPORT('RNXTEV',4,'E')
      ELSE
         WRITE(CHREP,1030) IOS,IUNIT,NEVDAD,NFADAD
         CALL REPORT('RNXTEV',4,'E')
      ENDIF
*-- Error in reading DAD list. As opened with CIO, CIO_CLOSE it!
*
+SELF,IF=SHIFT.
      IF(LASTNI.GT.0) THEN
         LIOHD  = LQ(LUTC-LLIOHD)
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIODI)
         IF(LIOBNK.GT.0) THEN
            CALL RCLSIO(LIOBNK,.TRUE.)
         ENDIF
       LASTNI = 0
      END IF
+SELF.
      IF(LDACIO) THEN
        LDACIO = .FALSE.
        LDACIN = .FALSE.
        CALL CFCLOS(LCIOLU(IUNIT),0)
      ENDIF
  999 RETURN
 1000 FORMAT('EOF on dadlist unit',I3,' after',I7,' events')
 1010 FORMAT('EOF on dadlist unit',I3,' after',I7,' events',
     +' of which',I7,' have been skipped')
 1020 FORMAT('Error',I3,' on dadlist unit',I3,' after',I7,' events')
 1030 FORMAT('Error',I3,' on dadlist unit',I3,' after',I7,' events',
     +' of which',I7,' have been skipped')
      END
+DECK,RNXTNA,IF=UNIX.
      SUBROUTINE RNXTNA(LUNIT,JJRUN,JJEVE,IER)
*.
*...RNXTNA    Gets an event from the nanodst in sequential access
*.
*.  SEQUENCES :
*.  CALLS     :  REPORT RNAPOS
*.  CALLED    :  RGETDA RNEVTL
*.
*.  AUTHORS   :  D.Lellouch
*.  VERSION   :  1.00
*.  CREATED   :   30-Apr-91
*.  LAST MOD  :   18-Feb-98
*.
*.  Modification Log.
*.  16-Feb-98   E.Barberio  use shift6 instead of shift8
*.  24-Apr-95   M.Schroder use shift8 instead of shift1
*.  18-Feb-94   O.Schaile change error printout 1000, 1010
*.   1-Feb-94   O.Schaile Reinstall normal NanoDST reading
*.  13-Aug-93   O.Schaile Change Report at 889 to Error,
*.                        Continue if error on open
*.  22-Sep-92   B.Panzer  no more reading from the nanodst, instead
*.                        using the new dad-database
*.  14-Feb-92   O.Schaile LEOFIN=.FALSE.
*.
*.********************************************************************
+SEQ,DECLARE.
      INTEGER      LUNIT,IER,JJRUN,JJEVE,IRC,OUTEVE(5)
      INTEGER      IRUN,IEVENT,IFILE,IRECOR,IOFFSE
      INTEGER      IOS,LNAME,FLAGS,LIOHD,LIOBNK
      INTEGER      LZLAST
      CHARACTER*4  ZOPT
      CHARACTER*80 CFNAME
      CHARACTER*200 CCCOMM
      INTEGER IQUEST
*
      COMMON/QUEST/IQUEST(100)
*
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROUNIT.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCREP.
*
      IF(LUNIT.EQ.0)THEN
         IRC = 0
C call the new dad-database to get the information for run-event
         IER=0
         CCCOMM = ' '
         WRITE(CCCOMM,1055) JJRUN,JJEVE
         CALL SYSTEM(CCCOMM)
         IF (IRC .NE. 0) THEN
            CHREP  = 'dad-database has problems'
            CALL REPORT('RNXTNA',1,'C')
            IER    = -9
                                                               GO TO 999
         ENDIF
         OPEN(UNIT=99,FILE='temp99.file',STATUS='OLD')
         READ(99,*,ERR=889) OUTEVE
         CLOSE(UNIT=99)

         IRUN   = OUTEVE(1)
         IEVENT = OUTEVE(2)
         IFILE  = OUTEVE(3)
         IRECOR = OUTEVE(4)
         IOFFSE = OUTEVE(5)
         NHEADR(3) = OUTEVE(1)
         NHEADR(4) = OUTEVE(2)
         NHEADR(59) = OUTEVE(3)
         NHEADR(60) = OUTEVE(4)
         NHEADR(61) = OUTEVE(5)
      ELSE
*        direct access NanoDST
         NANREC = NANREC + 1
         READ(LUNIT,REC=NANREC,ERR=100,IOSTAT=IOS) NHEADR
         IER    = 0
         IQUEST(1) = 0
         IRUN   = NHEADR(IIRUN)
         IEVENT = NHEADR(IIEVT)
         IFILE  = NHEADR(IIPDSF)
         IRECOR = NHEADR(IIPDSR)
         IOFFSE = NHEADR(IIPDSE)
      ENDIF
*-- Do the pointers make sense?
      IF(IFILE.EQ.0.AND.IRECOR.EQ.0.AND.IOFFSE.EQ.0) THEN
         IER    = -1
         IQUEST(1) = -1
                                                               GO TO 999
      END IF
      NEVDAD = NEVDAD + 1
*-- Is this particular file already opened?
      IF(LASTNI.NE.IFILE) THEN
*-- Open the new one. First of all, get its name
         CALL RGTDBS(IFILE,CFNAME,LNAME)
         IF(LNAME.LE.0) THEN
            CHREP  = 'NanoDst list is inconsistent with catalog'
            CALL REPORT('RNXTNA',1,'C')
            IER    = -5
                                                               GO TO 999
         END IF
*-- We will have to book a bank for it
   20    LIOHD  = LQ(LUTC-LLIOHD)
         LIOBNK = LZLAST(IXSTOR,LIOHD-LLIODI)
         IF(LIOBNK.LE.0) THEN
            CHREP  = 'IO Bank inconsistency ... Expert problem!'
            CALL REPORT('RNXTNA',2,'C')
            IER    = -5
                                                               GO TO 999
         END IF
*-- Close the previous one?
         IF(LASTNI.GT.0) THEN
            CALL RCLSIO(LIOBNK,.TRUE.)
            LASTNI = 0
                                                                GO TO 20
         END IF
         LASTNI = IFILE
         FLAGS  = IBSET(0,INDIRF)
         IF(LDADEX) THEN
            ZOPT   = 'LD'
         ELSE
            ZOPT   = 'LQD'
            FLAGS  = IBSET(FLAGS,CLSQUI)
         END IF
         CALL MZBOOK(IROCON,LIOBNK,LIOBNK,0,'IODI',NLIOXX,NSIOXX,
     +               NDIOXX,IOIOXX,0)
         IQ(LIOBNK+JLUN)   = LUNAIN
         IQ(LIOBNK+JLREC)  = 8100
         CALL UCTOH(ZOPT,IQ(LIOBNK+JFCHOP),4,4)
         IQ(LIOBNK+JDCHOP) = 1
         IQ(LIOBNK+JACMOD) = 0
         IQ(LIOBNK+JFNTYP) = 1
         IQ(LIOBNK+JFLAGS) = FLAGS
         CALL UCTOH('OLD ',IQ(LIOBNK+JFSTAT),4,4)
         CALL UCTOH(CFNAME,IQ(LIOBNK+JFNAME),NBYTEW,80)
         CALL ROOFLX(LIOBNK)
         LEOFIN = .FALSE.
         IF(IQ(LIOBNK+JACTIV).EQ.0) THEN
            CHREP  = 'Could not open the desired file'
            CALL REPORT('RNXTNA',5,'E')
            IF(LASTNI.GT.0) THEN
               CALL RCLSIO(LIOBNK,.TRUE.)
               LASTNI = 0
            ENDIF
                                                               GO TO 889
         ENDIF
      END IF
*-- Position file to requested event
      CALL FZINXT(LUNAIN,IRECOR,IOFFSE)
      IER    = 0
                                                                GOTO 999
*
  100 IER    = 5
      WRITE(CHREP,1000) LUNIT,NEVDAD
      CALL REPORT('RNXTNA',3,'I')
*
  889 IER = 5
      CLOSE(UNIT=99)
      WRITE(CHREP,1010) JJRUN,JJEVE
      CALL REPORT('RNXTNA',6,'E')
*
  999 RETURN
 1000 FORMAT('Error reading on unit',I8, ' NEVDAD',I8)
 1010 FORMAT('Couldnt find: RUNNR, EVTNR',2I8, ' try next')
+SELF,IF=SGI.
1055  FORMAT('read_dad_dbs ',I8,3X,I8,'  > temp99.file ')
+SELF,IF=-SGI.
1055  FORMAT('remsh shift6 " read_dad_dbs ',I8,3x,I8,' " > temp99.file')
+SELF.
      END
+DECK,RSEDBS.
      SUBROUTINE RSEDBS(GNERIC,PUTER,IENTRY,FILNAM,LUSED,IDXFIL)
*.
*...      RSEDBS : Searches data type file for the generic name
*.                 passed, and returns the machine specific filename.
*.                 Only takes file which are 'directly' attached to
*.                 computer PUTER if PUTER is not blank.
*.                 IENTRY is the passed desired entry (for multiple
*.                 occurrences of the generic name).  LUSED is 0
*.                 if the entry doesn't exist, and negative if error.
*.                 the machine specific name is returned in FILNAM,
*.                 and the file index (for nanodst/dadlist) is
*.                 returned in IDXFIL.
*.
*.
*.
*.
*.    Input    :
*.    Output   :
*.    Called   :
*.    Calls    :
*.    Seq.     :
*.
*.    Author   : Alfred Lee
*.    Version  : 1.01
*.    Created  : 13-May-1991
*. LAST MOD :  30-Oct-95
*.
*.    Modification log:
*. 30-Oct-95 O.Schaile    Use CIO for UNIX
*.    18-May-1991   D.Lellouch   Customize to ROPE400
*.    30-Apr-1991   Alfred Lee:   convert GETDFI to this routine.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
+SEQ,ROUNIT.
+SEQ,RBITFUNC.
+SEQ,RCFDBS.
*-- Passed which occurrence for multiple matches of a generic desired.
      INTEGER IENTRY
*--   passed generic name and its length
      CHARACTER*(*) GNERIC
*--   passed name of 'puter for which data is to be read.
*--   only data 'directly' attached to this machine is read.
      CHARACTER*(*) PUTER
*--   returned filename; length of storage space for filename
      CHARACTER*(*) FILNAM
*--   returned length used for filename or error if negative
      INTEGER LUSED
*--   returned file index for DADlists or nanodst.
      INTEGER IDXFIL
*--   local copy upcased of PUTER and leading blanks removed
      CHARACTER*(LENDBS) LOCPU
      INTEGER LLOCPU
*--   entry read on previous call and its index in dbs.
      INTEGER IOLDEN, IDXOLD
      SAVE IOLDEN, IDXOLD
      CHARACTER*(LENDBS) OLDGEN
      SAVE OLDGEN
*--   current direct access record in dbs
      INTEGER IDX
*--   next generic name matching entry to be read.
      INTEGER NXTENT
*--   local storage of lines from dbs
      CHARACTER*(LENDBS) DBLINE
*--   local copy of generic for manipulation
      CHARACTER*(LENDBS) LOCGEN
      INTEGER LLOCGE
*--   iostatus returned by read statements
      INTEGER IOS
*--   temporary variable
      INTEGER NWRD
      INTEGER ITEMP
      CHARACTER*(LENDBS) SPACES
      INTEGER            LENOCC,I1,I2
*--   initialize local variables
      DATA IOLDEN, IDXOLD /0,0/
      DATA OLDGEN /' '/
*==== PROCEDURE STATEMENTS ====*
*--   clean up PUTER.
      LOCPU=SPACES(PUTER,1)
      LLOCPU=LENOCC(LOCPU)
*--   assume no entry
      LUSED = 0
      FILNAM = ' '
      IF (IENTRY .LT. 1) THEN
         LUSED = -1
                                                               GO TO 999
      END IF
*--   append //CERN/OPAL if not present and a generic (two slashes)
*--   if not a generic, return error.
      LOCGEN=SPACES(GNERIC,1)
      CALL CLTOU(LOCGEN)
      IF (LOCGEN(1:2).NE.'//') THEN
         LUSED = -2
                                                               GO TO 999
      ELSE IF (LOCGEN(1:12) .NE. '//CERN/OPAL/') THEN
         CALL RSBWRD(GNERIC,1,I1,I2)
         LOCGEN = '//CERN/OPAL/'//GNERIC(2+I1:I2)
      END IF
      LLOCGE=LENOCC(LOCGEN)
*--   initialize starting point for search
      IF (IENTRY.LT.IOLDEN.OR.OLDGEN.NE.LOCGEN) THEN
         IOLDEN = 0
         IDXOLD = 0
      ELSE
         IF (IENTRY.EQ.IOLDEN) THEN
            IOLDEN = IOLDEN - 1
            IDXOLD = IDXOLD - 1
         END IF
      END IF
      OLDGEN = LOCGEN
      IDX = IDXOLD
      NXTENT = IOLDEN + 1
*--   now loop over records looking for the next match
  100 IDX = IDX + 1
      DBLINE=' '
      CALL CFSEEK(LUNCAT,0,40,IDX-1,IOS)
      NWRD=40
      IF(IOS.EQ.0)CALL CFGET(LUNCAT,0,40,NWRD,DBLINE,IOS)
      IF (IOS .EQ. 0) THEN
*--   First check: make sure the record number is right
*--   If not leave (we probably got the end-of-file !!!!)
         CALL RSBWRD(DBLINE,6,I1,I2)
         IF (I2 .LE. 0) THEN
            IREC = 0
         ELSE
            READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS)IREC
            IF (IOS .NE. 0) THEN
               LUSED = -10
                                                               GO TO 999
            END IF
         END IF
         IF (IREC.NE.IDX) THEN
            LUSED = -3
                                                               GO TO 999
         END IF
      ELSE
*--   ran off the end of the dbs, return with no file.
         LUSED = 0
         FILNAM = ' '
                                                               GO TO 999
      END IF
      DBLINE=SPACES(DBLINE,1)
      CALL RSBWRD(DBLINE,1,I1,I2)
      IF (I2 .LE. 0) THEN
         LUSED = -4
                                                               GO TO 999
      END IF
*--   generic name match
      IF (INDEX(DBLINE(I1:I2),LOCGEN(1:LLOCGE)).NE.1)          GO TO 100
*--   get file and node name
      CALL RSBWRD(DBLINE,2,I1,I2)
      FILNAM=DBLINE(I1:I2)
      IF (I1 .LE. 0) THEN
         LUSED = -5
                                                               GO TO 999
      ELSE
         LUSED=I2+1-I1
      END IF
*--   get node name.
      ITEMP = INDEX(FILNAM(1:LUSED),'::')
      IF (ITEMP .LE. 0) THEN
         LUSED = -6
                                                               GO TO 999
      END IF
*--      check on computer name
      IF (LLOCPU.GT.0) THEN
         IF(ITEMP.GT.1) THEN
            IF(FILNAM(1:ITEMP-1).NE.LOCPU(1:LLOCPU)) GOTO 100
         END IF
         FILNAM=FILNAM(2+ITEMP:)
      END IF
*--      is this the entry we want?
      IF (IENTRY .NE. NXTENT) THEN
         NXTENT = NXTENT + 1
         GOTO 100
      END IF
*--   end of do-until loop 100.
*--   the filename and length are right, set old pointer
*--   for next call.
      IDXOLD = IDX
      IOLDEN = IENTRY
*--   store useful info from filedbs in RCFDBS common,
*--   and get stuff to return as arguments.
*--   get full generic name and file name
      CALL RSBWRD(DBLINE,1,I1,I2)
      CGEN=DBLINE(I1:I2)
      IF (ITEMP.GT.1) THEN
         CHOST = FILNAM(1:ITEMP-1)
      ELSE
         CHOST = ' '
      END IF
*--   now drop node name from file name.
      CFILE = FILNAM(2+ITEMP:LUSED)
      LUSED = LUSED - (ITEMP+1)
*--   get the date/time string
      CALL RSBWRD(DBLINE,3,I1,I2)
      CTODAY=DBLINE(I1:I2)
      ITEMP=I2-I1+3
      CALL RSBWRD(DBLINE,4,I1,I2)
      CTODAY(ITEMP:)=DBLINE(I1:I2)
*--   now construct file index (pointer)
      CALL RSBWRD(DBLINE,5,I1,I2)
      IF (I2 .LE. 0) THEN
         LUSED = -7
                                                               GO TO 999
      END IF
      READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS)ISEQ
      IF (IOS .NE. 0) THEN
         LUSED = -8
                                                               GO TO 999
      END IF
*--   we have the sequence number and the record number
*--   create the file index
      IDXFIL = IDX
      CALL MVBITS(ISEQ,0,IBSEQ,IDXFIL,JBSEQ)
      IUNIQF = IDXFIL
*--   get first and last event number (if present)
      CALL RSBWRD(DBLINE,7,I1,I2)
      IF (I2.LE. 0) THEN
         IFSTEV = 1
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS) IFSTEV
         IF (IOS .NE. 0) IFSTEV = 0
      END IF
      CALL RSBWRD(DBLINE,8,I1,I2)
      IF (I2.LE. 0) THEN
         ILSTEV = 0
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)',IOSTAT=IOS) ILSTEV
         IF (IOS .NE. 0) ILSTEV = 0
      END IF
*--   and the number of partitions
      CALL RSBWRD(DBLINE,9,I1,I2)
      IF (I2 .LE. 0) THEN
         IPARTI = 0
      ELSE
         READ(UNIT=DBLINE(I1:I2),FMT='(BN,I10)', IOSTAT=IOS) IPARTI
         IF (IOS .NE. 0) IPARTI=0
      END IF
*--   all done.
  999 RETURN
      END
+DECK,ROFGETS,IF=UNIX.
      SUBROUTINE ROFGET(IBUF,IOWAY)
*.
*...ROFGET   Reads events from CIO file (LINPTR) according
*.           to pointers from a dad list: IRECNR,IOFF,NWORDS
*.           and reestablishes physical block structure needed
*.           by ZEBRA exchange file format. This avoids reading
*.           of unused data.
*.
*. SEQUENCE: RCREP
*. COMMON  : QUEST
*. CALLS   : CFSEEK, CFGET, UCOPY, ROCGED
*. CALLED  : FZIN
*.
*. BANK L  :
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 27-Oct-94
*. LAST MOD: 21-Nov-95
*.
*. Modification Log.
*.  21-Nov-95   O.Schaile  protect against NGET>NWORDS
*.  17-Nov-95   O.Schaile  correct NFAST  computation (Online case)
*.  30-Oct-95   G.Duckeck  Implement ROCGED
*.  13-Jan-95   G.Duckeck  skip reading if new event requested
*.
*****************************************************************
      INTEGER IRECL
      PARAMETER (IRECL=8100)
      INTEGER IBUF(IRECL), IOWAY, I
      INTEGER       IRECNR,IOFF,NWORDS,LINPTR
*      SAVE          IRECNR,IOFF,NWORDS,LINPTR
      COMMON/DADPTR/IRECNR,IOFF,NWORDS,LINPTR
      INTEGER IQUEST(100)
      COMMON/QUEST/IQUEST
      LOGICAL NEWEVT
      CHARACTER*132 CHREP
      COMMON/RCREP/CHREP
      INTEGER NFAST,IP,NGET,NREST,IPFILE,NWOVFL,NWUNUS, ISTAT,
     +        LRECL,PHYREC(6)

      INTEGER ROSWAB
      EXTERNAL ROSWAB

      SAVE NFAST,NREST,PHYREC
      DATA NFAST,NREST/0,0/
CCC      DATA PHYREC/Z'0123CDEF',Z'80708070',Z'4321ABCD',Z'80618061',
CCC     +            IRECL,0/
*-- Z-format not f77 !!
      DATA PHYREC/  19123695, -2140110736, 1126280141, -2141093791,
     +            IRECL,0/
*--
*      WRITE(*,*)'ROFGET:',IRECNR,IOFF,NWORDS,LINPTR, NFLIMI
      NEWEVT=.FALSE.
*-- New event requested ?
      IF( IQUEST(3) .EQ. 1 ) NEWEVT = .TRUE.
      IOWAY=0
      IQUEST(1)=0
      IQUEST(2)=IRECL

* GD patch
      IF ( .NOT. NEWEVT ) THEN
*--     continued with fast blocks ?

         IF(NFAST.GT.0)THEN
            NFAST=NFAST-1
            IP=1
            NGET=IRECL
            IF(NFAST.EQ.0)THEN
               NREST=NWORDS-NGET
            ELSE
               NREST=0
            ENDIF

*     event continued in new physical record

         ELSE IF(NREST.GT.0)THEN
            IP=1
*        account for a physical record header
*         NGET=NREST+8    (now already in dadlist)
            NGET=NREST
            IF(NGET.GT.IRECL)THEN
               WRITE(CHREP,'(A)')'NGET.GT. 8100 !!'
               CALL REPORT('ROFGET',2,'E')
               NREST=0
               IQUEST(1)=2
               GOTO 10
            ENDIF
            NREST=-999
         ELSE
            WRITE(CHREP,'(A)')
     +           'FZIN expects more records, but nothing left'
            CALL REPORT('ROFGET',7,'E')
            NREST=0
            IQUEST(1)=2
            GOTO 10
         ENDIF

      ELSE


         IF(IRECNR.LE.0)THEN
            IQUEST(1)=3
            WRITE(CHREP,'(A)')'IRECNR=0 when new event expected!!'
            CALL REPORT('ROFGET',3,'E')
            GOTO 10
         ENDIF
*        issue a seek at start of a new event only
*        fake a word offset to CFSEEK (set NWREC=1)
* > GD
         if ( LINPTR .EQ. -99 ) THEN
            ISTAT = 0
         else
            IPFILE=(IRECNR-1)*IRECL+IOFF
            CALL CFSEEK(LINPTR,0,1,IPFILE,ISTAT)
         endif
* GD
         NEWEVT=.TRUE.
         IF(ISTAT.NE.0)THEN
            WRITE(CHREP,'(A)')'Error from CFSEEK ',ISTAT
            CALL REPORT('ROFGET',4,'E')
            IQUEST(1)=ISTAT
            GOTO 10
         ELSE

*           NWORDS contains the physical length of the event
*           i.e. Log Rec length and type, the Loc Rec itself.
*           If the event does not fit in the current Phys Rec
*           and more the 12 words would be unused at the end of
*           a fast block then there are extra 8 words accounting
*           for a Phys Rec header.

            IP=IOFF+1
            IRECNR=0
         ENDIF
*        how many words do we need to read
         IF(NWORDS.GT.IRECL-IOFF)THEN
            NGET= IRECL-IOFF
         ELSE
            NGET=NWORDS
         ENDIF

         IF(IP.LT.9)THEN
            WRITE(CHREP,'(A,I10)')
     +      'Start of data in physical record invalid',IP
            CALL REPORT('ROFGET',4,'E')
            IQUEST(1)=4
            GOTO 10
         ENDIF
      ENDIF

*     now get the data, make sure not too many
      NGET=MIN(NWORDS,NGET)
      LRECL=NGET
* > GD
      if ( LINPTR .EQ. -99 ) THEN
         ISTAT = 0
         CALL ROCGED(LRECL,NGET,IBUF(IP),ISTAT)
      else
         CALL CFGET(LINPTR,0,LRECL,NGET,IBUF(IP),ISTAT)
      endif
* GD
      IF(ISTAT.NE.0)THEN
         WRITE(CHREP,'(A,I10)')
     +      'Error from CFGET (data) ',ISTAT
            CALL REPORT('ROFGET',5,'E')
            IQUEST(1)=ISTAT
         GOTO 10
      ENDIF
      NWORDS=NWORDS-NGET
*     fake "physical record header" PRH if none was read
      IF(IP.GT.8)THEN
         IF(.NOT.NEWEVT)WRITE(*,*)'IP GT 8, but not NEW_EVENT'
         DO 111 I=1,6
           IBUF(I) = ROSWAB(PHYREC(I))
 111     CONTINUE
CCC         CALL UCOPY(PHYREC,IBUF(1),6)
         IBUF(7)=ROSWAB(IOFF)
*
*        calculate NFAST (this is the tricky part)
*
CCC         NWOVFL=IBUF(IP)+2-1+IOFF-IRECL
         NWOVFL=ROSWAB(IBUF(IP))+2+IOFF-IRECL
*        does it fit in current PHR
         IF(NWOVFL.LE.0)THEN
*           yes
            NFAST=0
         ELSE
*           fast blocks to follow
            NFAST=(NWOVFL-1)/IRECL+1
            NWUNUS = NFAST*IRECL - NWOVFL
*           for real ZEBRA its 12, for inline Rope 10
            IF     (NWUNUS .GE. 12) THEN
*              this should be ok for both cases
               NFAST=NFAST-1
            ELSE IF(NWUNUS .LT. 10) THEN
*              let NFAST as it is for both cases
            ELSE
*              compare dad list (it should know who wrote it) with LR
               IF(NWORDS+NGET-IBUF(IP).GE.10)NFAST=NFAST-1
*              look if we try to read more words then IBUF(IP) forsees
*               IF(NFAST*IRECL+NGET .GT. ROSWAB(IBUF(IP))+2)NFAST=NFAST-1
            ENDIF
         ENDIF
         IBUF(8)=ROSWAB(NFAST)
         IF(NFAST.GT.0)THEN
            NREST=0
         ELSE
            NREST=NWORDS
         ENDIF
         WRITE(CHREP,'(A,4I8)')'NWORDS(dad),IBUF(IP), IOFF, NFAST',
     +   NWORDS+NGET,ROSWAB(IBUF(IP)), IOFF, NFAST
         CALL REPORT('ROFGET',10,'I')
*         WRITE(*,*)'ZEBRA Vers.',IBUF(IP+3)
      ELSE
         IF(NEWEVT)WRITE(*,*)'IP le 8, but NEW_EVENT'
      ENDIF
      IF(NREST.EQ.-999)THEN
*     event was continued in a normal physical record
         IBUF(8)=ROSWAB(0)
         IF(NWORDS.GT.0)THEN
            WRITE(CHREP,'(A)')
     +      '2 physical record needed to complete event'
            CALL REPORT('ROFGET',6,'W')
            NREST=NWORDS
         ENDIF
      ENDIF
*     cover rest of PHR with a padding record
      IP=IP+NGET
      IF(IP.LE.IRECL)THEN
         IF(IP.LT.IRECL)THEN
*          LR length
           IBUF(IP)=ROSWAB(IRECL-IP)
*          LR type
           IBUF(IP+1)=ROSWAB(5)
         ELSE
*          special case only 1 words left
           IBUF(IP)=ROSWAB(0)
         ENDIF
      ENDIF
 10   CONTINUE
      RETURN
      END
+DECK,ROFPOSS,IF=UNIX.
      SUBROUTINE ROFPOS(IRIONW,LU)
      INTEGER IRIONW(3),LU
      INTEGER       IRECNR,IOFF,NWORDS,LINPTR
      COMMON/DADPTR/IRECNR,IOFF,NWORDS,LINPTR
      IRECNR=IRIONW(1)
      IOFF  =IRIONW(2)
      NWORDS=IRIONW(3)
      LINPTR=LU
      RETURN
      END
+DECK,ROFGETO,IF=-UNIX.
      SUBROUTINE ROFGET(IBUF,IOWAY)
*.
*.ROFGET    Dummy for non shift
*.  SEQUENCES :
*.  CALLS     :  REPORT
*.  CALLED    :  RNXTEV
*.
*.  AUTHORS   :  O.Schaile
*.  VERSION   :  1.00
*.  CREATED   :  1-Feb-94
*.  LAST MOD  :
*.
*.  Modification Log.
*.
*.
**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IBUF,IOWAY
+SEQ,RCREP.
      CHREP='CIO Dadlists are only supported on SHIFT'
      CALL REPORT('ROFGET',1,'C')
      END
+DECK,ROFPOSO,IF=-UNIX.
      SUBROUTINE ROFPOS(IRIONW,LU)
*.
*.ROFPOS    Dummy for non UNIX
*.  SEQUENCES :
*.  CALLS     :  REPORT
*.  CALLED    :  RNXTEV
*.
*.  AUTHORS   :  O.Schaile
*.  VERSION   :  1.00
*.  CREATED   :  1-Feb-94
*.  LAST MOD  :  1-Jul-96
*.
*.  Modification Log.
*.
*.  1-Jul-96 M.Schroder now activated for non-UNIX instaed of non-SHIFT
**********************************************************************
+SEQ,DECLARE.
*
      INTEGER IRIONW,LU
+SEQ,RCREP.
      CHREP='CIO Dadlists are only supported under UNIX'
      CALL REPORT('ROFPOS',1,'C')
      END
+PATCH,ROTYPE.
+DECK,RBABFD.
      SUBROUTINE RBABFD( FKBABA, FKBABM, FBBABA )
**********************************************************************
*.
*..RBABFD    it returns the Forward Detector lumi event flags :
*.                   FKBABA   for  Etotbar  method
*.                   FKBABM   for  Emainbar method
*.                   FBBABA   for  CUBED    method
*.
*.  SEQUENCES :  RCNTRL,ROCPAR,ROPAR,CRO,ODPAR
*.  CALLS     :
*.  CALLED    :
*.
*.  AUTHORS   :  G.M.Dallavalle
*.  VERSION   :  2.00
*.  CREATED   :  O3-Mar-90
*.  LAST MOD  :  15-Apr-91
*.
*.  Modification Log.
*.  15-Apr-91  C.Hawkes     Removed DUMMY argument (used to be EBEAM)
*.  27-Feb-91  C.Grandi     Reads lumi tags in new FD-DST structure
*.  05-Mar-90  C.Hawkes     Change phi cut to 10 deg for Etotbar
*.                          Add Etotmin cut of 18 GeV for Etotbar
*.  03-Mar-90  C.Hawkes     Renamed to RBABFD from BHBHFD for ROPE
*.
**********************************************************************
+SEQ,DECLARE.
*
+SEQ,RCNTRL.
+SEQ,ROCPAR,ROPAR,CRO.
+SEQ,ODPAR.
*
      LOGICAL FKBABA, FKBABM, FBBABA, FLBABA
*
      INTEGER  JBIT
      EXTERNAL JBIT
*
      INTEGER NCLS
      INTEGER NIMOV, NRMOV, JFDMSK
      INTEGER IFDAT(NIFDET)
      REAL    RFDAT(NRFDET)
*
      INTEGER IDO

*--   reset Bhabha event flags

      FKBABA= .FALSE.
      FKBABM= .FALSE.
      FBBABA= .FALSE.
      FLBABA= .FALSE.

*--   number of FD blocks for the current event

      CALL ODNBLK( 'FDET', NCLS )

*--   fetch FD blocks
*     ===============

      IF (NCLS.EQ.0)RETURN
      CALL ODFBLK('FDET',1,NIFDET,IFDAT,NIMOV,NRFDET,RFDAT,NRMOV)
      JFDMSK= IFDAT(JFSOUR)
      IF(JBIT(JFDMSK,16) .EQ. 1) FKBABM= .TRUE.
      IF(JBIT(JFDMSK,17) .EQ. 1) FKBABA= .TRUE.
      IF(JBIT(JFDMSK,18) .EQ. 1) FBBABA= .TRUE.
      IF(JBIT(JFDMSK,19) .EQ. 1) FLBABA= .TRUE.
*
      RETURN
      END
+DECK,RBABSW.
      SUBROUTINE RBABSW (LSWITA, LSWITR, LSWOTR, LSWITL, LSWOTL)
*.
*...RBABSW   Return a flag if this is a good SW bhabha
*.
*. OUTPUT    : LSWITA  two clusters match with average radius cut
*. OUTPUT    : LSWITR  two clusters match tight right cut, loose left cut
*. OUTPUT    : LSWOTR  ADC cluster / out-of-time trigger cluster match
*. OUTPUT    : LSWITL  two clusters match loose right cut, tight left cut
*. OUTPUT    : LSWOTL  ADC cluster / out-of-time trigger cluster match
*.
*. CALLS     : RSWCLS RSWCOR RSWBIT RSWMRG
*. CALLED    : ROEVTY
*.
*. AUTHOR    : D.Wagner
*. VERSION   : 1.00
*. CREATED   :  7-Oct-93
*. LAST MOD  : 31-May-94
*.
*. Modification Log.
*. 31-May-94   M.Foucher  add RSWMRG call, add flag in RSWBIT
*.  3-Feb-94   D.Wagner   Split into three separate subroutines
*.**********************************************************************
+SEQ,DECLARE.
      LOGICAL LSWITA, LSWITR, LSWOTR, LSWITL, LSWOTL
*
      CALL RSWCLS
      CALL RSWCOR
      CALL RSWMRG
      CALL RSWBIT (11111111,LSWITA, LSWITR, LSWOTR, LSWITL, LSWOTL)
*
      RETURN
      END
+DECK,RSWCLS.
      SUBROUTINE RSWCLS
*.
*...RSWCLS   Fills the ROSWVA common block with our clusters
*.
*. SEQUENCE  : CRO GCONST ODPAR ODSFUN1 RBITFUNC RCREP ROBANK ROPAR
*.             ROSWVA ROTPAR SWDATA SWGCPM SWSURV SWTCPM SWTRDT SWWBUF
*.             TRPMPS TRMAPS ODSFUN2
*. CALLS     : ODFBLK ODFUNS ODNBLK ODSWGC ODSWNG ODSWNT ODSWTC REPORT
*.             SORTZV SUBEAM SUSW SUFD SUCJ SUCV SUEB SUEBEA SUEE SUFD
*.             SUSW SWFROD SWNBXR SWUNPT SWZCOR
*. CALLED    : RBABSW <user>
*.
*. AUTHOR    : D.Wagner
*. VERSION   : 1.01
*. CREATED   : 03-Feb-94
*. LAST MOD  : 04-May-98
*.
*. Modification Log.
*.  4-May-98   C. Strom    set ebeam=1000 for ebeam undefined.
*. 20-Apr-98   D. Strom    update range of irope
*. 15-Apr-98   D. Strom    remove end do
*. 29-Oct-96   G. Martinez Adapt E limits to new Ranges for LEP2
*. 06-Sep-96   G. Martinez fix SHCL(2) bug
*. 30-Jul-96   G. Martinez Add trigger information for all layers, and some
*.                         related triggers
*. 03-Nov-95   G. Martinez fix EBEAM bug,add LLAY13
*. 12-Oct-95   G. Martinez Add ISWHBV
*. 11-Oct-95   G. Martinez Fix Bug on WT INFO when LODSL Does Not exists
*. 05-Oct-95   G. Martinez Restructure of WT Block, add IBCHLT (Rope Bunchlet #)
*. 20-Sep-95   G. Martinez Add wagon tagger Block
*. 31-Aug-95   S. Gascon-Shotkin Add IWAGHL from OD bank not
*.                  header due to filter bug
*. 28-Aug-95   S. Gascon-Shotkin Add bunchlet-related variables
*.             IWAGHx,ITGMOD, (from header)
*.             IBUNx,IBUDFx,XTRAx (from hidden DST bank)
*.                               Correct SHCTEMP(1) initialization bug
*.  6-Feb-95   D.Wagner   less output for MC if GNRL bank does not exist
*. 25-Apr-94   M.Foucher  Complete rewrite to fill new ROSWVA common
*.  3-Feb-94   D.Wagner   Created from first half of old RBABSW
*. O.Schaile   IF(JBIT(JMASK,20).NE.0) to keep f77 happy
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,CRO.
+SEQ,GCONST.
+SEQ,ODPAR.
+SEQ,ODSFUN1.
+SEQ,RBITFUNC.
+SEQ,RCREP.
+SEQ,ROBANK.
+SEQ,ROBUN.
+SEQ,ROPAR.
+SEQ,ROSWVA.
+SEQ,ROTPAR.
+SEQ,SWDATA.
+SEQ,SWGCPM.
+SEQ,SWSURV.
+SEQ,SWTCPM.
+SEQ,SWTRDT.
+SEQ,SWWBUF.
+SEQ,TRPMPS.
+SEQ,TRMAPS.
+SEQ,SWODPM.
*
*-- Local variables
*
      INTEGER NLOTMP(MAXCLS),NLATMP(MAXCLS),IROW,ITOWER
      INTEGER IPID,INDEX(MAXCLS)
      INTEGER ICVDST, ICJDST, IEBDST, IEEDST
      INTEGER ICVTST, ICJTST, IEBTST, IEETST,IOFF
      REAL BPOS(3), BWID(3), EBPOS(3),ZTEMP,DZ,RCTMP(MAXCLS)
      INTEGER IPOS,LODSL,NLINK,ISBTMP(MAXCLS)
      INTEGER I,J,NCL,IFDDAT(NIFDET),NIMOV,NRMOV
      REAL RFDDAT(NRFDET),ETEMP(MAXCLS),RTMP(MAXCLS),THITMP(MAXCLS)
      REAL PHITMP(MAXCLS),SHDTMP(MAXCLS),SHATMP(MAXCLS),RERTMP(MAXCLS)
      INTEGER NPDTMP(MAXCLS),PMXTMP(MAXPAD),ITPTMP(MAXCLS)
      INTEGER IBUTMP(MAXCLS),IBDTMP(MAXCLS)
      REAL CLUS(NGCSIZ),TCLUS(NTCSIZ),EPRTMP(MAXCLS),C5TTMP(MAXCLS)
      REAL C15TMP(MAXCLS),A5TTMP(MAXCLS),A15TMP(MAXCLS),PKOTMP(MAXCLS)
      REAL PKETMP(MAXCLS),QDOTMP(MAXCLS),QDETMP(MAXCLS),SIGN,AMAXCT
      REAL SHCTMP(MAXCLS),XTRTMP(MAXCLS)
      INTEGER IBN256
      INTEGER ISIDE,IBX
      PARAMETER (AMAXCT=6.)
*
      INTEGER TRBTST,TRPTST,SWNBXR
      EXTERNAL TRBTST,TRPTST,SWNBXR
      LOGICAL REVTYP
      EXTERNAL REVTYP
*
      INTEGER JBYT
      EXTERNAL JBYT
+SEQ,ODSFUN2.
*
*-- Initialize variables
*
      EVPEDR=1008.
      EVPEDL=1008.
      NFCLSR=0
      NFCLSL=0
      NCLSR=0
      NCLSL=0
      NPR=0
      NPL=0
      NTRKR=0
      NTRKL=0
      DO 10 I=1,MAXCLS
         ER(I)=0.
         EL(I)=0.
         RADR(I)=6.2
         RADL(I)=6.2
         PHIR(I)=0.
         PHIL(I)=0.
         THINTR(I)=0.
         THINTL(I)=0.
         SHDR(I)=0.
         SHDL(I)=0.
         SHAR(I)=0.
         SHAL(I)=0.
         RERRR(I)=0.
         RERRL(I)=0.
         NPADR(I)=0
         NPADL(I)=0
         ICTYPR(I)=0
         ICTYPL(I)=0
         NLOFFR(I)=0
         NLOFFL(I)=0
         RCENTR(I)=0.
         RCENTL(I)=0.
         E5TCR(I)=0.
         E5TCL(I)=0.
         E15CR(I)=0.
         E15CL(I)=0.
         E5TAR(I)=0.
         E5TAL(I)=0.
         E15AR(I)=0.
         E15AL(I)=0.
         EPKOR(I)=0.
         EPKOL(I)=0.
         EPKER(I)=0.
         EPKEL(I)=0.
         EQDOR(I)=0.
         EQDOL(I)=0.
         EQDER(I)=0.
         EQDEL(I)=0.
         NLAYR(I)=0
         NLAYL(I)=0
         ISHBR(I)=0
         ISHBL(I)=0
         SHCR(I)=0.
         SHCL(I)=0.
         IBUNR(I)=0
         IBUNL(I)=0
         IBUDFR(I)=0
         IBUDFL(I)=0
         XTRAR(I)=0.
         XTRAL(I)=0.
         DO 5 J=1,MLAY
            IPMAXR(J+(I-1)*MLAY)=-1
            IPMAXL(J+(I-1)*MLAY)=-1
    5    CONTINUE
         ESUMR=0.
         ESUML=0.
         ETR(I)=0.
         ETL(I)=0.
         THTR(I)=0.
         THTL(I)=0.
         PHTR(I)=0.
         PHTL(I)=0.
         EFR(I)=0.
         EFL(I)=0.
         THETFR(I)=0.04
         THETFL(I)=0.04
         PHIFR(I)=0.
         PHIFL(I)=0.
         EPREFR(I)=0.
         EPREFL(I)=0.
         INDEX(I)=0
   10 CONTINUE
      EMXR=0.
      EMXL=0.
      PHITR=0.
      PHITL=0.
      EMXAR=0.
      EMXAL=0.
      PHITAR=0.
      PHITAL=0.
      ITRATE=0
      SEGR(1)=0.
      SEGL(1)=0.
      SEG(1)=0.
      SEGA(1)=0.
      BKG2(1)=0.
      LHTRO = .FALSE.
      LHTRE = .FALSE.
      LHTLO = .FALSE.
      LHTLE = .FALSE.
      LFTR  = .FALSE.
      LFTL  = .FALSE.
      LATHR = .FALSE.
      LATHL = .FALSE.
      NPPRET = -2
      ETADCR = 0.
      ETADCL = 0.
      ETSRVR = 0.
      ETSRVL = 0.
      ESUMR = 0.
      ESUML = 0.
      NCJTR=0
      NEC=0
      PCJTR(1)=0.
      THCJTR(1)=0.
      PHCJTR(1)=0.
      EECAL(1)=0.
      THECAL(1)=0.
      PHECAL(1)=0.
       ISWHBV=0
       NWTCH=0
       INLB=0
       ITGLOG=0
       ISTRBR=0
       ISTRBL=0
       ITEXR=0
       ITEXL=0
       LTXROK=.FALSE.
       LTXLOK=.FALSE.
       LRNDM=.FALSE.
       LNOTEX=.FALSE.
       LCWROK=.FALSE.
       LCWLOK=.FALSE.
       LTGROK=.FALSE.
       LTGLOK=.FALSE.
       DO 15 I=1,MAXWTC
         ITAGRC(I)=0
         ITAGLC(I)=0
         ITAGRA(I)=0
         ITAGLA(I)=0
         LBDTRC(I)=.FALSE.
         LBDTLC(I)=.FALSE.
         LBDTRA(I)=.FALSE.
         LBDTLA(I)=.FALSE.
         ICHNRC(I)=0
         ICHNLC(I)=0
         ICHNRA(I)=0
         ICHNLA(I)=0
         EWTTRC(I)=0
         EWTTLC(I)=0
         EWTTRA(I)=0
         EWTTLA(I)=0
         EWTPRC(I)=0
         EWTPLC(I)=0
   15   CONTINUE
         NWTCRC=0
         NWTCLC=0
         NWTCRA=0
         NWTCLA=0
*
*-- detector status'
*
      CALL SUSW (IDSTAT, ITSTAT)
      CALL SUFD (IFDDST,I)
*
*-- Good multi-hadron detector and trigger status cuts, TN025
*
      CALL SUCV ( ICVDST, ICVTST )
      CALL SUCJ ( ICJDST, ICJTST )
      CALL SUEB ( IEBDST, IEBTST )
      CALL SUEE ( IEEDST, IEETST )
      LGMHST=.FALSE.
      IF ( ICJDST .GE. 3 .AND. ICJTST .GE. 0 .AND.
     +   ICVDST .GE. 3 .AND. ICVTST .GE. 0 .AND.
     +   IEBDST .GE. 2 .AND. IEBTST .GE. 2 .AND.
     +   IEEDST .GE. 3 .AND. IEETST .GE. 3) LGMHST=.TRUE.
*
*-- Trigger bits.  The bunch number is a number from 1 to 256
*-- which increments each bunch crossing.  It is not necessarliy correlated
*-- with the LEP bunch number
*-- Also now: Bunchlet-tagging information:Right and left strobe-
*   determined held bunchlets, and bunchlet-tagging mode.
*
      IRUN  = IRDRUN
      IEVT  = IRDEVT
      IBN256= JBYT(IUHEAD(IIBUN),1,8)
      IBUNCH= MOD(IBN256,8)
      IF(LFIBUS) THEN
        IBCHLT= MAX(MIN(IROBUN,7),0)
      ELSE
        IBCHLT= 0
      ENDIF
      IWAGHR= JBYT(IUHEAD(IIBUN),9,3)
      IWAGHL= JBYT(IUHEAD(IIBUN),12,3)
      ITGMOD= JBYT(IUHEAD(IIBUN),15,2)
      IROPE = MAX0(MIN0(IUHEAD(IIPVER),5000),1500)
      LSSGL = TRBTST(IUHEAD(IITRWD),IBSSGL) .EQ. 1
      LSSGR = TRBTST(IUHEAD(IITRWD),IBSSGR) .EQ. 1
      LSLOL = TRBTST(IUHEAD(IITRWD),IBSLOL) .EQ. 1
      LSLOR = TRBTST(IUHEAD(IITRWD),IBSLOR) .EQ. 1
      LSWH  = TRBTST(IUHEAD(IITRWD),IBSWH ) .EQ. 1
      LSSEG = TRBTST(IUHEAD(IITRWD),IBSSEG) .EQ. 1
      LSSGA = TRBTST(IUHEAD(IITRWD),IBSSGA) .EQ. 1
      LSSUM = TRBTST(IUHEAD(IITRWD),IBSSUM) .EQ. 1
      LSSMA = TRBTST(IUHEAD(IITRWD),IBSSMA) .EQ. 1
      LFDH  = TRBTST(IUHEAD(IITRWD),IBFDH ) .EQ. 1
      LFSUM = TRBTST(IUHEAD(IITRWD),IBFSUM) .EQ. 1
      LFSEG = TRBTST(IUHEAD(IITRWD),IBFSEG) .EQ. 1
      LLCAL = TRBTST(IUHEAD(IITRWD),IBLCAL) .EQ. 1
      LRCAL = TRBTST(IUHEAD(IITRWD),IBRCAL) .EQ. 1
      LEBTL = TRBTST(IUHEAD(IITRWD),IBEBTL) .EQ. 1
      LTBM1 = TRBTST(IUHEAD(IITRWD),IBTBM1) .EQ. 1
      LBXR  = TRBTST(IUHEAD(IITRWD),IBBXR ) .EQ. 1
      LBXRS = TRBTST(IUHEAD(IITRWD),IBBXRS) .EQ. 1
      LFGCLT= TRBTST(IUHEAD(IITRWD),IBGCLT) .EQ. 1
      LFGCRT= TRBTST(IUHEAD(IITRWD),IBGCRT) .EQ. 1
      LFSGA = TRBTST(IUHEAD(IITRWD),IBFSGA) .EQ. 1
      LEELLO= TRBTST(IUHEAD(IITRWD),IBEELL) .EQ. 1
      LEERLO= TRBTST(IUHEAD(IITRWD),IBEERL) .EQ. 1
      LFDSGL= TRPTST(IUHEAD(IIPRTA),KFDSGL) .EQ. 1
      LFDSGR= TRPTST(IUHEAD(IIPRTA),KFDSGR) .EQ. 1
      LEBWG = TRBTST(IUHEAD(IITRWD),IBEBWG) .EQ. 1
      LEML  = TRBTST(IUHEAD(IITRWD),IBEML) .EQ. 1
      LEMR  = TRBTST(IUHEAD(IITRWD),IBEMR) .EQ. 1
      LTM2  = TRBTST(IUHEAD(IITRWD),IBTM2) .EQ. 1
      DO 3145 I=0,15
         LLAY(I+1) = BTEST(IG(JGTRES),I)
 3145 CONTINUE
*
*-- Event type logicals
*
      LFYZ1 = REVTYP(IEFYZ1)
      LFYZS = REVTYP(IEFYZS)
      LFYZT = REVTYP(IEFYZT)
      LTKMH = REVTYP(IETKMH)
      LLUET = REVTYP(IELUET)
      LLUEM = REVTYP(IELUEM)
      LLUCU = REVTYP(IELUCU)
      LSWITA= REVTYP(IESWIA)
      LSWITR= REVTYP(IESWIR)
      LSWOTR= REVTYP(IESWOR)
      LSWITL= REVTYP(IESWIL)
      LSWOTL= REVTYP(IESWOL)
*
*-- Gold plated events set in the filter
*
      LSWBH = BTEST(IUHEAD(IIFITY),14)
      LGPMH = BTEST(IUHEAD(IIFITY),25)
      LFDBH = BTEST(IUHEAD(IIFITY),26)
      LGPEE = BTEST(IUHEAD(IIFITY),27)
      LGPMM = BTEST(IUHEAD(IIFITY),28)
      LGPTT = BTEST(IUHEAD(IIFITY),29)
      LGPLL = BTEST(IUHEAD(IIFITY),30)
*
*-- Event parameters
*
      CALL SUEBEA(EBEAM,SYSEB,I)
*
*--   If EBEAM is not defined set it to a large value so that
*--   no events are flagged as bhabhas
*
      IF(EBEAM.LE.0.0) THEN
        EBEAM = 1000.0
        CHREP = 'EBEAM .LE.0.0, SETTING EBEAM=1000'
        CALL REPORT ('RSWCLS', 11, 'W')
      END IF
*
      SYSEB = AMAX1(AMIN1(SYSEB,0.020),0.0)
      CTHR  = AMAX1(AMIN1(FLOAT(IUHEAD(IICTHR))/10000.,1.1),-1.1)
      CALL SUBEAM(BPOS,BWID,EBPOS,IPOS)
      XBEAM = AMAX1(AMIN1(BPOS(1),0.0),-0.1)
      YBEAM = AMAX1(AMIN1(BPOS(2),0.1), 0.0)
      ZBEAM = AMAX1(AMIN1(BPOS(3),1.0),-0.5)
      IDATE = MAX0(MIN0(IUHEAD(IIDATE),1000000),0)
      ITIME = MAX0(MIN0(IUHEAD(IITIME),240000),0)
      IBPOS = MAX0(MIN0(IPOS,2),-2)
*
*-- SW information, check first if ODSL bank exists, if not don't fill ntuple
*
      CALL SWFROD(3)
      IF(ESCALE.EQ.0.) ESCALE=1250.
      LGNRL = LQ(LOD-LLODGL)
      IF (LGNRL .LT. 1) THEN
         IF (IRDEXP .LT. 1000) THEN
           CHREP = 'GNRL bank doesn''t exist; can''t get ODSL bank'
           CALL REPORT ('RSWCLS', 8, 'E')
         END IF
         LODSL = 0
      ELSE
         NLINK = IQ(LGNRL-3)
         IF (NLINK .GE. LLODSL) THEN
            LODSL = LQ(LGNRL-LLODSL)
         ELSE
            LODSL = 0
         END IF
      END IF
      IF (LODSL .LT. 1) THEN
         CHREP ='ODSL bank doesn''t exist'
         CALL REPORT ('RSWCLS', 9, 'E')
      ELSE
         ISWHBV=JBYT(IQ(LODSL+KDSOUR), 17, 4)
         LHTRO = IDSCHF(1,1) .NE. 0
         LHTRE = IDSCHF(2,1) .NE. 0
         LHTLO = IDSCHF(1,2) .NE. 0
         LHTLE = IDSCHF(2,2) .NE. 0
         LFTR  = IDSCFL(1)   .NE. 0
         LFTL  = IDSCFL(2)   .NE. 0
         LATHR = BTEST(IATRES(1),1)
         LATHL = BTEST(IATRES(2),1)
         NPPRET = MAX0(MIN0(SWNBXR(1),127),-2)
         ETADCR = AMAX1(AMIN1(ENASWC(1),200.),-40.)
         ETADCL = AMAX1(AMIN1(ENASWC(2),200.),-40.)
         ETSRVR = AMAX1(AMIN1(SRVSWC(1),200.),-40.)
         ETSRVL = AMAX1(AMIN1(SRVSWC(2),200.),-40.)
         EVPEDR=AMAX1(AMIN1(SWEVPD(1),1040.),1008.)
         EVPEDL=AMAX1(AMIN1(SWEVPD(2),1040.),1008.)
         ESUMR=MAX(MIN(ETOTAL(1)/ESCALE,240.),0.)
         ESUML=MAX(MIN(ETOTAL(2)/ESCALE,240.),0.)
         IF((ISLUSH(1,1).GT.0).AND.(ISLUSH(4,1).LT.1000)) THEN
            ITRATE=1
            SEGR(1)=AMAX1(AMIN1((FLOAT(ISLUSH(1,1))/100.),10000.),0.)
            SEGL(1)=AMAX1(AMIN1((FLOAT(ISLUSH(2,1))/100.),10000.),0.)
            SEG(1)=AMAX1(AMIN1((FLOAT(ISLUSH(4,1))/100.),10.),0.)
            SEGA(1)=AMAX1(AMIN1((FLOAT(ISLUSH(3,1))/100.),20.),0.)
            BKG2(1)=AMAX1(AMIN1((FLOAT(ISLUSH(5,1))/100.),20.),0.)
         END IF
      END IF
      CALL SWUNPT
      ZTEMP=ZLAYER(8,1)
      CALL SWZCOR(1,ZTEMP,DZ)
      ZDET=ZTEMP
      ZTEMP=ZLAYER(8,2)
      CALL SWZCOR(2,ZTEMP,DZ)
      ZDET=(ZDET+ABS(ZTEMP))/2.
      ZDET=AMAX1(AMIN1(ZDET,248.0),244.0)
*
*-- Get CJ and ECAL information from DST
*
      CALL ODFUNS
      IF(NGNRL.GT.0) THEN
         IF((ICJDST.GE.3).AND.(ICJTST.GE.0)) THEN
            DO 20 I=1,NCTRK
               IF(RC(JCP,I).GT.PCJTR(1)) THEN
                  PCJTR(1)=RC(JCP,I)
                  SIGN=RC(JCQ,I)
                  THCJTR(1)=RC(JCTHEC,I)
                  PHCJTR(1)=RC(JCPHEC,I)
               END IF
   20       CONTINUE
            IF(PCJTR(1).GT.0.15) THEN
               NCJTR=1
               PCJTR(1)=MAX(MIN(PCJTR(1)*SIGN,60.0),-60.0)
               THCJTR(1)=MAX(MIN(THCJTR(1),3.142),0.)
               PHCJTR(1)=MAX(MIN(PHCJTR(1),6.28319),0.)
            ELSE
               NCJTR=0
               PCJTR(1)=0.
               THCJTR(1)=0.
               PHCJTR(1)=0.
            END IF
         END IF
         IF((IEBDST.GE.2).AND.(IEBTST.GE.2).AND.
     +      (IEEDST.GE.3).AND.(IEETST.GE.3)) THEN
            DO 30 I=1,NECAL
               IF((IAND(IE(JESOUR,I),MSKEB).GT.0).OR.
     +            (IAND(IE(JESOUR,I),MSKEE).GT.0)) THEN
                  IF(RE(JEE,I).GT.EECAL(1)) THEN
                     EECAL(1)=RE(JEE,I)
                     THECAL(1)=RE(JETHET,I)
                     PHECAL(1)=RE(JEPHI,I)
                  END IF
               END IF
   30       CONTINUE
            IF(EECAL(1).GT.0.3) THEN
               NEC=1
               EECAL(1)=MAX(MIN(EECAL(1),120.),0.)
               THECAL(1)=MAX(MIN(THECAL(1),3.142),0.)
               PHECAL(1)=MAX(MIN(PHECAL(1),6.28319),0.)
            ELSE
               NEC=0
               EECAL(1)=0.
               THECAL(1)=0.
               PHECAL(1)=0.
            END IF
         END IF
      END IF
*
*-- Get FD information from DST block
*
      CALL ODNBLK('FDET',NCL)
      DO 100 I=1,NCL
         CALL ODFBLK('FDET',I,MIFDET,IFDDAT,NIMOV,MRFDET,RFDDAT,
     +                                                       NRMOV)
         IF((NRMOV.GT.0).AND.(NIMOV.GT.0)) THEN
            IF(BTEST(IFDDAT(JFSOUR),4)) THEN
               IF(RFDDAT(JFTHET).LT.PI/2.) THEN
                  IF(NFCLSR.LT.7) THEN
                     NFCLSR=NFCLSR+1
                     EFR(NFCLSR)   =RFDDAT(JFE)
                     THETFR(NFCLSR)=RFDDAT(JFTHET)
                     PHIFR(NFCLSR) =RFDDAT(JFPHI)
                     EPREFR(NFCLSR)=RFDDAT(JFEPRE)
                  ELSE
                     CHREP='MORE THAN 7 FD CLUSTERS RIGHT SIDE'
                     CALL REPORT ('RSWCLS', 6, 'E')
                  END IF
               ELSE
                  IF(NFCLSL.LT.7) THEN
                     NFCLSL=NFCLSL+1
                     EFL(NFCLSL)   =RFDDAT(JFE)
                     THETFL(NFCLSL)=PI-RFDDAT(JFTHET)
                     PHIFL(NFCLSL) =RFDDAT(JFPHI)
                     EPREFL(NFCLSL)=RFDDAT(JFEPRE)
                  ELSE
                     CHREP='MORE THAN 7 FD CLUSTERS LEFT SIDE'
                     CALL REPORT ('RSWCLS', 7, 'E')
                  END IF
               END IF
            END IF
         END IF
  100 CONTINUE
*
*-- Now get SW information from DST block,inc. bunchlet tagging
*
      CALL ODSWNG(NCL)
      DO 200 I=1,NCL
         CALL ODSWGC(I,CLUS)
         IPID=NINT(CLUS(JGCPID))
*
*-- first find all non tracks
*
         IF(IPID.NE.KPIDTR) THEN
            IF(CLUS(JGCEND).LT.1.5) THEN
               IF(NCLSR.LT.7) THEN
                  NCLSR=NCLSR+1
                  NPR=NPR+MLAY
                  ER(NCLSR)=CLUS(JGCENR)
                  RADR(NCLSR)=CLUS(JGCRAD)
                  THINTR(NCLSR)=CLUS(JGCTRE)
                  PHIR(NCLSR)=CLUS(JGCPHI)
                  SHDR(NCLSR)=CLUS(JGCSHD)
                  SHAR(NCLSR)=CLUS(JGCSHA)
                  RERRR(NCLSR)=CLUS(JGCDRA)
                  NPADR(NCLSR)=NINT(CLUS(JGCNPD))
                  ICTYPR(NCLSR)=IPID
                  NLOFFR(NCLSR)=NINT(CLUS(JGCLOF))
                  RCENTR(NCLSR)=CLUS(JGCZTH)
                  E5TCR(NCLSR)=CLUS(JGC5TC)
                  E15CR(NCLSR)=CLUS(JGC15C)
                  E5TAR(NCLSR)=CLUS(JGC5TA)
                  E15AR(NCLSR)=CLUS(JGC15A)
                  EPKOR(NCLSR)=CLUS(JGCPKO)
                  EPKER(NCLSR)=CLUS(JGCPKE)
                  EQDOR(NCLSR)=CLUS(JGCPSO)
                  EQDER(NCLSR)=CLUS(JGCPSE)
                  NLAYR(NCLSR)=NINT(CLUS(JGCNLA))
                  ISHBR(NCLSR)=NINT(CLUS(JGCSHB))
                  SHCR(NCLSR)=CLUS(JGCSHC)
                  IBUNR(NCLSR)=NINT(CLUS(JGCBUN))
                  IBUDFR(NCLSR)=NINT(CLUS(JGCBXI))
                  XTRAR(NCLSR)=CLUS(JGCBXT)
                  DO 150 J=1,MLAY
                     IROW=NINT(CLUS(JGCRLA+J-1))
                     ITOWER=NINT(CLUS(JGCTOW))
                     IF((IROW.GE.1).AND.(IROW.LE.32).AND.
     +                  (ITOWER.GE.1).AND.(ITOWER.LE.32)) THEN
                        IF(PCOR(IROW,J,ITOWER,1).GT.AMAXCT) THEN
                           IPMAXR(J+(NCLSR-1)*MLAY)=IROW
                        END IF
                     ELSE
                        CHREP='TOWER AND ROW OUT OF RANGE'
                        CALL REPORT ('RSWCLS', 10, 'E')
                     END IF
  150             CONTINUE
               ELSE
                  CHREP='MORE THAN 7 SW CLUSTERS RIGHT SIDE'
                  CALL REPORT ('RSWCLS', 2, 'E')
               END IF
            ELSE
               IF(NCLSL.LT.7) THEN
                  NCLSL=NCLSL+1
                  NPL=NPL+MLAY
                  EL(NCLSL)=CLUS(JGCENR)
                  RADL(NCLSL)=CLUS(JGCRAD)
                  THINTL(NCLSL)=CLUS(JGCTRE)
                  PHIL(NCLSL)=CLUS(JGCPHI)
                  SHDL(NCLSL)=CLUS(JGCSHD)
                  SHAL(NCLSL)=CLUS(JGCSHA)
                  RERRL(NCLSL)=CLUS(JGCDRA)
                  NPADL(NCLSL)=NINT(CLUS(JGCNPD))
                  ICTYPL(NCLSL)=IPID
                  NLOFFL(NCLSL)=NINT(CLUS(JGCLOF))
                  RCENTL(NCLSL)=CLUS(JGCZTH)
                  E5TCL(NCLSL)=CLUS(JGC5TC)
                  E15CL(NCLSL)=CLUS(JGC15C)
                  E5TAL(NCLSL)=CLUS(JGC5TA)
                  E15AL(NCLSL)=CLUS(JGC15A)
                  EPKOL(NCLSL)=CLUS(JGCPKO)
                  EPKEL(NCLSL)=CLUS(JGCPKE)
                  EQDOL(NCLSL)=CLUS(JGCPSO)
                  EQDEL(NCLSL)=CLUS(JGCPSE)
                  NLAYL(NCLSL)=NINT(CLUS(JGCNLA))
                  ISHBL(NCLSL)=NINT(CLUS(JGCSHB))
                  SHCL(NCLSL)=CLUS(JGCSHC)
                  IBUNL(NCLSL)=NINT(CLUS(JGCBUN))
                  IBUDFL(NCLSL)=NINT(CLUS(JGCBXI))
                  XTRAL(NCLSL)=CLUS(JGCBXT)
                  DO 160 J=1,MLAY
                     IROW=NINT(CLUS(JGCRLA+J-1))
                     ITOWER=NINT(CLUS(JGCTOW))
                     IF((IROW.GE.1).AND.(IROW.LE.32).AND.
     +                  (ITOWER.GE.1).AND.(ITOWER.LE.32)) THEN
                        IF(PCOR(IROW,J,ITOWER,2).GT.AMAXCT) THEN
                           IPMAXL(J+(NCLSL-1)*MLAY)=IROW
                        END IF
                     ELSE
                        CHREP='TOWER AND ROW OUT OF RANGE'
                        CALL REPORT ('RSWCLS', 10, 'E')
                     END IF
  160             CONTINUE
               ELSE
                  CHREP='MORE THAN 7 SW CLUSTERS LEFT SIDE'
                  CALL REPORT ('RSWCLS', 3, 'E')
               END IF
            END IF
*
*-- Now store SW track information
*
         ELSE IF(IPID.EQ.KPIDTR) THEN
            IF(CLUS(JGCEND).LT.1.5) THEN
               IF(NTRKR.LT.7) THEN
                  NTRKR=NTRKR+1
                  ETR(NTRKR)=CLUS(JGCBET)/ESCALE
                  THTR(NTRKR)=CLUS(JGCTHE)
                  PHTR(NTRKR)=CLUS(JGCPHI)
               ELSE
                  CHREP='MORE THAN 7 TRACKS RIGHT SIDE'
                  CALL REPORT ('RSWCLS', 4, 'E')
               END IF
            ELSE
               IF(NTRKL.LT.7) THEN
                  NTRKL=NTRKL+1
                  ETL(NTRKL)=CLUS(JGCBET)/ESCALE
                  THTL(NTRKL)=CLUS(JGCTHE)
                  PHTL(NTRKL)=CLUS(JGCPHI)
               ELSE
                  CHREP='MORE THAN 7 TRACKS LEFT SIDE'
                  CALL REPORT ('RSWCLS', 5, 'E')
               END IF
            END IF
         END IF
  200 CONTINUE
*
*-- Sort SW clusters right side
*
      IF(NCLSR.EQ.0) THEN
         CONTINUE
      ELSE IF(NCLSR.EQ.1) THEN
         ER(1)=AMAX1(AMIN1(ER(1),500.0),0.0)
         RADR(1)=AMAX1(AMIN1(RADR(1),14.2),6.2)
         THINTR(1)=AMAX1(AMIN1(THINTR(1),0.1),-0.1)
         PHIR(1)=AMAX1(AMIN1(PHIR(1),6.28319),0.0)
         SHDR(1)=AMAX1(AMIN1(SHDR(1),1.0),0.0)
         SHAR(1)=AMAX1(AMIN1(SHAR(1),22.0),0.0)
         RERRR(1)=AMAX1(AMIN1(RERRR(1),1.0),0.0)
         NPADR(1)=MAX0(MIN0(NPADR(1),1023),0)
         ICTYPR(1)=MAX0(MIN0(ICTYPR(1),7),0)
         NLOFFR(1)=MAX(MIN(NLOFFR(1),3),-3)
         RCENTR(1)=MAX(MIN(RCENTR(1),22.0),0.0)
         E5TCR(1)=MAX(MIN(E5TCR(1),198.0),0.0)
         E15CR(1)=MAX(MIN(E15CR(1),99.),0.0)
         E5TAR(1)=MAX(MIN(E5TAR(1),198.0),0.0)
         E15AR(1)=MAX(MIN(E15AR(1),99.),0.0)
         EPKOR(1)=MAX(MIN(EPKOR(1),49.5),0.0)
         EPKER(1)=MAX(MIN(EPKER(1),49.5),0.0)
         EQDOR(1)=MAX(MIN(EQDOR(1),49.5),0.0)
         EQDER(1)=MAX(MIN(EQDER(1),49.5),0.0)
         NLAYR(1)=MAX(MIN(NLAYR(1),15),0)
         ISHBR(1)=MAX(MIN(ISHBR(1),31),0)
         SHCR(1)=MAX(MIN(SHCR(1),1.0),0.0)
         IBUNR(1)=MAX0(MIN0(IBUNR(1),6),0)
         IBUDFR(1)=MAX(MIN(IBUDFR(1),3),-4)
         XTRAR(1)=AMAX1(AMIN1(XTRAR(1),0.1),-0.1)
         DO 210 J=1,MLAY
            IPMAXR(J)=MAX0(MIN0(IPMAXR(J),33),-1)
  210    CONTINUE
      ELSE IF(NCLSR.EQ.2) THEN
         IF(ER(1).LT.ER(2)) THEN
            ETEMP(1)=ER(1)
            RTMP(1)=RADR(1)
            THITMP(1)=THINTR(1)
            PHITMP(1)=PHIR(1)
            SHDTMP(1)=SHDR(1)
            SHATMP(1)=SHAR(1)
            RERTMP(1)=RERRR(1)
            NPDTMP(1)=NPADR(1)
            ITPTMP(1)=ICTYPR(1)
            NLOTMP(1)=NLOFFR(1)
            RCTMP(1)=RCENTR(1)
            C5TTMP(1)=E5TCR(1)
            C15TMP(1)=E15CR(1)
            A5TTMP(1)=E5TAR(1)
            A15TMP(1)=E15AR(1)
            PKOTMP(1)=EPKOR(1)
            PKETMP(1)=EPKER(1)
            QDOTMP(1)=EQDOR(1)
            QDETMP(1)=EQDER(1)
            NLATMP(1)=NLAYR(1)
            ISBTMP(1)=ISHBR(1)
            SHCTMP(1)=SHCR(1)
            IBUTMP(1)=IBUNR(1)
            IBDTMP(1)=IBUDFR(1)
            XTRTMP(1)=XTRAR(1)
            DO 220 J=1,MLAY
               PMXTMP(J)=IPMAXR(J)
  220       CONTINUE
            ER(1)=AMAX1(AMIN1(ER(2),500.0),0.0)
            ER(2)=AMAX1(AMIN1(ETEMP(1),500.0),0.0)
            RADR(1)=AMAX1(AMIN1(RADR(2),14.2),6.2)
            RADR(2)=AMAX1(AMIN1(RTMP(1),14.2),6.2)
            THINTR(1)=AMAX1(AMIN1(THINTR(2),0.1),-0.1)
            THINTR(2)=AMAX1(AMIN1(THITMP(1),0.1),-0.1)
            PHIR(1)=AMAX1(AMIN1(PHIR(2),6.28319),0.0)
            PHIR(2)=AMAX1(AMIN1(PHITMP(1),6.28319),0.0)
            SHDR(1)=AMAX1(AMIN1(SHDR(2),1.0),0.0)
            SHDR(2)=AMAX1(AMIN1(SHDTMP(1),1.0),0.0)
            SHAR(1)=AMAX1(AMIN1(SHAR(2),22.0),0.0)
            SHAR(2)=AMAX1(AMIN1(SHATMP(1),22.0),0.0)
            RERRR(1)=AMAX1(AMIN1(RERRR(2),1.0),0.0)
            RERRR(2)=AMAX1(AMIN1(RERTMP(1),1.0),0.0)
            NPADR(1)=MAX0(MIN0(NPADR(2),1023),0)
            NPADR(2)=MAX0(MIN0(NPDTMP(1),1023),0)
            ICTYPR(1)=MAX0(MIN0(ICTYPR(2),7),0)
            ICTYPR(2)=MAX0(MIN0(ITPTMP(1),7),0)
            NLOFFR(1)=MAX(MIN(NLOFFR(2),3),-3)
            NLOFFR(2)=MAX(MIN(NLOTMP(1),3),-3)
            RCENTR(1)=MAX(MIN(RCENTR(2),22.0),0.0)
            RCENTR(2)=MAX(MIN(RCTMP(1),22.0),0.0)
            E5TCR(1)=MAX(MIN(E5TCR(2),198.0),0.0)
            E5TCR(2)=MAX(MIN(C5TTMP(1),198.0),0.0)
            E15CR(1)=MAX(MIN(E15CR(2),99.),0.0)
            E15CR(2)=MAX(MIN(C15TMP(1),99.),0.0)
            E5TAR(1)=MAX(MIN(E5TAR(2),198.0),0.0)
            E5TAR(2)=MAX(MIN(A5TTMP(1),198.0),0.0)
            E15AR(1)=MAX(MIN(E15AR(2),99.),0.0)
            E15AR(2)=MAX(MIN(A15TMP(1),99.),0.0)
            EPKOR(1)=MAX(MIN(EPKOR(2),49.5),0.0)
            EPKOR(2)=MAX(MIN(PKOTMP(1),49.5),0.0)
            EPKER(1)=MAX(MIN(EPKER(2),49.5),0.0)
            EPKER(2)=MAX(MIN(PKETMP(1),49.5),0.0)
            EQDOR(1)=MAX(MIN(EQDOR(2),49.5),0.0)
            EQDOR(2)=MAX(MIN(QDOTMP(1),49.5),0.0)
            EQDER(1)=MAX(MIN(EQDER(2),49.5),0.0)
            EQDER(2)=MAX(MIN(QDETMP(1),49.5),0.0)
            NLAYR(1)=MAX(MIN(NLAYR(2),15),0)
            NLAYR(2)=MAX(MIN(NLATMP(1),15),0)
            ISHBR(1)=MAX(MIN(ISHBR(2),31),0)
            ISHBR(2)=MAX(MIN(ISBTMP(1),31),0)
            SHCR(1)=MAX(MIN(SHCR(2),1.0),0.0)
            SHCR(2)=MAX(MIN(SHCTMP(1),1.0),0.0)
            IBUNR(1)=MAX0(MIN0(IBUNR(2),6),0)
            IBUNR(2)=MAX0(MIN0(IBUTMP(1),6),0)
            IBUDFR(1)=MAX(MIN(IBUDFR(2),3),-4)
            IBUDFR(2)=MAX(MIN(IBDTMP(1),3),-4)
            XTRAR(1)=AMAX1(AMIN1(XTRAR(2),0.1),-0.1)
            XTRAR(2)=AMAX1(AMIN1(XTRTMP(1),0.1),-0.1)
            DO 230 J=1,MLAY
               IPMAXR(J)=MAX0(MIN0(IPMAXR(MLAY+J),33),-1)
               IPMAXR(MLAY+J)=MAX0(MIN0(PMXTMP(J),33),-1)
  230       CONTINUE
         ELSE
            ER(1)=AMAX1(AMIN1(ER(1),500.0),0.0)
            ER(2)=AMAX1(AMIN1(ER(2),500.0),0.0)
            RADR(1)=AMAX1(AMIN1(RADR(1),14.2),6.2)
            RADR(2)=AMAX1(AMIN1(RADR(2),14.2),6.2)
            THINTR(1)=AMAX1(AMIN1(THINTR(1),0.1),-0.1)
            THINTR(2)=AMAX1(AMIN1(THINTR(2),0.1),-0.1)
            PHIR(1)=AMAX1(AMIN1(PHIR(1),6.28319),0.0)
            PHIR(2)=AMAX1(AMIN1(PHIR(2),6.28319),0.0)
            SHDR(1)=AMAX1(AMIN1(SHDR(1),1.0),0.0)
            SHDR(2)=AMAX1(AMIN1(SHDR(2),1.0),0.0)
            SHAR(1)=AMAX1(AMIN1(SHAR(1),22.0),0.0)
            SHAR(2)=AMAX1(AMIN1(SHAR(2),22.0),0.0)
            RERRR(1)=AMAX1(AMIN1(RERRR(1),1.0),0.0)
            RERRR(2)=AMAX1(AMIN1(RERRR(2),1.0),0.0)
            NPADR(1)=MAX0(MIN0(NPADR(1),1023),0)
            NPADR(2)=MAX0(MIN0(NPADR(2),1023),0)
            ICTYPR(1)=MAX0(MIN0(ICTYPR(1),7),0)
            ICTYPR(2)=MAX0(MIN0(ICTYPR(2),7),0)
            NLOFFR(1)=MAX(MIN(NLOFFR(1),3),-3)
            NLOFFR(2)=MAX(MIN(NLOFFR(2),3),-3)
            RCENTR(1)=MAX(MIN(RCENTR(1),22.0),0.0)
            RCENTR(2)=MAX(MIN(RCENTR(2),22.0),0.0)
            E5TCR(1)=MAX(MIN(E5TCR(1),198.0),0.0)
            E5TCR(2)=MAX(MIN(E5TCR(2),198.0),0.0)
            E15CR(1)=MAX(MIN(E15CR(1),99.0),0.0)
            E15CR(2)=MAX(MIN(E15CR(2),99.0),0.0)
            E5TAR(1)=MAX(MIN(E5TAR(1),198.0),0.0)
            E5TAR(2)=MAX(MIN(E5TAR(2),198.0),0.0)
            E15AR(1)=MAX(MIN(E15AR(1),99.0),0.0)
            E15AR(2)=MAX(MIN(E15AR(2),99.0),0.0)
            EPKOR(1)=MAX(MIN(EPKOR(1),49.5),0.0)
            EPKOR(2)=MAX(MIN(EPKOR(2),49.5),0.0)
            EPKER(1)=MAX(MIN(EPKER(1),49.5),0.0)
            EPKER(2)=MAX(MIN(EPKER(2),49.5),0.0)
            EQDOR(1)=MAX(MIN(EQDOR(1),49.5),0.0)
            EQDOR(2)=MAX(MIN(EQDOR(2),49.5),0.0)
            EQDER(1)=MAX(MIN(EQDER(1),49.5),0.0)
            EQDER(2)=MAX(MIN(EQDER(2),49.5),0.0)
            NLAYR(1)=MAX(MIN(NLAYR(1),15),0)
            NLAYR(2)=MAX(MIN(NLAYR(2),15),0)
            ISHBR(1)=MAX(MIN(ISHBR(1),31),0)
            ISHBR(2)=MAX(MIN(ISHBR(2),31),0)
            SHCR(1)=MAX(MIN(SHCR(1),1.0),0.0)
            SHCR(2)=MAX(MIN(SHCR(2),1.0),0.0)
            IBUNR(1)=MAX0(MIN0(IBUNR(1),6),0)
            IBUNR(2)=MAX0(MIN0(IBUNR(2),6),0)
            IBUDFR(1)=MAX(MIN(IBUDFR(1),3),-4)
            IBUDFR(2)=MAX(MIN(IBUDFR(2),3),-4)
            XTRAR(1)=AMAX1(AMIN1(XTRAR(1),0.1),-0.1)
            XTRAR(2)=AMAX1(AMIN1(XTRAR(2),0.1),-0.1)
            DO 240 J=1,2*MLAY
               IPMAXR(J)=MAX0(MIN0(IPMAXR(J),33),-1)
  240       CONTINUE
         END IF
      ELSE
         CALL SORTZV(ER,INDEX,NCLSR,1,1,0)
         DO 300 I=1,NCLSR
            ETEMP(I)=ER(I)
            RTMP(I)=RADR(I)
            THITMP(I)=THINTR(I)
            PHITMP(I)=PHIR(I)
            SHDTMP(I)=SHDR(I)
            SHATMP(I)=SHAR(I)
            RERTMP(I)=RERRR(I)
            NPDTMP(I)=NPADR(I)
            ITPTMP(I)=ICTYPR(I)
            NLOTMP(I)=NLOFFR(I)
            RCTMP(I)=RCENTR(I)
            C5TTMP(I)=E5TCR(I)
            C15TMP(I)=E15CR(I)
            A5TTMP(I)=E5TAR(I)
            A15TMP(I)=E15AR(I)
            PKOTMP(I)=EPKOR(I)
            PKETMP(I)=EPKER(I)
            QDOTMP(I)=EQDOR(I)
            QDETMP(I)=EQDER(I)
            NLATMP(I)=NLAYR(I)
            ISBTMP(I)=ISHBR(I)
            SHCTMP(I)=SHCR(I)
            IBUTMP(I)=IBUNR(I)
            IBDTMP(I)=IBUDFR(I)
            XTRTMP(I)=XTRAR(I)
            DO 290 J=1,MLAY
               PMXTMP(J+(I-1)*MLAY)=IPMAXR(J+(I-1)*MLAY)
  290       CONTINUE
  300    CONTINUE
         DO 400 I=1,NCLSR
            ER(I)=AMAX1(AMIN1(ETEMP(INDEX(I)),500.0),0.0)
            RADR(I)=AMAX1(AMIN1(RTMP(INDEX(I)),14.2),6.2)
            THINTR(I)=AMAX1(AMIN1(THITMP(INDEX(I)),0.1),-0.1)
            PHIR(I)=AMAX1(AMIN1(PHITMP(INDEX(I)),6.28319),0.0)
            SHDR(I)=AMAX1(AMIN1(SHDTMP(INDEX(I)),1.0),0.0)
            SHAR(I)=AMAX1(AMIN1(SHATMP(INDEX(I)),22.0),0.0)
            RERRR(I)=AMAX1(AMIN1(RERTMP(INDEX(I)),1.0),0.0)
            NPADR(I)=MAX0(MIN0(NPDTMP(INDEX(I)),1023),0)
            ICTYPR(I)=MAX0(MIN0(ITPTMP(INDEX(I)),7),0)
            NLOFFR(I)=MAX(MIN(NLOTMP(INDEX(I)),3),-3)
            RCENTR(I)=MAX(MIN(RCTMP(INDEX(I)),22.0),0.0)
            E5TCR(I)=MAX(MIN(C5TTMP(INDEX(I)),198.0),0.0)
            E15CR(I)=MAX(MIN(C15TMP(INDEX(I)),99.0),0.0)
            E5TAR(I)=MAX(MIN(A5TTMP(INDEX(I)),198.0),0.0)
            E15AR(I)=MAX(MIN(A15TMP(INDEX(I)),99.0),0.0)
            EPKOR(I)=MAX(MIN(PKOTMP(INDEX(I)),49.5),0.0)
            EPKER(I)=MAX(MIN(PKETMP(INDEX(I)),49.5),0.0)
            EQDOR(I)=MAX(MIN(QDOTMP(INDEX(I)),49.5),0.0)
            EQDER(I)=MAX(MIN(QDETMP(INDEX(I)),49.5),0.0)
            NLAYR(I)=MAX(MIN(NLATMP(INDEX(I)),15),0)
            ISHBR(I)=MAX(MIN(ISBTMP(INDEX(I)),31),0)
            SHCR(I)=MAX(MIN(SHCTMP(INDEX(I)),1.0),0.0)
            IBUNR(I)=MAX0(MIN0(IBUTMP(INDEX(I)),6),0)
            IBUDFR(I)=MAX(MIN(IBDTMP(INDEX(I)),3),-4)
            XTRAR(I)=AMAX1(AMIN1(XTRTMP(INDEX(I)),0.1),-0.1)
            DO 390 J=1,MLAY
               IPMAXR(J+(I-1)*MLAY)=
     +                MAX0(MIN0(PMXTMP(J+(INDEX(I)-1)*MLAY),33),-1)
  390       CONTINUE
  400    CONTINUE
      END IF
*
*-- Sort SW clusters left side
*
      IF(NCLSL.EQ.0) THEN
         CONTINUE
      ELSE IF(NCLSL.EQ.1) THEN
         EL(1)=AMAX1(AMIN1(EL(1),500.0),0.0)
         RADL(1)=AMAX1(AMIN1(RADL(1),14.2),6.2)
         THINTL(1)=AMAX1(AMIN1(THINTL(1),0.1),-0.1)
         PHIL(1)=AMAX1(AMIN1(PHIL(1),6.28319),0.0)
         SHDL(1)=AMAX1(AMIN1(SHDL(1),1.0),0.0)
         SHAL(1)=AMAX1(AMIN1(SHAL(1),22.0),0.0)
         RERRL(1)=AMAX1(AMIN1(RERRL(1),1.0),0.0)
         NPADL(1)=MAX0(MIN0(NPADL(1),1023),0)
         ICTYPL(1)=MAX0(MIN0(ICTYPL(1),7),0)
         NLOFFL(1)=MAX(MIN(NLOFFL(1),3),-3)
         RCENTL(1)=MAX(MIN(RCENTL(1),22.0),0.0)
         E5TCL(1)=MAX(MIN(E5TCL(1),198.0),0.0)
         E15CL(1)=MAX(MIN(E15CL(1),99.0),0.0)
         E5TAL(1)=MAX(MIN(E5TAL(1),198.0),0.0)
         E15AL(1)=MAX(MIN(E15AL(1),99.0),0.0)
         EPKOL(1)=MAX(MIN(EPKOL(1),49.5),0.0)
         EPKEL(1)=MAX(MIN(EPKEL(1),49.5),0.0)
         EQDOL(1)=MAX(MIN(EQDOL(1),49.5),0.0)
         EQDEL(1)=MAX(MIN(EQDEL(1),49.5),0.0)
         NLAYL(1)=MAX(MIN(NLAYL(1),15),0)
         ISHBL(1)=MAX(MIN(ISHBL(1),31),0)
         SHCL(1)=MAX(MIN(SHCL(1),1.0),0.0)
         IBUNL(1)=MAX0(MIN0(IBUNL(1),6),0)
         XTRAL(1)=AMAX1(AMIN1(XTRAL(1),0.1),-0.1)
         DO 410 J=1,MLAY
            IPMAXL(J)=MAX0(MIN0(IPMAXL(J),33),-1)
  410    CONTINUE
      ELSE IF(NCLSL.EQ.2) THEN
         IF(EL(1).LT.EL(2)) THEN
            ETEMP(1)=EL(1)
            RTMP(1)=RADL(1)
            THITMP(1)=THINTL(1)
            PHITMP(1)=PHIL(1)
            SHDTMP(1)=SHDL(1)
            SHATMP(1)=SHAL(1)
            RERTMP(1)=RERRL(1)
            NPDTMP(1)=NPADL(1)
            ITPTMP(1)=ICTYPL(1)
            NLOTMP(1)=NLOFFL(1)
            RCTMP(1)=RCENTL(1)
            C5TTMP(1)=E5TCL(1)
            C15TMP(1)=E15CL(1)
            A5TTMP(1)=E5TAL(1)
            A15TMP(1)=E15AL(1)
            PKOTMP(1)=EPKOL(1)
            PKETMP(1)=EPKEL(1)
            QDOTMP(1)=EQDOL(1)
            QDETMP(1)=EQDEL(1)
            NLATMP(1)=NLAYL(1)
            ISBTMP(1)=ISHBL(1)
            SHCTMP(1)=SHCL(1)
            IBUTMP(1)=IBUNL(1)
            IBDTMP(1)=IBUDFL(1)
            XTRTMP(1)=XTRAL(1)
            DO 420 J=1,MLAY
               PMXTMP(J)=IPMAXL(J)
  420       CONTINUE
            EL(1)=AMAX1(AMIN1(EL(2),500.0),0.0)
            EL(2)=AMAX1(AMIN1(ETEMP(1),500.0),0.0)
            RADL(1)=AMAX1(AMIN1(RADL(2),14.2),6.2)
            RADL(2)=AMAX1(AMIN1(RTMP(1),14.2),6.2)
            THINTL(1)=AMAX1(AMIN1(THINTL(2),0.1),-0.1)
            THINTL(2)=AMAX1(AMIN1(THITMP(1),0.1),-0.1)
            PHIL(1)=AMAX1(AMIN1(PHIL(2),6.28319),0.0)
            PHIL(2)=AMAX1(AMIN1(PHITMP(1),6.28319),0.0)
            SHDL(1)=AMAX1(AMIN1(SHDL(2),1.0),0.0)
            SHDL(2)=AMAX1(AMIN1(SHDTMP(1),1.0),0.0)
            SHAL(1)=AMAX1(AMIN1(SHAL(2),22.0),0.0)
            SHAL(2)=AMAX1(AMIN1(SHATMP(1),22.0),0.0)
            RERRL(1)=AMAX1(AMIN1(RERRL(2),1.0),0.0)
            RERRL(2)=AMAX1(AMIN1(RERRL(1),1.0),0.0)
            NPADL(1)=MAX0(MIN0(NPADL(2),1023),0)
            NPADL(2)=MAX0(MIN0(NPDTMP(1),1023),0)
            ICTYPL(1)=MAX0(MIN0(ICTYPL(2),7),0)
            ICTYPL(2)=MAX0(MIN0(ITPTMP(1),7),0)
            NLOFFL(1)=MAX(MIN(NLOFFL(2),3),-3)
            NLOFFL(2)=MAX(MIN(NLOTMP(1),3),-3)
            RCENTL(1)=MAX(MIN(RCENTL(2),22.0),0.0)
            RCENTL(2)=MAX(MIN(RCTMP(1),22.0),0.0)
            E5TCL(1)=MAX(MIN(E5TCL(2),198.0),0.0)
            E5TCL(2)=MAX(MIN(C5TTMP(1),198.0),0.0)
            E15CL(1)=MAX(MIN(E15CL(2),99.0),0.0)
            E15CL(2)=MAX(MIN(C15TMP(1),99.0),0.0)
            E5TAL(1)=MAX(MIN(E5TAL(2),198.0),0.0)
            E5TAL(2)=MAX(MIN(A5TTMP(1),198.0),0.0)
            E15AL(1)=MAX(MIN(E15AL(2),99.0),0.0)
            E15AL(2)=MAX(MIN(A15TMP(1),99.0),0.0)
            EPKOL(1)=MAX(MIN(EPKOL(2),49.5),0.0)
            EPKOL(2)=MAX(MIN(PKOTMP(1),49.5),0.0)
            EPKEL(1)=MAX(MIN(EPKEL(2),49.5),0.0)
            EPKEL(2)=MAX(MIN(PKETMP(1),49.5),0.0)
            EQDOL(1)=MAX(MIN(EQDOL(2),49.5),0.0)
            EQDOL(2)=MAX(MIN(QDOTMP(1),49.5),0.0)
            EQDEL(1)=MAX(MIN(EQDEL(2),49.5),0.0)
            EQDEL(2)=MAX(MIN(QDETMP(1),49.5),0.0)
            NLAYL(1)=MAX(MIN(NLAYL(2),15),0)
            NLAYL(2)=MAX(MIN(NLATMP(1),15),0)
            ISHBL(1)=MAX(MIN(ISHBL(2),31),0)
            ISHBL(2)=MAX(MIN(ISBTMP(1),31),0)
            SHCL(1)=MAX(MIN(SHCL(2),1.0),0.0)
            SHCL(2)=MAX(MIN(SHCTMP(1),1.0),0.0)
            IBUNL(1)=MAX0(MIN0(IBUNL(2),6),0)
            IBUNL(2)=MAX0(MIN0(IBUTMP(1),6),0)
            IBUDFL(1)=MAX(MIN(IBUDFL(2),3),-4)
            IBUDFL(2)=MAX(MIN(IBDTMP(1),3),-4)
            XTRAL(1)=AMAX1(AMIN1(XTRAL(2),0.1),-0.1)
            XTRAL(2)=AMAX1(AMIN1(XTRTMP(1),0.1),-0.1)
            DO 430 J=1,MLAY
               IPMAXL(J)=MAX0(MIN0(IPMAXL(J+MLAY),33),-1)
               IPMAXL(J+MLAY)=MAX0(MIN0(PMXTMP(J),33),-1)
  430       CONTINUE
         ELSE
            EL(1)=AMAX1(AMIN1(EL(1),500.0),0.0)
            EL(2)=AMAX1(AMIN1(EL(2),500.0),0.0)
            RADL(1)=AMAX1(AMIN1(RADL(1),14.2),6.2)
            RADL(2)=AMAX1(AMIN1(RADL(2),14.2),6.2)
            THINTL(1)=AMAX1(AMIN1(THINTL(1),0.1),-0.1)
            THINTL(2)=AMAX1(AMIN1(THINTL(2),0.1),-0.1)
            PHIL(1)=AMAX1(AMIN1(PHIL(1),6.28319),0.0)
            PHIL(2)=AMAX1(AMIN1(PHIL(2),6.28319),0.0)
            SHDL(1)=AMAX1(AMIN1(SHDL(1),1.0),0.0)
            SHDL(2)=AMAX1(AMIN1(SHDL(2),1.0),0.0)
            SHAL(1)=AMAX1(AMIN1(SHAL(1),22.0),0.0)
            SHAL(2)=AMAX1(AMIN1(SHAL(2),22.0),0.0)
            RERRL(1)=AMAX1(AMIN1(RERRL(1),1.0),0.0)
            RERRL(2)=AMAX1(AMIN1(RERRL(2),1.0),0.0)
            NPADL(1)=MAX0(MIN0(NPADL(1),1023),0)
            NPADL(2)=MAX0(MIN0(NPADL(2),1023),0)
            ICTYPL(1)=MAX0(MIN0(ICTYPL(1),7),0)
            ICTYPL(2)=MAX0(MIN0(ICTYPL(2),7),0)
            NLOFFL(1)=MAX(MIN(NLOFFL(1),3),-3)
            NLOFFL(2)=MAX(MIN(NLOFFL(2),3),-3)
            RCENTL(1)=MAX(MIN(RCENTL(1),22.0),0.0)
            RCENTL(2)=MAX(MIN(RCENTL(2),22.0),0.0)
            E5TCL(1)=MAX(MIN(E5TCL(1),198.0),0.0)
            E5TCL(2)=MAX(MIN(E5TCL(2),198.0),0.0)
            E15CL(1)=MAX(MIN(E15CL(1),99.0),0.0)
            E15CL(2)=MAX(MIN(E15CL(2),99.0),0.0)
            E5TAL(1)=MAX(MIN(E5TAL(1),198.0),0.0)
            E5TAL(2)=MAX(MIN(E5TAL(2),198.0),0.0)
            E15AL(1)=MAX(MIN(E15AL(1),99.0),0.0)
            E15AL(2)=MAX(MIN(E15AL(2),99.0),0.0)
            EPKOL(1)=MAX(MIN(EPKOL(1),49.5),0.0)
            EPKOL(2)=MAX(MIN(EPKOL(2),49.5),0.0)
            EPKEL(1)=MAX(MIN(EPKEL(1),49.5),0.0)
            EPKEL(2)=MAX(MIN(EPKEL(2),49.5),0.0)
            EQDOL(1)=MAX(MIN(EQDOL(1),49.5),0.0)
            EQDOL(2)=MAX(MIN(EQDOL(2),49.5),0.0)
            EQDEL(1)=MAX(MIN(EQDEL(1),49.5),0.0)
            EQDEL(2)=MAX(MIN(EQDEL(2),49.5),0.0)
            NLAYL(1)=MAX(MIN(NLAYL(1),15),0)
            NLAYL(2)=MAX(MIN(NLAYL(2),15),0)
            ISHBL(1)=MAX(MIN(ISHBL(1),31),0)
            ISHBL(2)=MAX(MIN(ISHBL(2),31),0)
            SHCL(1)=MAX(MIN(SHCL(1),1.0),0.0)
            SHCL(2)=MAX(MIN(SHCL(2),1.0),0.0)
            IBUNL(1)=MAX0(MIN0(IBUNL(1),6),0)
            IBUNL(2)=MAX0(MIN0(IBUNL(2),6),0)
            IBUDFL(1)=MAX(MIN(IBUDFL(1),3),-4)
            IBUDFL(2)=MAX(MIN(IBUDFL(2),3),-4)
            XTRAL(1)=AMAX1(AMIN1(XTRAL(1),0.1),-0.1)
            XTRAL(2)=AMAX1(AMIN1(XTRAL(2),0.1),-0.1)
            DO 440 J=1,2*MLAY
               IPMAXL(J)=MAX0(MIN0(IPMAXL(J),33),-1)
  440       CONTINUE
         END IF
      ELSE
         CALL SORTZV(EL,INDEX,NCLSL,1,1,0)
         DO 500 I=1,NCLSL
            ETEMP(I)=EL(I)
            RTMP(I)=RADL(I)
            THITMP(I)=THINTL(I)
            PHITMP(I)=PHIL(I)
            SHDTMP(I)=SHDL(I)
            SHATMP(I)=SHAL(I)
            RERTMP(I)=RERRL(I)
            NPDTMP(I)=NPADL(I)
            ITPTMP(I)=ICTYPL(I)
            NLOTMP(I)=NLOFFL(I)
            RCTMP(I)=RCENTL(I)
            C5TTMP(I)=E5TCL(I)
            C15TMP(I)=E15CL(I)
            A5TTMP(I)=E5TAL(I)
            A15TMP(I)=E15AL(I)
            PKOTMP(I)=EPKOL(I)
            PKETMP(I)=EPKEL(I)
            QDOTMP(I)=EQDOL(I)
            QDETMP(I)=EQDEL(I)
            NLATMP(I)=NLAYL(I)
            ISBTMP(I)=ISHBL(I)
            SHCTMP(I)=SHCL(I)
            IBUTMP(I)=IBUNL(I)
            IBDTMP(I)=IBUDFL(I)
            XTRTMP(I)=XTRAL(I)
            DO 490 J=1,MLAY
               PMXTMP(J+(I-1)*MLAY)=IPMAXL(J+(I-1)*MLAY)
  490       CONTINUE
  500    CONTINUE
         DO 600 I=1,NCLSL
            EL(I)=AMAX1(AMIN1(ETEMP(INDEX(I)),500.0),0.0)
            RADL(I)=AMAX1(AMIN1(RTMP(INDEX(I)),14.2),6.2)
            THINTL(I)=AMAX1(AMIN1(THITMP(INDEX(I)),0.1),-0.1)
            PHIL(I)=AMAX1(AMIN1(PHITMP(INDEX(I)),6.28319),0.0)
            SHDL(I)=AMAX1(AMIN1(SHDTMP(INDEX(I)),1.0),0.0)
            SHAL(I)=AMAX1(AMIN1(SHATMP(INDEX(I)),22.0),0.0)
            RERRL(I)=AMAX1(AMIN1(RERTMP(INDEX(I)),1.0),0.0)
            NPADL(I)=MAX0(MIN0(NPDTMP(INDEX(I)),1023),0)
            ICTYPL(I)=MAX0(MIN0(ITPTMP(INDEX(I)),7),0)
            NLOFFL(I)=MAX(MIN(NLOTMP(INDEX(I)),3),-3)
            RCENTL(I)=MAX(MIN(RCTMP(INDEX(I)),22.0),0.0)
            E5TCL(I)=MAX(MIN(C5TTMP(INDEX(I)),198.0),0.0)
            E15CL(I)=MAX(MIN(C15TMP(INDEX(I)),99.0),0.0)
            E5TAL(I)=MAX(MIN(A5TTMP(INDEX(I)),198.0),0.0)
            E15AL(I)=MAX(MIN(A15TMP(INDEX(I)),99.0),0.0)
            EPKOL(I)=MAX(MIN(PKOTMP(INDEX(I)),49.5),0.0)
            EPKEL(I)=MAX(MIN(PKETMP(INDEX(I)),49.5),0.0)
            EQDOL(I)=MAX(MIN(QDOTMP(INDEX(I)),49.5),0.0)
            EQDEL(I)=MAX(MIN(QDETMP(INDEX(I)),49.5),0.0)
            NLAYL(I)=MAX(MIN(NLATMP(INDEX(I)),15),0)
            ISHBL(I)=MAX(MIN(ISBTMP(INDEX(I)),31),0)
            SHCL(I)=MAX(MIN(SHCTMP(INDEX(I)),1.0),0.0)
            IBUNL(I)=MAX0(MIN0(IBUTMP(INDEX(I)),6),0)
            IBUDFL(I)=MAX(MIN(IBDTMP(INDEX(I)),3),-4)
            XTRAL(I)=AMAX1(AMIN1(XTRTMP(INDEX(I)),0.1),-0.1)
            DO 590 J=1,MLAY
               IPMAXL(J+(I-1)*MLAY)=
     +                MAX0(MIN0(IPMAXL(J+(INDEX(I)-1)*MLAY),33),-1)
  590       CONTINUE
  600    CONTINUE
      END IF
*
*-- Sort SW tracks
*
      IF(NTRKR.EQ.0) THEN
         CONTINUE
      ELSE IF(NTRKR.EQ.1) THEN
         ETR(1)=AMAX1(AMIN1(ETR(1),40.0),0.0)
         THTR(1)=AMAX1(AMIN1(THTR(1),0.1),-0.1)
         PHTR(1)=AMAX1(AMIN1(PHTR(1),6.28319),0.0)
      ELSE IF(NTRKR.EQ.2) THEN
         IF(ETR(1).LT.ETR(2)) THEN
            ETEMP(1)=ETR(1)
            THITMP(1)=THTR(1)
            PHITMP(1)=PHTR(1)
            ETR(1)=AMAX1(AMIN1(ETR(2),40.0),0.0)
            ETR(2)=AMAX1(AMIN1(ETEMP(1),40.0),0.0)
            THTR(1)=AMAX1(AMIN1(THTR(2),0.1),-0.1)
            THTR(2)=AMAX1(AMIN1(THITMP(1),0.1),-0.1)
            PHTR(1)=AMAX1(AMIN1(PHTR(2),6.28319),0.0)
            PHTR(2)=AMAX1(AMIN1(PHITMP(1),6.28319),0.0)
         ELSE
            ETR(1)=AMAX1(AMIN1(ETR(1),40.0),0.0)
            ETR(2)=AMAX1(AMIN1(ETR(2),40.0),0.0)
            THTR(1)=AMAX1(AMIN1(THTR(1),0.1),-0.1)
            THTR(2)=AMAX1(AMIN1(THTR(2),0.1),-0.1)
            PHTR(1)=AMAX1(AMIN1(PHTR(1),6.28319),0.0)
            PHTR(2)=AMAX1(AMIN1(PHTR(2),6.28319),0.0)
         END IF
      ELSE
         CALL SORTZV(ETR,INDEX,NTRKR,1,1,0)
         DO 610 I=1,NTRKR
            ETEMP(I)=ETR(I)
            THITMP(I)=THTR(I)
            PHITMP(I)=PHTR(I)
  610    CONTINUE
         DO 620 I=1,NTRKR
            ETR(I)=AMAX1(AMIN1(ETEMP(INDEX(I)),40.0),0.0)
            THTR(I)=AMAX1(AMIN1(THITMP(INDEX(I)),0.1),-0.1)
            PHTR(I)=AMAX1(AMIN1(PHITMP(INDEX(I)),6.28319),0.0)
  620    CONTINUE
      END IF
      IF(NTRKL.EQ.0) THEN
         CONTINUE
      ELSE IF(NTRKL.EQ.1) THEN
         ETL(1)=AMAX1(AMIN1(ETL(1),40.0),0.0)
         THTL(1)=AMAX1(AMIN1(THTL(1),0.1),-0.1)
         PHTL(1)=AMAX1(AMIN1(PHTL(1),6.28319),0.0)
      ELSE IF(NTRKL.EQ.2) THEN
         IF(ETL(1).LT.ETL(2)) THEN
            ETEMP(1)=ETL(1)
            THITMP(1)=THTL(1)
            PHITMP(1)=PHTL(1)
            ETL(1)=AMAX1(AMIN1(ETL(2),40.0),0.0)
            ETL(2)=AMAX1(AMIN1(ETEMP(1),40.0),0.0)
            THTL(1)=AMAX1(AMIN1(THTL(2),0.1),-0.1)
            THTL(2)=AMAX1(AMIN1(THITMP(1),0.1),-0.1)
            PHTL(1)=AMAX1(AMIN1(PHTL(2),6.28319),0.0)
            PHTL(2)=AMAX1(AMIN1(PHITMP(1),6.28319),0.0)
         ELSE
            ETL(1)=AMAX1(AMIN1(ETL(1),40.0),0.0)
            ETL(2)=AMAX1(AMIN1(ETL(2),40.0),0.0)
            THTL(1)=AMAX1(AMIN1(THTL(1),0.1),-0.1)
            THTL(2)=AMAX1(AMIN1(THTL(2),0.1),-0.1)
            PHTL(1)=AMAX1(AMIN1(PHTL(1),6.28319),0.0)
            PHTL(2)=AMAX1(AMIN1(PHTL(2),6.28319),0.0)
         END IF
      ELSE
         CALL SORTZV(ETL,INDEX,NTRKL,1,1,0)
         DO 630 I=1,NTRKL
            ETEMP(I)=ETL(I)
            THITMP(I)=THTL(I)
            PHITMP(I)=PHTL(I)
  630    CONTINUE
         DO 640 I=1,NTRKL
            ETL(I)=AMAX1(AMIN1(ETEMP(INDEX(I)),40.0),0.0)
            THTL(I)=AMAX1(AMIN1(THITMP(INDEX(I)),0.1),-0.1)
            PHTL(I)=AMAX1(AMIN1(PHITMP(INDEX(I)),6.28319),0.0)
  640    CONTINUE
      END IF
*
*-- Sort FD clusters
*
      IF(NFCLSR.EQ.0) THEN
         CONTINUE
      ELSE IF(NFCLSR.EQ.1) THEN
         EFR(1)=AMAX1(AMIN1(EFR(1),198.0),0.0)
         THETFR(1)=AMAX1(AMIN1(THETFR(1),0.14),0.04)
         PHIFR(1)=AMAX1(AMIN1(PHIFR(1),6.28319),0.0)
         EPREFR(1)=AMAX1(AMIN1(EPREFR(1),80.0),0.0)
      ELSE IF(NFCLSR.EQ.2) THEN
         IF(EFR(1).LT.EFR(2)) THEN
            ETEMP(1)=EFR(1)
            THITMP(1)=THETFR(1)
            PHITMP(1)=PHIFR(1)
            EPRTMP(1)=EPREFR(1)
            EFR(1)=AMAX1(AMIN1(EFR(2),198.0),0.0)
            EFR(2)=AMAX1(AMIN1(ETEMP(1),198.0),0.0)
            THETFR(1)=AMAX1(AMIN1(THETFR(2),0.14),0.04)
            THETFR(2)=AMAX1(AMIN1(THITMP(1),0.14),0.04)
            PHIFR(1)=AMAX1(AMIN1(PHIFR(2),6.28319),0.0)
            PHIFR(2)=AMAX1(AMIN1(PHITMP(1),6.28319),0.0)
            EPREFR(1)=AMAX1(AMIN1(EPREFR(2),80.0),0.0)
            EPREFR(2)=AMAX1(AMIN1(EPRTMP(1),80.0),0.0)
         ELSE
            EFR(1)=AMAX1(AMIN1(EFR(1),198.0),0.0)
            EFR(2)=AMAX1(AMIN1(EFR(2),198.0),0.0)
            THETFR(1)=AMAX1(AMIN1(THETFR(1),0.14),0.04)
            THETFR(2)=AMAX1(AMIN1(THETFR(2),0.14),0.04)
            PHIFR(1)=AMAX1(AMIN1(PHIFR(1),6.28319),0.0)
            PHIFR(2)=AMAX1(AMIN1(PHIFR(2),6.28319),0.0)
            EPREFR(1)=AMAX1(AMIN1(EPREFR(1),80.0),0.0)
            EPREFR(2)=AMAX1(AMIN1(EPREFR(2),80.0),0.0)
         END IF
      ELSE
         CALL SORTZV(EFR,INDEX,NFCLSR,1,1,0)
         DO 650 I=1,NFCLSR
            ETEMP(I)=EFR(I)
            THITMP(I)=THETFR(I)
             PHITMP(I)=PHIFR(I)
            EPRTMP(I)=EPREFR(I)
  650    CONTINUE
         DO 660 I=1,NFCLSR
            EFR(I)=AMAX1(AMIN1(ETEMP(INDEX(I)),198.0),0.0)
            THETFR(I)=AMAX1(AMIN1(THITMP(INDEX(I)),0.14),0.04)
            PHIFR(I)=AMAX1(AMIN1(PHITMP(INDEX(I)),6.28319),0.0)
            EPREFR(I)=AMAX1(AMIN1(EPRTMP(INDEX(I)),80.0),0.0)
  660    CONTINUE
      END IF
      IF(NFCLSL.EQ.0) THEN
         CONTINUE
      ELSE IF(NFCLSL.EQ.1) THEN
         EFL(1)=AMAX1(AMIN1(EFL(1),198.0),0.0)
         THETFL(1)=AMAX1(AMIN1(THETFL(1),0.14),0.04)
         PHIFL(1)=AMAX1(AMIN1(PHIFL(1),6.28319),0.0)
         EPREFL(1)=AMAX1(AMIN1(EPREFL(1),80.0),0.0)
      ELSE IF(NFCLSL.EQ.2) THEN
         IF(EFL(1).LT.EFL(2)) THEN
            ETEMP(1)=EFL(1)
            THITMP(1)=THETFL(1)
            PHITMP(1)=PHIFL(1)
            EPRTMP(1)=EPREFL(1)
            EFL(1)=AMAX1(AMIN1(EFL(2),198.0),0.0)
            EFL(2)=AMAX1(AMIN1(ETEMP(1),198.0),0.0)
            THETFL(1)=AMAX1(AMIN1(THETFL(2),0.14),0.04)
            THETFL(2)=AMAX1(AMIN1(THITMP(1),0.14),0.04)
            PHIFL(1)=AMAX1(AMIN1(PHIFL(2),6.28319),0.0)
            PHIFL(2)=AMAX1(AMIN1(PHITMP(1),6.28319),0.0)
            EPREFL(1)=AMAX1(AMIN1(EPREFL(2),80.0),0.0)
            EPREFL(2)=AMAX1(AMIN1(EPRTMP(1),80.0),0.0)
         ELSE
            EFL(1)=AMAX1(AMIN1(EFL(1),198.0),0.0)
            EFL(2)=AMAX1(AMIN1(EFL(2),198.0),0.0)
            THETFL(1)=AMAX1(AMIN1(THETFL(1),0.14),0.04)
            THETFL(2)=AMAX1(AMIN1(THETFL(2),0.14),0.04)
            PHIFL(1)=AMAX1(AMIN1(PHIFL(1),6.28319),0.0)
            PHIFL(2)=AMAX1(AMIN1(PHIFL(2),6.28319),0.0)
            EPREFL(1)=AMAX1(AMIN1(EPREFL(1),80.0),0.0)
            EPREFL(2)=AMAX1(AMIN1(EPREFL(2),80.0),0.0)
         END IF
      ELSE
         CALL SORTZV(EFL,INDEX,NFCLSL,1,1,0)
         DO 670 I=1,NFCLSL
            ETEMP(I)=EFL(I)
            THITMP(I)=THETFL(I)
            PHITMP(I)=PHIFL(I)
            EPRTMP(I)=EPREFL(I)
  670    CONTINUE
         DO 680 I=1,NFCLSL
            EFL(I)=AMAX1(AMIN1(ETEMP(INDEX(I)),198.0),0.0)
            THETFL(I)=AMAX1(AMIN1(THITMP(INDEX(I)),0.14),0.04)
            PHIFL(I)=AMAX1(AMIN1(PHITMP(INDEX(I)),6.28319),0.0)
            EPREFL(I)=AMAX1(AMIN1(EPRTMP(INDEX(I)),80.0),0.0)
  680    CONTINUE
      END IF
*
*-- Get SW trigger clusters
*
      CALL ODSWNT(NCL)
      DO 700 I=1,NCL
         CALL ODSWTC(I,TCLUS)
         IF(NINT(TCLUS(JTCTYP)).EQ.KTCCUR) THEN
            IF(TCLUS(JTCEND).LT.1.5) THEN
               IF(TCLUS(JTCENR).GT.EMXR) THEN
                  EMXR=AMAX1(AMIN1(TCLUS(JTCENR),198.0),0.0)
                  PHITR=AMAX1(AMIN1(TCLUS(JTCPHI),6.28319),0.0)
               END IF
            ELSE
               IF(TCLUS(JTCENR).GT.EMXL) THEN
                  EMXL=AMAX1(AMIN1(TCLUS(JTCENR),198.0),0.0)
                  PHITL=AMAX1(AMIN1(TCLUS(JTCPHI),6.28319),0.0)
               END IF
            END IF
         ELSE
            IF(TCLUS(JTCEND).LT.1.5) THEN
               IF(TCLUS(JTCENR).GT.EMXAR) THEN
                  EMXAR=AMAX1(AMIN1(TCLUS(JTCENR),198.0),0.0)
                  PHITAR=AMAX1(AMIN1(TCLUS(JTCPHI),6.28319),0.0)
               END IF
            ELSE
               IF(TCLUS(JTCENR).GT.EMXAL) THEN
                  EMXAL=AMAX1(AMIN1(TCLUS(JTCENR),198.0),0.0)
                  PHITAL=AMAX1(AMIN1(TCLUS(JTCPHI),6.28319),0.0)
               END IF
            END IF
         END IF
  700 CONTINUE
*.
*.       Fill  WT Block information   (IF LODSL Bank exists)
*.
      IF (LODSL.GT.0) THEN
       NWTCH=JBYT(IQ(LODSL+KDSOUR), 21, 8)
       NWTCH=MIN(NWTCH,128)
       INLB=IBITS(ISLUSH(6,1),0,4)
       ITGLOG=IBITS(ISLUSH(6,1),16,2)
       ISTRBR=IBITS(ISLUSH(6,1),12,3)
       ISTRBL=IBITS(ISLUSH(1,2),12,3)
*      Copy this directly from DST
       ITEXR=IBITS(IQ(LODSL+KDWT),14,3)
       ITEXL=IBITS(IQ(LODSL+KDWT),17,3)
*      Logic Variables
       IF (BTEST(IQ(LODSL+KDWT), 20)) LTXROK=.TRUE.
       IF (BTEST(IQ(LODSL+KDWT), 21)) LTXLOK=.TRUE.
       IF(BTEST(ISLUSH(6,1),18)) LRNDM=.TRUE.
       IF(BTEST(ISLUSH(6,1),19)) LNOTEX=.TRUE.
       IF(BTEST(ISLUSH(6,1),30)) LCWROK=.TRUE.
       IF(BTEST(ISLUSH(1,2),30)) LCWLOK=.TRUE.
       IF(BTEST(ISLUSH(6,1),31)) LTGROK=.TRUE.
       IF(BTEST(ISLUSH(1,2),31)) LTGLOK=.TRUE.
          IOFF = LODSL + KDHDSZ +
     +           JBYT(IQ(LODSL+KDSOUR), 1, 4)*KDTCSZ +
     +           JBYT(IQ(LODSL+KDSOUR), 5, 6)*KDTRSZ +
     +           JBYT(IQ(LODSL+KDSOUR), 11, 6)*KDPDSZ
       DO 810 I=1,NWTCH
         ISIDE= IBITS(IQ(IOFF+I),8,1)+1
         IBX=IBITS(IQ(IOFF+I),9,1)+1
         IF (IBX.EQ.1) THEN
             IF (ISIDE.EQ.1) THEN
                NWTCRC=NWTCRC+1
                NWTCRC=MIN(NWTCRC,32)
                ITAGRC(NWTCRC)=IBITS(IQ(IOFF+I),0,3)
                LBDTRC(NWTCRC)=BTEST(IQ(IOFF+I),31)
                ICHNRC(NWTCRC)=IBITS(IQ(IOFF+I),3,5)+1
                EWTTRC(NWTCRC)=IBITS(IQ(IOFF+I),10,9)*100./511.
                EWTPRC(NWTCRC)=IBITS(IQ(IOFF+I),19,10)*40./1023.
             ELSE
                NWTCLC=NWTCLC+1
                NWTCLC=MIN(NWTCLC,32)
                ITAGLC(NWTCLC)=IBITS(IQ(IOFF+I),0,3)
                LBDTLC(NWTCLC)=BTEST(IQ(IOFF+I),31)
                ICHNLC(NWTCLC)=IBITS(IQ(IOFF+I),3,5)+1
                EWTTLC(NWTCLC)=IBITS(IQ(IOFF+I),10,9)*100./511.
                EWTPLC(NWTCLC)=IBITS(IQ(IOFF+I),19,10)*40./1023.
             END IF
         ELSE
             IF (ISIDE.EQ.1) THEN
                NWTCRA=NWTCRA+1
                NWTCRA=MIN(NWTCRA,32)
                ITAGRA(NWTCRA)=IBITS(IQ(IOFF+I),0,3)
                LBDTRA(NWTCRA)=BTEST(IQ(IOFF+I),31)
                ICHNRA(NWTCRA)=IBITS(IQ(IOFF+I),3,5)+1
                EWTTRA(NWTCRA)=IBITS(IQ(IOFF+I),10,9)*100./511.
             ELSE
                NWTCLA=NWTCLA+1
                NWTCLA=MIN(NWTCLA,32)
                ITAGLA(NWTCLA)=IBITS(IQ(IOFF+I),0,3)
                LBDTLA(NWTCLA)=BTEST(IQ(IOFF+I),31)
                ICHNLA(NWTCLA)=IBITS(IQ(IOFF+I),3,5)+1
                EWTTLA(NWTCLA)=IBITS(IQ(IOFF+I),10,9)*100./511.
             END IF
         END IF
  810  CONTINUE
      END IF
      RETURN
      END
+DECK,RSWCOR.
      SUBROUTINE RSWCOR
*.
*...RSWCOR   Corrects the values in the ROSWVA common block
*.
*. SEQUENCE  : ROSWVA
*. CALLS     : RPHCOR RSWPSL RSWPSR RSWUL RSWUR
*. CALLED    : RBABSW
*.
*. AUTHOR    : D.Wagner
*. VERSION   : 1.01
*. CREATED   :  3-Feb-94
*. LAST MOD  :  7-May-99
*.
*. NB special rope only version will be needed for rerope
*. to handle phi correction...
*.
*. Modification Log.
*.  7-May-99 M.Schroder Fix edit descriptor (for linux)
*. 15-Apr-98   D.Strom    Moved data statements
*. 22-Jun-97   D.Strom    Add rope dependent corrections
*.  5-Jun-97   D.Strom    Warning if no correction
*. 14-Dec-96   D.Strom    Correct 1993 phi for "two tower" events
*. 15-Nov-96   D.Strom    Allow for lumped or unlumped smoothing
*. 10-Oct-96   D.Strom    Don't correct phi in 95
*. 20-Jun-96   D.Strom    Call Dick's new radial smoothing
*. 31-May-94   M.Foucher  Complete rewrite
*. 20-Avr-94   P.Hart     Make it do less (if using od407+)
*.  4-Feb-94   M.Mannelli Make it do something
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,ROSWVA.
+SEQ,RCREP
      REAL     RPHCOR,RSWPSL,RSWPSR
      EXTERNAL RPHCOR,RSWPSL,RSWPSR
*      REAL     RSWSML,RSWSMR
*      EXTERNAL RSWSML,RSWSMR
      REAL     RSWUR,RSWUL
      EXTERNAL RSWUR,RSWUL
*
      REAL DELPHI
*
      REAL PI
      PARAMETER ( PI=3.14159265 )
*
      INTEGER I
*
      INTEGER IORUN,IOEVT
*
      LOGICAL FIRST
      SAVE FIRST
*
      LOGICAL LUMP,PHCR
*
      CHARACTER*80 UPDATE
      DATA         UPDATE /'Corrections last updated 10-Oct-97'/
*
      DATA    FIRST /.TRUE./
*
*
      IF(IRUN.LT.4000) THEN
        RETURN
      ELSE IF(IRUN.LT.5000) THEN
        LUMP = .TRUE.
        PHCR = .TRUE.
      ELSE IF(IRUN.LT.6000) THEN
        LUMP = .FALSE.
        PHCR = .TRUE.
      ELSE IF(IRUN.LT.7000) THEN
        LUMP = .TRUE.
        PHCR = .FALSE.
*
* LEP II...
*
      ELSE
        LUMP = .TRUE.
        PHCR = .FALSE.
      END IF
*
*
*
      IF(FIRST) THEN
        CHREP = UPDATE
        CALL REPORT('RSWCOR',1,'I')
        IF(IRUN.LT.7000) THEN
            CHREP = 'Applying final LEP I corrections'
            CALL REPORT('RSWCOR',2,'I')
        ELSE
          WRITE(CHREP,1003)
1003      FORMAT('Applying last known corrections, may not be final')
          CALL REPORT('RSWCOR',3,'W')
        END IF
        FIRST = .FALSE.
      END IF
*
* Make sure we haven't already corrected this event...
*
      IF(IRUN.EQ.IORUN .AND. IEVT.EQ.IOEVT) THEN
          WRITE(CHREP,1004)IRUN,IEVT
1004      FORMAT('Already corrected this event!',2I8)
          CALL REPORT('RSWCOR',4,'W')
          GOTO 999
      END IF
*
* Loop over all clusters both sides, smooth phi, r, and correct energy
*
      IF(NCLSR.GT.0) THEN
         DO 100 I=1,NCLSR
           ER(I)=RSWPSR(ER(I),SHDR(I),RADR(I),EBEAM,IRUN)
           RADR(I)=RSWUR(RADR(I),EBEAM,IRUN,LUMP)
           IF(PHCR) THEN
             PHIR(I)=RPHCOR(PHIR(I),RADR(I),1)
           END IF
*
           IF(IROPE .GT. 1886 .AND. IRUN.LT.6000) THEN
             ER(I) = ER(I)*1282.5/1250.0
           END IF
*
  100    CONTINUE
      END IF
      IF(NCLSL.GT.0) THEN
         DO 200 I=1,NCLSL
*
* fixup period 68 -- use right on left here
*
            IF(IRUN.LT.5604 .OR.
     >         IRUN.GT.6000     ) THEN
              EL(I)=RSWPSL(EL(I),SHDL(I),RADL(I),EBEAM,IRUN)
            ELSE
              EL(I)=RSWPSR(EL(I),SHDL(I),RADL(I),EBEAM,IRUN)
              EL(I)=EL(I)*0.99850/1.0133
            END IF
*
*           RSWPSL and RSWPSR expect TOGEV = 1/1250.
*
            IF(IROPE .GT. 1886 .AND. IRUN.LT.6000) THEN
               EL(I) = EL(I)*1282.5/1250.0
            END IF
*
            RADL(I)=RSWUL(RADL(I),EBEAM,IRUN,LUMP)
            IF(PHCR) THEN
                PHIL(I)=RPHCOR(PHIL(I),RADL(I),2)
            END IF
  200    CONTINUE
      END IF
*
* NOW FIX PH PROBLEM IN 1993
*
      IF(IRUN.LT.5000 .AND. IROPE.LT.2089) THEN
*
* Only make the fix for events with reasonable energies.
*
        IF(ER(1)/EBEAM.GT.0.5  .AND.
     +       EL(1)/EBEAM.GT.0.5        ) THEN
*
           IF( MOD(PHIR(1),PI/16.)         .LT.0.0001.OR.
     +         PI/16. - MOD(PHIR(1),PI/16.).LT.0.0001    ) THEN
*
               DELPHI = PHIR(1) - PHIL(1)
               IF(DELPHI.LT.0.0) DELPHI = DELPHI + 2.*PI
               DELPHI = DELPHI - PI
*
               IF( ABS(DELPHI+PI/32.).LT.ABS(DELPHI-PI/32.).AND.
     +             ABS(DELPHI+PI/32.).LT.ABS(DELPHI)       )THEN
                     PHIR(1)  = PHIR(1) + PI/32.
               ELSE IF( ABS(DELPHI-PI/32.).LT.ABS(DELPHI+PI/32.).AND.
     +                  ABS(DELPHI-PI/32.).LT.ABS(DELPHI)       )THEN
                     PHIR(1)  = PHIR(1) - PI/32.
               END IF
           ELSE IF( MOD(PHIL(1),PI/16.)    .LT.0.0001.OR.
     +         PI/16. - MOD(PHIL(1),PI/16.).LT.0.0001       ) THEN
*
               DELPHI = PHIR(1) - PHIL(1)
               IF(DELPHI.LT.0.0) DELPHI = DELPHI + 2.*PI
               DELPHI = DELPHI - PI
*
               IF( ABS(DELPHI+PI/32.).LT.ABS(DELPHI-PI/32.).AND.
     +             ABS(DELPHI+PI/32.).LT.ABS(DELPHI)       )THEN
                     PHIL(1)  = PHIL(1) - PI/32.
               ELSE IF( ABS(DELPHI-PI/32.).LT.ABS(DELPHI+PI/32.).AND.
     +                  ABS(DELPHI-PI/32.).LT.ABS(DELPHI)       )THEN
                     PHIL(1)  = PHIL(1) + PI/32.
               END IF
           END IF
        END IF
      END IF
*
 999  CONTINUE
      RETURN
      END
+DECK,RSWUL.
      REAL FUNCTION RSWUL(R,EBEAM,IRUN,LUMP)
*
*...RSWUL   smooths radial coordinate
*.
*. SEQUENCE  : RSWUL
*. CALLS     : RSWCAR
*. CALLED    : RSWULx   x=0,A
*.
*. AUTHOR    : D.KELLOGG
*. VERSION   : 1.01
*. CREATED   : 20-apr-97
*.
*. LUMP = .TRUE. means lumped smoothing for year is used
*. LUMP = .FALSE. means smoothing for individual data blocks is used
*.
*. Modification Log.
*. 20-apr-97 recover run 5712 - give good smoothed coordiates, not zero
*.            default to un-smoothed coordinate for unknown data
*
* generates dick kellogg's smoothed coordinates
* from (marco's) dst coordinates
* by first un-doing marcos smoothing
* for the LEFT side
* LUMP = .TRUE. means lumped smoothing for year is used
* LUMP = .FALSE. means smoothing for individual data blocks is used
********************************************************************
+SEQ,DECLARE.
*
      LOGICAL LUMP
*
      REAL RSWUL0,RSWUL1,RSWUL2,RSWUL3,RSWUL4,RSWUL5
      REAL RSWUL6,RSWUL7,RSWUL8,RSWUL9,RSWULA
*
      EXTERNAL RSWUL0,RSWUL1,RSWUL2,RSWUL3,RSWUL4,RSWUL5
      EXTERNAL RSWUL6,RSWUL7,RSWUL8,RSWUL9,RSWULA
*
      REAL R, EBEAM, X, PI, ARG, ARG1, UNDO, RU
      INTEGER IRUN
* undo marco's smoothing
* reference for rope layer 7 z-value in mail from german 19.03.96
      X = R / 246.00225
      PI=3.141592654
      ARG= 2*PI/0.00102
      ARG1=ARG*(X+0.0002)
      UNDO=X-0.071/ARG*COS(ARG1)*(0.03/X)**4
      RU = 246.00225 * UNDO
* default for failure
      RSWUL = RU
* handle 1993 by beam energy
      IF( IRUN .GE. 4035 .AND. IRUN .LT. 5014 ) THEN
       IF(LUMP) THEN
        RSWUL = RSWUL0(RU)
       ELSE
        IF( EBEAM .LT. 45.0 ) THEN
          RSWUL = RSWUL1(RU)
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWUL = RSWUL3(RU)
        ELSE
          RSWUL = RSWUL2(RU)
        ENDIF
       ENDIF
      ENDIF
* handle 1994 by period
      IF( IRUN .GE. 5014 .AND. IRUN .LT. 5195 ) THEN
*         p59 to p60
          RSWUL = RSWUL4(RU)
      ELSEIF( IRUN .GE. 5195 .AND. IRUN .LT. 5600 ) THEN
*         p61 to p67
          RSWUL = RSWUL5(RU)
      ELSEIF( IRUN .GE. 5600 .AND. IRUN .LE. 5712 ) THEN
*         p68
          RSWUL = RSWUL6(RU)
      ENDIF
* handle 1995 by beam energy
      IF( IRUN .GE. 6002 .AND. IRUN .LT. 6604 ) THEN
       IF(LUMP) THEN
        RSWUL = RSWUL7(RU)
       ELSE
        IF( EBEAM .LT. 45.0 ) THEN
          RSWUL = RSWUL8(RU)
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWUL = RSWULA(RU)
        ELSE
          RSWUL = RSWUL9(RU)
        ENDIF
       ENDIF
      ENDIF
      RETURN
      END
+DECK,RSWUL0.
      REAL FUNCTION RSWUL0(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4210E-02 /
      DATA (FOU(I),I= 16, 18) / 0.9829E-03, 0.1130E-04,-0.8228E-04 /
      DATA (FOU(I),I= 19, 21) / 0.3344E-03,-0.5981E-04, 0.4364E-05 /
      DATA (FOU(I),I= 22, 24) /-0.4238E-02, 0.1386E-02, 0.1974E-03 /
      DATA (FOU(I),I= 25, 27) / 0.6955E-04, 0.5375E-03, 0.3478E-04 /
      DATA (FOU(I),I= 28, 30) / 0.2546E-04,-0.4077E-02, 0.1417E-02 /
      DATA (FOU(I),I= 31, 33) / 0.1912E-03, 0.1715E-03, 0.3359E-03 /
      DATA (FOU(I),I= 34, 36) / 0.3694E-04, 0.8550E-04,-0.4134E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1375E-02, 0.2996E-03, 0.2759E-03 /
      DATA (FOU(I),I= 40, 42) / 0.2113E-03, 0.2988E-04,-0.1896E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3380E-02, 0.1300E-02, 0.2761E-03 /
      DATA (FOU(I),I= 46, 48) / 0.3443E-03, 0.1620E-03, 0.1390E-04 /
      DATA (FOU(I),I= 49, 51) / 0.3348E-04,-0.2736E-02, 0.1397E-02 /
      DATA (FOU(I),I= 52, 54) / 0.4646E-03, 0.3279E-03, 0.9345E-04 /
      DATA (FOU(I),I= 55, 57) / 0.3852E-04, 0.3215E-04,-0.2908E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1099E-02, 0.4785E-03, 0.3667E-03 /
      DATA (FOU(I),I= 61, 63) / 0.1505E-04,-0.4203E-04, 0.1794E-04 /
      DATA (FOU(I),I= 64, 66) /-0.1803E-02, 0.8542E-03, 0.5284E-03 /
      DATA (FOU(I),I= 67, 69) / 0.2856E-03, 0.9193E-04, 0.9337E-04 /
      DATA (FOU(I),I= 70, 72) /-0.5600E-04,-0.5059E-03, 0.1361E-02 /
      DATA (FOU(I),I= 73, 75) / 0.6772E-03, 0.3998E-03, 0.6727E-04 /
      DATA (FOU(I),I= 76, 78) /-0.1601E-04,-0.4962E-04,-0.1055E-02 /
      DATA (FOU(I),I= 79, 81) / 0.1232E-02, 0.7923E-03, 0.2538E-03 /
      DATA (FOU(I),I= 82, 84) /-0.9192E-04, 0.1635E-04, 0.2111E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1524E-02, 0.1241E-02, 0.8302E-03 /
      DATA (FOU(I),I= 88, 90) / 0.2709E-03,-0.1523E-03,-0.3432E-05 /
      DATA (FOU(I),I= 91, 93) /-0.2598E-04,-0.1281E-02, 0.1542E-02 /
      DATA (FOU(I),I= 94, 96) / 0.5385E-03, 0.3166E-03,-0.6587E-04 /
      DATA (FOU(I),I= 97, 99) /-0.1067E-03, 0.3334E-04,-0.1140E-02 /
      DATA (FOU(I),I=100,102) / 0.1063E-02, 0.5552E-03, 0.3078E-03 /
      DATA (FOU(I),I=103,105) / 0.2140E-04,-0.1021E-03,-0.7256E-04 /
      DATA (FOU(I),I=106,108) / 0.1213E-02, 0.1865E-02, 0.9418E-03 /
      DATA (FOU(I),I=109,111) / 0.4758E-03, 0.4349E-04, 0.1245E-03 /
      DATA (FOU(I),I=112,114) / 0.2836E-04,-0.2311E-02, 0.1339E-02 /
      DATA (FOU(I),I=115,117) / 0.5471E-03, 0.1705E-03,-0.1013E-03 /
      DATA (FOU(I),I=118,120) /-0.1936E-03, 0.3608E-04, 0.2976E-03 /
      DATA (FOU(I),I=121,123) / 0.1077E-02, 0.6419E-03, 0.1276E-03 /
      DATA (FOU(I),I=124,126) / 0.2987E-04, 0.1188E-04, 0.4186E-04 /
      DATA (FOU(I),I=127,129) /-0.5913E-03, 0.1666E-02, 0.5033E-03 /
      DATA (FOU(I),I=130,132) / 0.1687E-03,-0.1219E-04,-0.1219E-04 /
      DATA (FOU(I),I=133,135) /-0.5714E-04,-0.1140E-02, 0.9538E-03 /
      DATA (FOU(I),I=136,138) / 0.3849E-03, 0.8334E-04, 0.1973E-04 /
      DATA (FOU(I),I=139,141) / 0.1570E-03,-0.5421E-04,-0.2415E-02 /
      DATA (FOU(I),I=142,144) / 0.1511E-02, 0.3996E-03, 0.2572E-03 /
      DATA (FOU(I),I=145,147) / 0.9998E-05, 0.5858E-04,-0.9533E-04 /
      DATA (FOU(I),I=148,150) / 0.2838E-03, 0.1535E-02, 0.2598E-03 /
      DATA (FOU(I),I=151,153) / 0.4452E-05, 0.3911E-03, 0.6686E-04 /
      DATA (FOU(I),I=154,156) / 0.1723E-04,-0.1065E-02, 0.1244E-02 /
      DATA (FOU(I),I=157,159) / 0.6046E-03, 0.2651E-03,-0.1000E-03 /
      DATA (FOU(I),I=160,162) /-0.1531E-04,-0.3716E-04, 0.3230E-03 /
      DATA (FOU(I),I=163,165) / 0.1262E-02, 0.7317E-04,-0.2089E-03 /
      DATA (FOU(I),I=166,168) / 0.5083E-04,-0.6801E-04, 0.9688E-04 /
      DATA (FOU(I),I=169,171) /-0.1033E-02, 0.9210E-03, 0.7420E-04 /
      DATA (FOU(I),I=172,174) / 0.2401E-04, 0.5946E-04, 0.1027E-03 /
      DATA (FOU(I),I=175,177) /-0.2627E-04,-0.1617E-02, 0.1219E-02 /
      DATA (FOU(I),I=178,180) / 0.1550E-03,-0.1253E-03,-0.1646E-03 /
      DATA (FOU(I),I=181,183) /-0.6623E-04, 0.3929E-04, 0.1027E-02 /
      DATA (FOU(I),I=184,186) / 0.1162E-02, 0.1595E-03,-0.1896E-03 /
      DATA (FOU(I),I=187,189) /-0.2231E-03,-0.9934E-04,-0.4989E-04 /
      DATA (FOU(I),I=190,192) /-0.9798E-04, 0.8174E-03,-0.2598E-03 /
      DATA (FOU(I),I=193,195) / 0.1258E-03, 0.1288E-03,-0.1602E-03 /
      DATA (FOU(I),I=196,198) /-0.4987E-04,-0.5606E-03, 0.5090E-03 /
      DATA (FOU(I),I=199,201) /-0.5934E-04, 0.9840E-04, 0.1497E-04 /
      DATA (FOU(I),I=202,204) /-0.2412E-04, 0.6778E-04, 0.1764E-02 /
      DATA (FOU(I),I=205,207) / 0.6362E-03,-0.2870E-03,-0.2910E-03 /
      DATA (FOU(I),I=208,210) /-0.9398E-04, 0.5226E-04,-0.2792E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL0 = F + RADM
      RETURN
      END
+DECK,RSWUL1.
      REAL FUNCTION RSWUL1(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4100E-02 /
      DATA (FOU(I),I= 16, 18) / 0.8268E-03, 0.4656E-04,-0.3688E-04 /
      DATA (FOU(I),I= 19, 21) / 0.4281E-03,-0.9731E-04, 0.1428E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4486E-02, 0.1402E-02, 0.1323E-03 /
      DATA (FOU(I),I= 25, 27) / 0.4533E-04, 0.4152E-03, 0.3807E-04 /
      DATA (FOU(I),I= 28, 30) / 0.6007E-04,-0.4450E-02, 0.1013E-02 /
      DATA (FOU(I),I= 31, 33) / 0.1599E-03, 0.1331E-03, 0.3468E-03 /
      DATA (FOU(I),I= 34, 36) / 0.1164E-03, 0.1191E-03,-0.4963E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1349E-02, 0.3649E-03, 0.3122E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1649E-03, 0.8817E-04,-0.2727E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3134E-02, 0.1056E-02, 0.5252E-03 /
      DATA (FOU(I),I= 46, 48) / 0.2785E-03, 0.4460E-04,-0.1875E-04 /
      DATA (FOU(I),I= 49, 51) / 0.4452E-04,-0.2753E-02, 0.1502E-02 /
      DATA (FOU(I),I= 52, 54) / 0.4313E-03, 0.3526E-03, 0.5162E-04 /
      DATA (FOU(I),I= 55, 57) / 0.1010E-04, 0.2319E-04,-0.3639E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1201E-02, 0.2165E-03, 0.1888E-03 /
      DATA (FOU(I),I= 61, 63) / 0.5053E-04,-0.4419E-04,-0.5800E-04 /
      DATA (FOU(I),I= 64, 66) /-0.2756E-02, 0.1089E-02, 0.4503E-03 /
      DATA (FOU(I),I= 67, 69) / 0.3021E-03, 0.1069E-03, 0.6030E-04 /
      DATA (FOU(I),I= 70, 72) /-0.3752E-04, 0.4304E-03, 0.9784E-03 /
      DATA (FOU(I),I= 73, 75) / 0.4444E-03, 0.4830E-03, 0.1410E-03 /
      DATA (FOU(I),I= 76, 78) /-0.5179E-04,-0.8770E-04,-0.5540E-03 /
      DATA (FOU(I),I= 79, 81) / 0.1329E-02, 0.9185E-03, 0.3572E-03 /
      DATA (FOU(I),I= 82, 84) /-0.2373E-03,-0.2993E-04,-0.1945E-04 /
      DATA (FOU(I),I= 85, 87) /-0.2139E-02, 0.1264E-02, 0.8790E-03 /
      DATA (FOU(I),I= 88, 90) / 0.3888E-03,-0.1868E-03, 0.5641E-04 /
      DATA (FOU(I),I= 91, 93) /-0.5775E-04,-0.1351E-02, 0.1546E-02 /
      DATA (FOU(I),I= 94, 96) / 0.6922E-03, 0.4327E-03,-0.1114E-03 /
      DATA (FOU(I),I= 97, 99) /-0.7309E-04, 0.1095E-03,-0.7357E-03 /
      DATA (FOU(I),I=100,102) / 0.6792E-03, 0.6932E-03,-0.4277E-04 /
      DATA (FOU(I),I=103,105) / 0.1331E-03,-0.1621E-04,-0.2591E-03 /
      DATA (FOU(I),I=106,108) / 0.1762E-02, 0.2110E-02, 0.8703E-03 /
      DATA (FOU(I),I=109,111) / 0.4125E-03,-0.1643E-03, 0.3665E-04 /
      DATA (FOU(I),I=112,114) /-0.5514E-04,-0.2956E-02, 0.1749E-02 /
      DATA (FOU(I),I=115,117) / 0.3266E-03, 0.1294E-03,-0.2286E-03 /
      DATA (FOU(I),I=118,120) /-0.2862E-03, 0.3974E-04, 0.2204E-03 /
      DATA (FOU(I),I=121,123) / 0.1441E-02, 0.7175E-03, 0.3039E-03 /
      DATA (FOU(I),I=124,126) /-0.2678E-04,-0.6177E-04, 0.1641E-04 /
      DATA (FOU(I),I=127,129) / 0.1412E-03, 0.2098E-02, 0.4871E-03 /
      DATA (FOU(I),I=130,132) / 0.1167E-03, 0.1666E-03, 0.7196E-04 /
      DATA (FOU(I),I=133,135) /-0.6799E-04,-0.9760E-03, 0.1282E-02 /
      DATA (FOU(I),I=136,138) / 0.3760E-03,-0.1657E-04,-0.3746E-03 /
      DATA (FOU(I),I=139,141) / 0.4425E-03, 0.1278E-03,-0.1103E-02 /
      DATA (FOU(I),I=142,144) / 0.1238E-02, 0.3216E-03,-0.5245E-04 /
      DATA (FOU(I),I=145,147) /-0.1240E-03, 0.1505E-03,-0.9028E-04 /
      DATA (FOU(I),I=148,150) /-0.4282E-03, 0.1672E-02, 0.2245E-03 /
      DATA (FOU(I),I=151,153) / 0.8786E-04, 0.4879E-03,-0.3241E-04 /
      DATA (FOU(I),I=154,156) /-0.9469E-04,-0.1413E-02, 0.2040E-02 /
      DATA (FOU(I),I=157,159) / 0.5638E-03, 0.3182E-03,-0.9163E-04 /
      DATA (FOU(I),I=160,162) /-0.1624E-03,-0.6381E-04,-0.4985E-03 /
      DATA (FOU(I),I=163,165) / 0.1298E-02, 0.2010E-03,-0.4221E-03 /
      DATA (FOU(I),I=166,168) /-0.9989E-04,-0.3757E-03, 0.1931E-03 /
      DATA (FOU(I),I=169,171) /-0.1232E-02, 0.1188E-02,-0.1615E-03 /
      DATA (FOU(I),I=172,174) / 0.4383E-03, 0.5329E-04, 0.2859E-03 /
      DATA (FOU(I),I=175,177) /-0.8627E-04,-0.1068E-02, 0.1461E-02 /
      DATA (FOU(I),I=178,180) / 0.4027E-03,-0.3350E-03,-0.1558E-03 /
      DATA (FOU(I),I=181,183) /-0.5067E-04,-0.8788E-04, 0.4250E-03 /
      DATA (FOU(I),I=184,186) / 0.1344E-02, 0.4079E-03,-0.3509E-03 /
      DATA (FOU(I),I=187,189) /-0.5787E-04, 0.4539E-04, 0.7951E-04 /
      DATA (FOU(I),I=190,192) /-0.8450E-05, 0.5793E-03,-0.4398E-03 /
      DATA (FOU(I),I=193,195) / 0.2954E-03,-0.4778E-04, 0.2943E-04 /
      DATA (FOU(I),I=196,198) /-0.1270E-04,-0.5597E-03, 0.1008E-02 /
      DATA (FOU(I),I=199,201) /-0.1305E-03,-0.5042E-04, 0.7394E-04 /
      DATA (FOU(I),I=202,204) /-0.7566E-04, 0.2957E-03, 0.1805E-02 /
      DATA (FOU(I),I=205,207) / 0.5599E-03,-0.5571E-03,-0.2786E-03 /
      DATA (FOU(I),I=208,210) / 0.1315E-03,-0.2744E-03,-0.3008E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL1 = F + RADM
      RETURN
      END
+DECK,RSWUL2.
      REAL FUNCTION RSWUL2(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4928E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1110E-02, 0.8545E-05,-0.1354E-03 /
      DATA (FOU(I),I= 19, 21) / 0.3066E-03,-0.1364E-03, 0.1113E-03 /
      DATA (FOU(I),I= 22, 24) /-0.3753E-02, 0.1486E-02, 0.1630E-03 /
      DATA (FOU(I),I= 25, 27) / 0.6717E-04, 0.5905E-03, 0.6035E-04 /
      DATA (FOU(I),I= 28, 30) /-0.8433E-04,-0.3655E-02, 0.1538E-02 /
      DATA (FOU(I),I= 31, 33) / 0.1366E-03, 0.1979E-03, 0.3844E-03 /
      DATA (FOU(I),I= 34, 36) / 0.4212E-05, 0.3022E-04,-0.3904E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1233E-02, 0.2509E-03, 0.3431E-03 /
      DATA (FOU(I),I= 40, 42) / 0.2073E-03, 0.1008E-03,-0.2565E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3467E-02, 0.1261E-02, 0.7544E-04 /
      DATA (FOU(I),I= 46, 48) / 0.4516E-03, 0.3957E-04, 0.8815E-04 /
      DATA (FOU(I),I= 49, 51) / 0.5356E-04,-0.2125E-02, 0.1171E-02 /
      DATA (FOU(I),I= 52, 54) / 0.5352E-03, 0.4572E-03, 0.2281E-03 /
      DATA (FOU(I),I= 55, 57) / 0.8041E-04, 0.6388E-04,-0.2760E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1183E-02, 0.6079E-03, 0.5154E-03 /
      DATA (FOU(I),I= 61, 63) /-0.1157E-03, 0.3781E-04,-0.1378E-04 /
      DATA (FOU(I),I= 64, 66) /-0.1430E-02, 0.1282E-02, 0.5140E-03 /
      DATA (FOU(I),I= 67, 69) / 0.6176E-03, 0.8674E-04, 0.1890E-03 /
      DATA (FOU(I),I= 70, 72) /-0.1371E-03,-0.1351E-02, 0.1333E-02 /
      DATA (FOU(I),I= 73, 75) / 0.8676E-03, 0.2355E-03, 0.2746E-03 /
      DATA (FOU(I),I= 76, 78) /-0.2465E-05,-0.4913E-04,-0.1255E-02 /
      DATA (FOU(I),I= 79, 81) / 0.1000E-02, 0.1003E-02, 0.3782E-03 /
      DATA (FOU(I),I= 82, 84) / 0.1103E-03, 0.3824E-04,-0.2682E-05 /
      DATA (FOU(I),I= 85, 87) /-0.1149E-02, 0.1519E-02, 0.1002E-02 /
      DATA (FOU(I),I= 88, 90) / 0.2409E-03,-0.9420E-04, 0.2268E-04 /
      DATA (FOU(I),I= 91, 93) /-0.1336E-03,-0.8098E-03, 0.1610E-02 /
      DATA (FOU(I),I= 94, 96) / 0.3601E-03, 0.1570E-03,-0.1555E-03 /
      DATA (FOU(I),I= 97, 99) /-0.1451E-03,-0.9415E-04,-0.6859E-04 /
      DATA (FOU(I),I=100,102) / 0.1273E-02, 0.4350E-03, 0.4543E-03 /
      DATA (FOU(I),I=103,105) /-0.1579E-03,-0.2350E-03,-0.7906E-04 /
      DATA (FOU(I),I=106,108) / 0.1387E-02, 0.1711E-02, 0.1111E-02 /
      DATA (FOU(I),I=109,111) / 0.3887E-03, 0.1307E-03, 0.2827E-03 /
      DATA (FOU(I),I=112,114) / 0.4501E-04,-0.2003E-02, 0.9689E-03 /
      DATA (FOU(I),I=115,117) / 0.7134E-03, 0.2021E-03,-0.2106E-03 /
      DATA (FOU(I),I=118,120) /-0.1870E-03,-0.7307E-04, 0.8877E-03 /
      DATA (FOU(I),I=121,123) / 0.5661E-03, 0.8567E-03, 0.3028E-03 /
      DATA (FOU(I),I=124,126) / 0.7944E-04, 0.1225E-03, 0.1045E-04 /
      DATA (FOU(I),I=127,129) /-0.7082E-03, 0.7074E-03, 0.5042E-03 /
      DATA (FOU(I),I=130,132) / 0.2659E-03,-0.2132E-03, 0.4378E-04 /
      DATA (FOU(I),I=133,135) /-0.7843E-04,-0.9122E-03, 0.1339E-02 /
      DATA (FOU(I),I=136,138) / 0.1179E-03, 0.8119E-04, 0.2837E-03 /
      DATA (FOU(I),I=139,141) / 0.3024E-04,-0.1462E-03,-0.3939E-02 /
      DATA (FOU(I),I=142,144) / 0.1357E-02, 0.2610E-03, 0.6342E-03 /
      DATA (FOU(I),I=145,147) /-0.2101E-03,-0.1809E-04,-0.2184E-03 /
      DATA (FOU(I),I=148,150) /-0.7232E-03, 0.1490E-02, 0.3015E-03 /
      DATA (FOU(I),I=151,153) /-0.1343E-03, 0.3215E-03, 0.1570E-03 /
      DATA (FOU(I),I=154,156) / 0.3177E-03,-0.4486E-03, 0.8816E-03 /
      DATA (FOU(I),I=157,159) / 0.4608E-03, 0.3003E-03,-0.1319E-03 /
      DATA (FOU(I),I=160,162) /-0.4515E-04, 0.1214E-04, 0.2358E-02 /
      DATA (FOU(I),I=163,165) / 0.1309E-02, 0.5450E-04,-0.1942E-03 /
      DATA (FOU(I),I=166,168) / 0.6306E-04, 0.3391E-03,-0.1129E-03 /
      DATA (FOU(I),I=169,171) /-0.1002E-02, 0.7427E-03, 0.1175E-03 /
      DATA (FOU(I),I=172,174) / 0.1226E-04, 0.8335E-04, 0.2551E-03 /
      DATA (FOU(I),I=175,177) / 0.1309E-03,-0.7802E-03, 0.9936E-03 /
      DATA (FOU(I),I=178,180) / 0.6541E-03,-0.1924E-03,-0.1965E-03 /
      DATA (FOU(I),I=181,183) / 0.6902E-04, 0.2155E-03, 0.1353E-02 /
      DATA (FOU(I),I=184,186) / 0.1000E-02, 0.4299E-03,-0.1572E-03 /
      DATA (FOU(I),I=187,189) /-0.2385E-03,-0.3506E-03,-0.1578E-04 /
      DATA (FOU(I),I=190,192) /-0.1378E-02, 0.1634E-02, 0.4538E-04 /
      DATA (FOU(I),I=193,195) / 0.5300E-03, 0.3162E-03,-0.1865E-03 /
      DATA (FOU(I),I=196,198) /-0.2894E-03, 0.3437E-03, 0.7892E-03 /
      DATA (FOU(I),I=199,201) /-0.2083E-04,-0.2540E-03, 0.3364E-03 /
      DATA (FOU(I),I=202,204) /-0.5917E-04, 0.1084E-03, 0.2948E-02 /
      DATA (FOU(I),I=205,207) / 0.7843E-03,-0.3518E-03, 0.3327E-04 /
      DATA (FOU(I),I=208,210) / 0.6740E-04, 0.1394E-03, 0.4265E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL2 = F + RADM
      RETURN
      END
+DECK,RSWUL3.
      REAL FUNCTION RSWUL3(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.3525E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1004E-02,-0.2382E-04,-0.7109E-04 /
      DATA (FOU(I),I= 19, 21) / 0.2675E-03, 0.6437E-04,-0.1247E-03 /
      DATA (FOU(I),I= 22, 24) /-0.4517E-02, 0.1259E-02, 0.3030E-03 /
      DATA (FOU(I),I= 25, 27) / 0.9752E-04, 0.6060E-03, 0.3438E-05 /
      DATA (FOU(I),I= 28, 30) / 0.1106E-03,-0.4153E-02, 0.1702E-02 /
      DATA (FOU(I),I= 31, 33) / 0.2828E-03, 0.1823E-03, 0.2719E-03 /
      DATA (FOU(I),I= 34, 36) /-0.9400E-05, 0.1114E-03,-0.3525E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1558E-02, 0.2845E-03, 0.1641E-03 /
      DATA (FOU(I),I= 40, 42) / 0.2639E-03,-0.1087E-03,-0.2895E-05 /
      DATA (FOU(I),I= 43, 45) /-0.3535E-02, 0.1593E-02, 0.2412E-03 /
      DATA (FOU(I),I= 46, 48) / 0.2940E-03, 0.4176E-03,-0.3490E-04 /
      DATA (FOU(I),I= 49, 51) / 0.6704E-06,-0.3405E-02, 0.1541E-02 /
      DATA (FOU(I),I= 52, 54) / 0.4226E-03, 0.1564E-03,-0.1364E-04 /
      DATA (FOU(I),I= 55, 57) / 0.2130E-04, 0.6173E-05,-0.2311E-02 /
      DATA (FOU(I),I= 58, 60) / 0.9021E-03, 0.6084E-03, 0.3872E-03 /
      DATA (FOU(I),I= 61, 63) / 0.1227E-03,-0.1281E-03, 0.1318E-03 /
      DATA (FOU(I),I= 64, 66) /-0.1225E-02, 0.1365E-03, 0.6259E-03 /
      DATA (FOU(I),I= 67, 69) /-0.9864E-04, 0.8152E-04, 0.2227E-04 /
      DATA (FOU(I),I= 70, 72) / 0.1407E-04,-0.5544E-03, 0.1791E-02 /
      DATA (FOU(I),I= 73, 75) / 0.7123E-03, 0.4924E-03,-0.2380E-03 /
      DATA (FOU(I),I= 76, 78) / 0.6700E-05,-0.1065E-04,-0.1354E-02 /
      DATA (FOU(I),I= 79, 81) / 0.1388E-02, 0.4296E-03, 0.9819E-05 /
      DATA (FOU(I),I= 82, 84) /-0.1647E-03, 0.3999E-04, 0.8941E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1305E-02, 0.9087E-03, 0.5903E-03 /
      DATA (FOU(I),I= 88, 90) / 0.1828E-03,-0.1812E-03,-0.9399E-04 /
      DATA (FOU(I),I= 91, 93) / 0.1260E-03,-0.1724E-02, 0.1464E-02 /
      DATA (FOU(I),I= 94, 96) / 0.5755E-03, 0.3719E-03, 0.7965E-04 /
      DATA (FOU(I),I= 97, 99) /-0.9918E-04, 0.9517E-04,-0.2774E-02 /
      DATA (FOU(I),I=100,102) / 0.1235E-02, 0.5524E-03, 0.5105E-03 /
      DATA (FOU(I),I=103,105) / 0.1019E-03,-0.4553E-04, 0.1328E-03 /
      DATA (FOU(I),I=106,108) / 0.4543E-03, 0.1782E-02, 0.8295E-03 /
      DATA (FOU(I),I=109,111) / 0.6371E-03, 0.1616E-03, 0.4198E-04 /
      DATA (FOU(I),I=112,114) / 0.9639E-04,-0.1993E-02, 0.1327E-02 /
      DATA (FOU(I),I=115,117) / 0.5915E-03, 0.1767E-03, 0.1510E-03 /
      DATA (FOU(I),I=118,120) /-0.1058E-03, 0.1535E-03,-0.2791E-03 /
      DATA (FOU(I),I=121,123) / 0.1266E-02, 0.3241E-03,-0.2521E-03 /
      DATA (FOU(I),I=124,126) / 0.3302E-04,-0.3417E-04, 0.1023E-03 /
      DATA (FOU(I),I=127,129) /-0.1221E-02, 0.2272E-02, 0.5208E-03 /
      DATA (FOU(I),I=130,132) / 0.1163E-03, 0.2243E-04,-0.1604E-03 /
      DATA (FOU(I),I=133,135) /-0.2236E-04,-0.1554E-02, 0.1936E-03 /
      DATA (FOU(I),I=136,138) / 0.6877E-03, 0.1840E-03, 0.1371E-03 /
      DATA (FOU(I),I=139,141) / 0.2755E-05,-0.1405E-03,-0.2082E-02 /
      DATA (FOU(I),I=142,144) / 0.1976E-02, 0.6333E-03, 0.1590E-03 /
      DATA (FOU(I),I=145,147) / 0.4015E-03, 0.4850E-04, 0.3674E-04 /
      DATA (FOU(I),I=148,150) / 0.2171E-02, 0.1442E-02, 0.2486E-03 /
      DATA (FOU(I),I=151,153) / 0.7279E-04, 0.3656E-03, 0.7100E-04 /
      DATA (FOU(I),I=154,156) /-0.1998E-03,-0.1390E-02, 0.8223E-03 /
      DATA (FOU(I),I=157,159) / 0.8033E-03, 0.1733E-03,-0.7465E-04 /
      DATA (FOU(I),I=160,162) / 0.1702E-03,-0.6288E-04,-0.1073E-02 /
      DATA (FOU(I),I=163,165) / 0.1178E-02,-0.3642E-04,-0.1255E-04 /
      DATA (FOU(I),I=166,168) / 0.1878E-03,-0.2012E-03, 0.2301E-03 /
      DATA (FOU(I),I=169,171) /-0.8585E-03, 0.8386E-03, 0.2749E-03 /
      DATA (FOU(I),I=172,174) /-0.3979E-03, 0.4129E-04,-0.2600E-03 /
      DATA (FOU(I),I=175,177) /-0.1408E-03,-0.3140E-02, 0.1214E-02 /
      DATA (FOU(I),I=178,180) /-0.6645E-03, 0.1741E-03,-0.1380E-03 /
      DATA (FOU(I),I=181,183) /-0.2352E-03,-0.2201E-04, 0.1274E-02 /
      DATA (FOU(I),I=184,186) / 0.1160E-02,-0.4009E-03,-0.6258E-04 /
      DATA (FOU(I),I=187,189) /-0.3751E-03, 0.3597E-04,-0.2225E-03 /
      DATA (FOU(I),I=190,192) / 0.1214E-02, 0.1650E-03,-0.4107E-03 /
      DATA (FOU(I),I=193,195) /-0.4964E-03, 0.1049E-03,-0.3262E-03 /
      DATA (FOU(I),I=196,198) / 0.1765E-03,-0.1553E-02,-0.3142E-03 /
      DATA (FOU(I),I=199,201) /-0.2952E-04, 0.6406E-03,-0.4010E-03 /
      DATA (FOU(I),I=202,204) / 0.7028E-04,-0.2140E-03, 0.4020E-03 /
      DATA (FOU(I),I=205,207) / 0.5584E-03, 0.4979E-04,-0.6471E-03 /
      DATA (FOU(I),I=208,210) /-0.5151E-03, 0.3051E-03,-0.1197E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL3 = F + RADM
      RETURN
      END
+DECK,RSWUL4.
      REAL FUNCTION RSWUL4(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5001E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1735E-02,-0.1963E-03,-0.2112E-03 /
      DATA (FOU(I),I= 19, 21) / 0.3408E-03, 0.1930E-04,-0.2510E-05 /
      DATA (FOU(I),I= 22, 24) /-0.4713E-02, 0.1795E-02, 0.2870E-03 /
      DATA (FOU(I),I= 25, 27) / 0.3035E-03, 0.2491E-03,-0.1562E-03 /
      DATA (FOU(I),I= 28, 30) /-0.2748E-04,-0.5584E-02, 0.1976E-02 /
      DATA (FOU(I),I= 31, 33) / 0.4170E-03, 0.2459E-03, 0.3048E-03 /
      DATA (FOU(I),I= 34, 36) /-0.2055E-03, 0.1396E-04,-0.3790E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1496E-02, 0.9212E-04, 0.2904E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1961E-03,-0.9761E-04, 0.7938E-04 /
      DATA (FOU(I),I= 43, 45) /-0.4640E-02, 0.1988E-02, 0.2064E-03 /
      DATA (FOU(I),I= 46, 48) / 0.9529E-04, 0.1461E-03,-0.9178E-05 /
      DATA (FOU(I),I= 49, 51) /-0.3533E-04,-0.3494E-02, 0.1391E-02 /
      DATA (FOU(I),I= 52, 54) / 0.5160E-03, 0.3387E-03,-0.1423E-03 /
      DATA (FOU(I),I= 55, 57) / 0.9772E-04, 0.5613E-04,-0.2918E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1157E-02, 0.5874E-03, 0.4067E-03 /
      DATA (FOU(I),I= 61, 63) / 0.2396E-03,-0.8560E-04, 0.1922E-03 /
      DATA (FOU(I),I= 64, 66) /-0.1739E-02, 0.9062E-03, 0.1573E-03 /
      DATA (FOU(I),I= 67, 69) / 0.5982E-03, 0.3633E-06,-0.8172E-04 /
      DATA (FOU(I),I= 70, 72) / 0.1056E-03,-0.4501E-03, 0.1610E-02 /
      DATA (FOU(I),I= 73, 75) / 0.3583E-03, 0.5800E-03,-0.2823E-03 /
      DATA (FOU(I),I= 76, 78) /-0.3320E-03, 0.1024E-03, 0.3988E-03 /
      DATA (FOU(I),I= 79, 81) / 0.9855E-03,-0.8319E-04, 0.4962E-03 /
      DATA (FOU(I),I= 82, 84) /-0.2483E-03,-0.1658E-03,-0.3073E-04 /
      DATA (FOU(I),I= 85, 87) /-0.9273E-03, 0.1562E-02, 0.4926E-03 /
      DATA (FOU(I),I= 88, 90) / 0.3238E-03,-0.1858E-03,-0.8411E-04 /
      DATA (FOU(I),I= 91, 93) / 0.1053E-03, 0.6291E-04, 0.1589E-02 /
      DATA (FOU(I),I= 94, 96) / 0.6454E-03, 0.4006E-03,-0.2531E-03 /
      DATA (FOU(I),I= 97, 99) /-0.1343E-03, 0.2829E-04, 0.2263E-03 /
      DATA (FOU(I),I=100,102) / 0.9866E-03, 0.5604E-03, 0.4752E-03 /
      DATA (FOU(I),I=103,105) /-0.2727E-03,-0.1834E-03,-0.9327E-04 /
      DATA (FOU(I),I=106,108) / 0.7868E-03, 0.9987E-03, 0.2177E-03 /
      DATA (FOU(I),I=109,111) / 0.4551E-04, 0.3540E-04,-0.2088E-03 /
      DATA (FOU(I),I=112,114) /-0.1653E-04,-0.7165E-03, 0.1766E-02 /
      DATA (FOU(I),I=115,117) / 0.9128E-04, 0.2857E-03,-0.3387E-03 /
      DATA (FOU(I),I=118,120) / 0.3096E-03,-0.1203E-03,-0.1170E-02 /
      DATA (FOU(I),I=121,123) / 0.1443E-02, 0.8558E-03, 0.1148E-03 /
      DATA (FOU(I),I=124,126) / 0.2334E-04, 0.3078E-03, 0.1756E-03 /
      DATA (FOU(I),I=127,129) /-0.3793E-03, 0.1918E-02, 0.3379E-03 /
      DATA (FOU(I),I=130,132) / 0.1066E-03,-0.1754E-04,-0.1366E-03 /
      DATA (FOU(I),I=133,135) / 0.3511E-04, 0.6356E-03, 0.1218E-02 /
      DATA (FOU(I),I=136,138) / 0.5109E-03, 0.3578E-03,-0.2760E-04 /
      DATA (FOU(I),I=139,141) / 0.1213E-03, 0.1013E-03,-0.1143E-02 /
      DATA (FOU(I),I=142,144) / 0.1790E-02, 0.7545E-04, 0.4020E-03 /
      DATA (FOU(I),I=145,147) /-0.3045E-04, 0.6849E-04,-0.3111E-04 /
      DATA (FOU(I),I=148,150) / 0.1960E-02, 0.1152E-02, 0.2739E-03 /
      DATA (FOU(I),I=151,153) /-0.4533E-03, 0.3027E-04, 0.1528E-03 /
      DATA (FOU(I),I=154,156) /-0.1627E-03,-0.6677E-03, 0.1390E-02 /
      DATA (FOU(I),I=157,159) / 0.4091E-03,-0.2276E-03,-0.3286E-03 /
      DATA (FOU(I),I=160,162) /-0.1343E-03,-0.1437E-03, 0.4540E-03 /
      DATA (FOU(I),I=163,165) / 0.1519E-02, 0.7322E-04,-0.1546E-05 /
      DATA (FOU(I),I=166,168) / 0.1947E-03, 0.2062E-03,-0.3982E-04 /
      DATA (FOU(I),I=169,171) /-0.1164E-02, 0.1336E-02, 0.2147E-03 /
      DATA (FOU(I),I=172,174) /-0.3567E-03,-0.5057E-04,-0.2141E-04 /
      DATA (FOU(I),I=175,177) /-0.4853E-04, 0.9793E-03, 0.1359E-03 /
      DATA (FOU(I),I=178,180) / 0.5230E-03,-0.1604E-03,-0.4719E-03 /
      DATA (FOU(I),I=181,183) /-0.9602E-04, 0.4034E-05, 0.4730E-03 /
      DATA (FOU(I),I=184,186) / 0.1492E-02,-0.3115E-03, 0.5331E-04 /
      DATA (FOU(I),I=187,189) /-0.2085E-03,-0.1120E-03,-0.9788E-04 /
      DATA (FOU(I),I=190,192) / 0.1452E-02, 0.1322E-02,-0.9831E-03 /
      DATA (FOU(I),I=193,195) / 0.1678E-03,-0.9273E-04,-0.5644E-04 /
      DATA (FOU(I),I=196,198) /-0.3330E-04, 0.2726E-02, 0.1658E-02 /
      DATA (FOU(I),I=199,201) / 0.2245E-03,-0.2191E-03, 0.3825E-03 /
      DATA (FOU(I),I=202,204) /-0.3002E-03, 0.1593E-03, 0.2459E-02 /
      DATA (FOU(I),I=205,207) / 0.7372E-03, 0.2590E-03,-0.1938E-03 /
      DATA (FOU(I),I=208,210) / 0.9717E-04, 0.3144E-03, 0.1329E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL4 = F + RADM
      RETURN
      END
+DECK,RSWUL5.
      REAL FUNCTION RSWUL5(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4453E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1276E-02,-0.9348E-04,-0.1286E-05 /
      DATA (FOU(I),I= 19, 21) / 0.3615E-03,-0.2459E-04, 0.5559E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4125E-02, 0.1206E-02, 0.1077E-03 /
      DATA (FOU(I),I= 25, 27) / 0.1838E-04, 0.3594E-03,-0.4442E-04 /
      DATA (FOU(I),I= 28, 30) / 0.5339E-04,-0.4203E-02, 0.1185E-02 /
      DATA (FOU(I),I= 31, 33) / 0.2450E-03, 0.1136E-03, 0.3707E-03 /
      DATA (FOU(I),I= 34, 36) /-0.6201E-04, 0.8424E-04,-0.4197E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1448E-02, 0.3741E-03, 0.1402E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1911E-03,-0.1861E-04, 0.2500E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3777E-02, 0.1232E-02, 0.3564E-03 /
      DATA (FOU(I),I= 46, 48) / 0.1865E-03, 0.2132E-03,-0.3719E-04 /
      DATA (FOU(I),I= 49, 51) / 0.2460E-04,-0.2992E-02, 0.1377E-02 /
      DATA (FOU(I),I= 52, 54) / 0.3577E-03, 0.3842E-03, 0.1834E-03 /
      DATA (FOU(I),I= 55, 57) /-0.2072E-04, 0.2294E-04,-0.2314E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1221E-02, 0.4439E-03, 0.3584E-03 /
      DATA (FOU(I),I= 61, 63) / 0.8001E-04, 0.3952E-04, 0.3593E-04 /
      DATA (FOU(I),I= 64, 66) /-0.1550E-02, 0.8536E-03, 0.3700E-03 /
      DATA (FOU(I),I= 67, 69) / 0.4844E-03, 0.3010E-04, 0.1373E-04 /
      DATA (FOU(I),I= 70, 72) / 0.4773E-04,-0.7825E-03, 0.1366E-02 /
      DATA (FOU(I),I= 73, 75) / 0.4749E-03, 0.4866E-03,-0.1296E-03 /
      DATA (FOU(I),I= 76, 78) /-0.3526E-04,-0.4419E-04,-0.7345E-03 /
      DATA (FOU(I),I= 79, 81) / 0.1174E-02, 0.5336E-03, 0.3489E-03 /
      DATA (FOU(I),I= 82, 84) / 0.8776E-04,-0.6157E-04,-0.4683E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1924E-02, 0.1369E-02, 0.7238E-03 /
      DATA (FOU(I),I= 88, 90) / 0.2573E-03,-0.1356E-04, 0.1102E-04 /
      DATA (FOU(I),I= 91, 93) / 0.9313E-05, 0.3060E-04, 0.1633E-02 /
      DATA (FOU(I),I= 94, 96) / 0.4713E-03, 0.2385E-03,-0.8549E-04 /
      DATA (FOU(I),I= 97, 99) /-0.5440E-04,-0.6213E-04,-0.5335E-03 /
      DATA (FOU(I),I=100,102) / 0.1336E-02, 0.7165E-03, 0.2236E-03 /
      DATA (FOU(I),I=103,105) /-0.9703E-04,-0.1072E-03,-0.7163E-04 /
      DATA (FOU(I),I=106,108) / 0.1180E-02, 0.1248E-02, 0.7107E-03 /
      DATA (FOU(I),I=109,111) / 0.2480E-03,-0.7726E-04,-0.1328E-03 /
      DATA (FOU(I),I=112,114) /-0.2784E-04,-0.2485E-02, 0.2166E-02 /
      DATA (FOU(I),I=115,117) / 0.4350E-03, 0.2835E-03,-0.2171E-03 /
      DATA (FOU(I),I=118,120) /-0.5950E-04, 0.2286E-04, 0.7459E-04 /
      DATA (FOU(I),I=121,123) / 0.1627E-02, 0.4328E-03, 0.1542E-03 /
      DATA (FOU(I),I=124,126) / 0.1837E-04,-0.4815E-04,-0.4226E-04 /
      DATA (FOU(I),I=127,129) /-0.7643E-03, 0.1384E-02, 0.3647E-03 /
      DATA (FOU(I),I=130,132) / 0.3508E-04,-0.9942E-04,-0.4989E-04 /
      DATA (FOU(I),I=133,135) / 0.3925E-04, 0.3646E-04, 0.6604E-03 /
      DATA (FOU(I),I=136,138) / 0.3240E-03, 0.1502E-03,-0.8989E-04 /
      DATA (FOU(I),I=139,141) /-0.3033E-04,-0.8946E-04,-0.2593E-02 /
      DATA (FOU(I),I=142,144) / 0.1776E-02, 0.1671E-03, 0.2460E-03 /
      DATA (FOU(I),I=145,147) /-0.2001E-03,-0.3105E-04,-0.1606E-04 /
      DATA (FOU(I),I=148,150) / 0.5281E-03, 0.1224E-02, 0.1935E-03 /
      DATA (FOU(I),I=151,153) / 0.9479E-04,-0.1294E-05,-0.4744E-04 /
      DATA (FOU(I),I=154,156) /-0.1570E-04, 0.7138E-03, 0.7804E-03 /
      DATA (FOU(I),I=157,159) / 0.2824E-03, 0.1142E-03,-0.1313E-03 /
      DATA (FOU(I),I=160,162) / 0.7858E-04,-0.1878E-03,-0.1452E-03 /
      DATA (FOU(I),I=163,165) / 0.9747E-03, 0.4155E-03, 0.5416E-04 /
      DATA (FOU(I),I=166,168) /-0.1485E-03,-0.2042E-04,-0.7211E-04 /
      DATA (FOU(I),I=169,171) / 0.4501E-03, 0.1224E-02, 0.7447E-04 /
      DATA (FOU(I),I=172,174) /-0.5469E-05,-0.6598E-04,-0.7344E-04 /
      DATA (FOU(I),I=175,177) /-0.1220E-03, 0.2552E-03, 0.1142E-02 /
      DATA (FOU(I),I=178,180) /-0.5272E-05, 0.1321E-03,-0.8941E-04 /
      DATA (FOU(I),I=181,183) /-0.2965E-04,-0.1859E-03, 0.4363E-03 /
      DATA (FOU(I),I=184,186) / 0.1982E-02, 0.1731E-03, 0.7954E-04 /
      DATA (FOU(I),I=187,189) /-0.2626E-04, 0.4205E-04,-0.1779E-03 /
      DATA (FOU(I),I=190,192) /-0.2292E-03, 0.1159E-02, 0.3956E-03 /
      DATA (FOU(I),I=193,195) /-0.1550E-04,-0.5717E-05, 0.1744E-03 /
      DATA (FOU(I),I=196,198) / 0.1030E-05, 0.1386E-02, 0.6714E-03 /
      DATA (FOU(I),I=199,201) / 0.3109E-03, 0.2899E-04, 0.8643E-04 /
      DATA (FOU(I),I=202,204) /-0.8493E-04, 0.5229E-04, 0.1068E-02 /
      DATA (FOU(I),I=205,207) / 0.1171E-02, 0.2233E-03,-0.4228E-04 /
      DATA (FOU(I),I=208,210) / 0.4159E-04,-0.5770E-04,-0.1378E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL5 = F + RADM
      RETURN
      END
+DECK,RSWUL6.
      REAL FUNCTION RSWUL6(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* n = 8 data period 95m (peak-2)
* n = 9 data period 95o (peak)
* n = A data period 95p (peak+2)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010 on 20. 3.97.
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.6220E-02 /
      DATA (FOU(I),I= 16, 18) / 0.4486E-03, 0.3605E-03, 0.1241E-03 /
      DATA (FOU(I),I= 19, 21) / 0.3532E-03,-0.3939E-04,-0.8074E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4357E-02, 0.1947E-02, 0.2101E-04 /
      DATA (FOU(I),I= 25, 27) / 0.4419E-04, 0.5240E-03,-0.2287E-03 /
      DATA (FOU(I),I= 28, 30) / 0.3557E-03,-0.4227E-02, 0.1426E-02 /
      DATA (FOU(I),I= 31, 33) / 0.6703E-03,-0.8123E-04, 0.3599E-03 /
      DATA (FOU(I),I= 34, 36) / 0.9555E-04, 0.1831E-03,-0.5348E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1319E-02, 0.1418E-03, 0.3525E-03 /
      DATA (FOU(I),I= 40, 42) / 0.2340E-03, 0.1693E-03,-0.2167E-04 /
      DATA (FOU(I),I= 43, 45) /-0.4560E-02, 0.6914E-03,-0.4777E-04 /
      DATA (FOU(I),I= 46, 48) / 0.9709E-04, 0.2360E-03,-0.1191E-03 /
      DATA (FOU(I),I= 49, 51) / 0.1997E-03,-0.2389E-02, 0.1235E-02 /
      DATA (FOU(I),I= 52, 54) / 0.6960E-03,-0.2239E-03, 0.2239E-03 /
      DATA (FOU(I),I= 55, 57) /-0.2398E-05, 0.2567E-03,-0.2863E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1442E-02, 0.5288E-03, 0.4839E-03 /
      DATA (FOU(I),I= 61, 63) / 0.1355E-03,-0.9237E-04, 0.4680E-05 /
      DATA (FOU(I),I= 64, 66) /-0.9309E-03, 0.7580E-03, 0.4736E-03 /
      DATA (FOU(I),I= 67, 69) / 0.1711E-03, 0.5597E-04, 0.6895E-04 /
      DATA (FOU(I),I= 70, 72) / 0.2459E-04,-0.2743E-02, 0.6229E-03 /
      DATA (FOU(I),I= 73, 75) / 0.4019E-03, 0.3854E-03,-0.4402E-04 /
      DATA (FOU(I),I= 76, 78) / 0.1151E-03, 0.1078E-03, 0.2685E-03 /
      DATA (FOU(I),I= 79, 81) / 0.9855E-03, 0.7092E-03, 0.2072E-03 /
      DATA (FOU(I),I= 82, 84) / 0.1050E-03,-0.9967E-04,-0.1598E-03 /
      DATA (FOU(I),I= 85, 87) /-0.1145E-02, 0.2051E-02, 0.8846E-03 /
      DATA (FOU(I),I= 88, 90) / 0.2956E-03, 0.1359E-03,-0.9155E-04 /
      DATA (FOU(I),I= 91, 93) /-0.4920E-04,-0.3430E-03, 0.6190E-03 /
      DATA (FOU(I),I= 94, 96) / 0.4255E-03, 0.5776E-03,-0.4306E-03 /
      DATA (FOU(I),I= 97, 99) /-0.9891E-04,-0.2020E-03, 0.3762E-03 /
      DATA (FOU(I),I=100,102) / 0.2873E-02, 0.6826E-03, 0.3854E-03 /
      DATA (FOU(I),I=103,105) /-0.1798E-03, 0.2138E-03,-0.3252E-04 /
      DATA (FOU(I),I=106,108) / 0.2688E-02, 0.1144E-02, 0.1326E-02 /
      DATA (FOU(I),I=109,111) /-0.5773E-03,-0.9257E-05, 0.1127E-03 /
      DATA (FOU(I),I=112,114) / 0.1508E-03,-0.6598E-03, 0.2673E-02 /
      DATA (FOU(I),I=115,117) / 0.8240E-03, 0.5595E-03,-0.3005E-03 /
      DATA (FOU(I),I=118,120) / 0.3816E-04,-0.1677E-03, 0.1516E-02 /
      DATA (FOU(I),I=121,123) / 0.1232E-02, 0.5495E-03, 0.4012E-03 /
      DATA (FOU(I),I=124,126) /-0.1287E-03, 0.1886E-03, 0.3074E-04 /
      DATA (FOU(I),I=127,129) / 0.7337E-03, 0.3587E-03, 0.4515E-03 /
      DATA (FOU(I),I=130,132) /-0.3599E-03, 0.2495E-03,-0.1527E-03 /
      DATA (FOU(I),I=133,135) / 0.2389E-03, 0.8295E-03, 0.1481E-02 /
      DATA (FOU(I),I=136,138) / 0.3503E-04, 0.8067E-03,-0.5977E-03 /
      DATA (FOU(I),I=139,141) / 0.2967E-03, 0.2943E-04,-0.2033E-02 /
      DATA (FOU(I),I=142,144) / 0.1103E-02,-0.3261E-03, 0.7282E-03 /
      DATA (FOU(I),I=145,147) /-0.3592E-03, 0.4089E-03,-0.4440E-03 /
      DATA (FOU(I),I=148,150) / 0.1077E-02, 0.1356E-02, 0.4156E-03 /
      DATA (FOU(I),I=151,153) / 0.8653E-04,-0.1775E-03, 0.3673E-03 /
      DATA (FOU(I),I=154,156) /-0.1744E-04,-0.8430E-03, 0.7881E-03 /
      DATA (FOU(I),I=157,159) / 0.4812E-03,-0.2039E-03, 0.1872E-03 /
      DATA (FOU(I),I=160,162) /-0.2885E-03, 0.2489E-03,-0.5035E-03 /
      DATA (FOU(I),I=163,165) / 0.1698E-02,-0.5090E-03,-0.2402E-03 /
      DATA (FOU(I),I=166,168) /-0.2675E-03,-0.1339E-03, 0.1179E-03 /
      DATA (FOU(I),I=169,171) /-0.8919E-03, 0.1063E-02,-0.4107E-03 /
      DATA (FOU(I),I=172,174) / 0.6657E-03, 0.6769E-03,-0.3869E-03 /
      DATA (FOU(I),I=175,177) / 0.1228E-03,-0.3604E-02, 0.2168E-02 /
      DATA (FOU(I),I=178,180) / 0.2452E-03,-0.1213E-03, 0.3069E-03 /
      DATA (FOU(I),I=181,183) / 0.1533E-03,-0.7382E-04, 0.1277E-02 /
      DATA (FOU(I),I=184,186) / 0.8735E-03, 0.8465E-03,-0.2601E-03 /
      DATA (FOU(I),I=187,189) /-0.4991E-03, 0.1726E-03,-0.4026E-03 /
      DATA (FOU(I),I=190,192) / 0.2031E-02, 0.1280E-02, 0.6382E-03 /
      DATA (FOU(I),I=193,195) / 0.5684E-03, 0.2521E-03,-0.7175E-03 /
      DATA (FOU(I),I=196,198) /-0.1128E-03, 0.1041E-02, 0.1520E-02 /
      DATA (FOU(I),I=199,201) /-0.6352E-04,-0.3901E-03,-0.8007E-04 /
      DATA (FOU(I),I=202,204) / 0.2053E-03,-0.6090E-04,-0.2832E-02 /
      DATA (FOU(I),I=205,207) / 0.1051E-02,-0.2387E-03, 0.7694E-03 /
      DATA (FOU(I),I=208,210) / 0.2497E-03, 0.2132E-04, 0.3732E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL6 = F + RADM
      RETURN
      END
+DECK,RSWUL7.
      REAL FUNCTION RSWUL7(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4774E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1518E-02,-0.3167E-03,-0.2363E-03 /
      DATA (FOU(I),I= 19, 21) / 0.2580E-03,-0.1071E-03, 0.6671E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4198E-02, 0.1476E-02, 0.1122E-03 /
      DATA (FOU(I),I= 25, 27) / 0.3277E-04, 0.3718E-03, 0.3012E-05 /
      DATA (FOU(I),I= 28, 30) / 0.8861E-04,-0.3659E-02, 0.1055E-02 /
      DATA (FOU(I),I= 31, 33) / 0.2670E-03,-0.1093E-04, 0.3032E-03 /
      DATA (FOU(I),I= 34, 36) / 0.6117E-04, 0.1172E-03,-0.3143E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1269E-02, 0.1491E-03, 0.5863E-04 /
      DATA (FOU(I),I= 40, 42) / 0.3879E-03, 0.3966E-04, 0.1360E-03 /
      DATA (FOU(I),I= 43, 45) /-0.3121E-02, 0.1408E-02, 0.1296E-03 /
      DATA (FOU(I),I= 46, 48) / 0.2166E-03, 0.2805E-03,-0.9966E-04 /
      DATA (FOU(I),I= 49, 51) / 0.8264E-05,-0.3053E-02, 0.1514E-02 /
      DATA (FOU(I),I= 52, 54) / 0.1348E-03, 0.8601E-04, 0.9174E-04 /
      DATA (FOU(I),I= 55, 57) / 0.1611E-05, 0.3506E-04,-0.3253E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1069E-02, 0.2232E-03, 0.1945E-03 /
      DATA (FOU(I),I= 61, 63) / 0.8357E-04, 0.5449E-04, 0.5645E-05 /
      DATA (FOU(I),I= 64, 66) /-0.1726E-02, 0.9461E-03, 0.2790E-03 /
      DATA (FOU(I),I= 67, 69) / 0.3373E-03, 0.1487E-03, 0.7101E-04 /
      DATA (FOU(I),I= 70, 72) / 0.8730E-04,-0.7250E-03, 0.9107E-03 /
      DATA (FOU(I),I= 73, 75) / 0.2803E-03, 0.3307E-03,-0.7449E-05 /
      DATA (FOU(I),I= 76, 78) / 0.6107E-04,-0.5035E-05,-0.1536E-02 /
      DATA (FOU(I),I= 79, 81) / 0.8081E-03, 0.5435E-03, 0.3502E-03 /
      DATA (FOU(I),I= 82, 84) /-0.6285E-05, 0.8810E-04, 0.9097E-04 /
      DATA (FOU(I),I= 85, 87) /-0.2439E-02, 0.1493E-02, 0.2956E-03 /
      DATA (FOU(I),I= 88, 90) / 0.3589E-03, 0.1145E-03,-0.4391E-05 /
      DATA (FOU(I),I= 91, 93) / 0.1076E-04,-0.1597E-02, 0.1166E-02 /
      DATA (FOU(I),I= 94, 96) / 0.4894E-03, 0.4736E-03,-0.6318E-04 /
      DATA (FOU(I),I= 97, 99) /-0.9725E-04, 0.6850E-04,-0.1302E-02 /
      DATA (FOU(I),I=100,102) / 0.1336E-02, 0.5351E-03, 0.1607E-03 /
      DATA (FOU(I),I=103,105) /-0.6324E-04,-0.2905E-04, 0.3615E-04 /
      DATA (FOU(I),I=106,108) /-0.2247E-02, 0.1786E-02, 0.5215E-03 /
      DATA (FOU(I),I=109,111) / 0.1116E-03,-0.3851E-04, 0.8124E-04 /
      DATA (FOU(I),I=112,114) / 0.7537E-05, 0.5101E-03, 0.1805E-02 /
      DATA (FOU(I),I=115,117) / 0.1443E-04, 0.2200E-03, 0.1937E-03 /
      DATA (FOU(I),I=118,120) / 0.5083E-04,-0.8742E-04,-0.3433E-03 /
      DATA (FOU(I),I=121,123) / 0.1616E-02, 0.1765E-03, 0.2066E-04 /
      DATA (FOU(I),I=124,126) /-0.4837E-04, 0.1290E-03,-0.6120E-04 /
      DATA (FOU(I),I=127,129) /-0.2349E-02, 0.1592E-02, 0.1806E-03 /
      DATA (FOU(I),I=130,132) / 0.8662E-04,-0.5032E-04,-0.4018E-04 /
      DATA (FOU(I),I=133,135) /-0.6626E-05,-0.1075E-02, 0.1178E-02 /
      DATA (FOU(I),I=136,138) / 0.7413E-03,-0.1660E-04, 0.6907E-04 /
      DATA (FOU(I),I=139,141) / 0.6964E-04,-0.1190E-03,-0.2522E-02 /
      DATA (FOU(I),I=142,144) / 0.1495E-02, 0.2403E-03, 0.7916E-04 /
      DATA (FOU(I),I=145,147) / 0.1265E-04, 0.2101E-03,-0.4264E-04 /
      DATA (FOU(I),I=148,150) /-0.2623E-04, 0.1585E-02, 0.4215E-03 /
      DATA (FOU(I),I=151,153) / 0.1158E-04, 0.1892E-03, 0.1850E-03 /
      DATA (FOU(I),I=154,156) /-0.8191E-04,-0.7920E-03, 0.7011E-03 /
      DATA (FOU(I),I=157,159) /-0.2075E-03,-0.1550E-03, 0.1470E-03 /
      DATA (FOU(I),I=160,162) /-0.1650E-04,-0.1376E-03, 0.1868E-03 /
      DATA (FOU(I),I=163,165) / 0.9179E-03, 0.3613E-03, 0.3399E-03 /
      DATA (FOU(I),I=166,168) / 0.1205E-03, 0.8888E-04, 0.1076E-04 /
      DATA (FOU(I),I=169,171) /-0.2132E-02, 0.8646E-03,-0.7173E-03 /
      DATA (FOU(I),I=172,174) /-0.1250E-04, 0.3150E-04, 0.1989E-03 /
      DATA (FOU(I),I=175,177) /-0.3990E-03, 0.3322E-03, 0.8745E-03 /
      DATA (FOU(I),I=178,180) /-0.3307E-03, 0.1578E-03,-0.1146E-04 /
      DATA (FOU(I),I=181,183) / 0.4168E-04,-0.1104E-03, 0.3076E-03 /
      DATA (FOU(I),I=184,186) / 0.8073E-03,-0.2689E-03, 0.3545E-03 /
      DATA (FOU(I),I=187,189) / 0.1558E-03, 0.7910E-04,-0.1094E-03 /
      DATA (FOU(I),I=190,192) /-0.2274E-03, 0.7958E-03,-0.2831E-03 /
      DATA (FOU(I),I=193,195) /-0.6627E-04,-0.7788E-04,-0.7837E-04 /
      DATA (FOU(I),I=196,198) /-0.2198E-03, 0.2257E-04, 0.4066E-03 /
      DATA (FOU(I),I=199,201) / 0.1604E-03, 0.9998E-04, 0.9331E-04 /
      DATA (FOU(I),I=202,204) /-0.2298E-03, 0.1581E-03,-0.2848E-03 /
      DATA (FOU(I),I=205,207) / 0.7156E-03, 0.1547E-03, 0.4898E-04 /
      DATA (FOU(I),I=208,210) /-0.1849E-03,-0.2170E-03,-0.4014E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL7 = F + RADM
      RETURN
      END
+DECK,RSWUL8.
      REAL FUNCTION RSWUL8(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5265E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1324E-02,-0.1220E-03,-0.2990E-03 /
      DATA (FOU(I),I= 19, 21) / 0.1755E-03,-0.1760E-03,-0.1709E-04 /
      DATA (FOU(I),I= 22, 24) /-0.3630E-02, 0.1417E-02,-0.3850E-04 /
      DATA (FOU(I),I= 25, 27) / 0.1342E-03, 0.3063E-03,-0.2073E-04 /
      DATA (FOU(I),I= 28, 30) / 0.5531E-04,-0.3445E-02, 0.1064E-02 /
      DATA (FOU(I),I= 31, 33) / 0.8148E-04,-0.8620E-04, 0.2812E-03 /
      DATA (FOU(I),I= 34, 36) /-0.9339E-05, 0.2885E-04,-0.3989E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1212E-02, 0.2654E-03, 0.1208E-03 /
      DATA (FOU(I),I= 40, 42) / 0.4157E-03,-0.6348E-04,-0.2273E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3054E-02, 0.1417E-02, 0.8372E-04 /
      DATA (FOU(I),I= 46, 48) / 0.2454E-03, 0.3892E-03,-0.2273E-03 /
      DATA (FOU(I),I= 49, 51) / 0.3226E-04,-0.2494E-02, 0.1107E-02 /
      DATA (FOU(I),I= 52, 54) / 0.1165E-03, 0.1436E-03,-0.2448E-04 /
      DATA (FOU(I),I= 55, 57) / 0.1467E-03, 0.1368E-04,-0.3642E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1010E-02, 0.5644E-04, 0.7464E-04 /
      DATA (FOU(I),I= 61, 63) / 0.1761E-04,-0.1352E-03,-0.3129E-05 /
      DATA (FOU(I),I= 64, 66) /-0.1583E-02, 0.1569E-02, 0.3940E-03 /
      DATA (FOU(I),I= 67, 69) / 0.4239E-03, 0.5848E-04, 0.1108E-03 /
      DATA (FOU(I),I= 70, 72) / 0.2632E-04,-0.7446E-03, 0.9649E-03 /
      DATA (FOU(I),I= 73, 75) / 0.2908E-04, 0.3482E-03,-0.5061E-04 /
      DATA (FOU(I),I= 76, 78) / 0.1787E-03, 0.9114E-04,-0.2517E-02 /
      DATA (FOU(I),I= 79, 81) / 0.1208E-02, 0.5312E-03, 0.3532E-03 /
      DATA (FOU(I),I= 82, 84) /-0.4574E-04, 0.3932E-03, 0.1053E-03 /
      DATA (FOU(I),I= 85, 87) /-0.2940E-02, 0.1775E-02, 0.3789E-03 /
      DATA (FOU(I),I= 88, 90) / 0.4377E-03, 0.1945E-03, 0.8012E-04 /
      DATA (FOU(I),I= 91, 93) /-0.2255E-04,-0.2412E-02, 0.1124E-02 /
      DATA (FOU(I),I= 94, 96) / 0.3027E-03, 0.3022E-03,-0.8413E-04 /
      DATA (FOU(I),I= 97, 99) /-0.1271E-03, 0.2080E-03,-0.1924E-02 /
      DATA (FOU(I),I=100,102) / 0.1479E-02, 0.4988E-03, 0.1746E-03 /
      DATA (FOU(I),I=103,105) /-0.1573E-03,-0.1469E-03,-0.2522E-03 /
      DATA (FOU(I),I=106,108) /-0.1706E-02, 0.1620E-02, 0.3636E-03 /
      DATA (FOU(I),I=109,111) / 0.3165E-03,-0.8035E-04, 0.2618E-03 /
      DATA (FOU(I),I=112,114) /-0.8235E-05,-0.9490E-03, 0.9915E-03 /
      DATA (FOU(I),I=115,117) / 0.7945E-04, 0.6246E-04, 0.2841E-03 /
      DATA (FOU(I),I=118,120) / 0.4589E-04, 0.4634E-04,-0.8343E-03 /
      DATA (FOU(I),I=121,123) / 0.1785E-02,-0.1327E-05,-0.7005E-04 /
      DATA (FOU(I),I=124,126) /-0.7636E-04, 0.7899E-04,-0.1353E-03 /
      DATA (FOU(I),I=127,129) /-0.1978E-02, 0.2445E-02, 0.1370E-03 /
      DATA (FOU(I),I=130,132) / 0.1293E-03,-0.1792E-03,-0.6367E-04 /
      DATA (FOU(I),I=133,135) /-0.5985E-04,-0.1812E-02, 0.1303E-02 /
      DATA (FOU(I),I=136,138) / 0.9681E-03,-0.8827E-04, 0.2306E-03 /
      DATA (FOU(I),I=139,141) /-0.1317E-03,-0.2582E-03,-0.3788E-02 /
      DATA (FOU(I),I=142,144) / 0.1570E-02,-0.1124E-03,-0.1980E-03 /
      DATA (FOU(I),I=145,147) /-0.2387E-04, 0.1425E-04,-0.9595E-04 /
      DATA (FOU(I),I=148,150) / 0.4124E-03, 0.1456E-02, 0.1681E-03 /
      DATA (FOU(I),I=151,153) / 0.2734E-03, 0.3138E-04, 0.3060E-04 /
      DATA (FOU(I),I=154,156) /-0.3706E-03,-0.1675E-02, 0.1275E-02 /
      DATA (FOU(I),I=157,159) / 0.1113E-03,-0.4364E-03, 0.1691E-03 /
      DATA (FOU(I),I=160,162) / 0.2444E-03, 0.4377E-04, 0.1931E-02 /
      DATA (FOU(I),I=163,165) / 0.3540E-03, 0.4951E-03, 0.6439E-03 /
      DATA (FOU(I),I=166,168) / 0.2634E-03, 0.1203E-03,-0.1995E-03 /
      DATA (FOU(I),I=169,171) /-0.2255E-02, 0.1511E-02,-0.4354E-03 /
      DATA (FOU(I),I=172,174) / 0.4134E-03, 0.2130E-04, 0.2374E-03 /
      DATA (FOU(I),I=175,177) /-0.3245E-03, 0.1681E-03, 0.5592E-03 /
      DATA (FOU(I),I=178,180) /-0.4734E-03,-0.2247E-03, 0.2310E-03 /
      DATA (FOU(I),I=181,183) /-0.9520E-04,-0.6914E-04,-0.5244E-03 /
      DATA (FOU(I),I=184,186) / 0.8957E-03,-0.5864E-03, 0.7087E-03 /
      DATA (FOU(I),I=187,189) / 0.5659E-03,-0.9437E-04,-0.1060E-03 /
      DATA (FOU(I),I=190,192) / 0.8753E-03,-0.4831E-03,-0.4606E-03 /
      DATA (FOU(I),I=193,195) /-0.2600E-03, 0.2093E-03,-0.3405E-03 /
      DATA (FOU(I),I=196,198) /-0.4312E-03,-0.3412E-03, 0.4546E-03 /
      DATA (FOU(I),I=199,201) / 0.6918E-03, 0.3274E-03, 0.8185E-04 /
      DATA (FOU(I),I=202,204) /-0.2711E-03, 0.2773E-03,-0.2579E-02 /
      DATA (FOU(I),I=205,207) / 0.9400E-03, 0.3717E-03,-0.3299E-03 /
      DATA (FOU(I),I=208,210) /-0.2482E-04,-0.2931E-03,-0.2896E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL8 = F + RADM
      RETURN
      END
+DECK,RSWUL9.
      REAL FUNCTION RSWUL9(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.3582E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1573E-02,-0.6688E-03,-0.3805E-03 /
      DATA (FOU(I),I= 19, 21) / 0.2552E-03, 0.3550E-04, 0.1107E-03 /
      DATA (FOU(I),I= 22, 24) /-0.3917E-02, 0.1106E-02, 0.2586E-03 /
      DATA (FOU(I),I= 25, 27) / 0.2034E-04, 0.2442E-03, 0.3271E-04 /
      DATA (FOU(I),I= 28, 30) / 0.1606E-03,-0.4205E-02, 0.1040E-02 /
      DATA (FOU(I),I= 31, 33) / 0.4660E-03, 0.5213E-04, 0.3046E-03 /
      DATA (FOU(I),I= 34, 36) / 0.1487E-03, 0.8794E-04,-0.2237E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1425E-02, 0.1212E-03, 0.1191E-03 /
      DATA (FOU(I),I= 40, 42) / 0.4098E-03, 0.1428E-03, 0.2772E-03 /
      DATA (FOU(I),I= 43, 45) /-0.2666E-02, 0.1562E-02, 0.5613E-04 /
      DATA (FOU(I),I= 46, 48) / 0.2395E-03, 0.4450E-04,-0.1513E-04 /
      DATA (FOU(I),I= 49, 51) /-0.3728E-04,-0.3966E-02, 0.1300E-02 /
      DATA (FOU(I),I= 52, 54) / 0.1233E-03,-0.2092E-04, 0.2533E-03 /
      DATA (FOU(I),I= 55, 57) /-0.1593E-03, 0.7972E-06,-0.4255E-02 /
      DATA (FOU(I),I= 58, 60) / 0.8944E-03, 0.3761E-03, 0.1391E-03 /
      DATA (FOU(I),I= 61, 63) /-0.1047E-03, 0.4973E-04,-0.4623E-05 /
      DATA (FOU(I),I= 64, 66) /-0.1682E-02, 0.1053E-02, 0.3430E-03 /
      DATA (FOU(I),I= 67, 69) / 0.1082E-03, 0.1017E-03, 0.3257E-04 /
      DATA (FOU(I),I= 70, 72) / 0.1898E-03,-0.1074E-02, 0.5277E-03 /
      DATA (FOU(I),I= 73, 75) / 0.8969E-03, 0.4236E-03, 0.1234E-03 /
      DATA (FOU(I),I= 76, 78) /-0.1536E-03, 0.4031E-04,-0.3313E-03 /
      DATA (FOU(I),I= 79, 81) / 0.7518E-03, 0.6758E-03, 0.3598E-03 /
      DATA (FOU(I),I= 82, 84) /-0.6227E-04, 0.1967E-04, 0.1141E-03 /
      DATA (FOU(I),I= 85, 87) /-0.2954E-02, 0.6335E-03, 0.3841E-03 /
      DATA (FOU(I),I= 88, 90) / 0.2380E-03, 0.3941E-04, 0.8505E-04 /
      DATA (FOU(I),I= 91, 93) / 0.5081E-04,-0.1518E-02, 0.1327E-02 /
      DATA (FOU(I),I= 94, 96) / 0.4888E-03, 0.6884E-03,-0.1249E-04 /
      DATA (FOU(I),I= 97, 99) /-0.1043E-03, 0.6589E-04,-0.1215E-02 /
      DATA (FOU(I),I=100,102) / 0.1198E-02, 0.6181E-03,-0.6428E-04 /
      DATA (FOU(I),I=103,105) / 0.1526E-03, 0.6967E-04, 0.7917E-04 /
      DATA (FOU(I),I=106,108) /-0.3070E-02, 0.1678E-02, 0.4865E-03 /
      DATA (FOU(I),I=109,111) / 0.1026E-03,-0.1616E-03, 0.1634E-04 /
      DATA (FOU(I),I=112,114) / 0.1249E-03, 0.1842E-02, 0.2733E-02 /
      DATA (FOU(I),I=115,117) / 0.1411E-03, 0.6037E-03, 0.4278E-04 /
      DATA (FOU(I),I=118,120) / 0.1451E-03,-0.2935E-03, 0.3999E-03 /
      DATA (FOU(I),I=121,123) / 0.1181E-02, 0.7125E-03, 0.1856E-03 /
      DATA (FOU(I),I=124,126) /-0.2080E-03, 0.1141E-03,-0.1112E-03 /
      DATA (FOU(I),I=127,129) /-0.2283E-02, 0.8382E-03,-0.3859E-03 /
      DATA (FOU(I),I=130,132) / 0.2967E-03, 0.3086E-03,-0.2016E-03 /
      DATA (FOU(I),I=133,135) / 0.1117E-03, 0.2809E-03, 0.7145E-03 /
      DATA (FOU(I),I=136,138) / 0.7259E-03,-0.9466E-04, 0.5152E-04 /
      DATA (FOU(I),I=139,141) / 0.1335E-03,-0.1087E-03,-0.1736E-03 /
      DATA (FOU(I),I=142,144) / 0.1499E-02, 0.8562E-03, 0.3646E-03 /
      DATA (FOU(I),I=145,147) / 0.1901E-03, 0.7782E-03, 0.1005E-03 /
      DATA (FOU(I),I=148,150) /-0.2180E-02, 0.6243E-03, 0.3219E-03 /
      DATA (FOU(I),I=151,153) /-0.1443E-03, 0.2749E-03, 0.2023E-03 /
      DATA (FOU(I),I=154,156) /-0.2265E-03, 0.4561E-03, 0.9323E-03 /
      DATA (FOU(I),I=157,159) /-0.5062E-03,-0.1037E-03, 0.2655E-03 /
      DATA (FOU(I),I=160,162) / 0.7146E-04,-0.5285E-04,-0.2600E-03 /
      DATA (FOU(I),I=163,165) / 0.1153E-02, 0.5397E-04, 0.1038E-03 /
      DATA (FOU(I),I=166,168) /-0.8962E-04, 0.2810E-03, 0.1241E-03 /
      DATA (FOU(I),I=169,171) /-0.3306E-02, 0.3404E-03,-0.9425E-03 /
      DATA (FOU(I),I=172,174) /-0.1865E-03, 0.1402E-03, 0.4160E-03 /
      DATA (FOU(I),I=175,177) /-0.3397E-03,-0.1094E-02, 0.1035E-02 /
      DATA (FOU(I),I=178,180) /-0.8637E-03,-0.1164E-03,-0.6449E-04 /
      DATA (FOU(I),I=181,183) /-0.1685E-03,-0.3311E-03, 0.5764E-03 /
      DATA (FOU(I),I=184,186) / 0.1786E-02, 0.2073E-03, 0.2287E-03 /
      DATA (FOU(I),I=187,189) /-0.3776E-03, 0.2592E-03, 0.3101E-03 /
      DATA (FOU(I),I=190,192) /-0.4638E-03, 0.4539E-03,-0.7914E-04 /
      DATA (FOU(I),I=193,195) / 0.3096E-03, 0.5187E-04, 0.3991E-03 /
      DATA (FOU(I),I=196,198) /-0.4484E-04,-0.2650E-03, 0.1128E-02 /
      DATA (FOU(I),I=199,201) / 0.7516E-04,-0.4290E-03,-0.4560E-04 /
      DATA (FOU(I),I=202,204) / 0.1149E-03,-0.2352E-03, 0.2654E-02 /
      DATA (FOU(I),I=205,207) / 0.1032E-04,-0.2194E-03, 0.3131E-03 /
      DATA (FOU(I),I=208,210) /-0.7615E-03,-0.3110E-04,-0.5750E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUL9 = F + RADM
      RETURN
      END
+DECK,RSWULA.
      REAL FUNCTION RSWULA(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     2010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5075E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1666E-02,-0.2742E-03,-0.8332E-04 /
      DATA (FOU(I),I= 19, 21) / 0.3380E-03,-0.1340E-03, 0.1177E-03 /
      DATA (FOU(I),I= 22, 24) /-0.4914E-02, 0.1764E-02, 0.1628E-03 /
      DATA (FOU(I),I= 25, 27) /-0.5476E-04, 0.5141E-03, 0.6992E-05 /
      DATA (FOU(I),I= 28, 30) / 0.7464E-04,-0.3511E-02, 0.1057E-02 /
      DATA (FOU(I),I= 31, 33) / 0.3135E-03, 0.1973E-04, 0.3236E-03 /
      DATA (FOU(I),I= 34, 36) / 0.7166E-04, 0.2187E-03,-0.2922E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1223E-02, 0.5701E-04,-0.3827E-04 /
      DATA (FOU(I),I= 40, 42) / 0.3477E-03, 0.7143E-04, 0.1961E-03 /
      DATA (FOU(I),I= 43, 45) /-0.3473E-02, 0.1302E-02, 0.2202E-03 /
      DATA (FOU(I),I= 46, 48) / 0.1743E-03, 0.3279E-03,-0.3249E-04 /
      DATA (FOU(I),I= 49, 51) / 0.1456E-04,-0.2996E-02, 0.2040E-02 /
      DATA (FOU(I),I= 52, 54) / 0.1595E-03, 0.9957E-04, 0.9867E-04 /
      DATA (FOU(I),I= 55, 57) /-0.3273E-04, 0.7777E-04,-0.2249E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1238E-02, 0.2859E-03, 0.3434E-03 /
      DATA (FOU(I),I= 61, 63) / 0.2656E-03, 0.2370E-03, 0.2033E-04 /
      DATA (FOU(I),I= 64, 66) /-0.1892E-02, 0.2833E-03, 0.1286E-03 /
      DATA (FOU(I),I= 67, 69) / 0.4025E-03, 0.2644E-03, 0.5689E-04 /
      DATA (FOU(I),I= 70, 72) / 0.7898E-04,-0.4852E-03, 0.1103E-02 /
      DATA (FOU(I),I= 73, 75) / 0.1252E-03, 0.2558E-03,-0.5061E-04 /
      DATA (FOU(I),I= 76, 78) / 0.8655E-04,-0.1248E-03,-0.1380E-02 /
      DATA (FOU(I),I= 79, 81) / 0.4639E-03, 0.4722E-03, 0.3404E-03 /
      DATA (FOU(I),I= 82, 84) / 0.6747E-04,-0.1578E-03, 0.6249E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1637E-02, 0.1770E-02, 0.1611E-03 /
      DATA (FOU(I),I= 88, 90) / 0.3629E-03, 0.8482E-04,-0.1415E-03 /
      DATA (FOU(I),I= 91, 93) / 0.1696E-04,-0.8701E-03, 0.1102E-02 /
      DATA (FOU(I),I= 94, 96) / 0.6659E-03, 0.4971E-03,-0.7664E-04 /
      DATA (FOU(I),I= 97, 99) /-0.6423E-04,-0.6267E-04,-0.7806E-03 /
      DATA (FOU(I),I=100,102) / 0.1289E-02, 0.5204E-03, 0.2881E-03 /
      DATA (FOU(I),I=103,105) /-0.1112E-03, 0.1769E-04, 0.2761E-03 /
      DATA (FOU(I),I=106,108) /-0.2250E-02, 0.2019E-02, 0.7006E-03 /
      DATA (FOU(I),I=109,111) /-0.8299E-04, 0.7970E-04,-0.5203E-04 /
      DATA (FOU(I),I=112,114) /-0.5266E-04, 0.1036E-02, 0.1981E-02 /
      DATA (FOU(I),I=115,117) /-0.1292E-03, 0.1210E-03, 0.2055E-03 /
      DATA (FOU(I),I=118,120) /-0.4674E-05,-0.8253E-04,-0.3547E-03 /
      DATA (FOU(I),I=121,123) / 0.1734E-02, 0.3409E-05, 0.2687E-05 /
      DATA (FOU(I),I=124,126) / 0.7693E-04, 0.1845E-03, 0.4045E-04 /
      DATA (FOU(I),I=127,129) /-0.2746E-02, 0.1273E-02, 0.5960E-03 /
      DATA (FOU(I),I=130,132) /-0.9535E-04,-0.1644E-03, 0.8899E-04 /
      DATA (FOU(I),I=133,135) /-0.3015E-04,-0.1211E-02, 0.1346E-02 /
      DATA (FOU(I),I=136,138) / 0.5293E-03, 0.1043E-03,-0.7455E-04 /
      DATA (FOU(I),I=139,141) / 0.2230E-03, 0.5639E-05,-0.2822E-02 /
      DATA (FOU(I),I=142,144) / 0.1421E-02, 0.1877E-03, 0.1638E-03 /
      DATA (FOU(I),I=145,147) /-0.6558E-04, 0.3133E-04,-0.8367E-04 /
      DATA (FOU(I),I=148,150) / 0.9220E-03, 0.2320E-02, 0.7253E-03 /
      DATA (FOU(I),I=151,153) /-0.1429E-03, 0.2861E-03, 0.3252E-03 /
      DATA (FOU(I),I=154,156) / 0.2845E-03,-0.7538E-03, 0.1737E-04 /
      DATA (FOU(I),I=157,159) /-0.3153E-03, 0.7397E-04, 0.5063E-04 /
      DATA (FOU(I),I=160,162) /-0.3160E-03,-0.3613E-03,-0.1211E-02 /
      DATA (FOU(I),I=163,165) / 0.1312E-02, 0.4387E-03, 0.1997E-03 /
      DATA (FOU(I),I=166,168) / 0.1205E-03,-0.6868E-04, 0.1388E-03 /
      DATA (FOU(I),I=169,171) /-0.1253E-02, 0.5863E-03,-0.8433E-03 /
      DATA (FOU(I),I=172,174) /-0.3083E-03,-0.2952E-04, 0.2099E-04 /
      DATA (FOU(I),I=175,177) /-0.5088E-03, 0.1400E-02, 0.1074E-02 /
      DATA (FOU(I),I=178,180) / 0.1442E-03, 0.6973E-03,-0.2073E-03 /
      DATA (FOU(I),I=181,183) / 0.3066E-03,-0.8705E-05, 0.9426E-03 /
      DATA (FOU(I),I=184,186) / 0.9004E-04,-0.2630E-03, 0.8873E-04 /
      DATA (FOU(I),I=187,189) / 0.9945E-04, 0.1337E-03,-0.3814E-03 /
      DATA (FOU(I),I=190,192) /-0.1153E-02, 0.2278E-02,-0.2365E-03 /
      DATA (FOU(I),I=193,195) /-0.1332E-03,-0.4428E-03,-0.1384E-03 /
      DATA (FOU(I),I=196,198) /-0.1278E-03, 0.5397E-03,-0.9930E-04 /
      DATA (FOU(I),I=199,201) /-0.2783E-03, 0.2240E-03, 0.1937E-03 /
      DATA (FOU(I),I=202,204) /-0.4104E-03, 0.2986E-03,-0.7823E-05 /
      DATA (FOU(I),I=205,207) / 0.1014E-02, 0.1253E-03, 0.2306E-03 /
      DATA (FOU(I),I=208,210) / 0.6288E-04,-0.2791E-03,-0.3773E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWULA = F + RADM
      RETURN
      END
+DECK,RSWUR.
      REAL FUNCTION RSWUR(R,EBEAM,IRUN,LUMP)
*
*...RSWUL   smooths radial coordinate
*.
*. SEQUENCE  : RSWUL
*. CALLS     : RSWCAR
*. CALLED    : RSWULx   x=0,A
*.
*. AUTHOR    : D.KELLOGG
*. VERSION   : 1.01
*. CREATED   : 20-apr-97
*.
*. LUMP = .TRUE. means lumped smoothing for year is used
*. LUMP = .FALSE. means smoothing for individual data blocks is used
*.
*. Modification Log.
*. 20-apr-97 recover run 5712 - give good smoothed coordiates, not zero
*.            default to un-smoothed coordinate for unknown data
*
* generates dick kellogg's smoothed coordinates
* from (marco's) dst coordinates
* by first un-doing marcos smoothing
* for the LEFT side
* LUMP = .TRUE. means lumped smoothing for year is used
* LUMP = .FALSE. means smoothing for individual data blocks is used
********************************************************************
+SEQ,DECLARE.
*
      LOGICAL LUMP
*
      REAL RSWUR0,RSWUR1,RSWUR2,RSWUR3,RSWUR4,RSWUR5
      REAL RSWUR6,RSWUR7,RSWUR8,RSWUR9,RSWURA
*
      EXTERNAL RSWUR0,RSWUR1,RSWUR2,RSWUR3,RSWUR4,RSWUR5
      EXTERNAL RSWUR6,RSWUR7,RSWUR8,RSWUR9,RSWURA
*
      REAL R, EBEAM, X, PI, ARG, ARG1, UNDO, RU
      INTEGER IRUN
* undo marco's smoothing
* reference for rope layer 7 z-value in mail from german 19.03.96
      X = R / 246.00225
      PI=3.141592654
      ARG= 2*PI/0.00102
      ARG1=ARG*(X+0.0002)
      UNDO=X-0.071/ARG*COS(ARG1)*(0.03/X)**4
      RU = 246.00225 * UNDO
* default for failure
      RSWUR = RU
* handle 1993 by beam energy
      IF( IRUN .GE. 4035 .AND. IRUN .LT. 5014 ) THEN
       IF(LUMP) THEN
        RSWUR = RSWUR0(RU)
       ELSE
        IF( EBEAM .LT. 45.0 ) THEN
          RSWUR = RSWUR1(RU)
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWUR = RSWUR3(RU)
        ELSE
          RSWUR = RSWUR2(RU)
        ENDIF
       ENDIF
      ENDIF
* handle 1994 by period
      IF( IRUN .GE. 5014 .AND. IRUN .LT. 5195 ) THEN
*         p59 to p60
          RSWUR = RSWUR4(RU)
      ELSEIF( IRUN .GE. 5195 .AND. IRUN .LT. 5600 ) THEN
*         p61 to p67
          RSWUR = RSWUR5(RU)
      ELSEIF( IRUN .GE. 5600 .AND. IRUN .LE. 5712 ) THEN
*         p68
          RSWUR = RSWUR6(RU)
      ENDIF
* handle 1995 by beam energy
      IF( IRUN .GE. 6002 .AND. IRUN .LT. 6604 ) THEN
       IF(LUMP) THEN
        RSWUR = RSWUR7(RU)
       ELSE
        IF( EBEAM .LT. 45.0 ) THEN
          RSWUR = RSWUR8(RU)
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWUR = RSWURA(RU)
        ELSE
          RSWUR = RSWUR9(RU)
        ENDIF
       ENDIF
      ENDIF
      RETURN
      END
+DECK,RSWUR0.
      REAL FUNCTION RSWUR0(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD, I, J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4678E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1004E-02,-0.2078E-04,-0.1440E-03 /
      DATA (FOU(I),I= 19, 21) / 0.2477E-03,-0.4501E-04, 0.3889E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4847E-02, 0.1186E-02, 0.3236E-03 /
      DATA (FOU(I),I= 25, 27) / 0.6594E-04, 0.4004E-03,-0.1726E-04 /
      DATA (FOU(I),I= 28, 30) / 0.7112E-04,-0.4545E-02, 0.1206E-02 /
      DATA (FOU(I),I= 31, 33) / 0.4693E-03,-0.3012E-04, 0.2289E-03 /
      DATA (FOU(I),I= 34, 36) /-0.5092E-06, 0.6791E-04,-0.4541E-02 /
      DATA (FOU(I),I= 37, 39) / 0.8663E-03, 0.4615E-03, 0.2260E-03 /
      DATA (FOU(I),I= 40, 42) / 0.2422E-03,-0.7302E-04, 0.1012E-03 /
      DATA (FOU(I),I= 43, 45) /-0.4373E-02, 0.1210E-02, 0.4579E-03 /
      DATA (FOU(I),I= 46, 48) / 0.1116E-03, 0.2176E-03,-0.9499E-04 /
      DATA (FOU(I),I= 49, 51) / 0.3702E-04,-0.4327E-02, 0.1159E-02 /
      DATA (FOU(I),I= 52, 54) / 0.4796E-03, 0.9705E-05, 0.2329E-03 /
      DATA (FOU(I),I= 55, 57) /-0.1794E-03, 0.4507E-04,-0.4265E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1464E-02, 0.6204E-03, 0.1125E-03 /
      DATA (FOU(I),I= 61, 63) / 0.2005E-03,-0.1073E-03, 0.1004E-03 /
      DATA (FOU(I),I= 64, 66) /-0.2627E-02, 0.1369E-02, 0.1500E-03 /
      DATA (FOU(I),I= 67, 69) / 0.2189E-03,-0.2543E-04,-0.2459E-04 /
      DATA (FOU(I),I= 70, 72) / 0.5322E-04,-0.1242E-02, 0.1353E-02 /
      DATA (FOU(I),I= 73, 75) / 0.2362E-03, 0.4645E-03,-0.7310E-05 /
      DATA (FOU(I),I= 76, 78) /-0.1141E-03, 0.3647E-05,-0.1082E-02 /
      DATA (FOU(I),I= 79, 81) / 0.1429E-02, 0.1761E-03, 0.4542E-03 /
      DATA (FOU(I),I= 82, 84) /-0.1865E-04, 0.1025E-03,-0.7415E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1120E-02, 0.9133E-03, 0.6539E-03 /
      DATA (FOU(I),I= 88, 90) / 0.3432E-03, 0.8030E-05,-0.1049E-03 /
      DATA (FOU(I),I= 91, 93) /-0.3418E-05,-0.1467E-02, 0.1518E-02 /
      DATA (FOU(I),I= 94, 96) / 0.5118E-03, 0.1325E-03,-0.2208E-04 /
      DATA (FOU(I),I= 97, 99) / 0.1028E-03, 0.6967E-04,-0.5779E-03 /
      DATA (FOU(I),I=100,102) / 0.9286E-03, 0.6081E-03, 0.2563E-03 /
      DATA (FOU(I),I=103,105) /-0.1225E-03, 0.1755E-04,-0.2174E-04 /
      DATA (FOU(I),I=106,108) / 0.9313E-03, 0.1493E-02, 0.2821E-03 /
      DATA (FOU(I),I=109,111) / 0.1581E-03, 0.9509E-04,-0.1235E-03 /
      DATA (FOU(I),I=112,114) / 0.4137E-04,-0.1734E-02, 0.7040E-03 /
      DATA (FOU(I),I=115,117) / 0.1792E-03, 0.3733E-03,-0.8460E-04 /
      DATA (FOU(I),I=118,120) /-0.5902E-04,-0.2820E-04, 0.5359E-03 /
      DATA (FOU(I),I=121,123) / 0.9291E-03, 0.5119E-03, 0.2290E-03 /
      DATA (FOU(I),I=124,126) /-0.2060E-03, 0.8573E-04,-0.1073E-03 /
      DATA (FOU(I),I=127,129) /-0.1332E-02, 0.1315E-02, 0.6229E-03 /
      DATA (FOU(I),I=130,132) / 0.8872E-06,-0.1595E-03, 0.4465E-04 /
      DATA (FOU(I),I=133,135) /-0.3883E-04,-0.4856E-04, 0.1160E-02 /
      DATA (FOU(I),I=136,138) / 0.5084E-03, 0.3677E-04,-0.1797E-03 /
      DATA (FOU(I),I=139,141) / 0.1128E-04,-0.1521E-03,-0.1659E-02 /
      DATA (FOU(I),I=142,144) / 0.1206E-02, 0.2647E-03,-0.8079E-04 /
      DATA (FOU(I),I=145,147) /-0.3803E-04, 0.8776E-04,-0.1437E-04 /
      DATA (FOU(I),I=148,150) /-0.3992E-03, 0.1237E-02, 0.1542E-03 /
      DATA (FOU(I),I=151,153) / 0.7748E-04,-0.9542E-04, 0.2105E-03 /
      DATA (FOU(I),I=154,156) /-0.1017E-03,-0.8673E-03, 0.1774E-02 /
      DATA (FOU(I),I=157,159) /-0.9412E-04,-0.3956E-04,-0.7971E-04 /
      DATA (FOU(I),I=160,162) / 0.1111E-03, 0.1995E-04,-0.1152E-02 /
      DATA (FOU(I),I=163,165) / 0.1024E-02, 0.6470E-04,-0.1588E-03 /
      DATA (FOU(I),I=166,168) /-0.1634E-03, 0.7784E-04,-0.5208E-05 /
      DATA (FOU(I),I=169,171) /-0.1070E-02, 0.1429E-02, 0.1217E-03 /
      DATA (FOU(I),I=172,174) / 0.1296E-03,-0.1225E-03,-0.7880E-04 /
      DATA (FOU(I),I=175,177) /-0.6790E-04, 0.6359E-03, 0.1057E-02 /
      DATA (FOU(I),I=178,180) /-0.1680E-03, 0.1088E-03, 0.8036E-05 /
      DATA (FOU(I),I=181,183) / 0.1733E-03,-0.1845E-03,-0.1380E-03 /
      DATA (FOU(I),I=184,186) / 0.9033E-03,-0.1446E-03,-0.5406E-04 /
      DATA (FOU(I),I=187,189) /-0.6341E-04, 0.1183E-03,-0.7590E-04 /
      DATA (FOU(I),I=190,192) / 0.9518E-03, 0.1666E-02, 0.3903E-03 /
      DATA (FOU(I),I=193,195) /-0.1826E-03, 0.1261E-03,-0.9093E-04 /
      DATA (FOU(I),I=196,198) /-0.4557E-04,-0.6204E-03, 0.1042E-02 /
      DATA (FOU(I),I=199,201) /-0.1199E-03,-0.1742E-03, 0.1580E-03 /
      DATA (FOU(I),I=202,204) / 0.8187E-04,-0.1279E-03,-0.4324E-03 /
      DATA (FOU(I),I=205,207) / 0.1580E-02,-0.1338E-03, 0.6902E-04 /
      DATA (FOU(I),I=208,210) /-0.1736E-04, 0.4276E-05, 0.1456E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR0 = F + RADM
      RETURN
      END
+DECK,RSWUR1.
      REAL FUNCTION RSWUR1(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5164E-02 /
      DATA (FOU(I),I= 16, 18) / 0.9026E-03,-0.7810E-04,-0.1214E-03 /
      DATA (FOU(I),I= 19, 21) / 0.2994E-03,-0.2665E-04, 0.3827E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4770E-02, 0.1384E-02, 0.4218E-03 /
      DATA (FOU(I),I= 25, 27) / 0.2092E-04, 0.2778E-03,-0.1444E-04 /
      DATA (FOU(I),I= 28, 30) /-0.8580E-05,-0.4246E-02, 0.1244E-02 /
      DATA (FOU(I),I= 31, 33) / 0.3011E-03, 0.1870E-03, 0.1816E-03 /
      DATA (FOU(I),I= 34, 36) / 0.7147E-04, 0.1542E-03,-0.3919E-02 /
      DATA (FOU(I),I= 37, 39) / 0.8684E-03, 0.3635E-03, 0.3247E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1286E-03,-0.1228E-03, 0.1202E-03 /
      DATA (FOU(I),I= 43, 45) /-0.4522E-02, 0.1081E-02, 0.5500E-03 /
      DATA (FOU(I),I= 46, 48) / 0.1872E-03, 0.3094E-03,-0.1036E-04 /
      DATA (FOU(I),I= 49, 51) / 0.1829E-04,-0.4253E-02, 0.1272E-02 /
      DATA (FOU(I),I= 52, 54) / 0.1608E-03,-0.1967E-03, 0.7204E-04 /
      DATA (FOU(I),I= 55, 57) /-0.9293E-04, 0.4472E-04,-0.3448E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1210E-02, 0.5734E-03,-0.1333E-03 /
      DATA (FOU(I),I= 61, 63) / 0.1238E-03,-0.1930E-03, 0.1898E-03 /
      DATA (FOU(I),I= 64, 66) /-0.3168E-02, 0.1007E-02, 0.1400E-03 /
      DATA (FOU(I),I= 67, 69) / 0.3906E-03,-0.1291E-03, 0.3992E-04 /
      DATA (FOU(I),I= 70, 72) / 0.1292E-03,-0.2163E-02, 0.1226E-02 /
      DATA (FOU(I),I= 73, 75) / 0.1853E-03, 0.3378E-03,-0.2112E-04 /
      DATA (FOU(I),I= 76, 78) /-0.8449E-04, 0.9105E-05,-0.5919E-03 /
      DATA (FOU(I),I= 79, 81) / 0.1352E-02, 0.1278E-03, 0.3971E-03 /
      DATA (FOU(I),I= 82, 84) /-0.1695E-03, 0.9990E-04,-0.5857E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1715E-02, 0.9476E-03, 0.6590E-03 /
      DATA (FOU(I),I= 88, 90) / 0.2206E-03, 0.4566E-04,-0.1795E-03 /
      DATA (FOU(I),I= 91, 93) /-0.9400E-04,-0.1098E-02, 0.1241E-02 /
      DATA (FOU(I),I= 94, 96) / 0.4985E-03, 0.8369E-04, 0.1886E-03 /
      DATA (FOU(I),I= 97, 99) / 0.1710E-03, 0.4733E-04,-0.2005E-02 /
      DATA (FOU(I),I=100,102) / 0.1676E-02, 0.5441E-03, 0.3586E-03 /
      DATA (FOU(I),I=103,105) /-0.1321E-03,-0.1111E-03, 0.7064E-04 /
      DATA (FOU(I),I=106,108) / 0.1726E-02, 0.1247E-02, 0.8351E-04 /
      DATA (FOU(I),I=109,111) /-0.1166E-03, 0.8280E-04,-0.1094E-03 /
      DATA (FOU(I),I=112,114) /-0.4215E-04,-0.1792E-02, 0.8685E-03 /
      DATA (FOU(I),I=115,117) / 0.1602E-03, 0.3949E-03,-0.7898E-04 /
      DATA (FOU(I),I=118,120) /-0.1188E-03, 0.7493E-05, 0.1464E-02 /
      DATA (FOU(I),I=121,123) / 0.6966E-03, 0.3936E-03,-0.1106E-03 /
      DATA (FOU(I),I=124,126) /-0.1625E-03, 0.1844E-03, 0.2227E-04 /
      DATA (FOU(I),I=127,129) /-0.2409E-02, 0.1082E-02, 0.6747E-03 /
      DATA (FOU(I),I=130,132) / 0.1799E-03, 0.3983E-04, 0.2994E-04 /
      DATA (FOU(I),I=133,135) / 0.5030E-04,-0.1251E-02, 0.1356E-02 /
      DATA (FOU(I),I=136,138) / 0.4105E-03,-0.1824E-03,-0.2744E-03 /
      DATA (FOU(I),I=139,141) / 0.6005E-04,-0.2751E-03,-0.1738E-02 /
      DATA (FOU(I),I=142,144) / 0.9377E-03,-0.1147E-03, 0.9628E-04 /
      DATA (FOU(I),I=145,147) / 0.6497E-04, 0.9435E-04,-0.4848E-04 /
      DATA (FOU(I),I=148,150) / 0.9569E-03, 0.1035E-02, 0.1425E-03 /
      DATA (FOU(I),I=151,153) / 0.2999E-03,-0.1615E-03, 0.2011E-03 /
      DATA (FOU(I),I=154,156) /-0.1765E-04,-0.8341E-03, 0.1680E-02 /
      DATA (FOU(I),I=157,159) /-0.6982E-03,-0.3468E-04,-0.3382E-03 /
      DATA (FOU(I),I=160,162) /-0.3403E-04,-0.1604E-03,-0.5337E-03 /
      DATA (FOU(I),I=163,165) / 0.1121E-02, 0.1404E-03,-0.2819E-03 /
      DATA (FOU(I),I=166,168) /-0.1978E-03, 0.1527E-03,-0.1136E-03 /
      DATA (FOU(I),I=169,171) /-0.2058E-02, 0.1445E-02, 0.2174E-03 /
      DATA (FOU(I),I=172,174) / 0.4072E-04,-0.1643E-04, 0.1856E-04 /
      DATA (FOU(I),I=175,177) /-0.4859E-04, 0.1032E-02, 0.9089E-03 /
      DATA (FOU(I),I=178,180) / 0.5749E-04, 0.3094E-03,-0.2086E-04 /
      DATA (FOU(I),I=181,183) / 0.1985E-03,-0.6318E-04, 0.1046E-02 /
      DATA (FOU(I),I=184,186) / 0.4448E-03,-0.3976E-04,-0.5653E-04 /
      DATA (FOU(I),I=187,189) /-0.1018E-03, 0.2983E-03,-0.1635E-03 /
      DATA (FOU(I),I=190,192) / 0.8158E-03, 0.1938E-02, 0.1967E-03 /
      DATA (FOU(I),I=193,195) / 0.1905E-03, 0.2431E-03,-0.4696E-03 /
      DATA (FOU(I),I=196,198) /-0.1232E-03, 0.5848E-03, 0.1575E-02 /
      DATA (FOU(I),I=199,201) / 0.4821E-04,-0.4725E-03, 0.1571E-03 /
      DATA (FOU(I),I=202,204) /-0.5679E-04, 0.3080E-06,-0.6726E-03 /
      DATA (FOU(I),I=205,207) / 0.1942E-02, 0.1081E-02,-0.5703E-04 /
      DATA (FOU(I),I=208,210) /-0.2246E-03, 0.1797E-03,-0.1345E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR1 = F + RADM
      RETURN
      END
+DECK,RSWUR2.
      REAL FUNCTION RSWUR2(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4280E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1114E-02,-0.1551E-03,-0.2237E-03 /
      DATA (FOU(I),I= 19, 21) / 0.1025E-03, 0.1451E-04, 0.9157E-05 /
      DATA (FOU(I),I= 22, 24) /-0.4299E-02, 0.1104E-02, 0.1620E-03 /
      DATA (FOU(I),I= 25, 27) / 0.1541E-03, 0.4263E-03,-0.3930E-04 /
      DATA (FOU(I),I= 28, 30) / 0.7299E-04,-0.4851E-02, 0.1120E-02 /
      DATA (FOU(I),I= 31, 33) / 0.8119E-03,-0.1984E-03, 0.2605E-03 /
      DATA (FOU(I),I= 34, 36) /-0.1383E-03, 0.1281E-03,-0.5101E-02 /
      DATA (FOU(I),I= 37, 39) / 0.5316E-03, 0.4530E-03, 0.1493E-03 /
      DATA (FOU(I),I= 40, 42) / 0.3636E-03,-0.1046E-03, 0.1143E-03 /
      DATA (FOU(I),I= 43, 45) /-0.4605E-02, 0.1370E-02, 0.2386E-03 /
      DATA (FOU(I),I= 46, 48) / 0.1336E-03, 0.1919E-03,-0.1509E-03 /
      DATA (FOU(I),I= 49, 51) / 0.8068E-04,-0.4176E-02, 0.9971E-03 /
      DATA (FOU(I),I= 52, 54) / 0.6211E-03, 0.1240E-03, 0.2912E-03 /
      DATA (FOU(I),I= 55, 57) /-0.2093E-03, 0.5305E-04,-0.4367E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1315E-02, 0.7128E-03, 0.3073E-03 /
      DATA (FOU(I),I= 61, 63) / 0.2504E-03,-0.6062E-04, 0.4761E-04 /
      DATA (FOU(I),I= 64, 66) /-0.2859E-02, 0.1609E-02, 0.2447E-03 /
      DATA (FOU(I),I= 67, 69) / 0.2707E-03, 0.4971E-04,-0.5365E-04 /
      DATA (FOU(I),I= 70, 72) /-0.1570E-04,-0.1186E-02, 0.1552E-02 /
      DATA (FOU(I),I= 73, 75) / 0.3148E-03, 0.6828E-03,-0.1572E-04 /
      DATA (FOU(I),I= 76, 78) /-0.1569E-03, 0.2021E-04,-0.1083E-02 /
      DATA (FOU(I),I= 79, 81) / 0.1906E-02, 0.5794E-04, 0.7011E-03 /
      DATA (FOU(I),I= 82, 84) / 0.2512E-04, 0.1798E-03,-0.1996E-03 /
      DATA (FOU(I),I= 85, 87) /-0.1756E-02, 0.7849E-03, 0.6505E-03 /
      DATA (FOU(I),I= 88, 90) / 0.2661E-03, 0.8448E-05, 0.2316E-04 /
      DATA (FOU(I),I= 91, 93) /-0.3679E-04,-0.1505E-02, 0.1413E-02 /
      DATA (FOU(I),I= 94, 96) / 0.8055E-03, 0.2159E-03, 0.2673E-04 /
      DATA (FOU(I),I= 97, 99) / 0.5340E-04, 0.2373E-04, 0.3799E-04 /
      DATA (FOU(I),I=100,102) / 0.3577E-03, 0.6578E-03, 0.2095E-03 /
      DATA (FOU(I),I=103,105) /-0.1274E-04,-0.9927E-05,-0.6611E-04 /
      DATA (FOU(I),I=106,108) / 0.6646E-03, 0.1482E-02,-0.8607E-04 /
      DATA (FOU(I),I=109,111) / 0.3143E-03, 0.3174E-04,-0.1275E-03 /
      DATA (FOU(I),I=112,114) / 0.4146E-04,-0.2064E-02, 0.5902E-03 /
      DATA (FOU(I),I=115,117) / 0.5328E-04, 0.4157E-03,-0.1520E-03 /
      DATA (FOU(I),I=118,120) /-0.2735E-04,-0.1481E-03, 0.2435E-03 /
      DATA (FOU(I),I=121,123) / 0.7385E-03, 0.6168E-03, 0.2737E-03 /
      DATA (FOU(I),I=124,126) /-0.3503E-03, 0.1773E-03,-0.1128E-03 /
      DATA (FOU(I),I=127,129) / 0.2373E-03, 0.1331E-02, 0.5162E-03 /
      DATA (FOU(I),I=130,132) /-0.1110E-03,-0.2238E-03, 0.2194E-04 /
      DATA (FOU(I),I=133,135) /-0.2078E-04, 0.3721E-03, 0.8744E-03 /
      DATA (FOU(I),I=136,138) / 0.7664E-03, 0.4011E-04,-0.3600E-04 /
      DATA (FOU(I),I=139,141) / 0.2710E-03,-0.1232E-03,-0.2204E-02 /
      DATA (FOU(I),I=142,144) / 0.1332E-02, 0.3927E-03,-0.2734E-03 /
      DATA (FOU(I),I=145,147) /-0.2711E-03, 0.2262E-03, 0.8476E-04 /
      DATA (FOU(I),I=148,150) /-0.1828E-02, 0.1158E-02, 0.1436E-03 /
      DATA (FOU(I),I=151,153) / 0.2959E-03,-0.2157E-05, 0.2008E-03 /
      DATA (FOU(I),I=154,156) /-0.1712E-03, 0.1526E-03, 0.1536E-02 /
      DATA (FOU(I),I=157,159) / 0.1116E-03, 0.3522E-03,-0.1369E-03 /
      DATA (FOU(I),I=160,162) / 0.2184E-03,-0.4885E-04,-0.1414E-02 /
      DATA (FOU(I),I=163,165) / 0.9835E-03, 0.1485E-03,-0.2528E-03 /
      DATA (FOU(I),I=166,168) /-0.3281E-03,-0.7473E-04, 0.1374E-03 /
      DATA (FOU(I),I=169,171) /-0.5635E-03, 0.1662E-02, 0.1118E-03 /
      DATA (FOU(I),I=172,174) / 0.2423E-03,-0.1278E-03,-0.1664E-03 /
      DATA (FOU(I),I=175,177) /-0.2257E-03, 0.4001E-03, 0.5784E-03 /
      DATA (FOU(I),I=178,180) / 0.7287E-04,-0.1822E-03,-0.1905E-03 /
      DATA (FOU(I),I=181,183) / 0.1515E-03,-0.2060E-03,-0.3752E-03 /
      DATA (FOU(I),I=184,186) / 0.9855E-03,-0.3904E-03, 0.9792E-04 /
      DATA (FOU(I),I=187,189) /-0.2207E-03, 0.3558E-04,-0.3906E-04 /
      DATA (FOU(I),I=190,192) / 0.2589E-02, 0.1755E-02, 0.7052E-03 /
      DATA (FOU(I),I=193,195) /-0.2317E-03, 0.6642E-04, 0.9123E-04 /
      DATA (FOU(I),I=196,198) /-0.7633E-04,-0.8711E-03, 0.3472E-03 /
      DATA (FOU(I),I=199,201) /-0.1040E-03,-0.1803E-03, 0.4347E-03 /
      DATA (FOU(I),I=202,204) /-0.2777E-05,-0.3196E-04, 0.1647E-02 /
      DATA (FOU(I),I=205,207) / 0.1367E-02,-0.5295E-03, 0.2847E-03 /
      DATA (FOU(I),I=208,210) /-0.2399E-04, 0.7839E-04,-0.1154E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR2 = F + RADM
      RETURN
      END
+DECK,RSWUR3.
      REAL FUNCTION RSWUR3(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4608E-02 /
      DATA (FOU(I),I= 16, 18) / 0.9887E-03, 0.1869E-03,-0.7997E-04 /
      DATA (FOU(I),I= 19, 21) / 0.3541E-03,-0.1302E-03, 0.7238E-04 /
      DATA (FOU(I),I= 22, 24) /-0.5536E-02, 0.1071E-02, 0.4025E-03 /
      DATA (FOU(I),I= 25, 27) / 0.1444E-04, 0.4979E-03, 0.4780E-05 /
      DATA (FOU(I),I= 28, 30) / 0.1517E-03,-0.4521E-02, 0.1263E-02 /
      DATA (FOU(I),I= 31, 33) / 0.2694E-03,-0.6956E-04, 0.2419E-03 /
      DATA (FOU(I),I= 34, 36) / 0.7599E-04,-0.8647E-04,-0.4568E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1236E-02, 0.5725E-03, 0.2071E-03 /
      DATA (FOU(I),I= 40, 42) / 0.2260E-03, 0.1433E-04, 0.6718E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3960E-02, 0.1168E-02, 0.6045E-03 /
      DATA (FOU(I),I= 46, 48) / 0.8021E-05, 0.1506E-03,-0.1214E-03 /
      DATA (FOU(I),I= 49, 51) / 0.8094E-05,-0.4571E-02, 0.1223E-02 /
      DATA (FOU(I),I= 52, 54) / 0.6522E-03, 0.9513E-04, 0.3351E-03 /
      DATA (FOU(I),I= 55, 57) /-0.2345E-03, 0.3691E-04,-0.5001E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1891E-02, 0.5654E-03, 0.1545E-03 /
      DATA (FOU(I),I= 61, 63) / 0.2245E-03,-0.6968E-04, 0.6519E-04 /
      DATA (FOU(I),I= 64, 66) /-0.1791E-02, 0.1482E-02, 0.5098E-04 /
      DATA (FOU(I),I= 67, 69) /-0.2055E-04, 0.3596E-06,-0.5922E-04 /
      DATA (FOU(I),I= 70, 72) / 0.4939E-04,-0.3511E-03, 0.1267E-02 /
      DATA (FOU(I),I= 73, 75) / 0.2029E-03, 0.3540E-03, 0.1514E-04 /
      DATA (FOU(I),I= 76, 78) /-0.9766E-04,-0.2016E-04,-0.1588E-02 /
      DATA (FOU(I),I= 79, 81) / 0.9860E-03, 0.3561E-03, 0.2424E-03 /
      DATA (FOU(I),I= 82, 84) / 0.9036E-04, 0.1970E-04, 0.4674E-04 /
      DATA (FOU(I),I= 85, 87) / 0.1949E-03, 0.1019E-02, 0.6536E-03 /
      DATA (FOU(I),I= 88, 90) / 0.5555E-03,-0.3107E-04,-0.1699E-03 /
      DATA (FOU(I),I= 91, 93) / 0.1265E-03,-0.1810E-02, 0.1924E-02 /
      DATA (FOU(I),I= 94, 96) / 0.2014E-03, 0.8910E-04,-0.2965E-03 /
      DATA (FOU(I),I= 97, 99) / 0.8617E-04, 0.1451E-03, 0.2134E-03 /
      DATA (FOU(I),I=100,102) / 0.7890E-03, 0.6177E-03, 0.2021E-03 /
      DATA (FOU(I),I=103,105) /-0.2342E-03, 0.1803E-03,-0.6764E-04 /
      DATA (FOU(I),I=106,108) / 0.4051E-03, 0.1763E-02, 0.8969E-03 /
      DATA (FOU(I),I=109,111) / 0.2685E-03, 0.1779E-03,-0.1329E-03 /
      DATA (FOU(I),I=112,114) / 0.1268E-03,-0.1309E-02, 0.6603E-03 /
      DATA (FOU(I),I=115,117) / 0.3381E-03, 0.3049E-03,-0.1512E-04 /
      DATA (FOU(I),I=118,120) /-0.3148E-04, 0.6816E-04,-0.1027E-03 /
      DATA (FOU(I),I=121,123) / 0.1378E-02, 0.5168E-03, 0.5345E-03 /
      DATA (FOU(I),I=124,126) /-0.9204E-04,-0.1161E-03,-0.2371E-03 /
      DATA (FOU(I),I=127,129) /-0.1957E-02, 0.1537E-02, 0.6922E-03 /
      DATA (FOU(I),I=130,132) /-0.6154E-04,-0.2963E-03, 0.8414E-04 /
      DATA (FOU(I),I=133,135) /-0.1507E-03, 0.7412E-03, 0.1271E-02 /
      DATA (FOU(I),I=136,138) / 0.3225E-03, 0.2625E-03,-0.2400E-03 /
      DATA (FOU(I),I=139,141) /-0.3239E-03,-0.5658E-04,-0.9770E-03 /
      DATA (FOU(I),I=142,144) / 0.1334E-02, 0.5125E-03,-0.4965E-04 /
      DATA (FOU(I),I=145,147) / 0.1170E-03,-0.7245E-04,-0.9021E-04 /
      DATA (FOU(I),I=148,150) /-0.2305E-03, 0.1550E-02, 0.1782E-03 /
      DATA (FOU(I),I=151,153) /-0.4176E-03,-0.1291E-03, 0.2347E-03 /
      DATA (FOU(I),I=154,156) /-0.1134E-03,-0.2040E-02, 0.2136E-02 /
      DATA (FOU(I),I=157,159) / 0.3013E-03,-0.4785E-03, 0.2517E-03 /
      DATA (FOU(I),I=160,162) / 0.1439E-03, 0.2865E-03,-0.1493E-02 /
      DATA (FOU(I),I=163,165) / 0.9712E-03,-0.1070E-03, 0.7092E-04 /
      DATA (FOU(I),I=166,168) / 0.5170E-04, 0.1711E-03,-0.4861E-04 /
      DATA (FOU(I),I=169,171) /-0.5966E-03, 0.1152E-02, 0.2986E-04 /
      DATA (FOU(I),I=172,174) / 0.9925E-04,-0.2262E-03,-0.8466E-04 /
      DATA (FOU(I),I=175,177) / 0.8809E-04, 0.4878E-03, 0.1744E-02 /
      DATA (FOU(I),I=178,180) /-0.6732E-03, 0.2267E-03, 0.2598E-03 /
      DATA (FOU(I),I=181,183) / 0.1719E-03,-0.2858E-03,-0.1117E-02 /
      DATA (FOU(I),I=184,186) / 0.1293E-02, 0.2345E-04,-0.2259E-03 /
      DATA (FOU(I),I=187,189) / 0.1525E-03, 0.2267E-04,-0.2319E-04 /
      DATA (FOU(I),I=190,192) /-0.7170E-03, 0.1290E-02, 0.2355E-03 /
      DATA (FOU(I),I=193,195) /-0.5058E-03, 0.7524E-04, 0.9117E-04 /
      DATA (FOU(I),I=196,198) / 0.6571E-04,-0.1614E-02, 0.1257E-02 /
      DATA (FOU(I),I=199,201) /-0.3092E-03, 0.1438E-03,-0.1494E-03 /
      DATA (FOU(I),I=202,204) / 0.3218E-03,-0.3689E-03,-0.2388E-02 /
      DATA (FOU(I),I=205,207) / 0.1458E-02,-0.9960E-03,-0.4282E-04 /
      DATA (FOU(I),I=208,210) / 0.2280E-03,-0.2676E-03, 0.5791E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR3 = F + RADM
      RETURN
      END
+DECK,RSWUR4.
      REAL FUNCTION RSWUR4(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4767E-02 /
      DATA (FOU(I),I= 16, 18) / 0.7950E-03, 0.1349E-03,-0.2471E-03 /
      DATA (FOU(I),I= 19, 21) / 0.4550E-03,-0.9570E-04, 0.5112E-04 /
      DATA (FOU(I),I= 22, 24) /-0.5294E-02, 0.1266E-02, 0.5653E-03 /
      DATA (FOU(I),I= 25, 27) /-0.2529E-04, 0.2515E-03,-0.1010E-03 /
      DATA (FOU(I),I= 28, 30) / 0.8516E-04,-0.5047E-02, 0.1122E-02 /
      DATA (FOU(I),I= 31, 33) / 0.5474E-03, 0.1536E-03, 0.3611E-03 /
      DATA (FOU(I),I= 34, 36) /-0.1325E-04, 0.1438E-04,-0.4389E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1120E-02, 0.5042E-03, 0.1362E-04 /
      DATA (FOU(I),I= 40, 42) / 0.2940E-03, 0.3038E-04,-0.3484E-04 /
      DATA (FOU(I),I= 43, 45) /-0.4690E-02, 0.1267E-02, 0.6768E-03 /
      DATA (FOU(I),I= 46, 48) / 0.5935E-04, 0.9383E-04,-0.7628E-04 /
      DATA (FOU(I),I= 49, 51) / 0.1438E-03,-0.5039E-02, 0.1219E-02 /
      DATA (FOU(I),I= 52, 54) / 0.7518E-03,-0.2291E-04, 0.1804E-03 /
      DATA (FOU(I),I= 55, 57) / 0.5660E-04, 0.2538E-03,-0.5813E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1314E-02, 0.4550E-03, 0.2140E-03 /
      DATA (FOU(I),I= 61, 63) / 0.7059E-04,-0.1793E-03,-0.9198E-05 /
      DATA (FOU(I),I= 64, 66) /-0.2541E-02, 0.8960E-03, 0.2306E-03 /
      DATA (FOU(I),I= 67, 69) / 0.1316E-03,-0.3256E-04,-0.2289E-03 /
      DATA (FOU(I),I= 70, 72) /-0.4820E-04,-0.1102E-02, 0.7210E-03 /
      DATA (FOU(I),I= 73, 75) / 0.6959E-03, 0.2393E-03, 0.8176E-04 /
      DATA (FOU(I),I= 76, 78) /-0.1132E-03,-0.1360E-04,-0.2505E-02 /
      DATA (FOU(I),I= 79, 81) / 0.5612E-03, 0.6820E-03, 0.8522E-04 /
      DATA (FOU(I),I= 82, 84) / 0.1832E-03,-0.1940E-03, 0.6691E-04 /
      DATA (FOU(I),I= 85, 87) /-0.6121E-03, 0.6032E-03, 0.6820E-03 /
      DATA (FOU(I),I= 88, 90) / 0.4705E-04, 0.8582E-04,-0.2179E-03 /
      DATA (FOU(I),I= 91, 93) / 0.2129E-06,-0.8357E-03, 0.1163E-02 /
      DATA (FOU(I),I= 94, 96) / 0.5129E-03, 0.5240E-03, 0.1458E-03 /
      DATA (FOU(I),I= 97, 99) / 0.3028E-03,-0.7752E-04,-0.1143E-02 /
      DATA (FOU(I),I=100,102) / 0.1472E-02,-0.1807E-03, 0.2992E-03 /
      DATA (FOU(I),I=103,105) /-0.1590E-03,-0.5720E-04, 0.4740E-04 /
      DATA (FOU(I),I=106,108) / 0.2245E-02, 0.9938E-03, 0.1502E-03 /
      DATA (FOU(I),I=109,111) / 0.6162E-04, 0.7582E-04,-0.2883E-03 /
      DATA (FOU(I),I=112,114) /-0.1544E-03,-0.4994E-03, 0.1714E-02 /
      DATA (FOU(I),I=115,117) / 0.6195E-04, 0.1013E-03, 0.1258E-03 /
      DATA (FOU(I),I=118,120) / 0.5571E-04, 0.1772E-05,-0.1650E-02 /
      DATA (FOU(I),I=121,123) / 0.8595E-03, 0.1822E-03, 0.3313E-03 /
      DATA (FOU(I),I=124,126) /-0.6226E-04, 0.1423E-03, 0.1429E-03 /
      DATA (FOU(I),I=127,129) / 0.6703E-03, 0.1112E-03, 0.7293E-03 /
      DATA (FOU(I),I=130,132) / 0.3261E-03, 0.2266E-03, 0.7677E-04 /
      DATA (FOU(I),I=133,135) /-0.2280E-03,-0.9593E-03, 0.1367E-02 /
      DATA (FOU(I),I=136,138) / 0.2507E-03, 0.2911E-04,-0.8368E-04 /
      DATA (FOU(I),I=139,141) /-0.2486E-03,-0.2621E-03,-0.1157E-03 /
      DATA (FOU(I),I=142,144) /-0.3200E-03, 0.3205E-04,-0.1989E-03 /
      DATA (FOU(I),I=145,147) /-0.2317E-03,-0.4322E-04, 0.1522E-03 /
      DATA (FOU(I),I=148,150) /-0.2276E-03, 0.1031E-02, 0.1180E-03 /
      DATA (FOU(I),I=151,153) /-0.2632E-03,-0.7321E-04, 0.2026E-04 /
      DATA (FOU(I),I=154,156) /-0.3790E-03,-0.1202E-02, 0.3248E-03 /
      DATA (FOU(I),I=157,159) /-0.2058E-04,-0.1694E-03,-0.2950E-04 /
      DATA (FOU(I),I=160,162) / 0.1722E-04,-0.2729E-04, 0.8878E-03 /
      DATA (FOU(I),I=163,165) / 0.2005E-02, 0.8023E-03,-0.5727E-05 /
      DATA (FOU(I),I=166,168) / 0.3305E-03, 0.2999E-04,-0.2511E-03 /
      DATA (FOU(I),I=169,171) / 0.5284E-03, 0.1045E-02,-0.1532E-04 /
      DATA (FOU(I),I=172,174) / 0.2131E-03,-0.2011E-03,-0.9141E-04 /
      DATA (FOU(I),I=175,177) /-0.9495E-04, 0.1173E-02, 0.1566E-02 /
      DATA (FOU(I),I=178,180) / 0.8092E-03,-0.3477E-03, 0.9689E-04 /
      DATA (FOU(I),I=181,183) /-0.1162E-04, 0.1639E-03, 0.3770E-03 /
      DATA (FOU(I),I=184,186) / 0.4163E-03, 0.1776E-03,-0.3711E-03 /
      DATA (FOU(I),I=187,189) / 0.2195E-03, 0.2289E-03,-0.2252E-03 /
      DATA (FOU(I),I=190,192) / 0.9343E-03, 0.1249E-02, 0.6658E-04 /
      DATA (FOU(I),I=193,195) / 0.7913E-04, 0.4573E-03,-0.1256E-03 /
      DATA (FOU(I),I=196,198) / 0.2566E-03,-0.5250E-03, 0.2790E-02 /
      DATA (FOU(I),I=199,201) /-0.1731E-03, 0.2510E-03, 0.2546E-03 /
      DATA (FOU(I),I=202,204) /-0.3369E-03,-0.1760E-03,-0.1333E-02 /
      DATA (FOU(I),I=205,207) / 0.8564E-03,-0.1108E-03,-0.2720E-03 /
      DATA (FOU(I),I=208,210) / 0.1282E-03, 0.2238E-03, 0.5252E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR4 = F + RADM
      RETURN
      END
+DECK,RSWUR5.
      REAL FUNCTION RSWUR5(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4361E-02 /
      DATA (FOU(I),I= 16, 18) / 0.9679E-03, 0.8156E-04,-0.1290E-04 /
      DATA (FOU(I),I= 19, 21) / 0.3982E-03,-0.1218E-04, 0.3069E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4692E-02, 0.1220E-02, 0.3028E-03 /
      DATA (FOU(I),I= 25, 27) / 0.3400E-04, 0.3310E-03,-0.7187E-04 /
      DATA (FOU(I),I= 28, 30) / 0.2622E-04,-0.4478E-02, 0.1179E-02 /
      DATA (FOU(I),I= 31, 33) / 0.4680E-03, 0.9907E-04, 0.2429E-03 /
      DATA (FOU(I),I= 34, 36) /-0.9380E-04, 0.8164E-04,-0.4536E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1114E-02, 0.4335E-03, 0.1311E-03 /
      DATA (FOU(I),I= 40, 42) / 0.2781E-03, 0.3028E-04, 0.6642E-04 /
      DATA (FOU(I),I= 43, 45) /-0.4218E-02, 0.1338E-02, 0.6438E-03 /
      DATA (FOU(I),I= 46, 48) / 0.4464E-04, 0.1241E-03,-0.1205E-03 /
      DATA (FOU(I),I= 49, 51) / 0.8657E-04,-0.4057E-02, 0.1384E-02 /
      DATA (FOU(I),I= 52, 54) / 0.5282E-03, 0.1205E-03, 0.2260E-03 /
      DATA (FOU(I),I= 55, 57) /-0.9425E-04, 0.7055E-04,-0.4327E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1244E-02, 0.7866E-03, 0.2231E-04 /
      DATA (FOU(I),I= 61, 63) / 0.2328E-03, 0.4967E-05, 0.8227E-05 /
      DATA (FOU(I),I= 64, 66) /-0.2391E-02, 0.9707E-03, 0.3594E-03 /
      DATA (FOU(I),I= 67, 69) / 0.3644E-03, 0.7884E-04,-0.3672E-04 /
      DATA (FOU(I),I= 70, 72) /-0.2606E-04,-0.1324E-02, 0.1275E-02 /
      DATA (FOU(I),I= 73, 75) / 0.3472E-03, 0.5046E-03, 0.5979E-05 /
      DATA (FOU(I),I= 76, 78) /-0.1787E-04,-0.8841E-05,-0.1205E-02 /
      DATA (FOU(I),I= 79, 81) / 0.9125E-03, 0.3726E-03, 0.3702E-03 /
      DATA (FOU(I),I= 82, 84) /-0.3425E-04,-0.4542E-04, 0.3901E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1763E-02, 0.1220E-02, 0.5209E-03 /
      DATA (FOU(I),I= 88, 90) / 0.2264E-03,-0.5629E-04,-0.6033E-04 /
      DATA (FOU(I),I= 91, 93) / 0.2612E-04,-0.1366E-02, 0.8281E-03 /
      DATA (FOU(I),I= 94, 96) / 0.5934E-03, 0.1987E-03,-0.1085E-03 /
      DATA (FOU(I),I= 97, 99) / 0.4263E-04,-0.4406E-04,-0.9946E-03 /
      DATA (FOU(I),I=100,102) / 0.1359E-02, 0.5650E-03, 0.2258E-03 /
      DATA (FOU(I),I=103,105) /-0.3966E-04, 0.1858E-03, 0.2587E-04 /
      DATA (FOU(I),I=106,108) / 0.1605E-02, 0.7814E-03, 0.4073E-03 /
      DATA (FOU(I),I=109,111) / 0.4013E-03,-0.6875E-04,-0.7852E-04 /
      DATA (FOU(I),I=112,114) /-0.9621E-05,-0.2590E-02, 0.1166E-02 /
      DATA (FOU(I),I=115,117) / 0.3783E-03, 0.1610E-03,-0.3387E-04 /
      DATA (FOU(I),I=118,120) / 0.6754E-04,-0.9056E-04,-0.3196E-03 /
      DATA (FOU(I),I=121,123) / 0.6775E-03, 0.2870E-03, 0.2611E-03 /
      DATA (FOU(I),I=124,126) / 0.8371E-04, 0.8316E-04,-0.7566E-04 /
      DATA (FOU(I),I=127,129) /-0.1009E-02, 0.9339E-03, 0.4774E-03 /
      DATA (FOU(I),I=130,132) / 0.2094E-03,-0.2552E-04, 0.7365E-04 /
      DATA (FOU(I),I=133,135) /-0.6223E-05,-0.8036E-04, 0.7080E-03 /
      DATA (FOU(I),I=136,138) / 0.5166E-03,-0.7565E-05, 0.4443E-04 /
      DATA (FOU(I),I=139,141) /-0.8680E-04,-0.7583E-04,-0.1234E-02 /
      DATA (FOU(I),I=142,144) / 0.1500E-02, 0.3007E-03, 0.2425E-03 /
      DATA (FOU(I),I=145,147) /-0.2087E-03,-0.9539E-04,-0.1525E-04 /
      DATA (FOU(I),I=148,150) /-0.6889E-03, 0.1717E-02, 0.3375E-03 /
      DATA (FOU(I),I=151,153) /-0.1780E-03, 0.1725E-04, 0.8327E-05 /
      DATA (FOU(I),I=154,156) /-0.5033E-04, 0.2057E-03, 0.1855E-02 /
      DATA (FOU(I),I=157,159) / 0.3386E-03,-0.1731E-03, 0.2304E-04 /
      DATA (FOU(I),I=160,162) / 0.1786E-03, 0.1582E-04,-0.1683E-03 /
      DATA (FOU(I),I=163,165) / 0.1456E-02, 0.2786E-03, 0.5715E-04 /
      DATA (FOU(I),I=166,168) /-0.2484E-04, 0.1159E-03, 0.1282E-04 /
      DATA (FOU(I),I=169,171) /-0.6728E-03, 0.1607E-02, 0.1848E-03 /
      DATA (FOU(I),I=172,174) /-0.1727E-03, 0.9729E-04,-0.1620E-04 /
      DATA (FOU(I),I=175,177) /-0.7998E-04, 0.1724E-03, 0.1388E-02 /
      DATA (FOU(I),I=178,180) /-0.1599E-03,-0.6403E-05, 0.6960E-04 /
      DATA (FOU(I),I=181,183) /-0.6381E-04,-0.5850E-04,-0.1817E-03 /
      DATA (FOU(I),I=184,186) / 0.1218E-02, 0.3015E-04,-0.1644E-03 /
      DATA (FOU(I),I=187,189) / 0.4298E-04, 0.1124E-03,-0.9428E-04 /
      DATA (FOU(I),I=190,192) / 0.1722E-02, 0.8892E-03,-0.1248E-03 /
      DATA (FOU(I),I=193,195) /-0.1876E-03, 0.1118E-03, 0.4230E-04 /
      DATA (FOU(I),I=196,198) / 0.4021E-04, 0.1012E-02, 0.7183E-03 /
      DATA (FOU(I),I=199,201) /-0.4126E-03,-0.1522E-03,-0.2348E-03 /
      DATA (FOU(I),I=202,204) / 0.2543E-04,-0.5631E-04,-0.5471E-03 /
      DATA (FOU(I),I=205,207) / 0.1060E-02,-0.7083E-04, 0.2787E-04 /
      DATA (FOU(I),I=208,210) / 0.7593E-04, 0.5242E-04,-0.6125E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR5 = F + RADM
      RETURN
      END
+DECK,RSWUR6.
      REAL FUNCTION RSWUR6(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* n = 8 data period 95m (peak-2)
* n = 9 data period 95o (peak)
* n = A data period 95p (peak+2)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010 on 20. 3.97.
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.4895E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1603E-02, 0.8938E-04, 0.3452E-03 /
      DATA (FOU(I),I= 19, 21) / 0.2391E-03, 0.1423E-03, 0.3577E-04 /
      DATA (FOU(I),I= 22, 24) /-0.5045E-02, 0.1277E-02, 0.5668E-03 /
      DATA (FOU(I),I= 25, 27) /-0.2692E-03, 0.5770E-03,-0.2114E-03 /
      DATA (FOU(I),I= 28, 30) / 0.1997E-03,-0.4598E-02, 0.9525E-03 /
      DATA (FOU(I),I= 31, 33) / 0.5548E-03, 0.3793E-03, 0.1496E-03 /
      DATA (FOU(I),I= 34, 36) / 0.2053E-03,-0.1793E-03,-0.5835E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1171E-02, 0.5848E-03, 0.1325E-03 /
      DATA (FOU(I),I= 40, 42) / 0.4328E-03,-0.5249E-04,-0.6716E-04 /
      DATA (FOU(I),I= 43, 45) /-0.4648E-02, 0.1529E-02, 0.7065E-03 /
      DATA (FOU(I),I= 46, 48) /-0.9619E-04, 0.5725E-05,-0.1132E-03 /
      DATA (FOU(I),I= 49, 51) / 0.1535E-03,-0.4571E-02, 0.1652E-02 /
      DATA (FOU(I),I= 52, 54) / 0.4287E-03,-0.2531E-03, 0.2349E-03 /
      DATA (FOU(I),I= 55, 57) / 0.1512E-03, 0.4204E-04,-0.2601E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1217E-02, 0.1287E-02,-0.1315E-03 /
      DATA (FOU(I),I= 61, 63) /-0.1217E-04, 0.3425E-05, 0.2225E-03 /
      DATA (FOU(I),I= 64, 66) /-0.3270E-02, 0.9801E-03, 0.5757E-03 /
      DATA (FOU(I),I= 67, 69) / 0.3742E-03, 0.3874E-04, 0.8112E-04 /
      DATA (FOU(I),I= 70, 72) / 0.4742E-04,-0.1779E-02, 0.3732E-03 /
      DATA (FOU(I),I= 73, 75) / 0.7344E-03, 0.3664E-03, 0.9648E-04 /
      DATA (FOU(I),I= 76, 78) / 0.7499E-04,-0.2037E-05,-0.1284E-02 /
      DATA (FOU(I),I= 79, 81) / 0.1454E-02, 0.2532E-03, 0.2581E-03 /
      DATA (FOU(I),I= 82, 84) / 0.6093E-04, 0.4431E-04, 0.5088E-04 /
      DATA (FOU(I),I= 85, 87) /-0.2673E-02, 0.1282E-02, 0.2984E-03 /
      DATA (FOU(I),I= 88, 90) / 0.1614E-03,-0.1299E-03,-0.2058E-03 /
      DATA (FOU(I),I= 91, 93) / 0.9593E-04,-0.1295E-02, 0.5577E-03 /
      DATA (FOU(I),I= 94, 96) / 0.6895E-03,-0.1250E-03,-0.2129E-03 /
      DATA (FOU(I),I= 97, 99) / 0.1262E-03,-0.4840E-05, 0.6618E-03 /
      DATA (FOU(I),I=100,102) / 0.1698E-02, 0.5689E-03, 0.5785E-03 /
      DATA (FOU(I),I=103,105) /-0.2008E-03, 0.1954E-03,-0.1927E-04 /
      DATA (FOU(I),I=106,108) / 0.6130E-03, 0.1034E-02,-0.9146E-04 /
      DATA (FOU(I),I=109,111) / 0.1270E-03, 0.2481E-04, 0.1485E-03 /
      DATA (FOU(I),I=112,114) /-0.1255E-03,-0.2482E-02, 0.2327E-02 /
      DATA (FOU(I),I=115,117) / 0.4089E-03,-0.4218E-03, 0.2173E-03 /
      DATA (FOU(I),I=118,120) / 0.1101E-04,-0.5506E-04,-0.2341E-02 /
      DATA (FOU(I),I=121,123) / 0.1473E-02, 0.1820E-03, 0.9959E-04 /
      DATA (FOU(I),I=124,126) / 0.8405E-04,-0.4665E-03,-0.2757E-03 /
      DATA (FOU(I),I=127,129) /-0.6952E-03,-0.2591E-03, 0.1277E-02 /
      DATA (FOU(I),I=130,132) / 0.3403E-03,-0.5248E-03,-0.1186E-03 /
      DATA (FOU(I),I=133,135) /-0.2535E-03, 0.9539E-03, 0.4791E-03 /
      DATA (FOU(I),I=136,138) /-0.2806E-03,-0.6378E-03,-0.2256E-03 /
      DATA (FOU(I),I=139,141) / 0.1665E-03, 0.2517E-04,-0.7280E-03 /
      DATA (FOU(I),I=142,144) / 0.4867E-03, 0.6767E-03, 0.2449E-05 /
      DATA (FOU(I),I=145,147) / 0.1047E-03, 0.6498E-04,-0.1788E-04 /
      DATA (FOU(I),I=148,150) /-0.2472E-02, 0.8998E-03,-0.5781E-04 /
      DATA (FOU(I),I=151,153) / 0.2517E-03,-0.6471E-03, 0.9050E-04 /
      DATA (FOU(I),I=154,156) /-0.4441E-03, 0.6905E-04, 0.1472E-02 /
      DATA (FOU(I),I=157,159) / 0.1125E-02,-0.1361E-04, 0.3974E-03 /
      DATA (FOU(I),I=160,162) /-0.5955E-04,-0.3928E-03, 0.7163E-04 /
      DATA (FOU(I),I=163,165) / 0.1495E-02, 0.1072E-02, 0.7314E-04 /
      DATA (FOU(I),I=166,168) /-0.8352E-06, 0.3176E-03,-0.3337E-03 /
      DATA (FOU(I),I=169,171) /-0.2965E-02, 0.2058E-02, 0.1494E-03 /
      DATA (FOU(I),I=172,174) / 0.1875E-04,-0.7533E-03,-0.3410E-03 /
      DATA (FOU(I),I=175,177) / 0.2634E-03, 0.1446E-02, 0.3904E-03 /
      DATA (FOU(I),I=178,180) /-0.2052E-03,-0.3337E-03, 0.1135E-03 /
      DATA (FOU(I),I=181,183) /-0.5463E-05,-0.1268E-03, 0.2279E-02 /
      DATA (FOU(I),I=184,186) / 0.2264E-03,-0.2613E-03, 0.4489E-03 /
      DATA (FOU(I),I=187,189) /-0.7125E-05, 0.2843E-03,-0.1768E-03 /
      DATA (FOU(I),I=190,192) /-0.3216E-02, 0.1866E-02, 0.7601E-03 /
      DATA (FOU(I),I=193,195) / 0.1175E-03,-0.4591E-03,-0.1264E-03 /
      DATA (FOU(I),I=196,198) /-0.4263E-03,-0.1357E-02, 0.1519E-02 /
      DATA (FOU(I),I=199,201) /-0.8102E-03, 0.8682E-03, 0.5536E-03 /
      DATA (FOU(I),I=202,204) / 0.3899E-03,-0.2251E-03,-0.1790E-02 /
      DATA (FOU(I),I=205,207) / 0.1862E-03, 0.5238E-04,-0.5807E-03 /
      DATA (FOU(I),I=208,210) / 0.6574E-04,-0.5726E-03, 0.2993E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR6 = F + RADM
      RETURN
      END
+DECK,RSWUR7.
      REAL FUNCTION RSWUR7(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5419E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1242E-02, 0.1181E-03,-0.8402E-04 /
      DATA (FOU(I),I= 19, 21) / 0.3061E-03,-0.1394E-03, 0.4261E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4915E-02, 0.1325E-02, 0.3880E-03 /
      DATA (FOU(I),I= 25, 27) / 0.1450E-03, 0.2939E-03,-0.7959E-04 /
      DATA (FOU(I),I= 28, 30) / 0.3201E-04,-0.4255E-02, 0.1491E-02 /
      DATA (FOU(I),I= 31, 33) / 0.2974E-03, 0.2511E-03, 0.4290E-03 /
      DATA (FOU(I),I= 34, 36) /-0.1632E-04, 0.3845E-04,-0.3526E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1514E-02, 0.3345E-03, 0.2699E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1434E-03, 0.1876E-04, 0.1436E-04 /
      DATA (FOU(I),I= 43, 45) /-0.2852E-02, 0.1249E-02, 0.5098E-03 /
      DATA (FOU(I),I= 46, 48) / 0.4200E-03, 0.9158E-04,-0.2402E-04 /
      DATA (FOU(I),I= 49, 51) / 0.9298E-05,-0.2112E-02, 0.1385E-02 /
      DATA (FOU(I),I= 52, 54) / 0.5114E-03, 0.2937E-03, 0.1804E-03 /
      DATA (FOU(I),I= 55, 57) /-0.5938E-04, 0.8894E-04,-0.3203E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1070E-02, 0.6254E-03, 0.2421E-03 /
      DATA (FOU(I),I= 61, 63) / 0.2559E-04,-0.8032E-04, 0.6241E-04 /
      DATA (FOU(I),I= 64, 66) /-0.1377E-02, 0.1421E-02, 0.3722E-03 /
      DATA (FOU(I),I= 67, 69) / 0.3540E-03, 0.5885E-04,-0.8557E-04 /
      DATA (FOU(I),I= 70, 72) / 0.2242E-04,-0.9106E-03, 0.1272E-02 /
      DATA (FOU(I),I= 73, 75) / 0.5908E-03, 0.4815E-03,-0.8363E-04 /
      DATA (FOU(I),I= 76, 78) /-0.7275E-04,-0.1276E-04,-0.2298E-03 /
      DATA (FOU(I),I= 79, 81) / 0.9092E-03, 0.7226E-03, 0.1899E-03 /
      DATA (FOU(I),I= 82, 84) / 0.1603E-04,-0.7533E-04,-0.2872E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1298E-02, 0.1342E-02, 0.5923E-03 /
      DATA (FOU(I),I= 88, 90) / 0.4126E-03,-0.1196E-03,-0.8681E-04 /
      DATA (FOU(I),I= 91, 93) /-0.7133E-04, 0.2357E-03, 0.1492E-02 /
      DATA (FOU(I),I= 94, 96) / 0.3678E-03, 0.2485E-03,-0.2380E-03 /
      DATA (FOU(I),I= 97, 99) /-0.9824E-04,-0.2009E-04, 0.5588E-03 /
      DATA (FOU(I),I=100,102) / 0.1134E-02, 0.6679E-03, 0.1576E-03 /
      DATA (FOU(I),I=103,105) /-0.2638E-03, 0.6183E-04,-0.2834E-04 /
      DATA (FOU(I),I=106,108) /-0.9983E-03, 0.1478E-02, 0.5337E-03 /
      DATA (FOU(I),I=109,111) / 0.3140E-03,-0.2020E-03, 0.1077E-04 /
      DATA (FOU(I),I=112,114) /-0.1002E-03,-0.6365E-03, 0.1525E-02 /
      DATA (FOU(I),I=115,117) / 0.4838E-03,-0.1813E-04,-0.2786E-03 /
      DATA (FOU(I),I=118,120) /-0.8650E-05, 0.3550E-04,-0.5425E-03 /
      DATA (FOU(I),I=121,123) / 0.9675E-03, 0.6856E-03,-0.8435E-04 /
      DATA (FOU(I),I=124,126) /-0.7426E-04, 0.9348E-04,-0.6623E-04 /
      DATA (FOU(I),I=127,129) /-0.2063E-02, 0.1197E-02, 0.8581E-03 /
      DATA (FOU(I),I=130,132) / 0.1061E-03, 0.5407E-04, 0.7167E-04 /
      DATA (FOU(I),I=133,135) / 0.2535E-04,-0.6360E-03, 0.1151E-02 /
      DATA (FOU(I),I=136,138) / 0.8239E-03, 0.2251E-03,-0.1366E-03 /
      DATA (FOU(I),I=139,141) / 0.8371E-04,-0.1510E-03,-0.1887E-02 /
      DATA (FOU(I),I=142,144) / 0.1493E-02, 0.1002E-03, 0.3212E-03 /
      DATA (FOU(I),I=145,147) /-0.1002E-03,-0.1713E-05, 0.1218E-03 /
      DATA (FOU(I),I=148,150) / 0.5001E-03, 0.1211E-02, 0.2771E-03 /
      DATA (FOU(I),I=151,153) / 0.7834E-04,-0.1602E-03, 0.4661E-05 /
      DATA (FOU(I),I=154,156) /-0.2113E-03,-0.7781E-03, 0.1340E-02 /
      DATA (FOU(I),I=157,159) / 0.5921E-03,-0.6249E-05,-0.1866E-03 /
      DATA (FOU(I),I=160,162) / 0.3247E-04, 0.3685E-05,-0.6705E-03 /
      DATA (FOU(I),I=163,165) / 0.1936E-02, 0.6174E-04, 0.5270E-04 /
      DATA (FOU(I),I=166,168) / 0.1003E-03,-0.1233E-03,-0.1435E-03 /
      DATA (FOU(I),I=169,171) /-0.8810E-03, 0.9691E-03, 0.2600E-04 /
      DATA (FOU(I),I=172,174) / 0.9072E-04, 0.6035E-04, 0.1030E-03 /
      DATA (FOU(I),I=175,177) / 0.1821E-03,-0.1924E-03, 0.1507E-02 /
      DATA (FOU(I),I=178,180) / 0.4324E-04,-0.6552E-04, 0.7243E-04 /
      DATA (FOU(I),I=181,183) / 0.1188E-03,-0.1519E-03, 0.1040E-02 /
      DATA (FOU(I),I=184,186) / 0.6245E-04, 0.4471E-03,-0.2767E-03 /
      DATA (FOU(I),I=187,189) / 0.1102E-03,-0.9255E-05,-0.1174E-03 /
      DATA (FOU(I),I=190,192) /-0.2980E-03, 0.6452E-03, 0.2077E-03 /
      DATA (FOU(I),I=193,195) /-0.3936E-03, 0.2538E-03, 0.2500E-04 /
      DATA (FOU(I),I=196,198) / 0.1081E-03, 0.6995E-03, 0.1415E-02 /
      DATA (FOU(I),I=199,201) /-0.4277E-03,-0.3764E-03,-0.6667E-04 /
      DATA (FOU(I),I=202,204) /-0.3158E-04,-0.1359E-03, 0.1669E-02 /
      DATA (FOU(I),I=205,207) / 0.1212E-02,-0.4171E-03,-0.4508E-04 /
      DATA (FOU(I),I=208,210) /-0.5066E-04,-0.5994E-04,-0.1398E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR7 = F + RADM
      RETURN
      END
+DECK,RSWUR8.
      REAL FUNCTION RSWUR8(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5281E-02 /
      DATA (FOU(I),I= 16, 18) / 0.8390E-03, 0.1550E-03,-0.7682E-04 /
      DATA (FOU(I),I= 19, 21) / 0.2153E-03,-0.2170E-03, 0.1218E-04 /
      DATA (FOU(I),I= 22, 24) /-0.5133E-02, 0.1197E-02, 0.3950E-03 /
      DATA (FOU(I),I= 25, 27) / 0.1588E-03, 0.4165E-03,-0.1334E-03 /
      DATA (FOU(I),I= 28, 30) / 0.7554E-04,-0.3957E-02, 0.1535E-02 /
      DATA (FOU(I),I= 31, 33) / 0.4523E-03, 0.3453E-03, 0.4585E-03 /
      DATA (FOU(I),I= 34, 36) /-0.1923E-04, 0.7345E-04,-0.3911E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1242E-02, 0.3812E-03, 0.2122E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1000E-03, 0.3693E-05, 0.8455E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3018E-02, 0.9855E-03, 0.6406E-03 /
      DATA (FOU(I),I= 46, 48) / 0.3915E-03, 0.1299E-03,-0.1074E-03 /
      DATA (FOU(I),I= 49, 51) / 0.6347E-04,-0.1968E-02, 0.1367E-02 /
      DATA (FOU(I),I= 52, 54) / 0.5515E-03, 0.1113E-03, 0.2974E-03 /
      DATA (FOU(I),I= 55, 57) /-0.1212E-03, 0.8651E-04,-0.3035E-02 /
      DATA (FOU(I),I= 58, 60) / 0.9319E-03, 0.6220E-03, 0.3323E-03 /
      DATA (FOU(I),I= 61, 63) /-0.1117E-04,-0.4312E-05, 0.1223E-03 /
      DATA (FOU(I),I= 64, 66) /-0.2033E-02, 0.1384E-02,-0.2380E-05 /
      DATA (FOU(I),I= 67, 69) / 0.5346E-03, 0.1319E-03,-0.1712E-03 /
      DATA (FOU(I),I= 70, 72) / 0.3466E-04,-0.1617E-02, 0.1514E-02 /
      DATA (FOU(I),I= 73, 75) / 0.4865E-03, 0.4807E-03,-0.1453E-05 /
      DATA (FOU(I),I= 76, 78) /-0.2572E-03,-0.1542E-03,-0.6326E-03 /
      DATA (FOU(I),I= 79, 81) / 0.7699E-03, 0.5959E-03, 0.2764E-03 /
      DATA (FOU(I),I= 82, 84) /-0.2358E-04,-0.2885E-03,-0.3818E-04 /
      DATA (FOU(I),I= 85, 87) /-0.1542E-02, 0.1145E-02, 0.4931E-03 /
      DATA (FOU(I),I= 88, 90) / 0.3602E-03,-0.8669E-04,-0.5521E-04 /
      DATA (FOU(I),I= 91, 93) /-0.1498E-03, 0.5786E-03, 0.1798E-02 /
      DATA (FOU(I),I= 94, 96) / 0.3744E-03, 0.2461E-03,-0.2528E-03 /
      DATA (FOU(I),I= 97, 99) / 0.3001E-04,-0.1422E-04,-0.1763E-03 /
      DATA (FOU(I),I=100,102) / 0.6973E-03, 0.8590E-03,-0.2537E-04 /
      DATA (FOU(I),I=103,105) /-0.8439E-04, 0.1472E-04, 0.4161E-04 /
      DATA (FOU(I),I=106,108) /-0.2430E-02, 0.1998E-02, 0.7028E-03 /
      DATA (FOU(I),I=109,111) / 0.1178E-03,-0.2897E-03, 0.1207E-03 /
      DATA (FOU(I),I=112,114) / 0.7170E-04,-0.1820E-02, 0.2196E-02 /
      DATA (FOU(I),I=115,117) /-0.4918E-04,-0.6543E-04,-0.4713E-03 /
      DATA (FOU(I),I=118,120) / 0.1994E-04, 0.1023E-03,-0.1739E-02 /
      DATA (FOU(I),I=121,123) / 0.5525E-03, 0.8192E-03, 0.1577E-03 /
      DATA (FOU(I),I=124,126) /-0.1073E-05, 0.9865E-04,-0.1855E-03 /
      DATA (FOU(I),I=127,129) /-0.1848E-02, 0.1295E-02, 0.8315E-03 /
      DATA (FOU(I),I=130,132) /-0.2770E-04, 0.1834E-03,-0.3651E-04 /
      DATA (FOU(I),I=133,135) / 0.1104E-03,-0.1390E-02, 0.1021E-02 /
      DATA (FOU(I),I=136,138) / 0.1252E-02, 0.1824E-04,-0.8077E-04 /
      DATA (FOU(I),I=139,141) / 0.1696E-03,-0.1853E-03,-0.1483E-02 /
      DATA (FOU(I),I=142,144) / 0.1407E-02,-0.1316E-03, 0.1181E-03 /
      DATA (FOU(I),I=145,147) / 0.2532E-03,-0.9006E-04, 0.2192E-04 /
      DATA (FOU(I),I=148,150) / 0.1365E-02, 0.1370E-02, 0.7630E-03 /
      DATA (FOU(I),I=151,153) / 0.8101E-04, 0.1080E-03,-0.2321E-03 /
      DATA (FOU(I),I=154,156) /-0.1826E-03,-0.1129E-02, 0.1164E-02 /
      DATA (FOU(I),I=157,159) / 0.4935E-03, 0.2650E-03, 0.3676E-04 /
      DATA (FOU(I),I=160,162) / 0.2007E-03,-0.6598E-04,-0.1251E-02 /
      DATA (FOU(I),I=163,165) / 0.2836E-02, 0.2876E-03, 0.2628E-04 /
      DATA (FOU(I),I=166,168) / 0.2201E-04,-0.1685E-03,-0.1517E-03 /
      DATA (FOU(I),I=169,171) / 0.7752E-04, 0.8245E-03, 0.5106E-04 /
      DATA (FOU(I),I=172,174) / 0.3157E-03, 0.8597E-04, 0.6879E-04 /
      DATA (FOU(I),I=175,177) / 0.3355E-03, 0.7342E-03, 0.1185E-02 /
      DATA (FOU(I),I=178,180) / 0.3055E-03,-0.2718E-04, 0.6715E-04 /
      DATA (FOU(I),I=181,183) / 0.1981E-03,-0.1360E-03, 0.5146E-03 /
      DATA (FOU(I),I=184,186) / 0.1088E-02, 0.2889E-03, 0.2330E-04 /
      DATA (FOU(I),I=187,189) /-0.3562E-03, 0.9055E-04,-0.2148E-03 /
      DATA (FOU(I),I=190,192) / 0.1475E-02,-0.3709E-03, 0.2940E-03 /
      DATA (FOU(I),I=193,195) /-0.7122E-03, 0.3525E-03, 0.5816E-04 /
      DATA (FOU(I),I=196,198) /-0.9337E-04, 0.1122E-02, 0.7466E-03 /
      DATA (FOU(I),I=199,201) /-0.8524E-03,-0.2806E-03,-0.1934E-03 /
      DATA (FOU(I),I=202,204) /-0.2524E-03,-0.2169E-03, 0.6210E-03 /
      DATA (FOU(I),I=205,207) / 0.1316E-02,-0.4920E-03,-0.4905E-03 /
      DATA (FOU(I),I=208,210) / 0.1149E-03,-0.1170E-03, 0.1187E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR8 = F + RADM
      RETURN
      END
+DECK,RSWUR9.
      REAL FUNCTION RSWUR9(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5347E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1320E-02, 0.1160E-03,-0.1217E-03 /
      DATA (FOU(I),I= 19, 21) / 0.2476E-03,-0.1406E-03,-0.3867E-04 /
      DATA (FOU(I),I= 22, 24) /-0.4576E-02, 0.1344E-02, 0.4339E-03 /
      DATA (FOU(I),I= 25, 27) / 0.3415E-03, 0.2354E-03,-0.4704E-05 /
      DATA (FOU(I),I= 28, 30) /-0.1051E-03,-0.4887E-02, 0.1687E-02 /
      DATA (FOU(I),I= 31, 33) / 0.2399E-03, 0.1674E-03, 0.2620E-03 /
      DATA (FOU(I),I= 34, 36) /-0.2830E-04, 0.3969E-04,-0.3570E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1588E-02, 0.4070E-03, 0.3140E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1213E-03, 0.1932E-04, 0.6125E-04 /
      DATA (FOU(I),I= 43, 45) /-0.3019E-02, 0.1286E-02, 0.1356E-03 /
      DATA (FOU(I),I= 46, 48) / 0.5927E-03, 0.3195E-03, 0.1078E-03 /
      DATA (FOU(I),I= 49, 51) /-0.1300E-04,-0.1245E-02, 0.1022E-02 /
      DATA (FOU(I),I= 52, 54) / 0.4488E-03, 0.4779E-03, 0.2347E-03 /
      DATA (FOU(I),I= 55, 57) / 0.1793E-03, 0.2103E-04,-0.3087E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1214E-02, 0.4174E-03, 0.3074E-03 /
      DATA (FOU(I),I= 61, 63) /-0.1084E-05,-0.7731E-04, 0.8355E-04 /
      DATA (FOU(I),I= 64, 66) /-0.1316E-02, 0.1301E-02, 0.4397E-03 /
      DATA (FOU(I),I= 67, 69) / 0.1772E-03, 0.9229E-05, 0.1498E-04 /
      DATA (FOU(I),I= 70, 72) / 0.6529E-04,-0.3867E-03, 0.9275E-03 /
      DATA (FOU(I),I= 73, 75) / 0.7186E-03, 0.5279E-03,-0.1309E-03 /
      DATA (FOU(I),I= 76, 78) / 0.2801E-03, 0.7283E-04,-0.3592E-03 /
      DATA (FOU(I),I= 79, 81) / 0.9478E-03, 0.1212E-02, 0.1486E-03 /
      DATA (FOU(I),I= 82, 84) / 0.2018E-03,-0.1192E-04, 0.9037E-05 /
      DATA (FOU(I),I= 85, 87) /-0.1411E-02, 0.1250E-02, 0.6733E-03 /
      DATA (FOU(I),I= 88, 90) / 0.5388E-03,-0.2009E-03,-0.4665E-04 /
      DATA (FOU(I),I= 91, 93) / 0.9949E-04,-0.1267E-02, 0.1583E-02 /
      DATA (FOU(I),I= 94, 96) /-0.5810E-04, 0.4376E-03,-0.2874E-03 /
      DATA (FOU(I),I= 97, 99) /-0.8258E-04,-0.2083E-03, 0.1860E-02 /
      DATA (FOU(I),I=100,102) / 0.1597E-02, 0.5664E-03, 0.3467E-03 /
      DATA (FOU(I),I=103,105) /-0.4224E-03, 0.1745E-03,-0.4043E-04 /
      DATA (FOU(I),I=106,108) /-0.5996E-03, 0.1233E-03, 0.8137E-03 /
      DATA (FOU(I),I=109,111) / 0.2258E-03,-0.1839E-03, 0.8210E-04 /
      DATA (FOU(I),I=112,114) /-0.2134E-03, 0.2590E-04, 0.1705E-02 /
      DATA (FOU(I),I=115,117) / 0.7324E-03,-0.3196E-03,-0.3507E-03 /
      DATA (FOU(I),I=118,120) / 0.1521E-03, 0.3898E-05,-0.5887E-03 /
      DATA (FOU(I),I=121,123) / 0.1369E-02, 0.7090E-03, 0.2360E-03 /
      DATA (FOU(I),I=124,126) /-0.3227E-03, 0.2450E-03,-0.1237E-03 /
      DATA (FOU(I),I=127,129) /-0.1288E-02, 0.9005E-03, 0.1294E-02 /
      DATA (FOU(I),I=130,132) /-0.2843E-04,-0.1836E-03, 0.8843E-04 /
      DATA (FOU(I),I=133,135) /-0.2180E-03, 0.1608E-02, 0.1959E-02 /
      DATA (FOU(I),I=136,138) /-0.1314E-03, 0.4251E-03,-0.4986E-03 /
      DATA (FOU(I),I=139,141) /-0.1182E-03,-0.2280E-03,-0.2613E-02 /
      DATA (FOU(I),I=142,144) / 0.9397E-03,-0.3239E-04, 0.2752E-03 /
      DATA (FOU(I),I=145,147) /-0.1122E-03, 0.9682E-04, 0.3314E-03 /
      DATA (FOU(I),I=148,150) /-0.4117E-04, 0.1461E-02, 0.3659E-03 /
      DATA (FOU(I),I=151,153) /-0.1490E-03,-0.3741E-03, 0.5611E-04 /
      DATA (FOU(I),I=154,156) /-0.1515E-03,-0.1835E-02, 0.1607E-02 /
      DATA (FOU(I),I=157,159) / 0.6862E-03,-0.2436E-03, 0.1108E-03 /
      DATA (FOU(I),I=160,162) /-0.5041E-04, 0.5894E-04, 0.9836E-03 /
      DATA (FOU(I),I=163,165) / 0.1007E-02, 0.1221E-03, 0.4559E-03 /
      DATA (FOU(I),I=166,168) / 0.3241E-04,-0.2166E-03,-0.1134E-03 /
      DATA (FOU(I),I=169,171) / 0.6320E-03, 0.1399E-02,-0.4360E-03 /
      DATA (FOU(I),I=172,174) / 0.6399E-04,-0.2992E-03, 0.2646E-03 /
      DATA (FOU(I),I=175,177) / 0.3126E-03, 0.1873E-02, 0.1296E-02 /
      DATA (FOU(I),I=178,180) / 0.6890E-04,-0.1109E-03,-0.5051E-04 /
      DATA (FOU(I),I=181,183) /-0.5962E-04, 0.8619E-04,-0.5530E-03 /
      DATA (FOU(I),I=184,186) /-0.4863E-03, 0.1807E-03,-0.4281E-03 /
      DATA (FOU(I),I=187,189) / 0.1427E-03, 0.1674E-03,-0.3125E-04 /
      DATA (FOU(I),I=190,192) /-0.1750E-02, 0.1540E-02, 0.7568E-03 /
      DATA (FOU(I),I=193,195) /-0.5553E-03,-0.1320E-03,-0.3748E-03 /
      DATA (FOU(I),I=196,198) / 0.2393E-03, 0.6862E-03, 0.2907E-02 /
      DATA (FOU(I),I=199,201) /-0.6372E-04,-0.7068E-03,-0.1882E-03 /
      DATA (FOU(I),I=202,204) / 0.2651E-03,-0.1999E-04, 0.3606E-02 /
      DATA (FOU(I),I=205,207) / 0.1197E-02,-0.5312E-03, 0.8433E-04 /
      DATA (FOU(I),I=208,210) /-0.1653E-03, 0.2966E-03,-0.2103E-04 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWUR9 = F + RADM
      RETURN
      END
+DECK,RSWURA.
      REAL FUNCTION RSWURA(RADM)
* coordinate smoother:
* RSWxRn smooths right coordinates
* RSWxLn smooths left  coordinates
* RSWUxn smooths un-marcoed dst coordinates
* RSWMxn smooths (marcoed) dst coordinates
* RSWxxn smooths coordinates
* RSSxxn resmooths smoothed coordinates
* -------------------------------------------
* n = 0 data period 93 (all)
* n = 1 data period 93m (peak-2)
* n = 2 data period 93o (peak)
* n = 3 data period 93p (peak+2)
* n = 4 data period 94x p59-60 runs 5014-5194
* n = 5 data period 94y p61-67 runs 5195-5599
* n = 6 data period 94z p68    runs 5600-5711
* n = 7 data period 95 (all)
* -------------------------------------------
* smoothing coefficients writen by write_four
* from histogram id     1010
* -------------------------------------------
+SEQ,DECLARE.
      INTEGER LORD, IPAD,I,J
      REAL FOUR(  7, 32), FOU(224)
      REAL RADM, Y, YC, F
      EQUIVALENCE (FOUR(1,1), FOU(1))
      DATA LORD /  7/
      DATA (FOU(I),I=  1,  3) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  4,  6) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=  7,  9) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 10, 12) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I= 13, 15) / 0.0000E+00, 0.0000E+00,-0.5596E-02 /
      DATA (FOU(I),I= 16, 18) / 0.1571E-02, 0.8470E-04,-0.6596E-04 /
      DATA (FOU(I),I= 19, 21) / 0.4296E-03,-0.6554E-04, 0.1241E-03 /
      DATA (FOU(I),I= 22, 24) /-0.4922E-02, 0.1434E-02, 0.3513E-03 /
      DATA (FOU(I),I= 25, 27) / 0.7609E-05, 0.2154E-03,-0.7642E-04 /
      DATA (FOU(I),I= 28, 30) / 0.7783E-04,-0.4128E-02, 0.1322E-02 /
      DATA (FOU(I),I= 31, 33) / 0.1850E-03, 0.2170E-03, 0.5090E-03 /
      DATA (FOU(I),I= 34, 36) /-0.5399E-05, 0.4010E-05,-0.3136E-02 /
      DATA (FOU(I),I= 37, 39) / 0.1722E-02, 0.2461E-03, 0.2967E-03 /
      DATA (FOU(I),I= 40, 42) / 0.1975E-03, 0.3265E-04,-0.8105E-04 /
      DATA (FOU(I),I= 43, 45) /-0.2588E-02, 0.1474E-02, 0.6261E-03 /
      DATA (FOU(I),I= 46, 48) / 0.3371E-03,-0.9114E-04,-0.2894E-04 /
      DATA (FOU(I),I= 49, 51) /-0.2777E-04,-0.2807E-02, 0.1635E-02 /
      DATA (FOU(I),I= 52, 54) / 0.5143E-03, 0.3498E-03, 0.3321E-04 /
      DATA (FOU(I),I= 55, 57) /-0.1534E-03, 0.1350E-03,-0.3435E-02 /
      DATA (FOU(I),I= 58, 60) / 0.1110E-02, 0.7611E-03, 0.1149E-03 /
      DATA (FOU(I),I= 61, 63) / 0.7768E-04,-0.1547E-03,-0.8066E-05 /
      DATA (FOU(I),I= 64, 66) /-0.7920E-03, 0.1535E-02, 0.6838E-03 /
      DATA (FOU(I),I= 67, 69) / 0.2955E-03, 0.2054E-04,-0.6825E-04 /
      DATA (FOU(I),I= 70, 72) /-0.1648E-04,-0.5836E-03, 0.1266E-02 /
      DATA (FOU(I),I= 73, 75) / 0.6084E-03, 0.4522E-03,-0.1304E-03 /
      DATA (FOU(I),I= 76, 78) /-0.1265E-03, 0.6509E-04, 0.2355E-03 /
      DATA (FOU(I),I= 79, 81) / 0.1017E-02, 0.5309E-03, 0.1337E-03 /
      DATA (FOU(I),I= 82, 84) /-0.6556E-04, 0.8736E-04,-0.4385E-04 /
      DATA (FOU(I),I= 85, 87) /-0.9943E-03, 0.1587E-02, 0.6347E-03 /
      DATA (FOU(I),I= 88, 90) / 0.3814E-03,-0.9886E-04,-0.1427E-03 /
      DATA (FOU(I),I= 91, 93) /-0.1066E-03, 0.8897E-03, 0.1147E-02 /
      DATA (FOU(I),I= 94, 96) / 0.6332E-03, 0.1298E-03,-0.1924E-03 /
      DATA (FOU(I),I= 97, 99) /-0.2282E-03, 0.9660E-04, 0.4423E-03 /
      DATA (FOU(I),I=100,102) / 0.1262E-02, 0.5456E-03, 0.2150E-03 /
      DATA (FOU(I),I=103,105) /-0.3351E-03, 0.3519E-04,-0.8872E-04 /
      DATA (FOU(I),I=106,108) / 0.1197E-03, 0.1850E-02, 0.1878E-03 /
      DATA (FOU(I),I=109,111) / 0.5607E-03,-0.1288E-03,-0.1415E-03 /
      DATA (FOU(I),I=112,114) /-0.1927E-03, 0.5262E-04, 0.7772E-03 /
      DATA (FOU(I),I=115,117) / 0.8262E-03, 0.2222E-03,-0.4996E-04 /
      DATA (FOU(I),I=118,120) /-0.1396E-03,-0.6222E-05, 0.6083E-03 /
      DATA (FOU(I),I=121,123) / 0.1102E-02, 0.5466E-03,-0.5157E-03 /
      DATA (FOU(I),I=124,126) / 0.1398E-04,-0.9026E-05, 0.8268E-04 /
      DATA (FOU(I),I=127,129) /-0.2759E-02, 0.1293E-02, 0.6063E-03 /
      DATA (FOU(I),I=130,132) / 0.3184E-03, 0.8180E-04, 0.1631E-03 /
      DATA (FOU(I),I=133,135) / 0.9986E-04,-0.1365E-02, 0.7580E-03 /
      DATA (FOU(I),I=136,138) / 0.1033E-02, 0.2900E-03, 0.4080E-04 /
      DATA (FOU(I),I=139,141) / 0.1349E-03,-0.6953E-04,-0.1817E-02 /
      DATA (FOU(I),I=142,144) / 0.1926E-02, 0.4104E-03, 0.5455E-03 /
      DATA (FOU(I),I=145,147) /-0.4333E-03, 0.1994E-04, 0.8540E-04 /
      DATA (FOU(I),I=148,150) / 0.2125E-04, 0.9028E-03,-0.2423E-03 /
      DATA (FOU(I),I=151,153) / 0.2202E-03,-0.2803E-03, 0.1971E-03 /
      DATA (FOU(I),I=154,156) /-0.2782E-03, 0.2345E-03, 0.1338E-02 /
      DATA (FOU(I),I=157,159) / 0.6284E-03,-0.1147E-03,-0.5921E-03 /
      DATA (FOU(I),I=160,162) /-0.7570E-04, 0.3547E-04,-0.1190E-02 /
      DATA (FOU(I),I=163,165) / 0.1669E-02,-0.1981E-03,-0.1853E-03 /
      DATA (FOU(I),I=166,168) / 0.2206E-03,-0.1872E-04,-0.1539E-03 /
      DATA (FOU(I),I=169,171) /-0.2742E-02, 0.8281E-03, 0.2890E-03 /
      DATA (FOU(I),I=172,174) /-0.1034E-03, 0.2681E-03, 0.3334E-04 /
      DATA (FOU(I),I=175,177) /-0.4376E-04,-0.2449E-02, 0.1966E-02 /
      DATA (FOU(I),I=178,180) /-0.2267E-03,-0.7866E-04, 0.1579E-03 /
      DATA (FOU(I),I=181,183) / 0.1586E-03,-0.3222E-03, 0.2589E-02 /
      DATA (FOU(I),I=184,186) /-0.5724E-03, 0.7786E-03,-0.4699E-03 /
      DATA (FOU(I),I=187,189) / 0.5412E-03,-0.2226E-03,-0.7687E-04 /
      DATA (FOU(I),I=190,192) /-0.1072E-02, 0.1052E-02,-0.2363E-03 /
      DATA (FOU(I),I=193,195) / 0.2081E-04, 0.4091E-03, 0.2580E-03 /
      DATA (FOU(I),I=196,198) / 0.2134E-03, 0.3195E-03, 0.1079E-02 /
      DATA (FOU(I),I=199,201) /-0.2661E-03,-0.2487E-03, 0.1306E-03 /
      DATA (FOU(I),I=202,204) /-0.1395E-04,-0.1326E-03, 0.1420E-02 /
      DATA (FOU(I),I=205,207) / 0.1133E-02,-0.2841E-03, 0.3004E-03 /
      DATA (FOU(I),I=208,210) /-0.1343E-03,-0.2378E-03,-0.4560E-03 /
      DATA (FOU(I),I=211,213) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=214,216) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=217,219) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=220,222) / 0.0000E+00, 0.0000E+00, 0.0000E+00 /
      DATA (FOU(I),I=223,224) / 0.0000E+00, 0.0000E+00 /
* -------------------------------------------
* fourier composition of sine components
      F = 0.0
      IPAD = (RADM-6.2)/0.25 + 1
      IF( IPAD.GE.1 .AND. IPAD.LE.32 ) THEN
      Y = (RADM - 6.2 - (IPAD-1) * 0.25)/0.25
      DO 101 J=1,LORD
      YC = Y * 3.14159265 * FLOAT(J)
      F = F + SIN(YC)*FOUR(J,IPAD)
 101  CONTINUE
      ENDIF
      RSWURA = F + RADM
      RETURN
      END
+DECK,RSWPSR.
      REAL FUNCTION RSWPSR(ER,PRER,RADR,EBEAM,IRUN)
*.**********************************************************************
*...RSWPSR   Returns pre-shower corrected energy, for the left
*.
*. EL        : energy measured on left
*. PREL      : preshowering ratio on left
*. RADL      : detector coordinate radius on left
*. EBEAM     : beam energy
*. IRUN      : run number
*.
*. CALLS     : RSWPR4,RSWPR5
*.
*. CALLED    : RSWCOR
*.
*. AUTHOR    : D. Strom
*. VERSION   : 1.00
*. CREATED   :  4-Feb-94
*. LAST MOD  : 15-Apr-98
*.
*. Modification Log.
*. 15-Apr-98   D.Strom     move data statement
*.  5-Jun-97   D.Strom     Add calls to report
*. 28-May-96   D.Strom    Include dms preshower correction...
*. 21-May-96   D.Strom    Only use scale factor
*. 29-May-94   P.Hart     Complete rewrite for pass4 data
*.  4-Feb-94   M.Mannelli Incorporated original code in ROPE framework
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
*
      REAL RADR,ER,PRER,EBEAM
      INTEGER IRUN
*
      EXTERNAL RSWPR4,RSWPR5
      REAL     RSWPR4,RSWPR5
*
      INTEGER NMAL
      SAVE    NMAL
*
      DATA    NMAL /0/
*
      IF(IRUN.LT.6000) THEN
         RSWPSR =  RSWPR4(ER,PRER,RADR,EBEAM,IRUN)
      ELSE
         RSWPSR =  RSWPR5(ER,PRER,RADR,EBEAM,IRUN)
      END IF
*
*
      IF(NMAL.LT.20) THEN
        WRITE(CHREP,1000) IRUN,ER,PRER,RADR,EBEAM,RSWPSR
        NMAL = NMAL + 1 
        CALL REPORT ('RSWPSR', 1, 'I')
      END IF
*
      RETURN
1000  FORMAT('IRUN,ER,PRER,RADR,EBEAM,RSWPSR',I5,6F10.6)
      END
+DECK,RSWPR4.
      REAL FUNCTION RSWPR4(ER,PRER,RADR,EBEAM,IRUN)
*.
*...RSWPR4   Returns pre-shower corrected energy, for the right
*.           tuned on pass4 data
*.
*. ER        : energy measured on right
*. PRER      : preshowering ratio on right
*. RADR      : detector coordinate radius on right
*. CALLED    : RSWCOR
*.
*. AUTHOR    : P.Hart
*. VERSION   : 2.00
*. CREATED   :  4-Feb-94
*. LAST MOD  : 21-May-96
*.
*. Modification Log.
*. 29-Mai-94   P.Hart     Complete rewrite for pass4 data
*.  4-Feb-94   M.Mannelli Incorporated original code in ROPE framework
*. 21-May-96   D.Strom    Only use scale factor
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      REAL RADR,ER,PRER,EBEAM
      INTEGER IRUN
      INTEGER NRAD
      REAL STEP
*
*     parameters in nonlinarity correction
*
      REAL PNL1,PNL2,BNOM
*      PARAMETER (PNL1 = 0.92930  , PNL2 = 0.87877, BNOM=45.5 )
      PARAMETER (PNL1 = 0.95201, PNL2 = 0.90305, BNOM=45.5 )
*
      REAL X,COR
*
      REAL FAC
*
*     Preshower correction
*
      REAL SCALE(60)
      REAL CN(60),E1(60),E2(60),E3(60),E4(60)
      REAL PMAX(60)
*
*     final fudge factor
*
      REAL SCALEF(60)
*
      DATA SCALE /
     & 0.8585068, 0.9223534, 0.9497151, 0.9696837, 0.9850983, 0.9966796,
     & 1.0064188, 1.0138743, 1.0201584, 1.0250484, 1.0296681, 1.0327320,
     & 1.0354754, 1.0374911, 1.0397934, 1.0426937, 1.0445278, 1.0447870,
     & 1.0430717, 1.0409250, 1.0389721, 1.0377884, 1.0383403, 1.0390768,
     & 1.0358495, 1.0320784, 1.0257542, 1.0206313, 1.0134985, 1.0146903,
     & 1.0177805, 1.0215988, 1.0231875, 1.0244383, 1.0276818, 1.0320756,
     & 1.0340849, 1.0345700, 1.0359168, 1.0390607, 1.0394388, 1.0387194,
     & 1.0365932, 1.0339277, 1.0307145, 1.0277803, 1.0236149, 1.0192956,
     & 1.0132962, 1.0060591, 0.9971245, 0.9876451, 0.9749558, 0.9606013,
     & 0.9430569, 0.9202558, 0.8917485, 0.8535503, 0.7992952, 0.7264405/
      DATA  CN /
     & 0.8434472, 0.9216304, 0.9488686, 0.9688959, 0.9843533, 0.9958332,
     & 1.0055038, 1.0129359, 1.0192840, 1.0242052, 1.0288911, 1.0319127,
     & 1.0344734, 1.0364643, 1.0389118, 1.0416758, 1.0433835, 1.0438292,
     & 1.0330520, 1.0244951, 0.9846495, 0.9859096, 0.9775949, 1.0003937,
     & 0.9839030, 0.9401812, 0.8871423, 0.8073475, 0.8455991, 0.8926224,
     & 0.8640918, 0.7579427, 0.8868372, 0.8967833, 0.9233060, 0.9779335,
     & 0.9574825, 0.9746666, 0.9801602, 1.0380871, 1.0384325, 1.0376405,
     & 1.0357842, 1.0330504, 1.0298309, 1.0266906, 1.0225270, 1.0184135,
     & 1.0124153, 1.0053120, 0.9961668, 0.9869237, 0.9743351, 0.9595927,
     & 0.9415610, 0.9197209, 0.8908165, 0.8520212, 0.7970335, 0.7148662/
      DATA  E1 /
     &   0.00000,   0.00020,   0.00000,   0.00000,   0.00000,   0.00000,
     &   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,
     &   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,
     &   0.00197,   0.00734,   0.05873,   0.05677,   0.06451,   0.04203,
     &   0.05686,   0.10104,   0.15009,   0.21262,   0.17420,   0.12690,
     &   0.15359,   0.26171,   0.13211,   0.12488,   0.10023,   0.05377,
     &   0.08400,   0.06539,   0.06147,   0.00000,   0.00000,   0.00000,
     &   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,
     &   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,
     &   0.00000,   0.00000,   0.00000,   0.00000,   0.00000,   0.00000/
      DATA  E2 /
     & -81.18807, -81.08660, -83.99300, -87.09457, -86.88541, -87.23447,
     & -87.61687, -78.16055, -79.47359, -80.38609, -80.95525, -81.72014,
     & -82.52344, -82.16837, -84.17911, -99.70161, -48.75140,   5.41121,
     &  94.15883,  53.26954,  -0.90300,  -0.35653,   1.17068,  -0.47766,
     &  -0.76230,  -0.91411,  -0.70349,   3.22995,   2.91100,   3.64727,
     &   4.42628,   4.50735,   6.35980,   7.97865,   9.07545,   1.44346,
     &  -1.16647,  -0.98409,  -1.54934, -94.50005, -97.67913, -99.68925,
     & -99.87646, -37.35482, -38.08711, -97.37078, -89.67486, -85.42176,
     & -77.74933, -72.82191, -87.90305, -87.45519, -85.39394, -84.46562,
     & -83.87491, -83.37455, -80.91467, -81.78100, -81.44944, -83.67305/
      DATA  E3 /
     &  99.89043,  99.89182,  99.67628,  99.82434,  99.83341,  99.89874,
     &  99.89767,  99.89283,  99.89336,  99.89049,  99.88963,  99.88853,
     &  99.88807,  99.88650,  99.88797,  98.20884,  87.30907,  26.48040,
     &  42.25508,  30.63598,   0.71225,   1.00420,   2.99809,   1.16705,
     &   0.72713,   2.39206,   2.34773,   4.03663,   4.05555,   4.90468,
     &   5.20022,   4.99116,   6.68092,   8.02394,   8.91243,   5.05797,
     &   0.23547,   0.48274,   0.22990,  46.92833,  99.89959,  99.90000,
     &  99.89982,  81.84254,  81.70091,  99.89071,  99.90000,  99.90000,
     &  99.89999,  99.89571,  99.89923,  99.89358,  99.89774,  99.88503,
     &  99.89920,  99.89945,  99.02610,  99.64754,  99.77602,  99.90000/
      DATA  E4 /
     &   1.00565,   1.50568,   2.55050,   2.99683,   2.98660,   1.00246,
     &   1.25635,   1.00002,   1.00002,   1.00003,   1.00001,   1.00000,
     &   1.00000,   1.00000,   1.00000,   1.00505,   1.00582,   1.00851,
     &   1.47039,   1.38100,   1.22299,   1.00279,   1.28125,   1.00677,
     &   1.00105,   2.47000,   2.81510,   1.28502,   1.31321,   1.39790,
     &   1.33917,   1.20479,   1.32077,   1.25538,   1.25843,   2.76823,
     &   1.00095,   1.00122,   1.06149,   1.35512,   1.40229,   1.00239,
     &   1.57030,   1.00000,   1.00000,   1.00015,   1.00004,   1.00000,
     &   1.00000,   1.00014,   2.98778,   2.38528,   1.02403,   1.01270,
     &   1.00275,   1.11905,   1.44139,   1.61301,   1.81924,   1.84103/
      DATA  PMAX /
     & 0.8506658, 0.9223058, 0.9500065, 0.9700965, 0.9857807, 0.9985681,
     & 1.0086789, 1.0225128, 1.0251065, 1.0327532, 1.0328436, 1.0360945,
     & 1.0379694, 1.0399415, 1.0438874, 1.0453876, 1.0459564, 1.0453608,
     & 1.0436879, 1.0424203, 1.0400792, 1.0393491, 1.0400014, 1.0403633,
     & 1.0372784, 1.0350348, 1.0304966, 1.0278475, 1.0235950, 1.0255612,
     & 1.0280148, 1.0300074, 1.0306394, 1.0325936, 1.0337713, 1.0360739,
     & 1.0368497, 1.0363325, 1.0377834, 1.0397240, 1.0407138, 1.0423998,
     & 1.0382085, 1.0364389, 1.1228561, 1.0298135, 1.0270063, 1.0411932,
     & 1.0168333, 1.0136336, 1.0025812, 0.9997500, 0.9797659, 0.9684744,
     & 0.9469952, 0.9307832, 0.9004858, 0.9278079, 0.8116184, 0.7227231/
*
      DATA SCALEF /
     & 1.0222611, 0.9996369, 0.9998632, 0.9999101, 1.0001912, 1.0001996,
     & 1.0002509, 1.0001987, 1.0004548, 1.0002919, 1.0004332, 1.0004091,
     & 1.0005347, 1.0006397, 1.0004166, 1.0003564, 1.0005077, 1.0003595,
     & 1.0003964, 1.0002717, 1.0011412, 1.0013329, 1.0004104, 1.0012505,
     & 1.0011439, 1.0005139, 1.0012165, 1.0012152, 1.0010053, 1.0011441,
     & 1.0009897, 1.0010345, 1.0009594, 1.0008563, 1.0011297, 1.0012993,
     & 1.0010281, 1.0011935, 1.0010792, 1.0012292, 1.0004201, 1.0002437,
     & 1.0002753, 1.0003520, 1.0003593, 1.0004964, 1.0003266, 1.0001932,
     & 1.0001774, 1.0000350, 1.0001523, 1.0003375, 1.0002416, 1.0003504,
     & 1.0004002, 1.0004042, 0.9995601, 0.9984570, 0.9950820, 0.9903679/

*
      STEP=60./(14.-6.5)
      NRAD=INT(STEP*(RADR-6.5))+1
      IF(NRAD.LT.1)  NRAD=1
      IF(NRAD.GT.60) NRAD = 60
*
* No sensible preshower correction here for first few bins...
*
      IF( NRAD.LE.20 .OR. NRAD.GT. 40 ) THEN
         RSWPR4 = ER/SCALE(NRAD)
      ELSE
         FAC = CN(NRAD) +
     +      E1(NRAD)*EXP( E2(NRAD)*PRER - (E3(NRAD)*PRER)**E4(NRAD) )
         IF(FAC.GT. 1.5) FAC = 1.5
         IF(FAC.LT. 0.4) FAC = 0.4
         RSWPR4 =  ER/FAC
      END IF
*
* FNAL FUDGE
*
      RSWPR4 = RSWPR4/SCALEF(NRAD)
      X      = RSWPR4/BNOM
      COR    = 0.02*BNOM*(1./(1.+PNL2*X**2-PNL1*X) - 1.)
      RSWPR4 = RSWPR4 + COR
*
*
*     final corrections
*
      IF(IRUN.LT.5000) THEN
        IF( EBEAM .LT. 45.0 ) THEN
          RSWPR4 = RSWPR4/1.0049
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWPR4 = RSWPR4/1.0051
        ELSE
          RSWPR4 = RSWPR4/1.0044
        ENDIF
      ELSE IF(IRUN.LT.5195 ) THEN
        RSWPR4 = RSWPR4/0.99996
      ELSE IF(IRUN.LT.5600 ) THEN
        RSWPR4 = RSWPR4/0.99988
      ELSE IF(IRUN.LT.6000 ) THEN
        RSWPR4 = RSWPR4/0.99850
      END IF
*
      IF(RSWPR4.LE.0.0) THEN
        WRITE(CHREP,1001) ER,PRER,RADR
1001    FORMAT('BAD VALUE OF ER?',3F12.6)
        CALL REPORT ('RSWPR4', 1, 'W')
        RETURN
      END IF
*
      RETURN
      END
+DECK,RSWPR5.
      REAL FUNCTION RSWPR5(ER,PRER,RADR,EBEAM,IRUN)
*.
*...RSWPR5   Returns pre-shower corrected energy, for the right
*.           tuned on pass4 data
*.
*. ER        : energy measured on right
*. PRER      : preshowering ratio on right
*. RADR      : detector coordinate radius on right
*. CALLED    : RSWCOR
*.
*. AUTHOR    : P.Hart
*. VERSION   : 2.00
*. CREATED   :  4-Feb-94
*. LAST MOD  : 16-Apr-98
*.
*. Modification Log.
*. 16-Apr-98   D.Strom    move data
*. 29-Mai-94   P.Hart     Complete rewrite for pass4 data
*.  4-Feb-94   M.Mannelli Incorporated original code in ROPE framework
*. 21-May-96   D.Strom    Only use scale factor
*. 14-Oct-97   D.Strom    nonlinearity including 183 GeV running
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      REAL RADR,ER,PRER,EBEAM
      INTEGER IRUN
      INTEGER NRAD
      REAL STEP
*
*     parameters in nonlinarity correction
*
      REAL PNL1,PNL2,BNOM
      PARAMETER (PNL1 = 0.23410, BNOM=45.5 )
*
      REAL X,COR
*
      REAL FAC
*
      INTEGER NMAL
      SAVE NMAL
*
*     Preshower correction
*
      REAL SCALE(60)
      REAL CN(60),E1(60),E2(60),E3(60),E4(60)
      REAL PMAX(60)
*
*     final fudge factor
*
      REAL SCALEF(60)
*
      LOGICAL FIRST
      SAVE    FIRST
*
      DATA    FIRST /.TRUE./
*
      DATA NMAL /0/
*
*
* right side parameterization from fitit.f
* /zzero/strom/sw_dt95.rzhist

      DATA SCALE /
     & 0.8986577, 0.9403717, 0.9683952, 0.9883153, 1.0040331, 1.0154042,
     & 1.0248376, 1.0322583, 1.0381844, 1.0424856, 1.0449687, 1.0463026,
     & 1.0468391, 1.0477327, 1.0489583, 1.0499232, 1.0502605, 1.0475086,
     & 1.0424299, 1.0378327, 1.0344062, 1.0326360, 1.0336282, 1.0359674,
     & 1.0332998, 1.0282216, 1.0223436, 1.0183676, 1.0125020, 1.0156729,
     & 1.0198108, 1.0197332, 1.0204494, 1.0185053, 1.0189890, 1.0216545,
     & 1.0230746, 1.0227385, 1.0282311, 1.0354756, 1.0374272, 1.0377712,
     & 1.0353171, 1.0329434, 1.0290533, 1.0271686, 1.0214474, 1.0174018,
     & 1.0116611, 1.0047348, 0.9976131, 0.9875890, 0.9755618, 0.9617931,
     & 0.9426450, 0.9210672, 0.8909477, 0.8509889, 0.7963127, 0.7274178/
      DATA  CN /
     & 0.6967756, 0.7482608, 0.7426229, 0.7546013, 0.7656557, 0.7721735,
     & 0.7803011, 0.7852788, 0.7920703, 0.7958345, 0.8197860, 0.7979838,
     & 0.7979062, 0.7980986, 0.7987148, 0.7907368, 0.8359130, 0.7269243,
     & 0.7349772, 0.7710476, 0.7559609, 0.7280300, 0.7416893, 0.7672101,
     & 0.5401835, 0.6107227, 0.6713011, 0.6773978, 0.6594656, 0.7109196,
     & 0.7971461, 0.7624320, 0.8382288, 0.7709877, 0.8534041, 0.6214566,
     & 0.5793083, 0.7897241, 0.7223030, 0.5764253, 0.7698905, 0.7880332,
     & 0.7909613, 0.7812570, 0.7812145, 0.6068558, 0.7757570, 0.7719167,
     & 0.7661980, 0.7644169, 0.7569887, 0.5807437, 0.7456421, 0.7425879,
     & 0.7489464, 0.7140148, 0.7485200, 0.6817435, 0.6573890, 0.6279426/
      DATA  E1 /
     &   0.19963,   0.19515,   0.22132,   0.22921,   0.23258,   0.23841,
     &   0.23638,   0.23735,   0.23831,   0.23877,   0.21827,   0.24179,
     &   0.24347,   0.24558,   0.24654,   0.25271,   0.20567,   0.31254,
     &   0.30316,   0.26529,   0.27612,   0.30402,   0.29032,   0.26102,
     &   0.48581,   0.41614,   0.34550,   0.34090,   0.36189,   0.31182,
     &   0.22324,   0.27210,   0.19070,   0.25204,   0.17510,   0.40708,
     &   0.45522,   0.24176,   0.31638,   0.45453,   0.26526,   0.24121,
     &   0.24010,   0.24361,   0.24140,   0.41841,   0.23865,   0.23906,
     &   0.23886,   0.23482,   0.23298,   0.40556,   0.22399,   0.21323,
     &   0.18223,   0.19510,   0.13217,   0.14047,   0.11263,   0.06582/
      DATA  E2 /
     &   8.30451,  -0.40085,  13.94125,  13.77852,  14.53738,  12.67577,
     &  15.32061,  14.27319,  14.72455,  13.83714,  12.93665,  11.70636,
     &  11.39024,  11.24156,  11.36804,  11.30840,  12.99809,   5.93188,
     &   5.42987,   5.28344,   5.95975,   3.66662,   4.80997,   7.06929,
     &   5.94012,   3.99046,   5.50414,   3.82942,   2.74479,   4.72888,
     &   6.13323,   5.67557,   5.95958,   6.23533,   7.36879,   5.17180,
     &   1.28534,   1.89512,   1.10340,  12.25793,  10.98703,  11.40997,
     &  11.32607,  11.17991,  11.41138,   3.12649,  11.54087,  11.29887,
     &  11.06698,  11.00095,  10.78062,   1.58440,  10.59978,   5.00521,
     &   9.36419,   6.43726,   5.44572,  31.06623,  11.57306,  13.21868/
      DATA  E3 /
     &   9.34276,   4.16724,  13.95663,  13.60503,  14.23088,  12.27214,
     &  14.67795,  13.54499,  14.02430,  13.30723,  12.55573,  11.49663,
     &  11.27670,  11.27648,  11.50238,  11.19377,  12.41860,   6.29542,
     &   5.91820,   5.87689,   6.34880,   4.58927,   5.57430,   7.31748,
     &   6.26575,   4.77503,   5.89108,   4.67443,   3.85197,   5.37718,
     &   6.52574,   6.40722,   6.76133,   6.68912,   8.03673,   5.82424,
     &   2.99365,   4.37885,   3.64485,  12.27103,  11.58002,  11.73351,
     &  11.86033,  11.56822,  11.86181,   4.80378,  11.95686,  11.78202,
     &  11.59999,  11.59441,  11.36500,   4.17963,  11.24733,   7.18489,
     &  10.07861,   8.20700,   7.89639,  25.67167,  10.51098,  10.06088/
      DATA  E4 /
     &   1.12765,   2.62321,   1.06704,   1.05750,   1.06130,   1.03702,
     &   1.06332,   1.07272,   1.04771,   1.06247,   1.08685,   1.09322,
     &   1.10605,   1.10858,   1.11806,   1.13221,   1.14946,   1.21163,
     &   1.23338,   1.29652,   1.27227,   1.39957,   1.35471,   1.30950,
     &   1.19512,   1.30858,   1.30025,   1.39540,   1.44530,   1.29949,
     &   1.34638,   1.21824,   1.33350,   1.26447,   1.32585,   1.20350,
     &   1.60304,   1.87119,   1.83515,   1.09962,   1.18172,   1.22009,
     &   1.19864,   1.20983,   1.20273,   1.33547,   1.20341,   1.20085,
     &   1.22131,   1.20648,   1.22534,   1.69296,   1.22553,   1.55167,
     &   1.39731,   1.60186,   1.92143,   1.18265,   1.66334,   1.96384/
      DATA  PMAX /
     & 0.8991984, 1.1144631, 0.9694800, 0.9897258, 1.0059693, 1.0400023,
     & 1.0302901, 1.0363368, 1.0423883, 1.0448995, 1.0482600, 1.0505038,
     & 1.0518699, 1.0528852, 1.0545709, 1.0572727, 1.0569417, 1.0560235,
     & 1.0525725, 1.0526818, 1.0512562, 1.0518506, 1.0511321, 1.0507889,
     & 1.0491034, 1.0459340, 1.0428427, 1.0425563, 1.0406508, 1.0426863,
     & 1.0418899, 1.0439788, 1.0426731, 1.0408516, 1.0416080, 1.0442182,
     & 1.0425416, 1.0431075, 1.0440264, 1.0474108, 1.0463740, 1.0443329,
     & 1.0438658, 1.0388221, 1.0351307, 1.0324306, 1.0280949, 1.0229372,
     & 1.0183620, 1.0103719, 1.0028733, 0.9936258, 0.9823864, 0.9685065,
     & 0.9490469, 0.9264137, 0.8970824, 0.8549376, 0.7993385, 0.7275928/
*
* right side parameterization from fitit.f
* /zzero/strom/sw_dt95.rzhist
*
      DATA SCALEF /
     & 0.9993581, 1.0002975, 1.0003455, 1.0004182, 1.0002393, 1.0003021,
     & 1.0002714, 1.0003150, 1.0003140, 1.0001698, 1.0002896, 1.0000308,
     & 1.0003572, 0.9999850, 0.9996857, 0.9994325, 0.9991912, 0.9988258,
     & 0.9982284, 0.9979548, 1.0011071, 1.0011128, 1.0010624, 1.0006075,
     & 1.0011277, 1.0016131, 1.0015031, 1.0024399, 1.0028102, 1.0029922,
     & 1.0038686, 1.0025667, 1.0026194, 1.0014538, 1.0018872, 1.0014489,
     & 1.0012572, 1.0014417, 1.0016134, 1.0007679, 0.9988997, 0.9991480,
     & 0.9994641, 0.9991658, 0.9994152, 0.9993486, 1.0000082, 0.9998644,
     & 0.9998234, 0.9999582, 0.9988716, 0.9992818, 0.9996784, 1.0002410,
     & 0.9999176, 0.9985427, 0.9988310, 0.9975590, 0.9973158, 0.9926467/
*
      STEP=60./(14.-6.5)
      NRAD=INT(STEP*(RADR-6.5))+1
      IF(NRAD.LT.1)  NRAD=1
      IF(NRAD.GT.60) NRAD = 60
*
* No sensible preshower correction here for first few bins...
*
      IF( NRAD.LE.20 .OR. NRAD.GT. 40 ) THEN
         RSWPR5 = ER/SCALE(NRAD)
      ELSE
         FAC = CN(NRAD) +
     +      E1(NRAD)*EXP( E2(NRAD)*PRER - (E3(NRAD)*PRER)**E4(NRAD) )
         IF(FAC.GT. 1.5) FAC = 1.5
         IF(FAC.LT. 0.4) FAC = 0.4
         RSWPR5 =  ER/FAC
      END IF
*
* FNAL FUDGE
*
      RSWPR5 = RSWPR5/SCALEF(NRAD)
      X      = RSWPR5/BNOM
*
* LEP 1 and 1.5
*
      IF(IRUN.LT.7000) THEN
        COR    = 0.2*X*BNOM*(1./(1.+PNL1*X**2-PNL1*X) - 1.)
        RSWPR5 = RSWPR5 + COR
*
*
*     final corrections
*
*
        IF( EBEAM .LT. 45.0 ) THEN
          RSWPR5 = RSWPR5/0.99808
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWPR5 = RSWPR5/0.99777
        ELSE
          RSWPR5 = RSWPR5/0.99803
        ENDIF
      ELSE
*
* Based on Anna's four points...
** correct for old gain constant 1304.5, CLU596 = 1450.0
*
          COR = 1./(1.01474 + RSWPR5*0.9721E-3)
          RSWPR5 = RSWPR5*COR*1450.0/1304.5
*
*
        IF(FIRST) THEN
          FIRST = .FALSE.
          WRITE(CHREP,1000) RSWPR5,COR
1000      FORMAT('Corrected energy, factor',2F12.6)
          CALL REPORT ('RSWPR5', 1, 'I')
        END IF
*
      END IF
*
*
      IF(RSWPR5.LE.0.0) THEN
          WRITE(CHREP,1001) ER,PRER,RADR
1001      FORMAT('BAD VALUE OF ER?',3F12.6)
          CALL REPORT ('RSWPR5', 2, 'W')
          RETURN
      END IF
*
      RETURN
      END
+DECK,RSWPL4.
      REAL FUNCTION RSWPL4(EL,PREL,RADL,EBEAM,IRUN)
*.
*...RSWPL4   Returns pre-shower corrected energy, for the left
*.           tuned on pass4 data
*.
*. EL        : energy measured on left
*. PREL      : preshowering ratio on left
*. RADL      : detector coordinate radius on left
*. CALLED    : RSWCOR
*.
*. AUTHOR    : P.Hart
*. VERSION   : 2.00
*. CREATED   :  4-Feb-94
*. LAST MOD  : 28-May-96
*.
*. Modification Log.
*. 29-Mai-94   P.Hart     Complete rewrite for pass4 data
*.  4-Feb-94   M.Mannelli Incorporated original code in ROPE framework
*. 21-May-96   D.Strom    Only use scale factor
*. 28-May-96   D.Strom    Include dms preshower correction...
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      REAL RADL,EL,PREL,EBEAM
      INTEGER IRUN
      INTEGER NRAD
      REAL STEP
      REAL FAC
*
*     parameters in nonlinarity correction
*
      REAL PNL1,PNL2,BNOM
*      PARAMETER (PNL1 =  0.55586 , PNL2=0.50549, BNOM=45.5 )
*     June 25, 1996
      PARAMETER (PNL1 = 0.63735, PNL2=0.58411, BNOM=45.5 )
*
      REAL X,COR
*
*     Preshower correction
*
      REAL SCALE(60)
      REAL CN(60),E1(60),E2(60),E3(60),E4(60)
      REAL PMAX(60)
*
      REAL SCALEF(60)
*
      DATA SCALE /
     & 0.8824251, 0.9349077, 0.9625842, 0.9827499, 0.9984373, 1.0099227,
     & 1.0198742, 1.0272230, 1.0339941, 1.0387515, 1.0424533, 1.0450674,
     & 1.0469644, 1.0474015, 1.0471910, 1.0465875, 1.0442381, 1.0409027,
     & 1.0346814, 1.0281826, 1.0224637, 1.0195314, 1.0205053, 1.0220796,
     & 1.0187324, 1.0112394, 1.0033909, 0.9934263, 0.9881415, 0.9918913,
     & 0.9980852, 1.0015826, 1.0030254, 1.0034618, 1.0083170, 1.0122672,
     & 1.0146170, 1.0147935, 1.0212544, 1.0304376, 1.0330634, 1.0329603,
     & 1.0333879, 1.0309659, 1.0275713, 1.0249233, 1.0226220, 1.0184160,
     & 1.0133873, 1.0071445, 0.9992995, 0.9890053, 0.9771221, 0.9625922,
     & 0.9445422, 0.9215831, 0.8938758, 0.8570271, 0.8039913, 0.7241240/
      DATA  CN /
     & 0.8322526, 0.6930816, 0.7144220, 0.7328398, 0.7444393, 0.7548642,
     & 0.7625937, 0.7894856, 0.7751167, 0.7830962, 0.7854508, 0.8516677,
     & 0.7854674, 0.4401759, 0.5008498, 0.4566111, 0.4252192, 0.6550847,
     & 0.6134532, 0.6165698, 0.6307746, 0.5040152, 0.5063380, 0.5391088,
     & 0.5667831, 0.5361803, 0.5709647, 0.3310341, 0.2785791, 0.4954370,
     & 0.7111919, 0.7437442, 0.7647638, 0.7877583, 0.7552799, 0.6202639,
     & 0.7000586, 0.6313255, 0.5059876, 0.6260727, 0.5087044, 0.4097280,
     & 0.5773900, 0.6157458, 0.5454538, 0.6031982, 0.4546822, 0.5920952,
     & 0.5828740, 0.7574539, 0.9077163, 0.8977950, 0.9046540, 0.7170368,
     & 0.6948416, 0.5295103, 0.6698248, 0.6923502, 0.4283502, 0.5023441/
      DATA  E1 /
     &   0.01313,   0.23769,   0.24278,   0.24539,   0.24824,   0.24812,
     &   0.25061,   0.23070,   0.25181,   0.24772,   0.24888,   0.18661,
     &   0.25351,   0.59921,   0.54889,   0.59138,   0.63155,   0.39498,
     &   0.42708,   0.41605,   0.40061,   0.52602,   0.52094,   0.48415,
     &   0.45994,   0.48651,   0.44726,   0.70205,   0.74434,   0.52654,
     &   0.30818,   0.28194,   0.25906,   0.23529,   0.26321,   0.39602,
     &   0.32885,   0.38336,   0.52140,   0.41200,   0.53146,   0.63185,
     &   0.45753,   0.41962,   0.49031,   0.42185,   0.56496,   0.42113,
     &   0.42985,   0.24464,   0.08749,   0.08712,   0.07312,   0.23652,
     &   0.23962,   0.37807,   0.21175,   0.13808,   0.35899,   0.20501/
      DATA  E2 /
     &  47.91646,  15.31305,  16.73151,  19.08848,  19.85014,  21.81209,
     &  20.07241,  19.21153,  17.50011,  15.19710,  14.87037,  15.72371,
     &  13.72278,  13.70976,   0.22675,   1.51626,  -0.03575,   0.82021,
     &   3.41340,   6.11415,   4.63673,   4.75510,   4.82570,   9.66361,
     &   4.36319,   4.63160,   5.23761,   0.75867,   1.94556,   4.43723,
     &   5.37671,   5.96941,   7.41754,   6.79566,   7.22550,   9.58623,
     &   2.17309,   7.81992,   4.37084,   2.69135,   3.03938,   0.74809,
     &   3.75145,   2.16637,   0.82258,   2.57742,   3.33901,   9.41799,
     &   2.87577,  12.89501,  15.24019,  14.43945,   4.63508,  12.93977,
     &  12.21682,  10.85002,   4.81222,  15.55515,   2.25190,  34.99041/
      DATA  E3 /
     &  28.70602,  15.32549,  16.51701,  18.82756,  19.42786,  21.19452,
     &  19.48816,  18.59934,  16.99829,  14.69667,  14.38080,  15.17738,
     &  13.38597,  13.56398,   2.08807,   2.36679,   1.55588,   2.47501,
     &   4.22490,   6.40352,   5.20927,   5.18488,   5.27885,   9.49327,
     &   5.06973,   5.20297,   5.67356,   1.95067,   2.73054,   4.99443,
     &   5.97711,   6.64712,   7.81020,   7.36008,   7.54306,   9.41214,
     &   4.08164,   7.92842,   5.20402,   4.51748,   4.52911,   2.78374,
     &   5.19771,   4.20803,   3.16794,   4.57075,   4.65476,   9.92128,
     &   4.50295,  13.04334,  15.00818,  14.35148,   9.05213,  12.80622,
     &  12.17657,  10.87836,   6.66399,  13.24647,   4.34406,  31.64066/
      DATA  E4 /
     &   2.00620,   1.04868,   1.04611,   1.03231,   1.03709,   1.04172,
     &   1.03562,   1.04348,   1.04427,   1.05467,   1.06458,   1.08803,
     &   1.08709,   1.04429,   1.99636,   1.25549,   2.09085,   1.63511,
     &   1.24809,   1.17424,   1.23041,   1.17472,   1.19472,   1.12323,
     &   1.26635,   1.23202,   1.21636,   1.48019,   1.25515,   1.17667,
     &   1.28439,   1.27038,   1.26042,   1.32243,   1.31232,   1.16651,
     &   1.68109,   1.22274,   1.24205,   1.42430,   1.28879,   1.62317,
     &   1.28205,   1.45636,   1.67041,   1.46920,   1.29092,   1.14799,
     &   1.35431,   1.17248,   1.40606,   1.41152,   2.16392,   1.18525,
     &   1.20888,   1.17300,   1.68947,   1.42412,   1.94743,   1.09426/
      DATA  PMAX /
     & 0.8589582, 0.9351318, 0.9669700, 1.1226116, 0.9987163, 1.0836465,
     & 1.0208219, 1.0280718, 1.0350678, 1.0402868, 1.0445215, 1.0480918,
     & 1.0499854, 1.0510010, 1.0525593, 1.0540510, 1.0551226, 1.0542793,
     & 1.0529706, 1.0512078, 1.0484226, 1.0484143, 1.0474768, 1.0478835,
     & 1.0475241, 1.0432695, 1.0387301, 1.0372376, 1.0353070, 1.0338361,
     & 1.0384674, 1.0417420, 1.0409468, 1.0416715, 1.0414523, 1.0420593,
     & 1.0427450, 1.0422189, 1.0450220, 1.0472329, 1.0488707, 1.0460318,
     & 1.0445244, 1.0433868, 1.0385926, 1.0347877, 1.0318837, 1.0282222,
     & 1.0211256, 1.0153692, 1.0077844, 0.9966150, 0.9839643, 0.9695507,
     & 0.9517107, 0.9293442, 0.9023784, 0.8647022, 0.8112161, 0.7312545/
*
      DATA SCALEF /
     & 1.0082579, 0.9990231, 0.9996548, 0.9999443, 1.0001402, 1.0001339,
     & 1.0001593, 1.0002884, 1.0001973, 1.0002384, 1.0011013, 1.0009459,
     & 1.0011884, 1.0009197, 1.0014197, 1.0014879, 1.0014186, 1.0019099,
     & 1.0020583, 1.0017432, 1.0021172, 1.0021675, 1.0024378, 1.0026532,
     & 1.0029062, 1.0032201, 1.0030936, 1.0035092, 1.0042466, 1.0051420,
     & 1.0050658, 1.0045214, 1.0045348, 1.0055017, 1.0048071, 1.0044132,
     & 1.0036038, 1.0039184, 1.0032984, 1.0029479, 1.0028454, 1.0031155,
     & 1.0023770, 1.0023240, 1.0020599, 1.0023676, 1.0021214, 1.0023614,
     & 1.0019047, 1.0020070, 1.0020704, 1.0021895, 1.0018137, 1.0022709,
     & 1.0017166, 1.0012352, 1.0007068, 0.9992532, 0.9934116, 1.0115386/
*
      STEP=60./(14.-6.5)
      NRAD=INT(STEP*(RADL-6.5))+1
      IF(NRAD.LT.1) NRAD=1
      IF(NRAD.GT.60) NRAD=60
*
* No sensible preshower correction here for first few bins...
*
      IF( NRAD.LE.10 ) THEN
         RSWPL4 = EL/SCALE(NRAD)
      ELSE
         FAC = CN(NRAD) +
     +      E1(NRAD)*EXP( E2(NRAD)*PREL - (E3(NRAD)*PREL)**E4(NRAD) )
         IF(FAC.GT. 1.5) FAC = 1.5
         IF(FAC.LT. 0.4) FAC = 0.4
         RSWPL4 =  EL/FAC
      END IF
*
      RSWPL4 = RSWPL4/SCALEF(NRAD)
*
      X      = RSWPL4/BNOM
      COR    = 0.02*BNOM*(1./(1.+PNL2*X**2-PNL1*X) - 1.)
      RSWPL4 = RSWPL4 + COR
*
*     final corrections
*
      IF(IRUN.LT.5000) THEN
        IF( EBEAM .LT. 45.0 ) THEN
          RSWPL4 = RSWPL4/1.0027
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWPL4 = RSWPL4/1.0028
        ELSE
          RSWPL4 = RSWPL4/1.0027
        ENDIF
      ELSE IF(IRUN.LT.5195 ) THEN
        RSWPL4 = RSWPL4/1.0005
      ELSE IF(IRUN.LT.5600 ) THEN
        RSWPL4 = RSWPL4/1.0004
      ELSE IF(IRUN.LT.6000 ) THEN
        RSWPL4 = RSWPL4/1.0133
      END IF
*
      IF(RSWPL4.LE.0.0) THEN
        WRITE(CHREP,1001) EL,PREL,RADL
1001    FORMAT('BAD VALUE OF El?',3F12.6)
        CALL REPORT ('RSWPL4', 1, 'W')
        RETURN
      END IF
*
      RETURN
      END
+DECK,RSWPL5.
      REAL FUNCTION RSWPL5(EL,PREL,RADL,EBEAM,IRUN)
*.
*...RSWPL5   Returns pre-shower corrected energy, for the left
*.           tuned on pass4 data
*.
*. EL        : energy measured on left
*. PREL      : preshowering ratio on left
*. RADL      : detector coordinate radius on left
*. CALLED    : RSWCOR
*.
*. AUTHOR    : P.Hart
*. VERSION   : 2.00
*. CREATED   :  4-Feb-94
*. LAST MOD  : 17-Oct-97
*.
*. Modification Log.
*. 29-Mai-94   P.Hart     Complete rewrite for pass4 data
*.  4-Feb-94   M.Mannelli Incorporated original code in ROPE framework
*. 21-May-96   D.Strom    Only use scale factor
*. 28-May-96   D.Strom    Include dms preshower correction...
*. 14-Oct-97   D.Strom    nonlinearity including 183 GeV running
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      REAL RADL,EL,PREL,EBEAM
      INTEGER IRUN
      INTEGER NRAD
      REAL STEP
      REAL FAC
*
*     parameters in nonlinarity correction
*
      REAL PNL1,PNL2,BNOM
*      PARAMETER (PNL1 =  0.55586 , PNL2=0.50549, BNOM=45.5 )
*     June 25, 1996
*      PARAMETER (PNL1 = 0.63735, PNL2=0.58411, BNOM=45.5 )
*
*      PARAMETER (PNL1 = 1.1036, PNL2=0.99014, BNOM=45.5 )
      PARAMETER (PNL1 = 0.17740,  BNOM=45.5 )
*
      REAL X,COR
*
*     Preshower correction
*
      REAL SCALE(60)
      REAL CN(60),E1(60),E2(60),E3(60),E4(60)
      REAL PMAX(60)
*
      REAL SCALEF(60)
*
      LOGICAL FIRST
      DATA    FIRST /.TRUE./
*
* left side parameterization from fitit.f
* /zzero/strom/sw_dt95.rzhist

      DATA SCALE /
     & 0.8987260, 0.9419804, 0.9698340, 0.9895765, 1.0046761, 1.0158937,
     & 1.0249883, 1.0326142, 1.0379046, 1.0421362, 1.0460507, 1.0492104,
     & 1.0516756, 1.0512612, 1.0506346, 1.0499758, 1.0461816, 1.0424274,
     & 1.0389266, 1.0367010, 1.0335448, 1.0306216, 1.0310286, 1.0304344,
     & 1.0250269, 1.0195260, 1.0132781, 1.0081397, 1.0013757, 1.0070235,
     & 1.0117512, 1.0127399, 1.0144128, 1.0158757, 1.0177357, 1.0212624,
     & 1.0232877, 1.0217961, 1.0246879, 1.0328307, 1.0329808, 1.0337453,
     & 1.0315368, 1.0280266, 1.0247549, 1.0213197, 1.0169955, 1.0123808,
     & 1.0077688, 1.0027785, 0.9941576, 0.9846210, 0.9743389, 0.9599118,
     & 0.9411888, 0.9178371, 0.8883647, 0.8513352, 0.7956410, 0.7330994/
      DATA  CN /
     & 0.6968467, 0.6922765, 0.7600362, 0.7316887, 0.7299528, 0.7379080,
     & 0.7425409, 0.7443256, 0.7496477, 0.7563756, 0.7567654, 0.4711617,
     & 0.7481456, 0.4332936, 0.3481451, 0.6901513, 0.8560086, 0.5523348,
     & 0.6765296, 0.7088707, 0.7230064, 0.6394830, 0.6735594, 0.6114591,
     & 0.5311560, 0.6678612, 0.5728149, 0.5167909, 0.5203654, 0.5965832,
     & 0.3271785, 0.7286821, 0.7094626, 0.7469847, 0.7241293, 0.6974223,
     & 0.7428423, 0.7172084, 0.5411516, 0.5792762, 0.5213253, 0.2703269,
     & 0.7255236, 0.6617565, 0.3554722, 0.4023772, 0.5011465, 0.6616620,
     & 0.5494865, 0.4232288, 0.6478004, 0.5707561, 0.6462456, 0.4546414,
     & 0.4938544, 0.4620748, 0.3880039, 0.4875727, 0.6501251, 0.5589375/
      DATA  E1 /
     &   0.19793,   0.24351,   0.20569,   0.25582,   0.26858,   0.27246,
     &   0.27494,   0.27851,   0.27664,   0.27806,   0.27852,   0.56711,
     &   0.29603,   0.60333,   0.69161,   0.35603,   0.18953,   0.49262,
     &   0.36420,   0.33285,   0.31688,   0.39826,   0.36519,   0.42855,
     &   0.50653,   0.36953,   0.45859,   0.51110,   0.49406,   0.43009,
     &   0.71702,   0.29893,   0.31662,   0.27552,   0.30056,   0.32817,
     &   0.28176,   0.30408,   0.48460,   0.45161,   0.50756,   0.76018,
     &   0.29877,   0.36191,   0.66832,   0.61384,   0.51055,   0.34603,
     &   0.45239,   0.57384,   0.33494,   0.41176,   0.32165,   0.49606,
     &   0.44053,   0.44103,   0.49548,   0.34186,   0.11372,   0.12443/
      DATA  E2 /
     &   2.67749,   7.13391,   7.05892,   0.68210,   8.59053,  10.74633,
     &  10.73631,   8.18069,  11.34309,  11.23896,  11.38689,   3.48089,
     &   1.15006,   7.43105,  13.81750,  11.09112,  12.77972,  14.36651,
     &  13.62303,   5.68682,   5.59204,   5.48263,   5.09329,   5.05882,
     &   6.89294,   3.40229,   2.87117,   2.78878,   4.88521,   3.98870,
     &   1.42579,   4.61110,   6.36373,   5.51217,   5.53693,   4.24129,
     &   4.33337,   6.09086,   9.36738,  11.03462,   8.97791,   1.99045,
     &   8.95916,   6.98460,   1.85838,   8.59782,   7.29083,   9.97877,
     &  12.04813,   5.03382,  14.22284,   2.81685,   5.06646,   7.39795,
     &   3.50389,  11.78308,   1.62290,  13.12647,  35.52055,  36.17620/
      DATA  E3 /
     &   5.86534,   8.02482,   7.96566,   4.54623,   8.96306,  10.77671,
     &  10.66149,   8.11328,  10.88071,  10.82841,  10.94830,   3.89203,
     &   3.42870,   7.59713,  13.61475,  11.06966,  12.43593,  14.09233,
     &  13.19401,   6.28006,   6.23571,   5.98860,   5.82051,   5.77992,
     &   7.23923,   4.59133,   3.88332,   3.70384,   5.24723,   4.68436,
     &   2.31800,   5.45435,   6.82784,   6.20979,   6.30524,   5.33915,
     &   5.57831,   6.72622,   9.44501,  11.18393,   9.39626,   3.34841,
     &   9.63267,   8.00355,   3.49707,   9.11052,   8.13240,  10.68129,
     &  12.30435,   6.09459,  13.96758,   4.94232,   6.79146,   8.11534,
     &   5.27358,  11.73604,   4.03046,  12.51327,  27.75689,  27.41393/
      DATA  E4 /
     &   1.63303,   1.19158,   1.17351,   2.57158,   1.12589,   1.08195,
     &   1.09550,   1.11979,   1.09611,   1.05165,   1.08926,   1.16126,
     &   2.16596,   1.11663,   1.05003,   1.09101,   1.16616,   1.05762,
     &   1.09449,   1.25159,   1.27672,   1.22701,   1.28517,   1.24883,
     &   1.15327,   1.38325,   1.34768,   1.32066,   1.21857,   1.24944,
     &   1.25421,   1.34521,   1.26221,   1.39162,   1.37686,   1.44677,
     &   1.53952,   1.37988,   1.13712,   1.13344,   1.14020,   1.37175,
     &   1.23892,   1.24300,   1.43345,   1.12257,   1.18345,   1.20309,
     &   1.12431,   1.21785,   1.16303,   1.50676,   1.41876,   1.19178,
     &   1.45302,   1.15112,   1.80287,   1.18479,   1.20266,   1.19046/
      DATA  PMAX /
     & 0.8996567, 0.9437438, 0.9713058, 0.9914429, 1.0066285, 1.0179199,
     & 1.0278944, 1.0357490, 1.0421146, 1.0463266, 1.0494227, 1.0519162,
     & 1.0549674, 1.0559196, 1.0555477, 1.0580826, 1.0593252, 1.0601239,
     & 1.0581326, 1.0592116, 1.0576800, 1.0566564, 1.0565696, 1.0589899,
     & 1.0562607, 1.0544517, 1.0477878, 1.0444595, 1.0406932, 1.0418694,
     & 1.0453949, 1.0465862, 1.0468743, 1.0476950, 1.0492929, 1.0501456,
     & 1.0476055, 1.0480001, 1.0489850, 1.0495641, 1.0458392, 1.0433387,
     & 1.0404204, 1.0376774, 1.0350819, 1.0322081, 1.0268294, 1.0243059,
     & 1.0183492, 1.0117842, 1.0046651, 0.9958212, 0.9840406, 0.9687569,
     & 0.9506489, 0.9280358, 0.8987572, 0.8593033, 0.8033396, 0.7411705/
*
* left side parameterization from fitit.f
* /zzero/strom/sw_dt95.rzhist

      DATA SCALEF /
     & 0.9998242, 1.0011724, 1.0011166, 1.0013256, 1.0010681, 1.0014330,
     & 1.0015488, 1.0010997, 1.0012673, 1.0014505, 1.0011251, 1.0013212,
     & 1.0012376, 1.0012211, 1.0010484, 1.0011463, 1.0017202, 1.0017467,
     & 1.0019928, 1.0018455, 1.0017555, 1.0017252, 1.0021210, 1.0016021,
     & 1.0025598, 1.0027686, 1.0035303, 1.0043997, 1.0050374, 1.0052842,
     & 1.0054268, 1.0055741, 1.0048608, 1.0047134, 1.0036680, 1.0035105,
     & 1.0028245, 1.0025357, 1.0023789, 1.0014884, 1.0018899, 1.0020989,
     & 1.0023490, 1.0025113, 1.0023940, 1.0019933, 1.0020816, 1.0018191,
     & 1.0020205, 1.0018973, 1.0009550, 1.0005493, 1.0005510, 1.0008025,
     & 1.0012114, 1.0009315, 1.0007241, 1.0011265, 1.0027881, 1.0032085/
*
      STEP=60./(14.-6.5)
      NRAD=INT(STEP*(RADL-6.5))+1
      IF(NRAD.LT.1) NRAD=1
      IF(NRAD.GT.60) NRAD=60
*
* No sensible preshower correction here for first few bins...
*
      IF( NRAD.LE.10 ) THEN
         RSWPL5 = EL/SCALE(NRAD)
      ELSE
         FAC = CN(NRAD) +
     +      E1(NRAD)*EXP( E2(NRAD)*PREL - (E3(NRAD)*PREL)**E4(NRAD) )
         IF(FAC.GT. 1.5) FAC = 1.5
         IF(FAC.LT. 0.4) FAC = 0.4
         RSWPL5 =  EL/FAC
      END IF
*
      RSWPL5 = RSWPL5/SCALEF(NRAD)
*
      X      = RSWPL5/BNOM
      IF(IRUN.LT.7000) THEN
        COR    = 0.2*X*BNOM*(1./(1.+PNL1*X**2-PNL1*X) - 1.)
        RSWPL5 = RSWPL5 + COR
*
*     final corrections
*
        IF( EBEAM .LT. 45.0 ) THEN
          RSWPL5 = RSWPL5/0.99671
        ELSEIF( EBEAM .GT. 46.0 ) THEN
          RSWPL5 = RSWPL5/0.99649
        ELSE
          RSWPL5 = RSWPL5/0.99692
        ENDIF
      ELSE
* correct for old gain constant 1304.5, CLU596 = 1450.0
        COR =    1.0/(1.01715 + RSWPL5*0.964623E-3)
        RSWPL5 = RSWPL5*COR*1450.0/1304.5
*
        IF(FIRST) THEN
          FIRST = .FALSE.
          WRITE(CHREP,1000) RSWPL5,COR
1000      FORMAT('Corrected energy, factor',2F12.6)
          CALL REPORT ('RSWPL5', 1, 'I')
        END IF
      END IF
*
      IF(RSWPL5.LE.0.0) THEN
        WRITE(CHREP,1001) EL,PREL,RADL
1001    FORMAT('BAD VALUE OF EL?',3F12.6)
        CALL REPORT ('RSWPL5', 2, 'W')
        RETURN
      END IF
*
      RETURN
      END
+DECK,RSWPSL.
      REAL FUNCTION RSWPSL(EL,PREL,RADL,EBEAM,IRUN)
*...RSWPSL   Returns pre-shower corrected energy, for the left
*.
*. EL        : energy measured on left
*. PREL      : preshowering ratio on left
*. RADL      : detector coordinate radius on left
*. EBEAM     : beam energy
*. IRUN      : run number
*.
*. CALLS     : RSWPL4,RSWPL5
*.
*. CALLED    : RSWCOR
*.
*. AUTHOR    : D. Strom
*. VERSION   : 1.00
*. CREATED   :  4-Feb-94
*. LAST MOD  : 6-Jun-97
*.
*. Modification Log.
*.  5-Jun-97   D.Strom     Add calls to report
*. 28-May-96   D.Strom    Include dms preshower correction...
*. 21-May-96   D.Strom    Only use scale factor
*. 29-May-94   P.Hart     Complete rewrite for pass4 data
*.  4-Feb-94   M.Mannelli Incorporated original code in ROPE framework
*.**********************************************************************
+SEQ,DECLARE.
      REAL RADL,EL,PREL,EBEAM
      INTEGER IRUN
*
      REAL RSWPL4,RSWPL5
      EXTERNAL RSWPL4,RSWPL5
*
      IF(IRUN.LT.6000) THEN
        RSWPSL = RSWPL4(EL,PREL,RADL,EBEAM,IRUN)
      ELSE
       RSWPSL = RSWPL5(EL,PREL,RADL,EBEAM,IRUN)
      END IF
      RETURN
      END
+DECK,RSWRBD.
      SUBROUTINE RSWRBD
*.
*...RSWRBD   REBUILDS clusters from ROSWVA common; puts into ROSWRB common
*.
*. SEQUENCE  : ROSWCT ROSWMG ROSWVA ROSWRB
*. CALLED    : RSWMRG
*. CALLS     : SORTZV VZERO
*.
*. AUTHOR    : M.Foucher
*. VERSION   : 1.00
*. CREATED   : 31-May-94
*. LAST MOD  : 14-Apr-99
*.
*. Modification Log.
*. 14-Apr-99 A.Macchiolo Resurrect some lines which got lost in March 98
*.   10-Sep-97   D.Strom    Make cut1 energy dependent
*.  4-Jun-97   D.Strom    Make RMIN depend on run #
*. 18-Mar-96   M.Mannelli Split REBUILDING from MERGING
*. 10-Jun-94   M.Mannelli New algorithm
*.  3-Jun-94   M.Foucher  Add logical array pointer, which clusters merged
*.  2-Jun-94   M.Foucher  Add energy of all clusters within zone to energy
*.  1-Jun-94   M.Foucher  Add energy of all clusters to merged energy
*.**********************************************************************
*
* cluster rebuilding algorithm:
*
* 1) Identify "cluster debris" (ie. pieces of clusters resulting from
*    "busting up" a true cluster). Then, starting with the lowest energy
*    derbis, merge it with the closest cluster within a certain r-phi window.
*    The merging consists of summing the associated energies and retaining
*    the coordinates of the more energetic cluster. The result of this
*    merging will be an array of "rebuilt" clusters (each of which will
*    contain, at most, one "cluster core").
*    NB when there was contentious 15 pad energy, attempt to reconstruct
*    total 15 pad energy of cluster core (to do this properly we really
*    need the total 15 pad energy to begin with; for the time being,
*    however, we store only the associated and contentious...)
*
************************************************************************
*
+SEQ,DECLARE.
+SEQ,ROSWCT.
+SEQ,ROSWMG.
+SEQ,ROSWVA.
+SEQ,ROSWRB.
*
      REAL PI
      PARAMETER(PI=3.14159265)
*
      INTEGER I,J,K,L
*
*-- Miscellania
*
      REAL DCLOST
      INTEGER ICLOST
*
*-- Declare some temporary variables
*
      REAL RTEMPS,RTEMPV(MAXCLS)
      INTEGER ITEMPS,ITEMPV(MAXCLS)
*
      REAL RMIN
      REAL CUT1E
*
* Define minimum definition cut
*
      IF(IRUN.GE.7000)THEN
        RMIN=RMIN96
        CUT1E = CUT1*EBEAM/45.5
      ELSE
        RMIN=RMIN93
        CUT1E = CUT1
      ENDIF
*
* Zero everything
*
      NRBR    = NCLSR
      NRBL    = NCLSL
      NCORER  = 0
      NCOREL  = 0
      I       = MAXCLS
*
      CALL VZERO(ERBR,I)
      CALL VZERO(ERBL,I)
      CALL VZERO(E15RBR,I)
      CALL VZERO(E15RBL,I)
      CALL VZERO(LCORER,I)
      CALL VZERO(LCOREL,I)
      CALL VZERO(LJOINR,I)
      CALL VZERO(LJOINL,I)
*
*********************************************************************
*
*-- Do the RIGHT
*
*********************************************************************
*
* First identify all true cluster cores: two cores may not be merged
* together.
* (here blobs do not count as cores)
* nb in order to protect against "ghosts", IGNORE ZERO ENERGY CLUSTERS
*
      IF(NCLSR.GT.0) THEN
        DO 101 I=1,NCLSR

          ERBR(I)   = ER(I)
          IF(ICTYPR(I).EQ.1) THEN
            E15RBR(I) = E15AR(I)
          END IF

          IF(
     &       (ER(I)*E15AR(I)*MIN(EQDER(I),EQDOR(I)).GT.0.1)
     &      ) THEN

            IF(
     &         (ICTYPR(I).EQ.1)                                    .AND.
     &         (E15CR(I)/E15AR(I).LT.CUT0)                         .AND.
     &         (
     &          (MIN(EPKER(I),EPKOR(I)).GT.CUT1E)                  .AND.
     &          (MIN(EPKER(I)/EQDER(I),EPKOR(I)/EQDOR(I)).GT.CUT2)
     &         )
     &        ) THEN

              NCORER    = NCORER + 1
              LCORER(I) = .TRUE.

            END IF
          END IF
 101    CONTINUE
      END IF
*
* Check to see if any clusters were "debris" candidates
*
      IF((NCLSR.GT.1).AND.(NCORER.LT.NCLSR)) THEN
*
* Yes, so find the lowest energy debris and add its energy to the closest
* cluster,
* as long as they are reasonably close...
* else keep it as a separate "rebuilt" cluster.
* Then repeat for the next lowest energy cluster etc.
* nb. at most one "core" per rebuilt cluster
* nb. only the energy of the cluster debris is added in, the coordinates
* are dropped.
* nb . perform merging regardless of wether the clusters are within the zone
* cuts etc.
*
*-- ordering is from most to least energetic, so loop in inverse order
*
        DO 200 I = NCLSR, 2, -1

          DCLOST = 999999999.
          ICLOST = 0

          DO 300 J = 1, I-1

            IF(.NOT.(LCORER(I).AND.LCORER(J))) THEN
              RTEMPS = PHIR(I)-PHIR(J)
*             IF(RTEMPS.GT.PI)  RTEMPS = RTEMPS - PI
*             IF(RTEMPS.LT.-PI) RTEMPS = RTEMPS + PI
              IF(RTEMPS.GT.PI)  RTEMPS =    2.*PI - RTEMPS
              IF(RTEMPS.LT.-PI) RTEMPS = - (2.*PI - RTEMPS)
              IF(ABS(RTEMPS).LT.DPJOIN) THEN
                RTEMPS = ABS(RADR(I)-RADR(J))
                IF(RTEMPS.LT.DCLOST) THEN
                  DCLOST = RTEMPS
                  ICLOST = J
                END IF
              END IF
            END IF

 300      CONTINUE

          IF(
     &       (ICLOST.GT.0)
     &       .AND.(
     &             (DCLOST.LT.DRJOIN)
     &             .OR.(
     &                  (RADR(I).GT.RBRMIN).AND.(RADR(I).LT.RBRMAX)
     &                 )
     &            )
     &      ) THEN
*
* we are going to merge: for now always merge into the most energetic
* of the two clusters, regardless of which, if any, is a "core".
* NB. if, however, either one is a "core", then the destination cluster
* also becomes one.
* NB attempt to reconstruct the total 15 pad energy of the cluster core
* use: tot 15pe of rb clus = 15a core + min(contentious , 15a debris)
*
            ERBR(ICLOST)   = ERBR(ICLOST) + ERBR(I)
            IF(ICTYPR(I).EQ.1) THEN
              E15RBR(ICLOST) = E15RBR(ICLOST) + MIN(E15CR(I),E15AR(I))
            END IF

            LJOINR(I)      = .TRUE.
            IF(LCORER(I)) THEN
              LCORER(ICLOST)  = .TRUE.
            END IF
*
* Now wipe the merged in cluster from the set of rebuilt clusters
*
            NRBR      = NRBR - 1
            ERBR(I)   = 0.
            E15RBR(I) = 0.

          END IF
 200    CONTINUE
      END IF
*
* Sort the rebuilt clusters by their energies.
*
      IF(NRBR.GT.0) THEN
        CALL SORTZV(ERBR,INDRBR,NCLSR,1,1,0)
      END IF
*
*-- NB From now on ALWAYS refer to INDRBR(x) !!!! --
*
*********************************************************************
*
*-- Do the LEFT in analogous manner as right
*
*********************************************************************
*
* First identify all true cluster cores, and use as seeds for rebuilt
* clusters.
* (here blobs do not count as cores)
* nb in order to protect against "ghosts", IGNORE ZERO ENERGY CLUSTERS
*
      IF(NCLSL.GT.0) THEN
        DO 201 I=1,NCLSL

          ERBL(I)   = EL(I)
          IF(ICTYPL(I).EQ.1) THEN
            E15RBL(I) = E15AL(I)
          END IF

          IF(
     &       (EL(I)*E15AL(I)*MIN(EQDEL(I),EQDOL(I)).GT.0.1)
     &      ) THEN

            IF(
     &         (ICTYPL(I).EQ.1)                                    .AND.
     &         (E15CL(I)/E15AL(I).LT.CUT0)                         .AND.
     &         (
     &          (MIN(EPKEL(I),EPKOL(I)).GT.CUT1E)                  .AND.
     &          (MIN(EPKEL(I)/EQDEL(I),EPKOL(I)/EQDOL(I)).GT.CUT2)
     &         )
     &        ) THEN

              NCOREL    = NCOREL + 1
              LCOREL(I) = .TRUE.

            END IF
          END IF
 201    CONTINUE
      END IF
*
* Check to see if any clusters were "debris" candidates
*
      IF((NCLSL.GT.1).AND.(NCOREL.LT.NCLSL)) THEN
*
* Yes, so find the lowest energy debris and add its energy to the closest
* cluster,
* as long as they are reasonably close...
* else keep it as a separate "rebuilt" cluster.
* Then repeat for the next lowest energy cluster etc.
* nb. at most one "core" per rebuilt cluster
* nb. only the energy of the cluster debris is added in, the coordinates
* are dropped.
* nb . perform merging regardless of wether the clusters are within the zone
* cuts etc.
*
*-- ordering is from most to least energetic, so loop in inverse order
*
        DO 203 I = NCLSL, 2, -1

          DCLOST = 999999999.
          ICLOST = 0

          DO 301 J = 1, I-1

            IF(.NOT.(LCOREL(I).AND.LCOREL(J))) THEN
              RTEMPS = PHIL(I)-PHIL(J)
*             IF(RTEMPS.GT.PI)  RTEMPS = RTEMPS - PI
*             IF(RTEMPS.LT.-PI) RTEMPS = RTEMPS + PI
              IF(RTEMPS.GT.PI)  RTEMPS =    2.*PI - RTEMPS
              IF(RTEMPS.LT.-PI) RTEMPS = - (2.*PI - RTEMPS)
              IF(ABS(RTEMPS).LT.DPJOIN) THEN
                RTEMPS = ABS(RADL(I)-RADL(J))
                IF(RTEMPS.LT.DCLOST) THEN
                  DCLOST = RTEMPS
                  ICLOST = J
                END IF
              END IF
            END IF

 301      CONTINUE

          IF(
     &       (ICLOST.GT.0)
     &       .AND.(
     &             (DCLOST.LT.DRJOIN)
     &             .OR.(
     &                  (RADL(I).GT.RBRMIN).AND.(RADL(I).LT.RBRMAX)
     &                 )
     &            )
     &      ) THEN
*
* we are going to merge: for now always merge into the most energetic
* of the two clusters, regardless of which, if any, is a "core".
* NB. if, however, either one is a "core", then the destination cluster
* also becomes one.
* NB attempt to reconstruct the total 15 pad energy of the cluster core
* use: tot 15pe of rb clus = 15a core + min(contentious , 15a debris)
*
            ERBL(ICLOST)   = ERBL(ICLOST) + ERBL(I)
            IF(ICTYPL(I).EQ.1) THEN
              E15RBL(ICLOST) = E15RBL(ICLOST) + MIN(E15CL(I),E15AL(I))

             END IF

            LJOINL(I)      = .TRUE.
            IF(LCOREL(I)) THEN
              LCOREL(ICLOST)  = .TRUE.
            END IF
*
* Now wipe the merged in cluster from the set of rebuilt clusters
*
            NRBL      = NRBL - 1
            ERBL(I)   = 0.
            E15RBL(I) = 0.

          END IF
 203    CONTINUE
      END IF
*
* Sort the remaining rebuilt clusters by their energies.
*
      IF(NRBL.GT.0) THEN
        CALL SORTZV(ERBL,INDRBL,NCLSL,1,1,0)
      END IF
*
*-- NB From now on ALWAYS refer to INDRBL(x) !!!! --
*
      RETURN
      END
+DECK,RSWBIT.
      SUBROUTINE RSWBIT (IFLAG, JSWITA, JSWITR, JSWOTR, JSWITL, JSWOTL)
*.
*...RSWBIT   Calculates the luminsosity bits using the ROSWMG common
*.
*. INPUT     : IFLAG     what selection cuts to apply
*.                     =        1 radial zone cuts
*.                     =       10 energy fraction cuts
*.                     =      100 average energy fraction cut
*.                     =     1000 acoplanarity cut
*.                     =    10000 acolinearity cut
*.                     =   100000 tight average radius cut
*.                     =  1000000 tight right radius cut
*.                     = 10000000 tight left radius cut
*. OUTPUT    : JSWITA  two clusters match with average theta cut
*. OUTPUT    : JSWITR  two clusters match tight right cut, loose left cut
*. OUTPUT    : JSWOTR  ADC cluster / out-of-time trigger cluster match
*. OUTPUT    : JSWITL  two clusters match loose right cut, tight left cut
*. OUTPUT    : JSWOTL  ADC cluster / out-of-time trigger cluster match
*.
*. SEQUENCE  : ROSWMG
*. CALLED    : RBABSW
*.
*. AUTHOR    : D.Wagner
*. VERSION   : 1.00
*. CREATED   :  3-Feb-94
*. LAST MOD  :  4-Jun-97
*.
*. Modification Log.
*.  4-Jun-97   D.Strom    Use run number which is ROSWVA
*.  7-Aug-96   S.Arcelli  Define Rmin depending on the year of data taking
*. 31-May-94   M.Foucher  complete rewrite
*.  4-Feb-94   M.Mannelli Added cut on maximum acolinearity (DTMAX)
*.  3-Feb-94   D.Wagner   Created from second half of old RBABSW
*.  7-Nov-93   D.Wagner   Add EAve to SWITR/L, loosen all phi cuts
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IFLAG
      LOGICAL JSWITA, JSWITR, JSWOTR, JSWITL, JSWOTL
+SEQ,ROSWCT.
+SEQ,ROSWMG.
+SEQ,ROSWVA.
      LOGICAL ZNCUT,ECUT,EACUT,ACPCUT,ACLCUT,RACUT,RRCUT,RLCUT,MKCUT
      REAL DPHI
      REAL RMIN
      REAL PI
      PARAMETER(PI=3.14159265)
*
* Define minimum definition cut
*
      IF(IRUN.GE.7000)THEN
        RMIN=RMIN96
      ELSE
        RMIN=RMIN93
      ENDIF
*
* Require both merged radii be within zone cuts
*
      ZNCUT=.TRUE.
      IF(RMGR.LT.RMIN-RZONE) ZNCUT=.FALSE.
      IF(RMGR.GT.RMAX+RZONE) ZNCUT=.FALSE.
      IF(RMGL.LT.RMIN-RZONE) ZNCUT=.FALSE.
      IF(RMGL.GT.RMAX+RZONE) ZNCUT=.FALSE.
*
* Energy fraction on each side must be above cut
*
      ECUT=.TRUE.
      IF(EFMGR.LT.EFRAC) ECUT=.FALSE.
      IF(EFMGL.LT.EFRAC) ECUT=.FALSE.
*
* Average energy fraction must be above cut
*
      EACUT=.TRUE.
      IF(((EFMGR+EFMGL)/2.).LT.EAFRAC) EACUT=.FALSE.
*
* Acoplanarity cut
*
      ACPCUT=.FALSE.
      DPHI=PHMGR-PHMGL
      IF(DPHI.LT.0.0) DPHI=DPHI+(2.*PI)
      DPHI=DPHI-PI
      IF(ABS(DPHI).LT.DPHMX) ACPCUT=.TRUE.
*
* Acolinearity cut
*
      ACLCUT=.FALSE.
      IF(ABS(RMGR-RMGL).LT.DRMX) ACLCUT=.TRUE.
*
* Tight cut on average radius
*
      RACUT=.TRUE.
      IF(((RMGR+RMGL)/2.).LT.RMIN) RACUT=.FALSE.
      IF(((RMGR+RMGL)/2.).GT.RMAX) RACUT=.FALSE.
*
* Tight cut on right radius
*
      RRCUT=.TRUE.
      IF(RMGR.LT.RMIN) RRCUT=.FALSE.
      IF(RMGR.GT.RMAX) RRCUT=.FALSE.
*
* Tight cut on left radius
*
      RLCUT=.TRUE.
      IF(RMGL.LT.RMIN) RLCUT=.FALSE.
      IF(RMGL.GT.RMAX) RLCUT=.FALSE.
*
* zero out the bits
*
      JSWOTR=.FALSE.
      JSWOTL=.FALSE.
      JSWITA=.TRUE.
      JSWITR=.TRUE.
      JSWITL=.TRUE.
*
* Now actually make the selections.
*
* Check if should make radial zone cuts, if so make zone cut
*
      MKCUT=MOD(IFLAG,10).NE.0
      IF(MKCUT.AND..NOT.ZNCUT) THEN
         JSWITA=.FALSE.
         JSWITR=.FALSE.
         JSWITL=.FALSE.
      END IF
*
* Check if should make energy fraction cuts, if so make energy cuts
*
      MKCUT=MOD(IFLAG/10,10).NE.0
      IF(MKCUT.AND..NOT.ECUT) THEN
         JSWITA=.FALSE.
         JSWITR=.FALSE.
         JSWITL=.FALSE.
      END IF
*
* Check if should make average energy cut, if so make energy cut
*
      MKCUT=MOD(IFLAG/100,10).NE.0
      IF(MKCUT.AND..NOT.EACUT) THEN
         JSWITA=.FALSE.
         JSWITR=.FALSE.
         JSWITL=.FALSE.
      END IF
*
* Check if should make acoplanarity cut, if so make acoplanarity cut
*
      MKCUT=MOD(IFLAG/1000,10).NE.0
      IF(MKCUT.AND..NOT.ACPCUT) THEN
         JSWITA=.FALSE.
         JSWITR=.FALSE.
         JSWITL=.FALSE.
      END IF
*
* Check if should make acolinearity cut, if so make acolinearity cut
*
      MKCUT=MOD(IFLAG/10000,10).NE.0
      IF(MKCUT.AND..NOT.ACLCUT) THEN
         JSWITA=.FALSE.
         JSWITR=.FALSE.
         JSWITL=.FALSE.
      END IF
*
* Check if should make tight cut on average radius, if so make it, only SWITA
*
      MKCUT=MOD(IFLAG/100000,10).NE.0
      IF(MKCUT.AND..NOT.RACUT) JSWITA=.FALSE.
*
* Check if should make tight cut on right radius, if so make it, only SWITR
*
      MKCUT=MOD(IFLAG/1000000,10).NE.0
      IF(MKCUT.AND..NOT.RRCUT) JSWITR=.FALSE.
*
* Check if should make tight cut on left radius, if so make it, only SWITL
*
      MKCUT=MOD(IFLAG/10000000,10).NE.0
      IF(MKCUT.AND..NOT.RLCUT) JSWITL=.FALSE.
*
      RETURN
      END
+DECK,RSWMRG.
      SUBROUTINE RSWMRG
*.
*...RSWMRG   Merges clusters from ROSWVA common; puts into ROSWMG common
*.
*. SEQUENCE  : ROSWCT ROSWMG ROSWVA
*. CALLED    : RSWCOR
*. CALLS     : SORTZV VZERO
*.
*. AUTHOR    : M.Foucher
*. VERSION   : 1.00
*. CREATED   : 31-May-94
*. LAST MOD  : 10-Jun-94
*.
*. Modification Log.
*.  3-Jun-97   D.Strom    make rmin depend on period...
*. 18-Mar-96   M.Mannelli Split REBUILDING from MERGING
*. 10-Jun-94   M.Mannelli New algorithm
*.  3-Jun-94   M.Foucher  Add logical array pointer, which clusters merged
*.  2-Jun-94   M.Foucher  Add energy of all clusters within zone to energy
*.  1-Jun-94   M.Foucher  Add energy of all clusters to merged energy
*.**********************************************************************
*
* cluster merging algorithm:
*
* 1) use as input REBUILT clusters
*
* 2) Based on the kinematic integrity of the event, reject background
*    clusters from off-momentum electrons. This will leave us with a set
*    of rebuilt "physics" clusters.
*
* 3) Calculate the merged four-momentum of the rebuilt physics clusters
*    nb for the time being, do not merge blobs, use them only if they
*    are the largest cluster in the event...
*
************************************************************************
*
+SEQ,DECLARE.
+SEQ,ROSWCT.
+SEQ,ROSWMG.
+SEQ,ROSWVA.
+SEQ,ROSWRB.
*
      REAL PI
      PARAMETER(PI=3.14159265)
*
      INTEGER I,J,K,L
*
*-- Storage for beam centered radius and phi
*
      REAL BMRADR(MAXCLS),BMRADL(MAXCLS)
      REAL BMPHIR(MAXCLS),BMPHIL(MAXCLS)
*
*-- Declare cartesian coordinates for clusters.
*
      REAL XR(7),YR(7)
      REAL XL(7),YL(7)
      REAL XWMGR,YWMGR
      REAL XWMGL,YWMGL
      REAL RMIN
*
*
*-- Miscellania
*
*-- Declare some temporary variables
*
      REAL RTEMPS,RTEMPV(MAXCLS)
      INTEGER ITEMPS,ITEMPV(MAXCLS)
*
* Define minimum definition cut
*
      IF(IRUN.GE.7000)THEN
        RMIN=RMIN96
      ELSE
        RMIN=RMIN93
      ENDIF
*
* Zero everything
*
      NTRYR   = 0
      ITRYR   = 0
      NTRYL   = 0
      ITRYL   = 0
      EFMGR   = 0.
      EFMGL   = 0.
      RMGR    = 0.
      RMGL    = 0.
      PHMGR   = 0.
      PHMGL   = 0.
      RWMGR   = 0.
      RWMGL   = 0.
      PHWMGR  = 0.
      PHWMGL  = 0.
      I       = MAXCLS
*
      CALL VZERO(EFTRYR,I)
      CALL VZERO(RTRYR,I)
      CALL VZERO(PHTRYR,I)
      CALL VZERO(EFTRYL,I)
      CALL VZERO(RTRYL,I)
      CALL VZERO(PHTRYL,I)
      CALL VZERO(LMGR,I)
      CALL VZERO(LMGL,I)
      CALL VZERO(XR,I)
      CALL VZERO(YR,I)
      CALL VZERO(XL,I)
      CALL VZERO(YL,I)
*
*-- Call cluster rebuilding routine (nb in the data only)
*
      CALL RSWRBD
*
*-- Now get beam centered coordinates, using Phil's routine
*-- which reads info from SWTABLE
*
      CALL RSWBUC(IRUN,BMRADR,BMPHIR,BMRADL,BMPHIL)
*
* Calculate cartesian coordinates for each cluster on each side
* NB in BEAM centered coordinates
*
      DO 100 I = 1,NCLSR
        XR(I) = BMRADR(I)*COS(BMPHIR(I))
        YR(I) = BMRADR(I)*SIN(BMPHIR(I))
 100  CONTINUE
*
      DO 101 I = 1,NCLSL
        XL(I) = BMRADL(I)*COS(BMPHIL(I))
        YL(I) = BMRADL(I)*SIN(BMPHIL(I))
 101  CONTINUE
*
*********************************************************************
*
*-- Do the RIGHT
*
*********************************************************************
*
*-- NB For REBUILT clusters ALWAYS refer to INDRBR(x) !!!! --
*
* Zap rebuilt clusters below 2 Gev or outside the ZONE cuts
* NB perhaps should except the most energetic one ???
*
      IF(NRBR.GT.0) THEN
        DO 103 I=1,NRBR
          IF(
     &       (RADR(INDRBR(I)).LT.RMIN-RZONE)     .OR.
     &       (RADR(INDRBR(I)).GT.RMAX+RZONE)     .OR.
     &       (ERBR(INDRBR(I)).LT.2.0)
     &      ) THEN

            NRBR              = NRBR - 1
            ERBR(INDRBR(I))   = 0.
            E15RBR(INDRBR(I)) = 0.

          END IF
 103    CONTINUE
      END IF
*
* Sort again the remaining rebuilt clusters by their energies.
*
      IF(NRBR.GT.0) THEN
        CALL SORTZV(ERBR,INDRBR,NCLSR,1,1,0)
      END IF
*
* Now calculate four vectors of all possible combinations amongst the 3
* remaining most energetic rebuilt clusters.
* NB in BEAM centered coordinates
*
      IF(NRBR.GE.1) THEN

        NTRYR   = 1
*
        I = 1
        L = 1

        EFTRYR(L) = ERBR(INDRBR(I))/EBEAM
        RTRYR(L)  = BMRADR(INDRBR(I))
        PHTRYR(L) = BMPHIR(INDRBR(I))
*
      END IF
*
      IF(NRBR.GE.2) THEN

        NTRYR   = 3
*
        I = 2
        L = 2

        EFTRYR(L) = ERBR(INDRBR(I))/EBEAM
        RTRYR(L)  = BMRADR(INDRBR(I))
        PHTRYR(L) = BMPHIR(INDRBR(I))
*
        I = 1
        J = 2
        L = 3

        RTEMPS = ( XR(INDRBR(I)) - XR(INDRBR(J)) )**2
        RTEMPS = RTEMPS + ( YR(INDRBR(I)) - YR(INDRBR(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P).AND.
     &     (ICTYPR(INDRBR(I))*ICTYPR(INDRBR(J)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBR(INDRBR(I))
          RTEMPV(2) = E15RBR(INDRBR(J))
        ELSE
          RTEMPV(1) = ERBR(INDRBR(I))
          RTEMPV(2) = ERBR(INDRBR(J))
        END IF
        XWMGR = XR(INDRBR(I))*RTEMPV(1) + XR(INDRBR(J))*RTEMPV(2)
        XWMGR = XWMGR / ( RTEMPV(1) + RTEMPV(2) )
        YWMGR = YR(INDRBR(I))*RTEMPV(1) + YR(INDRBR(J))*RTEMPV(2)
        YWMGR = YWMGR / ( RTEMPV(1) + RTEMPV(2) )
        RWMGR  = SQRT( XWMGR**2 + YWMGR**2)

        EFTRYR(L) = ERBR(INDRBR(I)) + ERBR(INDRBR(J))
        EFTRYR(L) = EFTRYR(L)/EBEAM
        RTRYR(L)  = RWMGR
        PHTRYR(L) = ATAN2( YWMGR/RWMGR , XWMGR/RWMGR )
        IF(PHTRYR(L).LT.0.) PHTRYR(L) = PHTRYR(L) + 2.*PI
*
      END IF
*
      IF(NRBR.GE.3) THEN

        NTRYR   = 7
*
        I = 3
        L = 4

        EFTRYR(L) = ERBR(INDRBR(I))/EBEAM
        RTRYR(L)  = BMRADR(INDRBR(I))
        PHTRYR(L) = BMPHIR(INDRBR(I))
*
        I = 1
        J = 3
        L = 5

        RTEMPS = ( XR(INDRBR(I)) - XR(INDRBR(J)) )**2
        RTEMPS = RTEMPS + ( YR(INDRBR(I)) - YR(INDRBR(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P).AND.
     &     (ICTYPR(INDRBR(I))*ICTYPR(INDRBR(J)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBR(INDRBR(I))
          RTEMPV(2) = E15RBR(INDRBR(J))
        ELSE
          RTEMPV(1) = ERBR(INDRBR(I))
          RTEMPV(2) = ERBR(INDRBR(J))
        END IF
        XWMGR = XR(INDRBR(I))*RTEMPV(1) + XR(INDRBR(J))*RTEMPV(2)
        XWMGR = XWMGR / ( RTEMPV(1) + RTEMPV(2) )
        YWMGR = YR(INDRBR(I))*RTEMPV(1) + YR(INDRBR(J))*RTEMPV(2)
        YWMGR = YWMGR / ( RTEMPV(1) + RTEMPV(2) )
        RWMGR  = SQRT( XWMGR**2 + YWMGR**2)

        EFTRYR(L) = ERBR(INDRBR(I)) + ERBR(INDRBR(J))
        EFTRYR(L) = EFTRYR(L)/EBEAM
        RTRYR(L)  = RWMGR
        PHTRYR(L) = ATAN2( YWMGR/RWMGR , XWMGR/RWMGR )
        IF(PHTRYR(L).LT.0.) PHTRYR(L) = PHTRYR(L) + 2.*PI
*
        I = 2
        J = 3
        L = 6

        RTEMPS = ( XR(INDRBR(I)) - XR(INDRBR(J)) )**2
        RTEMPS = RTEMPS + ( YR(INDRBR(I)) - YR(INDRBR(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P).AND.
     &     (ICTYPR(INDRBR(I))*ICTYPR(INDRBR(J)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBR(INDRBR(I))
          RTEMPV(2) = E15RBR(INDRBR(J))
        ELSE
          RTEMPV(1) = ERBR(INDRBR(I))
          RTEMPV(2) = ERBR(INDRBR(J))
        END IF
        XWMGR = XR(INDRBR(I))*RTEMPV(1) + XR(INDRBR(J))*RTEMPV(2)
        XWMGR = XWMGR / ( RTEMPV(1) + RTEMPV(2) )
        YWMGR = YR(INDRBR(I))*RTEMPV(1) + YR(INDRBR(J))*RTEMPV(2)
        YWMGR = YWMGR / ( RTEMPV(1) + RTEMPV(2) )
        RWMGR  = SQRT( XWMGR**2 + YWMGR**2)

        EFTRYR(L) = ERBR(INDRBR(I)) + ERBR(INDRBR(J))
        EFTRYR(L) = EFTRYR(L)/EBEAM
        RTRYR(L)  = RWMGR
        PHTRYR(L) = ATAN2( YWMGR/RWMGR , XWMGR/RWMGR )
        IF(PHTRYR(L).LT.0.) PHTRYR(L) = PHTRYR(L) + 2.*PI
*
        I = 1
        J = 2
        K = 3
        L = 7

        RTEMPS = ( XR(INDRBR(I)) - XR(INDRBR(J)) )**2
        RTEMPS = RTEMPS + ( YR(INDRBR(I)) - YR(INDRBR(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P)                       .AND.
     &     (ICTYPR(INDRBR(I))*ICTYPR(INDRBR(J))*ICTYPR(INDRBR(K)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBR(INDRBR(I))
          RTEMPV(2) = E15RBR(INDRBR(J))
          RTEMPV(3) = E15RBR(INDRBR(K))
        ELSE
          RTEMPV(1) = ERBR(INDRBR(I))
          RTEMPV(2) = ERBR(INDRBR(J))
          RTEMPV(3) = ERBR(INDRBR(K))
        END IF
        XWMGR = XR(INDRBR(I))*RTEMPV(1) + XR(INDRBR(J))*RTEMPV(2) +
     &         XR(INDRBR(K))*RTEMPV(3)
        XWMGR = XWMGR / (RTEMPV(1) + RTEMPV(2) + RTEMPV(3))
        YWMGR = YR(INDRBR(I))*RTEMPV(1) + YR(INDRBR(J))*RTEMPV(2) +
     &         YR(INDRBR(K))*RTEMPV(3)
        YWMGR = YWMGR / (RTEMPV(1) + RTEMPV(2) + RTEMPV(3))
        RWMGR  = SQRT( XWMGR**2 + YWMGR**2)

        EFTRYR(L) = ERBR(INDRBR(I)) + ERBR(INDRBR(J)) + ERBR(INDRBR(K))
        EFTRYR(L) = EFTRYR(L)/EBEAM
        RTRYR(L)  = RWMGR
        PHTRYR(L) = ATAN2( YWMGR/RWMGR , XWMGR/RWMGR )
        IF(PHTRYR(L).LT.0.) PHTRYR(L) = PHTRYR(L) + 2.*PI
*
      END IF
*
*********************************************************************
*
*-- Do the LEFT in analogous manner as right
*
*********************************************************************
*
*-- NB For REBULIT clusters on ALWAYS refer to INDRBL(x) !!!! --
*
* Zap rebuilt clusters below 2 Gev or outside the ZONE cuts
* NB perhaps should except the most energetic one ???
*
      IF(NRBL.GT.0) THEN
        DO 104 I=1,NRBL
          IF(
     &       (RADL(INDRBL(I)).LT.RMIN-RZONE)     .OR.
     &       (RADL(INDRBL(I)).GT.RMAX+RZONE)     .OR.
     &       (ERBL(INDRBL(I)).LT.2.0)
     &      ) THEN

            NRBL              = NRBL - 1
            ERBL(INDRBL(I))   = 0.
            E15RBL(INDRBL(I)) = 0.

          END IF
 104    CONTINUE
      END IF
*
* Sort again the remaining rebuilt clusters by their energies.
*
      IF(NRBL.GT.0) THEN
        CALL SORTZV(ERBL,INDRBL,NCLSL,1,1,0)
      END IF
*
* Now calculate four vectors of all possible combinations amongst the 3
* remaining most energetic rebuilt clusters.
* NB in BEAM centered coordinates
*
      IF(NRBL.GE.1) THEN

        NTRYL   = 1
*
        I = 1
        L = 1

        EFTRYL(L) = ERBL(INDRBL(I))/EBEAM
        RTRYL(L)  = BMRADL(INDRBL(I))
        PHTRYL(L) = BMPHIL(INDRBL(I))
*
      END IF
*
      IF(NRBL.GE.2) THEN

        NTRYL   = 3
*
        I = 2
        L = 2

        EFTRYL(L) = ERBL(INDRBL(I))/EBEAM
        RTRYL(L)  = BMRADL(INDRBL(I))
        PHTRYL(L) = BMPHIL(INDRBL(I))
*
        I = 1
        J = 2
        L = 3

        RTEMPS = ( XL(INDRBL(I)) - XL(INDRBL(J)) )**2
        RTEMPS = RTEMPS + ( YL(INDRBL(I)) - YL(INDRBL(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P).AND.
     &     (ICTYPL(INDRBL(I))*ICTYPL(INDRBL(J)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBL(INDRBL(I))
          RTEMPV(2) = E15RBL(INDRBL(J))
        ELSE
          RTEMPV(1) = ERBL(INDRBL(I))
          RTEMPV(2) = ERBL(INDRBL(J))
        END IF
        XWMGL = XL(INDRBL(I))*RTEMPV(1) + XL(INDRBL(J))*RTEMPV(2)
        XWMGL = XWMGL / ( RTEMPV(1) + RTEMPV(2) )
        YWMGL = YL(INDRBL(I))*RTEMPV(1) + YL(INDRBL(J))*RTEMPV(2)
        YWMGL = YWMGL / ( RTEMPV(1) + RTEMPV(2) )
        RWMGL  = SQRT( XWMGL**2 + YWMGL**2)

        EFTRYL(L) = ERBL(INDRBL(I)) + ERBL(INDRBL(J))
        EFTRYL(L) = EFTRYL(L)/EBEAM
        RTRYL(L)  = RWMGL
        PHTRYL(L) = ATAN2( YWMGL/RWMGL , XWMGL/RWMGL )
        IF(PHTRYL(L).LT.0.) PHTRYL(L) = PHTRYL(L) + 2.*PI
*
      END IF
*
      IF(NRBL.GE.3) THEN

        NTRYL   = 7
*
        I = 3
        L = 4

        EFTRYL(L) = ERBL(INDRBL(I))/EBEAM
        RTRYL(L)  = BMRADL(INDRBL(I))
        PHTRYL(L) = BMPHIL(INDRBL(I))
*
        I = 1
        J = 3
        L = 5

        RTEMPS = ( XL(INDRBL(I)) - XL(INDRBL(J)) )**2
        RTEMPS = RTEMPS + ( YL(INDRBL(I)) - YL(INDRBL(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P).AND.
     &     (ICTYPL(INDRBL(I))*ICTYPL(INDRBL(J)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBL(INDRBL(I))
          RTEMPV(2) = E15RBL(INDRBL(J))
        ELSE
          RTEMPV(1) = ERBL(INDRBL(I))
          RTEMPV(2) = ERBL(INDRBL(J))
        END IF
        XWMGL = XL(INDRBL(I))*RTEMPV(1) + XL(INDRBL(J))*RTEMPV(2)
        XWMGL = XWMGL / ( RTEMPV(1) + RTEMPV(2) )
        YWMGL = YL(INDRBL(I))*RTEMPV(1) + YL(INDRBL(J))*RTEMPV(2)
        YWMGL = YWMGL / ( RTEMPV(1) + RTEMPV(2) )
        RWMGL  = SQRT( XWMGL**2 + YWMGL**2)

        EFTRYL(L) = ERBL(INDRBL(I)) + ERBL(INDRBL(J))
        EFTRYL(L) = EFTRYL(L)/EBEAM
        RTRYL(L)  = RWMGL
        PHTRYL(L) = ATAN2( YWMGL/RWMGL , XWMGL/RWMGL )
        IF(PHTRYL(L).LT.0.) PHTRYL(L) = PHTRYL(L) + 2.*PI
*
        I = 2
        J = 3
        L = 6

        RTEMPS = ( XL(INDRBL(I)) - XL(INDRBL(J)) )**2
        RTEMPS = RTEMPS + ( YL(INDRBL(I)) - YL(INDRBL(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P).AND.
     &     (ICTYPL(INDRBL(I))*ICTYPL(INDRBL(J)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBL(INDRBL(I))
          RTEMPV(2) = E15RBL(INDRBL(J))
        ELSE
          RTEMPV(1) = ERBL(INDRBL(I))
          RTEMPV(2) = ERBL(INDRBL(J))
        END IF
        XWMGL = XL(INDRBL(I))*RTEMPV(1) + XL(INDRBL(J))*RTEMPV(2)
        XWMGL = XWMGL / ( RTEMPV(1) + RTEMPV(2) )
        YWMGL = YL(INDRBL(I))*RTEMPV(1) + YL(INDRBL(J))*RTEMPV(2)
        YWMGL = YWMGL / ( RTEMPV(1) + RTEMPV(2) )
        RWMGL  = SQRT( XWMGL**2 + YWMGL**2)

        EFTRYL(L) = ERBL(INDRBL(I)) + ERBL(INDRBL(J))
        EFTRYL(L) = EFTRYL(L)/EBEAM
        RTRYL(L)  = RWMGL
        PHTRYL(L) = ATAN2( YWMGL/RWMGL , XWMGL/RWMGL )
        IF(PHTRYL(L).LT.0.) PHTRYL(L) = PHTRYL(L) + 2.*PI
*
        I = 1
        J = 2
        K = 3
        L = 7

        RTEMPS = ( XL(INDRBL(I)) - XL(INDRBL(J)) )**2
        RTEMPS = RTEMPS + ( YL(INDRBL(I)) - YL(INDRBL(J)) )**2
        RTEMPS = SQRT(RTEMPS)
        IF(
     &     (RTEMPS.LT.D15P)                       .AND.
     &     (ICTYPL(INDRBL(I))*ICTYPL(INDRBL(J))*ICTYPL(INDRBL(K)).EQ.1)
     &    ) THEN
          RTEMPV(1) = E15RBL(INDRBL(I))
          RTEMPV(2) = E15RBL(INDRBL(J))
          RTEMPV(3) = E15RBL(INDRBL(K))
        ELSE
          RTEMPV(1) = ERBL(INDRBL(I))
          RTEMPV(2) = ERBL(INDRBL(J))
          RTEMPV(3) = ERBL(INDRBL(K))
        END IF
        XWMGL = XL(INDRBL(I))*RTEMPV(1) + XL(INDRBL(J))*RTEMPV(2) +
     &         XL(INDRBL(K))*RTEMPV(3)
        XWMGL = XWMGL / (RTEMPV(1) + RTEMPV(2) + RTEMPV(3))
        YWMGL = YL(INDRBL(I))*RTEMPV(1) + YR(INDRBL(J))*RTEMPV(2) +
     &         YL(INDRBL(K))*RTEMPV(3)
        YWMGL = YWMGL / (RTEMPV(1) + RTEMPV(2) + RTEMPV(3))
        RWMGL  = SQRT( XWMGL**2 + YWMGL**2)

        EFTRYL(L) = ERBL(INDRBL(I)) + ERBL(INDRBL(J)) + ERBL(INDRBL(K))
        EFTRYL(L) = EFTRYL(L)/EBEAM
        RTRYL(L)  = RWMGL
        PHTRYL(L) = ATAN2( YWMGL/RWMGL , XWMGL/RWMGL )
        IF(PHTRYL(L).LT.0.) PHTRYL(L) = PHTRYL(L) + 2.*PI
*
      END IF
*
**************************************************************************
*
*-- Now we have made all possible combinations amongst the 3
*-- highest energy clusters on each side: now we beat the two sides
*-- against each other and pick the pair of combinations which best
*-- preserves Pt.
*
**************************************************************************
*
*-- First, if either side has no cluster, then set the merged cluster
*-- on the opposite side equal to the most energetic rebuilt cluster.
*-- Nb keep track both of the "weighted" coordinates (nb beam centered)
*-- and those the original most energetic clusters (nb detector centered)
*
      IF((NTRYR.GT.0).AND.(NTRYL.EQ.0)) THEN
        ITRYR  = 1
        EFMGR  = ERBR(INDRBR(1))/EBEAM
        RMGR   = RADR(INDRBR(1))
        PHMGR  = PHIR(INDRBR(1))
        RWMGR  = BMRADR(INDRBR(1))
        PHWMGR = BMPHIR(INDRBR(1))
        LMGR(INDRBR(1)) = .TRUE.
      END IF
*
      IF((NTRYL.GT.0).AND.(NTRYR.EQ.0)) THEN
        ITRYL  = 1
        EFMGL  = ERBL(INDRBL(1))/EBEAM
        RMGL   = RADL(INDRBL(1))
        PHMGL  = PHIL(INDRBL(1))
        RWMGL  = BMRADL(INDRBL(1))
        PHWMGL = BMPHIL(INDRBL(1))
        LMGL(INDRBL(1)) = .TRUE.
      END IF
*
*-- If each side has at least one cluster then execute these nested loops
*
      IF(NTRYR*NTRYL.GT.0) THEN

        PTMXCL = 999999.
        PTMIN  = 999999.
        PTMINO = 999999.

        DO 200 I = 1,NTRYR
*
*-- Calculate Pt of this cluster combination on the right
*
          RTEMPV(1) = EFTRYR(I)*RTRYR(I)*COS(PHTRYR(I))
          RTEMPV(2) = EFTRYR(I)*RTRYR(I)*SIN(PHTRYR(I))

          DO 300 J = 1,NTRYL
*
*-- Calculate Pt of this cluster combination on the left
*
            RTEMPV(3) = EFTRYL(J)*RTRYL(J)*COS(PHTRYL(J))
            RTEMPV(4) = EFTRYL(J)*RTRYL(J)*SIN(PHTRYL(J))
*
*-- Calculate Pt imbalance for the event, retain this combination
*-- if DPt is minimum
*
            RTEMPS = (RTEMPV(1)+RTEMPV(3))**2 + (RTEMPV(2)+RTEMPV(4))**2
            RTEMPS = SQRT(RTEMPS)
*
*-- Normalize the Pt imbalance to the total energy in the event
*-- (otherwise if two clusters on each side would pick up the smallest...)
*
            RTEMPS = RTEMPS/(EFTRYR(I)+EFTRYL(J))
*
*-- Keep track of PT for the 2 max clusters (for diagnostics)
*
            IF(I*J.EQ.1) PTMXCL = RTEMPS
*
*-- Store combo with PTMIN value
*
            IF(RTEMPS.LT.PTMIN) THEN

              ITRYR = I
              ITRYL = J
              PTMIN = RTEMPS

            END IF
*
*-- and keep track of PTMINO:
*--  the min pt other than for the 2 max clusters
*
            IF((I*J.GT.1).AND.(RTEMPS.LT.PTMINO)) THEN

              PTMINO = RTEMPS

            END IF

 300      CONTINUE
 200      CONTINUE
*
*-- Now set the merged cluster variables to the combinations chosen
*-- Nb keep track both of the "weighted" coordinates (nb beam centered)
*-- and those the original most energetic clusters (nb detector centered)
*
        EFMGR  = EFTRYR(ITRYR)
        RWMGR  = RTRYR(ITRYR)
        PHWMGR = PHTRYR(ITRYR)

        IF(ITRYR.EQ.1) THEN
          LMGR(INDRBR(1)) = .TRUE.
          RMGR  = RADR(INDRBR(1))
          PHMGR = PHIR(INDRBR(1))
        ELSEIF(ITRYR.EQ.2) THEN
          LMGR(INDRBR(2)) = .TRUE.
          RMGR  = RADR(INDRBR(2))
          PHMGR = PHIR(INDRBR(2))
        ELSEIF(ITRYR.EQ.3) THEN
          LMGR(INDRBR(1)) = .TRUE.
          LMGR(INDRBR(2)) = .TRUE.
          RMGR  = RADR(INDRBR(1))
          PHMGR = PHIR(INDRBR(1))
        ELSEIF(ITRYR.EQ.4) THEN
          LMGR(INDRBR(3)) = .TRUE.
          RMGR  = RADR(INDRBR(3))
          PHMGR = PHIR(INDRBR(3))
        ELSEIF(ITRYR.EQ.5) THEN
          LMGR(INDRBR(1)) = .TRUE.
          LMGR(INDRBR(3)) = .TRUE.
          RMGR  = RADR(INDRBR(1))
          PHMGR = PHIR(INDRBR(1))
        ELSEIF(ITRYR.EQ.6) THEN
          LMGR(INDRBR(2)) = .TRUE.
          LMGR(INDRBR(3)) = .TRUE.
          RMGR  = RADR(INDRBR(2))
          PHMGR = PHIR(INDRBR(2))
        ELSEIF(ITRYR.EQ.7) THEN
          LMGR(INDRBR(1)) = .TRUE.
          LMGR(INDRBR(2)) = .TRUE.
          LMGR(INDRBR(3)) = .TRUE.
          RMGR  = RADR(INDRBR(1))
          PHMGR = PHIR(INDRBR(1))
        END IF
*
        EFMGL  = EFTRYL(ITRYL)
        RWMGL  = RTRYL(ITRYL)
        PHWMGL = PHTRYL(ITRYL)

        IF(ITRYL.EQ.1) THEN
          LMGL(INDRBL(1)) = .TRUE.
          RMGL  = RADL(INDRBL(1))
          PHMGL = PHIL(INDRBL(1))
        ELSEIF(ITRYL.EQ.2) THEN
          LMGL(INDRBL(2)) = .TRUE.
          RMGL  = RADL(INDRBL(2))
          PHMGL = PHIL(INDRBL(2))
        ELSEIF(ITRYL.EQ.3) THEN
          LMGL(INDRBL(1)) = .TRUE.
          LMGL(INDRBL(2)) = .TRUE.
          RMGL  = RADL(INDRBL(1))
          PHMGL = PHIL(INDRBL(1))
        ELSEIF(ITRYL.EQ.4) THEN
          LMGL(INDRBL(3)) = .TRUE.
          RMGL  = RADL(INDRBL(3))
          PHMGL = PHIL(INDRBL(3))
        ELSEIF(ITRYL.EQ.5) THEN
          LMGL(INDRBL(1)) = .TRUE.
          LMGL(INDRBL(3)) = .TRUE.
          RMGL  = RADL(INDRBL(1))
          PHMGL = PHIL(INDRBL(1))
        ELSEIF(ITRYL.EQ.6) THEN
          LMGL(INDRBL(2)) = .TRUE.
          LMGL(INDRBL(3)) = .TRUE.
          RMGL  = RADL(INDRBL(2))
          PHMGL = PHIL(INDRBL(2))
        ELSEIF(ITRYL.EQ.7) THEN
          LMGL(INDRBL(1)) = .TRUE.
          LMGL(INDRBL(2)) = .TRUE.
          LMGL(INDRBL(3)) = .TRUE.
          RMGL  = RADL(INDRBL(1))
          PHMGL = PHIL(INDRBL(1))
        END IF

      END IF

      RETURN
      END
+DECK,RSWBUC.
      SUBROUTINE RSWBUC(IRUNL,BMRADR,BMPHIR,BMRADL,BMPHIL)
*.----------------------------------------------------------------------
*.-
*.-....   RSWBUC : Puts beam centered version of DST variables
*.-                BMRADR,etc
*.-
*.-
*.-   Input    : run number or 0 to initialize
*.-   Output   : alters merged angular variables
*.-   Called   : ?
*.-   Calls    : rswbmf
*.-   Seq.     :
*.-
*.-   Author   : Philip Hart
*.-   Version  : 1.00
*.-   Created  :  9-JUN-1994
*.    LAST MOD : 18-Mar-00
*.-
*. Modification Log.
*. 18-Mar-00 M.Schroder Use position from BEAM bank for all MC
*.  7-May-99 M.Schroder Fix edit descriptor (for linux)
*. 15-Apr-1998 moved data statements
*. 5-Mar-1996 pass beam centered coordinates out
*.              as variables
*. 03-Jul-97 G. Martinez Reset Beam spot to zero is to big
*.
*.----------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,CRO.
+SEQ,ROSWVA.
+SEQ,ROSWBM.
*.----------------------------------------------------------------------
      INTEGER IRUNL,LRUN
      SAVE LRUN
*
*--   beam centered variables returned
*
      REAL BMRADR(MAXCLS),BMRADL(MAXCLS)
      REAL BMPHIR(MAXCLS),BMPHIL(MAXCLS)
*     Variables to SUSWBM
      INTEGER    INFO
      REAL       BSP(3),EBSP(3),EXC(2,2),EEXC(2,2)
*
      INTEGER I
      INTEGER LGNCT, LBEAM
      REAL XBM,YBM,ZBM,TILTY,ZDIST,BTWIST
      REAL PI
      PARAMETER (ZDIST=246.0225)
C distance from nominal beam spot to detector center of measurement
      PARAMETER (PI=3.14159)
      PARAMETER (BTWIST=0.003288)
C for the effect of the bfield (radians)
      REAL XTMP,YTMP
C
C reality check
C
      LOGICAL FIRST
      SAVE    FIRST
C
      DATA    LRUN   /0/
      DATA    FIRST /.TRUE./

C tilt is optional
      IF(.NOT.LTILTY) TILTY=0.00
      IF(LTILTY) TILTY=0.02

C Monte Carlo?
      IF ( IRDEXP .GT. 1000 ) THEN
C Preset the variables
        XBM = 0.
        YBM = 0.
        ZBM = 0.
C Look for the BEAM bank
        LGNCT = LQ ( LDAC-LLGNCT )
        IF ( LGNCT .LE. 0 ) THEN
          CHREP = 'No GNCT bank found.'
          CALL REPORT('RSWBUC',4,'W')
        ELSE
          LBEAM = LQ( LGNCT-LLBEAM )
          IF ( LBEAM .LE. 0 ) THEN
            CHREP = 'No BEAM bank found.'
            CALL REPORT('RSWBUC',5,'W')
          ELSE
            XBM = Q( LBEAM+1 )
            YBM = Q( LBEAM+2 )
            ZBM = Q( LBEAM+3 )
          ENDIF
        ENDIF
      ELSE
C Real Data
        IF(IRUNL.GT.4000.AND.IRUNL.LT.6000) IBFL=0
        IF(IRUNL.GE.6000)  THEN
          IF(ISTRBL.EQ.ISTRBR) THEN
            IBFL=ISTRBR
          ELSE
            IBFL=0
          END IF
        END IF
*     
        IF (IRUNL.GT.4000) THEN
          CALL SUSWBM(IRUNL,IBFL,BSP,EBSP,EXC,EEXC,INFO)
          XBM=BSP(1)
          YBM=BSP(2)
          ZBM=BSP(3)
          IF((XBM.GT.1.).OR.(YBM.GT.1.).OR.(ZBM.GT.10.)) THEN
            XBM=0.
            YBM=0.
            ZBM=0.
            CHREP='BEAM SPOT OFFSET TOO BIG: RESET TO 0'
            CALL REPORT('RSWBUC',3,'W')
          ENDIF
        ELSE IF(IRUNL.EQ.1) THEN
          XBM = BSXMC
          YBM = BSYMC
          ZBM = BSZMC
*     
        END IF
*     
      ENDIF
      IF(IRUNL.NE.LRUN) FIRST=.TRUE.
      IF(FIRST) THEN
        LRUN=IRUNL
        FIRST = .FALSE.
*     
        WRITE(CHREP,1001) IRUNL
 1001   FORMAT(1X, 'SW BEAM SPOT POSITION FOR RUN',I8)
        CALL REPORT ('RSWBUC', 1, 'I')
        WRITE(CHREP,1002) XBM,YBM,ZBM
 1002   FORMAT(1X, 'X,Y,Z (cm) ',3F12.8)
        CALL REPORT ('RSWBUC', 2, 'I')
      END IF
*     
      DO 101 I=1,NCLSR
        IF(RADR(I).GT.0.) THEN
          XTMP=RADR(I)*COS(PHIR(I))-XBM
          YTMP=RADR(I)*SIN(PHIR(I))-YBM-TILTY
          BMRADR(I)=SQRT(XTMP**2+YTMP**2)*(1+ZBM/ZDIST)
          BMPHIR(I)=ATAN2(YTMP,XTMP)-BTWIST
          IF(BMPHIR(I).LT.0.) BMPHIR(I)=BMPHIR(I)+2.*PI
        ENDIF
 101  CONTINUE
      DO 102 I=1,NCLSL
        IF(RADL(I).GT.0.) THEN
          XTMP=RADL(I)*COS(PHIL(I))-XBM
          YTMP=RADL(I)*SIN(PHIL(I))-YBM+TILTY
          BMRADL(I)=SQRT(XTMP**2+YTMP**2)*(1-ZBM/ZDIST)
          BMPHIL(I)=ATAN2(YTMP,XTMP)+BTWIST
          IF(BMPHIL(I).LT.0.) BMPHIL(I)=BMPHIL(I)+2.*PI
        ENDIF
 102  CONTINUE
 999  RETURN
      END
+DECK,RGAM.
      SUBROUTINE RGAM(FLAG1,FLAG2,VMUON,VBWALL)
************************************************************************
*.
*...RGAM     Preselection for events with a good em cluster:
*.
*.  o E > 1.5 GeV in barrel or E > 2.5 GeV in endcap
*.  o Cosmic rejection: veto on any muon segment or group of HCAL strips
*.  o Beam wall rejection: veto on >3 tracks pointing away from origin
*.
*.   This subroutine returns FLAG1=TRUE if event passes preselection.
*.   FLAG2 is set true if a photon conversion candidate has been
*.         found by SUBROUTINE RPHCON
*.   VMUON  = TRUE if event was vetoed by the cosmic/halo muon veto
*.   VBWALL = TRUE if event was vetoed by the beam-wall veto
*.
*. SEQUENCE  : RGAMCM ODPAR RBITFUNC
*. CALLS     : ODNBLK ODFBLK RPHCON
*. CALLED    : ROEVTY
*.
*. AUTHOR    : D. Karlen
*. CREATED   : 06-APR-1990
*. LAST MOD  :  25-Sep-95
*.
*. Modification log:
*. 25-Sep-95  M.Schroder   avoid double counting of tracks if CXUNCZ fails
*. 27-Aug-91  S.Weisz      Use RBITFUNC sequence
*. 16-May-91  G.W. Wilson  Remove HP strips from RGAM muon veto.
*. 11-May-91  G.W. Wilson  Add endcap 2nd most energetic block cut,
*.                         and change to an E cut in endcap.
*. 10-May-91  G.W. Wilson  Unconstrain tracks in z for beam-wall veto.
*. 02-May-91  G.W. Wilson  Re-write using only clusters.
*. 14-Apr-91  G.W. Wilson  Pass muon and beam-wall veto flags.
*. 02-APR-91  C. Hawkes    Call RPHCON (photon conversions) for FLAG2
*. 10-OCT-90  D. Karlen    Reduce thresholds from 1 GeV to 0.7 GeV
*. 11-MAY-90  D. Karlen    veto on any muon segment
*.
************************************************************************
+SEQ,DECLARE.
+SEQ,RGAMCM.
+SEQ,RBITFUNC.
+SEQ,RCREP.
*
      INTEGER  JBYT
      EXTERNAL JBYT
      LOGICAL FLAG1,FLAG2,VMUON,VBWALL
      REAL PI
      PARAMETER (PI=3.141592654)
* -----------
* DST arrays:
* -----------
+SEQ,ODPAR.
* Specify the maximum number of selected DST blocks to consider:
      INTEGER NCSELX,NHSELX,NMSELX
      PARAMETER (NCSELX=40,NHSELX=40,NMSELX=40)
      INTEGER  NIMOV,NRMOV
      INTEGER  NCBLK,NEBLK,NHBLK,NMBLK
      INTEGER  ICBLK,IEBLK,IHBLK,IMBLK
      INTEGER  NCSEL,NESEL,NHSEL,NMSEL
      INTEGER  ICSEL,IESEL,IHSEL,IMSEL
      INTEGER  ICSELD(NICTRK,NCSELX),IESELD(NIECAL)
      REAL     RCSELD(NRCTRK,NCSELX),RESELD(NRECAL)
      INTEGER  IHSELD(NIHCAL,NHSELX),IMSELD(NIMUON,NMSELX)
      REAL     RHSELD(NRHCAL,NHSELX),RMSELD(NRMUON,NMSELX)
* ------------------
* Internal variables
* ------------------
      INTEGER IERR
      INTEGER  NPOINT
      REAL PT,PTMAX
      INTEGER IEBMAX,IEEMAX
      REAL EBMAX,EETMAX,EBSUM,EETSUM
      INTEGER ISET,IROAD,ILAY,ILROAD(8,3,9),NLAYMX,NLAYSM
      INTEGER IKODE,NDIG,IDIV,IDIG,NUM
      LOGICAL LMBTRK,LMETRK,LHBTRK,LHPTRK,LHETRK
      LOGICAL ECALOK
* ------------------------
* Parameters used for cuts
* ------------------------
      REAL D0CUT,Z0CUT,EBCUT,EECUT,DTHCUT,DPHCUT
      INTEGER NBLCUT,NLCUT,NBWCUT
      REAL FRMCUT,COSCUT,E2NDCT
      PARAMETER (  D0CUT  = 1.0 , Z0CUT  = 20.0 ,
     +             EBCUT  = 1.5 , EECUT  = 2.5  ,
     +             DTHCUT = 0.4 , DPHCUT = 0.4  , NBLCUT = 2   ,
     +             NLCUT  =   3 , NBWCUT = 4    , FRMCUT = 0.99,
     +             E2NDCT = 0.05, COSCUT = 1.00)
* ---------------------------------------------
* Statement functions to access DST information
* ---------------------------------------------
      INTEGER IDUM,JDUM,IDUML,IPHD
      REAL PH1,PH2,TH1,TH2
      REAL PHISEP,THESEP
      INTEGER NHCJ
      REAL D0,Z0,PX,PY
      LOGICAL EBCLUS,EECLUS
      INTEGER NBLO
      REAL EE,EET,ETHETA,EPHI,ETHSEP
      REAL ETHE1,ETHE2,EPHI1,EPHI2,DELTHE,DELPHI,EFRMX
      INTEGER NSTR,HNL14,HNL58,HNL90,I45BIN
      REAL HPHI
      INTEGER MKODE
      PHISEP(PH1,PH2)=ABS(PI-ABS(ABS(PH1-PH2)-PI))
      THESEP(TH1,PH1,TH2,PH2)=ACOS(MIN(0.99999,MAX(-0.99999,
     +   SIN(TH1)*SIN(TH2)*COS(PH1-PH2)+COS(TH1)*COS(TH2))))
      NHCJ(IDUM) = ICSELD(JCNHCJ,IDUM)
      PX(IDUM)   = RCSELD(JCPX,IDUM)
      PY(IDUM)   = RCSELD(JCPY,IDUM)
      D0(IDUM)   = RCSELD(JCD0,IDUM)
      Z0(IDUM)   = RCSELD(JCZ0,IDUM)
      NSTR(IDUM)        = IHSELD(JHNSTR,IDUM)
      HNL14(IDUM,IDUML) = JBYT(IHSELD(JHNL14,IDUM),8*(IDUML-1)+1,8)
      HNL58(IDUM,IDUML) = JBYT(IHSELD(JHNL58,IDUM),8*(IDUML-5)+1,8)
      HNL90(IDUM)       = IHSELD(JHNL90,IDUM)
      HPHI(IDUM)        = RHSELD(JHPHI,IDUM)
      I45BIN(PH1,IPHD)=MOD(INT((PH1*180./PI+(IPHD-1)*15.+360.)/45.),8)+1
      MKODE(IDUM) = IMSELD(JMKODE,IDUM)
* --------------
* Initialization
* --------------
      FLAG1  = .FALSE.
      FLAG2  = .FALSE.
      VMUON  = .FALSE.
      VBWALL = .FALSE.
      ECALOK = .FALSE.
* ---------------------------
* Find the tracks of interest
* ---------------------------
      NCSEL=0
      NPOINT=0
      PTMAX=0
      CALL ODNBLK('CTRK',NCBLK)
      DO 1 ICBLK=1,NCBLK
         ICSEL=MIN(NCSEL+1,NCSELX)
         CALL ODFBLK('CTRK',ICBLK,NICTRK,ICSELD(1,ICSEL),NIMOV,
     +                            NRCTRK,RCSELD(1,ICSEL),NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
            IF(MOD(ICSELD(JCFTYP,ICSEL),32)/16.EQ.1)THEN
               CALL CXUNCZ(NIMOV,NRMOV,ICSELD(1,ICSEL),RCSELD(1,ICSEL),
     +                     ICSELD(1,ICSEL),RCSELD(1,ICSEL),IERR)
               IF(IERR.NE.0)THEN
                  CHREP=' Pbs in CXUNCZ - count it as good'
                  CALL REPORT('RGAM',1,'W')
* If this happens then if the track passes the quality cuts
* we automatically count it as a pointing track
                  IF(NHCJ(ICSEL).GE.30)THEN
                     NCSEL=MIN(NCSEL+1,NCSELX)
                     NPOINT=NPOINT+1
                     PT=SQRT(PX(NCSEL)**2+PY(NCSEL)**2)
                     PTMAX=MAX(PTMAX,PT)
                     GOTO 1
                  ENDIF
               ENDIF
            ENDIF
            IF(NHCJ(ICSEL).GE.30)THEN
               NCSEL=MIN(NCSEL+1,NCSELX)
               IF(ABS(D0(NCSEL)).LE.D0CUT .AND.
     +            ABS(Z0(NCSEL)).LE.Z0CUT)THEN
                  NPOINT=NPOINT+1
                  PT=SQRT(PX(NCSEL)**2+PY(NCSEL)**2)
                  PTMAX=MAX(PTMAX,PT)
               ENDIF
            ENDIF
         ENDIF
 1    CONTINUE
* ----------------------------------
* Find if there is an ECAL cluster of interest
* ----------------------------------
      CALL ODNBLK('ECAL',NEBLK)
      DO 2 IEBLK=1,NEBLK
         CALL ODFBLK('ECAL',IEBLK,NIECAL,IESELD,NIMOV,
     +                            NRECAL,RESELD,NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
*
            IF(
     +         IAND(IESELD(JESOUR),MSKEB).NE.0               .AND.
     +         RESELD(JEERAW).GE.EBCUT                       .AND.
     +         ABS(RESELD(JETHE1)-RESELD(JETHE2)).LE.DTHCUT  .AND.
     +         PHISEP(RESELD(JEPHI1),RESELD(JEPHI2)).LE.DPHCUT    .OR.
     +         IAND(IESELD(JESOUR),MSKEE).NE.0               .AND.
     +         RESELD(JEERAW).GE.EECUT                       .AND.
     +         RESELD(JEFSMX)*RESELD(JEERAW).GT.E2NDCT       .AND.
     +         IESELD(JENBLO).GE.NBLCUT                      .AND.
     +         RESELD(JEFRMX).LE.FRMCUT                      .AND.
     +         ABS(COS(RESELD(JETHET))).LE.COSCUT)  THEN
               ECALOK = .TRUE.
               GOTO   3
*
            ENDIF
         ENDIF
 2    CONTINUE
*
 3    CONTINUE
* ----------------------------------
* Find the HCAL clusters of interest
* ----------------------------------
      NHSEL=0
      CALL ODNBLK('HCAL',NHBLK)
      DO 4 IHBLK=1,NHBLK
         IHSEL=MIN(NHSEL+1,NHSELX)
         CALL ODFBLK('HCAL',IHBLK,NIHCAL,IHSELD(1,IHSEL),NIMOV,
     +                            NRHCAL,RHSELD(1,IHSEL),NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
            IF(NSTR(IHSEL).GE.1.AND.IHSELD(JHSOUR,IHSEL).NE.MSKHP)THEN
               NHSEL=MIN(NHSEL+1,NHSELX)
            ENDIF
         ENDIF
 4    CONTINUE
* --------------------------------------------------------------------
* Find the maximum number of layers hit in any 45 degree road : NLAYMX
* --------------------------------------------------------------------
      DO 10 ISET=1,3
         DO 11 IROAD=1,8
            DO 12 ILAY=1,9
               ILROAD(IROAD,ISET,ILAY)=0
 12         CONTINUE
 11      CONTINUE
 10   CONTINUE
*
      DO 20 IHSEL=1,NHSEL
         DO 21 ILAY=1,4
            IF(HNL14(IHSEL,ILAY).GE.1)THEN
               DO 22 ISET=1,3
                  IROAD=I45BIN(HPHI(IHSEL),ISET)
                  ILROAD(IROAD,ISET,ILAY)=1
 22            CONTINUE
            ENDIF
 21      CONTINUE
         DO 23 ILAY=5,8
            IF(HNL58(IHSEL,ILAY).GE.1)THEN
               DO 24 ISET=1,3
                  IROAD=I45BIN(HPHI(IHSEL),ISET)
                  ILROAD(IROAD,ISET,ILAY)=1
 24            CONTINUE
            ENDIF
 23      CONTINUE
         IF(HNL90(IHSEL).GE.1)THEN
            DO 25 ISET=1,3
               IROAD=I45BIN(HPHI(IHSEL),ISET)
               ILROAD(IROAD,ISET,9)=1
 25         CONTINUE
         ENDIF
 20   CONTINUE
*
      NLAYMX=0
      DO 30 ISET=1,3
         DO 31 IROAD=1,8
            NLAYSM=0
****  Do not use layer 1  *****
            DO 32 ILAY=2,9
               NLAYSM=NLAYSM+ILROAD(IROAD,ISET,ILAY)
 32         CONTINUE
            NLAYMX=MAX(NLAYMX,NLAYSM)
 31      CONTINUE
 30   CONTINUE
* ----------------------------------
* Find the MUON segments of interest: LMBTRK,LMETRK,LHBTRK,LHPTRK,LHETRK
* ----------------------------------
      NMSEL=0
      LMBTRK=.FALSE.
      LMETRK=.FALSE.
      LHBTRK=.FALSE.
      LHPTRK=.FALSE.
      LHETRK=.FALSE.
      CALL ODNBLK('MUON',NMBLK)
      DO 40 IMBLK=1,NMBLK
         IMSEL=MIN(NMSEL+1,NMSELX)
         CALL ODFBLK('MUON',IMBLK,NIMUON,IMSELD(1,IMSEL),NIMOV,
     +                            NRMUON,RMSELD(1,IMSEL),NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
            NMSEL=MIN(NMSEL+1,NMSELX)
            IKODE=MKODE(NMSEL)
            IF(IKODE.GT.0)THEN
               NDIG=LOG10(REAL(IKODE))+1
               IDIV=10**NDIG
               DO 41 IDIG=1,NDIG
                  IDIV=IDIV/10
                  NUM=IKODE/IDIV
                  IF(NUM.EQ.2)THEN
                     LMBTRK=LMBTRK.OR.IDIG.EQ.1
                     LMETRK=LMETRK.OR.IDIG.EQ.2
                     LHBTRK=LHBTRK.OR.IDIG.EQ.3
                     LHPTRK=LHPTRK.OR.IDIG.EQ.4
                     LHETRK=LHETRK.OR.IDIG.EQ.5
                  ENDIF
                  IKODE=IKODE-NUM*IDIV
 41            CONTINUE
            ENDIF
         ENDIF
 40   CONTINUE
*-------------------------------------------
* Define the vetoes
*-------------------------------------------
      VMUON =  (NLAYMX .GE. NLCUT) .OR.
     +         (LMBTRK.OR.LMETRK.OR.LHBTRK.OR.LHPTRK.OR.LHETRK)
      VBWALL = NCSEL-NPOINT.GE.NBWCUT
* ------------------------------------------
* Determine if the event satisifies criteria
* ------------------------------------------
      FLAG1  = ECALOK .AND.
     +         .NOT.VMUON .AND. .NOT.VBWALL
* ---------------------------------
* Finally fill the common variables
* ---------------------------------
      NTRKS=NCSEL
      NTRKSP=NPOINT
      PTTRKX=PTMAX
      NLAYRD=NLAYMX
      MBIT=0
      IF(LMBTRK)MBIT=MBIT+1
      IF(LMETRK)MBIT=MBIT+2
      IF(LHBTRK)MBIT=MBIT+4
      IF(LHPTRK)MBIT=MBIT+8
      IF(LHETRK)MBIT=MBIT+16
*
      EBTH=999.
      EBPH=999.
      EETH=0.0
      EEPH=0.0
      IF(ECALOK)THEN
         EBTH=RESELD(JETHET)
         EBPH=RESELD(JEPHI)
         IF(IAND(IESELD(JESOUR),MSKEB).NE.0)EETH = 1.0
         IF(IAND(IESELD(JESOUR),MSKEE).NE.0)EEPH = 1.0
         ESUMB=RESELD(JEERAW)
         ETSUME=RESELD(JEERAW)*SIN(RESELD(JETHET))
      ENDIF
* ------------------------------------------
* Look for photon conversions to set FLAG2
* ------------------------------------------
      CALL RPHCON(FLAG2)
      RETURN
      END
+DECK,RGEM.
      SUBROUTINE RGEM(FLAG)
************************************************************************
*.
*...RGEM   Preselection of events with em clusters based only on ECAL
*.                  (no vetoes)
*.  o Eraw > 5 GeV
*.  o Nblocks >=2
*.  o 0.25 < frmx < 0.99
*.  o E (2nd most energetic block) > 0.1 GeV
*.
*.   This subroutine returns FLAG=TRUE if event passes preselection.
*.
*. SEQUENCE  : RGEMCM, ODPAR
*. CALLS     : ODNBLK ODFBLK
*. CALLED    : ROEVTY
*.
*. AUTHOR    : G.W. Wilson
*. CREATED   : 02-May-1991
*. LAST MOD  : 26-Sep-95
*.
*. Modification log:
*. 09-May-1991 G.W. Wilson  Add common block
*. 26-Sep-95   M.Schroder Change documentation
************************************************************************
+SEQ,DECLARE.
+SEQ,RGEMCM.
*
      LOGICAL FLAG
      REAL PI
      PARAMETER (PI=3.141592654)
* -----------
* DST arrays:
* -----------
+SEQ,ODPAR.
      INTEGER  NIMOV,NRMOV
      INTEGER  NEBLK,IEBLK
      INTEGER  IE(NIECAL)
      REAL     RE(NRECAL)
* ------------------------
* Parameters used for cuts
* ------------------------
      REAL ECUT,FRMMIN,FRMMAX,E2NDCT
      INTEGER NBLCUT
      PARAMETER (  ECUT = 5.0 , FRMMIN = 0.25 , FRMMAX = 0.99,
     +          E2NDCT = 0.1 , NBLCUT = 2 )
      REAL PH1,PH2,PHISEP
*
      PHISEP(PH1,PH2)=ABS(PI-ABS(ABS(PH1-PH2)-PI))
* --------------
* Initialization
* --------------
      FLAG  = .FALSE.
      RGEMMX = 0.0
* ----------------------------------
* Find if there is an ECAL cluster of interest
* ----------------------------------
      CALL ODNBLK('ECAL',NEBLK)
      DO 1 IEBLK=1,NEBLK
         CALL ODFBLK('ECAL',IEBLK,NIECAL,IE,NIMOV,
     +                            NRECAL,RE,NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
*
            IF(
     +         RE(JEERAW).GE.ECUT                       .AND.
     +         IE(JENBLO).GE.NBLCUT                     .AND.
     +         RE(JEFRMX).LT.FRMMAX                     .AND.
     +         RE(JEFSMX)*RE(JEERAW).GT.E2NDCT          .AND.
     +         RE(JEFRMX).GT.FRMMIN) THEN
               FLAG  = .TRUE.
               IF(RE(JEERAW).GT.RGEMMX)RGEMMX = RE(JEERAW)
            ENDIF
         ENDIF
 1    CONTINUE
*
      END
+DECK,ROPHOT.
      FUNCTION ROPHOT()
*.**********************************************************************
*. 28-11-97 A. Honma
*...1+2 photon "preselection" to be used to identify photon candidate
*...events from the FYZ1 sample that should have the DD data kept.
*...Returns ROPHOT = .TRUE. if the event passes the criteria below.
*.
*. Single photon requirements:
*.  o Ecorr > 0.025*Ebeam for |costh|<0.82 OR
*.  o Ecorr > 0.050*Ebeam for |costh|>0.82
*.  o Nblocks >=2
*.  o frmx < 0.99
*.
*. Two (or more) photon requirements:
*.  o Eraw > 1 for at least 2 clusters
*. 
*. AUTHOR  : A. Honma
*. VERSION : 1.01
*. CREATED : 28-Nov-97
*. LAST MOD: 10-May-98
*.
*. Modification Log.
*. 10-May-98 M.Schroder Add parentheses to the header
*.
*. 17-Apr-98 M.Schroder Turn into function
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,ROPAR.
+SEQ,CRO.
+SEQ,ODPAR.
      LOGICAL  ROPHOT
      INTEGER  NIMOV,NRMOV
      INTEGER  NEBLK,IEBLK
      INTEGER  IE(NIECAL)
      REAL     RE(NRECAL),EBEAM
* ------------------------
* Parameters used for cuts
* ------------------------
      REAL XCUTB,XCUTE,ELCUT,FRMMAX
      INTEGER NBLCUT,IGD,IGL
      PARAMETER (  XCUTB = 0.025 , XCUTE = 0.05 , ELCUT = 1.0,
     + FRMMAX = 0.99, NBLCUT = 2 )
* --------------
* Initialization
* --------------
      EBEAM=IUHEAD(IIEBEA)*.001
      ROPHOT = .FALSE.
      IGD = 0
      IGL = 0
* ----------------------------------
* Find if there is an ECAL cluster of interest
* ----------------------------------
      CALL ODNBLK('ECAL',NEBLK)
      DO 1 IEBLK=1,NEBLK
         CALL ODFBLK('ECAL',IEBLK,NIECAL,IE,NIMOV,
     +                            NRECAL,RE,NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
*
            IF( IE(JENBLO).GE.NBLCUT .AND. RE(JEFRMX).LT.FRMMAX ) THEN
* single photon thresholds
               IF(
     +  (ABS(COS(RE(JETHET))).LE.0.82.AND.RE(JEE)/EBEAM.GE.XCUTB) .OR. 
     +  (ABS(COS(RE(JETHET))).GT.0.82.AND.RE(JEE)/EBEAM.GE.XCUTE) )THEN
                 IGD=IGD+1
               ENDIF
* two photon threshold
               IF(RE(JEERAW).GE.ELCUT)THEN
                 IGL=IGL+1
               ENDIF
            ENDIF
         ENDIF
 1    CONTINUE
      IF( IGD.GE.1 .OR. IGL.GE.2 ) ROPHOT = .TRUE.
*
      END
+DECK,RGTOEM.
      SUBROUTINE RGTOEM(FLAG,FLAGT0,FLAGGT)
************************************************************************
*.
*...RGTOEM   Preselection for events with a good em cluster
*.           associated to a TOF hit in phi.
*.
*.  Modified so as to remove the direct muon and beam-wall veto.
*.  The routine now returns three flags as described below.
*.
*.  Based on code of RGAM, but with TOF criterion expect/hope to
*.  be more robust against noise / lower the energy threshold.
*.  This selection is essentially the TPTOEM trigger.
*.
*.  o E > 0.5 GeV in barrel or Et > 0.5 GeV in endcap
*.    associated with a good TOF bar within 200 mrad in phi.
*.
*.  This subroutine returns FLAG=TRUE if event passes TOF-EM
*.  requirements.
*.  FLAGT0 = .TRUE. if there is some EM energy and
*.  an in time good quality TOF bar is found.
*.  The flag is set to .FALSE. if a downward travelling
*.  cosmic is identified.
*.  (Explicit association of the specific TOF bar
*.   with the cluster is not needed for this flag)
*.  FLAGGT = .TRUE. if there is some EM energy and
*.  a good quality track - cuts are designed to be sensitive to
*.  long-lived decays. For the track selection , the track must
*.  be associated in phi to an EM cluster and events with several
*.  tracks with poor z0 close to the beam in r-phi are rejected as
*.  beam-wall.
*.
*.  It is intended that eventually the following will
*.  be accepted by the PHYS1 selection.
*.
*.     Status quo    : TOEM.AND.(.NOT.VMUON).AND.(.NOT.VBWALL)
*.  Safe for hadrons : TOEM.AND.FLAGT0.AND.(.NOT.VBWALL)
*.  Safe for V0's    : TOEM.AND.FLAGT0.AND.FLAGGT
*.
*.
*. SEQUENCE  : ODPAR RBITFUNC
*. CALLS     : ODNBLK ODFBLK RPHCON
*. CALLED    : ROEVTY
*.
*. AUTHOR    : G.W. Wilson
*. CREATED   : 15-Apr-1991
*. LAST MOD  : 21-Sep-1992
*.
*. Modification log:
*. 21-Sep-1992  G.W. Wilson  Remove PRINT statements
*. 05-Sep-1992  G.W. Wilson  Toughen up the track selection.
*.                           Make it powerful against beam-wall.
*. 01-Sep-1992  G.W. Wilson  Add downward travelling cosmic veto
*.                           to the FLAGT0 condition.
*. 30-Aug-1992  G.W. Wilson  Fix bug in track loop ('TOF' -> 'CTRK')
*. 20-Aug-1992  G.W. Wilson  Add tight TOF and track criteria
*.                           to recuperate events vetoed by
*.                           muon and beam-wall vetoes.
*.
*. 27-Aug-1991  S.Weisz      Use RBITFUNC sequence
*. 30-Apr-1991  G.W. Wilson  Fix bug in endcap loop
*. 30-Apr-1991  G.W. Wilson  Add TOEM selection for all clusters
*.                           Previously one only looked to see if the
*.                         highest energy cluster had an associated TOF.
************************************************************************
+SEQ,DECLARE.
*
+SEQ,RBITFUNC.
*
      LOGICAL FLAG
      LOGICAL FLAGT0,FLAGGT,LCANDI
      REAL PI
      PARAMETER (PI=3.141592654)
* -----------
* DST arrays:
* -----------
+SEQ,ODPAR.
+SEQ,ODQTOF.
* Specify the maximum number of selected DST blocks to consider:
      INTEGER NESELX,NTSELX
      PARAMETER (NESELX=40,NTSELX=160)
      INTEGER  NIMOV,NRMOV
      INTEGER  NEBLK,IEBLK,NESEL,IESEL
      INTEGER  NTBLK,ITBLK
      INTEGER  IESELD(NIECAL,NESELX),ITSELD(NITOF,NTSELX)
      REAL     RESELD(NRECAL,NESELX),RTSELD(NRTOF,NTSELX)
* Cosmic stuff
      REAL TOF(2),PHI(2),THETA(2)
      REAL TSEPN,TSEPXY,DTTEST
      INTEGER NOKLR,IUP,IDOWN
* For CTRKs let's not use so much space !
      INTEGER ITK(NICTRK),ICTRK,NCTRK
      REAL RTK(NRCTRK)
      REAL T0,PT,ZUNC
* ------------------
* Internal variables
* ------------------
      INTEGER IEBMAX,IEEMAX
      REAL EBMAX,EETMAX,EBSUM,EETSUM
* ------------------------
* Parameters used for cuts
* ------------------------
      REAL EBCUT,EECUT,ETHCUT,DTHCUT,DPHCUT
      INTEGER NBLCUT
      REAL FRMCUT,EBSCUT,EETCUT,COSCUT
      REAL DPHTEM
      REAL T0MIN,T0MAX,PTCUT
      REAL COSTMX
      INTEGER NHCJCT
      REAL TSEPCT,TXYCUT,DTMCUT,DTPCUT
      REAL D0CUT
      REAL HPTCUT,DPETCT,Z0DRCT
      LOGICAL LGDTRK
      INTEGER NBADTK,NTOTTK
      PARAMETER ( EBCUT  = 0.1 , EECUT  = 0.5  , ETHCUT = 0.3 ,
     +            DTHCUT = 0.4 , DPHCUT = 0.4  , NBLCUT = 2   ,
     +            FRMCUT = 0.99, EBSCUT = 0.5  , EETCUT = 0.5 ,
     +            COSCUT = 0.90, DPHTEM = 0.2 ,
     +            T0MIN = -5.0, T0MAX = 5.0, PTCUT = 0.1,NHCJCT=20 ,
     +            COSTMX = 0.9, Z0DRCT = 1.0,D0CUT = 10.0)
      PARAMETER ( HPTCUT = 1.0, DPETCT = 0.2 )
      PARAMETER ( TSEPCT = 7.5, TXYCUT = 5.0, DTMCUT = -2.5,
     +            DTPCUT =  5.0  )
* ---------------------------------------------
* Statement functions to access DST information
* ---------------------------------------------
      INTEGER IDUM,JDUM
      REAL PH1,PH2,TH1,TH2
      REAL PHISEP,THESEP
      LOGICAL EBCLUS,EECLUS
      INTEGER NBLO
      REAL EE,EET,ETHETA,EPHI,ETHSEP
      REAL ETHE1,ETHE2,EPHI1,EPHI2,DELTHE,DELPHI,EFRMX
      REAL TOFPHI
      INTEGER ITFLAG
      REAL EMTOSP
      PHISEP(PH1,PH2)=ABS(PI-ABS(ABS(PH1-PH2)-PI))
      THESEP(TH1,PH1,TH2,PH2)=ACOS(MIN(0.99999,MAX(-0.99999,
     +   SIN(TH1)*SIN(TH2)*COS(PH1-PH2)+COS(TH1)*COS(TH2))))
      EBCLUS(IDUM) = IAND(IESELD(JESOUR,IDUM),MSKEB).NE.0
      EECLUS(IDUM) = IAND(IESELD(JESOUR,IDUM),MSKEE).NE.0
      NBLO(IDUM)   = IESELD(JENBLO,IDUM)
      EE(IDUM)     = RESELD(JEERAW,IDUM)
      ETHETA(IDUM) = RESELD(JETHET,IDUM)
      EET(IDUM)    = EE(IDUM)*SIN(ETHETA(IDUM))
      EPHI(IDUM)   = RESELD(JEPHI,IDUM)
      ETHSEP(IDUM,JDUM) = THESEP(ETHETA(IDUM),EPHI(IDUM),
     +                           ETHETA(JDUM),EPHI(JDUM))
      ETHE1(IDUM)  = RESELD(JETHE1,IDUM)
      ETHE2(IDUM)  = RESELD(JETHE2,IDUM)
      EPHI1(IDUM)  = RESELD(JEPHI1,IDUM)
      EPHI2(IDUM)  = RESELD(JEPHI2,IDUM)
      DELTHE(IDUM) = ABS(ETHE1(IDUM)-ETHE2(IDUM))
      DELPHI(IDUM) = PHISEP(EPHI1(IDUM),EPHI2(IDUM))
      EFRMX(IDUM)  = RESELD(JEFRMX,IDUM)
      ITFLAG(IDUM) = ITSELD(JTFLAG,IDUM)
      TOFPHI(IDUM) = RTSELD(JTPHI,IDUM)
      EMTOSP(IDUM,JDUM) = PHISEP(EPHI(IDUM),TOFPHI(JDUM))
* --------------
* Initialization
* --------------
      FLAG   = .FALSE.
      FLAGT0 = .FALSE.
      FLAGGT = .FALSE.
      LCANDI = .FALSE.
* ----------------------------------
* Find the ECAL clusters of interest
* ----------------------------------
      NESEL=0
      EBMAX=0.
      IEBMAX=0
      EETMAX=0.
      IEEMAX=0
      CALL ODNBLK('ECAL',NEBLK)
      DO 1 IEBLK=1,NEBLK
         IESEL=MIN(NESEL+1,NESELX)
         CALL ODFBLK('ECAL',IEBLK,NIECAL,IESELD(1,IESEL),NIMOV,
     +                            NRECAL,RESELD(1,IESEL),NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
*
            IF(EBCLUS(IESEL).AND.EE(IESEL).GE.EBCUT.AND.
     +                           DELTHE(IESEL).LE.DTHCUT.AND.
     +                           DELPHI(IESEL).LE.DPHCUT        .OR.
     +         EECLUS(IESEL).AND.EE(IESEL).GE.EECUT.AND.
     +                           NBLO(IESEL).GE.NBLCUT.AND.
     +                           EFRMX(IESEL).LE.FRMCUT.AND.
     +                           ABS(COS(ETHETA(IESEL))).LE.COSCUT)THEN

               NESEL=MIN(NESEL+1,NESELX)
*
               IF(  (EBCLUS(IESEL).AND.EE(IESEL).GT.EBSCUT).OR.
     +           (EECLUS(IESEL).AND.EET(IESEL).GT.EETCUT)   )THEN
                 LCANDI = .TRUE.
               ENDIF
               IF(EBCLUS(NESEL).AND.EE(NESEL).GT.EBMAX)THEN
                  EBMAX=EE(NESEL)
                  IEBMAX=NESEL
               ENDIF
               IF(EECLUS(NESEL).AND.EET(NESEL).GT.EETMAX)THEN
                  EETMAX=EET(NESEL)
                  IEEMAX=NESEL
               ENDIF
            ENDIF
         ENDIF
 1    CONTINUE
* ----------------------------------------------------------------------
* Sum up energy around the largest energy EB cluster : EBSUM
* and the transverse energy around largest trans. en EE cluster : EETSUM
* ----------------------------------------------------------------------
      EBSUM=EBMAX
      EETSUM=EETMAX
      DO 2 IESEL=1,NESEL
         IF(IEBMAX.NE.0.AND.IESEL.NE.IEBMAX)THEN
            IF(ETHSEP(IESEL,IEBMAX).LE.ETHCUT)EBSUM=EBSUM+EE(IESEL)
         ENDIF
         IF(IEEMAX.NE.0.AND.IESEL.NE.IEEMAX)THEN
            IF(ETHSEP(IESEL,IEEMAX).LE.ETHCUT)EETSUM=EETSUM+EET(IESEL)
         ENDIF
 2    CONTINUE
*
* Check if any reasonable EM clusters or cones of clusters
*
      IF(EBSUM.GT.EBSCUT.OR.EETSUM.GT.EETCUT)LCANDI = .TRUE.
      IF(.NOT.LCANDI)RETURN
*
      CALL ODNBLK('TOF ',NTBLK)
* Check if any in time good TOF counters.
* While checking this we count the number of counters
* with good info at left and right. We jump out early if
* we find an in time TOF counter and too many
* for the subsequent downward travelling cosmic veto.
      NOKLR = 0
      DO 11 ITBLK=1,NTBLK
         CALL ODFBLK('TOF',ITBLK,NITOF,ITSELD(1,ITBLK),NIMOV,
     +                           NRTOF,RTSELD(1,ITBLK),NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
            CALL ODTQUA(ITFLAG(ITBLK))
            IF(TFOKLR)THEN
               NOKLR = NOKLR + 1
               IF(NOKLR.LE.2)THEN
* Fill arrays for later cosmic veto
                  TOF(NOKLR) = RTSELD(JTTOF,ITBLK)
                  THETA(NOKLR) = RTSELD(JTTHET,ITBLK)
                  PHI(NOKLR) = RTSELD(JTPHI,ITBLK)
               ENDIF
               IF(FLAGT0.AND.NOKLR.GE.3)GOTO 911
               T0 = RTSELD(JTTOF,ITBLK)-(7.88/SIN(RTSELD(JTTHET,ITBLK)))
               IF(T0.GT.T0MIN.AND.T0.LT.T0MAX)THEN
                  FLAGT0 = .TRUE.
* We could also check that this TOF is associated to the
* EM cluster - but why complicate matters given that any
* events of interest will have at least one TOF associated to
* a cluster.
               ENDIF
            ENDIF
         ENDIF
 11   CONTINUE
 911  CONTINUE
* Implement downward travelling cosmic veto for events with
* at least one TOF hit in-time and two and only two OKLR TOF
* counters
      IF(FLAGT0.AND.NOKLR.EQ.2)THEN
* First check the expected time separation of
* the two hits
         TSEPN = 7.88*SQRT( (COS(PHI(1)) - COS(PHI(2)))**2 +
     +                      (SIN(PHI(1)) - SIN(PHI(2)))**2 +
     +           ((1./TAN(THETA(1))) - (1./TAN(THETA(2))))**2 )
         IF(TSEPN.GT.TSEPCT)THEN
* Also check only in x-y as large TSEPN could be an
* artefact of poor TB z-measurement. (This is really just
* an acoplanarity cut)
            TSEPXY = 7.88*SQRT( (COS(PHI(1)) - COS(PHI(2)))**2 +
     +                          (SIN(PHI(1)) - SIN(PHI(2)))**2 )
            IF(TSEPXY.GT.TXYCUT)THEN
* Check which is uppermost
               IUP = 1
               IDOWN = 2
               IF(SIN(PHI(1)).LT.SIN(PHI(2)))THEN
                  IUP = 2
                  IDOWN = 1
               ENDIF
               DTTEST = TOF(IDOWN) - TOF(IUP) - TSEPN
               IF(DTMCUT.LT.DTTEST.AND.DTTEST.LT.DTPCUT)THEN
* Signed time difference is within tolerance of the
* expected value for a downward travelling cosmic
* In this case we reset the in-time flag to .FALSE.
* The cuts are asymmetric to allow somewhat for the curvature of
* softer cosmic rays.
                  FLAGT0 = .FALSE.
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
* Track loop
*
      CALL ODNBLK('CTRK',NCTRK)
      LGDTRK = .FALSE.
      NTOTTK = 0
      NBADTK = 0
      DO 12 ICTRK=1,NCTRK
         CALL ODFBLK('CTRK',ICTRK,NICTRK,ITK,NIMOV,
     +                           NRCTRK,RTK,NRMOV)
         IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
            PT = SQRT(RTK(JCPX)**2+RTK(JCPY)**2)
            IF(PT.GT.PTCUT.AND.ITK(JCNHCJ).GE.NHCJCT)THEN
               NTOTTK = NTOTTK + 1
               CALL ODUNCZ(ICTRK,ZUNC)
               IF(ABS(ZUNC)/RTK(JCR1).GT.Z0DRCT.AND.
     +                 ABS(RTK(JCD0)).LT.D0CUT)THEN
* track misses by a lot in z - and is still
* close enough to origin in r-phi to be beam-pipe related
* - so unlikely to be a decay track - count it as junk
                  NBADTK = NBADTK + 1
               ENDIF
* Now look for a moderately high pT track with some
* pointing in z - must be vaguely in the barrel too
* and associated to an EM cluster (if we haven't found one yet)
               IF(.NOT.LGDTRK)THEN
                  IF(ABS(RTK(JCPZ)/RTK(JCP)).LT.COSTMX.AND.
     +               PT.GT.HPTCUT.AND.
     +               ABS(ZUNC)/RTK(JCR1).LT.Z0DRCT)THEN
                     DO 13 IESEL=1,NESEL
                        IF(PHISEP(EPHI(IESEL),RTK(JCPHEC))
     +                                     .LT.DPETCT)THEN
                           LGDTRK = .TRUE.
                        ENDIF
  13                 CONTINUE
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
 12   CONTINUE
      IF(LGDTRK)THEN
         FLAGGT = .TRUE.
* If at least 3 bad tracks and this represents more than 1/3
* of all tracks - then the track selection bit is not set
         IF(NBADTK.GE.3.AND.3*NBADTK.GT.NTOTTK)FLAGGT = .FALSE.
      ENDIF
* ----------------------------------------------------------------------
* Find if there is a good quality TOF bar (hits in both TDCs)
* associated in phi within DPHTEM to the EB or EE photon candidate
* ----------------------------------------------------------------------
* Barrel
      IF(EBSUM.GT.EBSCUT)THEN
         DO 3 ITBLK=1,NTBLK
            CALL ODFBLK('TOF',ITBLK,NITOF,ITSELD(1,ITBLK),NIMOV,
     +                            NRTOF,RTSELD(1,ITBLK),NRMOV)
            IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
               IF(EMTOSP(IEBMAX,ITBLK).LT.DPHTEM)THEN
                  CALL ODTQUA(ITFLAG(ITBLK))
                  IF(TFOKLR)THEN
                     FLAG = .TRUE.
                     RETURN
                  ENDIF
               ENDIF
            ENDIF
 3       CONTINUE
      ENDIF
*
* Endcap (I know they don't overlap too much !)
* This is meant to select overlap region photons - hence
* the cos(theta) cut. N.B. TOFOR . (TPEML + TPEMR) should
* be in the trigger.
*
      IF(EETSUM.GT.EETCUT)THEN
         DO 4 ITBLK=1,NTBLK
            CALL ODFBLK('TOF',ITBLK,NITOF,ITSELD(1,ITBLK),NIMOV,
     +                            NRTOF,RTSELD(1,ITBLK),NRMOV)
            IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
               IF(EMTOSP(IEEMAX,ITBLK).LT.DPHTEM)THEN
                  CALL ODTQUA(ITFLAG(ITBLK))
                  IF(TFOKLR)THEN
                     FLAG = .TRUE.
                     RETURN
                  ENDIF
               ENDIF
            ENDIF
 4       CONTINUE
      ENDIF
*
* Now loop over all clusters which are selected and are above the
* cone cuts to see if any are associated to a good TOF hit
*
      DO 5 IESEL=1,NESEL
         IF(  (EBCLUS(IESEL).AND.EE(IESEL).GT.EBSCUT).OR.
     +        (EECLUS(IESEL).AND.EET(IESEL).GT.EETCUT)   )THEN
            DO 6 ITBLK=1,NTBLK
               CALL ODFBLK('TOF',ITBLK,NITOF,ITSELD(1,ITBLK),NIMOV,
     +                                 NRTOF,RTSELD(1,ITBLK),NRMOV)
               IF(NIMOV.GT.0.AND.NRMOV.GT.0)THEN
                  IF(EMTOSP(IESEL,ITBLK).LT.DPHTEM)THEN
                     CALL ODTQUA(ITFLAG(ITBLK))
                     IF(TFOKLR)THEN
                        FLAG = .TRUE.
                        RETURN
                     ENDIF
                  ENDIF
               ENDIF
 6          CONTINUE
         ENDIF
 5    CONTINUE
*
      END
+DECK,RHLASS.
      SUBROUTINE RHLASS
************************************************************************
*.
*...RHLASS   Associated charged tracks to ecal clusters, allowing
*.           more than one trk/clust but no more than one clust/trk
*.
*. SEQUENCE  : HLODCM HLCUTS RCREP
*. CALLS     : REPORT
*. CALLED    : RHLSEL
*.
*. AUTHOR    : K. Riles (condensed and looser version of heavy lepton
*.                       working group selection program written by
*.                       J.Hobbs J.Kroll F.Merritt M.Redmond
*.                       K.Riles I.Wingerter)
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
*
* Associates tracks to ecal showers. More than 1 track can be assigned
* to a cluster, but at most 1 cluster per track. The association of
* a cluster to a track is to take highest energy cluster within
* delta phi of 50 mrad and delta theta of 150 mrad of track.
* Note: this routine redefines the original OD variables CIECA and ENCTR
*
+SEQ,DECLARE.
*
+SEQ,HLODCM.
+SEQ,HLCUTS.
+SEQ,RCREP.
*
      INTEGER I,J,JMAX
      REAL EMAX,DELPHI,DELTHE
*
      REAL     MODPHI
      EXTERNAL MODPHI
*
* Initialize number of tracks associated to clusters
*
      DO 5 I=1,NECAL
        ENCTR(I)=0
 5    CONTINUE
*
* Loop over charged tracks, require good track with sufficient momentum
*
      DO 10 I=1,NCTRK
        CIECA(I)=0
        IF(CQUAL(I).LE.0)GOTO 10
        IF(CP(I).LE.MIN(THRKCT,SUMPMX))GOTO 10
        EMAX=0.
        JMAX=0
*
* Loop over ecal clusters to find most energetic in angular window
*
        DO 8 J=1,NECAL
          IF(EQUAL(J).LE.0)GOTO 8
          DELPHI=ABS(MODPHI(CPHEC(I)-EPHI(J)))
          IF(DELPHI.GT.DPHIMX)GOTO 8
          DELTHE=ABS(MODPHI(CTHEC(I)-ETHET(J)))
          IF(DELTHE.GT.DTHEMX)GOTO 8
          IF(EE(J).GT.EMAX)THEN
            EMAX=EE(J)
            JMAX=J
          ENDIF
 8      CONTINUE
*
* Store association info
*
        IF(JMAX.GT.0)THEN
          CIECA(I)=JMAX
          IF(ENCTR(JMAX).GE.ENCTMX)THEN
            WRITE(CHREP,9)JMAX,ENCTMX
 9          FORMAT('ECAL clust',I3,' has more than',I3,' assoc tracks')
            CALL REPORT('RHLASS',1,'W')
          ELSE
            ENCTR(JMAX)=ENCTR(JMAX)+1
            EICTR(ENCTR(JMAX),JMAX)=I
          ENDIF
        ENDIF
 10   CONTINUE
*
      RETURN
      END
*
+DECK,RHLCLS.
      SUBROUTINE RHLCLS(CLOMAS)
****************************************************************
*.
*...RHLCLS    Inclusive close mass heavy lepton selection.
*.
*. SEQUENCE  : ROPAR CRO ODPAR HLODCM HLCONS
*. CALLS     :
*. CALLED    : RHLSEL
*.
*. AUTHOR    : H. Oh
*. CREATED   : 07-OCT-1990
*. LAST MOD  : 07-OCT-1990
*.
*. Modification log:
*.
****************************************************************
*
+SEQ,DECLARE.
*
      LOGICAL CLOMAS
*
*  CLOMAS is returned true for events satisfying requirments.
*
+SEQ,ROPAR.
+SEQ,CRO.
+SEQ,ODPAR.
+SEQ,HLODCM.
+SEQ,HLCONS.
*
      INTEGER BLK,NGOOD,NFLAG,TRK(2)
      REAL CCOST,ACP
*
      CLOMAS=.FALSE.
*
*.... Only two good barrel tracks
      NGOOD=0
      NFLAG=0
      DO 20 BLK=1,GNCTR
        IF(ABS(CD0(BLK)).GT..5)      GOTO 20
        IF(ABS(CZ0(BLK)).GT.40.)     GOTO 20
        IF(CNHCJ(BLK).LT.30)         GOTO 20
        IF(CPXY(BLK).LT..13)         GOTO 20
        CCOST=ABS(CPZ(BLK)/CP(BLK))
        IF(CCOST.GT..95)             GOTO 20
        NGOOD=NGOOD+1
        IF(NGOOD.LE.2) TRK(NGOOD)=BLK
        IF(CNHCJ(BLK).LT.80)         GOTO 20
        IF(CCOST.GT..7)              GOTO 20
        NFLAG=NFLAG+1
   20 CONTINUE

      IF(NFLAG.LT.2) RETURN
      IF(NGOOD.NE.2) RETURN
*
*.... Oppositely charged pair
      IF(CQ(TRK(1))+CQ(TRK(2)).NE.0.) RETURN
*
*.... Acoplanarity
      ACP=ABS( CPHI0(TRK(1))-CPHI0(TRK(2)) )
      ACP=PI-MIN(ACP,TWOPI-ACP)
      IF(ACP.LT..4) RETURN
*
      CLOMAS=.TRUE.
*
      RETURN
      END
*
+DECK,RHLFIL.
      SUBROUTINE RHLFIL
************************************************************************
*.
*...RHLFIL   Fills kinematic variables and quality flags for heavy
*.           lepton selection
*.
*. SEQUENCE  : HLCUTS RBITFUNC
*. CALLS     :
*. CALLED    : RHLSEL
*.
*. AUTHOR    : K. Riles (condensed and looser version of heavy lepton
*.                       working group selection program written by
*.                       J.Hobbs J.Kroll F.Merritt M.Redmond
*.                       K.Riles I.Wingerter)
*. CREATED   : 06-Apr-1990
*. LAST MOD  : 27-Aug-1991
*.
*. Modification log:
*.  27-Aug-91  S.Weisz    Use RBITFUNC sequence
*.  22-Jun-91  K.Riles    Z0 values deconstrained with ODUNCZ
*.
************************************************************************
*
+SEQ,DECLARE.
*
+SEQ,RBITFUNC.
+SEQ,HLCUTS.
+SEQ,HLODCM.
+SEQ,RCREP.
*
      INTEGER I
      REAL SINTHE
*
* Fill original OD variables
*
      CALL ODFILL
*
* Check for excessive track or cluster multiplicity
*
      IF(GNCTR.GT.NCTRKM)THEN
        WRITE(CHREP,1)GNCTR,NCTRKM
 1      FORMAT('Too many charged tracks:',I6,' (maximum allowed=',I6)
        CALL REPORT('RHLFIL',1,'W')
      ENDIF
      NCTRK=MIN(GNCTR,NCTRKM)
*
      IF(GNECA.GT.NECALM)THEN
        WRITE(CHREP,2)GNECA,NECALM
 2      FORMAT('Too many ecal clusters:',I6,' (maximum allowed=',I6)
        CALL REPORT('RHLFIL',2,'W')
      ENDIF
      NECAL=MIN(GNECA,NECALM)
*
* Get total, transverse momenta, and cos(theta)
*
      DO 10 I=1,NCTRK
        CP(I)=SQRT(CPX(I)*CPX(I)+CPY(I)*CPY(I)+CPZ(I)*CPZ(I))
        CPXY(I)=SQRT(CPX(I)*CPX(I)+CPY(I)*CPY(I))
        CALL ODUNCZ(I,CZ0(I))
 10   CONTINUE
*
* Flag quality of central tracks
*
      DO 20 I=1,NCTRK
        CQUAL(I)=0
        IF(ABS(CPZ(I)/CP(I)).GT.GCOSMX)   GOTO 20
        IF(ABS(CD0(I)).GT.GD0MX)          GOTO 20
        IF(ABS(CZ0(I)).GT.GZ0MX)          GOTO 20
        IF(CPXY(I).LT.GPXYMN)             GOTO 20
        IF(CNHCJ(I).LT.GNCJMN)            GOTO 20
        CQUAL(I)=1
        IF(CPXY(I).LT.PTTGHT)             GOTO 20
        IF(ABS(CD0(I)).GT.D0TGHT)         GOTO 20
        IF(ABS(CZ0(I)).GT.Z0TGHT)         GOTO 20
        CQUAL(I)=2
 20   CONTINUE
*
* Do kinematics for ecal clusters
*
      DO 30 I=1,NECAL
        SINTHE=SIN(ETHET(I))
        EPX(I)=EE(I)*COS(EPHI(I))*SINTHE
        EPY(I)=EE(I)*SIN(EPHI(I))*SINTHE
        EPZ(I)=EE(I)*COS(ETHET(I))
 30   CONTINUE
*
* Flag quality of ecal clusters
*
      DO 40 I=1,NECAL
        EQUAL(I)=0
        IF(IAND(ESOUR(I),128).NE.0.AND.EE(I).GE.EEBTHR)EQUAL(I)=1
        IF(IAND(ESOUR(I),256).NE.0.AND.EE(I).GE.EEETHR)EQUAL(I)=1
        IF(IAND(ESOUR(I),256).NE.0.AND.EE(I).GT.5.
     *     .AND.EFRMX(I).GE.0.99)EQUAL(I)=0
 40   CONTINUE
*
      RETURN
      END
*
*
+DECK,RHLINI.
      SUBROUTINE RHLINI
************************************************************************
*.
*...RHLINI   Initializes constants, control variables for heavy
*.           lepton selection
*.
*. SEQUENCE  : HLCONS HLCUTS
*. CALLS     :
*. CALLED    : ROPINI
*.
*. AUTHOR    : K. Riles (condensed and looser version of heavy lepton
*.                       working group selection program written by
*.                       J.Hobbs J.Kroll F.Merritt M.Redmond
*.                       K.Riles I.Wingerter)
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
*
+SEQ,DECLARE.
*
+SEQ,HLCONS.
+SEQ,HLCUTS.
*
      REAL     ACOSCK
      EXTERNAL ACOSCK
*
      PI=ACOSCK(-1.)
      TWOPI=2.*PI
      RADIAN=180./PI
*
      D0TGHT=0.5
      Z0TGHT=40.
      PTTGHT=0.15
*
      NGDMN=2
      GCOSMX=0.985
      GPXYMN=0.15
      GD0MX=1.0
      GZ0MX=80.
      GNCJMN=30
*
      THRKCT=0.5
      THRKEC=0.5
      EEBTHR=0.10
      EEETHR=0.20
      DPHIMX=0.05
      DTHEMX=0.15
*
      EVISMN=7.0
      EVISMX=70.0
      PTOFST=7.0
      PTFACT=0.17
*
      PISMN1=5.0
      PISMN2=2.0
      CSISMX=0.9
      HLFANG=0.524
      SUMPMX=1.
      EEXTMX=4.
*
      ACOLMN=0.250
      TMSMN=2.0
*
      CALL FFKEY('D0TGHT'  ,D0TGHT,     1,'REAL'   )
      CALL FFKEY('Z0TGHT'  ,Z0TGHT,     1,'REAL'   )
      CALL FFKEY('PTTGHT'  ,PTTGHT,     1,'REAL'   )
*
      CALL FFKEY('NGDMN'   ,NGDMN ,     1,'INTEGER')
      CALL FFKEY('GCOSMX'  ,GCOSMX,     1,'REAL'   )
      CALL FFKEY('GPXYMN'  ,GPXYMN,     1,'REAL'   )
      CALL FFKEY('GD0MX'   ,GD0MX ,     1,'REAL'   )
      CALL FFKEY('GZ0MX'   ,GZ0MX ,     1,'REAL'   )
      CALL FFKEY('GNCJMN'  ,GNCJMN,     1,'INTEGER')
*
      CALL FFKEY('THRKCT'  ,THRKCT,     1,'REAL'   )
      CALL FFKEY('THRKEC'  ,THRKEC,     1,'REAL'   )
      CALL FFKEY('EEBTHR'  ,EEBTHR,     1,'REAL'   )
      CALL FFKEY('EEETHR'  ,EEETHR,     1,'REAL'   )
      CALL FFKEY('DPHIMX'  ,DPHIMX,     1,'REAL'   )
      CALL FFKEY('DTHEMX'  ,DTHEMX,     1,'REAL'   )
*
      CALL FFKEY('HLFANG'  ,HLFANG,     1,'REAL'   )
      CALL FFKEY('PISMN1'  ,PISMN1,     1,'REAL'   )
      CALL FFKEY('PISMN2'  ,PISMN2,     1,'REAL'   )
      CALL FFKEY('SUMPMX'  ,SUMPMX,     1,'REAL'   )
      CALL FFKEY('CSISMX'  ,CSISMX,     1,'REAL'   )
      CALL FFKEY('EEXTMX'  ,EEXTMX,     1,'REAL'   )
*
      CALL FFKEY('ACOLMN'  ,ACOLMN,     1,'REAL'   )
      CALL FFKEY('TMSMN'   ,TMSMN ,     1,'REAL'   )
*
      RETURN
      END
+DECK,RHLPRT.
      SUBROUTINE RHLPRT
************************************************************************
*.
*...RHLPRT   Prints out control variables for heavy lepton selection
*.
*. SEQUENCE  : HLCUTS
*. CALLS     :
*. CALLED    : RHLSEL
*.
*. AUTHOR    : K. Riles (condensed and looser version of heavy lepton
*.                       working group selection program written by
*.                       J.Hobbs J.Kroll F.Merritt M.Redmond
*.                       K.Riles I.Wingerter)
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
*
+SEQ,DECLARE.
*
* Print out control parameters
*
+SEQ,HLCUTS.
*
        WRITE(6,101)D0TGHT,Z0TGHT,PTTGHT,NGDMN,GCOSMX,GPXYMN,GD0MX,
     +   GZ0MX,GNCJMN,EEBTHR,EEETHR,THRKCT,THRKEC,DPHIMX,DTHEMX
 101    FORMAT(' Cut parameters used for heavy lepton search:'//
     +'   At least one track must pass following tight cuts:'//
     +'     Maximum |d0| (cm)=                                 ',F6.2/
     +'     Maximum |z0| (cm)=                                 ',F6.2/
     +'     Minimum transverse momentum(GeV/c)=                ',F6.3//
     +'   Minimum number of good central tracks=                  ',I3//
     +'     Maximum |cos(theta) for good central track=        ',F6.3/
     +'     Minimum transverse momentum for good central track=',F6.2/
     +'     Maximum |d0| for good central track=               ',F6.2/
     +'     Maximum |z0| for good central track=               ',F6.2/
     +'     Minimum number of CJ hits for good central track=     ',I3//
     +'   Requirements on good ecal clusters:'//
     +'     Threshold energy for accepting EB cluster=         ',F6.2/
     +'     Threshold energy for accepting EE cluster=         ',F6.2//
     +'   Requirements on 4-vector contributions:'//
     +'     Minimum momentum for including charged track=      ',F6.2/
     +'     Minimum momentum for including ecal cluster=       ',F6.2/
     +'     Max diff in phi between ctrk and assoc ecal clust= ',F6.3/
     +'     Max diff in theta betwn ctrk and assoc ecal clust= ',F6.3/)
       WRITE(6,102)EVISMN,EVISMX,PTOFST,PTFACT
 102   FORMAT('   Requirements for missing energy/momentum flag:'//
     +'     Minimum total visible energy (ctrk+ecal)=          ',F6.2/
     +'     Maximum total visible energy (ctrk+ecal)=          ',F6.2/
     +'     PTOFST (Offset in transverse momentum) =           ',F6.2/
     +'     PTFACT (Scaling factor in transverse momentum)=    ',F6.2/
     +'     where Pperp >= PTOFST + PTFACT * EVIS'/)
       WRITE(6,103)HLFANG,PISMN1,PISMN2,CSISMX,SUMPMX,EEXTMX,ACOLMN,
     +             TMSMN
 103   FORMAT('   Requirements on isolated tracks:'//
     +'     Half-angle of isolation cone=                      ',F6.3/
     +'     Minimum momentum of isolated track candidate=      ',F6.3/
     +'     Minimum momentum of second track in event=         ',F6.3/
     +'     Maximum |cos(theta)|=                              ',F6.3/
     +'     Maximum sum of charged energy in search cone=      ',F6.2/
     +'     Maximum extra ecal energy allowed in search cone=  ',F6.2//
     +'   Dilepton veto cuts:'//
     +'     Acolinearity cutoff angle=                         ',F6.3/
     +'     Transverse mass cutoff=                            ',F6.2/)
*
      RETURN
      END
*
*
+DECK,RHLSEL.
      SUBROUTINE RHLSEL(MISEPT,ISOTRK,CLOMAS)
************************************************************************
*.
*...RHLSEL   Selects heavy lepton candidates via two independent
*.           algorithms based on missing energy/momentum and
*.           isolated tracks.
*.
*.           As of Oct 90, also selects events with very low visible
*.           energy and at least two good tracks in the barrel
*.
*. SEQUENCE  : HLCONS HLCUTS HLODCM P4VEC  ROPAR  CRO
*. CALLS     : RHLPRT RHLFIL RHLASS RHL4VC PXTTH3 VZERO
*. CALLED    : ROEVTY
*.
*. AUTHOR    : K. Riles (condensed and looser version of heavy lepton
*.                       working group selection program written by
*.                       J.Hobbs J.Kroll F.Merritt M.Redmond
*.                       K.Riles I.Wingerter)
*. CREATED   : 06-APR-1990
*. LAST MOD  : 02-OCT-1990
*.
*. Modification log:
*.  07-Oct-90  K.Riles    Added close-mass selection (Heungmin Oh)
*.  20-Jun-90  S.weisz    Comment all printing
*.
************************************************************************
*
+SEQ,DECLARE.
*
      LOGICAL MISEPT, ISOTRK, CLOMAS
*
*  MISEPT is returned true for events with sufficient missing energy
*         and missing transverse momentum
*
*  ISOTRK is returned true for events with isolated tracks that are
*  not consistent with conventional dilepton events
*
*  CLOMAS is returned true for events with exactly two "very good"
*  oppositely-charged tracks with |cos(theta)| < 0.7 and an
*  acoplanarity greater than 400 mrad. The event's total ecal
*  energy must be less than 0.3*Ecm.
*  and endcap energy / scalar sum track momentum < 0.1. Muon pairs
*  are suppressed by requiring scalar sum track momentum < 0.75*Ecm.
*
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,HLCONS.
+SEQ,HLODCM.
+SEQ,HLCUTS.
+SEQ,P4VEC.
*
      CHARACTER*128 BUFFER(10)
      LOGICAL FIRST,GOOD(NCTRKM)
      INTEGER NGOOD,NTHRSH,NTIGHT,I,J,K,ICTRK,I4VECT,IRUN,IEVT,NITRK,
     +        IGOOD,IERR,NBUFF
      REAL COSHLF,COSOPN,PHEMI(4,2),PTHEMI(4,2),ACOLL,PTOTIN,ETOTIN,
     +     EEXT,EVIS,PTMISS,THRUST,THRVEC(3),PTRK(3,NCTRKM),
     +     PMAX,SCALE,PIMASS
      SAVE FIRST,PMAX,PIMASS
*
      REAL SQRTCK,ACOSCK
*
      DATA FIRST/.TRUE./
      DATA PMAX/46./,PIMASS/.1396/
*
      MISEPT = .FALSE.
      ISOTRK = .FALSE.
*
      IRUN = IUHEAD(IIRUN)
      IEVT = IUHEAD(IIEVT)
*
      IF(FIRST)THEN
        FIRST=.FALSE.
*
* For the time being, call RHLINI and RHLSET from here
*
        CALL RHLINI
        CALL RHLSET
*
* Call RHLPRT to print out control variables
*
        CALL RHLPRT
*
      ENDIF
*
* Call RHLFIL to fill dst variables and set quality flags
* Require at least NGDMN good charged tracks
*
      CALL RHLFIL
*
* Check for the close-mass, very-low-visible-energy events
*
      CALL RHLCLS(CLOMAS)
*
* Flag and count the "good" tracks, also count number above threshold
*
      NGOOD =  0
      NTHRSH = 0
      NTIGHT = 0
      DO 1 ICTRK = 1, NCTRK
        GOOD(ICTRK) = CQUAL(ICTRK).GT.0
        IF(GOOD(ICTRK))NGOOD = NGOOD + 1
        IF(GOOD(ICTRK).AND.CP(ICTRK).GT.MIN(PISMN1,PISMN2))
     +     NTHRSH = NTHRSH + 1
        IF(CQUAL(ICTRK).GT.1)NTIGHT=NTIGHT+1
 1    CONTINUE
      IF(NGOOD.LT.NGDMN)RETURN
      IF(NTIGHT.LT.1)RETURN
*
* Call track-ecal cluster association routine
*
      CALL RHLASS
*
* Call LL4VEC to calculate "4 vectors" of resolvable particles
*
      CALL RHL4VC
*
* Flag event if it satisfies visible energy / missing momentum /
* thrust cuts
*
      NBUFF = 0
      EVIS = P4VTOT(4)
      PTMISS = SQRT(P4VTOT(1)**2+P4VTOT(2)**2)
      IF(EVIS.GE.EVISMN.AND.EVIS.LE.EVISMX.AND.
     +   PTMISS.GE.PTOFST+PTFACT*EVIS)THEN
        IGOOD = 0
        DO 5 I=1,NCTRK
          IF(.NOT.GOOD(I))  GOTO 5
          IGOOD = IGOOD+1
          PTRK(1,IGOOD) = CPX(I)
          PTRK(2,IGOOD) = CPY(I)
          PTRK(3,IGOOD) = CPZ(I)
 5      CONTINUE
        CALL PXTTH3(IGOOD,3,PTRK,THRUST,THRVEC,IERR)
CKR     IF(THRUST.LE.0.95) MISEPT = .TRUE.
        MISEPT = .TRUE.
C       NBUFF = NBUFF + 1
C       WRITE(BUFFER(NBUFF),701)EVIS,PTMISS,THRUST,THRVEC
C701    FORMAT(' Visible energy=',F6.2,' Missing pt=',F6.2,
C    +         ' Thrust value=',F6.3,' direction=',3(1X,F6.3))
C       NBUFF = NBUFF + 1
C       WRITE(BUFFER(NBUFF),702)(P4VTOT(I),I=1,3)
C702    FORMAT(' Event momentum(px,py,pz)=',3(1X,F6.2))
      ENDIF
*
* For isolated track search, require there be at least two tracks
* satisfying minimum p requirement
*
      IF(NTHRSH.LT.2)GOTO 51
*
* Loop over good charged tracks to find isolated candidates
*
      COSHLF=COS(HLFANG)
      NITRK = 0
      DO 50 I=1,NCTRK
        IF(.NOT.GOOD(I))                GOTO 50
        IF(CIECA(I).LE.0)               GOTO 50
        IF(EE(CIECA(I)).LT.0.100)       GOTO 50
        IF(CP(I).LT.PISMN1)             GOTO 50
        IF(ABS(CPZ(I)/CP(I)).GT.CSISMX) GOTO 50
*
* Calculate total charged energy within search cone, require < SUMPMX
* (Also calculate transverse mass of charged tracks in each hemisphere
*  defined by direction of central track I)
*
        PTOTIN=0.
        CALL VZERO(PTHEMI,8)
        DO 10 J=1,NCTRK
          IF(.NOT.GOOD(J))  GOTO 10
          COSOPN=(CPX(I)*CPX(J)+CPY(I)*CPY(J)+CPZ(I)*CPZ(J))
     +           /CP(I)/CP(J)
          IF(COSOPN.GT.COSHLF.AND.J.NE.I)PTOTIN=PTOTIN+CP(J)
          IF(COSOPN.GT.0.)THEN
            K = 1
          ELSE
            K = 2
          ENDIF
          IF(CP(J).LE.PMAX)THEN
            SCALE = 1.
          ELSE
            SCALE = PMAX/CP(J)
          ENDIF
          PTHEMI(1,K) = PTHEMI(1,K) + CPX(J)*SCALE
          PTHEMI(2,K) = PTHEMI(2,K) + CPY(J)*SCALE
          PTHEMI(3,K) = PTHEMI(3,K)
     +                  + SQRTCK((CPXY(J)*SCALE)**2+PIMASS**2)
 10     CONTINUE
        IF(PTOTIN.GT.SUMPMX) GOTO 50
        DO 11 K = 1, 2
          PTHEMI(4,K) = SQRTCK(PTHEMI(3,K)**2
     +                         -PTHEMI(1,K)**2-PTHEMI(2,K)**2)
 11     CONTINUE
*
* Calculate total energy of good ecal clusters within search cone.
*
        ETOTIN=0.
        DO 20 J=1,NECAL
          IF(EQUAL(J).LE.0)GOTO 20
          COSOPN=(CPX(I)*EPX(J)+CPY(I)*EPY(J)+CPZ(I)*EPZ(J))
     +           /CP(I)/EE(J)
          IF(COSOPN.GE.COSHLF)ETOTIN=ETOTIN+EE(J)
 20     CONTINUE
*
* Require excess cluster energy be smaller than EEXTMX
*
        EEXT=ETOTIN-EE(CIECA(I))
        IF(EEXT.GE.EEXTMX)GOTO 50
*
* Initialize 3-D hemisphere kinematics
*
        DO 25 K=1,2
          DO 24 J = 1, 3
            PHEMI(J,K) = 0.
 24       CONTINUE
 25     CONTINUE
*
* Calculate 3-D kinematics of each hemisphere
*
        DO 30  I4VECT=1,N4VECT
          COSOPN=CPX(I)*P4VECT(1,I4VECT)+CPY(I)*P4VECT(2,I4VECT)
     +          +CPZ(I)*P4VECT(3,I4VECT)
          IF(COSOPN.GT.0)THEN
            K=1
          ELSE
            K=2
          ENDIF
          DO 28 J = 1, 3
            PHEMI(J,K) = PHEMI(J,K) + P4VECT(J,I4VECT)
 28       CONTINUE
 30     CONTINUE
*
* Calculate total p of each hemisphere and the acolinearity between them
*
        DO 35 K = 1, 2
          PHEMI(4,K) = SQRT(PHEMI(1,K)**2+PHEMI(2,K)**2+PHEMI(3,K)**2)
 35     CONTINUE
        IF(PHEMI(4,1)*PHEMI(4,2).EQ.0.)THEN
          ACOLL = PI
        ELSE
          COSOPN = (PHEMI(1,1)*PHEMI(1,2)+PHEMI(2,1)*PHEMI(2,2)
     +             +PHEMI(3,1)*PHEMI(3,2))/(PHEMI(4,1)*PHEMI(4,2))
          ACOLL = ACOSCK(-COSOPN)
        ENDIF
*
* Skip isolated track if acolinearity is too small and both
* hemispheres have small transverse masses
*
        IF(ACOLL.LT.ACOLMN
     +     .AND.MAX(PTHEMI(4,1),PTHEMI(4,2)).LT.TMSMN) GOTO 50
*
C       NBUFF = NBUFF + 1
C       WRITE(BUFFER(NBUFF),711)I,CPX(I),CPY(I),CPZ(I),CP(I)
C711    FORMAT(' Track',I3,' is isolated: px,py,pz,p=',4F7.2)
C       NBUFF = NBUFF + 1
C       WRITE(BUFFER(NBUFF),712)ACOLL,PTHEMI(4,1),PTHEMI(4,2),CIECA(I),
C    +                         EE(CIECA(I))
C712    FORMAT(' Acolinearity=',F6.3,' Near/far hemi transv masses=',
C    +         2F6.2,' Assoc ecal clust=',I3,' E=',F6.3)
        ISOTRK = .TRUE.
        NITRK = NITRK + 1
*
 50   CONTINUE
*
 51   CONTINUE
      IF(.NOT.(MISEPT.OR.ISOTRK))RETURN
*
C     WRITE(6,52)IRUN,IEVT,NCTRK,NGOOD,NECAL
C52   FORMAT(' RHLSEL tag: Run/Event =',I6,'/',I6/
C    +       ' Number of ctrks(good)=',I3,'(',I3,
C    +       ') Number of ecal clusts=',I3)
C     DO 60 I = 1, NBUFF
C       WRITE(6,59)BUFFER(I)
C59     FORMAT(A128)
C60   CONTINUE
C     DO 54 I = 1, NCTRK
C       WRITE(6,53)I,GOOD(I),CPX(I),CPY(I),CPZ(I),CP(I)
C53     FORMAT(' TRK',I3,' GOOD=',L1,' PX,PY,PZ,P=',4F6.2)
C54   CONTINUE
C     DO 56 I = 1, NECAL
C       WRITE(6,55)I,EQUAL(I),EPX(I),EPY(I),EPZ(I),EE(I)
C55     FORMAT(' ECA',I3,' EQUAL=',I1,' PX,PY,PZ,P=',4F6.2)
C56   CONTINUE
*
      RETURN
*
      END
+DECK,RHLSET.
      SUBROUTINE RHLSET
************************************************************************
*.
*...RHLSET   Calls ODBOOK to set up filling various kinematic variables
*.
*. SEQUENCE  : HLODCM
*. CALLS     : ODBOOK
*. CALLED    : ROPSET
*.
*. AUTHOR    : K. Riles (condensed and looser version of heavy lepton
*.                       working group selection program written by
*.                       J.Hobbs J.Kroll F.Merritt M.Redmond
*.                       K.Riles I.Wingerter)
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
*
+SEQ,DECLARE.
*
+SEQ,HLODCM.
*
      CALL ODBOOK('GNRL','NCTR',GNCTR,1)
      CALL ODBOOK('GNRL','NECA',GNECA,1)
      CALL ODBOOK('GNRL','EBEA',GEBEA,1)
*
      CALL ODBOOK('CTRK','NHCJ',CNHCJ,NCTRKM)
      CALL ODBOOK('CTRK','PX  ',CPX,NCTRKM)
      CALL ODBOOK('CTRK','PY  ',CPY,NCTRKM)
      CALL ODBOOK('CTRK','PZ  ',CPZ,NCTRKM)
      CALL ODBOOK('CTRK','D0  ',CD0,NCTRKM)
      CALL ODBOOK('CTRK','Z0  ',CZ0,NCTRKM)
      CALL ODBOOK('CTRK','THEC',CTHEC,NCTRKM)
      CALL ODBOOK('CTRK','PHEC',CPHEC,NCTRKM)
      CALL ODBOOK('CTRK','Q   ',CQ,NCTRKM)
      CALL ODBOOK('CTRK','PHI0',CPHI0,NCTRKM)
*
      CALL ODBOOK('ECAL','SOUR',ESOUR,NECALM)
      CALL ODBOOK('ECAL','E   ',EE,NECALM)
      CALL ODBOOK('ECAL','THET',ETHET,NECALM)
      CALL ODBOOK('ECAL','PHI ',EPHI,NECALM)
      CALL ODBOOK('ECAL','FRMX',EFRMX,NECALM)
*
      RETURN
      END
+DECK,RHL4VC.
      SUBROUTINE RHL4VC
************************************************************************
*.
*...RHL4VC   Creates 4-vectors from charged tracks and ecal clusters
*.           where a ecal cluster and all associated tracks are treated
*.           as a single particle
*.
*. SEQUENCE  : HLODCM HLCUTS P4VEC RCREP
*. CALLS     : VZERO REPORT
*. CALLED    : RHLSEL
*.
*. AUTHOR    : K. Riles (condensed and looser version of heavy lepton
*.                       working group selection program written by
*.                       J.Hobbs J.Kroll F.Merritt M.Redmond
*.                       K.Riles I.Wingerter)
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
*
+SEQ,DECLARE.
*
+SEQ,HLODCM.
+SEQ,HLCUTS.
+SEQ,P4VEC.
+SEQ,RCREP.
*
      LOGICAL ENEUT(NECALM),ENUF(NECALM),TRKUSD(NCTRKM)
      INTEGER IECAL,ICTRK,J,I4VECT
      REAL ESUM,SCALE,PMAX,PIMASS
      SAVE PMAX,PIMASS
*
      DATA PMAX/46./,PIMASS/.1396/
*
* Flag ecal clusters satisfying threshold and neutrality requirements
*
      DO 1 IECAL=1,NECAL
        ENEUT(IECAL)=ENCTR(IECAL).EQ.0
        ENUF(IECAL)=EQUAL(IECAL).GT.0.AND.EE(IECAL).GE.THRKEC
 1    CONTINUE
*
* Initialize 4-vector arrays
*
      N4VECT=0
      DO 2 ICTRK=1,NCTRK
        TRKUSD(ICTRK)=.FALSE.
 2    CONTINUE
*
* Loop over ecal clusters
*
      DO 10  IECAL=1,NECAL
        IF(.NOT.ENUF(IECAL))GOTO 10
        ESUM=0.
        DO 3   J=1,ENCTR(IECAL)
          ESUM=ESUM+CP(EICTR(J,IECAL))
          TRKUSD(EICTR(J,IECAL))=.TRUE.
 3      CONTINUE
*
* If associated charged energy greater than cluster energy, rescale,
* but don't let charged energy be greater than PMAX
*
        ESUM=MIN(ESUM,PMAX)
        IF(EE(IECAL).GT.ESUM)THEN
          SCALE=1.
        ELSE
          SCALE=ESUM/EE(IECAL)
        ENDIF
*
* Ok, we have a new 4-vector. make sure there's room
*
        IF(N4VECT.GE.N4VMAX)THEN
          WRITE(CHREP,4)N4VMAX
 4        FORMAT('Too many 4-vectors found, maximum is',I6)
          CALL REPORT('RHL4VC',1,'W')
          GOTO 11
        ENDIF
        N4VECT=N4VECT+1
        P4VECT(1,N4VECT)=EPX(IECAL)*SCALE
        P4VECT(2,N4VECT)=EPY(IECAL)*SCALE
        P4VECT(3,N4VECT)=EPZ(IECAL)*SCALE
        IF(ENCTR(IECAL).EQ.0)THEN
          P4VECT(4,N4VECT)=EE(IECAL)*SCALE
        ELSE
          P4VECT(4,N4VECT)=SQRT((EE(IECAL)*SCALE)**2
     +     +(ENCTR(IECAL)*PIMASS)**2)
        ENDIF
 10   CONTINUE
*
* Loop over charged tracks that have not yet been used
*
 11   DO 20 ICTRK=1,NCTRK
        IF (TRKUSD(ICTRK))       GOTO 20
        IF (CQUAL(ICTRK).LE.0)   GOTO 20
        IF (CP(ICTRK).LT.THRKCT) GOTO 20
*
* Don't let charged track contribute more than PMAX
*
        SCALE=1.
        IF(CP(ICTRK).GT.PMAX)SCALE=PMAX/CP(ICTRK)
*
* New 4-vector, make sure there's room
*
        IF(N4VECT.GE.N4VMAX)THEN
          WRITE(CHREP,4)N4VMAX
          CALL REPORT('RHL4VC',2,'W')
          GOTO 21
        ENDIF
        N4VECT=N4VECT+1
        P4VECT(1,N4VECT)=CPX(ICTRK)*SCALE
        P4VECT(2,N4VECT)=CPY(ICTRK)*SCALE
        P4VECT(3,N4VECT)=CPZ(ICTRK)*SCALE
        P4VECT(4,N4VECT)=SQRT((CP(ICTRK)*SCALE)**2+PIMASS**2)
 20   CONTINUE
*
* Sum to get total 4-vector of event.
*
  21    CALL VZERO(P4VTOT,4)
        DO 30 I4VECT=1,N4VECT
          DO 29 J=1,4
            P4VTOT(J)=P4VTOT(J)+P4VECT(J,I4VECT)
  29      CONTINUE
  30    CONTINUE
*
      RETURN
      END
*
*
      FUNCTION MODPHI(PHI)
************************************************************************
*.
*...MODPHI   Returns value of PHI between -pi and +pi
*.
*. SEQUENCE  : HLCONS
*. CALLS     :
*. CALLED    : RHLSEL
*.
*. AUTHOR    : K. Riles
*.
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
+SEQ,DECLARE.
      REAL MODPHI,PHI,PHI1
*
+SEQ,HLCONS.
*
* Returns a value between -pi and +pi
*
      PHI1=MOD(PHI,TWOPI)
      IF(PHI1.GT.PI)PHI1=PHI1-TWOPI
      IF(PHI1.LT.-PI)PHI1=PHI1+TWOPI
*
      MODPHI=PHI1
*
      RETURN
      END
*
*
      FUNCTION SQRTCK(X)
************************************************************************
*.
*...SQRTCK   Checks that argument is >= zero before returning sqrt
*.
*. SEQUENCE  :
*. CALLS     : SQRT REPORT
*. CALLED    : RHLSEL RCREP
*.
*. AUTHOR    : K. Riles
*.
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
+SEQ,DECLARE.
      REAL SQRTCK,X,Y
*
+SEQ,RCREP.
*
      Y=X
      IF(Y.LT.-1.E-2)THEN
        WRITE(CHREP,1)Y
 1      FORMAT('SQRT function called with argument=',E14.6)
        CALL REPORT('SQRTCK',1,'E')
        Y = 0.
      ELSE IF(Y.LT.0.)THEN
        Y = 0.
      ENDIF
      SQRTCK=SQRT(Y)
      RETURN
      END
*
*
      FUNCTION ACOSCK(X)
************************************************************************
*.
*...ACOSCK   Checks that |argument| is <= 1 before returning acos
*.
*. SEQUENCE  : RCREP
*. CALLS     : ACOS SART
*. CALLED    : RHLSEL
*.
*. AUTHOR    : K. Riles
*.
*. CREATED   : 06-APR-1990
*. LAST MOD  : 06-APR-1990
*.
*. Modification log:
*.
************************************************************************
+SEQ,DECLARE.
      REAL ACOSCK,X,Y
*
+SEQ,RCREP.
*
      Y=X
      IF(ABS(Y).GT.1.001)THEN
        WRITE(CHREP,1)Y
 1      FORMAT('ACOS function called with argument=',E14.6)
        CALL REPORT('ACOSCK',1,'E')
        Y = SIGN(1.,Y)
      ELSE IF(ABS(Y).GT.1.)THEN
        Y = SIGN(1.,Y)
      ENDIF
      ACOSCK=ACOS(Y)
*
      RETURN
      END
+DECK,RHSEL.
      SUBROUTINE RHSEL(HBIT)
*.
*...RHSEL   Routine to return logical true if event has more than
*.          4 tracks satisfying the Higgs WG quality cuts:
*.
*.                 MINIMUM PT       :  0.100 GeV
*.                 MAXIMUM COST     :  0.966
*.                 MAXIMUM d0       :  2.5   cm
*.                 MAXIMUM z0       :  50.0  cm
*.                 MINIMUM CJ HITS  :  20 and 50% of
*.                                     possible hits
*.
*.  SEQUENCES :  RCREP,ODPAR
*.  CALLS     :  ODNBLK,ODFBLK
*.  CALLED    :  ROEVTY
*.
*.  AUTHOR    :  Opher GANEL and Eilam GROSS
*.  VERSION   :  1.01
*.  CREATED   :  14-Jun-90
*.  LAST MOD  :  09-Oct-90
*.
*.  Modification Log.
*.  09-Oct-90  O. Ganel   New track quality cuts
*.  15-Jun-90  O.Ganel    Change cut from 5 to 4 tracks
*.  14-Jun-90  C.Hawkes   Convert to standard FORTRAN77. Add header.
*.                        Rename HSEL->RHSEL for ROPE pam.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,ODPAR.
C
C --- Dimension
C
      REAL    RCTRKD(NRCTRK),PT,PT2,PTOT,COST,XPHITS,THET,TTH
      REAL    CUTPT,CUTD0,CUTZ0,CUTCOS
      SAVE    CUTPT,CUTD0,CUTZ0,CUTCOS
      INTEGER NT,NTRKS,ITRK,ICTRKD(NICTRK),NI,NR,NHITS
      INTEGER ICUTNH,MINHIT,MPHITS
      SAVE    MINHIT
      LOGICAL HBIT
C
C --- Determine cuts
C
      DATA CUTZ0   /50./
      DATA CUTD0   /2.5/
      DATA CUTPT   /0.10/
      DATA CUTCOS  /0.966/
      DATA MINHIT  /20/
C
C --- Set accept counter to zero
C
      HBIT = .FALSE.
      NT = 0
C
C --- Get number of charged tracks.
C
      CALL ODNBLK('CTRK',NTRKS)
      IF (NTRKS.LE.0)                                          GO TO 999
C
C --- Loop on CT tracks.
C
      DO 200 ITRK=1,NTRKS
         CALL ODFBLK('CTRK',ITRK,NICTRK,ICTRKD,NI,NRCTRK,RCTRKD,NR)
         IF (NI.LE.0)                                          GO TO 100
C
C --- Apply track quality cuts
C

C
C     --- Cut on z0 and d0
C
         IF (ABS(RCTRKD(JCD0)).GT.CUTD0)                       GO TO 100
         IF (ABS(RCTRKD(JCZ0)).GT.CUTZ0)                       GO TO 100
C
C     --- Cut on transverse momentum
C
         PT2  = RCTRKD(JCPX)**2+RCTRKD(JCPY)**2
         PTOT = SQRT(PT2+RCTRKD(JCPZ)**2)
         PT   = SQRT(PT2)
         IF (PT.LT.CUTPT)                                      GO TO 100
C
C     --- Cut on cos(theta)
C
         COST = RCTRKD(JCPZ)/PTOT
         IF (ABS(COST).GT.CUTCOS)                              GO TO 100
C
C     --- Calculate number of possible CJ hits
C
         THET = ACOS(COST)
         TTH  = TAN(THET)
         IF (ABS(TTH).GT.1) THEN
            XPHITS = 159.5
         ELSE
            XPHITS = (155.2*ABS(TTH)-25)/(1-0.2679*ABS(TTH))
         END IF
         MPHITS = MIN(INT(XPHITS-0.5),159)
C
C     --- Determine minimal number of hits for accepting track
C
         ICUTNH = MAX(INT(MPHITS/2),MINHIT)
C
C     --- Cut on number of CJ hits
C
         NHITS = ICTRKD(JCNHCJ)
         IF (NHITS.LT.ICUTNH)                                  GO TO 100
         NT = NT+1
100      CONTINUE
200   CONTINUE
C
C --- Set HBIT to .true. if more than four good tracks
C
      IF (NT.GT.4) HBIT = .TRUE.
C
C --- Termination
C
  999 RETURN
      END
+DECK,RMHSEL.
      LOGICAL FUNCTION RMHSEL(ISEL)
*.
*...RMHSEL   SELECTS MULTIHADRONIC EVENTS
*.
*.
*. INPUT     : ISEL     : dummy argument
*. AUTHOR    : T.Mori
*. Created   : 11-Sep-1990  Copied from THSELH.
*.  24-Sep-90  T. Mori  cluster+track selection.
*.  11-Feb-91  T. Mori  definition of # CV hits in OD blocks changed.
*.  02-Jul-91  T. Mori  Refine the message for EBEAM=0.
*.  27-Aug-91  S.Weisz  Use RBITFUNC sequence
*.  31-Aug-91  T. Mori  Unconstrained z0.  OD statement functions.
***********************************************************************
+SEQ,DECLARE.
*
+SEQ,ODPAR,ROPAR,RCLINE,CRO,RCREP,RBITFUNC.
*
      INTEGER ISEL,I
      INTEGER KIND,NBLO,NHCV
      INTEGER NEB,NEE,NHIT,KHIT
      INTEGER NCHG,NSHW
      REAL EBEAM,ERAW
      REAL YEEB,YEEE,YD0,YZ0,YR1,YPT,YCOS,YX2R,YX2Z
      REAL PZ,P0,PT,COST,ZUNC
      REAL RVIS,RBAL,PBAL,EBAL,ESHW,PCHG
      REAL YRVIS,YRBAL,YNSHW,YNCHG,WTCHG
      LOGICAL LEVIS,LRBAL,LNSHW,LNCHG
      INTEGER INIPRI
      SAVE INIPRI
      SAVE YEEB,YEEE,NEB,NEE
      SAVE NHIT,YD0,YZ0,YR1,YPT,YCOS,YX2R,YX2Z
      SAVE YRVIS,YRBAL,YNSHW,YNCHG,WTCHG
*
+SEQ,ODSFUN.
*
      DATA INIPRI /0/
*
* ...Selection cut values
*   good cluster selection
      DATA YEEB /0.10/, YEEE /0.20/, NEB /1/, NEE /2/
*   good track selection
      DATA NHIT / 20/, YD0 /2.00/, YZ0 /40.0/, YR1 /60.0/
      DATA YCOS /0.995/, YPT /0.05/, YX2R /999./, YX2Z /999./
*   Multihadron selection
      DATA YRBAL /0.65/, YNCHG /4.9/, YNSHW /6.9/
      DATA YRVIS /0.10/, WTCHG /0.00/
*
* ...Print cut values
      IF(INIPRI.EQ.0) THEN
         INIPRI=1
         WRITE(CHLINE,1010)
         CALL RMAIL(5,0)
         WRITE(CHLINE,1011)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1012)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1010)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1013) WTCHG,YRVIS
         CALL RMAIL(0,0)
         WRITE(CHLINE,1014) WTCHG,YRBAL
         CALL RMAIL(0,0)
         WRITE(CHLINE,1015) YNSHW,YNCHG
         CALL RMAIL(0,0)
         WRITE(CHLINE,1010)
         CALL RMAIL(0,5)
      END IF
*
* ...Set up for OD statement functions
      CALL ODFUNS
*
* ...Get beam energy
      EBEAM = FLOAT(IUHEAD(IIEBEA))/1000.
      IF(EBEAM.LT.1.E-7) THEN
         WRITE(CHREP,9010) EBEAM
         CALL REPORT('RMHSEL',1,'ERROR')
         RMHSEL=.FALSE.
         RETURN
      END IF
*
* ...Select good clusters
      NSHW=0
      ESHW=0.
      EBAL=0.
      DO 100 I=1,NECAL
         KIND=IE(JESOUR,I)
         ERAW=RE(JEERAW,I)
         NBLO=IE(JENBLO,I)
         IF( (IAND(KIND,MSKEE).EQ.0.AND.
     +        ERAW.GE.YEEB.AND.NBLO.GE.NEB)
     +    .OR.
     +       (IAND(KIND,MSKEE).NE.0.AND.
     +        ERAW.GE.YEEE.AND.NBLO.GE.NEE)
     +     ) THEN
           NSHW=NSHW+1
           ESHW=ESHW+ERAW
           EBAL=EBAL+COS(RE(JETHET,I))*ERAW
         END IF
  100 CONTINUE
*
* ...Select good tracks
      NCHG=0
      PCHG=0.
      PBAL=0.
      DO 200 I=1,NCTRK
         PT=SQRT(RC(JCPX,I)**2+RC(JCPY,I)**2)
         PZ=RC(JCPZ,I)
         P0=SQRT(PT**2+PZ**2)
         IF(P0.LE.1.E-10) GOTO 200
         COST=PZ/P0
         NHCV=IC(JCNHCV,I)
         KHIT=NHCV/100+MOD(NHCV,100)+IC(JCNHCZ,I)+IC(JCNHCJ,I)
         CALL ODUNCZ(I,ZUNC)
         IF( KHIT.GE.NHIT
     +       .AND. ABS(RC(JCD0,I)).LE.YD0
     +       .AND. ABS(ZUNC).LE.YZ0
     +       .AND. RC(JCR1,I).LE.YR1
     +       .AND. PT.GE.YPT.AND.ABS(COST).LE.YCOS
     +       .AND. RC(JCCHIR,I).LE.YX2R
     +       .AND. RC(JCCHI3,I).LE.YX2Z
     +     ) THEN
            IF(P0.GT.EBEAM) P0=EBEAM
            NCHG=NCHG+1
            PCHG=PCHG+P0
            PBAL=PBAL+P0*COST
         END IF
  200 CONTINUE
*
* ...Calculate visible energy and energy imbalance
      RVIS = 0.5*(ESHW+WTCHG*PCHG)/EBEAM
      IF((ESHW+WTCHG*PCHG).GT.1.E-7) THEN
         RBAL = (WTCHG*PBAL+EBAL)/(ESHW+WTCHG*PCHG)
      ELSE
         RBAL = 0.
      END IF
*
* ...Multihadronic event cuts
      LEVIS = RVIS         .GE. YRVIS
      LRBAL = ABS(RBAL)    .LE. YRBAL
      LNSHW = FLOAT(NSHW)  .GE. YNSHW
      LNCHG = FLOAT(NCHG)  .GE. YNCHG
*
* ...Multihadronic event selection
      RMHSEL = LEVIS .AND. LRBAL .AND. LNSHW .AND. LNCHG
C
      RETURN
 1010 FORMAT(' +----------------------------------------------+')
 1011 FORMAT(' I      Standard Multihadron Selection Cuts     I')
 1012 FORMAT(' I        last update:  20-Aug-91  T.Mori       I')
 1013 FORMAT(' I   Rvis = Rshw  +',F8.3,' * Rchg  >',F8.3,'   I')
 1014 FORMAT(' I   Rbal = RZshw +',F8.3,' * RZchg <',F8.3,'   I')
 1015 FORMAT(' I   Nshw >=',F8.3,', Nchg >=',F8.3,'           I')
 9010 FORMAT('too small EBEAM=',F10.3,': Tokyo MH analysis skipped')
      END
+DECK,RL2MHS.
      LOGICAL FUNCTION RL2MHS(ISEL)
*.
*...RMHSL2   SELECTS MULTIHADRONIC EVENTS
*.
*.
*. INPUT     : ISEL     : dummy argument
*. AUTHOR    : T.Mori
*. Created   : 11-Sep-1990  Copied from THSELH.
*.  24-Sep-90  T. Mori  cluster+track selection.
*.  11-Feb-91  T. Mori  definition of # CV hits in OD blocks changed.
*.  02-Jul-91  T. Mori  Refine the message for EBEAM=0.
*.  27-Aug-91  S.Weisz  Use RBITFUNC sequence
*.  31-Aug-91  T. Mori  Unconstrained z0.  OD statement functions.
*.  12-Jun-96  G. Duckeck Copied from RMHSEL,
*.                        adjust cuts for LEP2 (Rvis, Rbal)
*.  17-Jun-96  M.Schroder Cleanup, fix REPORT message
***********************************************************************
+SEQ,DECLARE.
*
+SEQ,ODPAR,ROPAR,RCLINE,CRO,RCREP,RBITFUNC.
*
      INTEGER ISEL,I
      INTEGER KIND,NBLO,NHCV
      INTEGER NEB,NEE,NHIT,KHIT
      INTEGER NCHG,NSHW
      REAL EBEAM,ERAW
      REAL YEEB,YEEE,YD0,YZ0,YR1,YPT,YCOS,YX2R,YX2Z
      REAL PZ,P0,PT,COST,ZUNC
      REAL RVIS,RBAL,PBAL,EBAL,ESHW,PCHG
      REAL YRVIS,YRBAL,YNSHW,YNCHG,WTCHG
      LOGICAL LEVIS,LRBAL,LNSHW,LNCHG
      INTEGER INIPRI
      SAVE INIPRI
      SAVE YEEB,YEEE,NEB,NEE
      SAVE NHIT,YD0,YZ0,YR1,YPT,YCOS,YX2R,YX2Z
      SAVE YRVIS,YRBAL,YNSHW,YNCHG,WTCHG
*
+SEQ,ODSFUN.
*
      DATA INIPRI /0/
*
* ...Selection cut values
*   good cluster selection
      DATA YEEB /0.10/, YEEE /0.20/, NEB /1/, NEE /2/
*   good track selection
      DATA NHIT / 20/, YD0 /2.00/, YZ0 /40.0/, YR1 /60.0/
      DATA YCOS /0.995/, YPT /0.05/, YX2R /999./, YX2Z /999./
*   Multihadron selection
* LEP1 TKMH
CCC      DATA YRBAL /0.65/, YNCHG /4.9/, YNSHW /6.9/
CCC      DATA YRVIS /0.10/, WTCHG /0.00/
*
* LEP2 L2MH
      DATA YRBAL /0.75/, YNCHG /4.9/, YNSHW /6.9/
      DATA YRVIS /0.14/, WTCHG /0.00/
*
* ...Print cut values
      IF(INIPRI.EQ.0) THEN
         INIPRI=1
         WRITE(CHLINE,1010)
         CALL RMAIL(5,0)
         WRITE(CHLINE,1011)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1012)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1010)
         CALL RMAIL(0,0)
         WRITE(CHLINE,1013) WTCHG,YRVIS
         CALL RMAIL(0,0)
         WRITE(CHLINE,1014) WTCHG,YRBAL
         CALL RMAIL(0,0)
         WRITE(CHLINE,1015) YNSHW,YNCHG
         CALL RMAIL(0,0)
         WRITE(CHLINE,1010)
         CALL RMAIL(0,5)
      END IF
*
* ...Set up for OD statement functions
      CALL ODFUNS
*
* ...Get beam energy
      EBEAM = FLOAT(IUHEAD(IIEBEA))/1000.
      IF(EBEAM.LT.1.E-7) THEN
         WRITE(CHREP,9010) EBEAM
         CALL REPORT('RL2MHS',1,'ERROR')
         RL2MHS=.FALSE.
         RETURN
      END IF
*
* ...Select good clusters
      NSHW=0
      ESHW=0.
      EBAL=0.
      DO 100 I=1,NECAL
         KIND=IE(JESOUR,I)
         ERAW=RE(JEERAW,I)
         NBLO=IE(JENBLO,I)
         IF( (IAND(KIND,MSKEE).EQ.0.AND.
     +        ERAW.GE.YEEB.AND.NBLO.GE.NEB)
     +    .OR.
     +       (IAND(KIND,MSKEE).NE.0.AND.
     +        ERAW.GE.YEEE.AND.NBLO.GE.NEE)
     +     ) THEN
           NSHW=NSHW+1
           ESHW=ESHW+ERAW
           EBAL=EBAL+COS(RE(JETHET,I))*ERAW
         END IF
  100 CONTINUE
*
* ...Select good tracks
      NCHG=0
      PCHG=0.
      PBAL=0.
      DO 200 I=1,NCTRK
         PT=SQRT(RC(JCPX,I)**2+RC(JCPY,I)**2)
         PZ=RC(JCPZ,I)
         P0=SQRT(PT**2+PZ**2)
         IF(P0.LE.1.E-10) GOTO 200
         COST=PZ/P0
         NHCV=IC(JCNHCV,I)
         KHIT=NHCV/100+MOD(NHCV,100)+IC(JCNHCZ,I)+IC(JCNHCJ,I)
         CALL ODUNCZ(I,ZUNC)
         IF( KHIT.GE.NHIT
     +       .AND. ABS(RC(JCD0,I)).LE.YD0
     +       .AND. ABS(ZUNC).LE.YZ0
     +       .AND. RC(JCR1,I).LE.YR1
     +       .AND. PT.GE.YPT.AND.ABS(COST).LE.YCOS
     +       .AND. RC(JCCHIR,I).LE.YX2R
     +       .AND. RC(JCCHI3,I).LE.YX2Z
     +     ) THEN
            IF(P0.GT.EBEAM) P0=EBEAM
            NCHG=NCHG+1
            PCHG=PCHG+P0
            PBAL=PBAL+P0*COST
         END IF
  200 CONTINUE
*
* ...Calculate visible energy and energy imbalance
      RVIS = 0.5*(ESHW+WTCHG*PCHG)/EBEAM
      IF((ESHW+WTCHG*PCHG).GT.1.E-7) THEN
         RBAL = (WTCHG*PBAL+EBAL)/(ESHW+WTCHG*PCHG)
      ELSE
         RBAL = 0.
      END IF
*
* ...Multihadronic event cuts
      LEVIS = RVIS         .GE. YRVIS
      LRBAL = ABS(RBAL)    .LE. YRBAL
      LNSHW = FLOAT(NSHW)  .GE. YNSHW
      LNCHG = FLOAT(NCHG)  .GE. YNCHG
*
* ...Multihadronic event selection
      RL2MHS = LEVIS .AND. LRBAL .AND. LNSHW .AND. LNCHG
C
      RETURN
 1010 FORMAT(' +----------------------------------------------+')
 1011 FORMAT(' I        LEP2 Multihadron Selection Cuts       I')
 1012 FORMAT(' I        last update:  12-Jun-96  G.Duckeck    I')
 1013 FORMAT(' I   Rvis = Rshw  +',F8.3,' * Rchg  >',F8.3,'   I')
 1014 FORMAT(' I   Rbal = RZshw +',F8.3,' * RZchg <',F8.3,'   I')
 1015 FORMAT(' I   Nshw >=',F8.3,', Nchg >=',F8.3,'           I')
 9010 FORMAT('too small EBEAM=',F10.3,': LEP2 MH analysis skipped')
      END
+DECK,RPHCON.
      SUBROUTINE RPHCON(LCONV)
*.********************************************************************
*.
*. Routine to select events with candidate photon conversions
*. in the PHYS1 pre-selection.
*. We explicitly never attempt to flag GPMH events.
*. (Avoids combinatorics - and we assume these events get through
*.  PHYS1 anyway)
*.
*.
*. OUTPUT    : LCONV  logical flag indicating if a conversion in a
*.                    non GPMH event has been found.
*.
*. SEQUENCES : DECLARE
*. CALLS     : RPHGCV
*. CALLED    : RGAM
*.
*. AUTHOR    : G.W. Wilson
*. VERSION   : 1.00
*. CREATED   : 24-Mar-1991
*. LAST MOD  : 06-Feb-1992
*.
*. Modification log:
*. 06-Feb-92  C.Hawkes    Delete four lines of unreachable code
*. 27-Aug-91  S.Weisz     Use RBITFUNC sequence
*. 09-May-91  G.W.Wilson  Unconstrain the tracks in z.
*. 30-Apr-91  G.W.Wilson  Add high-multiplicity and beam-wall/gas vetoes
*. 07-Apr-91  G.W.Wilson  Put all code accessing the tracks into
*.                         RPHGCV
*.
*.********************************************************************
+SEQ,DECLARE.
+SEQ,ODPAR.
+SEQ,RBITFUNC.
+SEQ,RCREP.
      LOGICAL LCONV
      REAL PVERT(3)
      INTEGER I,IMODE
      INTEGER NGTRK,NBZL,NBZT
      REAL Z0
*
      INTEGER NGTKCT,NBZLCT,NBZTCT
      PARAMETER (NGTKCT = 5, NBZLCT = 3, NBZTCT = 3)
      INTEGER NHCJL,NHCJT,NHCZ
      PARAMETER (NHCJL = 30, NHCJT = 60, NHCZ = 4)
      REAL Z0LCUT,Z0TCUT
      PARAMETER (Z0LCUT = 150., Z0TCUT = 50.)
*
+SEQ,ODSFUN.
      CALL ODFUNS
*
* Initialisation
*
      LCONV = .FALSE.
      NGTRK = 0
      NBZL  = 0
      NBZT  = 0
*
* If event is a GPMH in the filter then
* assuming that GPMH are selected in PHYS1
* we do not need to try to find a photon conversion.
*
      IF(BTEST(IG(JGFITY),26-1)) RETURN
*
* Track counting for event vetoes
*
      DO 10 I=1,NCTRK
         CALL ODUNCZ(I,Z0)
         IF(IC(JCNHCJ,I).GE.NHCJL)
     +      NGTRK = NGTRK + 1
         IF(IC(JCNHCJ,I).GE.NHCJT.AND.ABS(Z0).GT.Z0LCUT)
     +      NBZL  = NBZL  + 1
         IF(IC(JCNHCJ,I).GE.NHCJT.AND.IC(JCNHCZ,I).GE.NHCZ
     +      .AND.ABS(Z0).GT.Z0TCUT)
     +      NBZT  = NBZT  + 1
 10   CONTINUE
*
* Apply event vetoes based on track counting
*
* High multiplicity
      IF(NGTRK.GE.NGTKCT) RETURN
* Loose CJ only z0 cut
      IF(NBZL.GE.NBZLCT)  RETURN
* Tight CJ and CZ z0 cut
      IF(NBZT.GE.NBZTCT)  RETURN
*
* Best estimate of event-vertex - for single photon type
* events we should take the best estimate of the beam spot
* position. As cuts are pretty loose it will be OK for now
* to take nominal collision point.
*
      PVERT(1) = 0.0
      PVERT(2) = 0.0
      PVERT(3) = 0.0
*
      IF(NCTRK.GE.2)THEN
         IMODE = 0
         CALL RPHGCV(IMODE,PVERT,LCONV)
      ENDIF
*
      END
+DECK,RPHGCV.
      SUBROUTINE RPHGCV(IMODE,PVERT,LGCON)
*.**********************************************************************
*.
*...RPHGCV   Searches for pairs of tracks which
*.           can make a gamma-conversion V0.
*.
*.           Cuts here are very loose and really only in x-y.
*.           Designed for pre-selecting photon conversions
*.           in low mult. events, but starting from code of ELEC-ID
*.           group.   - GWW
*. INPUT:
*.         IMODE         0      jumps out of loop once candidate found
*.                    non-zero  goes through all combinations
*.
*.         PVERT(3)   Estimated interaction point
*.
*. OUTPUT:
*.         LGCON   Logical flag indicating if at least one gamma
*.                 conversion has been found from a pairing of tracks.
*.
*. SEQUENCES : DECLARE ODPAR RCREP
*. CALLS     : ODNBLK ODFBLK CXUNCZ OUKABG RPHTNG
*. CALLED    : RPHCON
*.
*. AUTHOR    : G.W. Wilson
*. VERSION   : 1.04
*. CREATED   : 24-Mar-1991
*. LAST MOD  : 10-May-1991
*.
*. Modification log:
*. 10-May-91   G.W.Wilson   Change J loop to look at each combn. once.
*. 27-Mar-91   G.W.Wilson   Add ET cut
*. 07-Apr-91   G.W.Wilson   Tidy up, and call CXUNCZ necessitating
*.                          changing to OD access routines.
*. 08-Apr-91   G.W.Wilson   If Pb with CXUNCZ skip track rather abort
*. 09-Apr-91   G.W.Wilson   Add IMODE control and common block.
*. 30-Apr-91   G.W.Wilson   Add cuts against split tracks if radius
*.                          of first measured point in CJ very different
*. 10-May-91   G.W.Wilson   Fix bug related to unconstraining in z.
*.********************************************************************
+SEQ,DECLARE.
+SEQ,ODPAR.
+SEQ,RCREP.
+SEQ,RPHCCM.
*
      REAL PVERT(3)
      LOGICAL LGCON
*
      INTEGER IZERO
      SAVE IZERO
*
      INTEGER I,J
*
      INTEGER NCTRKS,NIMOV,NRMOV
      INTEGER IT1(NICTRK),IT2(NICTRK)
      REAL RT1(NRCTRK),RT2(NRCTRK)
*
      INTEGER IERR
*
      REAL AKAP1,PHI01,D0COR1,D01,PPT1
      REAL AKAP2,PHI02,D0COR2,D02,PPT2
      REAL DUMMY
      REAL Z0(2),TLAM(2)
      REAL KAP(2),ALP(2),BET(2),GAM(2),XI(2),XV(3,2)
      REAL RI2,RJ2,XYDIF,ZDIFF,XX,YY,RBEAM,RFIRST
      REAL PPI(3),PPJ(3),PPV(3),PT2,COSV
*
      INTEGER IMODE
*
*
* Cuts
* This set are extremely loose and purely geometric
* Will probably pick up a lot of taus since no cut on rmin
*
      REAL       R2MIN    ,R2MAX      ,XYSEP    ,ZSEP
      PARAMETER (R2MIN=0.0,R2MAX=200.0,XYSEP=0.5,ZSEP=600.)
      REAL       RBEFOR     ,COSVTX
      PARAMETER (RBEFOR=200.,COSVTX=-1.0)
* Add ETmin cut (ie pt1+pt2 for e+e- pairs)
      REAL       ETMIN
      PARAMETER (ETMIN=0.4)
*
      REAL RMIN,DRMAX
      PARAMETER (RMIN = 25.0, DRMAX = 25.0)
      INTEGER NHCJ,IDIVNH
      PARAMETER (NHCJ = 20, IDIVNH = 5)
      INTEGER NHMORE,NHLESS
*
      DATA IZERO /0/
*
*.......................................................................
*
      LGCON = .FALSE.
* Reset elements of common block
      NCONV = 0
      DXYFIR = 999.
      ETFIR  = -999.
      DXYMIN = 999.
      ETMAX  = -999.
*
* As tracks are now constrained to the vertex in z
* we need to unconstrain them for looking for V0's this
* necessitates using the OD access functions rather than
* statement functions.
*
      CALL ODNBLK('CTRK',NCTRKS)
*
      DO 10 I=1,NCTRKS-1
         CALL ODFBLK('CTRK',I,NICTRK,IT1,NIMOV,
     +                        NRCTRK,RT1,NRMOV)
         IF(NRMOV.LE.0) GOTO 10
* Unconstrain in z if constrained
         IF(MOD(IT1(JCFTYP),32)/16.EQ.1)THEN
            CALL CXUNCZ(NIMOV,NRMOV,IT1,RT1,IT1,RT1,IERR)
            IF(IERR.NE.0)THEN
               CHREP=' Pbs in CXUNCZ - skip track '
               CALL REPORT('RPHGCV',1,'W')
               GOTO 10
            ENDIF
         ENDIF
*
         AKAP1  = RT1(JCKAPP)
         PHI01  = RT1(JCPHI0)
         D0COR1 = PVERT(2)*COS(RT1(JCPHI0)) -
     +            PVERT(1)*SIN(RT1(JCPHI0))
         D01    = RT1(JCD0) - D0COR1
         PPT1   = SQRT(RT1(JCPX)**2+RT1(JCPY)**2)
*
*-- Get relevant track variables for track I
*
         CALL OUKABG( AKAP1, PHI01, D01, DUMMY, IZERO,
     +        KAP(1), ALP(1), BET(1), GAM(1), XI(1), DUMMY )
*
*-- Loop thru second track
*
         DO 20 J=I+1,NCTRKS
            CALL ODFBLK('CTRK',J,NICTRK,IT2,NIMOV,
     +                           NRCTRK,RT2,NRMOV)
            IF(NRMOV.LE.0) GOTO 20
* Unconstrain in z if constrained
            IF(MOD(IT2(JCFTYP),32)/16.EQ.1)THEN
               CALL CXUNCZ(NIMOV,NRMOV,IT2,RT2,IT2,RT2,IERR)
               IF(IERR.NE.0)THEN
                  CHREP=' Pbs in CXUNCZ - skip track '
                  CALL REPORT('RPHGCV',1,'W')
                  GOTO 20
               ENDIF
            ENDIF
            AKAP2  = RT2(JCKAPP)
            PHI02  = RT2(JCPHI0)
            D0COR2 = PVERT(2)*COS(RT2(JCPHI0)) -
     +               PVERT(1)*SIN(RT2(JCPHI0))
            D02    = RT2(JCD0) - D0COR2
            PPT2   = SQRT(RT2(JCPX)**2+RT2(JCPY)**2)
*
*-- Require opposite sign pair.
*
            IF( AKAP1*AKAP2 .GE. 0.0 ) GOTO 20
*
*   Cut on scalar sum of pt1+pt2 i.e. ET for a photon.
*
            IF( PPT1+PPT2 .LT. ETMIN ) GOTO 20
*
*-- Get relevant track variables for track J
*
            CALL OUKABG( AKAP2, PHI02, D02, DUMMY, IZERO,
     +           KAP(2), ALP(2), BET(2), GAM(2), XI(2), DUMMY )
*
            Z0(1) = RT1(JCZ0)
            Z0(2) = RT2(JCZ0)
            TLAM(1) = RT1(JCTLAM)
            TLAM(2) = RT2(JCTLAM)
*
*-- Find points where the tracks are parallel in xy plane
*
            CALL RPHTNG(Z0, TLAM, KAP, ALP, BET, XI, XV )
            RI2 = SQRT( XV(1,1)**2 + XV(2,1)**2 )
            RJ2 = SQRT( XV(1,2)**2 + XV(2,2)**2 )
*
*-- Check on radius of conversion
*
            IF( RI2.LT.R2MIN .AND. RJ2.LT.R2MIN ) GOTO 20
            IF( RI2.GT.R2MAX .AND. RJ2.GT.R2MAX ) GOTO 20
*
*-- Check xy separation
*
            XYDIF = SQRT((XV(1,2)-XV(1,1))**2+(XV(2,2)-XV(2,1))**2)
            IF( XYDIF .GT. XYSEP ) GOTO 20
*
*-- Check z separation
*
            ZDIFF = ABS(XV(3,1) - XV(3,2))
            IF( ZDIFF .GT. ZSEP ) GOTO 20
*
*-- Test the number/position of hits before RBEAM
*
            XX = 0.5*(XV(1,1) + XV(1,2)) - PVERT(1)
            YY = 0.5*(XV(2,1) + XV(2,2)) - PVERT(2)
            RBEAM = SQRT( XX**2 + YY**2 )
            RFIRST = MIN(RT1(JCR1),RT2(JCR1))
            IF( (RBEAM-RFIRST) .GT. RBEFOR ) GO TO 20
*
* Now cut against split tracks in CJ.
* Only if both tracks start in CJ, and the start radius is
* quite different, then chuck pairs if one of the tracks has
* less than NHCJ hits AND it has IDIVNH times less hits than the
* other. Don't want to cut explicitly on NHITS as we want to keep
* as much forward acceptance as possible
*
* Both tracks start in CJ
            IF(RT1(JCR1).GT.RMIN.AND.RT2(JCR1).GT.RMIN)THEN
* Big difference in start radius
               IF(ABS(RT1(JCR1)-RT2(JCR1)).GT.DRMAX)THEN
* Now see if we can veto this pair of tracks
* Keep if more than NHCJ hits on both
                  IF(IT1(JCNHCJ).GE.NHCJ.AND.IT2(JCNHCJ).GE.NHCJ)GOTO 21
                  IF(IT1(JCNHCJ).GE.IT2(JCNHCJ))THEN
                     NHMORE = IT1(JCNHCJ)
                     NHLESS = IT2(JCNHCJ)
                  ELSE
                     NHMORE = IT2(JCNHCJ)
                     NHLESS = IT1(JCNHCJ)
                  ENDIF
                  IF(NHLESS.LT.NHMORE/IDIVNH) GOTO 20
* We jump here if the pair is not to be chucked by the split track veto
 21               CONTINUE
               ENDIF
            ENDIF
*
*-- Get momentum components at intersection point - careful with signs
*
            PPI(1) = -ABS(PPT1)*(2.*KAP(1)*XV(2,1)+BET(1))
            PPI(2) =  ABS(PPT1)*(2.*KAP(1)*XV(1,1)+ALP(1))
            PPJ(1) = -ABS(PPT2)*(2.*KAP(2)*XV(2,2)+BET(2))
            PPJ(2) =  ABS(PPT2)*(2.*KAP(2)*XV(1,2)+ALP(2))
            PPV(1) = PPI(1)  + PPJ(1)
            PPV(2) = PPI(2)  + PPJ(2)
            PT2    = PPV(1)**2 + PPV(2)**2
            COSV = XX*PPV(1) + YY*PPV(2)
            COSV = COSV / SQRT( XX**2 + YY**2 )
            COSV = COSV / SQRT( PPV(1)**2 + PPV(2)**2 )
            IF( COSV .LT. COSVTX ) GO TO 20
* Got this far means we found one
            LGCON = .TRUE.
* Fill common block
            NCONV = NCONV + 1
            IF(NCONV.EQ.1)THEN
               DXYFIR = XYDIF
               ETFIR  = PPT1 + PPT2
            ENDIF
            IF(XYDIF.LT.DXYMIN)DXYMIN=XYDIF
            IF(PPT1+PPT2.GT.ETMAX)ETMAX=PPT1+PPT2
* So quit searching any more if in correct IMODE
            IF(IMODE.EQ.0) GO TO 99
   20    CONTINUE
   10 CONTINUE
*
   99 RETURN
      END
+DECK,RPHTNG.
      SUBROUTINE RPHTNG( Z0, TLAM, KAP, ALP, BET, XI, XV )
************************************************************************
*.
*...RPHTNG  Finds point where two tracks are parallel in xy plane
*.
*. INPUT:
*.          Z0   Z0 of tracks
*.          TLAM TLAM pf tracks
*.          KAP  curvature of tracks
*.          ALP  alpha of tracks
*.          BET  beta of tracks
*.          XI   alpha**2+beta**2 of tracks
*.
*. OUTPUT:
*.          XV  coordinates of tangent points
*.
*. Modification log:
*. 7-Apr-91    G.W.Wilson  Pass Z0,TLAM for simplicity
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER K
      REAL Z0(2),TLAM(2)
      REAL KAP(2), ALP(2), BET(2), XI(2), SS(2), XV(3,2), A, B
     +,    ADRAB, BDRAB, A2KAP, RAB

*
*.......................................................................
*
      A = (KAP(1)*ALP(2) - KAP(2)*ALP(1))*SIGN(1.,KAP(1))
      B = (KAP(1)*BET(2) - KAP(2)*BET(1))*SIGN(1.,KAP(1))
      RAB = SQRT( A**2 + B**2 )
      ADRAB = A/RAB
      BDRAB = B/RAB
*
*-- Determine points where circles first have parallel tangents
*
      DO 10 K= 1, 2
        XV(1,K) = - 0.5*(ALP(K) - ADRAB)/KAP(K)
        XV(2,K) = - 0.5*(BET(K) - BDRAB)/KAP(K)
        A2KAP = 2*ABS(KAP(K))
        SS(K) = ATAN2( A2KAP*(ALP(K)*XV(2,K) - BET(K)*XV(1,K)),
     +  2.0*KAP(K)*(ALP(K)*XV(1,K)+BET(K)*XV(2,K))+XI(K)**2)/A2KAP
        XV(3,K) = Z0(K) + SS(K)*TLAM(K)
   10 CONTINUE
*
      END
+DECK,ROCHIN.
      SUBROUTINE ROCHIN
*.
*...ROCHIN: Initialisation of ROCHSE routine for ONLINE ROPE selection
*.          of charginos at LEP1.5
*.
*. COMMON  : ROCHCU
*. SEQUENCE:  DECLARE,ROCHCU
*.
*. CALLS   : none
*.
*. CALLED  :
*.
*. AUTHOR  : A. Furtjes
*. CREATED : 13-Oct-95
*. LAST MOD: 17-Jun-96
*.
*. Modification Log.
*. 18-Oct-95  1.00   A.Furtjes   First version for ROPE
*. 25-Oct-95  1.01   A.Furtjes   Enable cut on forward energy fraction
*. 26-Oct-95         O.S.        Init ROCHVA
*. 17-Jun-96  1.02   A.Furtjes   Replace p_t cut by cut on p_t/sqrt(s)
*.                               Change p_t cut value in quality criteria
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,ROCHCU.
+SEQ,ROCHVA.
      INTEGER I
*
*     ---> Track quality cuts:
*          -------------------
*       --> minimal number of CJ hits
      CHTRQU(1) = 20.
*       --> 1/(fraction of max. possible CJ hits)
      CHTRQU(2) = 2.
*       --> d0 cut
      CHTRQU(3) = 5.
*       --> z0 cut
      CHTRQU(4) = 40.
*       --> radius of first measured hit in CJ
      CHTRQU(5) = 60.
*       --> Chi^2/DGF in r-phi
      CHTRQU(6) = 999.
*       --> Chi^2/DGF in s-z
      CHTRQU(7) = 999.
*       --> transverse momentum of track
      CHTRQU(8) = 0.10
*       --> Maximal momentum / EBEAM
      CHTRQU(9) = 9999.9
*
      CALL FFKEY('ROCHTR',CHTRQU, 9,'REAL')
*
*     ---> ECAL quality cuts
*          -----------------
*       --> minimal raw energy in EB cluster
      CHECQU(1) = 0.1
*       --> minimal raw energy in EE cluster
      CHECQU(2) = 0.2
*       --> minimal number of blocks in EE cluster
      CHECQU(3) = 2.0
*
      CALL FFKEY('ROCHEC',CHECQU, 3,'REAL')
*
*     --> general acoplanarity selection (1)
*         ----------------------------------
*       --> Minimal energy in both hemispheres
      CHSEL1(1) = 1.0
      CHSET1(1) = 1.0
*       --> Maximal energy in FD
      CHSEL1(2) = 2.0
      CHSET1(2) = 2.0
*       --> Minimal number of good charged tracks
      CHSEL1(3) = 2.0
      CHSET1(3) = 2.0
*       --> Visible Energy / sqrt(s)
      CHSEL1(4) = 0.08
      CHSET1(4) = 0.10
*       --> Acoplanarity angle
      CHSEL1(5) = 10.0
      CHSET1(5) = 20.0
*       --> Scale for correlation with E_vis
      CHSEL1(6) = 0.0
      CHSET1(6) = 1.0
*       --> | cos(theta_Pmiss) |
      CHSEL1(7) = 0.9
      CHSET1(7) = 0.9
*       --> | cos(theta_jet_max) |  (!!DUMMY!!)
      CHSEL1(8) = 9999.9
      CHSET1(8) = 9999.9
*       --> | cos(theta_thrust) |
      CHSEL1(9) = 9999.9
      CHSET1(9) = 0.7
*       --> Energy fraction in forward region
      CHSEL1(10) = 0.8
      CHSET1(10) = 0.8
*
      CALL FFKEY('ROCHSEL1',CHSEL1,10,'REAL')
      CALL FFKEY('ROCHSET1',CHSET1,10,'REAL')
*
*     --> low multiplicity selection (2)
*         ------------------------------
*       --> Minimal energy in both hemispheres
      CHSEL2(1) = 1.0
      CHSET2(1) = 1.0
*       --> Maximal energy in FD
      CHSEL2(2) = 2.0
      CHSET2(2) = 2.0
*       --> Minimal number of good charged tracks
      CHSEL2(3) = 2.0
      CHSET2(3) = 2.0
*       --> Maximal number of good charged tracks
      CHSEL2(4) = 10.0
      CHSET2(4) =  8.0
*       --> Visible Energy / sqrt(s)   (!!DUMMY!!)
      CHSEL2(5) = -1.0
      CHSET2(5) = -1.0
*       --> Acoplanarity angle
      CHSEL2(6) = 10.0
      CHSET2(6) = 20.0
*       --> | cos(theta_Pmiss) |
      CHSEL2(7) = 0.9
      CHSET2(7) = 0.9
*       --> | cos(theta_jet_max) |
      CHSEL2(8) = 9999.9
      CHSET2(8) = 0.9
*       --> | cos(theta_thrust) |   (!!DUMMY!!)
      CHSEL2(9) = 9999.9
      CHSET2(9) = 9999.9
*       --> p_t / sqrt(s)
      CHSEL2(10) = 0.0225564
      CHSET2(10) = 0.0300752
*       --> Sum of energy inside cones
      CHSEL2(11) = -1.0
      CHSET2(11) =  1.0
*       --> Sum of energy outside cones
      CHSEL2(12) = 9999.9
      CHSET2(12) =  5.0
*       --> Energy fraction in forward region
      CHSEL2(13) = 0.8
      CHSET2(13) = 0.8
*
      CALL FFKEY('ROCHSEL2',CHSEL2,13,'REAL')
      CALL FFKEY('ROCHSET2',CHSET2,13,'REAL')
*
*     --> monojet selection (3)
*         ---------------------
*       --> Minimal energy in both hemispheres
      CHSEL3(1) = 1.0
      CHSET3(1) = 1.0
*       --> Maximal energy in FD
      CHSEL3(2) = 2.0
      CHSET3(2) = 2.0
*       --> Minimal number of good charged tracks
      CHSEL3(3) = 2.0
      CHSET3(3) = 2.0
*       --> Visible Energy / sqrt(s)
      CHSEL3(4) = -1.0
      CHSET3(4) = -1.0
*       --> | cos(theta_Pmiss) |
      CHSEL3(5) = 0.9
      CHSET3(5) = 0.9
*       --> | cos(theta_thrust) |
      CHSEL3(6) = 9999.9
      CHSET3(6) = 0.7
*       --> p_t / sqrt(s)
      CHSEL3(7) = 0.0225564
      CHSET3(7) = 0.0300752
*       --> Total invariant Mass
      CHSEL3(8) = -1.0
      CHSET3(8) = 2.0
*       --> Energy fraction in forward region
      CHSEL3(9) = 0.8
      CHSET3(9) = 0.8
*
      CALL FFKEY('ROCHSEL3',CHSEL3,9,'REAL')
      CALL FFKEY('ROCHSET3',CHSET3,9,'REAL')
*
      EHEM(1)=0.
      EHEM(2)=0.
      EFDCL1=0.
      EFDCL2=0.
      EVIS=0.
      EBEAM=1.
      ACOPLA=0.
      COTHTH=0.
      COTHPM=0.
      COSJMX=0.
      EFRAC=0.
      PT=0.
      ECONJ1=0.
      ECONJ2=0.
      EOUT=0.
      DO 10 I=1,5
10    PCOMB(I)=0.
      NGOCTR=0
      END
+DECK,ROCHPR.
      SUBROUTINE ROCHPR
*.
*...ROCHPR : print cut values used in ROCHSE routine
*.
*. COMMON  : ROCHCU
*. SEQUENCE: DECLARE,ROCHCU
*.
*. CALLS   :
*.
*. CALLED  :
*.
*. AUTHOR  : A. Furtjes
*. CREATED : 13-Oct-95
*. LAST MOD: 17-Jun-96
*.
*. Modification Log.
*. 17-Jun-96  1.03   A.Furtjes   Replace p_t cut by cut on p_t/sqrt(s)
*. 31-Oct-95  1.02   A.Furtjes   Some cosmetics
*. 23-Oct-95         O.Schaile   Use RMAIL
*. 18-Oct-95  1.00   A.Furtjes   First version for ROPE
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCLINE.
+SEQ,ROCHCU.
+SEQ,ROCHVA.
*
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='**     Selection criteria used in ROCHSE        **'
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='*      Track Quality cuts:                       *'
      CALL RMAIL(0,0)
      CHLINE=
     +'*      -------------------                       *'
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Min. number of CJ hits',CHTRQU(1)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) '1/(Fract of max. possible CJ hits)',CHTRQU(2)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'd0 cut',CHTRQU(3)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'z0 cut',CHTRQU(4)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Radius of first CJ hit',CHTRQU(5)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Chi^2 of track fit in r/phi',CHTRQU(6)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Chi^2 of track fit in s/z',CHTRQU(7)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Transverse momentum of track',CHTRQU(8)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Maximal momentum / EBEAM',CHTRQU(9)
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='*      ECAL quality cuts:                        *'
      CALL RMAIL(0,0)
      CHLINE=
     +'*      ------------------                        *'
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Min raw energy in EB cluster',CHECQU(1)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Min raw energy in EE cluster',CHECQU(2)
      CALL RMAIL(0,0)
      WRITE(CHLINE,100) 'Min no. of blocks in EE cluster',CHECQU(3)
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='*      General Selection (1)                     *'
      CALL RMAIL(0,0)
      CHLINE='*      ---------------------                     *'
      CALL RMAIL(0,0)
      CHLINE=
     +'*                            Loose Cut Tight Cut |   Curr Value'
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E in hemispheres',CHSEL1(1),CHSET1(1)
     +                                    ,EHEM
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E in FD cal',CHSEL1(2),CHSET1(2)
     +                                    ,EFDCL1,EFDCL2
      CALL RMAIL(0,0)
      WRITE(CHLINE,102) 'Min # good charged tracks',CHSEL1(3),CHSET1(3)
     +                                    ,NGOCTR
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E_vis/sqrt(s)',CHSEL1(4),CHSET1(4)
     +                                    ,EVIS/(2.*EBEAM)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'Acopl. angle',CHSEL1(5),CHSET1(5)
     +                                    ,ACOPLA
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'Scale of corr with E_vis',CHSEL1(6),CHSET1(6)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_p_miss)',CHSEL1(7),CHSET1(7)
     +                                    ,COTHPM
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_jet_max)',CHSEL1(8),CHSET1(8)
     +                                    ,COSJMX
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_thrust)',CHSEL1(9),CHSET1(9)
     +                                    ,COTHTH
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E frac. in forw. reg.',CHSEL1(10),CHSET1(10)
     +                                    ,EFRAC
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='*      Low Multiplicity Selection (2)            *'
      CALL RMAIL(0,0)
      CHLINE='*      -----------------------------             *'
      CALL RMAIL(0,0)
      CHLINE=
     +'*                            Loose Cut Tight Cut |   Curr Value'
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E in hemispheres',CHSEL2(1) ,CHSET2(1)
     +                                    ,EHEM
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E in FD cal',CHSEL2(2) ,CHSET2(2)
     +                                    ,EFDCL1,EFDCL2
      CALL RMAIL(0,0)
      WRITE(CHLINE,102) 'Min # good charged tracks',CHSEL2(3),CHSET2(3)
     +                                    ,NGOCTR
      CALL RMAIL(0,0)
      WRITE(CHLINE,102) 'Max # good charged tracks',CHSEL2(4),CHSET2(4)
     +                                    ,NGOCTR
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E_vis/sqrt(s)',CHSEL2(5) ,CHSET2(5)
     +                                    ,EVIS/(2.*EBEAM)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'Acopl. angle',CHSEL2(6) ,CHSET2(6)
     +                                    ,ACOPLA
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_p_miss)',CHSEL2(7) ,CHSET2(7)
     +                                    ,COTHPM
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_jet_max)',CHSEL2(8) ,CHSET2(8)
     +                                    ,COSJMX
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_thrust)',CHSEL2(9) ,CHSET2(9)
     +                                    ,COTHTH
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'p_t/sqrt(s)',CHSEL2(10),CHSET2(10)
     +                                    ,PT/(2.*EBEAM)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E inside cones',CHSEL2(11),CHSET2(11)
     +                                    ,ECONJ1,ECONJ2
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E outside cones',CHSEL2(12),CHSET2(12)
     +                                    ,EOUT
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E frac. in forw. reg.',CHSEL2(13),CHSET2(13)
     +                                    ,EFRAC
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
      CHLINE='*      Monojet Selection (3)                     *'
      CALL RMAIL(0,0)
      CHLINE='*      ---------------------                     *'
      CALL RMAIL(0,0)
      CHLINE=
     +'*                            Loose Cut Tight Cut |   Curr Value'
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E in hemispheres',CHSEL3(1) ,CHSET3(1)
     +                                    ,EHEM
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E in FD cal',CHSEL3(2) ,CHSET3(2)
     +                                    ,EFDCL1,EFDCL2
      CALL RMAIL(0,0)
      WRITE(CHLINE,102) 'Min # good charged tracks',CHSEL3(3),CHSET3(3)
     +                                    ,NGOCTR
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E_vis/sqrt(s)',CHSEL3(4) ,CHSET3(4)
     +                                    ,EVIS/(2.*EBEAM)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_p_miss)',CHSEL3(5) ,CHSET3(5)
     +                                    ,COTHPM
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'cos(th_thrust)',CHSEL3(6) ,CHSET3(6)
     +                                    ,COTHTH
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'p_t/sqrt(s)',CHSEL3(7) ,CHSET3(7)
     +                                    ,PT/(2.*EBEAM)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'Total invariant mass',CHSEL3(8) ,CHSET3(8)
     +                                    ,PCOMB(5)
      CALL RMAIL(0,0)
      WRITE(CHLINE,101) 'E frac. in forw. reg.',CHSEL3(9),CHSET3(9)
     +                                    ,EFRAC
      CALL RMAIL(0,0)
      CHLINE='**************************************************'
      CALL RMAIL(0,0)
  100 FORMAT('*',1X,A,T40,': ',F7.2,T50,'|',2F7.2)
  101 FORMAT('*',1X,A,T29,': ',F7.2,T41,F7.2,T50,'|',2F7.2)
  102 FORMAT('*',1X,A,T29,': ',F7.2,T41,F7.2,T50,'|',I7)
*
      END
+DECK,ROCHSE.
      SUBROUTINE ROCHSE(ISEL,ISELGP)
*.
*...ROCHSE: Online ROPE routine for chargino search at LEP1.5
*.
*. OUTPUT  : ISEL  : Flag indication selection by loose criteria
*.                   1: 1. Selection: General acoplanar events
*.                   2: 2. Selection: Low multiplicity acoplanar events
*.                   4: 3. Selection: Monojet type events
*.           ISELGP: Flag indication selection by tight criteria
*.                   1: 1. Selection: General acoplanar events
*.                   2: 2. Selection: Low multiplicity acoplanar events
*.                   4: 3. Selection: Monojet type events
*.
*. COMMON  :  ROCHCU,ROCHVA
*. SEQUENCE:  DECLARE,RCREP,ODPAR
*.
*. CALLS   : REPORT,PXLTH4,PXANG3,PXADD5,UCOPY,VZERO
*.
*. CALLED  : ROEVTY
*.
*. AUTHOR  : A. Furtjes
*. CREATED : 18-Sep-95
*. LAST MOD: 30-Jun-97
*.
*. Modification Log.
*. 30-Jun-97         A.Furtjes   Protect against writing outside MOMECL
*. 05-Jul-96  1.09   A.Furtjes   Protection, if NCHTR or NECL are greater than PARMX2
*. 24-Jun-96  1.08   A.Furtjes   Protection, if EBEAM is zero
*. 18-Sep-95  0.00   A.Furtjes   Start coding
*. 29-Sep-95  1.00   A.Furtjes   1st version to be implemented in ROPE
*. 07-Oct-95  1.01   A.Furtjes   Some changes:
*.                               - clean up the code
*.                               - exclude gamma catcher for FD energy
*.                               - calculate additional quantities
*.                               - add 3rd selection
*.                               - Cut value according to mail from
*.                                 Asai (7/10/95)
*. 13-Oct-95  1.02   A.Furtjes   Change REPORT parameter
*. 18-Oct-95  1.03   A.Furtjes   Some changes:
*.                               - bug fix: ABS(Z0) and ABS(D0)
*.                               - ANGLE1/2 now defined for P1/2.EQ.0
*.                               - yet another set of cuts
*.                               - define COMMON blocks for cut values
*.                               - introduce FFREAD cards
*. 19-Oct-95  1.04   A.Furtjes   Fix problem of ECHTR=0.0
*.                               Put cut quantities in COMMON block ROCHVA
*.                               Check on IERR after THRUST routine
*. 25-Okt-95  1.05   A.Furtjes   - change .GT./.LT. to .GE./.LE. in
*.                                 track/ECAL quality criteria
*.                               - fix bug in forward energy calculation
*. 31-Okt-95  1.06   A.Furtjes   Cut on unconstrained z0 in track
*.                               quality selection
*. 17-Jun-96  1.07   A.Furtjes   Replace p_t cut by cut on p_t/sqrt(s)
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,ODPAR.
+SEQ,ROCHCU.
+SEQ,ROCHVA.
*
      INTEGER ISEL,ISELGP
*
      INTEGER I,IB,IERR,IPAR
      INTEGER NCHTR,ICTR,NECL,IECL
      INTEGER NPAR,NGOECL
      INTEGER PARMAX
      PARAMETER ( PARMAX = 200 )
      REAL    PPAR(5,PARMAX),QPAR(PARMAX)
      REAL    PHEM(3,2),PSUM(3),PMIS(3),EFORW,ECHTR
      REAL    PHEMXY(3,2)
      REAL    ACOLLI
      INTEGER IHEM
      REAL    THRUST   ,THRVEC(3)
      REAL    THRUS2(3),THRVE2(3,3)
      INTEGER PARMX2
      PARAMETER ( PARMX2 = 300 )
      LOGICAL ACCTRK(PARMX2),ACCECL(PARMX2)
      LOGICAL LASSCL
      REAL    ECL,SINTHE,COSTHE,SINPHI,COSPHI
      REAL    CUT,NMAX
      REAL    MOMECL(PARMAX)
      REAL    EDIFF
      REAL    EMAXUA,ECONUA
      INTEGER IMAXUA
      REAL    INPROD
      REAL    COSJ1,COSJ2
      REAL    COSAN,ANGLE,ANGLE1,ANGLE2
      REAL    P1,P2
      INTEGER NCONJ1,NCONJ2
      REAL    PCONJ1(3),PCONJ2(3)
      INTEGER NFDCL,IFDCL
      REAL    EGCCL1,EGCCL2
      INTEGER BSOUR
      REAL ZUNC
*
      REAL    PI
      PARAMETER (PI = 3.1415926535 )
*
      LOGICAL LDBG
+SEQ,ODSFUN.
      DATA    LDBG /.FALSE./
*
      IF ( LDBG ) THEN
        WRITE(6,*) '************************************************'
        WRITE(6,*) '************************************************'
        WRITE(6,*) 'ROCHSE called for run/evt:',IG(JGIRUN),IG(JGIEVT)
        WRITE(6,*) '************************************************'
      ENDIF
*
      ISEL = 0
      ISELGP  = 0
*
*************************************
*     Chargino Event Selection      *
*************************************
*
* --- extract information from DST
*
* --> reset some counters
*
      NPAR   = 0
      NGOCTR = 0
      NGOECL = 0
*
*     --> Beam energy
      EBEAM  = RG(JGEBEA)
      IF ( EBEAM .LE. 0.0 ) THEN
        WRITE (CHREP,'(A)') 'ROCHSE: Beam Energy is ZERO!'
        CALL REPORT('ROCHSE',1,'Error')
        GOTO 999
      ENDIF
*
* --> loop over all charged DST tracks
*
*     --> Number of charged tracks on DST
      NCHTR = IG(JGNCTR)
      IF ( NCHTR .GT. PARMX2 ) THEN
        CHREP = 'ROCHSE: Too many charged tracks -> exit!'
        CALL REPORT('ROCHSE',2,'Error')
        GOTO 999
      ENDIF
*
      DO 10 ICTR = 1,NCHTR
*
*     --> apply quality criteria
*
        ACCTRK(ICTR) = .FALSE.
*
        IB = 0
*
        COSTHE = ABS(SIN(ATAN(RC(JCTLAM,ICTR))))
        IF ( COSTHE .LT. 0.7 ) THEN
          NMAX = 140.
        ELSE
          NMAX = 140. * (1. - ( COSTHE-0.7 ) / 0.3 )
        ENDIF
        CUT = MAX( CHTRQU(1), NMAX/CHTRQU(2) )
        IF ( REAL(IC(JCNHCJ,ICTR))   .LE. CUT       ) IB=IB+1
        IF (  ABS(RC(JCD0,  ICTR))   .GE. CHTRQU(3) ) IB=IB+2
        CALL ODUNCZ(ICTR,ZUNC)
        IF (  ABS( ZUNC )            .GE. CHTRQU(4) ) IB=IB+4
        IF (      RC(JCR1,  ICTR)    .GE. CHTRQU(5) ) IB=IB+8
        IF (      RC(JCCHIR,ICTR)    .GE. CHTRQU(6) ) IB=IB+16
        IF (      RC(JCCHI3,ICTR)    .GE. CHTRQU(7) ) IB=IB+32
        IF (      SQRT(  RC(JCPX,ICTR)**2
     +                 + RC(JCPY,ICTR)**2 )
     +                               .LT. CHTRQU(8) ) IB=IB+64
        IF (      RC(JCP,ICTR)/EBEAM .GE. CHTRQU(9) ) IB=IB+128
*
*       --> Track passed quality criteria
        IF ( IB .EQ. 0 ) THEN
          ACCTRK(ICTR) = .TRUE.
          NGOCTR = NGOCTR + 1
          NPAR   = NPAR + 1
          IF ( NPAR .LE. PARMAX ) THEN
            PPAR(1,NPAR) = RC(JCPX,ICTR)
            PPAR(2,NPAR) = RC(JCPY,ICTR)
            PPAR(3,NPAR) = RC(JCPZ,ICTR)
            PPAR(5,NPAR) = 0.0
            PPAR(4,NPAR) = SQRT( PPAR(1,NPAR)**2 + PPAR(2,NPAR)**2
     +                         + PPAR(3,NPAR)**2 + PPAR(5,NPAR)**2 )
            QPAR(NPAR) = RC(JCQ,ICTR)
          ELSE
            WRITE (CHREP,'(A)') 'ROCHSE: Array overflow 1'
            CALL REPORT('ROCHSE',7,'Warning')
            NPAR = NPAR - 1
            GOTO 999
          ENDIF
        ENDIF
10    CONTINUE
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Number of good charged tracks on DST:',IG(JGNCT)
        WRITE(6,*) 'Number of good charged tracks here:  ',NGOCTR
      ENDIF
*
* --> loop over all ECAL clusters
*
*     --> Number of ECAL clusters
      NECL = IG(JGNECA)
      IF ( NECL .GT. PARMX2 ) THEN
        CHREP = 'ROCHSE: Too many ECAL clusters -> exit!'
        CALL REPORT('ROCHSE',3,'Error')
        GOTO 999
      ENDIF
*
      EMAXUA = 0.0
      IMAXUA = 0
*
      DO 20 IECL = 1,NECL
*
*     --> apply quality criteria
*
        ACCECL(IECL) = .FALSE.
*
        IB = 0
*       -- Require minimum energy (different in barrel and endcap).
        IF ( IAND(IE(JESOUR,IECL),MSKEB).NE.0) THEN
          IF (      RE(JEERAW,IECL)  .LE.  CHECQU(1) ) IB=IB+1
        ELSE
          IF (      RE(JEERAW,IECL)  .LE.  CHECQU(2) ) IB=IB+2
*         -- For the endcap also require at least two blocks.
          IF ( REAL(IE(JENBLO,IECL)) .LE.  CHECQU(3) ) IB=IB+4
        ENDIF
*
*       --> Cluster passed quality criteria
        IF ( IB .EQ. 0 ) THEN
          ACCECL(IECL) = .TRUE.
*
*         --- loop over all good tracks an determine, wether it
*             points to an ECAL cluster
*             -> if yes, sum up all momenta of pointing tracks
*
          IF (IECL .GT. PARMAX) THEN
            WRITE (CHREP,'(A)') 'ROCHSE: Array overflow 3'
            CALL REPORT('ROCHSE',8,'Warning')
            GOTO 999
          ENDIF
*
          LASSCL=.FALSE.
          MOMECL(IECL) = 0.0
          DO 30 ICTR = 1,NCHTR
            IF ( ACCTRK(ICTR)
     +          .AND. IC(JCIECA,ICTR) .EQ. IECL
     +                                          ) THEN
              LASSCL=.TRUE.
*             --> store momenta of all pointing trks
              MOMECL(IECL) =   MOMECL(IECL)
     +                       + SQRT (  RC(JCPX,ICTR)**2
     +                               + RC(JCPY,ICTR)**2
     +                               + RC(JCPZ,ICTR)**2 )
            ENDIF
30        CONTINUE
*
*         -->   !!! take raw energy here !!!
          ECL    = RE(JEERAW,IECL)
          SINTHE = SIN(RE(JETHET,IECL))
          COSTHE = COS(RE(JETHET,IECL))
          SINPHI = SIN(RE(JEPHI,IECL))
          COSPHI = COS(RE(JEPHI,IECL))
*         --> associated ECAL cluster
          IF ( LASSCL ) THEN
*
*           --- if EDIFF is greater than 0.1, add difference as
*               additional particle
*
            EDIFF = ECL - MOMECL(IECL)
            IF ( EDIFF .GT. 0.1 ) THEN
              NPAR   = NPAR + 1
              NGOECL = NGOECL + 1
              IF ( NPAR .LE. PARMAX ) THEN
                PPAR(1,NPAR) = EDIFF*SINTHE*COSPHI
                PPAR(2,NPAR) = EDIFF*SINTHE*SINPHI
                PPAR(3,NPAR) = EDIFF*COSTHE
                PPAR(5,NPAR) = 0.0
                PPAR(4,NPAR) = SQRT( PPAR(1,NPAR)**2 + PPAR(2,NPAR)**2
     +                             + PPAR(3,NPAR)**2 + PPAR(5,NPAR)**2 )
                QPAR(NPAR) = 0.0
              ELSE
                WRITE (CHREP,'(A)') 'ROCHSE: Array overflow 4'
                CALL REPORT('ROCHSE',9,'Warning')
                NPAR = NPAR - 1
                GOTO 999
              ENDIF
            ENDIF
*         --> unassociated ECAL cluster
          ELSE
            NPAR   = NPAR + 1
            NGOECL = NGOECL + 1
*           --> save highest energy cluster
            IF ( ECL .GT. EMAXUA ) THEN
              EMAXUA = ECL
              IMAXUA = NPAR
            ENDIF
            IF ( NPAR .LE. PARMAX ) THEN
              PPAR(1,NPAR) = ECL*SINTHE*COSPHI
              PPAR(2,NPAR) = ECL*SINTHE*SINPHI
              PPAR(3,NPAR) = ECL*COSTHE
              PPAR(5,NPAR) = 0.0
              PPAR(4,NPAR) = SQRT( PPAR(1,NPAR)**2 + PPAR(2,NPAR)**2
     +                           + PPAR(3,NPAR)**2 + PPAR(5,NPAR)**2 )
              QPAR(NPAR) = 0.0
            ELSE
              WRITE (CHREP,'(A)') 'ROCHSE: Array overflow 2'
              CALL REPORT('ROCHSE',10,'Warning')
              NPAR = NPAR - 1
              GOTO 999
            ENDIF
          ENDIF
        ENDIF
*
20    CONTINUE
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Number of good ECAL clusters:',NGOECL
        WRITE(6,*) 'Number of good particles:',NPAR
      ENDIF
*
      IF ( NPAR .LE. 1 ) THEN
         WRITE (CHREP,'(A)') 'ROCHSE: Number of particles .LE. 1'
         CALL REPORT('ROCHSE',11,'Warning')
         GOTO 999
      ENDIF
*
* --- calculate event quantities
*
*     --> thrust axis
*
*     --- thrust algorithm used by JETSET
      CALL PXLTH4(NPAR,5,PPAR,THRUS2,THRVE2,IERR)
      IF ( IERR .EQ. 0 ) THEN
        THRVEC(1) = THRVE2(1,3)
        THRVEC(2) = THRVE2(2,3)
        THRVEC(3) = THRVE2(3,3)
        THRUST    = THRUS2(3)
        COTHTH    = THRVEC(3) / SQRT( THRVEC(1)**2
     +                              + THRVEC(2)**2 + THRVEC(3)**2 )
      ELSE
        WRITE (CHREP,'(A)') 'ROCHSE: No THRUST axis available'
        CALL REPORT('ROCHSE',12,'Warning')
        GOTO 999
      ENDIF
*
*     --> properties of hemispheres
*
      CALL VZERO(PHEM,6)
      CALL VZERO(PSUM,3)
      CALL VZERO(EHEM,2)
      CALL VZERO(PCOMB,5)
      EVIS   = 0.0
      EFORW  = 0.0
      ECHTR  = 0.0
      ECONUA = 0.0
*
*     --> loop over charged/neutral particles
      DO 40 IPAR = 1,NPAR
        INPROD = THRVEC(1)*PPAR(1,IPAR) + THRVEC(2)*PPAR(2,IPAR)
     +                                  + THRVEC(3)*PPAR(3,IPAR)
        IF ( INPROD .GT. 0.0 ) THEN
          IHEM = 1
        ELSE
          IHEM = 2
        ENDIF
*       --> 'Jet' momentum
        PHEM(1,IHEM) = PHEM(1,IHEM) + PPAR(1,IPAR)
        PHEM(2,IHEM) = PHEM(2,IHEM) + PPAR(2,IPAR)
        PHEM(3,IHEM) = PHEM(3,IHEM) + PPAR(3,IPAR)
*       --> Energy in hemisphere
        EHEM(IHEM)   = EHEM(IHEM)   + PPAR(4,IPAR)
*       --> Visible Energy
        EVIS = EVIS + PPAR(4,IPAR)
*       --> Visible Energy in forward region (cos_theta > 0.8)
        IF ( ABS(QPAR(IPAR)) .GT. 0.0 ) THEN
          ECHTR = ECHTR + PPAR(4,IPAR)
          IF ( ABS(PPAR(3,IPAR)) / SQRT( PPAR(1,IPAR)**2 +
     +              PPAR(2,IPAR)**2 + PPAR(3,IPAR)**2 ) .GT. 0.8 ) THEN
            EFORW = EFORW + PPAR(4,IPAR)
          ENDIF
        ENDIF
*       --> Momentum sum
        PSUM(1) = PSUM(1) + PPAR(1,IPAR)
        PSUM(2) = PSUM(2) + PPAR(2,IPAR)
        PSUM(3) = PSUM(3) + PPAR(3,IPAR)
*
*       --> invariant mass of all particles
        CALL PXADD5(PPAR(1,IPAR),PCOMB,PCOMB)
*
*       --> Energy in cone around E_max(unass. ECAL cluster)
        IF ( IPAR .NE. IMAXUA .AND. IMAXUA .NE. 0 ) THEN
          CALL PXANG3(PPAR(1,IPAR),PPAR(1,IMAXUA),COSAN,ANGLE,IERR)
          ANGLE = ANGLE / PI * 180.0
          IF ( ANGLE .LT. 20.0 ) THEN
            ECONUA = ECONUA + PPAR(4,IPAR)
          ENDIF
        ENDIF
40    CONTINUE
*
*     ---> Missing Momentum
      PMIS(1) = -1.0 * PSUM(1)
      PMIS(2) = -1.0 * PSUM(2)
      PMIS(3) = -1.0 * PSUM(3)
*
*     ---> Transverse Momentum
      PT = SQRT(PSUM(1)**2+PSUM(2)**2)
*
*     ---> Energy in forward region
      IF ( ECHTR .GT. 0.0 ) THEN
        EFRAC = EFORW / ECHTR
      ELSE
        EFRAC = 0.0
      ENDIF
*
*     --> Cos(theta) of missing momentum
      P1 = SQRT(PSUM(1)**2+PSUM(2)**2+PSUM(3)**2)
      IF ( P1 .GT. 0.0 ) THEN
        COTHPM = PMIS(3) / P1
      ELSE
        IF ( PMIS(3) .GE. 0.0 ) THEN
          COTHPM = 1.0
        ELSE
          COTHPM = -1.0
        ENDIF
      ENDIF
*
*     --> Max( cosinus of theta_jet )
      P1 = SQRT(PHEM(1,1)**2+PHEM(2,1)**2+PHEM(3,1)**2)
      IF ( P1 .GT. 0.0 ) THEN
        COSJ1 = PHEM(3,1) / P1
      ELSE
        COSJ1 = 0.0
      ENDIF
*
      P2 = SQRT(PHEM(1,2)**2+PHEM(2,2)**2+PHEM(3,2)**2)
      IF ( P2 .GT. 0.0 ) THEN
        COSJ2 = PHEM(3,2) / P2
      ELSE
        COSJ2 = 0.0
      ENDIF
*
      IF ( ABS(COSJ1) .GT. ABS(COSJ2) ) THEN
        COSJMX = COSJ1
      ELSE
        COSJMX = COSJ2
      ENDIF
*
*     --> Acollinearity (Angle between Jet1 and Jet2 in 3d)
      P1 = SQRT(PHEM(1,1)**2+PHEM(2,1)**2+PHEM(3,1)**2)
      P2 = SQRT(PHEM(1,2)**2+PHEM(2,2)**2+PHEM(3,2)**2)
      IF ( P1.GT.1.0E-5 .AND. P2.GT.1.0E-5 ) THEN
        CALL PXANG3(PHEM(1,1),PHEM(1,2),COSAN,ANGLE,IERR)
*
        IF ( ABS(COSAN) .LE. 0.9999999 ) THEN
          ACOLLI = 180.0 - ( ANGLE / PI * 180.0 )
        ELSEIF ( COSAN .GT. 0.0 ) THEN
          ACOLLI = 180.0
        ELSE
          ACOLLI = 0.0
        ENDIF
      ELSE
        ACOLLI = 180.0
      ENDIF
*
*     --> Acoplanarity (Angle between Jet1 and Jet2 in x-y plane)
      CALL UCOPY(PHEM,PHEMXY,6)
      PHEMXY(3,1) = 0.0
      PHEMXY(3,2) = 0.0
      P1 = SQRT(PHEMXY(1,1)**2+PHEMXY(2,1)**2)
      P2 = SQRT(PHEMXY(1,2)**2+PHEMXY(2,2)**2)
      IF ( P1 .GT. 0.0 .AND. P2 .GT. 0.0 ) THEN
        CALL PXANG3(PHEMXY(1,1),PHEMXY(1,2),COSAN,ANGLE,IERR)
*
        IF ( ABS(COSAN) .LE. 0.9999999 ) THEN
          ACOPLA = 180.0 - ( ANGLE / PI * 180.0 )
        ELSEIF ( COSAN .GT. 0.0 ) THEN
          ACOPLA = 180.0
        ELSE
          ACOPLA = 0.0
        ENDIF
      ELSE
        ACOPLA = 180.0
      ENDIF
*
*     --> Determine cone quantities:
*            - the number of charged tracks in cone around jets
*            - the summed momentum of all particles in cone around jets
*
      NCONJ1 = 0
      NCONJ2 = 0
      CALL VZERO(PCONJ1,3)
      CALL VZERO(PCONJ2,3)
      ECONJ1 = 0.0
      ECONJ2 = 0.0
      EOUT   = 0.0
      P1 = SQRT(PHEM(1,1)**2+PHEM(2,1)**2+PHEM(3,1)**2)
      P2 = SQRT(PHEM(1,2)**2+PHEM(2,2)**2+PHEM(3,2)**2)
*     --> loop over charged/neutral particles
      DO 50 IPAR = 1,NPAR
*
*         --- Angle between jet1 and charged particle
        IF ( P1 .GT. 0.0 ) THEN
          CALL PXANG3(PPAR(1,IPAR),PHEM(1,1),COSAN,ANGLE1,IERR)
          ANGLE1 = ANGLE1 / PI * 180.0
          IF ( ANGLE1 .LT. 20.0 ) THEN
            IF ( ABS(QPAR(IPAR)) .GT. 0.0 ) THEN
              NCONJ1  = NCONJ1 + 1
            ENDIF
            PCONJ1(1) = PCONJ1(1) + PPAR(1,IPAR)
            PCONJ1(2) = PCONJ1(2) + PPAR(2,IPAR)
            PCONJ1(3) = PCONJ1(3) + PPAR(3,IPAR)
            ECONJ1    = ECONJ1    + PPAR(4,IPAR)
          ENDIF
        ELSE
          ANGLE1 = 0.
        ENDIF
*
*       --- Angle between jet2 and charged particle
        IF ( P2 .GT. 0.0 ) THEN
          CALL PXANG3(PPAR(1,IPAR),PHEM(1,2),COSAN,ANGLE2,IERR)
          ANGLE2 = ANGLE2 / PI * 180.0
          IF ( ANGLE2 .LT. 20.0 ) THEN
            IF ( ABS(QPAR(IPAR)) .GT. 0.0 ) THEN
              NCONJ2  = NCONJ2 + 1
            ENDIF
            PCONJ2(1) = PCONJ2(1) + PPAR(1,IPAR)
            PCONJ2(2) = PCONJ2(2) + PPAR(2,IPAR)
            PCONJ2(3) = PCONJ2(3) + PPAR(3,IPAR)
            ECONJ2    = ECONJ2    + PPAR(4,IPAR)
          ENDIF
        ELSE
          ANGLE2 = 0.
        ENDIF
*
*       --- Energy not contained in cones
        IF ( ANGLE1.GE.20. .AND. ANGLE2.GE.20. ) THEN
          EOUT = EOUT + PPAR(4,IPAR)
        ENDIF
*
50    CONTINUE
*
*     --> Energy deposited in FD
*
      NFDCL = IG(JGNFDE)
*
      EFDCL1 = 0.0
      EFDCL2 = 0.0
      EGCCL1 = 0.0
      EGCCL2 = 0.0
      DO 60 IFDCL = 1,NFDCL
        BSOUR = IF(JFSOUR,IFDCL)
*       --> exclude information from SiW and Gamma Catcher
        IF ( .NOT. ( BTEST(BSOUR,19) .OR. BTEST(BSOUR,0) ) ) THEN
          IF ( RF(JFTHET,IFDCL) .GT. PI/2.0 ) THEN
            EFDCL1 = EFDCL1 + RF(JFE,IFDCL)
          ELSE
            EFDCL2 = EFDCL2 + RF(JFE,IFDCL)
          ENDIF
        ENDIF
*       --> record information from Gamma Catcher
        IF ( BTEST(BSOUR,0) ) THEN
          IF ( RF(JFTHET,IFDCL) .GT. PI/2.0 ) THEN
            EGCCL1 = EGCCL1 + RF(JFE,IFDCL)
          ELSE
            EGCCL2 = EGCCL2 + RF(JFE,IFDCL)
          ENDIF
        ENDIF
60    CONTINUE
*
*     --- output of calculated variables for debugging
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'THRUST, THRUST AXIS:',THRUST,(THRVEC(I),I=1,3)
     +             ,SQRT(THRVEC(1)**2+THRVEC(2)**2+THRVEC(3)**2)
        WRITE(6,*) 'Cos_theta_thrust:',COTHTH
        WRITE(6,*) '                        Px,Py,Pz,P'
        WRITE(6,*) 'Summed Momentum     :',(PSUM(I),I=1,3)
     +               ,SQRT(PSUM(1)**2+PSUM(2)**2+PSUM(3)**2)
        WRITE(6,*) 'Summed Momentum Hem1:',(PHEM(I,1),I=1,3)
     +               ,SQRT(PHEM(1,1)**2+PHEM(2,1)**2+PHEM(3,1)**2)
        WRITE(6,*) 'Summed Momentum Hem2:',(PHEM(I,2),I=1,3)
     +               ,SQRT(PHEM(1,2)**2+PHEM(2,2)**2+PHEM(3,2)**2)
        WRITE(6,*) 'Missing Momentum    :',(PMIS(I),I=1,3)
     +               ,SQRT(PMIS(1)**2+PMIS(2)**2+PMIS(3)**2)
        WRITE(6,*) '                        Px,Py,Pz,E,M'
        WRITE(6,*) 'Combined Momentum   :',(PCOMB(I),I=1,5)
        WRITE(6,*) 'Acoplanarity angle:',ACOPLA
        WRITE(6,*) 'Acollinearity angle:',ACOLLI
        WRITE(6,*) 'Visible Energy:',EVIS
        WRITE(6,*) 'Energy from charged trks:',ECHTR
        WRITE(6,*) 'Energy from charged trks in forward region:',EFORW
        WRITE(6,*) 'Energy in hem 1/2:',EHEM(1),EHEM(2)
        WRITE(6,*) 'Beam Energy:',EBEAM
        WRITE(6,*) 'E_max(unass. ECAL CL),Index:',EMAXUA,IMAXUA
        WRITE(6,*) 'Energy in 20^o around E_max(..):',ECONUA
        WRITE(6,*) 'Cosine of Jet1,2,Max.Value:',COSJ1,COSJ2,COSJMX
        WRITE(6,*) 'Number of charged tracks in 20^o cone around',
     +             ' Jet1,2:',NCONJ1,NCONJ2
        WRITE(6,*) 'P sum in 20^o cone around Jet1:',
     +                (PCONJ1(I),I=1,3),
     +           SQRT(PCONJ1(1)**2+PCONJ1(2)**2+PCONJ1(3)**2)
        WRITE(6,*) 'E sum in 20^o cone around Jet1:',ECONJ1
        WRITE(6,*) 'P sum in 20^o cone around Jet2:',
     +                (PCONJ2(I),I=1,3),
     +           SQRT(PCONJ2(1)**2+PCONJ2(2)**2+PCONJ2(3)**2)
        WRITE(6,*) 'E sum in 20^o cone around Jet2:',ECONJ2
        WRITE(6,*) 'E not contained in cones: ',EOUT,
     +                                          EVIS-ECONJ1-ECONJ2
        WRITE(6,*) 'Energy deposited in FD:',EFDCL1,EFDCL2
      ENDIF
************************************
* --- loose selection 1            *
************************************
*
      IB=0
*
      IF ( EHEM(1)          .LE. CHSEL1(1)  ) IB=IB+1
      IF ( EHEM(2)          .LE. CHSEL1(1)  ) IB=IB+2
      IF ( EFDCL1           .GE. CHSEL1(2)  ) IB=IB+4
      IF ( EFDCL2           .GE. CHSEL1(2)  ) IB=IB+8
      IF ( REAL(NGOCTR)     .LT. CHSEL1(3)  ) IB=IB+16
      IF ( EVIS/(2.0*EBEAM) .LE. CHSEL1(4)  ) IB=IB+32
      CUT = MAX(  CHSEL1(5),
     +            CHSEL1(6)*(80.-(300.*EVIS/(2.0*EBEAM))))
      IF ( ACOPLA           .LE.  CUT       ) IB=IB+64
      IF ( ABS(COTHPM)      .GE. CHSEL1(7)  ) IB=IB+128
      IF ( ABS(COSJMX)      .GE. CHSEL1(8)  ) IB=IB+256
      IF ( ABS(COTHTH)      .GE. CHSEL1(9)  ) IB=IB+512
      IF ( EFRAC            .GE. CHSEL1(10) ) IB=IB+1024
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Selection word for 1. loose selection:',IB
      ENDIF
*     --> event is accepted
      IF ( IB .EQ. 0 ) THEN
        IF ( LDBG ) THEN
          WRITE(6,*) '***********************************'
          WRITE(6,*) '*   Loose selection 1 satisfied   *'
          WRITE(6,*) '***********************************'
        ENDIF
*
* --- set output flags
*
        ISEL = ISEL + 1
*
* --- report that event passed selection criteria
*
        WRITE (CHREP,'(A)') 'ROCHSE: Event passed loose selection 1'
        CALL REPORT('ROCHSE',1,'Information')
*
      ENDIF
*
************************************
* --- tight selection 1            *
************************************
*
      IB=0
*
      IF ( EHEM(1) .LE. CHSET1(1) ) THEN
        IF ( NCONJ1         .EQ.  0     ) IB=IB+1
      ENDIF
      IF ( EHEM(2) .LE. CHSET1(1) ) THEN
        IF ( NCONJ2         .EQ.  0     ) IB=IB+2
      ENDIF
      IF ( EFDCL1           .GE. CHSET1(2) ) IB=IB+4
      IF ( EFDCL2           .GE. CHSET1(2) ) IB=IB+8
      IF ( REAL(NGOCTR)     .LT. CHSET1(3) ) IB=IB+16
      IF ( EVIS/(2.0*EBEAM) .LE. CHSET1(4) ) IB=IB+32
      CUT = MAX(  CHSET1(5),
     +            CHSET1(6)*(80.-(300.*EVIS/(2.0*EBEAM))))
      IF ( ACOPLA           .LE.  CUT   ) IB=IB+64
      IF ( ABS(COTHPM)      .GE. CHSET1(7) ) IB=IB+128
      IF ( ABS(COSJMX)      .GE. CHSET1(8) ) IB=IB+256
      IF ( ABS(COTHTH)      .GE. CHSET1(9) ) IB=IB+512
      IF ( EFRAC            .GE. CHSET1(10) ) IB=IB+1024
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Selection word for 1. tight selection:',IB
      ENDIF
*     --> event is accepted
      IF ( IB .EQ. 0 ) THEN
        IF ( LDBG ) THEN
          WRITE(6,*) '***********************************'
          WRITE(6,*) '*   Tight selection 1 satisfied   *'
          WRITE(6,*) '***********************************'
        ENDIF
*
* --- set output flags
*
        ISELGP = ISELGP + 1
*
* --- report that event passed selection criteria
*
        WRITE (CHREP,'(A)') 'ROCHSE: Event passed tight selection 1'
        CALL REPORT('ROCHSE',2,'Information')
*
      ENDIF
*
************************************
* --- loose selection 2            *
************************************
*
      IB=0
*
      IF ( EHEM(1)          .LE. CHSEL2(1)  ) IB=IB+1
      IF ( EHEM(2)          .LE. CHSEL2(1)  ) IB=IB+2
      IF ( EFDCL1           .GE. CHSEL2(2)  ) IB=IB+4
      IF ( EFDCL2           .GE. CHSEL2(2)  ) IB=IB+8
      IF ( REAL(NGOCTR)     .LT. CHSEL2(3)  ) IB=IB+16
      IF ( REAL(NGOCTR)     .GT. CHSEL2(4)  ) IB=IB+32
      IF ( EVIS/(2.0*EBEAM) .LE. CHSEL2(5)  ) IB=IB+64
      IF ( ACOPLA           .LE. CHSEL2(6)  ) IB=IB+128
      IF ( ABS(COTHPM)      .GE. CHSEL2(7)  ) IB=IB+256
      IF ( ABS(COSJMX)      .GE. CHSEL2(8)  ) IB=IB+512
      IF ( ABS(COTHTH)      .GE. CHSEL2(9)  ) IB=IB+1024
      IF ( PT/(2.0*EBEAM)   .LE. CHSEL2(10) ) IB=IB+2048
      IF ( ECONJ1           .LE. CHSEL2(11) ) IB=IB+4096
      IF ( ECONJ2           .LE. CHSEL2(11) ) IB=IB+8192
      IF ( EOUT             .GE. CHSEL2(12) ) IB=IB+16384
      IF ( EFRAC            .GE. CHSEL2(13) ) IB=IB+32768
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Selection word for 2. loose selection:',IB
      ENDIF
*     --> event is accepted
      IF ( IB .EQ. 0 ) THEN
        IF ( LDBG ) THEN
          WRITE(6,*) '***********************************'
          WRITE(6,*) '*   Loose selection 2 satisfied   *'
          WRITE(6,*) '***********************************'
        ENDIF
*
* --- set output flags
*
        ISEL = ISEL + 2
*
* --- report that event passed selection criteria
*
        WRITE (CHREP,'(A)') 'ROCHSE: Event passed loose selection 2'
        CALL REPORT('ROCHSE',3,'Information')
*
      ENDIF
*
*
************************************
* --- tight selection 2            *
************************************
*
      IB=0
*
      IF ( EHEM(1) .LE. CHSET2(1) ) THEN
        IF ( NCONJ1         .EQ.  0     ) IB=IB+1
      ENDIF
      IF ( EHEM(2) .LE. CHSET2(1) ) THEN
        IF ( NCONJ2         .EQ.  0     ) IB=IB+2
      ENDIF
      IF ( EFDCL1           .GE. CHSET2(2)  ) IB=IB+4
      IF ( EFDCL2           .GE. CHSET2(2)  ) IB=IB+8
      IF ( REAL(NGOCTR)     .LT. CHSET2(3)  ) IB=IB+16
      IF ( REAL(NGOCTR)     .GT. CHSET2(4)  ) IB=IB+32
      IF ( EVIS/(2.0*EBEAM) .LE. CHSET2(5)  ) IB=IB+64
      IF ( ACOPLA           .LE. CHSET2(6)  ) IB=IB+128
      IF ( ABS(COTHPM)      .GE. CHSET2(7)  ) IB=IB+256
      IF ( ABS(COSJMX)      .GE. CHSET2(8)  ) IB=IB+512
      IF ( ABS(COTHTH)      .GE. CHSET2(9)  ) IB=IB+1024
      IF ( PT/(2.0*EBEAM)   .LE. CHSET2(10) ) IB=IB+2048
      IF ( ECONJ1           .LE. CHSET2(11) ) IB=IB+4096
      IF ( ECONJ2           .LE. CHSET2(11) ) IB=IB+8192
      IF ( EOUT             .GE. CHSET2(12) ) IB=IB+16384
      IF ( EFRAC            .GE. CHSET2(13) ) IB=IB+32768
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Selection word for 2. tight selection:',IB
      ENDIF
*     --> event is accepted
      IF ( IB .EQ. 0 ) THEN
        IF ( LDBG ) THEN
          WRITE(6,*) '***********************************'
          WRITE(6,*) '*   Tight selection 2 satisfied   *'
          WRITE(6,*) '***********************************'
        ENDIF
*
* --- set output flags
*
        ISELGP = ISELGP + 2
*
* --- report that event passed selection criteria
*
        WRITE (CHREP,'(A)') 'ROCHSE: Event passed tight selection 2'
        CALL REPORT('ROCHSE',4,'Information')
*
      ENDIF
*
************************************
* --- loose selection 3            *
************************************
*
      IB=0
*
      IF ( EHEM(1) .LE. CHSEL3(1) .AND.
     +     EHEM(2) .LE. CHSEL3(1)          ) IB=IB+1
      IF ( EHEM(1) .GE. CHSEL3(1) .AND.
     +     EHEM(2) .GE. CHSEL3(1)          ) IB=IB+2
      IF ( EFDCL1           .GE. CHSEL3(2) ) IB=IB+4
      IF ( EFDCL2           .GE. CHSEL3(2) ) IB=IB+8
      IF ( REAL(NGOCTR)     .LT. CHSEL3(3) ) IB=IB+16
      IF ( EVIS/(2.0*EBEAM) .LE. CHSEL3(4) ) IB=IB+32
      IF ( ABS(COTHPM)      .GE. CHSEL3(5) ) IB=IB+64
      IF ( ABS(COTHTH)      .GE. CHSEL3(6) ) IB=IB+128
      IF ( PT/(2.0*EBEAM)   .LE. CHSEL3(7) ) IB=IB+256
      IF ( PCOMB(5)         .LE. CHSEL3(8) ) IB=IB+512
      IF ( EFRAC            .GE. CHSEL3(9) ) IB=IB+1024
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Selection word for 3. loose selection:',IB
      ENDIF
*     --> event is accepted
      IF ( IB .EQ. 0 ) THEN
        IF ( LDBG ) THEN
          WRITE(6,*) '***********************************'
          WRITE(6,*) '*   Loose selection 3 satisfied   *'
          WRITE(6,*) '***********************************'
        ENDIF
*
* --- set output flags
*
        ISEL = ISEL + 4
*
* --- report that event passed selection criteria
*
        WRITE (CHREP,'(A)') 'ROCHSE: Event passed loose selection 3'
        CALL REPORT('ROCHSE',5,'Information')
*
      ENDIF
*
*
************************************
* --- tight selection 3            *
************************************
*
      IB=0
*
      IF ( EHEM(1) .GE. CHSET3(1) ) THEN
        IF ( EHEM(2) .GT. CHSET3(1) ) IB=IB+1
        IF ( NCONJ2  .GT.  0  ) IB=IB+2
      ENDIF
      IF ( EHEM(2) .GE. CHSET3(1) ) THEN
        IF ( EHEM(1) .GT. CHSET3(1) ) IB=IB+4
        IF ( NCONJ1  .GT.  0  ) IB=IB+8
      ENDIF
      IF ( EFDCL1           .GE. CHSET3(2) ) IB=IB+16
      IF ( EFDCL2           .GE. CHSET3(2) ) IB=IB+32
      IF ( REAL(NGOCTR)     .LT. CHSET3(3) ) IB=IB+64
      IF ( EVIS/(2.0*EBEAM) .LE. CHSET3(4) ) IB=IB+128
      IF ( ABS(COTHPM)      .GE. CHSET3(5) ) IB=IB+256
      IF ( COTHTH           .GE. CHSET3(6) ) IB=IB+512
      IF ( PT/(2.0*EBEAM)   .LE. CHSET3(7) ) IB=IB+1024
      IF ( PCOMB(5)         .LE. CHSET3(8) ) IB=IB+2048
      IF ( EFRAC            .GE. CHSET3(9) ) IB=IB+4096
*
      IF ( LDBG ) THEN
        WRITE(6,*) 'Selection word for 3. tight selection:',IB
      ENDIF
*     --> event is accepted
      IF ( IB .EQ. 0 ) THEN
        IF ( LDBG ) THEN
          WRITE(6,*) '***********************************'
          WRITE(6,*) '*   Tight selection 3 satisfied   *'
          WRITE(6,*) '***********************************'
        ENDIF
*
* --- set output flags
*
        ISELGP = ISELGP + 4
*
* --- report that event passed selection criteria
*
        WRITE (CHREP,'(A)') 'ROCHSE: Event passed tight selection 3'
        CALL REPORT('ROCHSE',6,'Information')
*
      ENDIF
*
*
 999  CONTINUE
*
      END
+DECK,RONRMH.
      SUBROUTINE RONRMH(LNRMH1,LNRMH2)
*.
*...RONRMH      Select non-radiative multihadrons (s'/s > 0.8)
*.
*. OUTPUT    :  LNRMH1  true if selected by simple algorithm WWSPRI
*. OUTPUT    :  LNRMH2  true if selected by complicated algorithm WWSPR
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. AUTHOR    :  D.R.Ward
*. VERSION   :  1.00
*. DATE      :  12-Jun-96
*. LAST MOD  :  5-Aug-96
*.
*. Modification Log.
*.  5-Aug-96 D.Ward     Cut on square of energy fraction, not on fraction
*.
*.**********************************************************************
*
+SEQ,DECLARE.
+SEQ,ODPAR.
+SEQ,RCREP.
+SEQ,ROTPAR.
      REAL DUMMY1,DUMMY2,DUMMY3,ECM,SPR
      INTEGER IERR
      LOGICAL REVTYP,LNRMH1,LNRMH2
+SEQ,ODSFUN.
*
      LNRMH1=.FALSE.
      LNRMH2=.FALSE.
*   Only if TKMH or L2MH selection
      IF(REVTYP(IETKMH) .OR. REVTYP(IEL2MH)) THEN
         ECM=2.*RG(JGEBEA)
         CALL WWSPRI(SPR,DUMMY1,DUMMY2,DUMMY3,IERR)
         IF((SPR/ECM)**2.GT.0.8) LNRMH1=.TRUE.
         CALL WWSPR(' ',SPR,DUMMY1,DUMMY2,IERR)
         IF((SPR/ECM)**2.GT.0.8) LNRMH2=.TRUE.
      ENDIF
*
      END
+DECK,ROWWSE.
      SUBROUTINE ROWWSE(ISEL,IERR)
*.
*...ROWWSE     Select reasonable quality WW candidates, using:
*.               o  cuts based selections (ONLINE),
*.               o  WW default selections (likelihoods, in WW110) (OFFLINE).
*.
*. OUTPUT    :  ISEL      Bit string. Defined as below.
*. OUTPUT    :  IERR      Non-zero ==> Error return
*.
*.
*.  NB:  Selections are not exclusive
*.  ---------------------------------
*.
*.  ISEL bits (0-4) are defined               event type bits
*.  ---------------------------               ---------------
*.   bit 0  - flagged as  WW -> qqqq      ->    set IEWW4Q
*.   bit 1  - flagged as  WW -> qqenu     ->    set IEWWQE
*.   bit 2  - flagged as  WW -> qqmunu    ->    set IEWWQM
*.   bit 3  - flagged as  WW -> qq taunu  ->    set IEWWQT
*.   bit 4  - flagged as  WW -> lnu lnu   ->    set IEWWLL
*.
*.
*. COMMON    :
*. SEQUENCE  : DECLARE RCREP RBITFUNC
*. CALLS     : WWSLCT WWQQQQ WWQQLN WWQQTN WWLNLN ROUPON
*. CALLED    : <user>
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : N.K.Watson
*. VERSION   : 1.00
*. CREATED   :  6-Jun-96
*. LAST MOD  : 18-May-97
*.
*. Modification Log.
*. 18-May-97 N.K.Watson   Changes for WW110, different selections on/offline
*. 20-Jun-96 N.K.Watson   Return in ISEL bit string for event selection.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,RBITFUNC.
      INTEGER ISEL,IERR
      INTEGER ISQQQQ,ISQQLN,ISQQTN,ISLNLN,ICLEMU,JERR
      REAL    RSQQQQ,RSQQLN
      CHARACTER*1 CHOPT
      LOGICAL ONLINE
*- Definitions of bits pattern returned in ISEL
      INTEGER    IBWW4Q,   IBWWQE,  IBWWQM,  IBWWQT,  IBWWLL
      PARAMETER (IBWW4Q=0, IBWWQE=1,IBWWQM=2,IBWWQT=3,IBWWLL=4)
*
+SEQ,ODSFUN.
*
*- Initialise selection word.
      ISEL=0
      IERR=0
      JERR=0
*
      ISQQQQ=0
      ISQQLN=0
      ISQQTN=0
      ISLNLN=0
*
*-- For ONLINE ROPE, always use the cuts based analyses.
      CALL ROUPON(ONLINE)
      IF (ONLINE) THEN
        CHOPT='C'
      ELSE
        CHOPT=' '
      ENDIF
*
*   Apply event selections for each channel in turn.
*
*-- WW -> qqqq
      CALL WWQQQQ(CHOPT,ISQQQQ,RSQQQQ,JERR)
      IF (JERR.NE.0) THEN
        WRITE(CHREP,1001)'WWQQQQ',JERR
        CALL REPORT('ROWWSE',1,'WARNING')
        JERR=0
      ELSEIF (ISQQQQ.GE.1) THEN
*- Set bit for   WW -> qqqq   selection.
         ISEL=IBSET(ISEL,IBWW4Q)
      ENDIF
*
*-- WW -> qq lnu
      CALL WWQQLN(CHOPT,ISQQLN,RSQQLN,ICLEMU,JERR)
      IF (JERR.NE.0) THEN
        WRITE(CHREP,1001)'WWQQLN',JERR
        CALL REPORT('ROWWSE',2,'WARNING')
        JERR=0
      ELSEIF (ISQQLN.GE.1) THEN
*- Set bit for   WW -> qqenu   selection?
        IF (BTEST(ICLEMU,0)) ISEL=IBSET(ISEL,IBWWQE)
*- Set bit for   WW -> qqmunu   selection?
        IF (BTEST(ICLEMU,1)) ISEL=IBSET(ISEL,IBWWQM)
*- Set bit for   WW -> qqtaunu   selection? (Not for cuts selection.)
        IF (.NOT.ONLINE.AND.BTEST(ICLEMU,2)) ISEL=IBSET(ISEL,IBWWQT)
      ENDIF

*
*-- qqtaunu is part of qqlnu in the likelihood selctions, so only
*-- use cuts analysis online for now.
      IF (ONLINE) THEN
*-- WW -> qq taunu
        CALL WWQQTN('C',ISQQTN,JERR)
        IF (JERR.NE.0) THEN
          WRITE(CHREP,1001)'WWQQTN',JERR
          CALL REPORT('ROWWSE',5,'WARNING')
          JERR=0
        ELSEIF (ISQQTN.GE.1) THEN
*- Set bit for   WW -> qqtaunu   selection.
          ISEL=IBSET(ISEL,IBWWQT)
        ENDIF
      ENDIF
*
*-- WW -> lnu lnu
      CALL WWLNLN(ISLNLN,JERR)
      IF (JERR.NE.0) THEN
        WRITE(CHREP,1001)'WWLNLN',JERR
        CALL REPORT('ROWWSE',6,'WARNING')
        JERR=0
      ELSEIF (ISLNLN.GE.1) THEN
*- Set bit for   WW -> lnulnu   selection.
        ISEL=IBSET(ISEL,IBWWLL)
      ENDIF
*
 1001 FORMAT(A6,' returned error status ',I2,', event rejected.')
  99  END
+DECK,RPHCOR.
      REAL FUNCTION RPHCOR(PHIIN,RAD,IEND)
*.
*...RPHCOR  CORRECTS PHI POSITION
*.
*. INPUT     : PHIIN   INPUT PHI
*. INPUT     : RAD     RADIUS OF SHOWER
*. INPUT     : IEND    END TO USE (1=RIGHT, 2=LEFT)
*.
*. AUTHOR    : W. P. Lai / D. Strom
*. VERSION   : 1.00
*. CREATED   : 28-Jan-95
*. LAST MOD  : 15-Apr-98
*.
*. Modification Log.
*. 15-Apr-98   D. Strom   Changed length of variables like xxxphi
*. 30-Jan-95   W-P Lai    Added ratio for left side, and correct the sign of m
*. 08-Jul-96   W-P Lai    type DELTAPHI as real( untyped originally )
*.****************************************************************************
*
+SEQ,DECLARE.
      REAL PHIIN,RAD
      INTEGER IEND
*
      REAL A
      REAL PHI0,UNITPH
      REAL DELTAP
      REAL PI
      REAL P1,P2,P3,P4
      REAL RATIO,M
      PARAMETER ( PI=3.14159265 )

      UNITPH = (2.0*PI/32.0)
      PHI0= (UNITPH)*INT((PHIIN/UNITPH)+0.5)
*
* The value of a is the value of smearing currently used in rope
*
      A=0.1
      DELTAP=(PHIIN-PHI0)

*For tower boundary, return unsmoothed phi:

      IF(ABS(DELTAP).GT.0.098169799999999) THEN
        RPHCOR=PHIIN
        RETURN
       END IF
*
*For RHS, sign(ratior)= sign(deltaphi)
*For LHS, sign(ratiol)=-sign(deltaphi)

      IF( DELTAP .EQ. 0.0 ) THEN
            RPHCOR=PHIIN
          RETURN
       END IF
       IF(IEND.EQ.1)  THEN
           IF( DELTAP .GT. 0.0) THEN
             RATIO= ( A/ ( PI/(32.0*DELTAP) - (1.0-A) ) )
           END IF
           IF( DELTAP .LT. 0.0) THEN
             RATIO= ( A/ ( PI/(32.0*DELTAP) + (1.0-A) ) )
           END IF
        ELSE
           IF( DELTAP .GT. 0.0) THEN
             RATIO=-( A/ ( PI/(32.0*DELTAP) - (1.0-A) ) )
           END IF
           IF( DELTAP .LT. 0.0) THEN
             RATIO=-( A/ ( PI/(32.0*DELTAP) + (1.0-A) ) )
           END IF
        END IF
* Right End
*
        IF(IEND.EQ.1) THEN
*
*Select different set of fitting parameters according
*the radial regions: 0,1,2,3,4,5,6,7
*
*region #0
        IF( 6.2.LT.RAD.AND.RAD.LT.7.2 ) THEN
           P1=0.007111
           P2=0.1703
           P3=9055
           P4=23.42
        END IF
*region #1
        IF( 7.2.LT.RAD.AND.RAD.LT.8.2 ) THEN
          P1=0.007111
          P2=0.1703
          P3=9055
          P4=23.42
        END IF
*region #2
        IF( 8.2.LT.RAD.AND.RAD.LT.9.2 ) THEN
          P1=0.006997
          P2=0.1683
          P3=10260
          P4=20.32
        END IF
*region #3
        IF( 9.2.LT.RAD.AND.RAD.LT.10.2 ) THEN
          P1=0.006331
          P2=0.1754
          P3=10960
          P4=18.01
        END IF
*region #4
        IF( 10.2.LT.RAD.AND.RAD.LT.11.2 ) THEN
         P1=0.006428
         P2=0.1690
         P3=12580
         P4=15.57
        END IF
*region #5
        IF( 11.2.LT.RAD.AND.RAD.LT.12.2 ) THEN
         P1=0.007183
         P2=0.1426
         P3=15820
         P4=12.08
        END IF
*region #6
        IF( 12.2.LT.RAD.AND.RAD.LT.13.2 ) THEN
         P1=0.007761
         P2=0.1280
         P3=18880
         P4=10.02
        END IF
*region #7
        IF( 13.2.LT.RAD.AND.RAD.LT.14.2 ) THEN
          P1=0.007761
          P2=0.1280
          P3=18880
          P4=10.02
        END IF
      ELSE
**
* left side
*region #0
      IF( 6.2.LT.RAD.AND.RAD.LT.7.2 ) THEN
         P1=0.007028
         P2=0.1733
         P3=8951.
         P4=23.76
      END IF
*region #1
      IF( 7.2.LT.RAD.AND.RAD.LT.8.2 ) THEN
         P1=0.007028
         P2=0.1733
         P3=8951.
         P4=23.76
      END IF
*region #2
      IF( 8.2.LT.RAD.AND.RAD.LT.9.2 ) THEN
         P1=0.006534
         P2=0.1803
         P3=9447.
         P4=21.78
      END IF
*region #3
      IF( 9.2.LT.RAD.AND.RAD.LT.10.2 ) THEN
       P1=0.005979
       P2=0.1932
       P3=10110
       P4=19.91
      END IF
*region #4
      IF( 10.2.LT.RAD.AND.RAD.LT.11.2 ) THEN
       P1=0.005857
       P2=0.1917
       P3=11600
       P4=17.08
      END IF
*region #5
      IF( 11.2.LT.RAD.AND.RAD.LT.12.2 ) THEN
       P1=0.007684
       P2=0.1479
       P3=15760
       P4=13.24
      END IF
*region #6
      IF( 12.2.LT.RAD.AND.RAD.LT.13.2 ) THEN
       P1=0.007660
       P2=0.1333
       P3=17640
       P4=10.92
      END IF
*region #7
      IF( 13.2.LT.RAD.AND.RAD.LT.14.2 ) THEN
       P1=0.007660
       P2=0.1333
       P3=17640
       P4=10.92
      END IF
*
      END IF
*******************************************************************
*         Calculate spr here!
*******************************************************************
*p(x)dx=f(smdeltaPhi)d(smdeltaPhi), where x=ratio,
*                                         f()=n:normalization factor
*Define normalization factor n for RHS
*                              and LHS:
*       n= (32/Pi)[Q(1)-Q(0)]      RHS
*       n=-(32/Pi)[Q(1)-Q(0)]      LHS
*                             where
*                               Q(x)=integration of p(x)
*                               Q(1)-Q(0)=(1/2)
*                               in the ideal case, i.e. only when
*                               'perfect fitting' is made.
*       Q(0)=0 when Q(x)=linear combination of arctan(x). In case of
*       an extra parameter, i.e. x+p5, instead of x, Q(0) will not
*       equal to 0.
*
*Define m=1/n
********************************************************************

        M=(PI/32.0)/( P1*P2*ATAN( 1.0/P2 )+
     +              (1./P3)*SQRT(P3/P4)*ATAN(SQRT(P3/P4)*
     +               1.0)  )
        IF(IEND.EQ.2) THEN
          M=-M
        END IF
*
      RPHCOR=M*( P1*P2*ATAN( RATIO/P2 )+
     +          (1./P3)*SQRT(P3/P4)*ATAN(SQRT(P3/P4)*
     +           RATIO)  ) +PHI0


*
* This should never happen
*
      IF(RPHCOR.LT.0.) THEN
*        PRINT *,'RPHCOR PHIIN RAD IEND P1 P2 P3 P4'
*        PRINT *,RPHCOR,PHIIN,RAD,IEND,P1,P2,P3,P4
        RPHCOR=PHIIN
      END IF
      IF(RPHCOR.GT.2.*PI) THEN
*        PRINT *,'RPHCOR PHIIN RAD IEND P1 P2 P3 P4'
*        PRINT *,RPHCOR,PHIIN,RAD,IEND,P1,P2,P3,P4
        RPHCOR=PHIIN
      END IF
*
      RETURN
      END
+DECK,RSPTRG.
      SUBROUTINE RSPTRG(SPTRIG,VMUON)
*.
*...RSPTRG   Flag special single photon triggers which have been
*.           validated by filter EB raw energy criterion (bit 2)
*.           and survive the cosmic/beam halo muon veto of RGAM
*. CALLS   : TRBTST REPORT
*. CALLED  : ROEVTY
*.
*. AUTHOR  : G.W.Wilson
*. VERSION : 1.04
*. CREATED : 16-Aug-90
*. LAST MOD: 22-Apr-97
*.
*. Modification Log
*. 22-Apr-97  M.Schroder    Remove extraneous parentheses
*.  9-May-95  G. Wilson     skip if exp>=7 and IRDRUN.LE.1916
*. 31-Mar-93  C.Hawkes      Use TRBTST to decode trigger words
*. 27-Aug-91  S.Weisz       Use RBITFUNC sequence
*. 14-Apr-91  G.W.Wilson    Add RGAM muon veto and remove TPTO2 veto
*. 25-Oct-90  G.W.Wilson    Only apply to runs after trigger was enabled
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,RCREP.
+SEQ,TRMAPS.
+SEQ,RBITFUNC.
      LOGICAL  SPTRIG,VMUON
      INTEGER  TRBTST,ISTOFM,ISJ1H
      EXTERNAL TRBTST
*
      SPTRIG =.FALSE.
* TOFMUL trigger signal no longer functions for
* bunch-train running and is undefined
* => skip if expt >= 7 to avoid errors.
      IF(MOD(IRDEXP,1000).GE.7) GOTO 999
* Selection is pointless for data before P17.
      IF(IRDEXP.LT.1000.AND.IRDRUN.LE.1916)GOTO 999
*
* Look at TOFMUL trigger
      ISTOFM=TRBTST(IUHEAD(IITRWD),IBTOFM)
      IF(ISTOFM.EQ.-1)THEN
        CHREP='TOFMUL trigger bit undefined. Has TRCALR been called?'
        CALL REPORT('RSPTRG',1,'E')
      ENDIF
* Look at J1H trigger
      ISJ1H =TRBTST(IUHEAD(IITRWD),IBJ1H )
      IF(ISJ1H .EQ.-1)THEN
        CHREP='J1H trigger bit undefined. Has TRCALR been called?'
        CALL REPORT('RSPTRG',2,'E')
      ENDIF
*
* Demand filter bit 2 (> 200 MeV EB raw energy) and
* TOFMUL.(~J1H)
* Veto events which set the RGAM muon veto
*
      IF(  (BTEST(IUHEAD(IIFITY),2-1)) .AND.
     +     (ISTOFM.EQ.1) .AND. (ISJ1H.EQ.0) .AND.
     +     (.NOT.VMUON)   )        SPTRIG=.TRUE.
*
 999  CONTINUE
      END
+DECK,RTRGFD.
      SUBROUTINE RTRGFD(FDTRIG)
**********************************************************************
*.
*..RTRGFD       Validates forward detector triggered events for Phys1:
*.                   FDTRIG=.TRUE.  for validated FD triggers
*.
*.       Validation conditions (based on info from D.Kellogg)
*.
*.       Following triggers (so-far) passed without validation:
*.       the FDSUM trigger
*.       the FDSEG trigger
*.       (following only for 1992 data onwards)
*.       the FDSEGA accidental trigger
*.       the FDSPEC special calibration trig
*.       left.AND.right gamma catcher high energy triggers
*.       FD-SW combined trigs  (RCALLO.AND.SWSEGL.OR.LCALLO.AND.SWSEGR)
*.
*.       Also, events triggered exclusively by
*.       the FDHIOR trigger
*.       must have an FK cluster of energy greater than 35 GeV
*.
*.       Also, now allow all events with the following trigger bits:
*.         SWSEG
*.         SWSEGA
*.         SWSUM
*.         SWHIOR
*.
*.  SEQUENCES :  CRO ROPAR RCREP ODPAR ODSFUN TRMAPS RBITFUNC
*.  CALLS     :  ODFUNS TRBTST ROFDCL REPORT
*.  CALLED    :  ROEVTY
*.
*.  AUTHORS   :  C.M.Hawkes
*.  VERSION   :  1.06
*.  CREATED   :  08-Apr-91
*.  LAST MOD  :  28-Oct-97
*.
*.  Modification Log.
*. 28-Oct-97  D.Strom        Require ISSWH and ISSSUM
*. 28-Oct-97  M.Schroder     raise EHICUT (now depends on EBEAM),
*.                           make SW-validation code accessible (ELSEIF -> IF),
*.                           don't call rofdcl, use EXP nummer instead of dates
*. 18-Aug-93  C.Darling      Add selection based on FK and SW energy cuts
*. 12-Aug-93  C.Darling      Add SWSEG, SWSEGA, SWSUM and SWHIOR
*. 05-Aug-93  C.Hawkes       Add FD-SW combined triggers (for D.Kellogg)
*. 28-Apr-93  M.Lehto        Include 1992 and beyond Gamma Catcher.
*. 31-Mar-93  C.Hawkes       Use TRBTST to decode trigger words
*. 24-Nov-92  C.Hawkes       Remove FDSEGA, FDSPEC and gamma catcher
*.                           triggers for pre-1992 data
*. 27-Aug-91  S.Weisz        Use RBITFUNC sequence
*. 14-May-91  C.Hawkes       Clean up and correct trigger definitions
*.
************************************************************************
+SEQ,DECLARE.
*
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,RCREP.
+SEQ,ODPAR.
+SEQ,TRMAPS.
+SEQ,RBITFUNC.
*
      LOGICAL  FDTRIG
      INTEGER  TRBTST,IFDET,ISFSUM,ISFSEG,ISFSGA,ISFSPC,ISFDH
      INTEGER  ISFGCR,ISFGCL,ISRCAL,ISLCAL,ISSSGL,ISSSGR
      INTEGER  ISSSEG,ISSSGA,ISSSUM,ISSWH
      EXTERNAL TRBTST
*
*--   set cuts for FD trigger validation
*
      REAL EHICUT
*
*     Total energy cut for FDHIOR triggers (GeV)
C
C
C mhs this should became a function of EBEAM ! [IUHEAD(IIEBEA)]
C    [ 0.8*EBEAM seems to be a reasonable number ]
C
C      PARAMETER  ( EHICUT = 35.0 )
*
* Bit masks for the subdetectors of the FD
      INTEGER MSKFE,MSKFL,MSKFT,MSKFB,MSKFK,MSKFF
      PARAMETER (MSKFE=1,MSKFL=2,MSKFT=4,MSKFB=8,MSKFK=16,MSKFF=32)
*
*-- Send event to FYZT stream because of FD energy cluster analysis (ROFDCL)
      LOGICAL  SFYZT
*
+SEQ,ODSFUN.
*
*--   reset return flag
*
      EHICUT = 0.8*IUHEAD(IIEBEA)
      FDTRIG= .FALSE.
*
* Look at FDSUM trigger
      ISFSUM=TRBTST(IUHEAD(IITRWD),IBFSUM)
      IF(ISFSUM.EQ.-1)THEN
        CHREP='FDSUM trigger bit undefined. Has TRCALR been called?'
        CALL REPORT('RTRGFD',1,'E')
      ENDIF
* Look at FDSEG trigger
      ISFSEG=TRBTST(IUHEAD(IITRWD),IBFSEG)
      IF(ISFSEG.EQ.-1)THEN
        CHREP='FDSEG trigger bit undefined. Has TRCALR been called?'
        CALL REPORT('RTRGFD',2,'E')
      ENDIF
* These triggers passed without further validation
      IF(ISFSUM.EQ.1.OR.ISFSEG.EQ.1)THEN
        FDTRIG=.TRUE.
*
* following only for 1992 data onwards
C      ELSEIF(IUHEAD(IIDATE).GE.920000)THEN
      ELSEIF(MOD(IUHEAD(IIEXPT),1000).GE.3)THEN
*   Look at FDSEGA trigger
        ISFSGA=TRBTST(IUHEAD(IITRWD),IBFSGA)
        IF(ISFSGA.EQ.-1)THEN
          CHREP='FDSEGA trigger bit undefined. Has TRCALR been called?'
          CALL REPORT('RTRGFD',3,'E')
        ENDIF
*   Look at FDSPEC trigger
        ISFSPC=TRBTST(IUHEAD(IITRWD),IBFSPC)
        IF(ISFSPC.EQ.-1)THEN
          CHREP='FDSPEC trigger bit undefined. Has TRCALR been called?'
          CALL REPORT('RTRGFD',4,'E')
        ENDIF
        IF(ISFSGA.EQ.1.OR.ISFSPC.EQ.1)THEN
          FDTRIG=.TRUE.
        ELSE
* Look at FDGCLT and FDGCRT
          ISFGCR=TRBTST(IUHEAD(IITRWD),IBGCRT)
          IF(ISFGCR.EQ.-1)THEN
            CHREP='FDGCRT trigger bit undefined.'
            CALL REPORT('RTRGFD',6,'E')
          ENDIF
          ISFGCL=TRBTST(IUHEAD(IITRWD),IBGCLT)
          IF(ISFGCL.EQ.-1)THEN
            CHREP='FDGCLT trigger bit undefined.'
            CALL REPORT('RTRGFD',7,'E')
          ENDIF
          IF(ISFGCL.EQ.1.AND.ISFGCR.EQ.1)THEN
            FDTRIG=.TRUE.
          ELSE
* Look at FD-SW combined triggers
            ISRCAL=TRBTST(IUHEAD(IITRWD),IBRCAL)
            ISLCAL=TRBTST(IUHEAD(IITRWD),IBLCAL)
            ISSSGL=TRBTST(IUHEAD(IITRWD),IBSSGL)
            ISSSGR=TRBTST(IUHEAD(IITRWD),IBSSGR)
            IF(    (ISRCAL.EQ.1.AND.ISSSGL.EQ.1)
     +         .OR.(ISLCAL.EQ.1.AND.ISSSGR.EQ.1) )THEN
              FDTRIG=.TRUE.
            ENDIF
          ENDIF
        ENDIF
      ENDIF
* following only for 1993 data onwards
C      IF(IUHEAD(IIDATE).GE.930000)THEN
      IF(MOD(IUHEAD(IIEXPT),1000).GE.4)THEN
* Look at SWSEG trigger
        ISSSEG=TRBTST(IUHEAD(IITRWD),IBSSEG)
        IF(ISSSEG.EQ.-1)THEN
          CHREP='SWSEG trigger bit undefined. Has TRCALR been called?'
          CALL REPORT('RTRGFD',8,'E')
        ENDIF
*   Look at SWSEGA trigger
        ISSSGA=TRBTST(IUHEAD(IITRWD),IBSSGA)
        IF(ISSSGA.EQ.-1)THEN
          CHREP='SWSEGA trigger bit undefined. Has TRCALR been called?'
          CALL REPORT('RTRGFD',9,'E')
        ENDIF
* Look at SWSUM trigger
        ISSSUM=TRBTST(IUHEAD(IITRWD),IBSSUM)
        IF(ISSSUM.EQ.-1)THEN
          CHREP='SWSUM trigger bit undefined. Has TRCALR been called?'
          CALL REPORT('RTRGFD',10,'E')
        ENDIF
C        IF(ISSSEG.EQ.1.OR.ISSSGA.EQ.1.OR.ISSSUM.EQ.1)FDTRIG=.TRUE.
        IF(ISSSEG.EQ.1.OR.ISSSGA.EQ.1)FDTRIG=.TRUE.
        IF(.NOT.FDTRIG)THEN
*  Look at SWHIOR trigger
          ISSWH=TRBTST(IUHEAD(IITRWD),IBSWH)
          IF(ISSWH.EQ.-1)THEN
            CHREP=
     +      'SWHIOR trigger bit undefined. Has TRCALR been called?'
            CALL REPORT('RTRGFD',11,'E')
*  Require low threashold on both sides PLUS high threshold on one side
*  (as is done in trigger)
          ELSEIF(ISSSUM.EQ.1.AND.ISSWH.EQ.1)THEN
            FDTRIG = .TRUE.
          ENDIF
        ENDIF
      ENDIF
*
      IF(.NOT.FDTRIG)THEN
*  Look at FDHIOR trigger
        ISFDH=TRBTST(IUHEAD(IITRWD),IBFDH)
        IF(ISFDH.EQ.-1)THEN
          CHREP='FDHIOR trigger bit undefined. Has TRCALR been called?'
          CALL REPORT('RTRGFD',5,'E')
*   FDHIOR trigger. Cut on highest energy cluster in calorimeter
        ELSEIF(ISFDH.EQ.1)THEN
*    Set up pointers for OD statement functions
          CALL ODFUNS
*    Loop over all forward detector clusters
          CALL ODNBLK('FDET',NFDET)
          DO 100 IFDET=1,NFDET
*    Distinguish calorimeter and gamma catcher
            IF(IAND(IF(JFSOUR,IFDET),MSKFK).NE.0)THEN
*    Require at least one calorimeter cluster with energy > EHICUT
              IF(RF(JFE,IFDET).GE.EHICUT)THEN
                FDTRIG=.TRUE.
                GOTO 101
              ENDIF
            ENDIF
  100     CONTINUE
  101     CONTINUE
        ENDIF
      ENDIF
*
*-- Check some FK and SW energy quantities
C
C     This is crap. non-FD/SW triggers have not to be 'validated' and
C     should not go to the FYZ1/FYZT stream !
C
C      IF(.NOT.FDTRIG)THEN
C        CALL ROFDCL(SFYZT)
C        IF(SFYZT)FDTRIG = .TRUE.
C      ENDIF
*
      RETURN
      END
+DECK,RTWOPH.
      SUBROUTINE RTWOPH( TWOPHO )
**********************************************************************
*.
*..RTWOPH  returns the tagged two-photon preselection event flag :
*.  TWOPHO = .TRUE.   if the event satisfies the preselection cuts.
*.
*.  SEQUENCES :  CRO ROPAR ODPAR RBITFUNC
*.  CALLS     :
*.  CALLED    :  ROEVTY
*.
*.  AUTHOR    :  Terry Wyatt and Mark Lehto
*.  VERSION   :  2.00
*.  CREATED   :  13-Jun-90
*.  LAST MOD  :  28-Oct-97
*.
*.  Modification Log.
*.
*.  28-Oct-97 R.Nisius     Make minimum energy beam energy dependent.
*.                         Remove bug in number of hits for track selection
*.                         and change to a loose cj only cut.
*.                         Change to looser track critera (as MT)
*.                         Require MINTOT tracks also for ECAL
*.                         Make code more efficient, exit as soon as
*.                         TWOPHO .eq. .TRUE.
*.   4-Jul-94 B.W.Kennedy  Debugged SiW selection.
*.  24-May-94 J.J.Ward     Loop over SiW clusters as well as FD clusters.
*.                         Make cluster energy threshold 10 GeV for
*.                         both FD tags and SiW tags.
*.  28-May-92 M.Lehto      Remove trigger dependance from selection
*.  27-Aug-91 S.Weisz      Use RBITFUNC sequence
*.  23-Apr-91 T.R.Wyatt    Fix IECA bug. Remove redundant loop over tracks.
*.                         Demand at least two blocks for EE clusters.
*.  21-Mar-91 M.Lehto      Put in specific Endcap tag selection.
*.
**********************************************************************
+SEQ,DECLARE.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ODPAR.
+SEQ,RBITFUNC.
*
      LOGICAL TWOPHO
*
      INTEGER NIM,NRM,IT,NCTRKK,NTOT
      INTEGER NECBLK,NETOT
      INTEGER IJ,NFDBLK
      INTEGER IK,NSWBLK
      INTEGER IECA(NIECAL)
      REAL    RECA(NRECAL)
      REAL    PTT
      INTEGER ICTR(NICTRK)
      REAL    RCTR(NRCTRK)
      INTEGER IFDE(NIFDET)
      REAL    RFDE(NRFDET)
      INTEGER ISIW(NISIW)
      REAL    RSIW(NRSIW)
CR---
      INTEGER IGNR(NIGNRL)
      REAL    RGNR(NRGNRL)
CR---
*
*-- Quality cuts for tracks/clusters
      INTEGER NHMIN,MINTOT,MINBLK
      SAVE    NHMIN,MINTOT,MINBLK
      REAL    D0MAX,Z0MAX,R1MAX,PTMIN,MINEGY,FRMAX
      SAVE    D0MAX,Z0MAX,R1MAX,PTMIN,MINEGY,FRMAX
CR---
      REAL    EFRAC
      SAVE    EFRAC
CR---
      DATA  NHMIN, D0MAX, Z0MAX, R1MAX, PTMIN, MINEGY, MINBLK, FRMAX
CR   +  /      30,    2.,   50.,   75.,    .1,    10.,      2,   .99/
     +  /      20,   2.5,   50.,   75.,    .1,    10.,      2,   .99/
*-- Cuts on the minimum number of tracks
      DATA  MINTOT
     +  /       2                                    /
CR---
      DATA  EFRAC
     +  /    0.35 /
CR---
*
CR---
+SELF,IF=DRTWOPH.
      INTEGER IDURCH
      DATA IDURCH /0/
+SELF.
CR---

      TWOPHO = .FALSE.

CR---SET MINIMUM ENERGY AS FRACTION OF THE BEAM ENERGY
      CALL ODFBLK('GNRL',0,NIGNRL,IGNR,NIM,NRGNRL,RGNR,NRM)
      MINEGY = EFRAC * RGNR(JGEBEA)
+SELF,IF=DRTWOPH.
      IDURCH = IDURCH + 1
      IF(IDURCH .LE. 30)
     +WRITE(6,*)'RTWOPH Energy',MINEGY,EFRAC,RGNR(JGEBEA)
+SELF.
CR---END
*
*-- Loop over the charged tracks in OD blocks.
*-- Count the number of good quality tracks (NTOT).
*
      NTOT  = 0
*
      CALL ODNBLK('CTRK',NCTRKK)
      DO 10 IT=1,NCTRKK
        CALL ODFBLK('CTRK',IT,NICTRK,ICTR,NIM,NRCTRK,RCTR,NRM)
        IF( NIM.LE.0 .OR. NRM.LE.0 ) GO TO 10
*
        PTT = SQRT(RCTR(JCPX)**2+RCTR(JCPY)**2)
*
*  apply the track quality cuts
*
CR---REMOVE WRONGLY CODED NUMBER OF CV HITS USE CJ ONLY
CR---AS OTHER GOOD TRACK SELECTIONS DO THIS AS WELL
CR      IF( (ICTR(JCNHCJ)+ICTR(JCNHCV)).LT.NHMIN )      GOTO 10
        IF(  ICTR(JCNHCJ).LT.NHMIN )                    GOTO 10
+SELF,IF=DRTWOPH.
      IF( (ICTR(JCNHCJ)+ICTR(JCNHCV)).GT.NHMIN .AND.
     +     ICTR(JCNHCJ).LE.NHMIN)
     +     WRITE(6,*)'RTWOPH HITS',ICTR(JCNHCJ),ICTR(JCNHCV)
+SELF.
CR---END
        IF( ABS(RCTR(JCD0)) .GT. D0MAX )                GOTO 10
        IF( ABS(RCTR(JCZ0)) .GT. Z0MAX )                GOTO 10
        IF( RCTR(JCR1) .GT. R1MAX )                     GOTO 10
        IF( PTT .LT. PTMIN )                            GOTO 10
*
        NTOT = NTOT + 1
*
 10   CONTINUE
*-- End of loop over tracks.

*
*-- If less than mintot tracks were found then this event is of no interest
*
+SELF,IF=DRTWOPH.
      WRITE(6,*)'EXIT',NTOT
+SELF.
      IF( NTOT .LT. MINTOT) GO TO 999
*
*-- There are three ways for an event to be preselected
*

*
*-- Loop over FD clusters to see if any are over MINEGY
*
      CALL ODNBLK('FDET',NFDBLK)
      DO 15 IJ=1,NFDBLK
+SELF,IF=DRTWOPH.
         CALL ODPBLK('FDET',IJ)
+SELF.
         CALL ODFBLK('FDET',IJ,NIFDET,IFDE,NIM,NRFDET,RFDE,NRM)
         IF (RFDE(JFE) .LT. MINEGY)GOTO 15
         IF (NTOT.GE.MINTOT)THEN
            TWOPHO = .TRUE.
            GOTO 999
         ENDIF
 15   CONTINUE
*
*-- Loop over SiW clusters to see if any are over MINEGY
*
      CALL ODNBLK('SIW ',NSWBLK)
      DO 25 IK=1,NSWBLK
+SELF,IF=DRTWOPH.
         CALL ODPBLK('SIW ',IK)
+SELF.
         CALL ODFBLK('SIW ',IK,NISIW,ISIW,NIM,NRSIW,RSIW,NRM)
         IF (RSIW(JSE).LT.MINEGY)GOTO 25
         IF (NTOT.GE.MINTOT)THEN
            TWOPHO = .TRUE.
            GOTO 999
         ENDIF
 25   CONTINUE
*
*-- The third is a specific endcap tag selection
*
*-- Loop over clusters to see if any are over MINEGY
*
        NETOT = 0
*
        CALL ODNBLK('ECAL',NECBLK)
        DO 20 IT=1,NECBLK
+SELF,IF=DRTWOPH.
          CALL ODPBLK('ECAL',IT)
+SELF.
          CALL ODFBLK('ECAL',IT,NIECAL,IECA,NIM,NRECAL,RECA,NRM)
          IF ( IECA(JESOUR) .EQ. MSKEB )                 GOTO 20
          IF ( RECA(JEERAW) .LT. MINEGY)                 GOTO 20
          IF ( IECA(JENBLO) .LT. MINBLK)                 GOTO 20
          IF ( RECA(JEFRMX) .GT. FRMAX )                 GOTO 20
          NETOT = NETOT + 1
 20     CONTINUE
*
*-- If there is at least one cluster and at least one charged track then
*-- accept the event
*
        IF (NETOT.GE.1 .AND. NTOT.GE.MINTOT) TWOPHO = .TRUE.
+SELF,IF=DRTWOPH.
        WRITE(6,*)'EE',NTOT
+SELF.
*
  999 RETURN
*
      END
+DECK,RSWPRE.
      SUBROUTINE RSWPRE (LSWKP )
*.
*...RBABSW   Return a flag if this event passes the SW preselection
*.
*. OUTPUT    : LSWKP   true if event passes SW phys1 selection
*.
*. CALLS     : none
*. CALLED    : RBABSW
*.
*. Note this routine requires that RSW common be filled !
*. This routine performs a selection similar to the trigger
*. selection and exists primarly to keep the triggered events
*. in the case trigger readout malfunctions or if the trigger
*. information is corrupted.
*.
*. AUTHOR    : D.Strom
*. VERSION   : 1.00
*. CREATED   : 28-Oct-97
*. LAST MOD  :  7-May-99
*.
*. Modification Log.
*.  7-May-99 M.Schroder Fix edit descriptor (for linux)
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,ROSWVA.
+SEQ,ROSWMG.
+SEQ,CRO.
*
      LOGICAL LSWKP
*
*
*
      LSWKP = .FALSE.
*
*     keep the event if merged energy is okay
*
      IF( (EFMGR+EFMGL).GT. 1.0  ) LSWKP = .TRUE.
      IF(  EFMGR       .GT. 0.3  .AND.
     +     EFMGL       .GT. 0.3       ) THEN
        IF(  EFMGR       .GT. 0.7  ) LSWKP = .TRUE.
        IF(  EFMGL       .GT. 0.7  ) LSWKP = .TRUE.
      END IF
*
*     check same for total energy sum
*
*       ESUMx     sum of energy(GeV) in right/left calorimeter
*
      IF( (ESUMR+ESUML).GT.EBEAM     ) LSWKP = .TRUE.
      IF(  ESUMR       .GT.EBEAM*0.3  .AND.
     +     ESUML       .GT.EBEAM*0.3        ) THEN
        IF(  ESUMR       .GT.EBEAM*0.7  ) LSWKP = .TRUE.
        IF(  ESUML       .GT.EBEAM*0.7  ) LSWKP = .TRUE.
      END IF
*
*     check same for total energy sum
*
*       ESUMx     sum of energy(GeV) in right/left calorimeter
*
      IF( (ESUMR+ESUML).GT.EBEAM     ) LSWKP = .TRUE.
      IF(  ESUMR       .GT.EBEAM*0.3  .AND.
     +     ESUML       .GT.EBEAM*0.3        ) THEN
        IF(  ESUMR       .GT.EBEAM*0.7  ) LSWKP = .TRUE.
        IF(  ESUML       .GT.EBEAM*0.7  ) LSWKP = .TRUE.
      END IF
*
*     now for trigger energy

*       EMXx      energy(GeV) of the trigger cluster from the
*                 current beam crossing, Right/Left.
*
      IF( (EMXR + EMXL).GT.EBEAM      ) LSWKP = .TRUE.
      IF(  EMXR        .GT.EBEAM*0.3     .AND.
     +     EMXL        .GT.EBEAM*0.3          ) THEN
        IF(  EMXR        .GT.EBEAM*0.7  ) LSWKP = .TRUE.
        IF(  EMXL        .GT.EBEAM*0.7  ) LSWKP = .TRUE.
      END IF
*
*       EMXAx     energy(GeV) from the trigger cluster from one
*                 LEP revolution ago, Right/Left
*
      IF( (EMXR + EMXAL).GT.EBEAM      ) LSWKP = .TRUE.
*
      IF(  EMXR         .GT.EBEAM*0.3     .AND.
     +     EMXL         .GT.EBEAM*0.3           ) THEN
        IF( EMXR        .GT. EBEAM*0.7  ) LSWKP = .TRUE.
        IF( EMXAL       .GT. EBEAM*0.7  ) LSWKP = .TRUE.
      END IF
*
      IF( (EMXAR + EMXL).GT.EBEAM     ) LSWKP = .TRUE.
*
      IF(  EMXAR        .GT.EBEAM*0.3         .AND.
     +     EMXL         .GT.EBEAM*0.3              ) THEN
        IF( EMXAR       .GT.EBEAM*0.7   ) LSWKP = .TRUE.
        IF( EMXL        .GT.EBEAM*0.7   ) LSWKP = .TRUE.
      END IF
*
      IF( LSWITA.OR.LSWITR.OR.LSWITA ) THEN
        IF(.NOT.LSWKP ) THEN
          WRITE(CHREP,1001)IRUN,IEVT
1001      FORMAT('Event in final sample, but not selected:',2I8)
          CALL REPORT('RSWPRE',1,'E')
          LSWKP = .TRUE.
        END IF
      END IF
*
      IF(LSWKP) THEN
        WRITE(CHREP,1002)
1002    FORMAT('Event marked for phyzt')
        CALL REPORT('RSWPRE',2,'I')
      END IF
*
      RETURN
      END
+DECK,RTRIGS.
      SUBROUTINE RTRIGS(TRGSEL)
**********************************************************************
*.
*..RTRIGS  Makes selection of triggers for Phys1.
*.         TRGSEL=.TRUE.  for selected triggers
*.
*.       Following triggers passed without validation:
*.       the stand-alone random trigger, BXRSA
*.
*.      (FD (RTRGFD) and special single photon (RSPTRG) triggers,
*.       are also selected after validation, in separate routines.)
*.
*.  SEQUENCES :  CRO ROBANK ROCPAR ROPAR RCREP TRLINK TRMAPS
*.  CALLS     :  TRBTST TRIPUS REPORT
*.  CALLED    :  ROEVTY
*.
*.  AUTHORS   :  C.M.Hawkes
*.  VERSION   :  1.03
*.  CREATED   :  24-Apr-91
*.  LAST MOD  :   3-Jun-94
*.
*.  Modification Log.
*.  3-June-94 D.Charlton Keep BXRTST triggers if standalone
*.  31-Mar-93 C.Hawkes  Use TRBTST to decode trigger words (need OPCAL)
*.  24-Nov-92 C.Hawkes  Select only STAND-ALONE random triggers, BXRSA
*.  27-Aug-91 S.Weisz   Use RBITFUNC sequence
*.  11-May-91 C.Hawkes  Remove monopole trigger
*.
**********************************************************************
+SEQ,DECLARE.
*
+SEQ,CRO.
+SEQ,RBITFUNC.
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,ROPAR.
+SEQ,RCREP.
+SEQ,TRLINK.
+SEQ,TRMAPS.
*
      LOGICAL  TRGSEL
      INTEGER  TRBTST,ISBXRS,ISBXRT
      EXTERNAL TRBTST
      INTEGER  IW,IB,USEBIT(4),STOBIT(4)
*
* Look at BXRSA trigger
      ISBXRS=TRBTST(IUHEAD(IITRWD),IBBXRS)
      IF(ISBXRS.EQ.-1)THEN
        CHREP='BXRSA trigger bit undefined. Has TRCALR been called?'
        CALL REPORT('RTRIGS',1,'E')
      ENDIF
*
* These triggers passed without further validation
      TRGSEL=ISBXRS.EQ.1
*
* Look at BXRTST trigger
      IF (.NOT.TRGSEL) THEN
        ISBXRT = TRBTST(IUHEAD(IITRWD),IBBXRT)
        IF (ISBXRT.EQ.1) THEN
          LTRDF = 0
          IF (LDAC.GT.0) THEN
            LTRCT = LQ(LDAC-LLTRCT)
            IF (LTRCT.GT.0) LTRDF = LQ(LTRCT-LLTRDF)
          ENDIF
          IF (LTRDF.GT.0) THEN
            IW=(IBBXRT-1)/32
            IB=MOD(IBBXRT-1,32)
            CALL TRIPUS(IQ(LTRDF+1),USEBIT,STOBIT)
            TRGSEL = BTEST(STOBIT(IW+1),IB)
          ELSE
            CHREP = 'No TRDF bank available; can''t check BXRTST status'
            CALL REPORT('RTRIGS',1,'W')
          ENDIF
        ENDIF
      ENDIF
*
      RETURN
      END
+DECK,RTETRG.
      SUBROUTINE RTETRG(TETRIG)
*.
*...RTETRG    Flag scaled-down MEL.MER triggers
*.            for a TE calibration study
*
*...CALLS   : TRBTST, REPORT
*
*.  AUTHOR    : Stan Bentvelsen
*.  CREATED   : 28-Jul-94
*.  LAST MOD  :  2-May-96
*.
*.  Modification Log.
*.
*.  2-May-96  M.Schroder scale by IRDEVT instead of internal counter
*.  1-Aug-94  O.Schaile  Change SCALED from 10 to 4
*.
*.*****************************************************************
+SEQ, DECLARE.
+SEQ, ROBANK.
+SEQ, RCNTRL.
+SEQ, CRO.
+SEQ, ROPAR.
+SEQ, RCREP.
+SEQ, TRMAPS.
+SEQ, RBITFUNC.
      LOGICAL  TETRIG
      INTEGER  TRBTST
      EXTERNAL TRBTST
      INTEGER  ISMEL , ISMER
      INTEGER  SCALED
      SAVE     SCALED
      DATA     SCALED  / 4 /
*
      TETRIG =.FALSE.
*
*..   Look at MEL trigger
      ISMEL=TRBTST(IUHEAD(IITRWD),IBMEL)
      IF(ISMEL.EQ.-1)THEN
        CHREP='MEL trigger bit undefined. Has TRCALR been called?'
        CALL REPORT('RTETRG',1,'E')
      ENDIF

*..   Look at MER trigger
      ISMER=TRBTST(IUHEAD(IITRWD),IBMER)
      IF(ISMER.EQ.-1)THEN
        CHREP='MER trigger bit undefined. Has TRCALR been called?'
        CALL REPORT('RTETRG',2,'E')
      ENDIF
*
*..   Demand coincidence MEL.MER
*
      IF (  ( ISMER  .EQ. 1)  .AND.
     +      ( ISMEL  .EQ. 1)       )    THEN
*
*..   Scale-down triggers
         IF ( MOD(IRDEVT,SCALED).EQ.0 ) TETRIG = .TRUE.
      ENDIF

 999  CONTINUE
      END
+DECK,ROFUGG
      LOGICAL FUNCTION ROFUGG()
*.
*...ROFUGG  This is a logical function which is .TRUE. if
*.          the event satisfies loose requirements for
*.          selecting exclusive untagged gamma gamma events.
*.          The OR of this function and ROGGSE define the
*.          event type bit IEUGGE
*.
*.  SEQUENCES :  DECLARE,ODPAR,ODSFUN,CRO,ROPAR,RBITFUNC
*.  CALLS     :  ODFUNS
*.  CALLED    :
*.
*.  AUTHOR    :  P.Bock, J.Lillich, J.Patt, S.Soeldner-Rembold 
*.  VERSION   :  1.0
*.  CREATED   :  27-Mar-98
*.  LAST MOD  :  17-Apr-98
*.
*.  Modification Log.
*.
*. 17-Apr-98 M.Schroder   Make ansi-compliant, rename
*.*********************************************************************
+SEQ,DECLARE.
+SEQ,ODPAR.
+SEQ,CRO.
+SEQ,RBITFUNC.

      INTEGER  KIND, NBLO, NCHG, I, KHIT, NEB, NEE
      INTEGER  LEVEL, NNECAL, NDEDXM, NDEDX
      INTEGER  NKAON, NPROT, NELEK, NAPROT
      REAL     KAONWT, PROTWT, ELEKWT, PIONWT, MUONWT
      REAL     PTMIN, PTMAX2
      REAL     ECALSU, QSUM
      REAL     PT, PX, PY
      REAL     Z0MAX, R1MAX
      REAL     ZUNC, ERAW
      REAL     YEEB, YEEE
      SAVE     YEEB, YEEE, NEB, NEE
      SAVE     Z0MAX, PTMIN, NDEDXM

      INTEGER  NCUT
      REAL PTSORT(10)

+SEQ,ODSFUN.
      DATA NCUT /10/
*
*     GOOD CLUSTER-SELECTION-VALUES
      DATA YEEB /0.10/, YEEE /0.20/, NEB /1/, NEE /2/
* 
*     GOOD TRACK-SELECTION-VALUES
      DATA PTMIN / .08/, Z0MAX / 50./, R1MAX/ 50./, NDEDXM / 20/
*
      ROFUGG = .FALSE.
      ECALSU  = 0.

      CALL ODFUNS
*
      IF (NGNRL.EQ.0) RETURN


*     ***DEFINITION OF GOOD CHARGED TRACKS***

      NCHG  = 0
      NKAON = 0
      NPROT = 0
      NAPROT = 0
      NELEK = 0
      QSUM  = 0. 
      DO 99 I=1, NCUT
        PTSORT(I)=0.
 99   CONTINUE
      DO 101 I=1,NCTRK
        PX=RC(JCPX,I)
        PY=RC(JCPY,I)
        PT=SQRT(PX**2+PY**2)
        KHIT=IC(JCNHCJ,I)
        NDEDX  = IC(JCNHDE,I)
        CALL ODUNCZ(I,ZUNC)
        KAONWT = ABS(RC(JCWDK,I))
        PROTWT = ABS(RC(JCWDP,I))
        ELEKWT = ABS(RC(JCWDE,I))
        PIONWT = ABS(RC(JCWDPI,I))
        MUONWT = ABS(RC(JCWDMU,I))
        
        IF ((ABS(RC(JCR1,I)).LE.R1MAX)
     +       .AND. (ABS(ZUNC).LE.Z0MAX)
     +       .AND. (NDEDX.GE.NDEDXM)
     +       .AND. (PT.GE.PTMIN)) THEN
          NCHG = NCHG + 1
          QSUM = QSUM + RC(JCQ,I)
          IF ( NCHG.LE.NCUT ) THEN
            PTSORT(NCHG)=PT
          ENDIF  
          IF (KAONWT.GT..01.AND.PIONWT.LT..01
     +         .AND.MUONWT.LT..01
     +         .AND.ELEKWT.LT..01) THEN
            NKAON = NKAON + 1
          ENDIF
          IF (PROTWT.GT..01.AND.PIONWT.LT..01   
     +         .AND.MUONWT.LT..01
     +         .AND.ELEKWT.LT..01
     +         .AND.RC(JCQ,I).EQ.1.) THEN
            NPROT = NPROT + 1
          ENDIF
          IF (PROTWT.GT..01.AND.PIONWT.LT..01
     +         .AND.MUONWT.LT..01
     +         .AND.ELEKWT.LT..01
     +         .AND.RC(JCQ,I).EQ.-1.) THEN
            NAPROT = NAPROT + 1
          ENDIF
          IF (ELEKWT.GT..01.AND.PIONWT.LT..01
     +         .AND.KAONWT.LT..01  
     +         .AND.MUONWT.LT..01) THEN
            NELEK = NELEK + 1
          ENDIF
        ENDIF
 101  CONTINUE

* SORT PT OF TRACKS IN ASCENDING ORDER

      CALL FLPSOR(PTSORT,NCUT)

* SECOND MAXIMUM TRANSVERSE MOMENTUM OF TRACKS

      PTMAX2 =  PTSORT(NCUT-1)

* CALCULATION OF THE ENERGY IN THE ECAL
 
      DO 201 I=1,NECAL
        IF((RE(JEE,I)).LE.1.E-10) GOTO 201
        KIND=IE(JESOUR,I)
        ERAW=RE(JEERAW,I)
        NBLO=IE(JENBLO,I)
        IF( (IAND(KIND,MSKEE).EQ.0.AND.ERAW.GE.YEEB.AND.NBLO.GE.NEB)
     +       .OR.
     +      (IAND(KIND,MSKEE).NE.0.AND.ERAW.GE.YEEE.AND.NBLO.GE.NEE)
     +       ) THEN
          ECALSU = ECALSU + RE(JEE,I)
        END IF
  201 CONTINUE

* ENERGY IN THE ECAL SMALLER THAN 10 GeV

      IF ( ECALSU.GT.10 ) GOTO 999

* EVENTS WITH 2 GOOD TRACKS

      IF ( NCHG.EQ.2.AND.ABS(QSUM).EQ.0..AND.
     +     (PTMAX2.GT.0.5.OR.NKAON.GT.0.OR.(NAPROT+NPROT).GT.0)) THEN
        ROFUGG = .TRUE.
      ENDIF

*    ***EVENTS WITH 3, 4 OR 5 GOOD TRACKS***

      IF ( NCHG.GT.2.AND.NCHG.LE.5
     +     .AND.ABS(QSUM).LE.1..AND.NELEK.EQ.0
     +     .AND.(NPROT.EQ.0.OR.NAPROT.GE.1) ) THEN
        ROFUGG = .TRUE.
      ENDIF

  999 RETURN
      END
+DECK,ROGGSE.
      LOGICAL FUNCTION ROGGSE()
*.
*...ROGGSE  This is a logical function which is .TRUE. if
*.          the event satisfies loose requirements for
*.          selecting exclusive untagged gamma gamma events.
*.
*.  SEQUENCES :  DECLARE,ODPAR,ODSFUN
*.  CALLS     :  VZERO,ODFUNS
*.  CALLED    :
*.
*.  AUTHOR    :  J.Letts and T.Barillari
*.  VERSION   :  1.0
*.  CREATED   :  14-Feb-96
*.  LAST MOD  :  18-Feb-98
*.
*.   I              !index for counting tracks
*.   NGOOD          !number of good tracks in event
*.   NBAD           !number of bad tracks in event
*.   NPOS           !number of good positive tracks in event
*.   NNEG           !number of good negative tracks in event
*.   NHIPT          !number of good tracks in event, pt>200 MeV
*.   SUMQAL         !sum of charges of all tracks
*.   SUMQGO         !sum of charges of good tracks
*.   SUMQBA         !sum of charges of bad tracks
*.   SUMPAL         !scalar sum of momentum of all tracks
*.   SUMPGO         !scalar sum of momentum of good tracks
*.   SUMPBA         !scalar sum of momentum of bad tracks
*.   PWGHT(10)      !proton dE/dx weight of good tracks
*.   ENECAL         !total energy in EB+EE
*.   PT             !pt of a single track
*.
*.  Modification Log.
*.  5-May-98 M.Schroder   tighten the cuts, require two high pt tracks
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,ODPAR.
      INTEGER  I
      INTEGER  NGOOD
      INTEGER  NBAD
      INTEGER  NPOS
      INTEGER  NNEG
      INTEGER  NHIPT
      INTEGER  NPROT, NAPROT
      REAL     SUMQAL
      REAL     SUMQGO
      REAL     SUMQBA
      REAL     SUMPAL
      REAL     SUMPGO
      REAL     SUMPBA
      REAL     PWGHT(10)
      REAL     ENECAL
      REAL     PT
+SEQ,ODSFUN.
*
*--initialization, set various counters to zero
*
      ROGGSE=.TRUE.
      NGOOD=0
      NBAD=0
      NPOS=0
      NNEG=0
      NPROT  = 0
      NAPROT = 0
      NHIPT=0
      SUMQAL=0.
      SUMQGO=0.
      SUMQBA=0.
      SUMPAL=0.
      SUMPGO=0.
      SUMPBA=0.
      CALL VZERO(PWGHT,10)
*
*--use statement functions
*
      CALL ODFUNS
      IF(NGNRL.LE.0)THEN
        ROGGSE=.FALSE.
        GOTO 999
      ENDIF
*
*--Event cuts: energy in ECAL < half beam energy
*  and at least 2 tracks in the event.
*
      ENECAL=RG(JGSEB)+RG(JGSEE)
      IF(ENECAL .GT. (0.5*RG(JGEBEA)) .OR.
     -   NCTRK  .LT. 2 )THEN
        ROGGSE=.FALSE.
        GOTO 999
      ENDIF
*
*--now examine the tracks in the event
*
      DO 10 I=1,NCTRK
        PT=SQRT(RC(JCPX,I)**2+RC(JCPY,I)**2)
        SUMPAL=SUMPAL+RC(JCP,I)
        SUMQAL=SUMQAL+RC(JCQ,I)
*
*--the following cuts define a "good track" for a gg event
*
        IF(PT              .LT. 0.050)GOTO 10
        IF(IC(JCNHCJ,I)    .LT.    20)GOTO 10
        IF(ABS(RC(JCD0,I)) .GT.  10.0)GOTO 10
        IF(ABS(RC(JCZ0,I)) .GT.  50.0)GOTO 10
*
*--count the number of positive, negative, and high-pt tracks
*
        NGOOD=NGOOD+1
        SUMPGO=SUMPGO+RC(JCP,I)
        SUMQGO=SUMQGO+RC(JCQ,I)
*
        IF(RC(JCQ,I).GT. 0.   )NPOS =NPOS +1
        IF(RC(JCQ,I).LT. 0.   )NNEG =NNEG +1
C check for (anti-)proton candidates
C they have "high" pt
        IF(PT       .GT. 0.200) THEN
          NHIPT=NHIPT+1
C and their proton weight should be bigger than epsilon
          IF ( ABS(RC(JCWDP,I)) .GE. 0.001 ) THEN
            IF ( RC(JCQ,I).GT. 0. ) THEN
              NPROT = NPROT + 1
            ELSE
              NAPROT = NAPROT + 1
            ENDIF
          ENDIF
        ENDIF
        IF(NGOOD.LE.10)PWGHT(NGOOD)=ABS(RC(JCWDP,I))
*
   10 CONTINUE
C we should have at least one proton and one antiproton
      IF ( NPROT.LE.0 .OR. NAPROT.LE.0 ) THEN
        ROGGSE = .FALSE.
        RETURN
      ENDIF
*
*--calculate the bad track quantities
*
      NBAD   =NCTRK-NGOOD
      SUMPBA=SUMPAL-SUMPGO
      SUMQBA=SUMQAL-SUMQGO
*
*--select the event as good if all of the following are satisfied:
*  1) there are at least two "high pt" tracks    .AND.
*  2) there is at least one good + track       .AND.
*  3) there is at least one good - track       .AND.
*  4) there are no more than 10 good tracks    .AND.
*  5) the total scalar momentum sum of the
*     good tracks is less than Ebeam/2,
*
*  and also the following requirements which help to reduce the
*  beam wall background:
*
*  6) the absolute value of the sum of the
*     charges of good tracks is less than 1    .AND.
*  7) the total scalar momentum sum of the
*     good tracks is greater than the total
*     scalar momentum sum of the bad tracks.
*
      IF(NHIPT .LT. 2 .OR.
     -   NPOS  .EQ. 0 .OR.
     -   NNEG  .EQ. 0 .OR.
     -   NGOOD .GT. 10 .OR.
     -   SUMPGO .GT. (0.5*RG(JGEBEA)) .OR.
     -   ABS(SUMQGO) .GT. 1 .OR.
     -   SUMPBA .GT. SUMPGO )THEN
        ROGGSE=.FALSE.
        GOTO 999
      ENDIF
*
*--use a dE/dx cut to get rid of gg->ee and gg->mumu events
*  since we are interested only in (hadronic) gg->p pbar events
*  This should be removed if one is interested in keeping the
*  leptonic gg events to do calibrations, for example.
*
      IF(NPOS.EQ.1.AND.NNEG.EQ.1)THEN
        IF(ABS(PWGHT(1)).LT.0.001 .OR.
     -     ABS(PWGHT(2)).LT.0.001 )THEN
          ROGGSE=.FALSE.
          GOTO 999
        ENDIF
      ENDIF
*
  999 CONTINUE
*
      END
+DECK,ROUTGG.
      LOGICAL FUNCTION ROUTGG()
*.
*...ROUTGG  This is a logical function which is .TRUE. if
*.          the event satisfies loose requirements for
*.          selecting inclusive untagged gamma gamma events.
*.
*.  SEQUENCES :  DECLARE,ODPAR,ODSFUN,CRO,ROPAR,RBITFUNC
*.  CALLS     :  ODFUNS
*.  CALLED    :
*.
*.  AUTHOR    :  J.Patt and R.Buergin
*.  VERSION   :  1.0
*.  CREATED   :  15-Feb-96
*.  LAST MOD  :  15-Feb-96
*.
*.  Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
+SEQ,ODPAR.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,RBITFUNC.

      INTEGER  KIND, NBLO, NCHG, I, KHIT, NEB, NEE
      INTEGER  NMIN
      REAL     PTMIN
      REAL     EBEAM
      REAL     ECALSU,PXETOT, PYETOT, PZETOT
      REAL     PT, PX, PY
      REAL     D0MAX, Z0MAX
      REAL     PESQ, WVIS
      REAL     ZUNC, ERAW
      REAL     YEEB, YEEE
      SAVE     YEEB, YEEE, NEB, NEE
      SAVE     D0MAX, Z0MAX, PTMIN, NMIN

+SEQ,ODSFUN.
*
*     GOOD CLUSTER-SELECTION-VALUES
      DATA YEEB /0.10/, YEEE /0.20/, NEB /1/, NEE /2/
*
*     GOOD TRACK-SELECTION-VALUES
      DATA PTMIN / .05/, D0MAX / 10./, Z0MAX / 50./, NMIN / 20/
*
      ROUTGG  = .FALSE.
      WVIS    = 0.
      ECALSU = 0.
*
      CALL ODFUNS
*
      IF (NGNRL .EQ. 0) RETURN

      EBEAM = RG(JGEBEA)
*
*     ***DEFINITION OF GOOD CHARGED TRACKS***
*
      NCHG  = 0
      DO 101 I=1,NCTRK
         PX=RC(JCPX,I)
         PY=RC(JCPY,I)
         PT=SQRT(PX**2+PY**2)
         KHIT=IC(JCNHCJ,I)
         CALL ODUNCZ(I,ZUNC)

         IF( (ABS(RC(JCD0,I)).LE.D0MAX)
     +       .AND. (ABS(ZUNC).LE.Z0MAX)
     +       .AND. (KHIT.GE.NMIN)
     +       .AND. (PT.GE.PTMIN)) THEN
            NCHG = NCHG + 1
         ENDIF
  101 CONTINUE
*
*     ***AT LEAST 3 GOOD CHARGED TRACKS***
*
      IF ( NCHG.LE.2 ) GOTO 999
*
*     ***DEFINITION OF GOOD ECAL-CLUSTERS***
*
      PXETOT  = 0.
      PYETOT  = 0.
      PZETOT  = 0.
      DO 201 I=1,NECAL
         IF((RE(JEE,I)).LE.1.E-10) GOTO 201
         KIND=IE(JESOUR,I)
         ERAW=RE(JEERAW,I)
         NBLO=IE(JENBLO,I)
         IF( (IAND(KIND,MSKEE).EQ.0.AND.
     +        ERAW.GE.YEEB.AND.NBLO.GE.NEB)
     +        .OR.
     +        (IAND(KIND,MSKEE).NE.0.AND.
     +        ERAW.GE.YEEE.AND.NBLO.GE.NEE)
     +        ) THEN
            ECALSU = ECALSU + RE(JEE,I)
            PXETOT=PXETOT + RE(JEE,I)*SIN(RE(JETHET,I))*COS(RE(JEPHI,I))
            PYETOT=PYETOT + RE(JEE,I)*SIN(RE(JETHET,I))*SIN(RE(JEPHI,I))
            PZETOT=PZETOT + RE(JEE,I)*COS(RE(JETHET,I))
         END IF
  201 CONTINUE
      PESQ = PXETOT**2 + PYETOT**2 + PZETOT**2
      WVIS = ECALSU**2 - PESQ
      IF (WVIS .GT. 0.) THEN
         WVIS = SQRT(WVIS)
      ENDIF
*
*     ***ENERGY IN ECAL < HALF OF BEAM-ENERGY***
*
      IF ( ECALSU.GT.(EBEAM/2)) GOTO 999
*
*     *** WVIS > 2 GeV ***
*
      IF ( WVIS.GT.2 ) THEN

         ROUTGG = .TRUE.

      ENDIF
*
  999 RETURN
      END
+PATCH,ROKUIP.
+DECK,RCNTLI.
      SUBROUTINE RCNTLI
*.
*...RCNTLI  Interactive ROPE control routine
*.
*. SEQUENCE: CRO RCNTRL RCREP RCLINE CRVER QFTITLE
*. COMMON  : PAWC
*. CALLS   : QNEXTE ROPPAK ROPINI ROPSET ROPIKU ROPFIN KUINIT FFGO
*.           TIMEX RPRTVS ZPHASE
*. CALLED  : RMAINI
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-87
*. LAST MOD: 31-Mar-94
*.
*. Modification Log.
*. 31-Mar-94 M.Redmond   Move KUEXEC call
*. 30-Mar-94 O.Schaile   Call KUINIM early, add CLOSE(6) for VMS
*.                       move exec ROPE from ROPIKU to here
*. 27-Mar-91 S.Weisz     Call RDUMLD to help the linker.
*.  7-Apr-88 S.Weisz     KUIP initialisation.
*. 11-Feb-88 S.Weisz     ZEBRA trouble recovery;calls QNEXTE.
*.
*.**********************************************************************
+SEQ,DECLARE.
*
      INTEGER MEMOR,NKMEM,IV1,IV2
      INTEGER IDUM, NCHDUG, NFIRST
+SEQ,CRO.
+SEQ,RCNTRL.
+SEQ,RCREP.
+SEQ,RCLINE.
+SEQ,RECNTL.
+SEQ,CRVER.
      COMMON/PAWC/MEMOR(2)
      NKMEM=MEMOR(2)
*-- Try to avoid linking problems.
      IDUM   = 0
      CALL RDUMLD(IDUM)
*-- Set interactive flag IRINTR <ON>.
      IRINTR = 1
*-- Initializes ZEBRA,HBOOK and FFREAD.
      CALL ROPPAK
*-- Initializes KUIP.
      CALL KUINIT(NKMEM)
      CALL VECDEF
*-- Initializes KUIP commands.
      CALL ROPIKU
+SELF,IF=KUWHAM,I=VAX,QMALPH.
      CLOSE(UNIT=6)
+SELF,IF=KUWHAM.
      CALL KUINIM('GRope++')
+SELF.
*     print list of dummies accumulated by GRIKU and ROPIKU
      IF (NCHDUM .GT. 1) THEN
         NCHDUG=INDEX(CHDUMM,'RO:')-1
         IF(NCHDUG.GE.3)THEN
            CHLINE='Dummies called from GRIKU:'
            CALL RMAIL(0,0)
            NFIRST=1
10          CONTINUE
            CHLINE=CHDUMM(NFIRST:MIN(NFIRST+59,NCHDUG))
            CALL RMAIL(0,0)
            IF (NFIRST+60 .LT. NCHDUG) THEN
               NFIRST=NFIRST+60
               GOTO 10
            ENDIF
         ENDIF
         NFIRST=NCHDUG+4
         IF(NCHDUM.GE.NFIRST+3)THEN
            CHLINE='Dummies called from ROPIKU:'
            CALL RMAIL(0,0)
20          CONTINUE
            CHLINE=CHDUMM(NFIRST:MIN(NFIRST+59,NCHDUM))
            CALL RMAIL(0,0)
            IF (NFIRST+60 .LT. NCHDUM) THEN
               NFIRST=NFIRST+60
               GOTO 20
            ENDIF
         ENDIF
      ENDIF
      WRITE(CHLINE,1000)
      CALL RMAIL(2,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1020)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1030)
      CALL RMAIL(0,0)
*-- Get ROPE version from Patchy title card.
      WRITE(CHREP,1040)
      READ(CHREP,1050) IV1,IV2,ISVRO
      IVRO = 100*IV1 + IV2
*-- Get date of last modification of the cradle.
+SELF,LASTMOD.
      READ(CHREP,0) IDAMRO
+SELF.
*
      WRITE(CHLINE,1070) IVRO,ISVRO,IDAMRO
      CALL RMAIL(0,0)
      WRITE(CHLINE,1010)
      CALL RMAIL(0,0)
      WRITE(CHLINE,1000)
      CALL RMAIL(0,2)
*-- Initialize and set default values for ROPE processors.
      CALL ROPINI
*-- Read data cards.
      WRITE(CHLINE,1080)
      CALL RMAIL(1,0)
      WRITE(CHLINE,1090)
      CALL RMAIL(0,1)
      CALL FFGO
*-- Set RUN parameters.
      CALL ROPSET
*-- Initializes KUIP commands. move up
*      CALL ROPIKU
*-- User set up
      CALL KUEXEC('EXEC ROPE')
*-- Set ZEBRA phase to Zero to enable exit to QNEXT.
      CALL ZPHASE(0)
*-- Now ready for the GO step.
      CALL TIMEX(RTIMST)
      WRITE(CHLINE,1100)
      CALL RMAIL(1,1)
*
      CALL QNEXTE
*
 1000 FORMAT(5X,'***************************************************')
 1010 FORMAT(5X,'*                                                 *')
 1020 FORMAT(5X,'*          W E L C O M E  to  R O P E             *')
 1030 FORMAT(5X,'*       The OPAL reconstruction program           *')
 1040 FORMAT(
+SEQ,QFTITLE,N=24.
     +            )
 1050 FORMAT(8X,I1,1X,I2,1X,I2)
 1060 FORMAT(18X,I6)
 1070 FORMAT(5X,'*      Version ',I3,'/',I2, ' Modified on ',I6,
     +'          *')
 1080 FORMAT(5X,' ==> Type your FFREAD data cards (LIST,TRIG,..)')
 1090 FORMAT(5X,' ==> Last data card must be STOP')
 1100 FORMAT(5X,' ==> ROPE now ready , You can type your commands')
      END
+DECK,ROFILE.
      SUBROUTINE ROFILE
*.
*...RINPUT  Interactive setting of new files
*.
*. SEQUENCE: RCNTRL RCREP
*. CALLS   : RFUSER ROOPEN RMAIL
*. CALLED  : KUIP
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 29-Sep-95
*. LAST MOD  :
*.
*. Modification log:
*.
***********************************************************************
+SEQ,DECLARE.
*
      INTEGER      LUDATI, LUDATO
      PARAMETER   (LUDATI=57,LUDATO=58)
      INTEGER      NCFNAM,NC,NPAR, IER
      CHARACTER*64 CFNAME
      CHARACTER*4  CDIREC, CZOPT, CROPT
      CHARACTER*8 CTYPE, CHPATH
+SEQ,RCNTRL.
+SEQ,ROWORD.
+SEQ,RCLINE.
*--
      CALL KUPATL(CHPATH,NPAR)
      CALL KUGETS(CFNAME,NCFNAM)
      IF(NCFNAM.LE.0)THEN
         CHLINE='No file name given'
         CALL RMAIL(0,0)
         GOTO 999
      ENDIF
      IF(CHPATH(1:4).EQ.'FILE' .OR. CHPATH(1:4).EQ.'INPU')THEN
         CALL UCTOH(CFNAME,LFINAM,NBYTEW,NCFNAM)
         IF(CHPATH(1:4).EQ.'FILE')THEN
            CALL KUGETC(CTYPE,NC)
            CALL UCTOH(CTYPE,LFITYP,NBYTEW,4)
            CALL KUGETC(CDIREC,NC)
            CALL UCTOH(CDIREC,LFIDIR,NBYTEW,4)
         ELSE
            CDIREC='IN'
            CROPT=' '
         ENDIF
         IF(CDIREC(1:1).EQ.'I')THEN
            LFIUNI=57
         ELSE
            LFIUNI=58
         ENDIF
         CALL KUGETI(LFILRE)
         CALL KUGETC(CZOPT,NC)
         CALL UCTOH(CZOPT,LFIFCH,NBYTEW,4)
         IF(CHPATH(1:4).EQ.'FILE')THEN
            CALL KUGETC(CROPT,NC)
            IF(CROPT.EQ.'.')CROPT=' '
         ENDIF
         CALL UCTOH(CROPT,LFIDCH,NBYTEW,4)
         CALL RFUSER('FILE')
         IF(CDIREC.EQ.'OUT')THEN
            IF(CTYPE.EQ.'DATA')CTYPE='OUTPUT'
         ENDIF
         IF(CDIREC.EQ.'IN')THEN
            CTYPE='INPUT'
         ENDIF
      ELSE IF(CHPATH(1:3).EQ.'DAD')THEN
         CALL UCTOH(CFNAME,LDANAM,NBYTEW,NCFNAM)
         CALL UCTOH('    ',LDAOPT,NBYTEW,4)
         CALL UCTOH('DATA',LDATYP,NBYTEW,4)
         CALL UCTOH('IN  ',LDADIR,NBYTEW,4)
         LDAUN1=57
         LDAUN2=0
         CTYPE='INPUT'
         CALL RFUSER('DADF')
      ELSE IF(CHPATH(1:3).EQ.'EVT')THEN
         CALL UCTOH(CFNAME,LEVNAM,NBYTEW,NCFNAM)
         CALL UCTOH('    ',LEVOPT,NBYTEW,4)
         CALL UCTOH('IN  ',LEVDIR,NBYTEW,4)
         LEVUN1=57
         LEVUN2=58
         LEVUN3=52
         CTYPE='INPUT'
         CALL RFUSER('EVTF')
      ELSE
         CHLINE='Invalid access mode'
         CALL RMAIL(0,0)
         GOTO 999
      ENDIF
      CALL ROOPEN(CTYPE,IER)
      IF(IER.NE.0)THEN
         CHLINE='Error from ROOPEN'
         CALL RMAIL(0,0)
      ENDIF
999   RETURN
      END
+DECK,ROCENT.
      SUBROUTINE ROCENT
*.
*...ROCENT   Execute interactive CENTRAL KUIP commands for ROPE
*.
*. SEQUENCE: RCNTRL RCLINE
*. CALLS   : UCTOH UHTOC VFILL KUPATL KUGETC RMAIL RFLSET
*. CALLED  : KUIP
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 14-Jun-89
*. LAST MOD: 14-Jun-89
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IDFLT,NPAR,I,NCH
      CHARACTER*80 CCENT
      CHARACTER*32 CHPATH
      CHARACTER*4  CPNAME
*
+SEQ,RCNTRL.
+SEQ,RCLINE.
*-- Recognise command.
      CALL KUPATL(CHPATH,NPAR)
      IF(CHPATH(1:2).EQ.'SH')                                   GO TO 20
*-- New selection of processes, reset LCENT array.
      CALL UCTOH('    ',IDFLT,4,4)
      NCENT = 0
      CALL VFILL(LCENT,20,IDFLT)
      IF(NPAR.GE.1) THEN
         IF(NPAR.GT.20) NPAR = 20
         DO 10 I=1,NPAR
            CALL KUGETC(CPNAME,NCH)
            IF(NCH.GT.4)                                        GO TO 10
            CALL UCTOH(CPNAME,LCENT(I),NCH,4)
   10    CONTINUE
      END IF
*-- Reset processing flags in constant structure.
      CALL RFLSET
   20 CONTINUE
*-- Print central processes selected.
      IF(NCENT.LE.0) THEN
         CHLINE = 'No central process selected'
         CALL RMAIL(0,0)
      ELSE
         CALL UHTOC(LCENT,4,CCENT,80)
         CHLINE = 'Central processes selected : '//CCENT
         CALL RMAIL(0,0)
      END IF
*.
      RETURN
      END
+DECK,ROECAL.
      SUBROUTINE ROECAL
*.
*...ROECAL   Execute interactive ECAL KUIP commands for ROPE
*.
*. SEQUENCE: RCNTRL RCLINE
*. CALLS   : UCTOH UHTOC VFILL KUPATL KUGETC RMAIL RFLSET
*. CALLED  : KUIP
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 14-Jun-89
*. LAST MOD: 14-Jun-89
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IDFLT,NPAR,I,NCH
      CHARACTER*80 CECAL
      CHARACTER*32 CHPATH
      CHARACTER*4  CPNAME
*
+SEQ,RCNTRL.
+SEQ,RCLINE.
*-- Recognise command.
      CALL KUPATL(CHPATH,NPAR)
      IF(CHPATH(1:2).EQ.'SH')                                   GO TO 20
*-- New selection of processes, reset LECAL array.
      CALL UCTOH('    ',IDFLT,4,4)
      NECAL = 0
      CALL VFILL(LECAL,20,IDFLT)
      IF(NPAR.GE.1) THEN
         IF(NPAR.GT.20) NPAR = 20
         DO 10 I=1,NPAR
            CALL KUGETC(CPNAME,NCH)
            IF(NCH.GT.4)                                        GO TO 10
            CALL UCTOH(CPNAME,LECAL(I),NCH,4)
   10    CONTINUE
      END IF
*-- Reset processing flags in constant structure.
      CALL RFLSET
   20 CONTINUE
*-- Print Ecal processes selected.
      IF(NECAL.LE.0) THEN
         CHLINE = 'No Ecal process selected'
         CALL RMAIL(0,0)
      ELSE
         CALL UHTOC(LECAL,4,CECAL,80)
         CHLINE = 'Ecal processes selected : '//CECAL
         CALL RMAIL(0,0)
      END IF
*.
      RETURN
      END
+DECK,ROEVSL.
      SUBROUTINE ROEVSL
*.
*...ROEVSL   Show or set cuts for selection of events
*.
*. SEQUENCE: RCNTRL RCLINE
*. CALLS   : KUPATL KUGETR KUGETI RMAIL
*. CALLED  : KUIP
*.
*. AUTHOR  : C.Hawkes
*. VERSION : 1.01
*. CREATED : 17-Sep-89
*. LAST MOD : 22-Apr-97
*.
*. Modification Log.
*. 22-Apr-97  M.Schroder NoName -> NoNa (CHHBIT is char*4)
*. 30-Nov-95  O.Schaile  implement veto
*.  6-Nov-95  O.Schaile  add argument (IERR) in ROTRIG
*. 27-Sep-95 O.Schaile   Selection based on bits in header (EVTY etc)
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RBITFUNC.
*
      LOGICAL      SHWALL,SHWNCT,SHWEEC,SHWEHC,SHWNMU,SHWEVT,SHWHDW
      CHARACTER*32 CHPATH
      CHARACTER*8  CPNAME
      INTEGER      NPAR,NCH
      INTEGER      NMIN,NMAX
      REAL         EMIN,EMAX
*
+SEQ,RCNTRL.
+SEQ,RCLINE.
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,OCFLAG.
+SEQ,ROUNIT.
+SEQ,ROCPAR.
      INTEGER LIOHD,LIODI,LUNIT
      CHARACTER*4 CHHBIT, CHDMNE(MAXSEL)
      INTEGER I, K
      INTEGER IERR
      CHARACTER*4 CVETO
+SEQ,ROTPARM.
      DATA CHDMNE/'BUN ','DETS','TRGS','TRWD','TRWC','TRWB','TRWA',
     +            'FITY','EVTY','EVT2'/
*-- Check calling path
      CALL KUPATL(CHPATH,NPAR)
      IF(CHPATH(1:2).EQ.'SH')THEN
*-- Show present cut values
         WRITE(CHLINE,1000)
         CALL RMAIL(0,0)
         IF(IFSLON.EQ.2)THEN
            WRITE(CHLINE,'(A)')'Selections are globally ENABLED'
            CALL RMAIL(0,0)
         ENDIF
         IF(IFSLON.EQ.0)THEN
            WRITE(CHLINE,'(A)')'Selections are globally DISABLED'
            CALL RMAIL(0,0)
         ENDIF
*-- Get character parameter
         CALL KUGETC(CPNAME,NCH)
*-- Show all
         SHWALL=CPNAME(1:3).EQ.'ALL'
         SHWHDW=CPNAME(1:3).EQ.'BIT'
         IF(SHWALL.OR.SHWHDW.OR.CPNAME(1:4).EQ.'BITS')THEN
            WRITE(CHLINE,'(A)')'Selection based on bits in header words'
            CALL RMAIL(0,0)
            WRITE(CHLINE,'(A)')'---------------------------------------'
            CALL RMAIL(0,0)
            IF(MSANYS.LE.0)THEN
               WRITE(CHLINE,'(A)')'--- None ---'
               CALL RMAIL(0,0)
            ELSE
               DO 20 I=1,MAXSEL
                  IF(MSHDSL(I).NE.0 .OR. MSHDVE(I).NE.0)THEN
                     WRITE(CHLINE,'(A)')'Header word: '//CHDMNE(I)
                     CALL RMAIL(0,0)
                     CHHBIT='NoNa'
                     DO 10 K=1,32
                       IF(IBITS(MSHDSL(I),K-1,1).NE.0 .OR.
     +                   IBITS(MSHDVE(I),K-1,1).NE.0 )THEN
                         IF(IBITS(MSHDVE(I),K-1,1).NE.0 )THEN
                            CVETO='Veto'
                         ELSE
                            CVETO='    '
                         ENDIF
                         IF(CHDMNE(I).EQ.'EVTY')CHHBIT=ROTYPM(K)(1:4)
                         IF(CHDMNE(I).EQ.'EVT2')CHHBIT=ROTYPM(K+32)(1:4)
                         WRITE(CHLINE,'(A,I3,A,A,A,A)')'Bit Nr set: ',K,
     +                          '   ',CHHBIT,' ',CVETO
                         CALL RMAIL(0,0)
                       ENDIF
10                   CONTINUE
                  ENDIF
20             CONTINUE
            ENDIF
         ENDIF
*-- Show charged track cuts
         SHWNCT=CPNAME(1:3).EQ.'NCT'
         IF(SHWALL.OR.SHWNCT.OR.CPNAME(1:4).EQ.'NCMI')THEN
            WRITE(CHLINE,1001)NSLCMI
            CALL RMAIL(0,0)
         ENDIF
         IF(SHWALL.OR.SHWNCT.OR.CPNAME(1:4).EQ.'NCMA')THEN
            WRITE(CHLINE,1002)NSLCMA
            CALL RMAIL(0,0)
         ENDIF
*         WRITE(CHLINE,1000)
*         CALL RMAIL(0,0)
*-- Show electromagnetic calorimeter cuts
         SHWEEC=CPNAME(1:3).EQ.'EEC'
         IF(SHWALL.OR.SHWEEC.OR.CPNAME(1:4).EQ.'EEMI')THEN
            WRITE(CHLINE,1011)ESLEMI
            CALL RMAIL(0,0)
         ENDIF
         IF(SHWALL.OR.SHWEEC.OR.CPNAME(1:4).EQ.'EEMA')THEN
            WRITE(CHLINE,1012)ESLEMA
            CALL RMAIL(0,0)
         ENDIF
*         WRITE(CHLINE,1000)
*         CALL RMAIL(0,0)
*-- Show hadronic calorimeter cuts
         SHWEHC=CPNAME(1:3).EQ.'EHC'
         IF(SHWALL.OR.SHWEHC.OR.CPNAME(1:4).EQ.'EHMI')THEN
            WRITE(CHLINE,1021)ESLHMI
            CALL RMAIL(0,0)
         ENDIF
         IF(SHWALL.OR.SHWEHC.OR.CPNAME(1:4).EQ.'EHMA')THEN
            WRITE(CHLINE,1022)ESLHMA
            CALL RMAIL(0,0)
         ENDIF
*         WRITE(CHLINE,1000)
*         CALL RMAIL(0,0)
*-- Show muon segment cuts
         SHWNMU=CPNAME(1:4).EQ.'NMUO'
         IF(SHWALL.OR.SHWNMU.OR.CPNAME(1:5).EQ.'NMUMI')THEN
            WRITE(CHLINE,1031)NSLMMI
            CALL RMAIL(0,0)
         ENDIF
         IF(SHWALL.OR.SHWNMU.OR.CPNAME(1:5).EQ.'NMUMA')THEN
            WRITE(CHLINE,1032)NSLMMA
            CALL RMAIL(0,0)
         ENDIF
*         WRITE(CHLINE,1000)
*         CALL RMAIL(0,0)
*-- Show trigger number and run number selection
         SHWEVT=CPNAME(1:2).EQ.'EV'
         IF(SHWALL.OR.SHWEVT.OR.CPNAME(1:2).EQ.'IE')THEN
            IF(ISLEVT.GT.0)THEN
               WRITE(CHLINE,1041)ISLEVT
               CALL RMAIL(0,0)
               IF(SHWALL.OR.SHWEVT.OR.CPNAME(1:2).EQ.'IR')THEN
                  IF(ISLRUN.GT.0)THEN
                     WRITE(CHLINE,1042)ISLRUN
                     CALL RMAIL(0,0)
                  ELSE
                     WRITE(CHLINE,1043)
                     CALL RMAIL(0,0)
                  ENDIF
               ENDIF
            ELSE
               WRITE(CHLINE,1044)ISLEVT
               CALL RMAIL(0,0)
            ENDIF
         ENDIF
*            WRITE(CHLINE,1000)
*            CALL RMAIL(0,0)
      ELSEIF(CHPATH(1:2).EQ.'NC')THEN
*-- Set cuts on number of charged tracks
*-- Get integer parameters and fill COMMON/RCNTRL/
         CALL KUGETI(NMIN)
         CALL KUGETI(NMAX)
         IF(NMIN.LE.NMAX)THEN
            NSLCMI=NMIN
            NSLCMA=NMAX
         ELSE
            WRITE(CHLINE,1901)NMIN
            CALL RMAIL(1,0)
            WRITE(CHLINE,1902)NMAX
            CALL RMAIL(0,0)
            WRITE(CHLINE,1903)
            CALL RMAIL(0,1)
         ENDIF
         WRITE(CHLINE,1001)NSLCMI
         CALL RMAIL(1,0)
         WRITE(CHLINE,1002)NSLCMA
         CALL RMAIL(0,1)
      ELSEIF(CHPATH(1:2).EQ.'EE')THEN
*-- Set cuts on energy in electromagnetic calorimeters
*-- Get real parameters and fill COMMON/RCNTRL/
         CALL KUGETR(EMIN)
         CALL KUGETR(EMAX)
         IF(EMIN.LE.EMAX)THEN
            ESLEMI=EMIN
            ESLEMA=EMAX
         ELSE
            WRITE(CHLINE,1911)EMIN
            CALL RMAIL(1,0)
            WRITE(CHLINE,1912)EMAX
            CALL RMAIL(0,0)
            WRITE(CHLINE,1903)
            CALL RMAIL(0,1)
         ENDIF
         WRITE(CHLINE,1011)ESLEMI
         CALL RMAIL(1,0)
         WRITE(CHLINE,1012)ESLEMA
         CALL RMAIL(0,1)
      ELSEIF(CHPATH(1:2).EQ.'EH')THEN
*-- Set cuts on energy in hadronic calorimeters
*-- Get real parameters and fill COMMON/RCNTRL/
         CALL KUGETR(EMIN)
         CALL KUGETR(EMAX)
         IF(EMIN.LE.EMAX)THEN
            ESLHMI=EMIN
            ESLHMA=EMAX
         ELSE
            WRITE(CHLINE,1921)EMIN
            CALL RMAIL(1,0)
            WRITE(CHLINE,1922)EMAX
            CALL RMAIL(0,0)
            WRITE(CHLINE,1903)
            CALL RMAIL(0,1)
         ENDIF
         WRITE(CHLINE,1021)ESLHMI
         CALL RMAIL(1,0)
         WRITE(CHLINE,1022)ESLHMA
         CALL RMAIL(0,1)
      ELSEIF(CHPATH(1:2).EQ.'NM')THEN
*-- Set cuts on number of muon segments
*-- Get integer parameters and fill COMMON/RCNTRL/
         CALL KUGETI(NMIN)
         CALL KUGETI(NMAX)
         IF(NMIN.LE.NMAX)THEN
            NSLMMI=NMIN
            NSLMMA=NMAX
         ELSE
            WRITE(CHLINE,1931)NMIN
            CALL RMAIL(1,0)
            WRITE(CHLINE,1932)NMAX
            CALL RMAIL(0,0)
            WRITE(CHLINE,1903)
            CALL RMAIL(0,1)
         ENDIF
         WRITE(CHLINE,1031)NSLMMI
         CALL RMAIL(1,0)
         WRITE(CHLINE,1032)NSLMMA
         CALL RMAIL(0,1)
      ELSEIF(CHPATH(1:2).EQ.'EV')THEN
*-- Select event by its trigger number and run number
*-- Get integer parameters and fill COMMON/RCNTRL/
         CALL KUGETI(ISLEVT)
         IF(ISLEVT.LE.0) IFSLON=0
         IF(NPAR.GT.1) CALL KUGETI(ISLRUN)
         IF(ISLEVT.GT.0)THEN
            WRITE(CHLINE,1041)ISLEVT
            CALL RMAIL(0,0)
            IF(ISLRUN.GT.0)THEN
               WRITE(CHLINE,1042)ISLRUN
               CALL RMAIL(0,0)
            ELSE
               WRITE(CHLINE,1043)
               CALL RMAIL(0,0)
            ENDIF
+SELF,IF=UNIX.
            LUNIT  = 0
            LIOHD  = LQ(LUTC-LLIOHD)
            IF(LIOHD.GE.1) THEN
               LIODI  = LQ(LIOHD-LLIODI)
               IF(LIODI.GE.1) LUNIT  = IQ(LIODI+JLUN)
            END IF
            IF(LEVTL) THEN
               IFSLON = 0
               CALL MZWIPE(IRODIV)
               IFBOOK = 1
               CALL VZERO(IOCRRV,3)
                CALL ROTRIG(IERR)
                IF(IRSTOP.EQ.0 .AND. IERR.NE.-33) THEN
                  IF(IDUBAT.LT.1) CALL RBKREV
                  WRITE(CHLINE,2000) IREVNT,IRDRUN,IRDEVT
                  CALL RMAIL(0,0)
               ELSE
                  CHLINE = ' *** Could not get requested event ***'
                  CALL RMAIL(0,0)
               END IF
            END IF
+SELF.
         ELSE
            WRITE(CHLINE,1044)ISLEVT
            CALL RMAIL(0,0)
         ENDIF
      ELSE
*-- Not a valid command
         WRITE(CHLINE,1999)
         CALL RMAIL(1,1)
      ENDIF
*
      RETURN
*
 1000 FORMAT(1X)
 1001 FORMAT(' Minimum number of charged tracks =',I6)
 1002 FORMAT(' Maximum number of charged tracks =',I6)
 1011 FORMAT(' Minimum energy in electromagnetic calorimeters =',F8.3)
 1012 FORMAT(' Maximum energy in electromagnetic calorimeters =',F8.3)
 1021 FORMAT(' Minimum energy in hadronic calorimeters =',F8.3)
 1022 FORMAT(' Maximum energy in hadronic calorimeters =',F8.3)
 1031 FORMAT(' Minimum number of muon segments =',I6)
 1032 FORMAT(' Maximum number of muon segments =',I6)
 1041 FORMAT(' Trigger number selected =',I9)
 1042 FORMAT('     Run number selected =',I9)
 1043 FORMAT('  No run number selected')
 1044 FORMAT(' Trigger number selected =',I1,'. No selection applied.')
*
 1901 FORMAT(' **    Requested minimum number of tracks,',I6,'  **')
 1902 FORMAT(' **  > requested maximum number of tracks,',I6,'. **')
 1903 FORMAT(' **    No action taken.')
 1911 FORMAT(' **    Requested minimum ECAL energy,',F8.3,'  **')
 1912 FORMAT(' **  > requested maximum ECAL energy,',F8.3,'. **')
 1921 FORMAT(' **    Requested minimum HCAL energy,',F8.3,'  **')
 1922 FORMAT(' **  > requested maximum HCAL energy,',F8.3,'. **')
 1931 FORMAT(' **    Requested minimum number of muons,',I6,'  **')
 1932 FORMAT(' **  > requested maximum number of muons,',I6,'. **')
*
 1999 FORMAT(' Not a valid event selection command')
+SELF,IF=UNIX.
 2000 FORMAT(' *** Get input#',I8,' ,RUN#',I6, ' ,EVENT#',I8,' ***')
+SELF
*
      END
+DECK,RODIVE.
      SUBROUTINE RODIVE
*.
*...RODIVE   Divert printed output to a file
*.
*. CALLS   :
*. CALLED  : KUIP
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 23-Oct-95
*. LAST MOD:
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,CRO.
      CHARACTER*64 CFNAME, CFNSAV
      CHARACTER*8 CWHERE
      INTEGER NCH, IFILOP, LUNDIV, ISTAT
      PARAMETER (LUNDIV=8)
      SAVE IFILOP, CFNSAV
      DATA IFILOP/0/
      CALL KUGETC(CWHERE,NCH)
      IF(CWHERE.EQ.'TERMINAL')THEN
         IF(IFILOP.GT.0)THEN
            WRITE(*,*)'Closing open file: ',CFNSAV
            CLOSE(LUNDIV)
            IFILOP=0
         ENDIF
         CALL FFGET('LOUT',LROUT)
         WRITE(*,*)'Divert output to UNIT: ',LROUT
      ELSE
         CALL KUGETS(CFNAME,NCH)
         IF(NCH.LE.0)THEN
            WRITE(*,*)'No file name given, no action'
            RETURN
         ENDIF
         IF(IFILOP.GT.0)THEN
            WRITE(*,*)'Closing open file: ',CFNSAV
            CLOSE(LUNDIV)
            IFILOP=0
         ENDIF
         OPEN(LUNDIV,FILE=CFNAME,IOSTAT=ISTAT)
         IF(ISTAT.EQ.0)THEN
            CFNSAV=CFNAME
            WRITE(*,*)'Divert output to: ',CFNSAV
            IFILOP=1
            LROUT=LUNDIV
         ELSE
            WRITE(*,*)'Error opening: ',CFNAME, ISTAT
         ENDIF
      ENDIF
      RETURN
      END
+DECK,ROCHSI.
      SUBROUTINE ROCHSI
*.
*...ROCHSI   Rerun ROCHSE (chargino selection)
*.
*. CALLS   :
*. CALLED  : KUIP
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 16-Oct-95
*. LAST MOD:
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RBITFUNC.
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,ROPAR.
+SEQ,ROTPAR.
      INTEGER I, J, IU, IR, IEVTB(2), ISEL, ISELGP
+SEQ,ROTPARM.            the mnemonics of event types (ROPE)
*     is header same as REV?
      DO 20 J=0,1
         IU=IUHEAD(IIEVTY+J)
         IEVTB(J+1)=IU
         IR=IQ(LREV+IIEVTY+J)
         IF(IU.NE.IR)THEN
            WRITE(*,*)'** EVTY differs in HEAD and REV **'
            DO 10 I=0,31
               IF(IBITS(IU,I,1).NE.IBITS(IR,I,1))THEN
                  IF(IBITS(IU,I,1).NE.0)THEN
                     WRITE(*,*)' ',ROTYPM(I+1+32*J),' set in USHEAD'
                  ELSE
                     WRITE(*,*)' ',ROTYPM(I+1+32*J),' set in REV'
                  ENDIF
               ENDIF
10          CONTINUE
         ENDIF
20    CONTINUE

*-- Define event type for chargino selection

      IUHEAD(IIEVT2)=IBCLR(IUHEAD(IIEVT2),IEGACE-33)
      IUHEAD(IIEVT2)=IBCLR(IUHEAD(IIEVT2),IELMAE-33)
      IUHEAD(IIEVT2)=IBCLR(IUHEAD(IIEVT2),IEMONO-33)
      IUHEAD(IIEVT2)=IBCLR(IUHEAD(IIEVT2),IEGOPL-33)
      IUHEAD(IIEVT2)=IBCLR(IUHEAD(IIEVT2),IENELO-33)
      IUHEAD(IIEVT2)=IBCLR(IUHEAD(IIEVT2),IENETI-33)

      CALL ROCHSE(ISEL,ISELGP)
      IF(BTEST(ISEL,0)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEGACE-33)
      IF(BTEST(ISEL,1)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IELMAE-33)
      IF(BTEST(ISEL,2)) IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEMONO-33)
      IF(ISELGP.GT.0)   IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IEGOPL-33)
*-- Define event type for neutralino selection
      CALL HIELIN(ISEL)
      IF(ISEL.EQ.1 .OR. ISEL.EQ.2)
     +  IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IENELO-33)
      IF(ISEL.EQ.2)IUHEAD(IIEVT2)=IBSET(IUHEAD(IIEVT2),IENETI-33)

      IF(IEVTB(1) .NE. IUHEAD(IIEVTY).OR.
     +   IEVTB(2) .NE. IUHEAD(IIEVTY+1))THEN
         WRITE(*,*)'** Event type differs after ROCHSE **'
         DO 40 J=0,1
            IU=IUHEAD(IIEVTY+J)
            IR=IEVTB(J+1)
            IF(IU.NE.IR)THEN
               DO 30 I=0,31
                  IF(IBITS(IU,I,1).NE.IBITS(IR,I,1))THEN
                     IF(IBITS(IU,I,1).NE.0)THEN
                        WRITE(*,*)' ',ROTYPM(I+1+32*J),' set now'
                     ELSE
                        WRITE(*,*)' ',ROTYPM(I+1+32*J),' no longer set'
                     ENDIF
                  ENDIF
30             CONTINUE
            ENDIF
40       CONTINUE
      ELSE
         WRITE(*,*)'** Event type didnt change after ROCHSE **'
      ENDIF
      END
+DECK,ROCHSC.
      SUBROUTINE ROCHSC
*.
*...ROCHSC   Set cut parameters for ROCHSE (chargino selection)
*.
*. CALLS   : KUPATL KUGETR RMAIL
*. CALLED  : KUIP
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 23-Oct-95
*. LAST MOD: 26-Oct-95
*.
*. Modification Log.
*. 26-Oct-95 O.Schaile  CHPATHs => Uppercase
*.
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RBITFUNC.
+SEQ,ROCHCU.
+SEQ,ROCHVA.
      CHARACTER*8 CHPATH
      INTEGER NPAR, I
*-- Get command
      CALL KUPATL(CHPATH,NPAR)
      IF     (CHPATH.EQ.'TRACKS')THEN
         DO 10 I=1,9
10       CALL KUGETR(CHTRQU(I))
      ELSE IF(CHPATH.EQ.'ECAL')THEN
         DO 20 I=1,3
20       CALL KUGETR(CHECQU(I))
      ELSE IF(CHPATH.EQ.'LOOSEGEN')THEN
         DO 30 I=1,10
30       CALL KUGETR(CHSEL1(I))
      ELSE IF(CHPATH.EQ.'TIGHTGEN')THEN
         DO 40 I=1,10
40       CALL KUGETR(CHSET1(I))
      ELSE IF(CHPATH.EQ.'LOOSELOW')THEN
         DO 50 I=1,13
50       CALL KUGETR(CHSEL2(I))
      ELSE IF(CHPATH.EQ.'TIGHTLOW')THEN
         DO 60 I=1,13
60       CALL KUGETR(CHSET2(I))
      ELSE IF(CHPATH.EQ.'LOOSEMON')THEN
         DO 70 I=1,9
70       CALL KUGETR(CHSEL3(I))
      ELSE IF(CHPATH.EQ.'TIGHTMON')THEN
         DO 80 I=1,9
80       CALL KUGETR(CHSET3(I))
      END IF
      END
+DECK,ROESTY.
      SUBROUTINE ROESTY
*.
*...ROESTY  Set bits for selection by event type, filter bits etc
*.
*. SEQUENCE: RCNTRL RCLINE
*. CALLS   : KUPATL KUGETR KUGETI RMAIL
*. CALLED  : KUIP
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 25-Sep-95
*. LAST MOD: 20-Nov-95
*.
*. Modification Log.
*. 20-Nov-95  O.Schaile  implement veto
*.**********************************************************************
+SEQ,DECLARE.
+SEQ,RCLINE.
+SEQ,RCNTRL.
      CHARACTER*32 CHPATH
      CHARACTER*8  CPNAME, CSETRE, CVETO
      CHARACTER*4  CEVT12
      INTEGER      NPAR,NCH,NCHNAM, ISETRE, IBITNR, IBITN1, IVETO
      INTEGER      ROTYBI
+SEQ,ROTPARM.            the mnemonics of event types (ROPE)
*----
*     default is 'SET'
      ISETRE=1
      IVETO=0
      IBITNR=0
*-- Get command
      CALL KUPATL(CHPATH,NPAR)
      IF(CHPATH(1:4).EQ.'ENAB')THEN
         IFSLON=2
         GOTO 999
      ENDIF
      IF(CHPATH(1:4).EQ.'IGNO')THEN
         IFSLON=0
         GOTO 999
      ENDIF
      IF(NPAR.LT.1)THEN
         WRITE(CHLINE,'(A)')'No parameters given, command rejected'
         CALL RMAIL(0,0)
         GOTO 999
      ENDIF
      CALL KUGETC(CPNAME,NCHNAM)
      IF(NPAR.GE.2)THEN
         CALL KUGETI(IBITNR)
         IF(NPAR.GE.3)THEN
            CALL KUGETC(CSETRE,NCH)
            IF(NCH.GT.0)THEN
               IF(CSETRE(1:1).EQ.'U' .OR. CSETRE(1:1).EQ.'R')ISETRE=0
            ENDIF
         ENDIF
         IF(NPAR.GE.4)THEN
            CALL KUGETC(CVETO,NCH)
            IF(NCH.GT.0)THEN
               IF(CVETO(1:1).EQ.'V' .OR. CVETO(1:1).EQ.'R')IVETO=1
            ENDIF
         ENDIF
      ENDIF

      IF(CHPATH(1:4).EQ.'EVTY')THEN
         IF(     CPNAME(1:4).NE.'NONE'
     +     .AND. CPNAME(1:4).NE.'    ')THEN
            IBITN1=ROTYBI(CPNAME(1:4))
         ELSE
            IBITN1=0
         ENDIF
         IF(IBITN1.LE.0)THEN
            IF(IBITNR.LT.-1 .OR.IBITNR.GT.64)THEN
               WRITE(CHLINE,'(A)')'No valid BitNr given'
               CALL RMAIL(0,0)
               GOTO 999
            ELSE
               IBITN1=IBITNR
            ENDIF
         ENDIF
         IF(IBITN1.LE.32)THEN
            CEVT12='EVTY'
         ELSE
            CEVT12='EVT2'
            IBITN1=IBITN1-32
         ENDIF
         IF(IBITNR.EQ.-1)IBITN1=-1
      ELSE IF(CHPATH(1:4).EQ.'FITY')THEN
         CEVT12='FITY'
*        no mnemonic yet
         IBITN1=0
         IF(IBITN1.LE.0)THEN
            IF(IBITNR.LE.-1 .OR.IBITNR.GT.32)THEN
               WRITE(CHLINE,'(A)')'No valid BitNr given'
               CALL RMAIL(0,0)
               GOTO 999
            ELSE
               IBITN1=IBITNR
            ENDIF
         ENDIF
      ELSE
*     all others BUN, DETS, TRGS, TRWA..
         CEVT12=CHPATH(1:4)
*        no mnemonic yet
         IBITN1=0
         IF(IBITN1.LE.0)THEN
            IF(IBITNR.LE.-1 .OR.IBITNR.GT.32)THEN
               WRITE(CHLINE,'(A)')'No valid BitNr given'
               CALL RMAIL(0,0)
               GOTO 999
            ELSE
               IBITN1=IBITNR
            ENDIF
         ENDIF
      ENDIF
      IF(ISETRE.NE.0)THEN
         IF(IBITN1.EQ.-1)IBITN1=0
         CALL RSLBIT(CEVT12,IBITN1,IVETO)
         IFSLON=2
         WRITE(CHLINE,'(A)')'Selection is ENABLED for all commands'
         CALL RMAIL(0,0)
      ELSE
         CALL RUSBIT(CEVT12,IBITN1,IVETO)
*        clear both eventype words?
         IF(CEVT12.EQ.'EVTY' .AND. IBITN1.EQ.-1)THEN
            CALL RUSBIT('EVT2',IBITN1,IVETO)
         ENDIF
      ENDIF
999   RETURN
      END
+DECK,RSLBIT.
      SUBROUTINE RSLBIT(CHHBIT,IBITNR,IVETO)
*.
*...RSLBIT  Event selection by header bits (counting 1-32 !!!).
*.
*. SEQUENCE: RCNTRL RCREP ROWORD
*. CALLS   :
*. CALLED  : RFUSER
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 26-Sep-95
*. LAST MOD:  1-Nov-96
*.
*. Modification Log.
*.  1-Nov-96  N.K.Watson Fix bug for IBITNR=32
*. 20-Nov-95  O.Schaile  implement veto
***********************************************************************
+SEQ,DECLARE.
+SEQ,RBITFUNC.
+SEQ,ROWORD.
+SEQ,RCNTRL.
+SEQ,RCREP.
      CHARACTER*4 CHHBIT
      INTEGER IBITNR,IVETO
      CHARACTER*4 CHDMNE(MAXSEL)
      INTEGER I, ISEUNS, IBITN1
      DATA CHDMNE/'BUN ','DETS','TRGS','TRWD','TRWC','TRWB','TRWA',
     +            'FITY','EVTY','EVT2'/
      ISEUNS=1
      IF(IBITNR.LE.0)THEN
         IBITN1=0
      ELSE
         IBITN1=IBITNR-1
      ENDIF
      GOTO 5
      ENTRY RUSBIT(CHHBIT,IBITNR,IVETO)
      IF(IBITNR.EQ.-1)THEN
*        clear all bits
         IBITN1=1
         ISEUNS=-1
      ELSE
        IBITN1=IBITNR-1
        ISEUNS=0
      ENDIF
5     CONTINUE
      IF(IBITN1.LT.0 .OR. IBITN1.GE.32)THEN
         CHREP='Only bits 1 - 32 allowed'
         CALL REPORT('RSLBIT',1,'E')
         GOTO 30
      ENDIF
*     loop on header words
      DO 20 I=1,MAXSEL
         IF(CHHBIT.EQ.CHDMNE(I))THEN
            IF(ISEUNS.EQ.1)THEN
               IF(IVETO.EQ.0)THEN
                  IF(IBITS(MSHDSL(I),IBITN1,1).EQ.0)MSANYS=MSANYS+1
                  MSHDSL(I)=IBSET(MSHDSL(I),IBITN1)
               ELSE
                  IF(IBITS(MSHDVE(I),IBITN1,1).EQ.0)MSANYS=MSANYS+1
                  MSHDVE(I)=IBSET(MSHDVE(I),IBITN1)
               ENDIF
            ELSE
               IF(ISEUNS.EQ.0)THEN
                  IF(IVETO.EQ.0)THEN
                     IF(IBITS(MSHDSL(I),IBITN1,1).NE.0)MSANYS=MSANYS-1
                     MSHDSL(I)=IBCLR(MSHDSL(I),IBITN1)
                  ELSE
                     IF(IBITS(MSHDVE(I),IBITN1,1).EQ.0)MSANYS=MSANYS-1
                     MSHDVE(I)=IBCLR(MSHDVE(I),IBITN1)
                  ENDIF
               ELSE
                  DO 10 IBITN1=0,31
                    IF(IVETO.EQ.0)THEN
                      IF(IBITS(MSHDSL(I),IBITN1,1).NE.0)MSANYS=MSANYS-1
                    ELSE
                      IF(IBITS(MSHDVE(I),IBITN1,1).NE.0)MSANYS=MSANYS-1
                    ENDIF
10                CONTINUE
                  MSHDSL(I)=0
               ENDIF
            ENDIF
            GOTO 30
         ENDIF
20    CONTINUE
      CHREP='Unkown header word '//CHHBIT
      CALL REPORT('RSLBIT',2,'E')
30    CONTINUE
      RETURN
      END
+DECK,ROFORW.
      SUBROUTINE ROFORW
*.
*...ROFORW   Execute interactive FORW KUIP commands for ROPE
*.
*. SEQUENCE: RCNTRL RCLINE
*. CALLS   : UCTOH UHTOC VFILL KUPATL KUGETC RMAIL RFLSET
*. CALLED  : KUIP
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 14-Jun-89
*. LAST MOD:  2-Jun-93
*.
*. Modification Log.
*. 2-Jun-93  D.Wagner    Cosmetic changes
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IDFLT,NPAR,I,NCH
      CHARACTER*80 CFORW
      CHARACTER*32 CHPATH
      CHARACTER*4  CPNAME
*
+SEQ,RCNTRL.
+SEQ,RCLINE.
*-- Recognise command.
      CALL KUPATL(CHPATH,NPAR)
      IF(CHPATH(1:2).EQ.'SH')                                   GO TO 20
*-- New selection of processes, reset LFORW array.
      CALL UCTOH('    ',IDFLT,4,4)
      NFORW = 0
      CALL VFILL(LFORW,20,IDFLT)
      IF(NPAR.GE.1) THEN
         IF(NPAR.GT.20) NPAR = 20
         DO 10 I=1,NPAR
            CALL KUGETC(CPNAME,NCH)
            IF(NCH.GT.4)                                        GO TO 10
            CALL UCTOH(CPNAME,LFORW(I),NCH,4)
   10    CONTINUE
      END IF
*-- Reset processing flags in constant structure.
      CALL RFLSET
   20 CONTINUE
*-- Print Forward processes selected.
      IF(NFORW.LE.0) THEN
         CHLINE = ' No Forward process selected'
         CALL RMAIL(0,0)
      ELSE
         CALL UHTOC(LFORW,4,CFORW,80)
         CHLINE = ' Forward processes selected : '//CFORW
         CALL RMAIL(0,0)
      END IF
*.
      RETURN
      END
+DECK,ROGOKU.
      SUBROUTINE ROGOKU
*.
*...ROGOKU   Execute interactive KUIP commands for ROPE
*.
*. SEQUENCE: ROBANK RCNTRL CRO ROCPAR RECNTL RCLINE OCFLAG
*. CALLS   : KUPATL KUGETI KUGETC RMAIL ROEVNT ROTRIG RBKREV ROBAT
*.           RIOSEL ROWOUT RPTREE
*.           ROSIZE MZWIPE DZSNAP DZSURV DZSHOW LZLOC DZVERI FZENDI
*. CALLED  : KUIP
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED :   7-Apr-88
*. LAST MOD:  14-Nov-95
*.
*. Modification Log.
*. 14-Nov-95 O.Schaile   Remap Trig, Goto to EVFIND if no file
*.  1-Nov-95 G.Duckeck   implement direct access
*. 24-Oct-95 O.Schaile   Call ODTOSI
*. 3-Nov-93  O.Schaile   Condition Call to ROPBAT on LREV/=0
*. 911015    S.Weisz Interactive Event List on shift.
*. 10-Oct-89 C.Hawkes       Add GET commands to select EVSEL events.
*. 12-Sep-89 S.Weisz        Implement CONSTANT,SCAN,NODROP cmd.
*.  7-Sep-89 S.Weisz        Reset OPCAL flags.
*. 21-Jul-89 S.Weisz        Restrict GOTO command options.
*. 15-Jul-89 S.Weisz        Implement REWIND command to restart scanning
*.  8-Fev-89 S.Weisz        Implement DZVERI call.
*. 31-Jan-89 S.Weisz        Update for ROPE306.
*. 16-Sep-88 S.Weisz        Implement PROCESS option.
*.
*.**********************************************************************
      IMPLICIT NONE
      INTEGER NPAR,NUMB1,NUMB2,IPRINT,NCH,LOC,LZLOC
      INTEGER NBANKS,NDATAS,NLINKS,NWORDS
      INTEGER IONOFF
      SAVE    IONOFF
      INTEGER IT, IFAIL
      INTEGER IERR
      CHARACTER*8 CWHAT
      INTEGER LIOHD,LIODI
      CHARACTER*32 CHPATH
      CHARACTER*4 CNAME,CHOPT
      CHARACTER*2 CHODSI, CHODCX
*
+SEQ,ROPAR.
+SEQ,ROBANK.
+SEQ,RCNTRL.
+SEQ,CRO .
+SEQ,ROCPAR.
+SEQ,RECNTL.
+SEQ,OCFLAG.
+SEQ,RCLINE.
+SEQ,ROUNIT.
      INTEGER LUNIT
C GD >
+SEQ,ROEVIA.
C GD <
      INTEGER IRUARG
      LOGICAL NOFILE, FIRSTT
      DATA FIRSTT/.TRUE./
      DATA IONOFF, IRUARG/0,-1/
      NUMB1  = 0
      NUMB2  = 0
      IRSTOP = 0
*-- Recognise command.
      CALL KUPATL(CHPATH,NPAR)
      LUNIT  = 0
      LIOHD  = LQ(LUTC-LLIOHD)
      IF(LIOHD.GE.1) THEN
         LIODI  = LQ(LIOHD-LLIODI)
         IF(LIODI.GE.1) LUNIT  = IQ(LIODI+JLUN)
      END IF
      IF(LEVTL.AND.LUNIT.EQ.LRIN) THEN
         IF(CHPATH(1:2).EQ.'SK' .OR. CHPATH(1:3).EQ.'REW'.OR.
     +      CHPATH(1:2).EQ.'PR') THEN
            CHLINE=' Command '//CHPATH//' is invalid with NOFILE'
            CALL RMAIL(0,0)
                                                               GO TO 999
         END IF
         NOFILE=.TRUE.
         IF(FIRSTT)THEN
            CALL KUCMD('ROPE',' ', 'SW')
            CALL KUPVAL('GOTO','CWHAT',0,0.0,'HOTLINE','D')
            IF(CHPATH(1:3).EQ.'TRI')THEN
               FIRSTT=.FALSE.
               IRUARG=0
               READ(4,*,END=3,ERR=3)IRUARG
3              CONTINUE
            END IF
         END IF
      ELSE
         NOFILE=.FALSE.
      END IF
      IF(CHPATH(1:3).EQ.'TRI')                                  GO TO 10
      IF(CHPATH(1:2).EQ.'SK')                                   GO TO 30
      IF(CHPATH(1:2).EQ.'GO')                                   GO TO 40
      IF(CHPATH(1:2).EQ.'PR')                                   GO TO 50
      IF(CHPATH(1:3).EQ.'RIO')                                  GO TO 60
      IF(CHPATH(1:3).EQ.'ROW')                                  GO TO 70
      IF(CHPATH(1:3).EQ.'ROB')                                  GO TO 80
      IF(CHPATH(1:3).EQ.'ROS')                                  GO TO 90
      IF(CHPATH(1:4).EQ.'DZSN')                                GO TO 100
      IF(CHPATH(1:4).EQ.'DZSU')                                GO TO 110
      IF(CHPATH(1:4).EQ.'DZSH')                                GO TO 120
      IF(CHPATH(1:3).EQ.'DZV')                                 GO TO 140
      IF(CHPATH(1:3).EQ.'ROT')                                 GO TO 150
      IF(CHPATH(1:3).EQ.'REW')                                 GO TO 160
      IF(CHPATH(1:3).EQ.'CON')                                 GO TO 170
      IF(CHPATH(1:2).EQ.'SC')                                  GO TO 180
      IF(CHPATH(1:3).EQ.'NOD')                                 GO TO 190
      IF(CHPATH(1:3).EQ.'GET')                                 GO TO 200
      IF(CHPATH(1:3).EQ.'EVF')                                 GO TO 210
      CHLINE=' *** Nonexistent command ***'
      CALL RMAIL(0,0)
                                                               GO TO 999
*-- Read in new events.
   10 CONTINUE
      IF(NOFILE)THEN
         IF(IRUFST.EQ.0 .AND. ABS(IRUARG).GT.1)THEN
            IRUFST=-ABS(IRUARG)
         ENDIF
         NPAR=0
         IFLGIA=0
         IEVFST=0
         GOTO 210
      ENDIF
      IRTRIG(1) = IREVNT + 1
      IF(NPAR.GE.1) THEN
         CALL KUGETI(NUMB2)
         IRTRIG(2) = IREVNT + NUMB2
      ELSE
         IRTRIG(2) = IREVNT + 1
      END IF
      IRTRIG(3) = 1
      IRUFST = 0
   20 IF(IONOFF.EQ.1) THEN
         CALL ROEVNT
      ELSE
         IF(NUMB2.GE.2) THEN
            CHLINE = ' *** Process flag not on, select it first ***'
            CALL RMAIL(0,0)
            CHLINE = ' ***        with PROCESS ON               ***'
            CALL RMAIL(0,0)
                                                               GO TO 999
         END IF
         CALL MZWIPE(IRODIV)
         IFBOOK = 1
         CALL VZERO(IOCRRV,3)
         CALL ROTRIG(IERR)
         IF(IRSTOP.EQ.0 .AND. IERR.NE.-33) THEN
            IF(IDUBAT.LT.1) CALL RBKREV
*   expand MCtree ^^^^
*-- Set option for ODTOSI
            IF(IFODSI.NE.0)THEN
               IF(MOD(IFODSI,10).EQ.2)THEN
                  CHODSI='SI'
               ELSE IF(MOD(IFODSI,10).EQ.1)THEN
                  CHODSI='si'
               ELSE IF(MOD(IFODSI,10).EQ.0)THEN
                  CHODSI=' '
               ENDIF
               IF(IFODSI.LE.10)THEN
                  CHODCX=' '
               ELSE
                  CHODCX='CX'
               ENDIF
               CALL ODTOSI(CHODSI,CHODCX,IFAIL)
            ENDIF
             WRITE(CHLINE,1000) IREVNT,IRDRUN,IRDEVT
             CALL RMAIL(0,0)
         ELSE
            CHLINE = ' *** Could not get requested event ***'
            CALL RMAIL(0,0)
         END IF
      END IF
      IF(IRSTOP.EQ.0 .AND. IERR.NE.-33) THEN
         IF(LREV.EQ.0)GOTO 5
         LEX=LQ(LREV-LLEX)
         IF(LEX.EQ.0)GOTO 5
         LMC=LQ(LEX-LLMC)
         IF(LMC.EQ.0)GOTO 5
         IF(LQ(LMC-1).EQ.0)GOTO 5
         IF(LQ(LQ(LMC-1)-1).EQ.0)GOTO 5
         CALL ROEXTR(IRODIV,LQ,IQ,Q,LQ(LQ(LMC-1)-1),' ','Expanded Tree')
         IF(LQ(LQ(LMC-1)-2).EQ.0)GOTO 5
         CALL ROEXJE(IRODIV,LQ,IQ,Q,LQ(LQ(LMC-1)-2),' ',
     +             'Expansion of Jets')
    5    CONTINUE
      ENDIF
      IRUFST=0
                                                               GO TO 999
*-- Skip NUMBER events.
   30 CALL KUGETI(NUMB1)
      IRTRIG(1) = IREVNT + NUMB1 + 1
      IF(NPAR.GE.2) THEN
         CALL KUGETI(NUMB2)
         IRTRIG(2) = IREVNT + NUMB1 + NUMB2
      ELSE
         IRTRIG(2) = IREVNT + NUMB1 + 1
      END IF
      IRTRIG(3) = 1
      IRUFST = 0
                                                                GO TO 20
*-- Get events from event number IEVFST,run number IEVFST.
   40 CALL KUGETI(IEVFST)
      IF(NPAR.GE.2) CALL KUGETI(IRUFST)
      CWHAT(1:4)='CURR'
      IFLGIA = 0
      IF(NPAR.GE.3) THEN
         CALL KUGETC(CWHAT,NCH)
         IF(CWHAT(1:4).EQ.'MCAR')THEN
            IFLGIA = 1
         ELSE IF(CWHAT(1:4).EQ.'HOTL')THEN
            IRUFST=-ABS(IRUFST)
         ENDIF
      ENDIF
      IF(NOFILE .OR. CWHAT(1:4).NE.'CURR' .OR. IRUFST.EQ.0)THEN
         NPAR=0
         GOTO 210
      ENDIF
*      IF(IRUFST.LE.0) THEN
*         IF(IRDRUN.LE.0) THEN
*            CHLINE=' *** You have to specify the RUN number ***'
*            CALL RMAIL(0,0)
*                                                              GO TO 999
*         ELSE
*            IRUFST=IRDRUN
*         END IF
*      END IF
      IRTRIG(2) = IREVNT
      IRULST = IRUFST
      IEVLST = IEVFST
                                                                GO TO 20
*-- Set processing flag
   50 CALL KUGETC(CHOPT,NCH)
      IF(CHOPT .EQ. 'ON') THEN
         IONOFF = 1
      ELSE
         IONOFF = 0
      END IF
                                                               GO TO 999
*-- Select output streams.
   60 IF(NPAR.GE.1) CALL KUGETI(NUMB1)
      IF(NPAR.GE.2) CALL KUGETI(NUMB2)
      CALL RIOSEL(NUMB1,NUMB2)
                                                               GO TO 999
*-- Write to selected output streams.
   70 CALL ROWOUT
                                                               GO TO 999
*-- Run ROPE according to FFREAD options.
   80 CONTINUE
      IF(LREV.EQ.0)THEN
         CHLINE=' *** No d/s , useless to CALL ROPBAT  ***'
         CALL RMAIL(0,0)
      ELSE
         CALL ROPBAT
      ENDIF
                                                               GO TO 999
*-- Print size used in the ROPE store.
   90 IPRINT=3
                                                               GO TO 130
*-- Snapshot of the ZEBRA store.
  100 CONTINUE
      CHOPT='M'
      CALL DZSNAP('DZSNAP',IXSTOR,CHOPT)
                                                               GO TO 999
*-- Survey of the ZEBRA store.
  110 IPRINT=2
                                                               GO TO 130
*-- Dump bank CNAME in the ZEBRA store.
  120 IPRINT=1
  130 NUMB1=0
      CALL KUGETC(CNAME,NCH)
      IF(NPAR.GT.1)CALL KUGETI(NUMB1)
      LOC=LZLOC(IXSTOR,CNAME,NUMB1)
      IF(LOC.EQ.0) THEN
         CHLINE=' *** Bank not found ***'
         CALL RMAIL(0,0)
                                                               GO TO 999
      END IF
      IF(IPRINT.EQ.3)THEN
         CALL ROSIZE(LOC,CNAME,NBANKS,NDATAS,NLINKS,NWORDS)
      ENDIF
      IF(IPRINT.EQ.2)THEN
         CALL DZSURV('DZSURV',IXSTOR,LOC)
      ENDIF
      IF(IPRINT.EQ.1)THEN
         CHOPT='BLV'
         IF(NPAR.GT.2)CALL KUGETC(CHOPT,NCH)
         CALL DZSHOW('DZSHOW',IXSTOR,LOC,CHOPT,0,0,0,0)
      ENDIF
                                                               GO TO 999
*-- Verify ROPE event division.
  140 CALL DZVERI('    ',IRODIV,'CLSU')
                                                               GO TO 999
*-- Print TREE structure.
  150 CALL KUGETI(IT)
      CALL RPTREE(IT)
                                                               GO TO 999
*-- Rewind input to restart scanning.
  160 CONTINUE
      LIOHD = LQ(LUTC - LLIOHD)
      IF(LIOHD.LE.0)                                           GO TO 999
      LIODI = LQ(LIOHD - LLIODI)
      IF(LIODI.LE.0)                                           GO TO 999
      CALL FZENDI(IQ(LIODI+JLUN),'IQ')
                                                               GO TO 999
*-- Set flag to write constant records.
  170 CALL KUGETI(IFCNST)
                                                               GO TO 999
*-- Set flag for input scan file.
  180 CALL KUGETI(IFSCAN)
                                                               GO TO 999
*-- Set flag to call dropping of working banks.
  190 CALL KUGETI(IFDROP)
      INDROP = 0
       IF(IFDROP.EQ.0) INDROP = 1
                                                               GO TO 999
*-- Set flag to select event according to REVSEL commands.
  200 IFSLON = 1
                                                                GO TO 10
*-- Get events from shift server
 210  CONTINUE
      IF(NPAR.GE.1) CALL KUGETI(IEVFST)
      IF ( IEVFST .GE. 0 ) THEN
         LEVTIA = .TRUE.
*         IONOFF = 1
      ELSE
         LEVTIA = .FALSE.
                                                               GO TO 999
      ENDIF
      IF(NPAR.GE.2) CALL KUGETI(IRUFST)
      IF(IRUFST.EQ.0) THEN
         IF(IRDRUN.EQ.0) THEN
            CHLINE=' *** You will get the latest data-taking run ***'
            CALL RMAIL(0,0)
         END IF
      END IF
* get data/MC/hot flag
      IF(NPAR.GE.3) THEN
         IFLGIA=0
         CALL KUGETC(CWHAT,NCH)
         IF(CWHAT(1:4).EQ.'MCAR')THEN
            IFLGIA = 1
         ELSE IF(CWHAT(1:4).EQ.'HOTL')THEN
            IRUFST=-ABS(IRUFST)
         ENDIF

*          CALL KUGETI(IFLGIA)
*          IF(IFLGIA .LE. 0 ) THEN
*             IFLGIA = 0
*          ELSE
*             IFLGIA = 1
*          END IF
      END IF

*       IF ( IFLGIA .NE. 1 ) IFLGIA = 0
      IRTRIG(2) = IREVNT + 1
      IRULST = 9999999
      IEVLST = 9999999
      IRUNIA = IRUFST
      IEVTIA = IEVFST
                                                                GO TO 20
C GD
*.
  999 RETURN
 1000 FORMAT(' *** Get input#',I8,' ,RUN#',I6, ' ,EVENT#',I8,' ***')
      END
+DECK,ROEXTR.
      SUBROUTINE ROEXTR(IXST,LQ,IQ,Q,LTREE,COPT,CTITLE)
*.
*...ROEXTR  Expand Mcarlo TREE bank (Interactive only)
*.
*. SEQUENCE:
*. CALLS   : BTMAMA
*. CALLED  : ROGOKU
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 21-Mar-96
*. LAST MOD:  1-Nov-96
*.
*. Modification log:
*.  1-Nov-96 O.Schaile Protect atan2 against PT=0
*.
*.  9-Apr-96 O.Schaile LQ(*) ...
*.  4-Apr-96 M.Schroder Make it at least a little f77 compliant
*.
      IMPLICIT NONE
      INTEGER LQ(*),IQ(*),IXST,LTREE
      REAL Q(*)
      CHARACTER*(*) COPT,CTITLE
*
      INTEGER NCCODE
      PARAMETER (NCCODE=151)
      CHARACTER*11 CPNAME(NCCODE)
      INTEGER CPCODE(NCCODE), IPCODE

      CHARACTER*80 CLINE
      CHARACTER*8 CSTART(0:12)
      CHARACTER*12 CEND(0:12)
      CHARACTER*4 CNPART
      REAL P, PHI, RS, RE, XE, YE, ZE, ROUTCD,ZOUTCD
      REAL PT
      INTEGER ND,NP,J,I,NPRIM,NPART,LOFF,NSEC,IOEXTR,IOEXT1, IFIRST,NC,
     +        ISFLAG, IEFLAG, NWTREE, IPHI
      REAL PI
      PARAMETER (PI=3.14159)

      INTEGER LNBLNK, BTMAMA
      LOGICAL NOHACD
      INTEGER LAREA(3),LAUX,L, LTOP
      COMMON/CEXTRE/LAREA,LAUX,L, LTOP
      SAVE IFIRST,IOEXTR
      DATA IFIRST/0/
      DATA CSTART(0)/'I_S_Phot'/
      DATA CSTART(1)/'Prim Par'/
      DATA CSTART(2)/'Dk_P_Gen'/
      DATA CSTART(3)/'F_GEA_St'/
      DATA CSTART(4)/'Unknown '/
      DATA CSTART(5)/'DK_GEANT'/
      DATA CSTART(6)/'Pair Pro'/
      DATA CSTART(7)/'Compton '/
      DATA CSTART(8)/'Photelec'/
      DATA CSTART(9)/'Bremsstr'/
      DATA CSTART(10)/'DeltaRay'/
      DATA CSTART(11)/'Posit An'/
      DATA CSTART(12)/'Hadr Int'/

      DATA CEND(0)/'-> DK_in_Gen'/
      DATA CEND(1)/'-> Neut_aliv'/
      DATA CEND(2)/'-> Chgd_aliv'/
      DATA CEND(3)/'-> Stopped  '/
      DATA CEND(4)/'-> Unknown  '/
      DATA CEND(5)/'-> DK_GEANT '/
      DATA CEND(6)/'-> PairProd '/
      DATA CEND(7)/'-> Compton  '/
      DATA CEND(8)/'-> Photelect'/
      DATA CEND(9)/'-> Bremsstra'/
      DATA CEND(10)/'-> DeltaRay '/
      DATA CEND(11)/'-> Posit Ann'/
      DATA CEND(12)/'-> Had Inter'/
      DATA (CPCODE(I),CPNAME(I),I=1,19)/
     + 1, 'd'
     +,2, 'u'
     +,3, 's'
     +,4, 'c'
     +,5, 'b'
     +,6, 't'
     +,7, 'l'
     +,8, 'h'
     +,11, 'e^-'
     +,12, '[n]?e'
     +,13, '[m^-'
     +,14, '[n]?[m]'
     +,15, '[t^-'
     +,16, '[n?t'
     +,17, '[h]-'
     +,18, '[n]?[h]'
     +,21, 'gluon'
     +,22, '[g'
     +,23, 'Z^0' /

      DATA (CPCODE(I),CPNAME(I),I=20,38)/
     + 24, 'W^+'
     +,25, 'H^0'
     +,32, 'Z^\47 0'
     +,33, 'Z^"0'
     +,34, 'W^\47 +'
     +,35, 'H^\47 0'
     +,36, 'A^0'
     +,37, 'H^+'
     +,39, 'L?Q'
     +,40, 'R^0'
     +,211, '[p]^+'
     +,213, '[r]^+'
     +,311, 'K^0'
     +,313, 'K^*0'
     +,321, 'K^+'
     +,323, 'K^*+'
     +,411, 'D^+'
     +,413, 'D^*+'
     +,421, 'D^0' /

      DATA (CPCODE(I),CPNAME(I),I=39,57)/
     + 423, 'D^*0'
     +,431, 'D?s^+'
     +,433, 'D?s^*+'
     +,511, 'B^0'
     +,513, 'B^*0'
     +,521, 'B^+'
     +,523, 'B^*+'
     +,531, 'B?s0'
     +,533, 'B?s^*0'
     +,111, '[p]^0'
     +,113, '[r]^0'
     +,221, '[c]'
     +,223, '[w]'
     +,331, '[c]'
     +,333, '[f]'
     +,441, '[c]?c'
     +,443, 'J/[y]'
     +,551, '[c]?b^'
     +,553, '[T]' /

      DATA (CPCODE(I),CPNAME(I),I=58,76)/
     + 661, '[c]?t'
     +,663, '[Q]'
     +,130, 'K?L^0'
     +,310, 'K?S^0'
     +,10213, 'b?1^+'
     +,10211, 'a?0^+'
     +,10313, 'K?1^0'
     +,10311, 'K*?0^0'
     +,10323, 'K?1^+'
     +,10321, 'K*?0^+'
     +,10413, 'D?1^+'
     +,10411, 'D*?0^+'
     +,10423, 'D?1^0'
     +,10421, 'D*?0^0'
     +,10433, 'D?1^s+'
     +,10431, 'D*?0^s+'
     +,10113, 'b?1^0'
     +,10111, 'a?0^0'
     +,10223, 'h?1^0' /

      DATA (CPCODE(I),CPNAME(I),I=77,95)/
     + 10221, 'f?0^0'
     +,10333, 'h\47 ?1^0'
     +,10331, 'f\47 ?0^0'
     +,10443, 'h?1^c0'
     +,10441, '[h]?0c^0'
     +,20213, 'a?1^+'
     +,215,   'a?2^+'
     +,20313, 'K?1^*0'
     +,315,   'K?2^*0'
     +,20323, 'K?1^*+'
     +,325,   'K?2^*+'
     +,20413, 'D?1^*+'
     +,415,   'D\47 ?2^+'
     +,20423, 'D?1^*0'
     +,425,   'D?2^*0'
     +,20433, 'D?1^*s+'
     +,435,   'D?2^*s+'
     +,20113, 'a?1^0'
     +,115,   'a?2^0' /

      DATA (CPCODE(I),CPNAME(I),I=96,114)/
     + 20223, 'f?1^0'
     +,225,   'f?2^0'
     +,20333, 'f\47 ?1^0'
     +,335,   'f\47 ?2^0'
     +,20443, '[h]?1^c0'
     +,445, '[h]?2^c0'
     +,1114, '[D]^-'
     +,2112, 'n'
     +,2114, '[D]^0'
     +,2212, 'p'
     +,2214, '[D]^+'
     +,2224, '[D]^++'
     +,3112, '[S]^-'
     +,3114, '[S]^*-'
     +,3122, '[L]^0'
     +,3212, '[S]^0'
     +,3214, '[S]^*0'
     +,3222, '[S]^+'
     +,3224, '[S]^*+' /

      DATA (CPCODE(I),CPNAME(I),I=115,133)/
     + 3312, '[H]^-'
     +,3314, '[H]^*-'
     +,3322, '[H]^0'
     +,3324, '[H]^*0'
     +,3334, '[W]^-'
     +,4112, '[S]?c^0'
     +,4114, '[S]?c^*0'
     +,4122, '[L]?c^+'
     +,4212, '[S]?c^+'
     +,4214, '[S]?c^*+'
     +,4222, '[S]?c^++'
     +,4224, '[S]?c^*++'
     +,4132, '[H]?c^0'
     +,4312, '[H]`?c^0'
     +,4314, '[H]?c^*0'
     +,4232, '[H]?c^+'
     +,4322, '[H]\47 ?c^+'
     +,4324, '[H]?c^*+'
     +,4332, '[W]?c^0' /

      DATA (CPCODE(I),CPNAME(I),I=134,151)/
     + 4334, '[W]?c^*0'
     +,5112, '[S]?b^-'
     +,5114, '[S]?b^*-'
     +,5122, '[L]?b^0'
     +,5212, '[S]?b^0'
     +,5214, '[S]?b^*0'
     +,5222, '[S]?b^+'
     +,5224, '[S]?b^*+'
     +,525, 'B^**+'
     +,95,'Deut'
     +,96,'Trit'
     +,97,'Alph'
     +,13122,'[L](1400)'
     +,10511, 'B?1^0'
     +,10513, 'B?1^*0'
     +,10523, 'B?1^*+'
     +,10515, 'B?1^**0'
     +,10521, 'B?1^+'  /

*--
*    bank EXTR:
*     1-22       copy of KINE
*    23-24       part name
*    25-27       start flag
*    28-30       end flag
*    31-34       p
*    35-38       rstart - rend
*--

      ND=IQ(LTREE-1)
      NWTREE=IQ(LQ(LTREE+1)+5)
      IF(MOD(ND,NWTREE).NE.0)THEN
         WRITE(*,*)'Length of TREE bank is invalid',ND
         GOTO 999
      ENDIF
      CALL ODFUNS
      IF(INDEX(COPT,'A').EQ.0)THEN
         NOHACD=.TRUE.
      ELSE
         NOHACD=.FALSE.
      ENDIF
      IF(IFIRST.EQ.0)THEN
         IF(INDEX(COPT,'A').EQ.0)THEN
            WRITE(*,*)
     +     'Secondories of hadronic interactions outside CD suppressed'
         ENDIF
         CALL MZFORM('EXTR','10I 12F -H',IOEXTR)
         CALL MZFORM('EXT1','10I 12F -H',IOEXT1)
         IFIRST=1
      ENDIF
      CALL MZLINT(IXST,'ROEXTR',LAREA,LAUX, LTOP)
*     auxillary  bank (NEXT OF TREE)
      NPART=ND/NWTREE
      CALL MZBOOK(IXST,LAUX,LTREE,0,'BAUX',NPART+1,0,NPART,2,0)

*     find number of primaries and book bank

      NPRIM=0
      DO 100 I=1,NPART
         IF(IQ(LTREE+(I-1)*NWTREE+2).EQ.0)NPRIM=NPRIM+1
  100 CONTINUE
      CALL MZBOOK(IXST,LTOP,LTREE,0,'EXTR',NPRIM,NPRIM,5,5,0)
      NC=MIN(LNBLNK(CTITLE),20)
      CALL UCTOH(CTITLE,IQ(LTOP+1),NC,4)
      LQ(LAUX-1)=LTOP

*     now run through particles

      DO 15 I=1,NPART
*        find parent bank and link offset
*         NP=IQ(LTREE+(I-1)*NWTREE+2)
         NP = BTMAMA(I)
         L=LQ(LAUX-(NP+1))
         IF(L.EQ.0)THEN
            WRITE(*,*)'Parent is not stored'
            GOTO 15
         ENDIF
         IF(IQ(L-3).EQ.0)THEN
            WRITE(*,*)'Parent has no links'
            GOTO 15
         ENDIF

         DO 200 J=1,IQ(L-3)
            IF(LQ(L-J).EQ.0)THEN
               LOFF=J
               GOTO 10
            ENDIF
  200    CONTINUE
*         WRITE(*,*)'Pushing bank for particle:',I
         CALL MZPUSH(IXST,L,1,0,'.')
         LOFF=IQ(L-3)
*         GOTO 999
10       CONTINUE

*        now book a bank for it

         NSEC=IQ(LTREE+(I-1)*NWTREE+4)
         ISFLAG=IQ(LTREE+(I-1)*NWTREE+9)
         IEFLAG=IQ(LTREE+(I-1)*NWTREE+10)
         XE=Q(LTREE+(I-1)*NWTREE+20)
         YE=Q(LTREE+(I-1)*NWTREE+21)
         ZE=Q(LTREE+(I-1)*NWTREE+22)
         RE=SQRT(XE**2+YE**2)
         ROUTCD=184.5
*                              =sin(15)
         ZOUTCD=159.8+(RE-24.5)*0.259
         IF(ISFLAG.EQ.10 .OR. ISFLAG.EQ.9)THEN
            LOFF=0
         ELSE
            IF((RE.GT.ROUTCD .OR.ZE.GT.ZOUTCD)
     +          .AND. IEFLAG.EQ.12
     +          .AND. NOHACD)NSEC=0
         ENDIF
         CALL MZBOOK(IXST,LTOP,L,-LOFF,'EXT1',NSEC,NSEC,40,IOEXTR,0)
         LQ(LAUX-I-1)=LTOP
*        Num Id = number in tree
         IQ(LTOP-5)=I
         CALL UCOPY(IQ(LTREE+(I-1)*NWTREE+1),IQ(LTOP+1),NWTREE)
         CALL VBLANK(IQ(LTOP+23),IQ(LTOP-1)-NWTREE)

*        put in momentum

         P=SQRT(Q(LTOP+11)**2+Q(LTOP+12)**2+Q(LTOP+13)**2)
          PT=SQRT(Q(LTOP+11)**2+Q(LTOP+12)**2)
          IF(PT.GT.0.00001)THEN
            PHI=ATAN2(Q(LTOP+12),Q(LTOP+11))
            IPHI=180.*PHI/PI+0.5
            IF(IPHI.LT.0.)IPHI=360.+IPHI
         ELSE
            IPHI=0
         ENDIF
         WRITE(CLINE,'(A,F6.2,A,I3)')'p=',P,' Phi=',IPHI
         CALL UCTOH(CLINE,IQ(LTOP+31),4,16)

*        put in start/end radius

         RS=SQRT(Q(LTOP+17)**2+Q(LTOP+18)**2)
         WRITE(CLINE,'(A,F5.1,A,F5.1,A)')'R:',RS,'->',RE,' cm'
         CALL UCTOH(CLINE,IQ(LTOP+35),4,17)

*        get particle name

         CLINE=' '
         IPCODE=ABS(IQ(LTOP+1))
         DO 300 J=1,NCCODE
            IF(CPCODE(J).EQ.IPCODE)THEN
*               IF(CLINE.NE.' ') WRITE(*,*)'Ambigous code:',IPCODE
               CLINE=CPNAME(J)
               GOTO 20
            ENDIF
  300    CONTINUE
20       CONTINUE
         NC=MIN(LNBLNK(CLINE),10)

*        put the correct charge

         IF(Q(LTOP+16).GT.0)THEN
            J=INDEX(CLINE,'-')
            IF(J.NE.0)CLINE(J:J)='+'
         ENDIF
         IF(Q(LTOP+16).LT.0)THEN
            J=INDEX(CLINE,'+')
            IF(J.NE.0)CLINE(J:J)='-'
         ENDIF

*        copy the particle name

         CALL UCTOH(CLINE,IQ(LTOP+23),4,NC)

*        number in tree

         CNPART='    '
         IF(I.LT.10)THEN
            WRITE(CNPART(1:1),'(I1)')I
         ELSE IF(I.LT.100)THEN
            WRITE(CNPART(1:2),'(I2)')I
         ELSE IF(I.LT.1000)THEN
            WRITE(CNPART(1:3),'(I3)')I
         ELSE
            CNPART='>999'
         ENDIF
         CALL UCTOH(CNPART,IQ(LTOP+25),4,4)

*        copy the start flag

         J=IQ(LTOP+9)
         IF(J.LT.0 .OR. J.GT.12)THEN
            WRITE(*,*)'Illegal start flag',J
         ELSE
            CALL UCTOH(CSTART(J),IQ(LTOP+26),4,8)
         ENDIF

*        copy the end flag

         J=IQ(LTOP+10)
         IF(J.EQ.-1)THEN
            J=0
         ELSE IF(J.LT.0)THEN
            J=-J
         ENDIF
         IF(J.EQ.30)J=3
         IF(J.LT.0 .OR. J.GT.12)THEN
            J=4
         ENDIF
         CALL UCTOH(CEND(J),IQ(LTOP+28),4,12)
 15   CONTINUE
      CALL MZDROP(IXST,LAUX,' ')
      LAREA(1)=0
999   CONTINUE
      END
+DECK, ROEXJE.
      SUBROUTINE ROEXJE(IXST,LQ,IQ,Q,LJETS,COPT,CTITLE)
*.
*...ROEXTR  Expand Mcarlo JETS bank (Interactive only)
*.
*. SEQUENCE:
*. CALLS   :
*. CALLED  : ROGOKU
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 21-Mar-96
*. LAST MOD:  1-Nov-96
*.
*. Modification log:
*.  1-Nov-96 O.Schaile Protect atan2 against PT=0
*.  9-Apr-96 O.Schaile LQ(*) ...
*.  4-Apr-96 M.Schroder Make it at least a little f77 compliant
*.
      IMPLICIT NONE
      INTEGER LQ(*),IQ(*),IXST,LJETS
      REAL Q(*)
      CHARACTER*(*) COPT,CTITLE
*
      INTEGER NCCODE
      PARAMETER (NCCODE=64)
      CHARACTER*11 CPNAME(NCCODE)
      INTEGER CPCODE(NCCODE), IPCODE

      CHARACTER*80 CLINE
      CHARACTER*4 CNPART
      REAL P, PHI
      INTEGER ND,NP,J,I,NPRIM,NPART,LOFF,NSEC,IOEXTR,IOEXT1, IFIRST,NC,
     +        NWJETS, IPHI
      REAL PI
      REAL PT
      PARAMETER (PI=3.14159)
      INTEGER LNBLNK
      INTEGER LAREA(3),LAUX,L, LTOP
      COMMON/CEXTRE/LAREA,LAUX,L, LTOP
      SAVE IFIRST,IOEXTR
      DATA IFIRST/0/
      DATA (CPCODE(I),CPNAME(I),I=1,19)/
     + 1, 'd'
     +,2, 'u'
     +,3, 's'
     +,4, 'c'
     +,5, 'b'
     +,6, 't'
     +,7, 'l'
     +,8, 'h'
     +,11, 'e^-'
     +,12, '[n]?e'
     +,13, '[m^-'
     +,14, '[n]?[m]'
     +,15, '[t^-'
     +,16, '[n?t'
     +,17, '[h]-'
     +,18, '[n]?[h]'
     +,21, 'gluon'
     +,22, '[g'
     +,23, 'Z^0' /
      DATA (CPCODE(I),CPNAME(I),I=20,38)/
     + 24, 'W^+'
     +,25, 'H^0'
     +,32, 'Z^\47 0'
     +,33, 'Z^"0'
     +,34, 'W^\47 +'
     +,35, 'H^\47 0'
     +,36, 'A^0'
     +,37, 'H^+'
     +,39, 'L?Q'
     +,40, 'R^0'
     +,92,'String'
     +,93,'Clust'
     +,94,'Indep'
     +,-1, 'd&^-'
     +,-2, 'u&^-'
     +,-3, 's&^-'
     +,-4, 'c&^-'
     +,-5, 'b&^-'
     +,-6, 't&^-' /
      DATA (CPCODE(I),CPNAME(I),I=39,57)/
     + -7, 'l&^-'
     +,-8, 'h&^-'
     +,-11, 'e^+'
     +,12, '[n]?e'
     +,13, '[m^-'
     +,14, '[n]?[m]'
     +,15, '[t^-'
     +,16, '[n?t'
     +,17, '[h]-'
     +,18, '[n]?[h]'
     +,21, 'gluon'
     +,22, '[g'
     +,23, 'Z^0'
     +,24, 'W^+'
     +,25, 'H^0'
     +,32, 'Z^\47 0'
     +,33, 'Z^"0'
     +,34, 'W^\47 +'
     +,35, 'H^\47 0' /
      DATA (CPCODE(I),CPNAME(I),I=58,64)/
     + 36, 'A^0'
     +,37, 'H^+'
     +,39, 'L?Q'
     +,40, 'R^0'
     +,92,'String'
     +,93,'Clust'
     +,94,'Indep'  /
*--
*    bank EXTR:
*     1-8      copy of JETS
*     8-10       part name
*    11-16       jet nr,comment
*    17-20       p
*    21-25       energy,mass
*--
      NWJETS=IQ(LQ(LJETS+1)+6)
      ND=IQ(LJETS-1)
      IF(MOD(ND,NWJETS).NE.0)THEN
         WRITE(*,*)'Length of JETS bank is invalid',ND
         GOTO 999
      ENDIF
*      CALL ODFUNS
      IF(IFIRST.EQ.0)THEN
         CALL MZFORM('EXJE','3I 5F -H',IOEXTR)
         CALL MZFORM('EXJ1','3I 5F -H',IOEXT1)
         IFIRST=1
      ENDIF
      CALL MZLINT(IXST,'ROEXTR',LAREA,LAUX, LTOP)

*     auxillary  bank (NEXT OF JETS)

      NPART=ND/NWJETS
      CALL MZBOOK(IXST,LAUX,LJETS,0,'BAUX',NPART+1,0,NPART,2,0)

*     find number of primaries and book bank

      NPRIM=0
      DO 100 I=1,NPART
         IF(IQ(LJETS+(I-1)*NWJETS+2).EQ.0)NPRIM=NPRIM+1
  100 CONTINUE
      CALL MZBOOK(IXST,LTOP,LJETS,0,'EXJE',NPRIM,NPRIM,5,5,0)
      NC=MIN(LNBLNK(CTITLE),20)
      CALL UCTOH(CTITLE,IQ(LTOP+1),NC,4)
      LQ(LAUX-1)=LTOP

*     now run through particles

      DO 15 I=1,NPART
*        find parent bank and link offset
         NP=IQ(LJETS+(I-1)*NWJETS+2)
         IF(NP.GT.1000)NP=NP/1000
*         NP = BTMAMA(I)
         L=LQ(LAUX-(NP+1))
         IF(L.EQ.0)THEN
            WRITE(*,*)'Parent is not stored'
            GOTO 15
         ENDIF
         IF(IQ(L-3).EQ.0)THEN
            WRITE(*,*)'Parent has no links'
            GOTO 15
         ENDIF

         DO 200 J=1,IQ(L-3)
            IF(LQ(L-J).EQ.0)THEN
               LOFF=J
               GOTO 10
            ENDIF
  200    CONTINUE
*         WRITE(*,*)'Pushing bank for particle:',I
         CALL MZPUSH(IXST,L,1,0,'.')
         LOFF=IQ(L-3)
*         GOTO 999
10       CONTINUE

*        now book a bank for it
         NSEC=2
         CALL MZBOOK(IXST,LTOP,L,-LOFF,'EXJ1',NSEC,NSEC,26,IOEXTR,0)
         LQ(LAUX-I-1)=LTOP
*        Num Id = number in JETS
         IQ(LTOP-5)=I
         CALL UCOPY(IQ(LJETS+(I-1)*NWJETS+1),IQ(LTOP+1),NWJETS)
         CALL VBLANK(IQ(LTOP+9),IQ(LTOP-1)-8)

*        put in momentum, phi

         P=SQRT(Q(LTOP+4)**2+Q(LTOP+5)**2+Q(LTOP+6)**2)
          PT=SQRT(Q(LTOP+4)**2+Q(LTOP+5)**2)
          IF(PT.GT.0.00001)THEN
            PHI=ATAN2(Q(LTOP+5),Q(LTOP+4))
            IPHI=180.*PHI/PI+0.5
            IF(IPHI.LT.0.)IPHI=360.+IPHI
         ELSE
            IPHI=0
         ENDIF
         WRITE(CLINE,'(A,F6.2,A,I3)')'p=',P,' Phi=',IPHI
         CALL UCTOH(CLINE,IQ(LTOP+17),4,16)

*        put in mass, energy

         WRITE(CLINE,'(A,F5.1,A,F5.1)')'E=',Q(LTOP+7),' m=',Q(LTOP+8)
         CALL UCTOH(CLINE,IQ(LTOP+21),4,15)

*        get particle name

         CLINE=' '
         IPCODE=IQ(LTOP+1)
         DO 300 J=1,NCCODE
            IF(CPCODE(J).EQ.IPCODE)THEN
               CLINE=CPNAME(J)
               GOTO 20
            ENDIF
  300    CONTINUE
20       CONTINUE
         NC=MIN(LNBLNK(CLINE),8)

*        copy the particle name

         CALL UCTOH(CLINE,IQ(LTOP+9),4,NC)

*        number in JETS

         CNPART='    '
         IF(I.LT.10)THEN
            WRITE(CNPART(1:1),'(I1)')I
         ELSE IF(I.LT.100)THEN
            WRITE(CNPART(1:2),'(I2)')I
         ELSE IF(I.LT.1000)THEN
            WRITE(CNPART(1:3),'(I3)')I
         ELSE
            CNPART='>999'
         ENDIF
         CALL UCTOH(CNPART,IQ(LTOP+11),4,4)
*        parent in tree??
         IF(IQ(LTOP+3).NE.0)THEN
            WRITE(CLINE,'(A,I4)')'From TREE Nr.:',IQ(LTOP+3)
            CALL UCTOH(CLINE,IQ(LTOP+12),4,18)
         ELSE IF(IQ(LTOP+2).GT.1000)THEN
            WRITE(CLINE,'(A,2I4)')'String betw:',
     +           IQ(LTOP+2)/1000,MOD(IQ(LTOP+2),1000)
            CALL UCTOH(CLINE,IQ(LTOP+12),4,20)
         ENDIF
 15   CONTINUE
      CALL MZDROP(IXST,LAUX,' ')
      LAREA(1)=0
999   CONTINUE
      END
+DECK,ROHCAL.
      SUBROUTINE ROHCAL
*.
*...ROHCAL   Execute interactive HCAL KUIP commands for ROPE
*.
*. SEQUENCE: RCNTRL RCLINE
*. CALLS   : UCTOH UHTOC VFILL KUPATL KUGETC RMAIL RFLSET
*. CALLED  : KUIP
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 14-Jun-89
*. LAST MOD: 14-Jun-89
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IDFLT,NPAR,I,NCH
      CHARACTER*80 CHCAL
      CHARACTER*32 CHPATH
      CHARACTER*4  CPNAME
*
+SEQ,RCNTRL.
+SEQ,RCLINE.
*-- Recognise command.
      CALL KUPATL(CHPATH,NPAR)
      IF(CHPATH(1:2).EQ.'SH')                                   GO TO 20
*-- New selection of processes, reset LHCAL array.
      CALL UCTOH('    ',IDFLT,4,4)
      NHCAL = 0
      CALL VFILL(LHCAL,20,IDFLT)
      IF(NPAR.GE.1) THEN
         IF(NPAR.GT.20) NPAR = 20
         DO 10 I=1,NPAR
            CALL KUGETC(CPNAME,NCH)
            IF(NCH.GT.4)                                        GO TO 10
            CALL UCTOH(CPNAME,LHCAL(I),NCH,4)
   10    CONTINUE
      END IF
*-- Reset processing flags in constant structure.
      CALL RFLSET
   20 CONTINUE
*-- Print Hcal processes selected.
      IF(NHCAL.LE.0) THEN
         CHLINE = 'No Hcal process selected'
         CALL RMAIL(0,0)
      ELSE
         CALL UHTOC(LHCAL,4,CHCAL,80)
         CHLINE = 'Hcal processes selected : '//CHCAL
         CALL RMAIL(0,0)
      END IF
*.
      RETURN
      END
+DECK,GOTREI.
      SUBROUTINE GOTREI
*.
*...GOTREI   Interface to GOTREE
*.
*. SEQUENCE:
*. CALLS   : GOTREE
*. CALLED  : KUIP
*.
*. AUTHOR  : O.Schaile
*. VERSION : 1.00
*. CREATED : 21-Jul-93
*. LAST MOD:  1-Jun-95
*.
*. Modification Log.
*. 1-Jun-95 O.Schaile Reactivate Track selection
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IT,NCH
*--
*     Get argument
      CALL KUGETI(IT)
      CALL GOTREE(IT)
      RETURN
      END
+DECK,ROMUON.
      SUBROUTINE ROMUON
*.
*...ROMUON   Execute interactive MUON KUIP commands for ROPE
*.
*. SEQUENCE: RCNTRL RCLINE
*. CALLS   : UCTOH UHTOC VFILL KUPATL KUGETC RMAIL RFLSET
*. CALLED  : KUIP
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 14-Jun-89
*. LAST MOD: 14-Jun-89
*.
*. Modification Log.
*.
*.**********************************************************************
+SEQ,DECLARE.
      INTEGER IDFLT,NPAR,I,NCH
      CHARACTER*80 CMUON
      CHARACTER*32 CHPATH
      CHARACTER*4  CPNAME
*
+SEQ,RCNTRL.
+SEQ,RCLINE.
*-- Recognise command.
      CALL KUPATL(CHPATH,NPAR)
      IF(CHPATH(1:2).EQ.'SH')                                   GO TO 20
*-- New selection of processes, reset LMUON array.
      CALL UCTOH('    ',IDFLT,4,4)
      NMUON = 0
      CALL VFILL(LMUON,20,IDFLT)
      IF(NPAR.GE.1) THEN
         IF(NPAR.GT.20) NPAR = 20
         DO 10 I=1,NPAR
            CALL KUGETC(CPNAME,NCH)
            IF(NCH.GT.4)                                        GO TO 10
            CALL UCTOH(CPNAME,LMUON(I),NCH,4)
   10    CONTINUE
      END IF
*-- Reset processing flags in constant structure.
      CALL RFLSET
   20 CONTINUE
*-- Print Muon processes selected.
      IF(NMUON.LE.0) THEN
         CHLINE = 'No Muon process selected'
         CALL RMAIL(0,0)
      ELSE
         CALL UHTOC(LMUON,4,CMUON,80)
         CHLINE = 'Muon processes selected : '//CMUON
         CALL RMAIL(0,0)
      END IF
*.
      RETURN
      END
+DECK,ROPIKU.
      SUBROUTINE ROPIKU
*.
*...ROPIKU   ROPE routine to initialize KUIP commands
*.
*. CALLS   : ROIKU GRIKU USIKU ODIKU
*.           CVIKU JCIKU CJIKU CZIKU CTIKU SIIKU CSIKU CXIKU CEIKU
*.           TBIKU PBIKU EBIKU PEIKU EEIKU EMIKU
*.           HBIKU HEIKU HPIKU MBIKU MEIKU SWIKU FDIKU
*.
*. CALLED  : RCNTLI
*.
*. AUTHOR  : S.Weisz
*. VERSION : 1.01
*. CREATED : 18-May-87
*. LAST MOD: 28-Mar-96
*.
*. Modification Log.
*. 28-Mar-96  O.Schaile       Introduce TE process.
*. 21-Mar-96 O.Schaile   Put ZBRDEF etc always in
*.  3-Feb-95 O.Schaile   Add CALL GRBROW
*.  1-Feb-94 O.Schaile   Add KUIP Motif stuff, REPORT=>RMAIL
*.  6-May-93 D.Wagner    Avoid blank line when printing dummies (35=>36)
*. 26-Apr-93 O.Schaile   Add SWIKU
*. 13-Feb-92 A.Buijs     Modify printout of dummy routines.
*. 17-Jul-89 S.Weisz     Call KUEXEC of ROPE KUMAC file
*. 13-Apr-91 S.Weisz     Add SIIKU, CSIKU
*.
*.**********************************************************************
+SEQ,DECLARE.
C      INTEGER NFIRST
C  +SEQ,RCREP.
C  +SEQ,RCLINE.
+SEQ,RECNTL.
*
      CHDUMM=' '
      NCHDUM=1
      CALL ROIKU
      CHDUMM=' '
      NCHDUM=1
      CALL GRIKU
      IF(NCHDUM.LE.LEN(CHDUMM)-5)THEN
         CHDUMM(NCHDUM:)='RO:'
         NCHDUM=NCHDUM+3
      ENDIF
      CALL CEIKU
      CALL CVIKU
      CALL JCIKU
      CALL CJIKU
      CALL CZIKU
      CALL CTIKU
      CALL SIIKU
      CALL CSIKU
      CALL CXIKU
      CALL PBIKU
      CALL EBIKU
      CALL EEIKU
      CALL EMIKU
      CALL HBIKU
      CALL HEIKU
      CALL HPIKU
      CALL MBIKU
      CALL MEIKU
      CALL TBIKU
      CALL TEIKU
      CALL PEIKU
      CALL FDIKU
      CALL SWIKU
      CALL ODIKU
      CALL USIKU
C +SELF,IF=KUWHAM.
      CALL KUIDFM
      CALL ZBRDEF
      CALL GRBROW
C +SELF.
      RETURN
      END
+PATCH,ROSLIM.
+DECK,BLANKDEK.
      SUBROUTINE FMINIT(IDUM1,IDUM2,IDUM3,CDUM1,IDUM4)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2,IDUM3,IDUM4
      CHARACTER*4 CDUM1
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMLOGL(IDUM1)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMLIST(CDUM1,CDUM2,IDUM1,IDUM2,IDUM3,IDUM4)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2,IDUM3,IDUM4
      CHARACTER*4 CDUM1,CDUM2
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMSORT(CDUM1,IDUM1,IDUM2,IDUM3,IDUM4)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2,IDUM3,IDUM4
      CHARACTER*4 CDUM1
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMGETK(IDUM1,IDUM2,IDUM3,IDUM4)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2,IDUM3,IDUM4
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMGETC(IDUM1,IDUM2,IDUM3,IDUM4,IDUM5)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2,IDUM3,IDUM4,IDUM5
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMQTMS(IDUM1,IDUM2,IDUM3,IDUM4,IDUM5,IDUM6,IDUM7)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2,IDUM3,IDUM4,IDUM5,IDUM6,IDUM7
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMOPEN(CDUM1,CDUM2,IDUM1,CDUM3,IDUM2)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2
      CHARACTER*4 CDUM1,CDUM2,CDUM3
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMCLOS(CDUM1,CDUM2,IDUM1,CDUM3,IDUM2)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1,IDUM2
      CHARACTER*4 CDUM1,CDUM2,CDUM3
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMLFIL(CDUM1,IDUM2,IDUM3,IDUM4,IDUM5,IDUM6,IDUM7)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM2,IDUM3,IDUM4,IDUM5,IDUM6,IDUM7
      CHARACTER*4 CDUM1
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMSELK(CDUM1,IDUM2,IDUM3,IDUM4,IDUM5,IDUM6)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM2,IDUM3,IDUM4,IDUM5,IDUM6
      CHARACTER*4 CDUM1
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
      SUBROUTINE FMEXST(CDUM1,IDUM1)
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER     IDUM1
      CHARACTER*4 CDUM1
      CHREP  = 'Library compiled with ROSLIM, no FATMEN here!'
      CALL REPORT('FATMEN',1,'F')
      END
*
+PATCH,ROBANK.
+DECK,REV. AVAILABLE IN SEQUENCE ROPAR
*B..REV  ROPE event header bank.
*B.AU    S.O'Neale,F.Meijers,R.Hemmingway,D.Ward,S.Weisz
*B.VE    410
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    64
*B.NL    10
*B.NS    10
*B.NX    None
*B.UP    None
*B.OR    None
*B.LINK
*B.1   EX       External device data
*B.2   UT       General utility data
*B.3   DA       Raw data header
*B.4   CD       Central detector header
*B.5   EC       Electromagnetic calorimeter header
*B.6   HC       Hadron calorimeter header
*B.7   MU       Muon chamber header
*B.8   FO       Forward detector header
*B.9   DDOU     Dense Data bank (outer det)
*B.10  OD       "DST" header
*B/LINK
*B.DATA
*B.1   IHDAT    Data type
*B.1   C1       OPAL experiment data
*B.1   C2       Calibration event
*B.1   C3       Test beam data
*B.1   C4       Cosmic ray data
*B.1   C5       Monte-carlo data
*B.1   C6       DST data
*B.1   C0000105 Calibration constants
*B.1   C0001000 Start of run
*B.1   C0002000 End of run
*B.2   IIEXPT   Experiment number(+1000 MonteCarlo)
*B.3   IIRUN    Run number
*B.4   IIEVT    Trigger number
*B.5   IIBUN    bunchtrain info
*B.5   BITS0007 LEP train number
*B.5   BITS0815 SW bunch train info
*B.5   BITVAL16 unused
*B.5   BITVAL17 ROPE activity flag
*B.5   BITVAL18 ROPE success flag
*B.5   BITVAL19 unused
*B.5   BITS2023 ROPE bunch number
*B.5   BITVAL24 bunchmode flag
*B.5   BITVAL25 FILTER activity flag
*B.5   BITVAL26 FILTER success flag
*B.5   BITVAL27 unused
*B.5   BITS2831 FILTER bunch number (count from 1)
*B.6   IIDETS   Detector status word (Bit string)
*B.6   BITS0001 CV
*B.6   BITS0203 CJ
*B.6   BITS0405 CZ
*B.6   BITS0607 TB
*B.6   BITS0809 PB
*B.6   BITS1011 EB
*B.6   BITS1213 PE
*B.6   BITS1415 EE
*B.6   BITS1617 HT
*B.6   BITS1819 HS
*B.6   BITS2021 HP
*B.6   BITS2223 MB
*B.6   BITS2425 ME
*B.6   BITS2627 FD
*B.6   BITS2829 SI
*B.6   BITS3031 SW
*B.7   IIDAQS   Trigger status word (Bit string)
*B.7   BITS0001 CV
*B.7   BITS0203 CJ
*B.7   BITS0607 TB
*B.7   BITS1011 EB
*B.7   BITS1415 EE
*B.7   BITS1617 HT
*B.7   BITS1819 HS
*B.7   BITS2021 HP
*B.7   BITS2223 MB
*B.7   BITS2425 ME
*B.7   BITS2627 FD
*B.7   BITS3031 SW
*B.8   IITRWD   Trigger Bits  1 -  32
*B.8   BITVAL00 TM1
*B.8   BITVAL01 TM2
*B.8   BITVAL02 TM3
*B.8   BITVAL03 TBM1
*B.8   BITVAL04 TBM2
*B.8   BITVAL05 TBM3
*B.8   BITVAL06 VXH
*B.8   BITVAL07 J1H
*B.8   BITVAL08 J2H
*B.8   BITVAL09 J3H
*B.8   BITVAL10 TPTO2
*B.8   BITVAL11 TOFOR
*B.8   BITVAL12 TOFMANY
*B.8   BITVAL13 MBH
*B.8   BITVAL14 MU
*B.8   BITVAL15 MELR
*B.8   BITVAL16 Quark
*B.8   BITVAL17 Monopol
*B.8   BITVAL18 - unused -
*B.8   BITVAL19 - unused -
*B.8   BITVAL20 EBTOTHI
*B.8   BITVAL21 EELHI
*B.8   BITVAL22 EERHI
*B.8   BITVAL23 - unused -
*B.8   BITVAL24 HA???
*B.8   BITVAL25 HA???
*B.8   BITVAL26 HA???
*B.8   BITVAL27 HA???
*B.8   BITVAL28 HA???
*B.8   BITVAL29 HA???
*B.8   BITVAL30 - unused -
*B.8   BITVAL31 - unused -
*B.9   IITRWC   Trigger Bits 33 -  64
*B.9   BITVAL00 FDSUM
*B.9   BITVAL01 FDSEG
*B.9   BITVAL02 FDHIOR
*B.9   BITVAL03 - unused -
*B.9   BITVAL04 FDSUMA
*B.9   BITVAL05 FDSEGA
*B.9   BITVAL06 FDFAR
*B.9   BITVAL07 FDFARA
*B.9   BITVAL08 - unused
*B.9   BITVAL09 FDSPEC
*B.9   BITVAL10 - unused -
*B.9   BITVAL11 - unused -
*B.9   BITVAL12 BXRSA
*B.9   BITVAL13 LCALLO
*B.9   BITVAL14 RCALLO
*B.9   BITVAL15 EELTPH
*B.9   BITVAL16 EERTPH
*B.9   BITVAL17 EELLO
*B.9   BITVAL18 EERLO
*B.9   BITVAL19 MEL
*B.9   BITVAL20 MER
*B.9   BITVAL21 EBTOTLO
*B.9   BITVAL22 EBTPHI
*B.9   BITVAL23 FDGCLT
*B.9   BITVAL24 FDGCRT
*B.9   BITVAL25 - unused -
*B.9   BITVAL26 TPTTL_1
*B.9   BITVAL27 TPTTR_1
*B.9   BITVAL28 VETOSTAR (CZ)
*B.9   BITVAL29 CJLASER
*B.9   BITVAL30 CV Proportional tubes
*B.9   BITVAL31 BXR
*B.10  IITRWB   Trigger Bits 65 -  94
*B.10  BITVAL00 TPTTTO
*B.10  BITVAL01 TPTTEM
*B.10  BITVAL02 TPTTHA
*B.10  BITVAL03 TPTTMU
*B.10  BITVAL04 TPTOEM
*B.10  BITVAL05 TPTOHA
*B.10  BITVAL06 TPTOMU
*B.10  BITVAL07 TPEMMU
*B.10  BITVAL08 TPHAMU
*B.10  BITVAL09 TOFCOL
*B.10  BITVAL10 - unused -
*B.10  BITVAL11 TPTTB
*B.10  BITVAL12 TPTT1
*B.10  BITVAL13 TPTT2
*B.10  BITVAL14 TPTO1
*B.10  BITVAL15 TPTO2
*B.10  BITVAL16 TPEMB
*B.10  BITVAL17 TPEM1
*B.10  BITVAL18 TPEM2
*B.10  BITVAL19 TPHAB
*B.10  BITVAL20 TPHA1
*B.10  BITVAL21 TPHA2
*B.10  BITVAL22 TPMUB
*B.10  BITVAL23 TPMU1
*B.10  BITVAL24 TPMU2
*B.10  BITVAL25 - unused -
*B.10  BITVAL26 TPTTL
*B.10  BITVAL27 TPTTR
*B.10  BITVAL28 TPEML
*B.10  BITVAL29 TPEMR
*B.10  BITVAL30 TPHAL
*B.10  BITVAL31 TPHAR
*B.11  IITRWA   Trigger Bits 95 - 132
*B.11  BITVAL00 TPMUL
*B.11  BITVAL01 TPMUR
*B.11  BITVAL02 - unused -
*B.11  BITVAL03 - unused -
*B.11  BITVAL04 - unused -
*B.11  BITVAL05 - unused -
*B.11  BITVAL06 TPHACL
*B.11  BITVAL07 TPTTCL
*B.11  BITVAL08 TPEMCL
*B.11  BITVAL09 - unused -
*B.11  BITVAL10 - unused -
*B.11  BITVAL11 - unused -
*B.11  BITVAL12 - unused -
*B.11  BITVAL13 - unused -
*B.11  BITVAL14 - unused -
*B.11  BITVAL15 - unused -
*B.11  BITVAL16 - unused -
*B.11  BITVAL17 - unused -
*B.11  BITVAL18 - unused -
*B.11  BITVAL19 - unused -
*B.11  BITVAL20 - unused -
*B.11  BITVAL21 - unused -
*B.11  BITVAL22 - unused -
*B.11  BITVAL23 - unused -
*B.11  BITVAL24 bit0 of TR event type ( 1=physics,2=pedestal,  )
*B.11  BITVAL25 bit1 of TR event type ( 4=cosmic,              )
*B.11  BITVAL26 bit2 of TR event type ( 7=random software,     )
*B.11  BITVAL27 bit3 of TR event type ( 8=physics off          )
*B.11  BITVAL28 Full-Readout
*B.11  BITVAL29 DAQ test trigger
*B.11  BITVAL30 bad detector status from Pattern Unit
*B.11  BITVAL31 - unused -
*B.12  IIFITY   Filter type (Bit string)
*B.12  BITVAL00 Sum E(clus) > 2 GeV
*B.12  BITVAL01 E(EB cls/blk) > 200MeV
*B.12  BITVAL02 E(Cluster 1) > 1 GeV
*B.12  BITVAL03 Clusters in L and R endcap > 200 MeV
*B.12  BITVAL04 Lumi Event
*B.12  BITVAL15 All Trigger validated
*B.12  BITVAL16 SOME Trigger validated
*B.12  BITVAL17  No special trigger
*B.12  BITVAL18 Event failed global selection
*B.12  BITVAL19 Event rejected
*B.12  BITVAL20 Acc lumi
*B.12  BITVAL23 Loose MH
*B.12  BITVAL24 Lepton preselection
*B.12  BITVAL25 GpMH
*B.12  BITVAL26 Gp Lumi Bhabba
*B.12  BITVAL27 Gp e+e-, gamma-gamma
*B.12  BITVAL28 Gp mu-mu
*B.12  BITVAL29 Gp tau-tau
*B.13  IIEVTY   First Event Type word (ROPE, Bit string)
*B.13  BITVAL00 IELUET: "Etotbar" calorimeter selection
*B.13  BITVAL01 IELUEM: "Emainbar" calorimeter selection
*B.13  BITVAL02 IELUCU: "CUBED" calorimeter + prop tubes + drift chamber seln.
*B.13  BITVAL03 IELLLM: Low multiplicity preselection
*B.13  BITVAL04 IELLQQ: High multiplicity veto
*B.13  BITVAL05 IELLCO: Cosmic ray veto
*B.13  BITVAL06 IELLFO: For official use only
*B.13  BITVAL07 IEGAM : Single photon preselection    (RGAM)
*B.13  BITVAL08 IEGCON: Converted photon preselection (RPHCON)
*B.13  BITVAL09 IEHLPT: Missing energy selection
*B.13  BITVAL10 IEHLIS: Isolated track selection
*B.13  BITVAL11 IETWOP: Tagged two photon preselection (RTWOPH)
*B.13  BITVAL12 IEHIGS: Higgs group high multiplicity preselection (RHSEL)
*B.13  BITVAL13 IEGSTR: Validated special single photon triggered events(RSPTRG)
*B.13  BITVAL14 IEHLCM: Close-mass heavy lepton selection
*B.13  BITVAL15 IETKMH: Tokyo group multihadron selection (RMHSEL)
*B.13  BITVAL16 IEFDTR: Validated forward detector triggered events (RTRGFD)
*B.13  BITVAL17 IELLEE: Electron pair classification
*B.13  BITVAL18 IELLMM: Muon pair classification
*B.13  BITVAL19 IELLTT: Tau pair classification
*B.13  BITVAL20 IELLLL: Lepton pair classification
*B.13  BITVAL21 IEGVMU: Single photon muon veto       (RGAM)
*B.13  BITVAL22 IEGVBW: Single photon beam-wall veto  (RGAM)
*B.13  BITVAL23 IEGEMT: EM cluster and associated TOF preselection (RGTOEM)
*B.13  BITVAL24 IEGTOE: EM and TOF criteria of IEGEMT preselection (RGTOEM)
*B.13  BITVAL25 IEGGT0: In-time TOF counter                        (RGTOEM)
*B.13  BITVAL26 IEGEM : EM cluster, N(block)>1, without vetoes, selection(RGEM)
*B.13  BITVAL27 IEGGTR: High pT track (only NHCJ and pT cut)       (RGTOEM)
*B.13  BITVAL28 IETRIG: Selections of other special triggers (RTRIGS)
*B.13  BITVAL29 IEGHOK: Single photon pre-selection with no HCAL or MUON veto
*B.13  BITVAL30 IEGLLD: Track selection for long-lived decays - no d0 cuts
*B.13  BITVAL31 IEFYZ1: "Phys1" selection of events for the DST farm (ROEVTY)
*B.14  IIEVT2   Second Event Type word (ROPE, Bit string)
*B.14  BITVAL00 IEFYZS: Z0 type physics (ROEVTY)
*B.14  BITVAL01 IEFYZT: lumi type physics (ROEVTY)
*B.14  BITVAL02 IEPRSC: event not processed by Online ROPE at the pit (prescaling)
*B.14  BITVAL03 IESWIA: two ADC clusters match with average theta cut
*B.14  BITVAL04 IESWIR: ADC cluster / in-time trigger cluster match, right
*B.14  BITVAL05 IESWOR: ADC cluster / out-of-time trigger cluster match, right
*B.14  BITVAL06 IESWIL: ADC cluster / in-time trigger cluster match, left
*B.14  BITVAL07 IESWOL: ADC cluster / out-of-time trigger cluster match, left
*B.14  BITVAL08 IETETR: scaled-down MEL.MER trigger for a TE calibration study
*B.14  BITVAL09 IEGACE: Chargino - General ACoplanar Event
*B.14  BITVAL10 IELMAE: Chargino - Low Multiplicity Acoplanar Event
*B.14  BITVAL11 IEMONO: Chargino - MONOJET type event
*B.14  BITVAL12 IEGOPL: Chargino - gold plated GACE,LMAE or MONO
*B.15  IIDATE   Date of event
*B.16  IITIME   Time of event
*B.17  IIPVER   Processing version number (ROPE)
*B.18  IINCTR   Number of CT tracks
*B.19  IIECAL   Total Electromagnetic Energy
*B.20  IIHCAL   Total Hadronic Energy
*B.21  IINMUO   Number of Muon Segments
*B.22  IINVTX   Number of Vertices
*B.23  IIEBEA   Nominal Beam Energy
*B.24  IIFILL   Fill number
*B.25  IITAPE   Original Raw data cartridge
*B.26  IIRECI   Record on Raw data cartridge
*B.27  IIPROD   Output Prod cartridge
*B.28  IIRECO   Record on Prod output cartridge
*B.29  IICDAT   Date of last update of OPCAL database
*B.30  IICTIM   Time of last update of OPCAL database
*B.31  IISULM   Date of last update of SU
*B.32  IIDAQS   Data acquisition status word  (Bit string)
*B.33  IIFIDD   Filter dense data status word (Bit string)
*B.34  IIFIST   Filter status word            (Bit string)
*B.35  IIROST   ROPE status word              (Bit string)
*B.36  IITHRU   Thrust * 10000
*B.37  IICTHR   Cosine of the thrust axis * 10000
*B.38  IIMEPX   x-component of missing energy vector (MeV)
*B.39  IIMEPY   y-component of missing energy vector (MeV)
*B.40  IIMEPZ   z-component of missing energy vector (MeV)
*B.41  IINCT    Number of good charged tracks
*B.42  IISCT    Scalar sum of good charged track momenta (MeV)
*B.43  IINEB    Number of good EB clusters
*B.44  IISEB    Sum of good EB cluster energy            (MeV)
*B.45  IINEE    Number of good EE clusters
*B.46  IISEE    Sum of good EE cluster energy            (MeV)
*B.47  IINHT    Number of good tower clusters (HB+HE)
*B.48  IISHT    Sum of good tower cluster energy (HB+HE) (MeV)
*B.49  IINHPT   Number of good HP tower clusters
*B.50  IISHPT   Sum of good HP tower cluster energy      (MeV)
*B.51  IISHS    Sum of strip cluster energy (HB+HE)      (MeV)
*B.52  IISHPS   Sum of HP strip cluster energy           (MeV)
*B.53  IISFE    Sum of FD gamma catchers cluster energy  (MeV)
*B.54  IISFK    Sum of FD calorimeters cluster energy    (MeV)
*B.55  IIPRTA   Pretrigger bit pattern  part I
*B.56  IIPRTB   Pretrigger bit pattern  part II
*B.57  IIVERN   Vernier scan info
*B.57  BITVAL00     Vernier scan somewhere active
*B.57  BITVAL01     Vernier scan in IP6 active
*B.57  BITVAL02     Vernier setting stable
*B.57  BITS0815     Vernier scaler
*B.57  BITS1631     reserved for ROPE
*B.58  IIEVLG   Event length
*B.59  IIDET1   detector status 2nd word
*B.59  BITS0001 TE
*B.60  IITRG1   trigger status 2nd word
*B.60  BITS0001 TE
*B.61  IITRPU   trigger pattern unit
*B.62  IIPDDF   miscelleneous Pretrigger information
*B.63  IIPPSF   Pretrigger Pam Scale Factors
*B.63  BITS0015 PPSF word 1
*B.63  BITS1631 PPSF word 2
*B.64  NOTUSED
*B/DATA
*B/
+DECK,EX.  AVAILABLE IN SEQUENCE ROPAR
*B..EX   External device data header.
*B.AU    S.Weisz,D.R.Ward
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    REV  -1
*B.OR    REV  -1
*B.LINK
*B.1   TRIG     Trigger information (might go in RA - 15)
*B.2   MC       Original Kinematics for MC data
*B.3   LEP      LEP machine data (slow control, might go in RA - 16)
*B/LINK
*B.DATA
*B.1   ITRIG    Trigger flag
*B.2   IFMC     MC flag
*B.3   IFLEP    LEP machine flag
*B/DATA
*B/
*B..EXTR Expanded tree
*B.AU    O.S.
*B.NL    NSEC
*B.NS    NSEC
*B.ND    20
*B.NX    None
*B.UP    GENE
*B.OR    TREE
*B.IO    32H
*B.DATA
*B.REP   ND
*B.1     TEXT
*B/REP
*B/DATA
*B/
*B..EXT1 HID@D(23:24) TITLE@D(25:30) NID@D(31:34) ND@D(35:39)
*B.AU    S.L.L + O.S.
*B.NL    NSEC
*B.NS    NSEC
*B.ND    40
*B.NX    None
*B.UP    EXTR -1
*B.OR    EXTR -1
*B.IO    10I 12F -H
*B.DATA
*B.1   ITRTY    Particle Data Group particle code
*B.1 C1   d
*B.1 C2   u
*B.1 C3   s
*B.1 C4   c
*B.1 C5   b
*B.1 C6   t
*B.1 C7   l
*B.1 C8   h
*B.1 C11  e-
*B.1 C12  nu_e
*B.1 C13  mu-
*B.1 C14  nu_mu
*B.1 C15  tau-
*B.1 C16  nu_tau
*B.1 C17  chi-
*B.1 C18  nu_chi
*B.1 C21  gluon
*B.1 C22  gamma
*B.1 C23  Z0
*B.1 C24  W+
*B.1 C25  H0
*B.1 C32  Z'0
*B.1 C33  Z"0
*B.1 C34  W'+
*B.1 C35  H'0
*B.1 C36  A0
*B.1 C37  H+
*B.1 C39  LQ
*B.1 C40  R0
*B.1 C211 pi+
*B.1 C213 rho+
*B.1 C311 K0
*B.1 C313 K*0
*B.1 C321 K+
*B.1 C323 K*+
*B.1 C411 D+
*B.1 C413 D*+
*B.1 C421 D0
*B.1 C423 D*0
*B.1 C431 D_s+
*B.1 C433 D*_s+
*B.1 C511 B0
*B.1 C513 B*0
*B.1 C521 B+
*B.1 C523 B*+
*B.1 C531 B_s0
*B.1 C533 B*_s0
*B.1 C111 pi0
*B.1 C113 rho0
*B.1 C221 eta
*B.1 C223 omega
*B.1 C331 eta'
*B.1 C333 phi
*B.1 C441 eta_c
*B.1 C443 J/psi
*B.1 C551 eta_b
*B.1 C553 Upsilon
*B.1 C661 eta_t
*B.1 C663 Theta
*B.1 C130 K_L0
*B.1 C310 K_S0
*B.1 C10213  b_1+
*B.1 C10211  a_0+
*B.1 C10313  K_10
*B.1 C10311  K*_00
*B.1 C10323  K_1+
*B.1 C10321  K*_0+
*B.1 C10413  D_1+
*B.1 C10411  D*_0+
*B.1 C10423  D_10
*B.1 C10421  D*_00
*B.1 C10433  D_1s+
*B.1 C10431  D*_0s+
*B.1 C10113  b_10
*B.1 C10111  a_00
*B.1 C10223  h_10
*B.1 C10221  f_00
*B.1 C10333  h'_10
*B.1 C10331  f'_00
*B.1 C10443  h_1c0
*B.1 C10441  chi_0c0
*B.1 C20213  a_1+
*B.1 C215    a_2+
*B.1 C20313  K*_10
*B.1 C315    K*_ 20
*B.1 C20323  K*_1+
*B.1 C325    K*_2+
*B.1 C20413  D*_1+
*B.1 C415    D*_ 2+
*B.1 C20423  D*_10
*B.1 C425    D*_20
*B.1 C20433  D*_1s+
*B.1 C435    D*_2s+
*B.1 C20113  a_10
*B.1 C115    a_20
*B.1 C20223  f_10
*B.1 C225    f_20
*B.1 C20333  f'_10
*B.1 C335    f'20
*B.1 C20443  chi_1c0
*B.1 C445    chi_2c0
*B.1 C1114   Delta-
*B.1 C2112   n
*B.1 C2114   Delta0
*B.1 C2212   p
*B.1 C2214   Delta+
*B.1 C2224   Delta++
*B.1 C3112   Sigma-
*B.1 C3114   Sigma*-
*B.1 C3122   Lambda0
*B.1 C3212   Sigma0
*B.1 C3214   Sigma*0
*B.1 C3222   Sigma+
*B.1 C3224   Sigma*+
*B.1 C3312   Xi-
*B.1 C3314   Xi*-
*B.1 C3322   Xi0
*B.1 C3324   Xi*0
*B.1 C3334   Omega-
*B.1 C4112   Sigma_c0
*B.1 C4114   Sigma*_c0
*B.1 C4122   Lambda_c+
*B.1 C4212   Sigma_c+
*B.1 C4214   Sigma*_c+
*B.1 C4222   Sigma_c++
*B.1 C4224   Sigma*_c++
*B.1 C4132   Xi_c0
*B.1 C4312   Xi'_c0
*B.1 C4314   Xi*_c0
*B.1 C4232   Xi_c+
*B.1 C4322   Xi'_c+
*B.1 C4324   Xi*_c+
*B.1 C4332   Omega_c0
*B.1 C4334   Omega*_c0
*B.1 C5112   Sigma_b-
*B.1 C5114   Sigma*_b-
*B.1 C5122   Lambda_b0
*B.1 C5212   Sigma_b0
*B.1 C5214   Sigma*_b0
*B.1 C5222   Sigma_b+
*B.1 C5224   Sigma*_b+
*B.1 C-1   d
*B.1 C-2   u
*B.1 C-3   s
*B.1 C-4   c
*B.1 C-5   b
*B.1 C-6   t
*B.1 C-7   l
*B.1 C-8   h
*B.1 C-11  e-
*B.1 C-12  nu_e
*B.1 C-13  mu-
*B.1 C-14  nu_mu
*B.1 C-15  tau-
*B.1 C-16  nu_tau
*B.1 C-17  chi-
*B.1 C-18  nu_chi
*B.1 C-21  gluon
*B.1 C-22  gamma
*B.1 C-23  Z0
*B.1 C-24  W+
*B.1 C-25  H0
*B.1 C-32  Z'0
*B.1 C-33  Z"0
*B.1 C-34  W'+
*B.1 C-35  H'0
*B.1 C-36  A0
*B.1 C-37  H+
*B.1 C-39  LQ
*B.1 C-40  R0
*B.1 C-211 pi+
*B.1 C-213 rho+
*B.1 C-311 K0
*B.1 C-313 K*0
*B.1 C-321 K+
*B.1 C-323 K*+
*B.1 C-411 D+
*B.1 C-413 D*+
*B.1 C-421 D0
*B.1 C-423 D*0
*B.1 C-431 D_s+
*B.1 C-433 D*_s+
*B.1 C-511 B0
*B.1 C-513 B*0
*B.1 C-521 B+
*B.1 C-523 B*+
*B.1 C-531 B_s0
*B.1 C-533 B*_s0
*B.1 C-111 pi0
*B.1 C-113 rho0
*B.1 C-221 eta
*B.1 C-223 omega
*B.1 C-331 eta'
*B.1 C-333 phi
*B.1 C-441 eta_c
*B.1 C-443 J/psi
*B.1 C-551 eta_b
*B.1 C-553 Upsilon
*B.1 C-661 eta_t
*B.1 C-663 Theta
*B.1 C-130 K_L0
*B.1 C-310 K_S0
*B.1 C-10213  b_1+
*B.1 C-10211  a_0+
*B.1 C-10313  K_10
*B.1 C-10311  K*_00
*B.1 C-10323  K_1+
*B.1 C-10321  K*_0+
*B.1 C-10413  D_1+
*B.1 C-10411  D*_0+
*B.1 C-10423  D_10
*B.1 C-10421  D*_00
*B.1 C-10433  D_1s+
*B.1 C-10431  D*_0s+
*B.1 C-10113  b_10
*B.1 C-10111  a_00
*B.1 C-10223  h_10
*B.1 C-10221  f_00
*B.1 C-10333  h'_10
*B.1 C-10331  f'_00
*B.1 C-10443  h_1c0
*B.1 C-10441  chi_0c0
*B.1 C-20213  a_1+
*B.1 C-215    a_2+
*B.1 C-20313  K*_10
*B.1 C-315    K*_ 20
*B.1 C-20323  K*_1+
*B.1 C-325    K*_2+
*B.1 C-20413  D*_1+
*B.1 C-415    D*_ 2+
*B.1 C-20423  D*_10
*B.1 C-425    D*_20
*B.1 C-20433  D*_1s+
*B.1 C-435    D*_2s+
*B.1 C-20113  a_10
*B.1 C-115    a_20
*B.1 C-20223  f_10
*B.1 C-225    f_20
*B.1 C-20333  f'_10
*B.1 C-335    f'20
*B.1 C-20443  chi_1c0
*B.1 C-445    chi_2c0
*B.1 C-1114   Delta-
*B.1 C-2112   n
*B.1 C-2114   Delta0
*B.1 C-2212   p
*B.1 C-2214   Delta+
*B.1 C-2224   Delta++
*B.1 C-3112   Sigma-
*B.1 C-3114   Sigma*-
*B.1 C-3122   Lambda0
*B.1 C-3212   Sigma0
*B.1 C-3214   Sigma*0
*B.1 C-3222   Sigma+
*B.1 C-3224   Sigma*+
*B.1 C-3312   Xi-
*B.1 C-3314   Xi*-
*B.1 C-3322   Xi0
*B.1 C-3324   Xi*0
*B.1 C-3334   Omega-
*B.1 C-4112   Sigma_c0
*B.1 C-4114   Sigma*_c0
*B.1 C-4122   Lambda_c+
*B.1 C-4212   Sigma_c+
*B.1 C-4214   Sigma*_c+
*B.1 C-4222   Sigma_c++
*B.1 C-4224   Sigma*_c++
*B.1 C-4132   Xi_c0
*B.1 C-4312   Xi'_c0
*B.1 C-4314   Xi*_c0
*B.1 C-4232   Xi_c+
*B.1 C-4322   Xi'_c+
*B.1 C-4324   Xi*_c+
*B.1 C-4332   Omega_c0
*B.1 C-4334   Omega*_c0
*B.1 C-5112   Sigma_b-
*B.1 C-5114   Sigma*_b-
*B.1 C-5122   Lambda_b0
*B.1 C-5212   Sigma_b0
*B.1 C-5214   Sigma*_b0
*B.1 C-5222   Sigma_b+
*B.1 C-5224   Sigma*_b+
*B.2   ITRPAR   Number of parent in tree
*B.3   ITRFSEC  Number of first secondary in tree
*B.4   ITRNSEC  Number of secondaries
*B.5   ITRNDST  Track number in DST structure
*B.6   ITRNJET  Jet number
*B.7   ITRKINE  Number of KINE bank for this particle
*B.8   MIXFLAG  Mixing flag
*B.8   C1       Mixed
*B.9   ITRSTAR  Start flag
*B.9   C0000000 Initial state photon
*B.9   C0000001 Primary particle
*B.9   C0000002 Decay product in generator
*B.9   C0000003 Transfered from GEANT stack
*B.9   C0000004 Unknown
*B.9   C0000005 Decay product in GEANT
*B.9   C0000006 Pair production
*B.9   C0000007 Compton
*B.9   C0000008 Photoelectric
*B.9   C0000009 Bremsstrahlung
*B.9   C0000010 Delta ray
*B.9   C0000011 Positron annihilation
*B.9   C0000012 Hadronic interaction
*B.10  ITREND   End flag
*B.10  C0000001 Neutral and still alive
*B.10  C0000002 Charged and still alive
*B.10  C-000001 Decayed in generator
*B.10  C-000005 Decay product in GEANT
*B.10  C-000006 Pair production
*B.10  C-000007 Compton
*B.10  C-000008 Photoelectric
*B.10  C-000009 Bremsstrahlung
*B.10  C-000010 Delta ray
*B.10  C-000011 Positron annihilation
*B.10  C-000012 Hadronic interaction
*B.11  TRPX     Px
*B.12  TRPY     Py
*B.13  TRPZ     Pz
*B.14  TRE      Energy
*B.15  TRM      Mass
*B.16  TRCH     Charge
*B.17  TRSX     Start x
*B.18  TRSY     Start y
*B.19  TRSZ     Start z
*B.20  TREX     End x
*B.21  TREY     End y
*B.22  TREZ     End z
*B.23  Name
*B.24  Name
*B.25  Start
*B.26  Start
*B.27  Start
*B.28  End
*B.29  End
*B.30  End
*B.31  P
*B.32  P
*B.33  P
*B.34  P
*B.35  Range
*B.36  Range
*B.37  Range
*B.38  Range
*B.39  Range
*B.40  Notused
*B/DATA
*B/
*B..EXT1 HID@D(23:24) TITLE@D(25:30) NID@D(31:34) ND@D(35:39)
*B.UP     EXT1
*B.IDEM   EXTR
*B/
*B..EXJE Expanded JETS
*B.AU    O.S.
*B.NL    NSEC
*B.NS    NSEC
*B.ND    20
*B.NX    None
*B.UP    GENE
*B.OR    TREE
*B.IO    32H
*B.DATA
*B.REP   ND
*B.1     TEXT
*B/REP
*B/DATA
*B/
*B..EXJ1 HID@D(9:10) TITLE@D(11:16) NID@D(17:20) ND@D(21:25)
*B.AU    S.L.L + O.S.
*B.NL    NSEC
*B.NS    NSEC
*B.ND    26
*B.NX    None
*B.UP    EXJE -1
*B.OR    EXJE -1
*B.IO    10I 12F -H
*B.DATA
*B.1   ITRTY     Flavour PDG code
*B.1 C1   d
*B.1 C2   u
*B.1 C3   s
*B.1 C4   c
*B.1 C5   b
*B.1 C6   t
*B.1 C7   l
*B.1 C8   h
*B.1 C11  e-
*B.1 C12  nu_e
*B.1 C13  mu-
*B.1 C14  nu_mu
*B.1 C15  tau-
*B.1 C16  nu_tau
*B.1 C17  chi-
*B.1 C18  nu_chi
*B.1 C21  gluon
*B.1 C22  gamma
*B.1 C23  Z0
*B.1 C24  W+
*B.1 C25  H0
*B.1 C32  Z'0
*B.1 C33  Z"0
*B.1 C34  W'+
*B.1 C35  H'0
*B.1 C36  A0
*B.1 C37  H+
*B.1 C39  LQ
*B.1 C40  R0
*B.2  I Parent number in JETS
*B.3  I Parent number in TREE
*B.4  R Px
*B.5  R Py
*B.6  R Pz
*B.7  R Energy
*B.8  R Mass
*B.9   Name
*B.10  Name
*B.11  jetnr, comment
*B.12  jetnr, comment
*B.13  jetnr, comment
*B.14  jetnr, comment
*B.15  jetnr, comment
*B.16  jetnr, comment
*B.17  P, Phi
*B.18  P, Phi
*B.19  P, Phi
*B.20  P, Phi
*B.21  energy,mass
*B.22  energy,mass
*B.23  energy,mass
*B.24  energy,mass
*B.25  energy,mass
*B.26  Notused
*B/DATA
*B/
*B..EXJ1 HID@D(9:10) TITLE@D(11:16) NID@D(17:20) ND@D(21:25)
*B.UP     EXJ1
*B.IDEM   EXJE
*B/
+DECK,UT.  AVAILABLE IN SEQUENCE ROPAR
*B..UT   Utility header bank.
*B.AU    D.R.Ward,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    0
*B.NL    1
*B.NS    1
*B.NX    None
*B.UP    REV  -2
*B.OR    REV  -2
*B.LINK
*B.1 REHE  Report header bank for event.
*B/LINK
*B/
+DECK,REHE.
*B..REHE REPORT header bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    6
*B.NL    6
*B.NS    6
*B.NX    None
*B.UP    UT   -1
*B.OR    UT   -1
*B.LINK
*B.1 RSUE       Success report bank associated to event structure.
*B.2 RINE       Information report bank associated to event structure.
*B.3 RWAE       Warning report bank associated to event structure.
*B.4 RERE       Error report bank associated to event structure.
*B.5 RFAE       Fatal report bank associated to event structure.
*B.6 RCRE       Crash report bank associated to event structure.
*B/LINK
*B.DATA
*B.1 NRSUE      Nb success report bank associated to event structure.
*B.2 NRINE      Nb information report bank associated to event structure.
*B.3 NRWAE      Nb Warning report bank associated to event structure.
*B.4 NRERE      Nb Error report bank associated to event structure.
*B.5 NRFAE      Nb Fatal report bank associated to event structure.
*B.6 NRCRE      Nb Crash report bank associated to event structure.
*B/DATA
*B/
+DECK,RSUE.
*B..RSUE Succes report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RSUE
*B.UP    REHE -1
*B.OR    REHE -1
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RINE.
*B..RINE Information report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RINE
*B.UP    REHE -2
*B.OR    REHE -2
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RWAE.
*B..RWAE Warning report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RWAE
*B.UP    REHE -3
*B.OR    REHE -3
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RERE.
*B..RERE Error report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RERE
*B.UP    REHE -4
*B.OR    REHE -4
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RFAE.
*B..RFAE Fatal report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RFAE
*B.UP    REHE -5
*B.OR    REHE -5
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RCRE.
*B..RCRE Crash report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RCRE
*B.UP    REHE -6
*B.OR    REHE -6
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,DA.  AVAILABLE IN SEQUENCE ROPAR
*B..DA   Raw Data Header Bank.
*B.AU    S.Weisz
*B.VE    404
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    22
*B.NL    22
*B.NS    22
*B.NX    None
*B.UP    REV  -3
*B.OR    REV  -3
*B.LINK
*B.1   CVRA     Vertex detector raw data
*B.2   CJRA     Jet Chamber raw data
*B.3   CZRA     Zed Chamber raw data
*B.4   TBRA     Time of Flight raw data
*B.5   PBRA     Presampler Barrel raw data
*B.6   EBRA     Lead glass Barrel raw data
*B.7   PERA     Presampler Endcap raw data
*B.8   EERA     Lead glass Endcap raw data
*B.9   HTRA     Hadron barrel raw data
*B.10  HSRA     Hadron endcap raw data
*B.11  HPRA     Hadron poletip raw data
*B.12  MBRA     Muon barrel raw data
*B.13  MERA     Muon endcap raw data
*B.14  FDRA     Forward detector raw data
*B.15  TRRA     Trigger information
*B.16  TTRA     Track trigger information
*B.17  SCRA     Slow control information
*B.18  FIRA     Filter information
*B.29  GNRA     Genaral data (not used)
*B.20  SIRA     Silicon Microvertex data
*B.22  SWRA     Silicon Tungsten data
*B/LINK
*B.DATA
*B.1   FCVRA    Vertex detector raw data flag
*B.2   FCJRA    Jet Chamber raw data flag
*B.3   FCZRA    Zed Chamber raw data flag
*B.4   FTBRA    Time of Flight raw data flag
*B.5   FPBRA    Presampler Barrel raw data flag
*B.6   FEBRA    Lead glass Barrel raw data flag
*B.7   FPERA    Presampler Endcap raw data flag
*B.8   FEERA    Lead glass Endcap raw data flag
*B.9   FHTRA    Hadron barrel raw data flag
*B.10  FHSRA    Hadron endcap raw data flag
*B.11  FHPRA    Hadron poletip raw data flag
*B.12  FMBRA    Muon barrel raw data flag
*B.13  FMERA    Muon endcap raw data flag
*B.14  FFDRA    Forward detector raw data flag
*B.15  FTRRA    Trigger information flag
*B.16  FTTRA    Track trigger information flag
*B.17  FSCRA    Slow control information flag
*B.18  FFIRA    Filter information flag
*B.29  GNRA     Genaral data flag (not used)
*B.20  SIRA     Silicon Microvertex raw data flag
*B.22  SWRA     Silicon Tungsten raw data flag
*B/DATA
*B/
*B..SCRA  Slow control information
*B.AU     H. Burckhart
*B.VE     2.10
*B.ND     39
*B.NS     0
*B.NL     0
*B.IO     I
*B.UP     DA
*B.DATA
*B.1      DAY        Day when data where recorded  (YYMMDD)
*B.2      TIME       Time when data where recorded  (HHMMSS)
*B.3      BFIELD     Field of OPAL magnet (Hall pr. EE left) [1/10 Gauss]
*B.4      CURRENT    Current of OPAL magnet (rectifier) [1/10 A]
*B.5      ATMPRESS   Atmospheric pressure UX6 [1/10 mbar]
*B.6      WTEMPGO4   Temperature of cooling water in GO4 [1/10 C]
*B.7      ATEMPGO4   Ambient temperature GO4 [1/10 C]
*B.8      ATEMPUX6   Ambient temperature UX6 near GO4 [1/10 C]
*B.9      MVOLTGO4   Mains voltage GO4 Phase R [1/10 V]
*B.10     GASDENS    Gas Density CJ [10E-6 bar/K]
*B.11     MEVOLT     High Voltage ME [Volt]
*B.12     OPALHALL   OPAL Magnetic Field (Central Hallprobe) [1/10 Gauss]
*B.13     OPALNMR    OPAL Magnetic Field (NMR) [mGauss]
*B.14     LEPNOME    LEP Energy (nominal) [MeV]
*B.15     LEPHALLE   LEP Energy (Hallprobe) [MeV]
*B.16     LEPFLIPE   LEP Energy (Flip Coil) [MeV]
*B.17     LEPEPLC    LEP e+ Beam Current [microAmpere]
*B.18     LEPEMIC    e- Beam Current [microAmpere]
*B.19     LEPPBPX    LEP e+ Beam Position x at z=0 [micrometer]
*B.20     LEPPBAY    LEP e+ Beam Angle x' at z=0 [microrad]
*B.21     LEPPBPY    LEP e+ Beam Position y at z=0 [micrometer]
*B.22     LEPPBAY    LEP e+ Beam Angle y' at z=0 [microrad]
*B.23     LEPPQFX    LEP Quality of e+ fit, X
*B.24     LEPPQFY    LEP Quality of e+ fit, Y
*B.25     LEPMBPX    LEP e- Beam Position x at z=0 [micrometer]
*B.26     LEPMBAX    LEP e- Beam Angle x' at z=0 [microrad]
*B.27     LEPMBPY    LEP e- Beam Position y at z=0 [micrometer]
*B.28     LEPMBAY    LEP e- Beam Angle y' at z=0 [microrad]
*B.29     LEPMQFX    LEP Quality of e- fit, X
*B.30     LEPMQFY    LEP Quality of e- fit, Y
*B.31     X_PLUS4    e+ Pos. x [1/100mm] at z=+6201mm (raw d) +-5000 XPU
*B.32     X_PLUS5    e+ Pos. x [1/100mm] at z=-6100mm (raw d) +-5000 XPU
*B.33     Y_PLUS4    e+ Pos. y [1/100mm] at z=+6201mm (raw d) +-5000 YPU
*B.34     Y_PLUS5    e+ Pos. y [1/100mm] at z=-6100mm (raw d) +-5000 YPU
*B.35     X_MINUS4   e- Pos. x [1/100mm] at z=+6201mm (raw d) +-5000 XPU
*B.36     X_MINUS5   e- Pos. x [1/100mm] at z=-6100mm (raw d) +-5000 XPU
*B.37     Y_MINUS4   e- Pos. y [1/100mm] at z=+6201mm (raw d) +-5000 YPU
*B.38     Y_MINUS5   e- Pos. y [1/100mm] at z=-6100mm (raw d) +-5000 YPU
*B.39     XXX        reserved
*B/DATA
*B/
+DECK,CD.  AVAILABLE IN SEQUENCE ROPAR
*B..CD   Central Detector Processing Bank.
*B.AU    S.Weisz
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    11
*B.NL    8
*B.NS    8
*B.NX    None
*B.UP    REV  -4
*B.OR    REV  -4
*B.LINK
*B.1   CV       Vertex Chamber Processing Bank
*B.2   CJ       Jet Chamber Processing Bank
*B.3   CZ       Z Chamber Processing Bank
*B.4   CT       CD Track Header Bank
*B.5   DX       De/Dx Header Bank
*B.6   CF       CD "fake" tracks and vertex Header Bank
*B.7   CX       CD Vertex Header Bank
*B.8   SI       Silicon Microvertex Processing bank
*B/LINK
*B.DATA
*B.1   FCV      Flag for CV Process
*B.2   FCX      Flag for CX Process
*B.3   FCZ      Flag for CZ Process
*B.4   FCT      Flag for CT Process
*B.5   FDX      Flag for DX Process
*B.6   FCF      Flag for CF Process
*B.7   FCX      Flag for CX Process
*B.8   FSI      Flag for SI Process
*B.9   FCS      Flag for CS Process
*B.10  FCE      Flag for CE Process
*B.11  FCA      Flag for CA Process
*B/DATA
*B/
+DECK,CF.  AVAILABLE IN SEQUENCE CFPAR
*B..CF   "FAKE" Tracks and Vertex Header Bank.
*B.AU    S.Weisz,A.McPherson,S.Lloyd
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    2
*B.NL    2
*B.NS    2
*B.NX    None
*B.UP    CD   -6
*B.OR    CD   -6
*B.LINK
*B.1   CFT      Fake Tracks Information Bank
*B.2   CFX      Fake Vertices Information Bank
*B/LINK
*B.DATA
*B.1   FCFT     Flag for Fake Tracks
*B.2   FCFX     Flag for Fake Vertices
*B/DATA
*B/
+DECK,CFT. AVAILABLE IN SEQUENCE CFPAR
*B..CFT  "FAKE" Tracks Header Bank.
*B.AU    S.Weisz,A.McPherson,S.Lloyd
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    *
*B.NS    *
*B.NX    None
*B.UP    CF   -1
*B.OR    CF   -1
*B.LINK
*B.REP NCFT
*B.1   CFTS     Main track parameters
*B/REP
*B/LINK
*B.DATA
*B.1   NCFT     Number of "fake" tracks
*B.REP NCFT
*B.2   FCFTS    Flag for "fake" track
*B/REP
*B/DATA
*B/
+DECK,CFTS.AVAILABLE IN SEQUENCE CFPAR
*B..CFTS Essential "Fake" Track Information Bank.
*B.AU    S.Weisz,A.McPherson,S.Lloyd
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    40
*B.NL    5
*B.NS    5
*B.NX    None
*B.UP    CFT  -Track#
*B.OR    CFT  -Track#
*B.LINK
*B.1   CFTH     Hit pointers (Not used for CF)
*B.2   CFTR     Residuals    (Not used for CF)
*B.3   CFTX     Track end point information
*B.4   CFTI     Track identification
*B.5   CFTE     Track extrapolation
*B/LINK
*B.DATA
*B.1   CFTTC    Track Code
*B.2   CFTSC    Sub Code (cathode cross,etc. need definition)
*B.3   CFTFC    Fit Type (need definition)
*B.4   CFTNH    Total Number of Hits
*B.5   CFTNV    Number of CV Hits
*B.6   CFTNJ    Number of CJ Hits
*B.7   CFTNZ    Number of CZ Hits
*B.8   CFTID    Assumed Particle Type (GEANT Code)
*B.9   ????     Spare
*B.10  CFTNP    Number of track parameters
*B.11  CFTCU    Curvature (Signed )
*B.12  CFTPH    Phi Angle of Track at Point of Closest Approach
*B.13  CFTD0    D0  Distance of Closest Approach in X,Y Plane
*B.14  CFTTL    Tan(Lambda) = dZ/dS(x,y) Slope in Z
*B.15  CFTZ0    Z Position of Point of Closest Approach in X,Y Plane
*B.16  CFTER    Element 11 of Triangle Error Matrix
*B.17  CFTER    Element 12 of Triangle Error Matrix
*B.18  CFTER    Element 22 of Triangle Error Matrix
*B.19  CFTER    Element 13 of Triangle Error Matrix
*B.20  CFTER    Element 23 of Triangle Error Matrix
*B.21  CFTER    Element 33 of Triangle Error Matrix
*B.22  CFTER    Element 14 of Triangle Error Matrix
*B.23  CFTER    Element 24 of Triangle Error Matrix
*B.24  CFTER    Element 34 of Triangle Error Matrix
*B.25  CFTER    Element 44 of Triangle Error Matrix
*B.26  CFTER    Element 15 of Triangle Error Matrix
*B.27  CFTER    Element 25 of Triangle Error Matrix
*B.28  CFTER    Element 35 of Triangle Error Matrix
*B.29  CFTER    Element 45 of Triangle Error Matrix
*B.30  CFTER    Element 55 of Triangle Error Matrix
*B.31  CFTCR    Chi Squared  per Degree of Freedom in R,Phi
*B.32  CFTCZ    Chi Squared  per Degree of Freedom in S,Z
*B.33  CFTC3    Chi Squared  per Degree of Freedom for the Helix Fit
*B.34  CFTPX    Px
*B.35  CFTPY    Py
*B.36  CFTPZ    Pz
*B.37  CFTEE    Energy
*B.38  CFTPP    Ptot
*B.39  CFTPT    Pt
*B.40  CFTQQ    Charge
*B/DATA
*B/
+DECK,CFTX.AVAILABLE IN SEQUENCE CFPAR
*B..CFTX End Points Information Bank.
*B.AU    S.Weisz,A.McPherson,S.Lloyd
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    8
*B.NL    2
*B.NS    0
*B.NX    None
*B.UP    CFTS -1
*B.OR    CFTS -1
*B.LINK
*B.1   CFXN     Reference Link to Parent Vertex
*B.2   CFXN     Reference Link to Decay Vertex if any
*B/LINK
*B.DATA
*B.1   CFTXO    Sequential number of Parent Vertex
*B.2   CFTXD    Sequential number of Decay Vertex
*B.3   CFTXX    X at Start/1st Point/Parent Vertex
*B.4   CFTXY    Y at Start/1st Point/Parent Vertex
*B.5   CFTXZ    Z at Start/1st Point/Parent Vertex
*B.6   CFTDX    X at End/Last Point/Decay Vertex
*B.7   CFTDY    Y at End/Last Point/Decay Vertex
*B.8   CFTDZ    Z at End/Last Point/Decay Vertex
*B/DATA
*B/
+DECK,CFX. AVAILABLE IN SEQUENCE CFPAR
*B..CFX  "FAKE" Vertices Header Bank.
*B.AU    S.Weisz,A.McPherson,S.Lloyd
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    *
*B.NS    *
*B.NX    None
*B.UP    CF   -2
*B.OR    CF   -2
*B.LINK
*B.REP CFXNV
*B.1   CFXN     Header Bank for "Fake" Vertices
*B/REP
*B/LINK
*B.DATA
*B.1   CFXNV    Number of Vertices
*B.REP CFXNV
*B.2   CFXFV    Flag for "fake" vertex
*B/REP
*B/DATA
*B/
+DECK,CFXN.AVAILABLE IN SEQUENCE CFPAR
*B..CFXN Header Bank for "Fake" Vertices.
*B.AU    S.Weisz
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    1
*B.NS    1
*B.NX    None
*B.UP    CFX  -Vertex#
*B.OR    CFX  -Vertex#
*B.LINK
*B.1   CFXP     Parameters for "Fake" Vertex
*B/LINK
*B.DATA
*B.1   CFXNN    Number of "Fake" Track coming from this Vertex
*B.REP CFXNN
*B.2   KCFT     Track number coming from this vertex in CFT
*B/REP
*B/DATA
*B/
+DECK,CFXP.AVAILABLE IN SEQUENCE CFPAR
*B..CFXP Parameters for "Fake" Vertex.
*B.AU    S.Weisz
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    9
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    CFXN -1
*B.OR    CFXN -1
*B.DATA
*B.1   CFXPX    X position of the vertex
*B.2   CFXPY    Y position of the vertex
*B.3   CFXPZ    Z position of the vertex
*B.4   CFXPE    D2(X) uncertainty in X position squared
*B.5   CFXPE    C(XY) correlation in D(X,Y)
*B.6   CFXPE    D2(Y) uncertainty in Y position squared
*B.7   CFXPE    C(XZ) correlation in D(X,Z)
*B.8   CFXPE    C(YZ) correlation in D(Y,Z)
*B.9   CFXPE    D2(Z) uncertainty in Z position squared
*B/DATA
*B/
+DECK,EC.  AVAILABLE IN SEQUENCE ROPAR
*B..EC   Electron Calorimeter Processing Bank.
*B.AU    S.Weisz
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    6
*B.NL    6
*B.NS    6
*B.NX    None
*B.UP    REV  -5
*B.OR    REV  -5
*B.LINK
*B.1   TB       ToF Barrel Processing Bank
*B.2   PB       Presampler Barrel Processing Bank
*B.3   EB       Lead Glass Barrel Processing Bank
*B.4   PE       Presampler Endcap Processing Bank
*B.5   EE       Lead Glass Endcap Processing Bank
*B.6   EM       Electro-Magnetic Clusters Results Bank
*B/LINK
*B.DATA
*B.1   IFTB     Flag for TB Processe (to be defined)
*B.2   IFPB     Flag for PB Processe
*B.3   IFEB     Flag for EB Processe
*B.4   IFPE     Flag for PE Processe
*B.5   IFEE     Flag for EE Processe
*B.6   IFEM     Flag for EM Processe
*B/DATA
*B/
+DECK,HC.  AVAILABLE IN SEQUENCE ROPAR
*B..HC   Hadron Calorimeter Processing Bank.
*B.AU    S.Weisz
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    4
*B.NL    4
*B.NS    4
*B.NX    None
*B.UP    REV  -6
*B.OR    REV  -6
*B.LINK
*B.1   HB       Hadron Barrel Processing Bank
*B.2   HE       Hadron Endcap Processing Bank
*B.3   HP       Hadron Poletip Processing Bank
*B.4   HM       Hadronic Clusters Result Bank
*B/LINK
*B.DATA
*B.1   IFHB     Flag for HB Processe
*B.2   IFHE     Flag for HE Processe
*B.3   IFHP     Flag for HP Processe
*B.4   IFHM     Flag for HM Processe
*B/DATA
*B/
+DECK,MU.  AVAILABLE IN SEQUENCE ROPAR
*B..MU   Muon Chambers Processing Bank.
*B.AU    S.Weisz
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    REV  -7
*B.OR    REV  -7
*B.LINK
*B.1   MB       Muon Barrel Processing Bank
*B.2   ME       Muon Endcap Processing Bank
*B.3   MM       Muon Barrel/Endcap Result Bank
*B/LINK
*B.DATA
*B.1   IFMB     Flag for MB Processe
*B.2   IFME     Flag for ME Processe
*B.3   IFMM     Flag for MM Processe
*B/DATA
*B/
+DECK,FO.  AVAILABLE IN SEQUENCE ROPAR
*B..FO   Forward Detector Processing Bank.
*B.AU    S.Weisz
*B.VE    404
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    REV  -8
*B.OR    REV  -8
*B.LINK
*B.1   FD       Forward Detector Results Banks
*B.2   FDD      Forward Detector Dense Data
*B.3   SW       Silicon Tungsten results
*B/LINK
*B.DATA
*B.1   IFFD     Flag for FD Processes
*B.2   IFFDD    Flag for FD Dense Data
*B.3   IIFSW    Flag for Silicon Tungsten results
*B/DATA
*B/
+DECK,OD.  AVAILABLE IN SEQUENCE ROPAR
*B..OD   OPAL DST Header Bank.
*B.AU    A.Buijs,S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    0
*B.NL    11
*B.NS    11
*B.NX    None
*B.UP    REV -10
*B.OR    REV -10
*B.LINK
*B.1   GNRL     General Bank
*B.2   CTRK     Charged Track Bank
*B.3   PRES     Presampler cluster Bank
*B.4   ECAL     EM Calorimeter Bank
*B.5   TOF      Time of Flight Bank
*B.6   HCAL     Hadron Calorimeter Bank
*B.7   MUON     Muon Bank
*B.8   FDET     Forward detector Bank
*B.9   VRTX     Vertex Bank
*B.10  ATRK     Alternative track Bank
*B.11  USER     User Bank
*B/LINK
*B/
+DECK,RCO. AVAILABLE IN ROCPAR
*B..RCO  ROPE constant header bank.
*B.AU    S.Weisz.
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    10
*B.NL    10
*B.NS    10
*B.NX    None
*B.UP    None
*B.OR    None
*B.LINK
*B.1   EXC      External device constants
*B.2   UTC      General utility constants
*B.3   DAC      Calibration constants
*B.4   CDC      Central detector constants
*B.5   ECC      Electromagnetic calorimeter constants
*B.6   HCC      Hadron calorimeter constants
*B.7   MUC      Muon chamber constants
*B.8   FOC      Forward detector constants
*B.9   DDC      Dense Data constants
*B.10  ODC      Constants for "DST"
*B/LINK
*B.DATA
*B.1   IFEXC    Flag for external device data
*B.2   IFUTC    Flag for general utility data
*B.3   IFDAC    Flag for raw detector data
*B.4   IFCDC    No. CD processes
*B.5   IFECC    No. EC processes
*B.6   IFHCC    No. HC processes
*B.7   IFMUC    No. MU processes
*B.8   IFFDC    No. FD processes
*B.9   IFDDC    No. DD processes
*B.10  IFODC    Flag for DST processing
*B/DATA
*B/
+DECK,EXC. AVAILABLE IN SEQUENCE ROCPAR
*B..EXC  External devices constants header.
*B.AU    S.Weisz,D.R.Ward
*B.VERS  1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    RCO  -1
*B.OR    RCO  -1
*B.LINK
*B.1   TRIC     Trigger constants (not used)
*B.2   MCC      MC constants header
*B.3   LEPC     Machine dependant constants (not used)
*B/LINK
*B.DATA
*B.1   IFTRC    Flag for trigger constants (not used)
*B.2   IFMCC    Flag for MC constants header
*B.3   IFLEPC   Flag for machine dependant constants (not used)
*B/DATA
*B/
+DECK,UTC. AVAILABLE IN SEQUENCE ROCPAR
*B..UTC  Utility constant header bank.
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    0
*B.NL    4
*B.NS    4
*B.NX    None
*B.UP    RCO  -2
*B.OR    RCO  -2
*B.LINK
*B.1 REPO    Report constant header bank (not used)
*B.2 GRHD    Graphics constant header bank
*B.3 IOHD    File definition header bank
*B.4 SLCT    Event selection header bank
*B/LINK
*B/
+DECK,IOHD.AVAILABLE IN SEQUENCE ROCPAR
*B..IOHD Input/Output header bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    0
*B.NL    15
*B.NS    15
*B.NX    None
*B.UP    UTC  -3
*B.OR    UTC  -3
*B.LINK
*B.1   IOII    INIT file description bank
*B.2   IOCI    Constant file description bank
*B.3   IODI    Data input file description bank
*B.4   IODO    Data output file description bank
*B.5   IODC    Copy file description bank
*B.6   IOOV    Large event dump description bank
*B.7   IODS    DST output file description bank
*B.8   IODD    DDST output file description bank
*B.9   IOCA    Calibration file description bank
*B.10  IOME    Metafile description bank
*B.11  IOBK    Bank documentation file description bank
*B.12  IOHB    Hbook RZ file description bank
*B.13  IODP    Production output file description bank
*B.14  IODG    Scan (GRAPHIC) file description bank
*B.15  IOAO    DAD output file description bank
*B/LINK
*B/
+DECK,IOII.AVAILABLE IN SEQUENCE ROCPAR
*B..IOII INIT structure file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  4.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    IOHD -1
*B.OR    IOHD -1
*B.DATA
*B.1   JACTIV   Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   JSELEC   Not used
*B.3   JLUN     Logical unit number
*B.4   JLREC    Logical record length
*B.5   JFCHOP   Option for FZFILE (Hollerith)
*B.6   JDCHOP   Not used
*B.7   JFSTAT   FORTRAN file status ('OLD',Hollerith)
*B.8   JFNTYP   Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   JACMOD   Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  JFLAGS   Not used
*B.11  JDEVIC   Not used
*B.12  JFKEYS   Not used
*B.22  JFNAME   File name (External file definition)
*B/DATA
*B/
+DECK,IOCI.AVAILABLE IN SEQUENCE ROCPAR
*B..IOCI Constant structure file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    IOHD -2
*B.OR    IOHD -2
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Not used
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   Not used
*B.7   FSTAT    FORTRAN file status ('OLD',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Not used
*B.11  DEVIC    Not used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IODI.AVAILABLE IN SEQUENCE ROCPAR
*B..IODI Input data file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IODI
*B.UP    IOHD -3
*B.OR    IOHD -3
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Not used
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('OLD',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.8   C0000002 Fatmen file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.9   C0000003 Pre-staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Fatmen Keys
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IODO.AVAILABLE IN SEQUENCE ROCPAR
*B..IODO Output data file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IODO
*B.UP    IOHD -4
*B.OR    IOHD -4
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IODC.AVAILABLE IN SEQUENCE ROCPAR
*B..IODC Copy data file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IODC
*B.UP    IOHD -5
*B.OR    IOHD -5
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IOOV.AVAILABLE IN SEQUENCE ROCPAR
*B..IOOV Unprocessed event dump file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IOOV
*B.UP    IOHD -6
*B.OR    IOHD -6
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IODS.AVAILABLE IN SEQUENCE ROCPAR
*B..IODS DST output file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IODS
*B.UP    IOHD -7
*B.OR    IOHD -7
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IODD.AVAILABLE IN SEQUENCE ROCPAR
*B..IODD DDST output file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IODD
*B.UP    IOHD -8
*B.OR    IOHD -8
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IOCA.AVAILABLE IN SEQUENCE ROCPAR
*B..IOCA Calibration data file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IOCA
*B.UP    IOHD -9
*B.OR    IOHD -9
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Not used
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for OPCAL (RZFILE option,Hollerith)
*B.6   DCHOPT   Name of calibration file ('MAIN','AUXn',Hollerith)
*B.7   FSTAT    FORTRAN file status (Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IOME.AVAILABLE IN SEQUENCE ROCPAR
*B..IOME Metafile description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    IOHD -10
*B.OR    IOHD -10
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Not used
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for OPCAL (RZFILE option,Hollerith)
*B.6   DCHOPT   Name of calibration file ('MAIN','AUXn',Hollerith)
*B.7   FSTAT    FORTRAN file status ('NEW' Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IOBK.AVAILABLE IN SEQUENCE ROCPAR
*B..IOBK Bank documentation file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    IOHD -11
*B.OR    IOHD -11
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Not used
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for RZFILE (Hollerith)
*B.6   DCHOPT   Not used
*B.7   FSTAT    FORTRAN file status ('OLD' Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.10  FLAGS    Not used
*B.11  DEVIC    Not used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IOHB.AVAILABLE IN SEQUENCE ROCPAR
*B..IOHB HBOOK4 RZ file description bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    IOHD -12
*B.OR    IOHD -12
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Not used
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for HROPEN (Hollerith)
*B.6   DCHOPT   Max Nb of record to open the file
*B.7   FSTAT    FORTRAN file status (Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.10  FLAGS    Not used
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IODP.AVAILABLE IN SEQUENCE ROCPAR
*B..IODP Production output data file description bank.
*B.AU    S.Weisz
*B.VERS  1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IODP
*B.UP    IOHD -13
*B.OR    IOHD -13
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IODG.AVAILABLE IN SEQUENCE ROCPAR
*B..IODG Graphic 'SCAN' output data file description bank.
*B.AU    S.Weisz
*B.VERS  1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IODG
*B.UP    IOHD -14
*B.OR    IOHD -14
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   LUN      Logical unit number
*B.4   LREC     Logical record length
*B.5   FCHOPT   Option for FZFILE (Hollerith)
*B.6   DCHOPT   File processing option
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,IOAO.AVAILABLE IN SEQUENCE ROCPAR
*B..IOAO DAD output file description bank.
*B.AU    A.Lee
*B.VERS  1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    41
*B.NL    0
*B.NS    0
*B.NX    IOAO
*B.UP    IOHD -15
*B.OR    IOHD -15
*B.DATA
*B.1   FLACTIVE Activation flag
*B.1   C0000000 File inactive, not open
*B.1   C0000001 File active, open
*B.2   FLSELEC  Selection flag
*B.2   C0000000 File not selected for output
*B.2   C0000001 File selected for output
*B.3   DADLUN   Logical unit number for DAD list
*B.4   DSTLUN   Logical unit number for DATA
*B.5   FDBLUN   Logical unit number for file database
*B.6   ????     Spare
*B.7   FSTAT    FORTRAN file status ('NEW',Hollerith)
*B.8   FNTYP    Type of file definition
*B.8   C0000000 External file definition
*B.8   C0000001 Internal named file definition
*B.9   ACMOD    Access mode
*B.9   C0000000 Disk file
*B.9   C0000001 Mounted cartridge
*B.9   C0000002 Staged cartridge
*B.10  FLAGS    Processing flags
*B.10  BITVAL00 Variable name
*B.10  BITVAL01 'One to one' flag
*B.10  BITVAL02 'Erase and dump' flag
*B.10  BITVAL03 'No constant record ' flag
*B.10  BITVAL04 'One event per file' flag
*B.10  BITVAL05 The previous file referred to the same tape
*B.10  BITVAL06 'Quiet FZEND' flag
*B.10  BITVAL07 'Anywhere' flag (Vax only)
*B.10  BITVAL08 'Autoput' flag  (IBM only)
*B.10  BITVAL09 'New foreign tape' flag  (VAX only)
*B.10  BITVAL10 'Explicit name flag' (VAX only)
*B.10  BITVAL11 'Plot the metafile' flag
*B.10  BITVAL12 'This is a dadlist' flag
*B.11  DEVIC    Device used
*B.12  FKEYS    Not used
*B.22  FNAME    File name (External file definition)
*B/DATA
*B/
+DECK,SLCT.AVAILABLE IN SEQUENCE ROCPAR
*B..SLCT Event selection header bank.
*B.AU    S.Weisz
*B.VERS  1.020
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    0
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    UTC  -4
*B.OR    UTC  -4
*B.LINK
*B.1   SLEV    Event selection bank on RUN and EVENT No. (*EVENT card)
*B.2   SLRE    Event selection bank on sequential read No. (*READIN )
*B.3   SLGE    Event selection bank on RUN and EVENT No. (*GET card)
*B/LINK
*B/
+DECK,SLEV.AVAILABLE IN SEQUENCE ROCPAR
*B..SLEV Event selection bank on RUN and EVENT No. (*EVENT card).
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    4
*B.NL    0
*B.NS    0
*B.NX    SLEV
*B.UP    SLCT -1
*B.OR    SLCT -1
*B.DATA
*B.1   IRUFST   First selected Run No.
*B.2   IEVFST   First selected Event No.
*B.3   IRULST   Last selected Run No.
*B.4   IEVLST   Last selected Event No.
*B/DATA
*B/
+DECK,SLGE.AVAILABLE IN SEQUENCE ROCPAR
*B..SLGE Event selection bank on RUN and EVENT No. (*GET card).
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    2
*B.NL    0
*B.NS    0
*B.NX    SLGE
*B.UP    SLCT -3
*B.OR    SLCT -3
*B.DATA
*B.1   IRUGET   Selected Run No.
*B.2   IEVGET   Selected Event No.
*B/DATA
*B/
+DECK,SLRE.AVAILABLE IN SEQUENCE ROCPAR
*B..SLRE Event selection on sequential read No. (*READIN card).
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    7
*B.NL    0
*B.NS    0
*B.NX    SLRE
*B.UP    SLCT -2
*B.OR    SLCT -2
*B.DATA
*B.1   IREFST   First event to read
*B.2   IRELST   Last event to read
*B.3   IRESTP   Step to read event
*B/DATA
*B/
+DECK,DAC. AVAILABLE IN SEQUENCE ROCPAR
*B..DAC  Calibration header bank.
*B.AU    S.Weisz
*B.VE    404
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    22
*B.NL    22
*B.NS    22
*B.NX    None
*B.UP    RCO  -3
*B.OR    RCO  -3
*B.LINK
*B.1   CVCT     Vertex Chamber Calibration data
*B.2   CJCT     Jet Chamber Calibration data
*B.3   CZCT     Z Chamber Calibration data
*B.4   TBCT     Time of Flight Calibration data
*B.5   PBCT     Barrel Presampler Calibration data
*B.6   EBCT     Electron Barrel Calibration data
*B.7   PECT     Endcap Presampler Calibration data
*B.8   EECT     Electron Endcap Calibration data
*B.9   HTCT     Hadron Barrel Calibration data
*B.10  HSCT     Hadron Endcap Calibration data
*B.11  HPCT     Hadron Poletip Calibration data
*B.12  MBCT     Muon Barrel Calibration data
*B.13  MECT     Muon Endcap Calibration data
*B.14  FDCT     Forward Detector Calibration data
*B.15  TRCT     Trigger constants
*B.16  TTCT     Track trigger constants
*B.17  SCCT     Slow control constants
*B.18  FICT     Filter constants
*B.19  GNCT     General constants
*B.20  SICT     Silicon Microvertex calibration data
*B.21  DXCT     De/Dx calibration data
*B.22  SWCT     Silicon Tungsten calibration data
*B/LINK
*B.DATA
*B.1   FCVCT    Vertex detector calibration data flag
*B.2   FCJCT    Jet Chamber calibration data flag
*B.3   FCZCT    Zed Chamber calibration data flag
*B.4   FTBCT    Time of Flight calibration data flag
*B.5   FPBCT    Presampler Barrel calibration data flag
*B.6   FEBCT    Lead glass Barrel calibration data flag
*B.7   FPECT    Presampler Endcap calibration data flag
*B.8   FEECT    Lead glass Endcap calibration data flag
*B.9   FHTCT    Hadron barrel calibration data flag
*B.10  FHSCT    Hadron endcap calibration data flag
*B.11  FHPCT    Hadron poletip calibration data flag
*B.12  FMBCT    Muon barrel calibration data flag
*B.13  FMECT    Muon endcap calibration data flag
*B.14  FFDCT    Forward detector calibration data flag
*B.15  FTRCT    Trigger constants flag
*B.16  FTTCT    Track trigger constants flag
*B.17  FSCCT    Slow control constants flag
*B.18  FFICT    Filter constants flag
*B.19  FGNCT    General constants flag
*B.20  FSICT     Silicon Microvertex calibration data flag (to be dfd)
*B.21  FDXCT     De/Dx calibration data flag
*B.22  FSWCT     Silicon Tungsten calibration data flag (to be dfd)
*B/DATA
*B/
+DECK,GNCT.AVAILABLE IN SEQUENCE ROCPAR
*B..GNCT General constant structure.
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    0
*B.NL    3
*B.NS    3
*B.NX    0
*B.UP    DAC  -19
*B.OR    DAC  -19
*B.LINK
*B.1   MAGF     Magnetic field Bank
*B.2   BEAM     Beam position Bank
*B.3   LIFE     Lifetime Bank (For MC only)
*B/LINK
*B/
+DECK,MAGF.AVAILABLE IN SEQUENCE ROCPAR
*B..MAGF Magnetic field constants.
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    1
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP    GNCT -1
*B.OR    GNCT -1
*B.DATA
*B.1   IMEANB   mean magnetic field (in kG)
*B/DATA
*B/
+DECK,BEAM.AVAILABLE IN SEQUENCE ROCPAR
*B..BEAM Beam position.
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    9
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP    GNCT -2
*B.OR    GNCT -2
*B.DATA
*B.1   IXBEAM   mean X position of beam crossing
*B.2   IYBEAM   mean Y position of beam crossing
*B.3   IZBEAM   mean Z position of beam crossing
*B.4   IDXBEA   LEP intrinsic X extention of beam crossing
*B.5   IDYBEA   LEP intrinsic Y extention of beam crossing
*B.6   IDZBEA   LEP intrinsic Z extention of beam crossing
*B.7   IEXBEA   Error of mean X position of beam crossing
*B.8   IEYBEA   Error of mean Y position of beam crossing
*B.9   IEZBEA   Error of mean Z position of beam crossing
*B/DATA
*B/
+DECK,LIFE.AVAILABLE IN SEQUENCE ROCPAR
*B..LIFE Lifetime constants for MC data.
*B.AU    S.Lloyd
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    30
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP    GNCT -3
*B.OR    GNCT -3
*B.DATA
*B.1   IPLIFE   Lifetime parameters at generation.
*B/DATA
*B/
+DECK,CDC. AVAILABLE IN SEQUENCE ROCPAR
*B..CDC  Central Detector Constant Bank.
*B.AU    S.Weisz
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    11
*B.NL    11
*B.NS    11
*B.NX    None
*B.UP    RCO  -4
*B.OR    RCO  -4
*B.LINK
*B.1   CVC      Vertex Chamber Constant Bank
*B.2   CJC      Jet Chamber Constant Bank
*B.3   CZC      Z Chamber Constant Bank
*B.4   CTC      CD Track Constant Bank
*B.5   DXC      De/Dx Constant Bank
*B.6   CFC      CD "fake" tracks and vertex Constant Bank
*B.7   CXC      CD Vertex Constant Bank
*B.8   SIC      Silicon Microvertex Constant Bank
*B.9   CES      Central association with SI Constant Bank
*B.10  CEC      Central track extrapolation Constant Bank
*B.11  CAC      Central track association Constant Bank
*B/LINK
*B.DATA
*B.1   IFCVC    Flag for CV Processing
*B.2   IFCJC    Flag for CJ Processing
*B.3   IFCZC    Flag for CZ Processing
*B.4   IFCTC    Flag for CT Processing
*B.5   IFDXC    Flag for DX Processing
*B.6   IFCFC    Flag for CF Processing
*B.7   IFCXC    Flag for CX Processing
*B.8   IFCXC    Flag for SI Processing
*B.9   IFCXC    Flag for CS Processing
*B.10  IFCEC    Flag for CE Processing
*B.11  IFCAC    Flag for CA Processing
*B/DATA
*B/
+DECK,ECC. AVAILABLE IN SEQUENCE ROCPAR
*B..ECC  Electron Calorimeter Constant Bank.
*B.AU    S.Weisz
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    6
*B.NL    6
*B.NS    6
*B.NX    None
*B.UP    RCO  -5
*B.OR    RCO  -5
*B.LINK
*B.1   TBC      ToF Barrel Constant Bank
*B.2   PBC      Presampler Barrel Constant Bank
*B.3   EBC      Lead Glass Barrel Constant Bank
*B.4   PEC      Presampler Endcap Constant Bank
*B.5   EEC      Lead Glass Endcap Constant Bank
*B.6   EMC      Electro-Magnetic Clusters Constant Bank
*B/LINK
*B.DATA
*B.1   IFTBC    Flag for TB Processing
*B.2   IFPBC    Flag for PB Processing
*B.3   IFEBC    Flag for EB Processing
*B.4   IFPEC    Flag for PE Processing
*B.5   IFEEC    Flag for EE Processing
*B.6   IFEMC    Flag for EM Processing
*B/DATA
*B/
+DECK,HCC. AVAILABLE IN SEQUENCE ROCPAR
*B..HCC  Hadron Calorimeter Constant Bank.
*B.AU    S.Weisz
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    4
*B.NL    4
*B.NS    4
*B.NX    None
*B.UP    RCO  -6
*B.OR    RCO  -6
*B.LINK
*B.1   HBC      Hadron Barrel Constant Bank
*B.2   HEC      Hadron Endcap Constant Bank
*B.3   HPC      Hadron Poletip Constant Bank
*B.4   HMC      Hadronic Clusters Constant Bank
*B/LINK
*B.DATA
*B.1   IFHBC    Flag for HB Processing
*B.2   IFHEC    Flag for HE Processing
*B.3   IFHPC    Flag for HP Processing
*B.4   IFHMC    Flag for HM Processing
*B/DATA
*B/
+DECK,MUC. AVAILABLE IN SEQUENCE ROCPAR
*B..MUC  Muon Chambers Constant Bank.
*B.AU    S.Weisz
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    RCO  -7
*B.OR    RCO  -7
*B.LINK
*B.1   MBC      Muon Barrel Constant Bank
*B.2   MEC      Muon Endcap Constant Bank
*B.3   MMC      Muon Barrel/Endcap Constant Bank
*B/LINK
*B.DATA
*B.1   IFMBC    Flag for MB Processing
*B.2   IFMEC    Flag for ME Processing
*B.3   IFMMC    Flag for MM Processing
*B/DATA
*B/
+DECK,FOC. AVAILABLE IN SEQUENCE ROCPAR
*B..FOC  Forward Detector Constant Bank.
*B.AU    S.Weisz
*B.VE    404
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    RCO  -8
*B.OR    RCO  -8
*B.LINK
*B.1   FDCR     Right forward Detector Constant Banks
*B.2   FDCL     Left forward Detector Constant Banks
*B.3   SWC      Silicon Tungsten constants bank
*B/LINK
*B.DATA
*B.1   IFFDC    Flag for FD Processing
*B.2   NOTUSED
*B.3   IFFSWC   Flag for Silicon Tungsten
*B/DATA
*B/
+DECK,ODC. AVAILABLE IN SEQUENCE ROCPAR
*B..ODC  DST Constant Bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    11
*B.NL    1
*B.NS    1
*B.NX    None
*B.UP    RCO  -10
*B.OR    RCO  -10
*B.LINK
*B.1   ODCB     User defined DST block description bank
*B/LINK
*B.DATA
*B.1   IFODG    Flag to build the OD GNRL block
*B.2   IFODT    Flag to build the OD CTRK block
*B.3   IFODP    Flag to build the OD PRES block
*B.4   IFODE    Flag to build the OD ECAL block
*B.5   IFODU    Flag to build the OD unsplitted ECAL block
*B.6   IFODH    Flag to build the OD HCAL block
*B.7   IFODM    Flag to build the OD MUON block
*B.8   IFODF    Flag to build the OD Forward detector block
*B.9   IFODV    Flag to build the OD VERT block
*B.10  IFODA    Flag to build the OD ATRK block
*B.11  IFODU    Flag to build the OD USER block
*B/DATA
*B/
+DECK,ODCB.
*B..ODCB User define DST block description bank
*B.AU    A.Buijs,S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    ODC  -1
*B.OR    ODC  -1
*B.DATA
*B.REP NUSWORD
*B.1   ODUSLNK  Link of the bank from ODHD down (1=GNRL, 2=CTRK, etc..)
*B.2   ODUSWONB Word number in the bank (+ integers, - reals)
*B.3   ODUSWOAD Address relative to Q(1)
*B.4   ODUSDIM  Maximum dimension of the array.
*B.5   ODUSHVR  Hollerith ID of variable (since OD410/03)
*B/REP
*B/DATA
*B/
+DECK,RST. AVAILABLE IN ROSPAR
*B..RST  ROPE statistics header bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    10
*B.NL    10
*B.NS    10
*B.NX    None
*B.UP    None
*B.OR    None
*B.LINK
*B.1   EXS      External device statistics
*B.2   UTS      General utility statistics
*B.3   DAS      Calibration statistics
*B.4   CDS      Central detector statistics
*B.5   ECS      Electromagnetic calorimeter statistics
*B.6   HCS      Hadron calorimeter statistics
*B.7   MUS      Muon chamber statistics
*B.8   FOS      Forward detector statistics
*B.9   DDS      Dense data statistics
*B.10  ODS      Constants for "DST"
*B/LINK
*B.DATA
*B.1   IFEXS    Flag for external device statistics (not defined)
*B.2   IFUTS    Flag for general utility statistics (not defined)
*B.3   IFDAS    Flag for raw detector statistics (not defined)
*B.4   IFCDS    Flag for CD statistics (not defined)
*B.5   IFECS    Flag for EC statistics (not defined)
*B.6   IFHCS    Flag for HC statistics (not defined)
*B.7   IFMUS    Flag for MU statistics (not defined)
*B.8   IFFDC    Flag for FD statistics (not defined)
*B.9   IFDDS    Flag for AD statistics (not defined)
*B.10  IFODS    Flag for DST statistics (not defined)
*B/DATA
*B/
+DECK,EXS. AVAILABLE IN SEQUENCE ROSPAR
*B..EXS  External devices statistics header.
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    RST  -1
*B.OR    RST  -1
*B.LINK
*B.1   TRIS     Trigger statistics (not used)
*B.2   MCS      MC statistics (not used)
*B.3   LEPS     Machine dependant statistics (not used)
*B/LINK
*B.DATA
*B.1   IFTRC    Flag for trigger statistics (not used)
*B.2   IFMCS    Flag for MC statistics (not used)
*B.3   IFLEPS   Flag for machine dependant statistics (not used)
*B/DATA
*B/
+DECK,UTS. AVAILABLE IN SEQUENCE ROSPAR
*B..UTS  Utility statistics header bank.
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    0
*B.NL    1
*B.NS    1
*B.NX    None
*B.UP    RST  -2
*B.OR    RST  -2
*B.LINK
*B.1 RSMS    Summary statistics header bank
*B/LINK
*B/
+DECK,RSMS.AVAILABLE IN SEQUENCE ROSPAR
*B..RSMS Summary statistics header bank.
*B.AU    S.Weisz
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    30
*B.NL    4
*B.NS    4
*B.NX    None
*B.UP    UTS  -2
*B.OR    UTS  -2
*B.LINK
*B.1 RTIS    Time summary statistics bank
*B.2 RSPS    Space summary statistics bank
*B.3 RTI2    Time**2 summary statistics bank
*B.4 RSP2    Space**2 summary statistics bank
*B/LINK
*B.DATA
*B.1   NBEVT    Number of event selected for processing
*B.2   ????     Spare
*B.3   ????     Spare
*B.4   NBCVS    Number segments found by CV processor
*B.5   NBCJS    Number segments found by CJ processor
*B.6   NBCZS    Number segments found by CZ processor
*B.7   NBCTS    Number tracks found by CT processor
*B.8   NBDXS    Number tracks processed by De/Dx
*B.9   NBCXS    Number vertices found by CX processor
*B.10  NBSIS    Number impacts found by SI processor
*B.11  NBCSS    Number tracks processed by CS processor
*B.12  NBCES    Number tracks extrapolated by CE processor
*B.13  NBCAS    Number tracks associated by CA processor
*B.14  NBTBS    Number bars found by TB processor
*B.15  NBPBS    Number clusters found by PB processor
*B.16  NBEBS    Number clusters found by EB processor
*B.17  NBPES    Number clusters found by PE processor
*B.18  NBEES    Number clusters found by EE processor
*B.19  NBEMS    Number clusters found by EM processor
*B.20  NBHBS    Number clusters found by HB processor
*B.21  NBHES    Number clusters found by HE processor
*B.22  NBHPS    Number clusters found by HP processor
*B.23  NBHMS    Number clusters found by HM processor
*B.24  NBMBS    Number segments found by MB processor
*B.25  NBMES    Number segments found by ME processor
*B.26  NBMMS    Number segments found by MM processor
*B.27  NBFDS    Number clusters found by FD processor
*B.28  NBSWS    Number clusters found by SW processor
*B.29  NBODS    Number banks lifted by OD processor
*B.30  ????     Spare
*B/
+DECK,RTIS.AVAILABLE IN SEQUENCE ROSPAR
*B..RTIS Time summary statistics bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    30
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    RSMS -1
*B.OR    RSMS -1
*B.DATA
*B.1   TIUSS    Time spend in user's routine(s)
*B.2   TIOCS    Time spend in OPCAL
*B.3   TIDDS    Time spend in data compression.
*B.4   TICVS    Time spend for CV processing
*B.5   TICJS    Time spend for CJ processing
*B.6   TICZS    Time spend for CZ processing
*B.7   TICTS    Time spend for CT processing
*B.8   TIDXS    Time spend for DX processing
*B.9   TICXS    Time spend for CX processing
*B.10  TISIS    Time spend for SI processing
*B.11  TICSS    Time spend for CS processing
*B.12  TICES    Time spend for CE processing
*B.13  TICAS    Time spend for CA processing
*B.14  TIPBS    Time spend for TB processing
*B.15  TIPBS    Time spend for PB processing
*B.16  TIEBS    Time spend for EB processing
*B.17  TIPES    Time spend for PE processing
*B.18  TIEES    Time spend for EE processing
*B.19  TIEMS    Time spend for EM processing
*B.20  TIHBS    Time spend for HB processing
*B.21  TIHES    Time spend for HE processing
*B.22  TIHPS    Time spend for HP processing
*B.23  TIHMS    Time spend for HM processing
*B.24  TIMBS    Time spend for MB processing
*B.25  TIMES    Time spend for ME processing
*B.26  TIMMS    Time spend for MM processing
*B.27  TIFDS    Time spend for FD processing
*B.28  TIFDS    Time spend for SW processing
*B.29  TIODS    Time spend for OD processing
*B.30  TITYS    Time spend for "Event Type" processing
*B/DATA
*B/
+DECK,RSPS.AVAILABLE IN SEQUENCE ROSPAR
*B..RSPS Space summary statistics bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    30
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    RSMS -2
*B.OR    RSMS -2
*B.DATA
*B.1   ????     Spare
*B.2   ????     Spare
*B.3   ????     Spare
*B.4   SPCVS    Space needed for CV processing
*B.5   SPCJS    Space needed for CJ processing
*B.6   SPCZS    Space needed for CZ processing
*B.7   SPCTS    Space needed for CT processing
*B.8   SPDXS    Space needed for DX processing
*B.9   SPCXS    Space needed for CX processing
*B.10  SPSIS    Space needed for SI processing
*B.11  SPCSS    Space needed for CS processing
*B.12  SPCES    Space needed for CE processing
*B.13  SPCAS    Space needed for CA processing
*B.14  SPTBS    Space needed for TB processing
*B.15  SPPBS    Space needed for PB processing
*B.16  SPEBS    Space needed for EB processing
*B.17  SPPES    Space needed for PE processing
*B.18  SPEES    Space needed for EE processing
*B.19  SPEMS    Space needed for EM processing
*B.20  SPHBS    Space needed for HB processing
*B.21  SPHES    Space needed for HE processing
*B.22  SPHPS    Space needed for HP processing
*B.23  SPHMS    Space needed for HM processing
*B.24  SPMBS    Space needed for MB processing
*B.25  SPMES    Space needed for ME processing
*B.26  SPMMS    Space needed for MM processing
*B.27  SPFDS    Space needed for FD processing
*B.28  SPFDS    Space needed for SW processing
*B.29  SPODS    Space needed for OD processing
*B.30  SPTYS    Space needed for "Event Type" processing
*B/DATA
*B/
+DECK,RTI2.AVAILABLE IN SEQUENCE ROSPAR
*B..RTI2 Time**2 summary statistics bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    30
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    RSMS -3
*B.OR    RSMS -3
*B.DATA
*B.1   ????     Spare
*B.2   ????     Spare
*B.3   ????     Spare
*B.4   TICV2S   Time**2 spend for CV processing
*B.5   TICJ2S   Time**2 spend for CJ processing
*B.6   TICZ2S   Time**2 spend for CZ processing
*B.7   TICT2S   Time**2 spend for CT processing
*B.8   TIDX2S   Time**2 spend for DX processing
*B.9   TICX2S   Time**2 spend for CX processing
*B.10  TISI2S   Time**2 spend for SI processing
*B.11  TICS2S   Time**2 spend for CS processing
*B.12  TICE2S   Time**2 spend for CE processing
*B.13  TICA2S   Time**2 spend for CA processing
*B.14  TITB2S   Time**2 spend for TB processing
*B.15  TIPB2S   Time**2 spend for PB processing
*B.16  TIEB2S   Time**2 spend for EB processing
*B.17  TIPE2S   Time**2 spend for PE processing
*B.18  TIEE2S   Time**2 spend for EE processing
*B.19  TIEM2S   Time**2 spend for EM processing
*B.20  TIHB2S   Time**2 spend for HB processing
*B.21  TIHE2S   Time**2 spend for HE processing
*B.22  TIHP2S   Time**2 spend for HP processing
*B.23  TIHM2S   Time**2 spend for HM processing
*B.24  TIMB2S   Time**2 spend for MB processing
*B.25  TIME2S   Time**2 spend for ME processing
*B.26  TIMM2S   Time**2 spend for MM processing
*B.27  TIFD2S   Time**2 spend for FD processing
*B.28  TISW2S   Time**2 spend for SW processing
*B.29  TIOD2S   Time**2 spend for OD processing
*B.30  TITY2S   Time**2 spend for "Event Type" processing
*B/DATA
*B/
+DECK,RSP2.AVAILABLE IN SEQUENCE ROSPAR
*B..RSP2 Space**2 summary statistics bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    30
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    RSMS -4
*B.OR    RSMS -4
*B.DATA
*B.1   ????     Spare
*B.2   ????     Spare
*B.3   ????     Spare
*B.4   SPCV2S   Space**2 needed for CV processing
*B.5   SPCJ2S   Space**2 needed for CJ processing
*B.6   SPCZ2S   Space**2 needed for CZ processing
*B.7   SPCT2S   Space**2 needed for CT processing
*B.8   SPDX2S   Space**2 needed for DX processing
*B.9   SPCX2S   Space**2 needed for CX processing
*B.10  SPSI2S   Space**2 needed for SI processing
*B.11  SPCS2S   Space**2 needed for CS processing
*B.12  SPCE2S   Space**2 needed for CE processing
*B.13  SPCA2S   Space**2 needed for CA processing
*B.14  SPTB2S   Space**2 needed for TB processing
*B.15  SPPB2S   Space**2 needed for PB processing
*B.16  SPEB2S   Space**2 needed for EB processing
*B.17  SPPE2S   Space**2 needed for PE processing
*B.18  SPEE2S   Space**2 needed for EE processing
*B.19  SPEM2S   Space**2 needed for EM processing
*B.20  SPHB2S   Space**2 needed for HB processing
*B.21  SPHE2S   Space**2 needed for HE processing
*B.22  SPHP2S   Space**2 needed for HP processing
*B.23  SPHM2S   Space**2 needed for HM processing
*B.24  SPMB2S   Space**2 needed for MB processing
*B.25  SPME2S   Space**2 needed for ME processing
*B.26  SPMM2S   Space**2 needed for MM processing
*B.27  SPFD2S   Space**2 needed for FD processing
*B.28  SPSW2S   Space**2 needed for SW processing
*B.29  SPOD2S   Space**2 needed for OD processing
*B.30  SPTY2S   Space**2 needed for "Event Type" processing
*B/DATA
*B/
+DECK,DAS. AVAILABLE IN SEQUENCE ROSPAR
*B..DAS  Raw Data statistics Bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    22
*B.NL    22
*B.NS    22
*B.NX    None
*B.UP    RST  -3
*B.OR    RST  -3
*B.LINK
*B.1   CVDS     Vertex Chamber Data statistics
*B.2   CJDS     Jet Chamber Data statistics
*B.3   CZDS     Z Chamber Data statistics
*B.4   TBDS     Time of Flight Data statistics
*B.5   PBDS     Barrel Presampler Data statistics
*B.6   EBDS     Electron Barrel Data statistics
*B.7   PEDS     Endcap Presampler Data statistics
*B.8   EEDS     Electron Endcap Data statistics
*B.9   HTDS     Hadron Barrel Data statistics
*B.10  HSDT     Hadron Endcap Data statistics
*B.11  HPDS     Hadron Poletip Data statistics
*B.12  MBDS     Muon Barrel Data statistics
*B.13  MEDS     Muon Endcap Data statistics
*B.14  FDDS     Forward Detector Data statistics
*B.15  TRDS     Trigger Data statistics
*B.16  TTDS     Track trigger Data statistics
*B.17  SCDS     Slow control Data statistics
*B.18  FIDS     Filter Data statistics
*B.19  GNDS     General Data statistics  (Not used)
*B.20  SIDS     Silicon Microvertex Data statistics
*B.22  SWDS     Silicon Tungsten Data statistics
*B/LINK
*B.DATA
*B.1   FCVDS    Vertex detector Data statistics flag
*B.2   FCJDS    Jet Chamber Data statistics flag
*B.3   FCZDS    Zed Chamber Data statistics flag
*B.4   FTBDS    Time of Flight Data statistics flag
*B.5   FPBDS    Presampler Barrel Data statistics flag
*B.6   FEBDS    Lead glass Barrel Data statistics flag
*B.7   FPEDS    Presampler Endcap Data statistics flag
*B.8   FEEDS    Lead glass Endcap Data statistics flag
*B.9   FHTDS    Hadron barrel Data statistics flag
*B.10  FHSDT    Hadron endcap Data statistics flag
*B.11  FHPDS    Hadron poletip Data statistics flag
*B.12  FMBDS    Muon barrel Data statistics flag
*B.13  FMEDS    Muon endcap Data statistics flag
*B.14  FFDDS    Forward detector Data statistics flag
*B.15  FTRDS    Trigger Data statistics flag
*B.16  FTTDS    Track trigger Data statistics flag
*B.17  FSCDS    Slow control Data statistics flag
*B.18  FFIDS    Filter Data statistics flag
*B.19  FGNDS    General Data statistics flag
*B.20  FSIDS    Silicon Microvertex Data statistics
*B.22  FSIDS    Silicon Tungsten Data statistics
*B/DATA
*B/
+DECK,CDS. AVAILABLE IN SEQUENCE ROSPAR
*B..CDS  Central Detector statistics Bank.
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    11
*B.NL    11
*B.NS    11
*B.NX    None
*B.UP    RST  -4
*B.OR    RST  -4
*B.LINK
*B.1   CVS      Vertex Chamber Constamt Bank
*B.2   CJS      Jet Chamber statistics bank (not yet used)
*B.3   CZS      Z Chamber statistics bank (not yet used)
*B.4   CTS      CD Track statistics bank (not yet used)
*B.5   DXS      De/Dx statistics bank (not yet used)
*B.6   CFS      CD "fake" tracks/vertex statistics bank (not yet used)
*B.7   CXS      CD Vertex statistics bank (not yet used)
*B.8   SIS      Silicon Microvertex statistics bank (not yet used)
*B.9   CSS      CS Track statistics bank (not yet used)
*B.10  CES      Central track extrapolation statistics bank (not used)
*B.11  CAS      Central track asociation statistics bank (not yet used)
*B/LINK
*B.DATA
*B.1   IFCVS    Flag for CV statistics (not defined)
*B.2   IFCJS    Flag for CJ statistics (not defined)
*B.3   IFCZS    Flag for CZ statistics (not defined)
*B.4   IFCTS    Flag for CT statistics (not defined)
*B.5   IFDXS    Flag for DX statistics (not defined)
*B.6   IFCFS    Flag for CF statistics (not defined)
*B.7   IFCXS    Flag for CX statistics (not defined)
*B.8   IFSIS    Flag for SI statistics (not defined)
*B.9   IFCsS    Flag for CS statistics (not defined)
*B.10  IFCES    Flag for CE statistics (not defined)
*B.11  IFCAS    Flag for CA statistics (not defined)
*B/DATA
*B/
+DECK,ECS. AVAILABLE IN SEQUENCE ROSPAR
*B..ECS  Electron Calorimeter statistics bank (not yet used).
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    6
*B.NL    6
*B.NS    6
*B.NX    None
*B.UP    RST  -5
*B.OR    RST  -5
*B.LINK
*B.1   TBS      ToF Barrel statistics bank (not yet used)
*B.2   PBS      Presampler Barrel statistics bank (not yet used)
*B.3   EBS      Lead Glas Barrel statistics bank (not yet used)
*B.4   PES      Presampler Endcap statistics bank (not yet used)
*B.5   EES      Lead Glas Endcap statistics bank (not yet used)
*B.6   EMS      Electro-Magnetic Clusters statistics bank (not yet used)
*B/LINK
*B.DATA
*B.1   IFTBS    Flag for TB statistics (not defined)
*B.2   IFPBS    Flag for PB statistics (not defined)
*B.3   IFEBS    Flag for EB statistics (not defined)
*B.4   IFPES    Flag for PE statistics (not defined)
*B.5   IFEES    Flag for EE statistics (not defined)
*B.6   IFEMS    Flag for EM statistics (not defined)
*B/DATA
*B/
+DECK,HCS. AVAILABLE IN SEQUENCE ROSPAR
*B..HCS  Hadron Calorimeter statistics bank (not yet used).
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    4
*B.NL    4
*B.NS    4
*B.NX    None
*B.UP    RST  -6
*B.OR    RST  -6
*B.LINK
*B.1   HBS      Hadron Barrel statistics bank (not yet used)
*B.2   HES      Hadron Endcap statistics bank (not yet used)
*B.3   HPS      Hadron Poletip statistics bank (not yet used)
*B.4   HMS      Hadronic Clusters statistics bank (not yet used)
*B/LINK
*B.DATA
*B.1   IFHBS    Flag for HB statistics (not defined)
*B.2   IFHES    Flag for HE statistics (not defined)
*B.3   IFHPS    Flag for HP statistics (not defined)
*B.4   IFHMS    Flag for HM statistics (not defined)
*B/DATA
*B/
+DECK,MUS. AVAILABLE IN SEQUENCE ROSPAR
*B..MUS  Muon Chambers statistics bank (not yet used).
*B.AU    S.Weisz
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    RST  -7
*B.OR    RST  -7
*B.LINK
*B.1   MBS      Muon Barrel statistics bank (not yet used)
*B.2   MES      Muon Endcap statistics bank (not yet used)
*B.3   MMS      Muon Barrel/Endcap statistics bank (not yet used)
*B/LINK
*B.DATA
*B.1   IFMBS    Flag for MB statistics (not defined)
*B.2   IFMES    Flag for ME statistics (not defined)
*B.3   IFMMS    Flag for MM statistics (not defined)
*B/DATA
*B/
+DECK,FOS. AVAILABLE IN SEQUENCE ROSPAR
*B..FOS  Forward Detector statistics bank (not yet used).
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    3
*B.NL    3
*B.NS    3
*B.NX    None
*B.UP    RST  -8
*B.OR    RST  -8
*B.LINK
*B.1   FDSR     Right forward Detector statistics bank (not yet used)
*B.2   FDSL     Left forward Detector statistics bank (not yet used)
*B.3   SWS      Silicon Tungsten  statistics bank (not yet used)
*B/LINK
*B.DATA
*B.1   IFFDS    Flag for FD statistics (not defined)
*B.3   NOTUSED
*B.3   IISWS    Flag for SW statistics (not defined)
*B/DATA
*B/
+DECK,ODS. AVAILABLE IN SEQUENCE ROSPAR
*B..ODS  DST statistics bank (not yet used).
*B.AU    S.Weisz
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IROSTA
*B.ND    1
*B.NL    1
*B.NS    1
*B.NX    None
*B.UP    RST  -10
*B.OR    RST  -10
*B.LINK
*B.1   ????     Spare
*B/LINK
*B.DATA
*B.1   ????     Spare
*B/DATA
*B/
+DECK,REHD.
*B..REHD REPORT header bank in statistics division.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IRESTO
*B.DV    IREDIV
*B.ND    6
*B.NL    6
*B.NS    6
*B.NX    None
*B.UP    None
*B.OR    None
*B.LINK
*B.1 RSUS       Success report bank in statistics division.
*B.2 RINS       Information report bank in statistics division.
*B.3 RWAS       Warning report bank in statistics division.
*B.4 RERS       Error report bank in statistics division.
*B.5 RFAS       Fatal report bank in statistics division.
*B.6 RCRS       Crash report bank in statistics division.
*B/LINK
*B.DATA
*B.1 NRSUS      Nb success report bank in statistics division.
*B.2 NRINS      Nb information report bank in statistics division.
*B.3 NRWAS      Nb Warning report bank in statistics division.
*B.4 NRERS      Nb Error report bank in statistics division.
*B.5 NRFAS      Nb Fatal report bank in statistics division.
*B.6 NRCRS      Nb Crash report bank in statistics division.
*B/DATA
*B/
+DECK,RSUS.
*B..RSUS Succes report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IRESTO
*B.DV    IREDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RSUS
*B.UP    REHD -1
*B.OR    REHD -1
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RINS.
*B..RINS Information report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IRESTO
*B.DV    IREDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RINS
*B.UP    REHD -2
*B.OR    REHD -2
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RWAS.
*B..RWAS Warning report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IRESTO
*B.DV    IREDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RWAS
*B.UP    REHD -3
*B.OR    REHD -3
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RERS.
*B..RERS Error report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IRESTO
*B.DV    IREDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RERS
*B.UP    REHD -4
*B.OR    REHD -4
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RFAS.
*B..RFAS Fatal report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IRESTO
*B.DV    IREDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RFAS
*B.UP    REHD -5
*B.OR    REHD -5
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+DECK,RCRS.
*B..RCRS Crash report bank.
*B.AU    A.Buijs,S.Weisz
*B.VERS  1.00
*B.ST    IRESTO
*B.DV    IREDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    RCRS
*B.UP    REHD -6
*B.OR    REHD -6
*B.DATA
*B.1 IDMESS     Message identifier.
*B.2 NBMESS     Nb occurences of this message.
*B.3 ????       Spare
*B.4 ????       Spare
*B.5 CHREP      Message send to REPORT.
*B/DATA
*B/
+PATCH,ROCDF,T=DATA.
>Name ROIKU

>Menu ROPE
>Guidance
ROPE interactive commands: main menu

>Command TRIG
>Parameters
+
NPROC  'No. events to process'        I  D=1
>Guidance
Get a new event, process NPROC if requested with PROCESS ON.
>Action ROGOKU

>Command SKIP
>Parameters
NSKIP  'No. events to skip'           I  D=1
NPROC  'No. events to process'        I  D=1
>Guidance
Skip N events, get N+1 th.
Process NPROC if requested with PROCESS ON.
>Action ROGOKU

>Command GOTO
>Parameters
IEVGET 'Get event#'                  I  D=0
+
IRUGET 'In run#'                     I  D=0
CWHAT 'In data/MC/hotline/current' C D='CURRENT' R='DATA,MCARLO,HOTLINE,CURRENT'
>Guidance
 With option DATA or MCARLO:
 Get event IEVGET of run IRUGET for data or MC from shift-server

 With option HOTLINE:
 if run# =   0: get latest hotline run events
 if event# = 0: get next event found

 With option CURRENT:
 Get event in data files defined by FFREAD cards, or interactively.
>Action ROGOKU

>Command EVFIND
>Parameters
IEVGET 'Get event#      '            I  D=0
IRUGET 'In run#         '            I  D=0
CWHAT 'In data/MC/hotline/current' C D='DATA' R='DATA,MCARLO,HOTLINE,CURRENT'

>Guidance
 With option DATA or MCARLO:
 Get event IEVGET of run IRUGET for data or MC from shift-server

 With option HOTLINE:
 if run# =   0: get latest hotline run events
 if event# = 0: get next event found

 With option CURRENT:
 Get event in data files defined by FFREAD cards, or interactively.
>Action ROGOKU

>Command PROCESS
>Parameters
CHOPT  'Option to call ROBAT'          C  D='ON'
>Guidance
Set ON/OFF the event processing folowing TRIG/SKIP/GOTO.
>Action ROGOKU

>Command RIOSEL
>Parameters
LUN    'Logical unit No.'              I  D=0
ISEL   'Selection flag'                I  D=0
>Guidance
Select output units: LUN = 0 --> all units selected.
>Action ROGOKU

>Command ROWOUT
>Guidance
Write to selected output units.
>Action ROGOKU

>Command ROBAT
>Guidance
Run ROPE according to FFREAD cards.
>Action ROGOKU

>Command DIVERT
>Guidance
Divert printed output to a file. Use option: "TERMINAL" to
close file and use screen again.
>Parameters
CWHERE  'Where to divert (FILE/TERM)' C D='TERMINAL' R='TERMINAL,FILE'
CFNAME  'File name'                   C D='rope.printout'
>Action RODIVE

>Command REWIND
>Guidance
Rewind input (disk file) to acces previous events.
>Action ROGOKU

>Command VERSION
>Guidance
Print versions of available processes.
>Action RPRTVS

>Command FILE
>Parameters
CFNAME  'File name'         C
+
FTYPE   'File type'         C D='DATA' R='DATA,DST,DDST,COPY'
DIRCET  'Direction'         C D='IN'   R='IN,OUT'
LREC    'Record length'     I  D=0
ZOPT    'ZEBRA options '    C  D='L   '
ROPT    'ROPE options '     C  D='.   '
>Guidance
Open a new file for input or output.
When an output file has been defined, use the command ROWOUT to
write out the current event.
>Action ROFILE

>Command DADFILE
>Parameters
CFNAME  'File name'         C
>Guidance
Open a new dadlist for input.
>Action ROFILE

>Command EVTFILE
>Parameters
CFNAME  'File name'         C
>Guidance
Open a new eventlist for input.
>Action ROFILE

>Command INPUT
>Parameters
CFNAME 'Input file'                  C  D='    '
+
LREC   'Record length'               I  D=0
CHOPT  'ZEBRA options for FZFILE'    C  D='I   '
>Guidance
Open a new file for input or output.
This command is obsolete, please use ROFILE instead
>Action ROFILE

>Menu \CHARGINO
>Guidance
Set/print cut parameters, rerun selection code (ROCHSE)

>Command Rerun
>Guidance
Rerun "chargino" classification.
>Action ROCHSI

>Command Print
>Guidance
Print cut parameters + values
>Action ROCHPR

>Menu Setcuts
>Guidance
Set cut parameters

>Command Tracks
>Guidance
Track quality criteria
>Parameters
CHTRQU1 'minimal number of CJ hits'       R D=20.
CHTRQU2 '1/(fract of max. poss CJ hits)'  R D=2.
CHTRQU3 'd0 cut'                          R D=5.
CHTRQU4 'z0 cut'                          R D=40.
CHTRQU5 'radius of first meas hit in CJ'  R D=60.
CHTRQU6 'Chi^2/DGF in r-phi'              R D=999.
CHTRQU7 'Chi^2/DGF in s-z'                R D=999.
CHTRQU8 'transverse momentum of track'    R D=0.05
CHTRQU9 'Maximal momentum / EBEAM'        R D=9999.9
>Action ROCHSC

>Command ECAL
>Guidance
ECAL quality criteria quality criteria
>Parameters
CHECQU1 'min raw energy in EB cl' R D=0.1
CHECQU2 'min raw energy in EE cl' R D=0.2
CHECQU3 'min nr of blocks in EE cluste' R D=2.0
>Action ROCHSC

>Command LooseGen
>Guidance
cut values for loose general acoplanar selection
>Parameters
CHSEL1_1 'Min energy in both hemispheres'    R D=1.0
CHSEL1_2 'Max energy in FD'                  R D=2.0
CHSEL1_3 'Min number of good charged tracks' R D=2.0
CHSEL1_4 'Visible Energy / sqrt(s)'          R D=0.08
CHSEL1_5 'Acoplanarity angle'                R D=10.0
CHSEL1_6 'Scale for corr with E_vis'         R D=0.0
CHSEL1_7 '| cos(theta_Pmiss) |'              R D=0.9
CHSEL1_8 '| cos(theta_jet_max) |!DUMMY!'     R D=9999.9
CHSEL1_9 '| cos(theta_thrust) |'             R D=9999.9
CHSEL1_0 'Energy fract in forward region'    R D=9999.9
>Action ROCHSC

>Command TightGen
>Guidance
cut values for tight general acoplanar selection
>Parameters
CHSET1_1 'Min energy in both hemispheres'    R D=1.0
CHSET1_2 'Max energy in FD'                  R D=2.0
CHSET1_3 'Min number of good charged tracks' R D=2.0
CHSET1_4 'Visible Energy / sqrt(s)'          R D=0.1
CHSET1_5 'Acoplanarity angle'                R D=20.0
CHSET1_6 'Scale for corr with E_vis'         R D=1.0
CHSET1_7 '| cos(theta_Pmiss) |'              R D=0.9
CHSET1_8 '| cos(theta_jet_max) |!DUMMY!'     R D=9999.9
CHSET1_9 '| cos(theta_thrust) |'             R D=0.7
CHSET1_0 'Energy fract in forward region'    R D=9999.9
>Action ROCHSC

>Command LooseLow
>Guidance
cut values for loose low multiplicity selection
>Parameters
CHSEL2_1 'Min energy in both hemispheres'    R D=1.0
CHSEL2_2 'Max energy in FD'                  R D=2.0
CHSEL2_3 'Min number of good charged tracks' R D=2.0
CHSEL2_4 'Max number of good charged tracks' R D=10.0
CHSEL2_5 'Visible Energy / sqrt(s)'          R D=-1.
CHSEL2_6 'Acoplanarity angle'                R D=10.0
CHSEL2_7 '| cos(theta_Pmiss) |'              R D=0.9
CHSEL2_8 '| cos(theta_jet_max) |!DUMMY!'     R D=9999.9
CHSEL2_9 '| cos(theta_thrust) |'             R D=9999.9
CHSEL2_10 'p_t'                              R D=3.0
CHSEL2_11 'Sum of energy inside cones'       R D=-1.
CHSEL2_12 'Sum of energy outside cones'      R D=9999.9
CHSET1_13 'Energy fract in forward region'   R D=9999.9
>Action ROCHSC

>Command TightLow
>Guidance
cut values for tight low multiplicity selection
>Parameters
CHSET2_1 'Min energy in both hemispheres'    R D=1.0
CHSET2_2 'Max energy in FD'                  R D=2.0
CHSET2_3 'Min number of good charged tracks' R D=2.0
CHSET2_4 'Max number of good charged tracks' R D=8.0
CHSET2_5 'Visible Energy / sqrt(s)'          R D=-1.
CHSET2_6 'Acoplanarity angle'                R D=20.0
CHSET2_7 '| cos(theta_Pmiss) |'              R D=0.9
CHSET2_8 '| cos(theta_jet_max) |'            R D=0.9
CHSET2_9 '| cos(theta_thrust) |'             R D=9999.9
CHSET2_10 'p_t'                              R D=4.0
CHSET2_11 'Sum of energy inside cones'       R D=-1.
CHSET2_12 'Sum of energy outside cones'      R D=5.0
CHSET1_13 'Energy fract in forward region'   R D=9999.9
>Action ROCHSC

>Command LooseMon
>Guidance
cut values for loose monojet selection
>Parameters
CHSEL3_1 'Min energy in both hemispheres'    R D=1.0
CHSEL3_2 'Max energy in FD'                  R D=2.0
CHSEL3_3 'Min number of good charged tracks' R D=2.0
CHSEL3_4 'Visible Energy / sqrt(s)'          R D=-1.
CHSEL3_5 '| cos(theta_Pmiss) |'              R D=0.9
CHSEL3_6 '| cos(theta_thrust) |'             R D=9999.9
CHSEL3_7 'p_t'                               R D=3.0
CHSEL3_8 'Total invariant Mass'              R D=-1.
CHSET1_9 'Energy fract in forward region'    R D=9999.9
>Action ROCHSC

>Command TightMon
>Guidance
cut values for tight monojet selection
>Parameters
CHSET3_1 'Min energy in both hemispheres'    R D=1.0
CHSET3_2 'Max energy in FD'                  R D=2.0
CHSET3_3 'Min number of good charged tracks' R D=2.0
CHSET3_4 'Visible Energy / sqrt(s)'          R D=-1.
CHSET3_5 '| cos(theta_Pmiss) |'              R D=0.9
CHSET3_6 '| cos(theta_thrust) |'             R D=0.7
CHSET3_7 'p_t'                               R D=4.0
CHSET3_8 'Total invariant Mass'              R D=2.0.
CHSET1_9 'Energy fract in forward region'    R D=9999.9
>Action ROCHSC

>Menu \\\CD
>Guidance
Interactive commands for Central Detector.

>Command CVBAT
>Guidance
CV steering routine.
>Action CVBAT

>Command CJBAT
>Guidance
CJ steering routine.
>Action JCBAT

>Command JCBAT
>Guidance
CJ steering routine.
>Action JCBAT

>Command CZBAT
>Guidance
CZ steering routine.
>Action CZBAT

>Command CTBAT
>Guidance
CT steering routine.
>Action CTBAT

>Command DXBAT
>Guidance
DX steering routine.
>Action DXBAT

>Command CXBAT
>Guidance
CX steering routine.
>Action CXBAT

>Command CFBAT
>Guidance
CF steering routine.
>Action CFBAT

>Command SIBAT
>Guidance
SI steering routine.
>Action SIBAT

>Command CSBAT
>Guidance
CS steering routine.
>Action CSBAT

>Command CEBAT
>Guidance
CE steering routine.
>Action CEBAT

>Command CABAT
>Guidance
CA steering routine.
>Action CABAT

>Menu CENTRAL
>Guidance
Interactive steering of central processors.

>Command SHOW
>Guidance
Show selected CENTRAL processes
>Action ROCENT

>Command SET
>Parameter
+
PROCESS 'Name(s) of central process(es) to run'     C  D='    '
>Guidance
Set selection of CENTRAL processes
>Action ROCENT

>Menu \\EC
>Guidance
Interactive commands for Electro-magnetic Calorimeter.

>Command TBBAT
>Guidance
TB steering routine.
>Action TBBAT

>Command PBBAT
>Guidance
PB steering routine.
>Action PBBAT

>Command EBBAT
>Guidance
EB steering routine.
>Action EBBAT

>Command PEBAT
>Guidance
PE steering routine.
>Action PEBAT

>Command EEBAT
>Guidance
EE steering routine.
>Action EEBAT

>Command EMBAT
>Guidance
EM steering routine.
>Action EMBAT

>Menu ECAL
>Guidance
Interactive steering of Ecal processors.

>Command SHOW
>Guidance
Show selected ECAL processes
>Action ROECAL

>Command SET
>Parameter
+
PROCESS 'Name(s) of Ecal process(es) to run'     C  D='    '
>Guidance
Set selection of ECAL processes
>Action ROECAL

>Menu \\HC
>Guidance
Interactive commands for Hadronic Calorimeter.

>Command HBBAT
>Guidance
HB steering routine.
>Action HBBAT

>Command HEBAT
>Guidance
HE steering routine.
>Action HEBAT

>Command HPBAT
>Guidance
HP steering routine.
>Action HPBAT

>Command HMBAT
>Guidance
HM steering routine.
>Action HMBAT

>Menu HCAL
>Guidance
Interactive steering of Hcal processors.

>Command SHOW
>Guidance
Show selected HCAL processes
>Action ROHCAL

>Command SET
>Parameter
+
PROCESS 'Name(s) of Hcal process(es) to run'     C  D='    '
>Guidance
Set selection of HCAL processes
>Action ROHCAL

>Menu \\MU
>Guidance
Interactive commands for Muon chamber.

>Command MBBAT
>Guidance
MB steering routine.
>Action MBBAT

>Command MEBAT
>Guidance
ME steering routine.
>Action MEBAT

>Command MMBAT
>Guidance
MM steering routine.
>Action MMBAT

>Menu MUON
>Guidance
Interactive steering of Muon processors.

>Command SHOW
>Guidance
Show selected Muon processes
>Action ROMUON

>Command SET
>Parameter
+
PROCESS 'Name(s) of Muon process(es) to run'     C  D='    '
>Guidance
Set selection of Muon processes
>Action ROMUON

>Menu \\FO
>Guidance
Interactive commands for Forward detector

>Command FDBAT
>Guidance
FD steering routine.
>Action FDBAT

>Menu FORW
>Guidance
Interactive steering of Forward processors.

>Command SHOW
>Guidance
Show selected Forward processes
>Action ROFORW

>Command SET
>Parameter
+
PROCESS 'Name(s) of Forward process(es) to run'     C  D='    '
>Guidance
Set selection of Forward processes
>Action ROFORW

>Menu \\DEBUG
>Guidance
ROPE debugging commands.

>Command ROSIZE
>Parameters
IDH    'Bank hollerlith identifier'  C  D='    '
IDN    'Bank numeric identifier'     I  D=0
>Guidance
Print memory size of a ZEBRA bank.
>Action ROGOKU

>Command DZSNAP
>Guidance
Snap shot of ZEBRA store.
>Action ROGOKU

>Command DZSURV
>Parameters
IDH    'Bank hollerlith identifier'  C  D='    '
IDN    'Bank numeric identifier'     I  D=0
>Guidance
Survey of ZEBRA store.
>Action ROGOKU

>Command DZSHOW
>Parameters
IDH    'Bank hollerlith identifier'  C  D='    '
IDN    'Bank numeric identifier'     I  D=0
+
CHOPT  'Dump option'                 C  D='BLV'
>Guidance
Dump of a ZEBRA bank.
>Action ROGOKU

>Command DZVERI
>Guidance
Verify ROPE division.
>Action ROGOKU

>Command SCAN
>Parameters
IFSCAN 'Flag for input scan file'    I  D=1
>Guidance
Set flag for input scan file.
>Action ROGOKU

>Command NODROP
>Parameters
IFDROP 'Flag to steer XXDROP calls'  I  D=0
>Guidance
Set flag to steer XXDROP calls.
>Action ROGOKU

>Command CONSTANT
>Parameters
IFCNST 'Constant rec. control flag'  I  D=1
>Guidance
Set flag to control writing of constant records.
>Action ROGOKU

>Menu \GE
>Guidance
Commands to get original GOPAL information.

>Command ROTREE
>Parameters
+
IT     'Track number'                I  D=0
>Guidance
Print Kinematics transmitted to ROPE in TREE structure.
>Action ROGOKU

>Command GOTREE
>Guidance
Print Kinematics transmitted to ROPE in TREE structure.
IT=0: all tracks,
IT<0: print track IT with its  ancestors and descendants
>Parameters
+
IT     'Track number'                I  D=0
>Action GOTREI

>Menu \EVSEL
>Guidance
Cuts for selection of events

>Command GET
>Guidance
Get the next event satisfying the cuts set using EVSEL.
>Action ROGOKU

>Command SHOW
>Guidance
Show cuts / bits for selection of events
>Parameters
EVPAR  'Cut parameter / selection bits'     C  D='BITS' R='ALL,_
BITS,NCT,EEC,EHC,EV'
>Action ROEVSL

>Command ENABLE
>Guidance
Enable event selection based on cuts and bits in header words
>Action ROESTY

>Command IGNORE
>Guidance
Disable (ignore) selection based on cuts and bits in header words
>Action ROESTY

>Menu SET
>Guidance
Define cuts/bits for selection of events

>Command EVTYPE
>Guidance
Select an event by its Event Type (ROPE)
+SEQ,ROTPARDOC.
>Parameters
OPTION 'Mnemonic for type' C  D='NONE'
-NONE Select by Bit number
-LLLM Low mult presel
-LLQQ High mult veto
-LLCO Cosmic ray veto
-LLIL LL Isolated Lepton
-GAM  Singl phot presel
-HLPT Heavy lept MissE
-HLIS Heavy lept IsolTrk
-TWOP Tagged two phot
-HIGS Higgs high mult
-GSTR Valid single phot
-HLCM Heavy lept Close-m
-TKMH TKMH multihadron
-LLEE Electron pair
-LLMM Muon pair
-LLTT Tau pair
-LLLL Lepton pair
-FYZ1 Phys1 selection
-FYZS Z0 type physics
-FYZT Lumi type physics
-TETR TE stud prescale
-GACE Chgino Gen ACop
-LMAE Chgino LowMul ACop
-MONO Chgino MONOJET
-GOPL GP Chargino
-NELO Neutralino loose
-NETI Neutralino tight
-NELO Neutralino loose
-UGGE Excl. Untag 2gamma
-IUGG Incl. Untag 2gamma
-WABB Wide Angle BhaBha
-L2MH LEP2 MultiHadron
-XXXX unused
-NGAM N-GAMma
-NRH1 Non-rad MH,simple
-NRH2 Non-rad MH,complex
-WW4Q WW ->  qq qq
-WWQE WW ->  qq  e nu
-WWQM WW ->  qq  mu nu
-WWQT WW ->  qq  tau nu
-WWLL WW ->  l nu  l nu

+
IBITNR 'Bit number (if mnemonic NONE)' I D=0 R=-1:64
SETUNS 'Set or unset, BitNr=-1:reset all bits' C D='SET' R='SET,UNSET'
CVETO  'Select or Veto'                C D='Select' R='Select,Veto'
>Action ROESTY

>Command FITYPE
>Guidance
Select an event by its Filter Type
>Parameters
CTYPE 'Mnemonic for type' C  D='NONE' R='NONE,-
+
IBITNR 'Bit number (if mnemonic NONE)' I D=0 R=-1:32
SETUNS 'Set or unset'                  C D='SET' R='SET,UNSET'
CVETO  'Select or Veto'                C D='Select' R='Select,Veto'
>Action ROESTY

>Command TRWA
>Guidance
Select an event by its trigger bits (97-128)
>Parameters
CTYPE 'Mnemonic for type' C  D='NONE' R='NONE,-
+
IBITNR 'Bit number (if mnemonic NONE)' I D=0 R=-1:32
SETUNS 'Set or unset'                  C D='SET' R='SET,UNSET'
CVETO  'Select or Veto'                C D='Select' R='Select,Veto'
>Action ROESTY

>Command TRWB
>Guidance
Select an event by its trigger bits (65-96)
>Parameters
CTYPE 'Mnemonic for type' C  D='NONE' R='NONE,-
+
IBITNR 'Bit number (if mnemonic NONE)' I D=0 R=-1:32
SETUNS 'Set or unset'                  C D='SET' R='SET,UNSET'
CVETO  'Select or Veto'                C D='Select' R='Select,Veto'
>Action ROESTY

>Command TRWC
>Guidance
Select an event by its trigger bits (33-64)
>Parameters
CTYPE 'Mnemonic for type' C  D='NONE' R='NONE,-
+
IBITNR 'Bit number (if mnemonic NONE)' I D=0 R=-1:32
SETUNS 'Set or unset'                  C D='SET' R='SET,UNSET'
CVETO  'Select or Veto'                C D='Select' R='Select,Veto'
>Action ROESTY

>Command TRWD
>Guidance
Select an event by its trigger bits (1-32)
>Parameters
CTYPE 'Mnemonic for type' C  D='NONE' R='NONE,-
+
IBITNR 'Bit number (if mnemonic NONE)' I D=0 R=-1:32
SETUNS 'Set or unset'                  C D='SET' R='SET,UNSET'
CVETO  'Select or Veto'                C D='Select' R='Select,Veto'
>Action ROESTY

>Command NCTRK
>Guidance
Minimum and maximum number of charged tracks
>Parameters
NCMIN  'Minimum number of charged tracks'  I  D=0     R=0:9999
NCMAX  'Maximum number of charged tracks'  I  D=9999  R=0:9999
>Action ROEVSL

>Command EECAL
>Guidance
Minimum and maximum energy in electromagnetic calorimeters
>Parameters
EEMIN 'Min. energy in electromagnetic calorimeters' R D=0.    R=0.:9999.
EEMAX 'Max. energy in electromagnetic calorimeters' R D=9999. R=0.:9999.
>Action ROEVSL

>Command EHCAL
>Guidance
Minimum and maximum energy in hadronic calorimeters
>Parameters
EHMIN  'Minimum energy in hadronic calorimeters' R  D=0.    R=0.:9999.
EHMAX  'Maximum energy in hadronic calorimeters' R  D=9999. R=0.:9999.
>Action ROEVSL

>Command NMUON
>Guidance
Minimum and maximum number of muon segments
>Parameters
NMUMIN 'Minimum number of muon segments' I  D=0     R=0:9999
NMUMAX 'Maximum number of muon segments' I  D=9999  R=0:9999
>Action ROEVSL

>Command EVENT
>Guidance
Select an event by its trigger number and run number
>Parameters
IEVT 'Trigger number selected (IEVT=0 -> no select)' I D=0 R=0:9999999
+
IRUN 'Run number selected (IRUN=0 -> no selection)' I D=0 R=0:9999999
>Action ROEVSL
+PATCH,CROUTINES,T=XCC.
+DECK,EVGET,T=XCC.
/*
 *     evclient package
 *
 *        -- Fortran callable routines to get events from shift  --
 *
 *        default server is shift6.cern.ch (since 18-feb-98)
 *          can be overriden with EVENT_SERVER environment variable
 *
 *        rocgep ( int *irun, int *iev, int *iflag,
 *                  int *iret, int *ib, int *io, int *il )
 *
 *              opens connection to shift-sever
 *              sends run-#, ev-# and flag (0 data, 1 MC, -1 for close)
 *              to server
 *              reads status, block-offset, byte offset, length back
 *              status is : 0 ok
 *                          1 not in dad_database
 *                          2 file not found
 *                          3 file read error
 *                         -1 connection open error
 *                         -2 connection communication problem
 *
 *
 *        rocged ( int *nget, int *nput, int *ibuf, int *iret )
 *
 *              reads data from server
 *                 nget = number of words requested
 *                 nput = number of words found
 *                 ibuf = buffer
 *                 iret = 0 ok
 *                      = 1 less found than requested
 *                      = 2 end of data
 *                      = 3 other trouble
 *
 */

#define EV_version "0.1"


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#ifdef VMS
#include <descrip.h>
#include <stdlib.h>
#include <uaidef.h>
#include <unixlib.h>
#ifdef UCX
#include netdb
#else
#ifdef WIN
#include "twg$tcp:[netdist.include]netdb.h"
#else
#include "multinet_root:[multinet.include]netdb.h"
#endif
#endif
#endif


#if unix | _AIX
#include <pwd.h>
#include <netdb.h>
#endif

#if unix | _AIX
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define CLOSE close
#define READ  read
#define WRITE write

#endif

#ifdef VMS
extern int bzero(), bcopy(), connect(), gethostname(), socket();
#ifdef UCX
#include types
#include in
#include socket

extern int close(), read(), write();
#define CLOSE close
#define READ  read
#define WRITE write

#define bzero(b, len) memset(b, '\0', len)
#define bcopy(b1, b2, len) memmove(b2, b1, len)
#define getservbyname(s1, s2) NULL
#else
extern int htons();
#ifdef WIN
#include "twg$tcp:[netdist.include.sys]types.h"
#include "twg$tcp:[netdist.include.netinet]in.h"
#include "twg$tcp:[netdist.include.sys]socket.h"

extern int netclose(), netread(), netwrite();
#define CLOSE netclose
#define READ  netread
#define WRITE netwrite
#else
#include "multinet_root:[multinet.include.sys]types.h"
#include "multinet_root:[multinet.include.netinet]in.h"
#include "multinet_root:[multinet.include.sys]socket.h"

extern int socket_close(), socket_read(), socket_write();
#define CLOSE socket_close
#define READ  socket_read
#define WRITE socket_write
#endif
#endif
#endif
/*     on UNIX append a underscore to f77 callables      */
#ifdef unix
#define roswab  roswab_
#define rocgep rocgep_
#define rocged rocged_
#endif
#define BUFSIZE 256                /* Size of buffer */
#define MSGSIZE 1024                /* Size of buffer for read/write */
#define CTOKEN  '>'
#define STOKEN  ">"
#define NBYTPW  4
#define EVBLEN  8100
#define MIN( a, b ) ((a) < (b) ? (a) : (b))
#define MAX( a, b ) ((a) > (b) ? (a) : (b))
#define ABS( a )    ( (a) > 0  ? (a) : -(a) )

static char *ev_server  = "shift6.cern.ch";

static char *ev_service  = "opalevs";
static int   ev_port      = 8012;

static char line[BUFSIZE];
static char buffer[BUFSIZE];

#ifdef KUIP
extern char *cuserid();
/* OS start */
extern char *ku_proc();
/* OS end */
#endif

int connected = 0;              /* Flag if c/s connection established */
int data_read = 0;              /* Flag if still data to read         */
int evsize    = 0;              /* Event-size                         */
int evrest    = 0;              /* still to be read                   */
int sock ;


#ifdef TEST
int main()
{
  struct ev_info {
    int run;
    int event;
    int flag;
  } evsend;
  struct ev_file {
    int block_off;
    int word_off;
    int len;
    int status;
    int run      ;
    int event    ;
  } evget;

  int evbuf[EVBLEN];

  int nwtot, nwords, nput, iret;
  FILE *nfp;

  void rocgep();
  void rocged();

  nfp = fopen("event.data","w");

  while ( 1 )
    {
      if( read_event(&evsend) != 0 )
        {
          exit(0);
        }

      rocgep ( &evsend.run, &evsend.event, &evsend.flag,
                 &evget.status, &evget.block_off, &evget.word_off,
                 &evget.len, &evget.run, &evget.event );

      nwtot  = evget.len;
      nwords = MIN(EVBLEN,nwtot);

      if ( evget.status != 0 )
        {
          fprintf(stderr, "Bad status from rocgep %d\n", evget.status );
          fflush(stderr);
          continue;
        }

      while ( nwtot > 0 )
        {
          rocged ( &nwords, &nput, evbuf, &iret ) ;
          nwtot -= nput;
          nwords = MIN(EVBLEN,nwtot);
          fwrite( evbuf, NBYTPW, nput, nfp );
        }

    }
  fclose(nfp);
}

int read_event( evi )
     struct ev_info {
       int run;
       int event;
       int flag;
     } *evi;
{
  printf("Give run-num, ev-num, flag (0=data,1=MC)\n");

  if ( scanf("%d %d %d",&evi->run,&evi->event, &evi->flag) != 3 )
    return(-1);
  else
    return(0);
}

#endif

unsigned long roswab (iword)
unsigned long *iword;
{
   return(htonl(*iword));
}

void rocgep ( irun, iev, iflag, iret, ib, io, il, iruno, ievo )
int *irun, *iev, *iflag, *iret, *ib, *io, *il, *iruno, *ievo;
{
  void fetchhostinfo(), fetchuserinfo(), clear_connection();

  int establish();
  int sndmsg();
  char dum[100];

  struct ev_info {
    int run;
    int event;
    int flag;
  } evsend;
  struct ev_file {
    int block_off;
    int word_off;
    int len;
    int status;
    int run      ;
    int event    ;
  } evget;

  int nbyte;
/* OS start */
  char cprompt[50];
  char * creturn;
/* OS end */
  /* close connection */
  if ( *iflag < 0  )
    {
      if ( connected )
        {
          evsend.run   = 0;
          evsend.event = 0;
          evsend.flag  = -1;

          WRITE(sock, &evsend, sizeof( evsend ));
          CLOSE( sock );
        }
      *iret = 0;
      return;
    }


  if ( ! connected )
    {
      /* Fetch host and user information */
      sprintf(buffer, "%s%c", EV_version, CTOKEN);
      fetchhostinfo(buffer);
      fetchuserinfo(buffer);

      /* Establish communication with the EV server */
#ifdef TEST
      printf("Connecting ... ok ?\n");
      scanf("%s", dum);
#endif
      if ( (sock = establish()) < 0 )
        {
          fprintf(stderr, "Can't open connection to %s\n", ev_server);
          fflush(stderr);
          *iret = -1 ;
          return;
        }
#ifdef TEST

      printf("Sending info ... ok ?\n");
      scanf("%s", dum);
#endif
      /* send the user-info */
      if ( sndmsg(sock, buffer) < 0 )
        {
          *iret = -2 ;
          return;
        }
      data_read = 0;
      connected = 1;
    }

  /* Clear network buffer  */
  if ( data_read )
    {
      clear_connection();
      data_read = 0;
    }

  evsend.run   = *irun;
  evsend.event = *iev;
  evsend.flag  = *iflag;


 request_ev:
  /* write request */
#ifdef TEST
  printf("writing request ... ok ? %d % d %d \n",
  evsend.run, evsend.event, evsend.flag );
  scanf("%s", dum);
#endif

  evsend.run   = htonl(evsend.run);
  evsend.event = htonl(evsend.event);
  evsend.flag  = htonl(evsend.flag);
  if( ( nbyte = WRITE(sock, &evsend, sizeof( evsend ))) < 0 )
    {
      fprintf(stderr, "Can't send event-info over the network %d.\n", nbyte);
      fflush(stderr);
      *iret = -2;
      CLOSE(sock);
      return;
    }

  /* read back event-info */
  if( ( nbyte = READ(sock, &evget, sizeof( evget ))) < 0 )
    {
      fprintf(stderr, "Can't read event-info over the network %d.\n", nbyte);
      fflush(stderr);
      *iret = -2;
      CLOSE(sock);
      connected = 0;
      return;
    }
  evget.status    = ntohl(evget.status);
  evget.block_off = ntohl(evget.block_off);
  evget.word_off  = ntohl(evget.word_off);
  evget.len       = ntohl(evget.len);
  evget.run       = ntohl(evget.run);
  evget.event     = ntohl(evget.event);

  *iret = evget.status;
  *ib   = evget.block_off;
  *io   = evget.word_off;
  *il   = evget.len;
  *iruno= evget.run;
  *ievo = evget.event;

#ifdef TEST
  printf("%d %d %d %d %d %d \n", *iret, *ib, *io, *il, *iruno, *ievo );
#endif
  if ( evget.len > 0 && evget.status == 0 )
    {
      data_read = 1;
      evsize = evget.len;
      evrest = evget.len;
    }

  if ( evget.status != 0 )
    {
      switch( evget.status )
        {
        case 1:
          printf("Nothing found for requested run %d, event %d, flag %d\n",
                 evsend.run, evsend.event, evsend.flag );
          break;
        case 2:
          printf("File not found  for requested run %d, event %d, flag %d\n",
                 evsend.run, evsend.event, evsend.flag );
          break;
        case 3:
          printf("Error reading file for requestd run %d, event %d, flag %d\n",
                 evsend.run, evsend.event, evsend.flag );
          break;
        case 55: /* position to next event */
          printf("Requested run %d, event %d, flag %d not found\n",
                 evsend.run, evsend.event, evsend.flag );

#ifdef KUIP
/* OS start */
          sprintf(cprompt,"Requested event %d, not found, take next %d",
                   evsend.event,evget.event);
          creturn=ku_proc( cprompt, "YES");
          if ( strcmp(creturn,"YES") !=  0)
            {
             *iret = -33;
             break;
            }

/* OS end */
#endif
          evsend.run   = evget.run;
          evsend.event = evget.event;
          evsend.flag  = *iflag;
          printf("Take next: run %d, event %d\n",
                 evsend.run, evsend.event );
          goto request_ev;
          break;

        case -5:
          fprintf(stderr,"Connection closed, shift-evt server not working\n");
          fflush(stderr);
          *iret = -5;
          CLOSE(sock);
          connected = 0;
          return;


        default:
          break;
        }
    }

  return;

}


void rocged ( nget, nput, ibuf, iret )
int *nget, *nput, *iret;
char *ibuf;
{
  int nbyte, nbyter, nbsum, idum;
  char *ip;

  if ( ! connected )
    {
      fprintf(stderr, "No connection\n" );
      fflush(stderr);
      *iret = 3;
      return;
    }

  if ( ! data_read )
    {
      fprintf(stderr, "Nothing to read\n" );
      fflush(stderr);
      *iret = 2;
      return;
    }


/* check if more stuff is requested as will be send */
  if ( *nget > evrest )
    {
      fprintf(stderr, "Error: too much requested: %d  left: %d\n",
              *nget, evrest);
      fflush(stderr);
      nbyte = evrest * NBYTPW;
    }
  else
    {
      nbyte  = *nget * NBYTPW;
    }
  ip     = ibuf;
  nbyter = 0;
  nbsum  = 0;
  while ( nbyte > 0 && (nbyter = READ(sock, ip, nbyte)) > 0 )
    {
#ifdef DEBUG
      idum = (int) ip[nbyter-4];
      printf("Reading: %d requested %d got  last %X  %\n",
      nbyte, nbyter, idum );
#endif
      nbyte -= nbyter;
      nbsum += nbyter;
      ip    += nbyter;
    }

  evrest -= nbsum / NBYTPW;
  *nput = nbsum / NBYTPW;
  if ( evrest <= 0 )
    {
      data_read = 0 ;
    }

  if ( nbsum != *nget * NBYTPW )
    {
      fprintf(stderr, "Trouble reading event: requested %d   read %d\n",
              *nget * NBYTPW, nbsum);
      fflush(stderr);
      *iret = -1;
    }
  else
    {
      *iret = 0;
    }
  return;
}

void fetchhostinfo(buf)
char *buf;
{
char tmp[BUFSIZE];
char name[BUFSIZE];
struct hostent *hostent;

        /* Local host name */
        if( !gethostname(name,BUFSIZE) ) {
                if( (hostent = gethostbyname(name)) != NULL )
                    sprintf(tmp, "%s%c", hostent->h_name, CTOKEN);
                else
                    sprintf(tmp, "%s%c", name, CTOKEN);
                strcat(buf, tmp);
        } else {
                fprintf(stderr, "Name of local host can't be found.\n");
                fflush(stderr);
        }
}


void fetchuserinfo(buf)
char *buf;
{
register char *fromuser, *workdir;
char tmp[BUFSIZE];

        fromuser = cuserid(NULL);
        if( fromuser == NULL  ) {
                fprintf(stderr, "User information can't be fetched.\n");
                fflush(stderr);
        }

        sprintf(tmp, "%s%c", fromuser, CTOKEN);
        strcat(buf, tmp);
}



int establish()
{
struct servent *servent;
int sock;
char *cp;
struct hostent *hostent;
struct sockaddr_in address;
int rcvval, sndval, len, iret;

        /* Build the address that we will bind() to */
        if( (servent = getservbyname(ev_service, "tcp")) == NULL ) {
                /* fprintf(stderr, "Service %s is unkown.\n", ev_service);
                fflush(stderr); */
        }

        /* Create a socket in Inet domain */
        if( (sock = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
                fprintf(stderr, "Can't create a socket.\n");
                fflush(stderr);
                return(-1);
        }

        if ( (cp= getenv("EVENT_SERVER")) != NULL )
                strcpy( ev_server, cp );
        if ( (cp= getenv("EVENT_SERVER_PORT")) != NULL )
                ( ev_server, cp );
        if( (hostent = gethostbyname(ev_server)) == NULL ) {
                fprintf(stderr, "Node %s unknown.\n", ev_server);
                fflush(stderr);
                return(-1);
        } else {
                /* Specify target object number for connection */
                bzero(&address, sizeof(address));
                bcopy(hostent->h_addr, &address.sin_addr, hostent->h_length);
                address.sin_family = AF_INET;
                address.sin_port = (servent != NULL ?
                                        servent->s_port : htons(ev_port));
                if ( (cp= getenv("EVENT_SERVER_PORT")) != NULL )
                  address.sin_port = htons( atol( cp ) );
        }

#ifdef DEBUG
        iret = getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&rcvval, &len);
        if ( iret != 0 ) perror("setsock");
        iret = getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *)&sndval, &len);
        if ( iret != 0 ) perror("setsock");
        printf("Socket_get %d   RCVBUF %d    SNDBUF %d\n",
               sock, rcvval, sndval);
#endif
        rcvval = 32768;
        iret = setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
                         (char *)&rcvval, sizeof(rcvval)) ;
        if ( iret != 0 ) perror("Error in setsockopt ");

#ifdef DEBUG
        printf("Socket_set %d   RCVBUF %d   iret %d\n", sock, rcvval, iret );
        iret = getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&rcvval, &len);
        if ( iret != 0 ) perror("setsock");
        printf("Socket_get %d   RCVBUF %d    SNDBUF %d\n",
               sock, rcvval, sndval);
#endif

        /* Connect to partner on specified node */
        if( connect(sock, &address, sizeof(address)) < 0 ) {
                fprintf(stderr, "Connection refused at host %s.\n", ev_server);
                fflush(stderr);
                return(-1);
        }

        return(sock);
}


int sndmsg(sock, buf)
int sock;
char *buf;
{
int len = strlen(buf), nw;

        if( ( nw = WRITE(sock, buf, len+1)) < 0 ) {
                fprintf(stderr, "Can't send message over the network.\n");
                fflush(stderr);
                return(-1);
        }
        return(nw);
}



void clear_connection()
{
  int evbuf[EVBLEN];
  int nbyte, nbyter;
  int nbytl;
  nbytl=evrest*NBYTPW;
  while ( nbytl > 0 )
    {
      nbyte = MAX(nbytl,EVBLEN*NBYTPW);
      nbyter =  READ( sock, evbuf, nbyte);
      nbytl -= nbyter;
    }
}
+DECK,ROPECDF,T=XCC.
/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 950303      Generation date: Wed Apr  2 09:24:22 1997
 *
 * Input file: ropetmp_cdf.cdf
 */

#if !defined(F77_LCASE) && !defined(F77_UCASE) && !defined(F77_USCORE)
#  if defined(__EXTENDED__) && !defined(IBM370) && !defined(_IBMR2)
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */

typedef struct _BrAction {      /*                                         */
  struct _BrAction *next;       /* link to next action binding             */
  BrActFlag   flags;            /*                                         */
  char       *text;             /* text line in menu                       */
  char       *user_text;        /* user text overriding CDF text (malloced)*/
  char       *accel;            /* accelerator                             */
  char       *exec;             /* action commands                         */
  SUBROUTINE *call_F;           /* action routine                          */
  IntFunc    *call_C;           /* action function                         */
  BrActTag    tag;              /* for which window the action is defined  */
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */

typedef struct _KmIcon {        /*                                         */
  struct _KmIcon *next;         /* link to next icon                       */
  char       *name;             /* unique identifier name                  */
  int         width;            /* width of the pixmap                     */
  int         height;           /* height of the pixmap                    */
  char       *bitmap;           /* bitmap data                             */
  KmPixmap    pix;              /* filled in Motif part                    */
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */

typedef enum {                  /*                                         */
  KmButtSensitive       = 0x00, /* sensitive button                        */
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */

struct {                        /*                                         */
  /* indirect calls to avoid linking HIGZ                                  */
  IntFunc    *graf_info_C;      /* pass display, open and close (ixmotif)  */
  SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)                  */
  SUBROUTINE *graf_pick_F;      /* identifying graphics objects (IGOBJ)    */
  SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)                  */
  SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)               */
  /* optional routines for Motif customization                             */
  pCharFunc  *user_FallBk_C;    /* get application fallbacks               */
  IntFunc    *user_TopWid_C;    /* pass toplevel widget identifiers        */
 } klnkaddr;                     /*                                         */

typedef enum {                  /*                                         */
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */

typedef struct {                /* file name                               */
  char         *filter_default; /* filter wildcard                         */
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */

typedef KmParInt KmParReal;     /* real and int have the same fields       */
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */

typedef struct _KmCommand {     /*                                         */
  struct _KmCommand *next;      /* link to next command                    */
  char         *path;           /* command path                            */
  char         *name;           /* command name                            */
  int           hidden;         /* flag if command is invisible            */
  int           level;          /* depth of submenus                       */
  int           total;          /* total number of parameters              */
  int           mandatory;      /* number of mandatory parameters          */
  KmParameter **par;            /* list of total parameter descriptions    */
  int           list_par;       /* index+1 of parameter taking a list      */
  int           xcount;         /* count number of action calls            */
  SUBROUTINE   *action_F;       /* action routine                          */
  IntFunc      *action_C;       /* action routine                          */
  SUBROUTINE   *user_help_F;    /* user help routine                       */
  pCharFunc    *user_help_C;    /* user help routine                       */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
  int           argc;           /* number of arguments entered             */
  char        **argv;           /* argc argument values                    */
  char         *argline;        /* argument line as entered                */
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */

typedef struct _KmMenu {        /*                                         */
  struct _KmMenu *next;         /* link to next menu                       */
  struct _KmMenu *down;         /* link to submenu                         */
  char         *path;           /* path of parent menu                     */
  char         *name;           /* menu name                               */
  int           level;          /* depth of submenus                       */
  KmCommand    *cmds;           /* link to first command                   */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */

#ifdef F77_LCASE
#  define roiku_ roiku
#  define rofile_ rofile
#  define rprtvs_ rprtvs
#  define rogoku_ rogoku
#  define rodive_ rodive
#  define rochsc_ rochsc
#  define rochpr_ rochpr
#  define rochsi_ rochsi
#  define rocent_ rocent
#  define cabat_ cabat
#  define cebat_ cebat
#  define csbat_ csbat
#  define sibat_ sibat
#  define cfbat_ cfbat
#  define cxbat_ cxbat
#  define dxbat_ dxbat
#  define ctbat_ ctbat
#  define czbat_ czbat
#  define jcbat_ jcbat
#  define cvbat_ cvbat
#  define roecal_ roecal
#  define embat_ embat
#  define eebat_ eebat
#  define pebat_ pebat
#  define ebbat_ ebbat
#  define pbbat_ pbbat
#  define tbbat_ tbbat
#  define rohcal_ rohcal
#  define hmbat_ hmbat
#  define hpbat_ hpbat
#  define hebat_ hebat
#  define hbbat_ hbbat
#  define romuon_ romuon
#  define mmbat_ mmbat
#  define mebat_ mebat
#  define mbbat_ mbbat
#  define roforw_ roforw
#  define fdbat_ fdbat
#  define gotrei_ gotrei
#  define roevsl_ roevsl
#  define roesty_ roesty
#endif

#ifdef F77_UCASE
#  define roiku_ ROIKU
#  define rofile_ ROFILE
#  define rprtvs_ RPRTVS
#  define rogoku_ ROGOKU
#  define rodive_ RODIVE
#  define rochsc_ ROCHSC
#  define rochpr_ ROCHPR
#  define rochsi_ ROCHSI
#  define rocent_ ROCENT
#  define cabat_ CABAT
#  define cebat_ CEBAT
#  define csbat_ CSBAT
#  define sibat_ SIBAT
#  define cfbat_ CFBAT
#  define cxbat_ CXBAT
#  define dxbat_ DXBAT
#  define ctbat_ CTBAT
#  define czbat_ CZBAT
#  define jcbat_ JCBAT
#  define cvbat_ CVBAT
#  define roecal_ ROECAL
#  define embat_ EMBAT
#  define eebat_ EEBAT
#  define pebat_ PEBAT
#  define ebbat_ EBBAT
#  define pbbat_ PBBAT
#  define tbbat_ TBBAT
#  define rohcal_ ROHCAL
#  define hmbat_ HMBAT
#  define hpbat_ HPBAT
#  define hebat_ HEBAT
#  define hbbat_ HBBAT
#  define romuon_ ROMUON
#  define mmbat_ MMBAT
#  define mebat_ MEBAT
#  define mbbat_ MBBAT
#  define roforw_ ROFORW
#  define fdbat_ FDBAT
#  define gotrei_ GOTREI
#  define roevsl_ ROEVSL
#  define roesty_ ROESTY
#endif

#ifdef IBM370
#  pragma linkage(ROIKU,FORTRAN)
#  pragma linkage(ROFILE,FORTRAN)
#  pragma linkage(RPRTVS,FORTRAN)
#  pragma linkage(ROGOKU,FORTRAN)
#  pragma linkage(RODIVE,FORTRAN)
#  pragma linkage(ROCHSC,FORTRAN)
#  pragma linkage(ROCHPR,FORTRAN)
#  pragma linkage(ROCHSI,FORTRAN)
#  pragma linkage(ROCENT,FORTRAN)
#  pragma linkage(CABAT,FORTRAN)
#  pragma linkage(CEBAT,FORTRAN)
#  pragma linkage(CSBAT,FORTRAN)
#  pragma linkage(SIBAT,FORTRAN)
#  pragma linkage(CFBAT,FORTRAN)
#  pragma linkage(CXBAT,FORTRAN)
#  pragma linkage(DXBAT,FORTRAN)
#  pragma linkage(CTBAT,FORTRAN)
#  pragma linkage(CZBAT,FORTRAN)
#  pragma linkage(JCBAT,FORTRAN)
#  pragma linkage(CVBAT,FORTRAN)
#  pragma linkage(ROECAL,FORTRAN)
#  pragma linkage(EMBAT,FORTRAN)
#  pragma linkage(EEBAT,FORTRAN)
#  pragma linkage(PEBAT,FORTRAN)
#  pragma linkage(EBBAT,FORTRAN)
#  pragma linkage(PBBAT,FORTRAN)
#  pragma linkage(TBBAT,FORTRAN)
#  pragma linkage(ROHCAL,FORTRAN)
#  pragma linkage(HMBAT,FORTRAN)
#  pragma linkage(HPBAT,FORTRAN)
#  pragma linkage(HEBAT,FORTRAN)
#  pragma linkage(HBBAT,FORTRAN)
#  pragma linkage(ROMUON,FORTRAN)
#  pragma linkage(MMBAT,FORTRAN)
#  pragma linkage(MEBAT,FORTRAN)
#  pragma linkage(MBBAT,FORTRAN)
#  pragma linkage(ROFORW,FORTRAN)
#  pragma linkage(FDBAT,FORTRAN)
#  pragma linkage(GOTREI,FORTRAN)
#  pragma linkage(ROEVSL,FORTRAN)
#  pragma linkage(ROESTY,FORTRAN)
#endif

extern void roiku_();
extern void rofile_();
extern void rprtvs_();
extern void rogoku_();
extern void rodive_();
extern void rochsc_();
extern void rochpr_();
extern void rochsi_();
extern void rocent_();
extern void cabat_();
extern void cebat_();
extern void csbat_();
extern void sibat_();
extern void cfbat_();
extern void cxbat_();
extern void dxbat_();
extern void ctbat_();
extern void czbat_();
extern void jcbat_();
extern void cvbat_();
extern void roecal_();
extern void embat_();
extern void eebat_();
extern void pebat_();
extern void ebbat_();
extern void pbbat_();
extern void tbbat_();
extern void rohcal_();
extern void hmbat_();
extern void hpbat_();
extern void hebat_();
extern void hbbat_();
extern void romuon_();
extern void mmbat_();
extern void mebat_();
extern void mbbat_();
extern void roforw_();
extern void fdbat_();
extern void gotrei_();
extern void roevsl_();
extern void roesty_();

void roiku_()
{

static KmParameter _ROPE_INPUT_CFNAME = { "CFNAME", 6, "Input file", "    ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ROPE_INPUT_LREC_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_INPUT_LREC = { "LREC", 4, "Record length", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_INPUT_LREC_type };
static KmParOption _ROPE_INPUT_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ROPE_INPUT_CHOPT = { "CHOPT", 5,
 "ZEBRA options for FZFILE", "I   ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_OPTION, &_ROPE_INPUT_CHOPT_type };
static KmParameter *_ROPE_INPUT_parameters[] = { &_ROPE_INPUT_CFNAME,
 &_ROPE_INPUT_LREC, &_ROPE_INPUT_CHOPT };
static char *_ROPE_INPUT_guidance[] = {
 "Open a new file for input or output.",
 "This command is obsolete, please use ROFILE instead" };
static KmCommand _ROPE_INPUT = {  (KmCommand*)0, "/ROPE/INPUT", "INPUT", 0, 1,
 3, 1, _ROPE_INPUT_parameters, 0, 0, rofile_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _ROPE_INPUT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _ROPE_EVTFILE_CFNAME = { "CFNAME", 6, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ROPE_EVTFILE_parameters[] = { &_ROPE_EVTFILE_CFNAME };
static char *_ROPE_EVTFILE_guidance[] = { "Open a new eventlist for input." };
static KmCommand _ROPE_EVTFILE = { &_ROPE_INPUT, "/ROPE/EVTFILE", "EVTFILE",
 0, 1, 1, 1, _ROPE_EVTFILE_parameters, 0, 0, rofile_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ROPE_EVTFILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ROPE_DADFILE_CFNAME = { "CFNAME", 6, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ROPE_DADFILE_parameters[] = { &_ROPE_DADFILE_CFNAME };
static char *_ROPE_DADFILE_guidance[] = { "Open a new dadlist for input." };
static KmCommand _ROPE_DADFILE = { &_ROPE_EVTFILE, "/ROPE/DADFILE", "DADFILE",
 0, 1, 1, 1, _ROPE_DADFILE_parameters, 0, 0, rofile_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ROPE_DADFILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ROPE_FILE_CFNAME = { "CFNAME", 6, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_ROPE_FILE_FTYPE_range[] = { "DATA", "DST", "DDST", "COPY" };
static char *_ROPE_FILE_FTYPE_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _ROPE_FILE_FTYPE_type = { _ROPE_FILE_FTYPE_text, (int*)0,
 (int*)0 };
static KmParameter _ROPE_FILE_FTYPE = { "FTYPE", 5, "File type", "DATA",
 (char*)0, 8, 4, _ROPE_FILE_FTYPE_range, 4, _ROPE_FILE_FTYPE_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ROPE_FILE_FTYPE_type };
static char *_ROPE_FILE_DIRCET_range[] = { "IN", "OUT" };
static char *_ROPE_FILE_DIRCET_text[] = { (char*)0, (char*)0 };
static KmParOption _ROPE_FILE_DIRCET_type = { _ROPE_FILE_DIRCET_text, (int*)0,
 (int*)0 };
static KmParameter _ROPE_FILE_DIRCET = { "DIRCET", 6, "Direction", "IN",
 (char*)0, 8, 2, _ROPE_FILE_DIRCET_range, 2, _ROPE_FILE_DIRCET_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ROPE_FILE_DIRCET_type };
static KmParInt    _ROPE_FILE_LREC_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_FILE_LREC = { "LREC", 4, "Record length", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_FILE_LREC_type };
static KmParameter _ROPE_FILE_ZOPT = { "ZOPT", 4, "ZEBRA options ", "L   ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _ROPE_FILE_ROPT = { "ROPT", 4, "ROPE options ", ".   ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_ROPE_FILE_parameters[] = { &_ROPE_FILE_CFNAME,
 &_ROPE_FILE_FTYPE, &_ROPE_FILE_DIRCET, &_ROPE_FILE_LREC, &_ROPE_FILE_ZOPT,
 &_ROPE_FILE_ROPT };
static char *_ROPE_FILE_guidance[] = { "Open a new file for input or output.",
 "When an output file has been defined, use the command ROWOUT to",
 "write out the current event." };
static KmCommand _ROPE_FILE = { &_ROPE_DADFILE, "/ROPE/FILE", "FILE", 0, 1, 6,
 1, _ROPE_FILE_parameters, 0, 0, rofile_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _ROPE_FILE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_ROPE_VERSION_guidance[] = {
 "Print versions of available processes." };
static KmCommand _ROPE_VERSION = { &_ROPE_FILE, "/ROPE/VERSION", "VERSION", 0,
 1, 0, 0, (KmParameter**)0, 0, 0, rprtvs_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _ROPE_VERSION_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_ROPE_REWIND_guidance[] = {
 "Rewind input (disk file) to acces previous events." };
static KmCommand _ROPE_REWIND = { &_ROPE_VERSION, "/ROPE/REWIND", "REWIND", 0,
 1, 0, 0, (KmParameter**)0, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _ROPE_REWIND_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_ROPE_DIVERT_CWHERE_range[] = { "TERMINAL", "FILE" };
static char *_ROPE_DIVERT_CWHERE_text[] = { (char*)0, (char*)0 };
static KmParOption _ROPE_DIVERT_CWHERE_type = { _ROPE_DIVERT_CWHERE_text,
 (int*)0, (int*)0 };
static KmParameter _ROPE_DIVERT_CWHERE = { "CWHERE", 6,
 "Where to divert (FILE/TERM)", "TERMINAL", (char*)0, 8, 2,
 _ROPE_DIVERT_CWHERE_range, 2, _ROPE_DIVERT_CWHERE_range, (KmParFlag)0,
 KmTYPE_OPTION, &_ROPE_DIVERT_CWHERE_type };
static KmParameter _ROPE_DIVERT_CFNAME = { "CFNAME", 6, "File name",
 "rope.printout", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ROPE_DIVERT_parameters[] = { &_ROPE_DIVERT_CWHERE,
 &_ROPE_DIVERT_CFNAME };
static char *_ROPE_DIVERT_guidance[] = {
 "Divert printed output to a file. Use option: \"TERMINAL\" to",
 "close file and use screen again." };
static KmCommand _ROPE_DIVERT = { &_ROPE_REWIND, "/ROPE/DIVERT", "DIVERT", 0,
 1, 2, 2, _ROPE_DIVERT_parameters, 0, 0, rodive_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _ROPE_DIVERT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_ROPE_ROBAT_guidance[] = { "Run ROPE according to FFREAD cards."
 };
static KmCommand _ROPE_ROBAT = { &_ROPE_DIVERT, "/ROPE/ROBAT", "ROBAT", 0, 1,
 0, 0, (KmParameter**)0, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _ROPE_ROBAT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_ROPE_ROWOUT_guidance[] = { "Write to selected output units." };
static KmCommand _ROPE_ROWOUT = { &_ROPE_ROBAT, "/ROPE/ROWOUT", "ROWOUT", 0,
 1, 0, 0, (KmParameter**)0, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _ROPE_ROWOUT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _ROPE_RIOSEL_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_RIOSEL_LUN = { "LUN", 3, "Logical unit No.", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_RIOSEL_LUN_type };
static KmParInt    _ROPE_RIOSEL_ISEL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_RIOSEL_ISEL = { "ISEL", 4, "Selection flag", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_RIOSEL_ISEL_type };
static KmParameter *_ROPE_RIOSEL_parameters[] = { &_ROPE_RIOSEL_LUN,
 &_ROPE_RIOSEL_ISEL };
static char *_ROPE_RIOSEL_guidance[] = {
 "Select output units: LUN = 0 --> all units selected." };
static KmCommand _ROPE_RIOSEL = { &_ROPE_ROWOUT, "/ROPE/RIOSEL", "RIOSEL", 0,
 1, 2, 2, _ROPE_RIOSEL_parameters, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _ROPE_RIOSEL_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParOption _ROPE_PROCESS_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ROPE_PROCESS_CHOPT = { "CHOPT", 5, "Option to call ROBAT",
 "ON", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_ROPE_PROCESS_CHOPT_type };
static KmParameter *_ROPE_PROCESS_parameters[] = { &_ROPE_PROCESS_CHOPT };
static char *_ROPE_PROCESS_guidance[] = {
 "Set ON/OFF the event processing folowing TRIG/SKIP/GOTO." };
static KmCommand _ROPE_PROCESS = { &_ROPE_RIOSEL, "/ROPE/PROCESS", "PROCESS",
 0, 1, 1, 1, _ROPE_PROCESS_parameters, 0, 0, rogoku_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ROPE_PROCESS_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ROPE_EVFIND_IEVGET_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_EVFIND_IEVGET = { "IEVGET", 6, "Get event#      ",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_EVFIND_IEVGET_type };
static KmParInt    _ROPE_EVFIND_IRUGET_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_EVFIND_IRUGET = { "IRUGET", 6, "In run#         ",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_EVFIND_IRUGET_type };
static char *_ROPE_EVFIND_CWHAT_range[] = { "DATA", "MCARLO", "HOTLINE",
 "CURRENT" };
static char *_ROPE_EVFIND_CWHAT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _ROPE_EVFIND_CWHAT_type = { _ROPE_EVFIND_CWHAT_text,
 (int*)0, (int*)0 };
static KmParameter _ROPE_EVFIND_CWHAT = { "CWHAT", 5,
 "In data/MC/hotline/current", "DATA", (char*)0, 8, 4,
 _ROPE_EVFIND_CWHAT_range, 4, _ROPE_EVFIND_CWHAT_range, (KmParFlag)0,
 KmTYPE_OPTION, &_ROPE_EVFIND_CWHAT_type };
static KmParameter *_ROPE_EVFIND_parameters[] = { &_ROPE_EVFIND_IEVGET,
 &_ROPE_EVFIND_IRUGET, &_ROPE_EVFIND_CWHAT };
static char *_ROPE_EVFIND_guidance[] = { " With option DATA or MCARLO:",
 " Get event IEVGET of run IRUGET for data or MC from shift-server",
 " With option HOTLINE:", " if run# =   0: get latest hotline run events",
 " if event# = 0: get next event found", " With option CURRENT:",
 " Get event in data files defined by FFREAD cards, or interactively." };
static KmCommand _ROPE_EVFIND = { &_ROPE_PROCESS, "/ROPE/EVFIND", "EVFIND", 0,
 1, 3, 3, _ROPE_EVFIND_parameters, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 7, _ROPE_EVFIND_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _ROPE_GOTO_IEVGET_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_GOTO_IEVGET = { "IEVGET", 6, "Get event#", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_GOTO_IEVGET_type };
static KmParInt    _ROPE_GOTO_IRUGET_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_GOTO_IRUGET = { "IRUGET", 6, "In run#", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_GOTO_IRUGET_type };
static char *_ROPE_GOTO_CWHAT_range[] = { "DATA", "MCARLO", "HOTLINE",
 "CURRENT" };
static char *_ROPE_GOTO_CWHAT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _ROPE_GOTO_CWHAT_type = { _ROPE_GOTO_CWHAT_text, (int*)0,
 (int*)0 };
static KmParameter _ROPE_GOTO_CWHAT = { "CWHAT", 5,
 "In data/MC/hotline/current", "CURRENT", (char*)0, 8, 4,
 _ROPE_GOTO_CWHAT_range, 4, _ROPE_GOTO_CWHAT_range, (KmParFlag)0,
 KmTYPE_OPTION, &_ROPE_GOTO_CWHAT_type };
static KmParameter *_ROPE_GOTO_parameters[] = { &_ROPE_GOTO_IEVGET,
 &_ROPE_GOTO_IRUGET, &_ROPE_GOTO_CWHAT };
static char *_ROPE_GOTO_guidance[] = { " With option DATA or MCARLO:",
 " Get event IEVGET of run IRUGET for data or MC from shift-server",
 " With option HOTLINE:", " if run# =   0: get latest hotline run events",
 " if event# = 0: get next event found", " With option CURRENT:",
 " Get event in data files defined by FFREAD cards, or interactively." };
static KmCommand _ROPE_GOTO = { &_ROPE_EVFIND, "/ROPE/GOTO", "GOTO", 0, 1, 3,
 1, _ROPE_GOTO_parameters, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 7, _ROPE_GOTO_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _ROPE_SKIP_NSKIP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_SKIP_NSKIP = { "NSKIP", 5, "No. events to skip", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_SKIP_NSKIP_type };
static KmParInt    _ROPE_SKIP_NPROC_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_SKIP_NPROC = { "NPROC", 5, "No. events to process",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_SKIP_NPROC_type };
static KmParameter *_ROPE_SKIP_parameters[] = { &_ROPE_SKIP_NSKIP,
 &_ROPE_SKIP_NPROC };
static char *_ROPE_SKIP_guidance[] = { "Skip N events, get N+1 th.",
 "Process NPROC if requested with PROCESS ON." };
static KmCommand _ROPE_SKIP = { &_ROPE_GOTO, "/ROPE/SKIP", "SKIP", 0, 1, 2, 2,
 _ROPE_SKIP_parameters, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _ROPE_SKIP_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _ROPE_TRIG_NPROC_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ROPE_TRIG_NPROC = { "NPROC", 5, "No. events to process",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ROPE_TRIG_NPROC_type };
static KmParameter *_ROPE_TRIG_parameters[] = { &_ROPE_TRIG_NPROC };
static char *_ROPE_TRIG_guidance[] = {
 "Get a new event, process NPROC if requested with PROCESS ON." };
static KmCommand _ROPE_TRIG = { &_ROPE_SKIP, "/ROPE/TRIG", "TRIG", 0, 1, 1, 0,
 _ROPE_TRIG_parameters, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _ROPE_TRIG_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_1 = { "CHSET3_1", 8,
 "Min energy in both hemispheres", "1.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightMon_CHSET3_1_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_2 = { "CHSET3_2", 8,
 "Max energy in FD", "2.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightMon_CHSET3_2_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_3_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_3 = { "CHSET3_3", 8,
 "Min number of good charged tracks", "2.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightMon_CHSET3_3_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_4_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_4 = { "CHSET3_4", 8,
 "Visible Energy / sqrt(s)", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightMon_CHSET3_4_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_5_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_5 = { "CHSET3_5", 8,
 "| cos(theta_Pmiss) |", "0.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightMon_CHSET3_5_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_6_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_6 = { "CHSET3_6", 8,
 "| cos(theta_thrust) |", "0.7", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightMon_CHSET3_6_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_7_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_7 = { "CHSET3_7", 8,
 "p_t", "4.0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_CHARGINO_Setcuts_TightMon_CHSET3_7_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET3_8_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET3_8 = { "CHSET3_8", 8,
 "Total invariant Mass", "2.0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightMon_CHSET3_8_type };
static KmParReal   _CHARGINO_Setcuts_TightMon_CHSET1_9_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightMon_CHSET1_9 = { "CHSET1_9", 8,
 "Energy fract in forward region", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightMon_CHSET1_9_type };
static KmParameter *_CHARGINO_Setcuts_TightMon_parameters[] = {
 &_CHARGINO_Setcuts_TightMon_CHSET3_1, &_CHARGINO_Setcuts_TightMon_CHSET3_2,
 &_CHARGINO_Setcuts_TightMon_CHSET3_3, &_CHARGINO_Setcuts_TightMon_CHSET3_4,
 &_CHARGINO_Setcuts_TightMon_CHSET3_5, &_CHARGINO_Setcuts_TightMon_CHSET3_6,
 &_CHARGINO_Setcuts_TightMon_CHSET3_7, &_CHARGINO_Setcuts_TightMon_CHSET3_8,
 &_CHARGINO_Setcuts_TightMon_CHSET1_9 };
static char *_CHARGINO_Setcuts_TightMon_guidance[] = {
 "cut values for tight monojet selection" };
static KmCommand _CHARGINO_Setcuts_TightMon = {  (KmCommand*)0,
 "/CHARGINO/Setcuts/TightMon", "TightMon", 0, 2, 9, 9,
 _CHARGINO_Setcuts_TightMon_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_TightMon_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_1 = { "CHSEL3_1", 8,
 "Min energy in both hemispheres", "1.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseMon_CHSEL3_1_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_2 = { "CHSEL3_2", 8,
 "Max energy in FD", "2.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseMon_CHSEL3_2_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_3_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_3 = { "CHSEL3_3", 8,
 "Min number of good charged tracks", "2.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseMon_CHSEL3_3_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_4_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_4 = { "CHSEL3_4", 8,
 "Visible Energy / sqrt(s)", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseMon_CHSEL3_4_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_5_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_5 = { "CHSEL3_5", 8,
 "| cos(theta_Pmiss) |", "0.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseMon_CHSEL3_5_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_6_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_6 = { "CHSEL3_6", 8,
 "| cos(theta_thrust) |", "9999.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseMon_CHSEL3_6_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_7_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_7 = { "CHSEL3_7", 8,
 "p_t", "3.0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_CHARGINO_Setcuts_LooseMon_CHSEL3_7_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSEL3_8_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSEL3_8 = { "CHSEL3_8", 8,
 "Total invariant Mass", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseMon_CHSEL3_8_type };
static KmParReal   _CHARGINO_Setcuts_LooseMon_CHSET1_9_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseMon_CHSET1_9 = { "CHSET1_9", 8,
 "Energy fract in forward region", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseMon_CHSET1_9_type };
static KmParameter *_CHARGINO_Setcuts_LooseMon_parameters[] = {
 &_CHARGINO_Setcuts_LooseMon_CHSEL3_1, &_CHARGINO_Setcuts_LooseMon_CHSEL3_2,
 &_CHARGINO_Setcuts_LooseMon_CHSEL3_3, &_CHARGINO_Setcuts_LooseMon_CHSEL3_4,
 &_CHARGINO_Setcuts_LooseMon_CHSEL3_5, &_CHARGINO_Setcuts_LooseMon_CHSEL3_6,
 &_CHARGINO_Setcuts_LooseMon_CHSEL3_7, &_CHARGINO_Setcuts_LooseMon_CHSEL3_8,
 &_CHARGINO_Setcuts_LooseMon_CHSET1_9 };
static char *_CHARGINO_Setcuts_LooseMon_guidance[] = {
 "cut values for loose monojet selection" };
static KmCommand _CHARGINO_Setcuts_LooseMon = { &_CHARGINO_Setcuts_TightMon,
 "/CHARGINO/Setcuts/LooseMon", "LooseMon", 0, 2, 9, 9,
 _CHARGINO_Setcuts_LooseMon_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_LooseMon_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_1 = { "CHSET2_1", 8,
 "Min energy in both hemispheres", "1.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightLow_CHSET2_1_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_2 = { "CHSET2_2", 8,
 "Max energy in FD", "2.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightLow_CHSET2_2_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_3_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_3 = { "CHSET2_3", 8,
 "Min number of good charged tracks", "2.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightLow_CHSET2_3_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_4_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_4 = { "CHSET2_4", 8,
 "Max number of good charged tracks", "8.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightLow_CHSET2_4_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_5_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_5 = { "CHSET2_5", 8,
 "Visible Energy / sqrt(s)", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightLow_CHSET2_5_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_6_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_6 = { "CHSET2_6", 8,
 "Acoplanarity angle", "20.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightLow_CHSET2_6_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_7_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_7 = { "CHSET2_7", 8,
 "| cos(theta_Pmiss) |", "0.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightLow_CHSET2_7_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_8_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_8 = { "CHSET2_8", 8,
 "| cos(theta_jet_max) |", "0.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightLow_CHSET2_8_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_9_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_9 = { "CHSET2_9", 8,
 "| cos(theta_thrust) |", "9999.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightLow_CHSET2_9_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_10_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_10 = { "CHSET2_10", 9,
 "p_t", "4.0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_CHARGINO_Setcuts_TightLow_CHSET2_10_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_11_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_11 = { "CHSET2_11", 9,
 "Sum of energy inside cones", "-1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightLow_CHSET2_11_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET2_12_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET2_12 = { "CHSET2_12", 9,
 "Sum of energy outside cones", "5.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightLow_CHSET2_12_type };
static KmParReal   _CHARGINO_Setcuts_TightLow_CHSET1_13_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightLow_CHSET1_13 = { "CHSET1_13", 9,
 "Energy fract in forward region", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightLow_CHSET1_13_type };
static KmParameter *_CHARGINO_Setcuts_TightLow_parameters[] = {
 &_CHARGINO_Setcuts_TightLow_CHSET2_1, &_CHARGINO_Setcuts_TightLow_CHSET2_2,
 &_CHARGINO_Setcuts_TightLow_CHSET2_3, &_CHARGINO_Setcuts_TightLow_CHSET2_4,
 &_CHARGINO_Setcuts_TightLow_CHSET2_5, &_CHARGINO_Setcuts_TightLow_CHSET2_6,
 &_CHARGINO_Setcuts_TightLow_CHSET2_7, &_CHARGINO_Setcuts_TightLow_CHSET2_8,
 &_CHARGINO_Setcuts_TightLow_CHSET2_9, &_CHARGINO_Setcuts_TightLow_CHSET2_10,
 &_CHARGINO_Setcuts_TightLow_CHSET2_11, &_CHARGINO_Setcuts_TightLow_CHSET2_12,
 &_CHARGINO_Setcuts_TightLow_CHSET1_13 };
static char *_CHARGINO_Setcuts_TightLow_guidance[] = {
 "cut values for tight low multiplicity selection" };
static KmCommand _CHARGINO_Setcuts_TightLow = { &_CHARGINO_Setcuts_LooseMon,
 "/CHARGINO/Setcuts/TightLow", "TightLow", 0, 2, 13, 13,
 _CHARGINO_Setcuts_TightLow_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_TightLow_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_1 = { "CHSEL2_1", 8,
 "Min energy in both hemispheres", "1.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_1_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_2 = { "CHSEL2_2", 8,
 "Max energy in FD", "2.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseLow_CHSEL2_2_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_3_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_3 = { "CHSEL2_3", 8,
 "Min number of good charged tracks", "2.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_3_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_4_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_4 = { "CHSEL2_4", 8,
 "Max number of good charged tracks", "10.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_4_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_5_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_5 = { "CHSEL2_5", 8,
 "Visible Energy / sqrt(s)", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseLow_CHSEL2_5_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_6_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_6 = { "CHSEL2_6", 8,
 "Acoplanarity angle", "10.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseLow_CHSEL2_6_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_7_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_7 = { "CHSEL2_7", 8,
 "| cos(theta_Pmiss) |", "0.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseLow_CHSEL2_7_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_8_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_8 = { "CHSEL2_8", 8,
 "| cos(theta_jet_max) |!DUMMY!", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_8_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_9_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_9 = { "CHSEL2_9", 8,
 "| cos(theta_thrust) |", "9999.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseLow_CHSEL2_9_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_10_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_10 = { "CHSEL2_10", 9,
 "p_t", "3.0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_CHARGINO_Setcuts_LooseLow_CHSEL2_10_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_11_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_11 = { "CHSEL2_11", 9,
 "Sum of energy inside cones", "-1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_11_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSEL2_12_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSEL2_12 = { "CHSEL2_12", 9,
 "Sum of energy outside cones", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_12_type };
static KmParReal   _CHARGINO_Setcuts_LooseLow_CHSET1_13_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseLow_CHSET1_13 = { "CHSET1_13", 9,
 "Energy fract in forward region", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseLow_CHSET1_13_type };
static KmParameter *_CHARGINO_Setcuts_LooseLow_parameters[] = {
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_1, &_CHARGINO_Setcuts_LooseLow_CHSEL2_2,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_3, &_CHARGINO_Setcuts_LooseLow_CHSEL2_4,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_5, &_CHARGINO_Setcuts_LooseLow_CHSEL2_6,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_7, &_CHARGINO_Setcuts_LooseLow_CHSEL2_8,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_9, &_CHARGINO_Setcuts_LooseLow_CHSEL2_10,
 &_CHARGINO_Setcuts_LooseLow_CHSEL2_11, &_CHARGINO_Setcuts_LooseLow_CHSEL2_12,
 &_CHARGINO_Setcuts_LooseLow_CHSET1_13 };
static char *_CHARGINO_Setcuts_LooseLow_guidance[] = {
 "cut values for loose low multiplicity selection" };
static KmCommand _CHARGINO_Setcuts_LooseLow = { &_CHARGINO_Setcuts_TightLow,
 "/CHARGINO/Setcuts/LooseLow", "LooseLow", 0, 2, 13, 13,
 _CHARGINO_Setcuts_LooseLow_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_LooseLow_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_1 = { "CHSET1_1", 8,
 "Min energy in both hemispheres", "1.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightGen_CHSET1_1_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_2 = { "CHSET1_2", 8,
 "Max energy in FD", "2.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightGen_CHSET1_2_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_3_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_3 = { "CHSET1_3", 8,
 "Min number of good charged tracks", "2.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightGen_CHSET1_3_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_4_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_4 = { "CHSET1_4", 8,
 "Visible Energy / sqrt(s)", "0.1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightGen_CHSET1_4_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_5_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_5 = { "CHSET1_5", 8,
 "Acoplanarity angle", "20.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightGen_CHSET1_5_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_6_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_6 = { "CHSET1_6", 8,
 "Scale for corr with E_vis", "1.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightGen_CHSET1_6_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_7_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_7 = { "CHSET1_7", 8,
 "| cos(theta_Pmiss) |", "0.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightGen_CHSET1_7_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_8_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_8 = { "CHSET1_8", 8,
 "| cos(theta_jet_max) |!DUMMY!", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightGen_CHSET1_8_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_9_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_9 = { "CHSET1_9", 8,
 "| cos(theta_thrust) |", "0.7", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_TightGen_CHSET1_9_type };
static KmParReal   _CHARGINO_Setcuts_TightGen_CHSET1_0_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_TightGen_CHSET1_0 = { "CHSET1_0", 8,
 "Energy fract in forward region", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_TightGen_CHSET1_0_type };
static KmParameter *_CHARGINO_Setcuts_TightGen_parameters[] = {
 &_CHARGINO_Setcuts_TightGen_CHSET1_1, &_CHARGINO_Setcuts_TightGen_CHSET1_2,
 &_CHARGINO_Setcuts_TightGen_CHSET1_3, &_CHARGINO_Setcuts_TightGen_CHSET1_4,
 &_CHARGINO_Setcuts_TightGen_CHSET1_5, &_CHARGINO_Setcuts_TightGen_CHSET1_6,
 &_CHARGINO_Setcuts_TightGen_CHSET1_7, &_CHARGINO_Setcuts_TightGen_CHSET1_8,
 &_CHARGINO_Setcuts_TightGen_CHSET1_9, &_CHARGINO_Setcuts_TightGen_CHSET1_0 };
static char *_CHARGINO_Setcuts_TightGen_guidance[] = {
 "cut values for tight general acoplanar selection" };
static KmCommand _CHARGINO_Setcuts_TightGen = { &_CHARGINO_Setcuts_LooseLow,
 "/CHARGINO/Setcuts/TightGen", "TightGen", 0, 2, 10, 10,
 _CHARGINO_Setcuts_TightGen_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_TightGen_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_1 = { "CHSEL1_1", 8,
 "Min energy in both hemispheres", "1.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_1_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_2 = { "CHSEL1_2", 8,
 "Max energy in FD", "2.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseGen_CHSEL1_2_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_3_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_3 = { "CHSEL1_3", 8,
 "Min number of good charged tracks", "2.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_3_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_4_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_4 = { "CHSEL1_4", 8,
 "Visible Energy / sqrt(s)", "0.08", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseGen_CHSEL1_4_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_5_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_5 = { "CHSEL1_5", 8,
 "Acoplanarity angle", "10.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseGen_CHSEL1_5_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_6_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_6 = { "CHSEL1_6", 8,
 "Scale for corr with E_vis", "0.0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseGen_CHSEL1_6_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_7_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_7 = { "CHSEL1_7", 8,
 "| cos(theta_Pmiss) |", "0.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseGen_CHSEL1_7_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_8_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_8 = { "CHSEL1_8", 8,
 "| cos(theta_jet_max) |!DUMMY!", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_8_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_9_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_9 = { "CHSEL1_9", 8,
 "| cos(theta_thrust) |", "9999.9", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_LooseGen_CHSEL1_9_type };
static KmParReal   _CHARGINO_Setcuts_LooseGen_CHSEL1_0_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_LooseGen_CHSEL1_0 = { "CHSEL1_0", 8,
 "Energy fract in forward region", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_0_type };
static KmParameter *_CHARGINO_Setcuts_LooseGen_parameters[] = {
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_1, &_CHARGINO_Setcuts_LooseGen_CHSEL1_2,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_3, &_CHARGINO_Setcuts_LooseGen_CHSEL1_4,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_5, &_CHARGINO_Setcuts_LooseGen_CHSEL1_6,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_7, &_CHARGINO_Setcuts_LooseGen_CHSEL1_8,
 &_CHARGINO_Setcuts_LooseGen_CHSEL1_9, &_CHARGINO_Setcuts_LooseGen_CHSEL1_0 };
static char *_CHARGINO_Setcuts_LooseGen_guidance[] = {
 "cut values for loose general acoplanar selection" };
static KmCommand _CHARGINO_Setcuts_LooseGen = { &_CHARGINO_Setcuts_TightGen,
 "/CHARGINO/Setcuts/LooseGen", "LooseGen", 0, 2, 10, 10,
 _CHARGINO_Setcuts_LooseGen_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_LooseGen_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_ECAL_CHECQU1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_ECAL_CHECQU1 = { "CHECQU1", 7,
 "min raw energy in EB cl", "0.1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_ECAL_CHECQU1_type };
static KmParReal   _CHARGINO_Setcuts_ECAL_CHECQU2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_ECAL_CHECQU2 = { "CHECQU2", 7,
 "min raw energy in EE cl", "0.2", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_ECAL_CHECQU2_type };
static KmParReal   _CHARGINO_Setcuts_ECAL_CHECQU3_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_ECAL_CHECQU3 = { "CHECQU3", 7,
 "min nr of blocks in EE cluste", "2.0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_ECAL_CHECQU3_type };
static KmParameter *_CHARGINO_Setcuts_ECAL_parameters[] = {
 &_CHARGINO_Setcuts_ECAL_CHECQU1, &_CHARGINO_Setcuts_ECAL_CHECQU2,
 &_CHARGINO_Setcuts_ECAL_CHECQU3 };
static char *_CHARGINO_Setcuts_ECAL_guidance[] = {
 "ECAL quality criteria quality criteria" };
static KmCommand _CHARGINO_Setcuts_ECAL = { &_CHARGINO_Setcuts_LooseGen,
 "/CHARGINO/Setcuts/ECAL", "ECAL", 0, 2, 3, 3,
 _CHARGINO_Setcuts_ECAL_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_ECAL_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU1 = { "CHTRQU1", 7,
 "minimal number of CJ hits", "20.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU1_type };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU2 = { "CHTRQU2", 7,
 "1/(fract of max. poss CJ hits)", "2.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU2_type
 };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU3_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU3 = { "CHTRQU3", 7,
 "d0 cut", "5.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU3_type };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU4_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU4 = { "CHTRQU4", 7,
 "z0 cut", "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU4_type };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU5_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU5 = { "CHTRQU5", 7,
 "radius of first meas hit in CJ", "60.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU5_type
 };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU6_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU6 = { "CHTRQU6", 7,
 "Chi^2/DGF in r-phi", "999.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU6_type };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU7_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU7 = { "CHTRQU7", 7,
 "Chi^2/DGF in s-z", "999.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU7_type };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU8_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU8 = { "CHTRQU8", 7,
 "transverse momentum of track", "0.05", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU8_type
 };
static KmParReal   _CHARGINO_Setcuts_Tracks_CHTRQU9_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _CHARGINO_Setcuts_Tracks_CHTRQU9 = { "CHTRQU9", 7,
 "Maximal momentum / EBEAM", "9999.9", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_CHARGINO_Setcuts_Tracks_CHTRQU9_type
 };
static KmParameter *_CHARGINO_Setcuts_Tracks_parameters[] = {
 &_CHARGINO_Setcuts_Tracks_CHTRQU1, &_CHARGINO_Setcuts_Tracks_CHTRQU2,
 &_CHARGINO_Setcuts_Tracks_CHTRQU3, &_CHARGINO_Setcuts_Tracks_CHTRQU4,
 &_CHARGINO_Setcuts_Tracks_CHTRQU5, &_CHARGINO_Setcuts_Tracks_CHTRQU6,
 &_CHARGINO_Setcuts_Tracks_CHTRQU7, &_CHARGINO_Setcuts_Tracks_CHTRQU8,
 &_CHARGINO_Setcuts_Tracks_CHTRQU9 };
static char *_CHARGINO_Setcuts_Tracks_guidance[] = { "Track quality criteria"
 };
static KmCommand _CHARGINO_Setcuts_Tracks = { &_CHARGINO_Setcuts_ECAL,
 "/CHARGINO/Setcuts/Tracks", "Tracks", 0, 2, 9, 9,
 _CHARGINO_Setcuts_Tracks_parameters, 0, 0, rochsc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Setcuts_Tracks_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_CHARGINO_Setcuts_guidance[] = { "Set cut parameters" };
static KmMenu _CHARGINO_Setcuts = {  (KmMenu*)0,  (KmMenu*)0,
 "/CHARGINO/Setcuts", "Setcuts", 2, &_CHARGINO_Setcuts_Tracks, 1,
 _CHARGINO_Setcuts_guidance, 0, (char**)0, 0, (char**)0 };

static char *_CHARGINO_Print_guidance[] = { "Print cut parameters + values" };
static KmCommand _CHARGINO_Print = {  (KmCommand*)0, "/CHARGINO/Print",
 "Print", 0, 1, 0, 0, (KmParameter**)0, 0, 0, rochpr_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Print_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_CHARGINO_Rerun_guidance[] = {
 "Rerun \"chargino\" classification." };
static KmCommand _CHARGINO_Rerun = { &_CHARGINO_Print, "/CHARGINO/Rerun",
 "Rerun", 0, 1, 0, 0, (KmParameter**)0, 0, 0, rochsi_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CHARGINO_Rerun_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _CD_CENTRAL_SET_PROCESS = { "PROCESS", 7,
 "Name(s) of central process(es) to run", "    ", (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_CD_CENTRAL_SET_parameters[] = { &_CD_CENTRAL_SET_PROCESS
 };
static char *_CD_CENTRAL_SET_guidance[] = {
 "Set selection of CENTRAL processes" };
static KmCommand _CD_CENTRAL_SET = {  (KmCommand*)0, "/CD/CENTRAL/SET", "SET",
 0, 2, 1, 0, _CD_CENTRAL_SET_parameters, 0, 0, rocent_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CD_CENTRAL_SET_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_CD_CENTRAL_SHOW_guidance[] = { "Show selected CENTRAL processes"
 };
static KmCommand _CD_CENTRAL_SHOW = { &_CD_CENTRAL_SET, "/CD/CENTRAL/SHOW",
 "SHOW", 0, 2, 0, 0, (KmParameter**)0, 0, 0, rocent_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _CD_CENTRAL_SHOW_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_CD_CENTRAL_guidance[] = {
 "Interactive steering of central processors." };
static KmMenu _CD_CENTRAL = {  (KmMenu*)0,  (KmMenu*)0, "/CD/CENTRAL",
 "CENTRAL", 2, &_CD_CENTRAL_SHOW, 1, _CD_CENTRAL_guidance, 0, (char**)0, 0,
 (char**)0 };

static char *_CD_CABAT_guidance[] = { "CA steering routine." };
static KmCommand _CD_CABAT = {  (KmCommand*)0, "/CD/CABAT", "CABAT", 0, 1, 0,
 0, (KmParameter**)0, 0, 0, cabat_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _CD_CABAT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_CD_CEBAT_guidance[] = { "CE steering routine." };
static KmCommand _CD_CEBAT = { &_CD_CABAT, "/CD/CEBAT", "CEBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, cebat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CEBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_CSBAT_guidance[] = { "CS steering routine." };
static KmCommand _CD_CSBAT = { &_CD_CEBAT, "/CD/CSBAT", "CSBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, csbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CSBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_SIBAT_guidance[] = { "SI steering routine." };
static KmCommand _CD_SIBAT = { &_CD_CSBAT, "/CD/SIBAT", "SIBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, sibat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_SIBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_CFBAT_guidance[] = { "CF steering routine." };
static KmCommand _CD_CFBAT = { &_CD_SIBAT, "/CD/CFBAT", "CFBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, cfbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CFBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_CXBAT_guidance[] = { "CX steering routine." };
static KmCommand _CD_CXBAT = { &_CD_CFBAT, "/CD/CXBAT", "CXBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, cxbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CXBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_DXBAT_guidance[] = { "DX steering routine." };
static KmCommand _CD_DXBAT = { &_CD_CXBAT, "/CD/DXBAT", "DXBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, dxbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_DXBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_CTBAT_guidance[] = { "CT steering routine." };
static KmCommand _CD_CTBAT = { &_CD_DXBAT, "/CD/CTBAT", "CTBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, ctbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CTBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_CZBAT_guidance[] = { "CZ steering routine." };
static KmCommand _CD_CZBAT = { &_CD_CTBAT, "/CD/CZBAT", "CZBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, czbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CZBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_JCBAT_guidance[] = { "CJ steering routine." };
static KmCommand _CD_JCBAT = { &_CD_CZBAT, "/CD/JCBAT", "JCBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, jcbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_JCBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_CJBAT_guidance[] = { "CJ steering routine." };
static KmCommand _CD_CJBAT = { &_CD_JCBAT, "/CD/CJBAT", "CJBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, jcbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CJBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_CD_CVBAT_guidance[] = { "CV steering routine." };
static KmCommand _CD_CVBAT = { &_CD_CJBAT, "/CD/CVBAT", "CVBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, cvbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _CD_CVBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _EC_ECAL_SET_PROCESS = { "PROCESS", 7,
 "Name(s) of Ecal process(es) to run", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_EC_ECAL_SET_parameters[] = { &_EC_ECAL_SET_PROCESS };
static char *_EC_ECAL_SET_guidance[] = { "Set selection of ECAL processes" };
static KmCommand _EC_ECAL_SET = {  (KmCommand*)0, "/EC/ECAL/SET", "SET", 0, 2,
 1, 0, _EC_ECAL_SET_parameters, 0, 0, roecal_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _EC_ECAL_SET_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_EC_ECAL_SHOW_guidance[] = { "Show selected ECAL processes" };
static KmCommand _EC_ECAL_SHOW = { &_EC_ECAL_SET, "/EC/ECAL/SHOW", "SHOW", 0,
 2, 0, 0, (KmParameter**)0, 0, 0, roecal_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _EC_ECAL_SHOW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_EC_ECAL_guidance[] = {
 "Interactive steering of Ecal processors." };
static KmMenu _EC_ECAL = {  (KmMenu*)0,  (KmMenu*)0, "/EC/ECAL", "ECAL", 2,
 &_EC_ECAL_SHOW, 1, _EC_ECAL_guidance, 0, (char**)0, 0, (char**)0 };

static char *_EC_EMBAT_guidance[] = { "EM steering routine." };
static KmCommand _EC_EMBAT = {  (KmCommand*)0, "/EC/EMBAT", "EMBAT", 0, 1, 0,
 0, (KmParameter**)0, 0, 0, embat_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _EC_EMBAT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_EC_EEBAT_guidance[] = { "EE steering routine." };
static KmCommand _EC_EEBAT = { &_EC_EMBAT, "/EC/EEBAT", "EEBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, eebat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _EC_EEBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_EC_PEBAT_guidance[] = { "PE steering routine." };
static KmCommand _EC_PEBAT = { &_EC_EEBAT, "/EC/PEBAT", "PEBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, pebat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _EC_PEBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_EC_EBBAT_guidance[] = { "EB steering routine." };
static KmCommand _EC_EBBAT = { &_EC_PEBAT, "/EC/EBBAT", "EBBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, ebbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _EC_EBBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_EC_PBBAT_guidance[] = { "PB steering routine." };
static KmCommand _EC_PBBAT = { &_EC_EBBAT, "/EC/PBBAT", "PBBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, pbbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _EC_PBBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_EC_TBBAT_guidance[] = { "TB steering routine." };
static KmCommand _EC_TBBAT = { &_EC_PBBAT, "/EC/TBBAT", "TBBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, tbbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _EC_TBBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _HC_HCAL_SET_PROCESS = { "PROCESS", 7,
 "Name(s) of Hcal process(es) to run", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HC_HCAL_SET_parameters[] = { &_HC_HCAL_SET_PROCESS };
static char *_HC_HCAL_SET_guidance[] = { "Set selection of HCAL processes" };
static KmCommand _HC_HCAL_SET = {  (KmCommand*)0, "/HC/HCAL/SET", "SET", 0, 2,
 1, 0, _HC_HCAL_SET_parameters, 0, 0, rohcal_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _HC_HCAL_SET_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_HC_HCAL_SHOW_guidance[] = { "Show selected HCAL processes" };
static KmCommand _HC_HCAL_SHOW = { &_HC_HCAL_SET, "/HC/HCAL/SHOW", "SHOW", 0,
 2, 0, 0, (KmParameter**)0, 0, 0, rohcal_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _HC_HCAL_SHOW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_HC_HCAL_guidance[] = {
 "Interactive steering of Hcal processors." };
static KmMenu _HC_HCAL = {  (KmMenu*)0,  (KmMenu*)0, "/HC/HCAL", "HCAL", 2,
 &_HC_HCAL_SHOW, 1, _HC_HCAL_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HC_HMBAT_guidance[] = { "HM steering routine." };
static KmCommand _HC_HMBAT = {  (KmCommand*)0, "/HC/HMBAT", "HMBAT", 0, 1, 0,
 0, (KmParameter**)0, 0, 0, hmbat_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _HC_HMBAT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_HC_HPBAT_guidance[] = { "HP steering routine." };
static KmCommand _HC_HPBAT = { &_HC_HMBAT, "/HC/HPBAT", "HPBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, hpbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _HC_HPBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_HC_HEBAT_guidance[] = { "HE steering routine." };
static KmCommand _HC_HEBAT = { &_HC_HPBAT, "/HC/HEBAT", "HEBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, hebat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _HC_HEBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_HC_HBBAT_guidance[] = { "HB steering routine." };
static KmCommand _HC_HBBAT = { &_HC_HEBAT, "/HC/HBBAT", "HBBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, hbbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _HC_HBBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _MU_MUON_SET_PROCESS = { "PROCESS", 7,
 "Name(s) of Muon process(es) to run", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_MU_MUON_SET_parameters[] = { &_MU_MUON_SET_PROCESS };
static char *_MU_MUON_SET_guidance[] = { "Set selection of Muon processes" };
static KmCommand _MU_MUON_SET = {  (KmCommand*)0, "/MU/MUON/SET", "SET", 0, 2,
 1, 0, _MU_MUON_SET_parameters, 0, 0, romuon_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _MU_MUON_SET_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MU_MUON_SHOW_guidance[] = { "Show selected Muon processes" };
static KmCommand _MU_MUON_SHOW = { &_MU_MUON_SET, "/MU/MUON/SHOW", "SHOW", 0,
 2, 0, 0, (KmParameter**)0, 0, 0, romuon_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _MU_MUON_SHOW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MU_MUON_guidance[] = {
 "Interactive steering of Muon processors." };
static KmMenu _MU_MUON = {  (KmMenu*)0,  (KmMenu*)0, "/MU/MUON", "MUON", 2,
 &_MU_MUON_SHOW, 1, _MU_MUON_guidance, 0, (char**)0, 0, (char**)0 };

static char *_MU_MMBAT_guidance[] = { "MM steering routine." };
static KmCommand _MU_MMBAT = {  (KmCommand*)0, "/MU/MMBAT", "MMBAT", 0, 1, 0,
 0, (KmParameter**)0, 0, 0, mmbat_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _MU_MMBAT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MU_MEBAT_guidance[] = { "ME steering routine." };
static KmCommand _MU_MEBAT = { &_MU_MMBAT, "/MU/MEBAT", "MEBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, mebat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _MU_MEBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_MU_MBBAT_guidance[] = { "MB steering routine." };
static KmCommand _MU_MBBAT = { &_MU_MEBAT, "/MU/MBBAT", "MBBAT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, mbbat_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _MU_MBBAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _FO_FORW_SET_PROCESS = { "PROCESS", 7,
 "Name(s) of Forward process(es) to run", "    ", (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_FO_FORW_SET_parameters[] = { &_FO_FORW_SET_PROCESS };
static char *_FO_FORW_SET_guidance[] = { "Set selection of Forward processes"
 };
static KmCommand _FO_FORW_SET = {  (KmCommand*)0, "/FO/FORW/SET", "SET", 0, 2,
 1, 0, _FO_FORW_SET_parameters, 0, 0, roforw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _FO_FORW_SET_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_FO_FORW_SHOW_guidance[] = { "Show selected Forward processes" };
static KmCommand _FO_FORW_SHOW = { &_FO_FORW_SET, "/FO/FORW/SHOW", "SHOW", 0,
 2, 0, 0, (KmParameter**)0, 0, 0, roforw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _FO_FORW_SHOW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_FO_FORW_guidance[] = {
 "Interactive steering of Forward processors." };
static KmMenu _FO_FORW = {  (KmMenu*)0,  (KmMenu*)0, "/FO/FORW", "FORW", 2,
 &_FO_FORW_SHOW, 1, _FO_FORW_guidance, 0, (char**)0, 0, (char**)0 };

static char *_FO_FDBAT_guidance[] = { "FD steering routine." };
static KmCommand _FO_FDBAT = {  (KmCommand*)0, "/FO/FDBAT", "FDBAT", 0, 1, 0,
 0, (KmParameter**)0, 0, 0, fdbat_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _FO_FDBAT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _DEBUG_CONSTANT_IFCNST_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _DEBUG_CONSTANT_IFCNST = { "IFCNST", 6,
 "Constant rec. control flag", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_DEBUG_CONSTANT_IFCNST_type };
static KmParameter *_DEBUG_CONSTANT_parameters[] = { &_DEBUG_CONSTANT_IFCNST };
static char *_DEBUG_CONSTANT_guidance[] = {
 "Set flag to control writing of constant records." };
static KmCommand _DEBUG_CONSTANT = {  (KmCommand*)0, "/DEBUG/CONSTANT",
 "CONSTANT", 0, 1, 1, 1, _DEBUG_CONSTANT_parameters, 0, 0, rogoku_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _DEBUG_CONSTANT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _DEBUG_NODROP_IFDROP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _DEBUG_NODROP_IFDROP = { "IFDROP", 6,
 "Flag to steer XXDROP calls", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_DEBUG_NODROP_IFDROP_type };
static KmParameter *_DEBUG_NODROP_parameters[] = { &_DEBUG_NODROP_IFDROP };
static char *_DEBUG_NODROP_guidance[] = { "Set flag to steer XXDROP calls." };
static KmCommand _DEBUG_NODROP = { &_DEBUG_CONSTANT, "/DEBUG/NODROP",
 "NODROP", 0, 1, 1, 1, _DEBUG_NODROP_parameters, 0, 0, rogoku_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _DEBUG_NODROP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _DEBUG_SCAN_IFSCAN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _DEBUG_SCAN_IFSCAN = { "IFSCAN", 6,
 "Flag for input scan file", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_DEBUG_SCAN_IFSCAN_type };
static KmParameter *_DEBUG_SCAN_parameters[] = { &_DEBUG_SCAN_IFSCAN };
static char *_DEBUG_SCAN_guidance[] = { "Set flag for input scan file." };
static KmCommand _DEBUG_SCAN = { &_DEBUG_NODROP, "/DEBUG/SCAN", "SCAN", 0, 1,
 1, 1, _DEBUG_SCAN_parameters, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _DEBUG_SCAN_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_DEBUG_DZVERI_guidance[] = { "Verify ROPE division." };
static KmCommand _DEBUG_DZVERI = { &_DEBUG_SCAN, "/DEBUG/DZVERI", "DZVERI", 0,
 1, 0, 0, (KmParameter**)0, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _DEBUG_DZVERI_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _DEBUG_DZSHOW_IDH = { "IDH", 3,
 "Bank hollerlith identifier", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _DEBUG_DZSHOW_IDN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _DEBUG_DZSHOW_IDN = { "IDN", 3, "Bank numeric identifier",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_DEBUG_DZSHOW_IDN_type };
static KmParOption _DEBUG_DZSHOW_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _DEBUG_DZSHOW_CHOPT = { "CHOPT", 5, "Dump option", "BLV",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_DEBUG_DZSHOW_CHOPT_type };
static KmParameter *_DEBUG_DZSHOW_parameters[] = { &_DEBUG_DZSHOW_IDH,
 &_DEBUG_DZSHOW_IDN, &_DEBUG_DZSHOW_CHOPT };
static char *_DEBUG_DZSHOW_guidance[] = { "Dump of a ZEBRA bank." };
static KmCommand _DEBUG_DZSHOW = { &_DEBUG_DZVERI, "/DEBUG/DZSHOW", "DZSHOW",
 0, 1, 3, 2, _DEBUG_DZSHOW_parameters, 0, 0, rogoku_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _DEBUG_DZSHOW_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _DEBUG_DZSURV_IDH = { "IDH", 3,
 "Bank hollerlith identifier", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _DEBUG_DZSURV_IDN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _DEBUG_DZSURV_IDN = { "IDN", 3, "Bank numeric identifier",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_DEBUG_DZSURV_IDN_type };
static KmParameter *_DEBUG_DZSURV_parameters[] = { &_DEBUG_DZSURV_IDH,
 &_DEBUG_DZSURV_IDN };
static char *_DEBUG_DZSURV_guidance[] = { "Survey of ZEBRA store." };
static KmCommand _DEBUG_DZSURV = { &_DEBUG_DZSHOW, "/DEBUG/DZSURV", "DZSURV",
 0, 1, 2, 2, _DEBUG_DZSURV_parameters, 0, 0, rogoku_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _DEBUG_DZSURV_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_DEBUG_DZSNAP_guidance[] = { "Snap shot of ZEBRA store." };
static KmCommand _DEBUG_DZSNAP = { &_DEBUG_DZSURV, "/DEBUG/DZSNAP", "DZSNAP",
 0, 1, 0, 0, (KmParameter**)0, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _DEBUG_DZSNAP_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _DEBUG_ROSIZE_IDH = { "IDH", 3,
 "Bank hollerlith identifier", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _DEBUG_ROSIZE_IDN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _DEBUG_ROSIZE_IDN = { "IDN", 3, "Bank numeric identifier",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_DEBUG_ROSIZE_IDN_type };
static KmParameter *_DEBUG_ROSIZE_parameters[] = { &_DEBUG_ROSIZE_IDH,
 &_DEBUG_ROSIZE_IDN };
static char *_DEBUG_ROSIZE_guidance[] = { "Print memory size of a ZEBRA bank."
 };
static KmCommand _DEBUG_ROSIZE = { &_DEBUG_DZSNAP, "/DEBUG/ROSIZE", "ROSIZE",
 0, 1, 2, 2, _DEBUG_ROSIZE_parameters, 0, 0, rogoku_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _DEBUG_ROSIZE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GE_GOTREE_IT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GE_GOTREE_IT = { "IT", 2, "Track number", "0", (char*)0,
 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GE_GOTREE_IT_type
 };
static KmParameter *_GE_GOTREE_parameters[] = { &_GE_GOTREE_IT };
static char *_GE_GOTREE_guidance[] = {
 "Print Kinematics transmitted to ROPE in TREE structure.",
 "IT=0: all tracks,",
 "IT<0: print track IT with its  ancestors and descendants" };
static KmCommand _GE_GOTREE = {  (KmCommand*)0, "/GE/GOTREE", "GOTREE", 0, 1,
 1, 0, _GE_GOTREE_parameters, 0, 0, gotrei_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _GE_GOTREE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GE_ROTREE_IT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GE_ROTREE_IT = { "IT", 2, "Track number", "0", (char*)0,
 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GE_ROTREE_IT_type
 };
static KmParameter *_GE_ROTREE_parameters[] = { &_GE_ROTREE_IT };
static char *_GE_ROTREE_guidance[] = {
 "Print Kinematics transmitted to ROPE in TREE structure." };
static KmCommand _GE_ROTREE = { &_GE_GOTREE, "/GE/ROTREE", "ROTREE", 0, 1, 1,
 0, _GE_ROTREE_parameters, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GE_ROTREE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _EVSEL_SET_EVENT_IEVT_type = { "0", "9999999", "0",
 "9999999", 0 };
static KmParameter _EVSEL_SET_EVENT_IEVT = { "IEVT", 4,
 "Trigger number selected (IEVT=0 -> no select)", "0", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_EVSEL_SET_EVENT_IEVT_type };
static KmParInt    _EVSEL_SET_EVENT_IRUN_type = { "0", "9999999", "0",
 "9999999", 0 };
static KmParameter _EVSEL_SET_EVENT_IRUN = { "IRUN", 4,
 "Run number selected (IRUN=0 -> no selection)", "0", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_EVSEL_SET_EVENT_IRUN_type };
static KmParameter *_EVSEL_SET_EVENT_parameters[] = { &_EVSEL_SET_EVENT_IEVT,
 &_EVSEL_SET_EVENT_IRUN };
static char *_EVSEL_SET_EVENT_guidance[] = {
 "Select an event by its trigger number and run number" };
static KmCommand _EVSEL_SET_EVENT = {  (KmCommand*)0, "/EVSEL/SET/EVENT",
 "EVENT", 0, 2, 2, 1, _EVSEL_SET_EVENT_parameters, 0, 0, roevsl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_EVENT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _EVSEL_SET_NMUON_NMUMIN_type = { "0", "9999", "0", "9999",
 0 };
static KmParameter _EVSEL_SET_NMUON_NMUMIN = { "NMUMIN", 6,
 "Minimum number of muon segments", "0", (char*)0, 5, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_NMUON_NMUMIN_type };
static KmParInt    _EVSEL_SET_NMUON_NMUMAX_type = { "0", "9999", "0", "9999",
 0 };
static KmParameter _EVSEL_SET_NMUON_NMUMAX = { "NMUMAX", 6,
 "Maximum number of muon segments", "9999", (char*)0, 5, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_NMUON_NMUMAX_type };
static KmParameter *_EVSEL_SET_NMUON_parameters[] = {
 &_EVSEL_SET_NMUON_NMUMIN, &_EVSEL_SET_NMUON_NMUMAX };
static char *_EVSEL_SET_NMUON_guidance[] = {
 "Minimum and maximum number of muon segments" };
static KmCommand _EVSEL_SET_NMUON = { &_EVSEL_SET_EVENT, "/EVSEL/SET/NMUON",
 "NMUON", 0, 2, 2, 2, _EVSEL_SET_NMUON_parameters, 0, 0, roevsl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_NMUON_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _EVSEL_SET_EHCAL_EHMIN_type = { "0.", "9999.", "0.",
 "9999.", 0 };
static KmParameter _EVSEL_SET_EHCAL_EHMIN = { "EHMIN", 5,
 "Minimum energy in hadronic calorimeters", "0.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_EVSEL_SET_EHCAL_EHMIN_type };
static KmParReal   _EVSEL_SET_EHCAL_EHMAX_type = { "0.", "9999.", "0.",
 "9999.", 0 };
static KmParameter _EVSEL_SET_EHCAL_EHMAX = { "EHMAX", 5,
 "Maximum energy in hadronic calorimeters", "9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_EVSEL_SET_EHCAL_EHMAX_type };
static KmParameter *_EVSEL_SET_EHCAL_parameters[] = { &_EVSEL_SET_EHCAL_EHMIN,
 &_EVSEL_SET_EHCAL_EHMAX };
static char *_EVSEL_SET_EHCAL_guidance[] = {
 "Minimum and maximum energy in hadronic calorimeters" };
static KmCommand _EVSEL_SET_EHCAL = { &_EVSEL_SET_NMUON, "/EVSEL/SET/EHCAL",
 "EHCAL", 0, 2, 2, 2, _EVSEL_SET_EHCAL_parameters, 0, 0, roevsl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_EHCAL_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _EVSEL_SET_EECAL_EEMIN_type = { "0.", "9999.", "0.",
 "9999.", 0 };
static KmParameter _EVSEL_SET_EECAL_EEMIN = { "EEMIN", 5,
 "Min. energy in electromagnetic calorimeters", "0.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_EVSEL_SET_EECAL_EEMIN_type };
static KmParReal   _EVSEL_SET_EECAL_EEMAX_type = { "0.", "9999.", "0.",
 "9999.", 0 };
static KmParameter _EVSEL_SET_EECAL_EEMAX = { "EEMAX", 5,
 "Max. energy in electromagnetic calorimeters", "9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_EVSEL_SET_EECAL_EEMAX_type };
static KmParameter *_EVSEL_SET_EECAL_parameters[] = { &_EVSEL_SET_EECAL_EEMIN,
 &_EVSEL_SET_EECAL_EEMAX };
static char *_EVSEL_SET_EECAL_guidance[] = {
 "Minimum and maximum energy in electromagnetic calorimeters" };
static KmCommand _EVSEL_SET_EECAL = { &_EVSEL_SET_EHCAL, "/EVSEL/SET/EECAL",
 "EECAL", 0, 2, 2, 2, _EVSEL_SET_EECAL_parameters, 0, 0, roevsl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_EECAL_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _EVSEL_SET_NCTRK_NCMIN_type = { "0", "9999", "0", "9999", 0
 };
static KmParameter _EVSEL_SET_NCTRK_NCMIN = { "NCMIN", 5,
 "Minimum number of charged tracks", "0", (char*)0, 5, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_NCTRK_NCMIN_type };
static KmParInt    _EVSEL_SET_NCTRK_NCMAX_type = { "0", "9999", "0", "9999", 0
 };
static KmParameter _EVSEL_SET_NCTRK_NCMAX = { "NCMAX", 5,
 "Maximum number of charged tracks", "9999", (char*)0, 5, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_NCTRK_NCMAX_type };
static KmParameter *_EVSEL_SET_NCTRK_parameters[] = { &_EVSEL_SET_NCTRK_NCMIN,
 &_EVSEL_SET_NCTRK_NCMAX };
static char *_EVSEL_SET_NCTRK_guidance[] = {
 "Minimum and maximum number of charged tracks" };
static KmCommand _EVSEL_SET_NCTRK = { &_EVSEL_SET_EECAL, "/EVSEL/SET/NCTRK",
 "NCTRK", 0, 2, 2, 2, _EVSEL_SET_NCTRK_parameters, 0, 0, roevsl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_NCTRK_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_SET_TRWD_CTYPE_range[] = { "NONE", "-" };
static char *_EVSEL_SET_TRWD_CTYPE_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWD_CTYPE_type = { _EVSEL_SET_TRWD_CTYPE_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWD_CTYPE = { "CTYPE", 5, "Mnemonic for type",
 "NONE", (char*)0, 8, 2, _EVSEL_SET_TRWD_CTYPE_range, 2,
 _EVSEL_SET_TRWD_CTYPE_range, (KmParFlag)2, KmTYPE_OPTION,
 &_EVSEL_SET_TRWD_CTYPE_type };
static KmParInt    _EVSEL_SET_TRWD_IBITNR_type = { "-1", "32", "-1", "32", 0 };
static KmParameter _EVSEL_SET_TRWD_IBITNR = { "IBITNR", 6,
 "Bit number (if mnemonic NONE)", "0", (char*)0, 3, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_TRWD_IBITNR_type };
static char *_EVSEL_SET_TRWD_SETUNS_range[] = { "SET", "UNSET" };
static char *_EVSEL_SET_TRWD_SETUNS_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWD_SETUNS_type = {
 _EVSEL_SET_TRWD_SETUNS_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWD_SETUNS = { "SETUNS", 6, "Set or unset",
 "SET", (char*)0, 8, 2, _EVSEL_SET_TRWD_SETUNS_range, 2,
 _EVSEL_SET_TRWD_SETUNS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWD_SETUNS_type };
static char *_EVSEL_SET_TRWD_CVETO_range[] = { "Select", "Veto" };
static char *_EVSEL_SET_TRWD_CVETO_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWD_CVETO_type = { _EVSEL_SET_TRWD_CVETO_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWD_CVETO = { "CVETO", 5, "Select or Veto",
 "Select", (char*)0, 8, 2, _EVSEL_SET_TRWD_CVETO_range, 2,
 _EVSEL_SET_TRWD_CVETO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWD_CVETO_type };
static KmParameter *_EVSEL_SET_TRWD_parameters[] = { &_EVSEL_SET_TRWD_CTYPE,
 &_EVSEL_SET_TRWD_IBITNR, &_EVSEL_SET_TRWD_SETUNS, &_EVSEL_SET_TRWD_CVETO };
static char *_EVSEL_SET_TRWD_guidance[] = {
 "Select an event by its trigger bits (1-32)" };
static KmCommand _EVSEL_SET_TRWD = { &_EVSEL_SET_NCTRK, "/EVSEL/SET/TRWD",
 "TRWD", 0, 2, 4, 1, _EVSEL_SET_TRWD_parameters, 0, 0, roesty_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_TRWD_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_SET_TRWC_CTYPE_range[] = { "NONE", "-" };
static char *_EVSEL_SET_TRWC_CTYPE_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWC_CTYPE_type = { _EVSEL_SET_TRWC_CTYPE_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWC_CTYPE = { "CTYPE", 5, "Mnemonic for type",
 "NONE", (char*)0, 8, 2, _EVSEL_SET_TRWC_CTYPE_range, 2,
 _EVSEL_SET_TRWC_CTYPE_range, (KmParFlag)2, KmTYPE_OPTION,
 &_EVSEL_SET_TRWC_CTYPE_type };
static KmParInt    _EVSEL_SET_TRWC_IBITNR_type = { "-1", "32", "-1", "32", 0 };
static KmParameter _EVSEL_SET_TRWC_IBITNR = { "IBITNR", 6,
 "Bit number (if mnemonic NONE)", "0", (char*)0, 3, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_TRWC_IBITNR_type };
static char *_EVSEL_SET_TRWC_SETUNS_range[] = { "SET", "UNSET" };
static char *_EVSEL_SET_TRWC_SETUNS_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWC_SETUNS_type = {
 _EVSEL_SET_TRWC_SETUNS_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWC_SETUNS = { "SETUNS", 6, "Set or unset",
 "SET", (char*)0, 8, 2, _EVSEL_SET_TRWC_SETUNS_range, 2,
 _EVSEL_SET_TRWC_SETUNS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWC_SETUNS_type };
static char *_EVSEL_SET_TRWC_CVETO_range[] = { "Select", "Veto" };
static char *_EVSEL_SET_TRWC_CVETO_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWC_CVETO_type = { _EVSEL_SET_TRWC_CVETO_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWC_CVETO = { "CVETO", 5, "Select or Veto",
 "Select", (char*)0, 8, 2, _EVSEL_SET_TRWC_CVETO_range, 2,
 _EVSEL_SET_TRWC_CVETO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWC_CVETO_type };
static KmParameter *_EVSEL_SET_TRWC_parameters[] = { &_EVSEL_SET_TRWC_CTYPE,
 &_EVSEL_SET_TRWC_IBITNR, &_EVSEL_SET_TRWC_SETUNS, &_EVSEL_SET_TRWC_CVETO };
static char *_EVSEL_SET_TRWC_guidance[] = {
 "Select an event by its trigger bits (33-64)" };
static KmCommand _EVSEL_SET_TRWC = { &_EVSEL_SET_TRWD, "/EVSEL/SET/TRWC",
 "TRWC", 0, 2, 4, 1, _EVSEL_SET_TRWC_parameters, 0, 0, roesty_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_TRWC_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_SET_TRWB_CTYPE_range[] = { "NONE", "-" };
static char *_EVSEL_SET_TRWB_CTYPE_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWB_CTYPE_type = { _EVSEL_SET_TRWB_CTYPE_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWB_CTYPE = { "CTYPE", 5, "Mnemonic for type",
 "NONE", (char*)0, 8, 2, _EVSEL_SET_TRWB_CTYPE_range, 2,
 _EVSEL_SET_TRWB_CTYPE_range, (KmParFlag)2, KmTYPE_OPTION,
 &_EVSEL_SET_TRWB_CTYPE_type };
static KmParInt    _EVSEL_SET_TRWB_IBITNR_type = { "-1", "32", "-1", "32", 0 };
static KmParameter _EVSEL_SET_TRWB_IBITNR = { "IBITNR", 6,
 "Bit number (if mnemonic NONE)", "0", (char*)0, 3, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_TRWB_IBITNR_type };
static char *_EVSEL_SET_TRWB_SETUNS_range[] = { "SET", "UNSET" };
static char *_EVSEL_SET_TRWB_SETUNS_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWB_SETUNS_type = {
 _EVSEL_SET_TRWB_SETUNS_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWB_SETUNS = { "SETUNS", 6, "Set or unset",
 "SET", (char*)0, 8, 2, _EVSEL_SET_TRWB_SETUNS_range, 2,
 _EVSEL_SET_TRWB_SETUNS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWB_SETUNS_type };
static char *_EVSEL_SET_TRWB_CVETO_range[] = { "Select", "Veto" };
static char *_EVSEL_SET_TRWB_CVETO_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWB_CVETO_type = { _EVSEL_SET_TRWB_CVETO_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWB_CVETO = { "CVETO", 5, "Select or Veto",
 "Select", (char*)0, 8, 2, _EVSEL_SET_TRWB_CVETO_range, 2,
 _EVSEL_SET_TRWB_CVETO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWB_CVETO_type };
static KmParameter *_EVSEL_SET_TRWB_parameters[] = { &_EVSEL_SET_TRWB_CTYPE,
 &_EVSEL_SET_TRWB_IBITNR, &_EVSEL_SET_TRWB_SETUNS, &_EVSEL_SET_TRWB_CVETO };
static char *_EVSEL_SET_TRWB_guidance[] = {
 "Select an event by its trigger bits (65-96)" };
static KmCommand _EVSEL_SET_TRWB = { &_EVSEL_SET_TRWC, "/EVSEL/SET/TRWB",
 "TRWB", 0, 2, 4, 1, _EVSEL_SET_TRWB_parameters, 0, 0, roesty_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_TRWB_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_SET_TRWA_CTYPE_range[] = { "NONE", "-" };
static char *_EVSEL_SET_TRWA_CTYPE_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWA_CTYPE_type = { _EVSEL_SET_TRWA_CTYPE_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWA_CTYPE = { "CTYPE", 5, "Mnemonic for type",
 "NONE", (char*)0, 8, 2, _EVSEL_SET_TRWA_CTYPE_range, 2,
 _EVSEL_SET_TRWA_CTYPE_range, (KmParFlag)2, KmTYPE_OPTION,
 &_EVSEL_SET_TRWA_CTYPE_type };
static KmParInt    _EVSEL_SET_TRWA_IBITNR_type = { "-1", "32", "-1", "32", 0 };
static KmParameter _EVSEL_SET_TRWA_IBITNR = { "IBITNR", 6,
 "Bit number (if mnemonic NONE)", "0", (char*)0, 3, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_TRWA_IBITNR_type };
static char *_EVSEL_SET_TRWA_SETUNS_range[] = { "SET", "UNSET" };
static char *_EVSEL_SET_TRWA_SETUNS_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWA_SETUNS_type = {
 _EVSEL_SET_TRWA_SETUNS_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWA_SETUNS = { "SETUNS", 6, "Set or unset",
 "SET", (char*)0, 8, 2, _EVSEL_SET_TRWA_SETUNS_range, 2,
 _EVSEL_SET_TRWA_SETUNS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWA_SETUNS_type };
static char *_EVSEL_SET_TRWA_CVETO_range[] = { "Select", "Veto" };
static char *_EVSEL_SET_TRWA_CVETO_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_TRWA_CVETO_type = { _EVSEL_SET_TRWA_CVETO_text,
 (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_TRWA_CVETO = { "CVETO", 5, "Select or Veto",
 "Select", (char*)0, 8, 2, _EVSEL_SET_TRWA_CVETO_range, 2,
 _EVSEL_SET_TRWA_CVETO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_TRWA_CVETO_type };
static KmParameter *_EVSEL_SET_TRWA_parameters[] = { &_EVSEL_SET_TRWA_CTYPE,
 &_EVSEL_SET_TRWA_IBITNR, &_EVSEL_SET_TRWA_SETUNS, &_EVSEL_SET_TRWA_CVETO };
static char *_EVSEL_SET_TRWA_guidance[] = {
 "Select an event by its trigger bits (97-128)" };
static KmCommand _EVSEL_SET_TRWA = { &_EVSEL_SET_TRWB, "/EVSEL/SET/TRWA",
 "TRWA", 0, 2, 4, 1, _EVSEL_SET_TRWA_parameters, 0, 0, roesty_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_TRWA_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_SET_FITYPE_CTYPE_range[] = { "NONE", "-" };
static char *_EVSEL_SET_FITYPE_CTYPE_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_FITYPE_CTYPE_type = {
 _EVSEL_SET_FITYPE_CTYPE_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_FITYPE_CTYPE = { "CTYPE", 5,
 "Mnemonic for type", "NONE", (char*)0, 8, 2, _EVSEL_SET_FITYPE_CTYPE_range,
 2, _EVSEL_SET_FITYPE_CTYPE_range, (KmParFlag)2, KmTYPE_OPTION,
 &_EVSEL_SET_FITYPE_CTYPE_type };
static KmParInt    _EVSEL_SET_FITYPE_IBITNR_type = { "-1", "32", "-1", "32", 0
 };
static KmParameter _EVSEL_SET_FITYPE_IBITNR = { "IBITNR", 6,
 "Bit number (if mnemonic NONE)", "0", (char*)0, 3, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_FITYPE_IBITNR_type };
static char *_EVSEL_SET_FITYPE_SETUNS_range[] = { "SET", "UNSET" };
static char *_EVSEL_SET_FITYPE_SETUNS_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_FITYPE_SETUNS_type = {
 _EVSEL_SET_FITYPE_SETUNS_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_FITYPE_SETUNS = { "SETUNS", 6, "Set or unset",
 "SET", (char*)0, 8, 2, _EVSEL_SET_FITYPE_SETUNS_range, 2,
 _EVSEL_SET_FITYPE_SETUNS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_FITYPE_SETUNS_type };
static char *_EVSEL_SET_FITYPE_CVETO_range[] = { "Select", "Veto" };
static char *_EVSEL_SET_FITYPE_CVETO_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_FITYPE_CVETO_type = {
 _EVSEL_SET_FITYPE_CVETO_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_FITYPE_CVETO = { "CVETO", 5, "Select or Veto",
 "Select", (char*)0, 8, 2, _EVSEL_SET_FITYPE_CVETO_range, 2,
 _EVSEL_SET_FITYPE_CVETO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_FITYPE_CVETO_type };
static KmParameter *_EVSEL_SET_FITYPE_parameters[] = {
 &_EVSEL_SET_FITYPE_CTYPE, &_EVSEL_SET_FITYPE_IBITNR,
 &_EVSEL_SET_FITYPE_SETUNS, &_EVSEL_SET_FITYPE_CVETO };
static char *_EVSEL_SET_FITYPE_guidance[] = {
 "Select an event by its Filter Type" };
static KmCommand _EVSEL_SET_FITYPE = { &_EVSEL_SET_TRWA, "/EVSEL/SET/FITYPE",
 "FITYPE", 0, 2, 4, 1, _EVSEL_SET_FITYPE_parameters, 0, 0, roesty_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _EVSEL_SET_FITYPE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_SET_EVTYPE_OPTION_range[] = { "NONE", "LLLM", "LLQQ",
 "LLCO", "LLIL", "GAM", "HLPT", "HLIS", "TWOP", "HIGS", "GSTR", "HLCM",
 "TKMH", "LLEE", "LLMM", "LLTT", "LLLL", "FYZ1", "FYZS", "FYZT", "TETR",
 "GACE", "LMAE", "MONO", "GOPL", "NELO", "NETI", "UGGE", "IUGG", "WABB",
 "L2MH", "XXXX", "NGAM", "NRH1", "NRH2", "WW4Q", "WWQE", "WWQM", "WWQT",
 "WWLL" };
static char *_EVSEL_SET_EVTYPE_OPTION_text[] = { "Select by Bit number",
 "Low mult presel", "High mult veto", "Cosmic ray veto", "LL Isolated Lepton",
 "Singl phot presel", "Heavy lept MissE", "Heavy lept IsolTrk",
 "Tagged two phot", "Higgs high mult", "Valid single phot",
 "Heavy lept Close-m", "TKMH multihadron", "Electron pair", "Muon pair",
 "Tau pair", "Lepton pair", "Phys1 selection", "Z0 type physics",
 "Lumi type physics", "TE stud prescale", "Chgino Gen ACop",
 "Chgino LowMul ACop", "Chgino MONOJET", "GP Chargino", "Neutralino loose",
 "Neutralino tight", "Excl. Untag 2gamma", "Incl. Untag 2gamma",
 "Wide Angle BhaBha", "LEP2 MultiHadron", "unused", "N-GAMma",
 "Non-rad MH,simple", "Non-rad MH,complex", "WW -> qq qq", "WW -> qq e nu",
 "WW -> qq mu nu", "WW -> qq tau nu", "WW -> l nu l nu" };
static KmParOption _EVSEL_SET_EVTYPE_OPTION_type = {
 _EVSEL_SET_EVTYPE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_EVTYPE_OPTION = { "OPTION", 6,
 "Mnemonic for type", "NONE", (char*)0, 8, 40, _EVSEL_SET_EVTYPE_OPTION_range,
 40, _EVSEL_SET_EVTYPE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_EVTYPE_OPTION_type };
static KmParInt    _EVSEL_SET_EVTYPE_IBITNR_type = { "-1", "64", "-1", "64", 0
 };
static KmParameter _EVSEL_SET_EVTYPE_IBITNR = { "IBITNR", 6,
 "Bit number (if mnemonic NONE)", "0", (char*)0, 3, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_EVSEL_SET_EVTYPE_IBITNR_type };
static char *_EVSEL_SET_EVTYPE_SETUNS_range[] = { "SET", "UNSET" };
static char *_EVSEL_SET_EVTYPE_SETUNS_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_EVTYPE_SETUNS_type = {
 _EVSEL_SET_EVTYPE_SETUNS_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_EVTYPE_SETUNS = { "SETUNS", 6,
 "Set or unset, BitNr=-1:reset all bits", "SET", (char*)0, 8, 2,
 _EVSEL_SET_EVTYPE_SETUNS_range, 2, _EVSEL_SET_EVTYPE_SETUNS_range,
 (KmParFlag)0, KmTYPE_OPTION, &_EVSEL_SET_EVTYPE_SETUNS_type };
static char *_EVSEL_SET_EVTYPE_CVETO_range[] = { "Select", "Veto" };
static char *_EVSEL_SET_EVTYPE_CVETO_text[] = { (char*)0, (char*)0 };
static KmParOption _EVSEL_SET_EVTYPE_CVETO_type = {
 _EVSEL_SET_EVTYPE_CVETO_text, (int*)0, (int*)0 };
static KmParameter _EVSEL_SET_EVTYPE_CVETO = { "CVETO", 5, "Select or Veto",
 "Select", (char*)0, 8, 2, _EVSEL_SET_EVTYPE_CVETO_range, 2,
 _EVSEL_SET_EVTYPE_CVETO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_EVSEL_SET_EVTYPE_CVETO_type };
static KmParameter *_EVSEL_SET_EVTYPE_parameters[] = {
 &_EVSEL_SET_EVTYPE_OPTION, &_EVSEL_SET_EVTYPE_IBITNR,
 &_EVSEL_SET_EVTYPE_SETUNS, &_EVSEL_SET_EVTYPE_CVETO };
static char *_EVSEL_SET_EVTYPE_guidance[] = {
 "Select an event by its Event Type (ROPE)" };
static KmCommand _EVSEL_SET_EVTYPE = { &_EVSEL_SET_FITYPE,
 "/EVSEL/SET/EVTYPE", "EVTYPE", 0, 2, 4, 1, _EVSEL_SET_EVTYPE_parameters, 0,
 0, roesty_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _EVSEL_SET_EVTYPE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_EVSEL_SET_guidance[] = {
 "Define cuts/bits for selection of events" };
static KmMenu _EVSEL_SET = {  (KmMenu*)0,  (KmMenu*)0, "/EVSEL/SET", "SET", 2,
 &_EVSEL_SET_EVTYPE, 1, _EVSEL_SET_guidance, 0, (char**)0, 0, (char**)0 };

static char *_EVSEL_IGNORE_guidance[] = {
 "Disable (ignore) selection based on cuts and bits in header words" };
static KmCommand _EVSEL_IGNORE = {  (KmCommand*)0, "/EVSEL/IGNORE", "IGNORE",
 0, 1, 0, 0, (KmParameter**)0, 0, 0, roesty_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _EVSEL_IGNORE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_ENABLE_guidance[] = {
 "Enable event selection based on cuts and bits in header words" };
static KmCommand _EVSEL_ENABLE = { &_EVSEL_IGNORE, "/EVSEL/ENABLE", "ENABLE",
 0, 1, 0, 0, (KmParameter**)0, 0, 0, roesty_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _EVSEL_ENABLE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_SHOW_EVPAR_range[] = { "ALL", "BITS", "NCT", "EEC", "EHC",
 "EV" };
static char *_EVSEL_SHOW_EVPAR_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0, (char*)0, (char*)0 };
static KmParOption _EVSEL_SHOW_EVPAR_type = { _EVSEL_SHOW_EVPAR_text, (int*)0,
 (int*)0 };
static KmParameter _EVSEL_SHOW_EVPAR = { "EVPAR", 5,
 "Cut parameter / selection bits", "BITS", (char*)0, 8, 6,
 _EVSEL_SHOW_EVPAR_range, 6, _EVSEL_SHOW_EVPAR_range, (KmParFlag)0,
 KmTYPE_OPTION, &_EVSEL_SHOW_EVPAR_type };
static KmParameter *_EVSEL_SHOW_parameters[] = { &_EVSEL_SHOW_EVPAR };
static char *_EVSEL_SHOW_guidance[] = {
 "Show cuts / bits for selection of events" };
static KmCommand _EVSEL_SHOW = { &_EVSEL_ENABLE, "/EVSEL/SHOW", "SHOW", 0, 1,
 1, 1, _EVSEL_SHOW_parameters, 0, 0, roevsl_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _EVSEL_SHOW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_EVSEL_GET_guidance[] = {
 "Get the next event satisfying the cuts set using EVSEL." };
static KmCommand _EVSEL_GET = { &_EVSEL_SHOW, "/EVSEL/GET", "GET", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, rogoku_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0,
 1, _EVSEL_GET_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_EVSEL_guidance[] = { "Cuts for selection of events" };
static KmMenu _EVSEL = {  (KmMenu*)0, &_EVSEL_SET, "/EVSEL", "EVSEL", 1,
 &_EVSEL_GET, 1, _EVSEL_guidance, 0, (char**)0, 0, (char**)0 };

static char *_GE_guidance[] = { "Commands to get original GOPAL information."
 };
static KmMenu _GE = { &_EVSEL,  (KmMenu*)0, "/GE", "GE", 1, &_GE_ROTREE, 1,
 _GE_guidance, 0, (char**)0, 0, (char**)0 };

static char *_DEBUG_guidance[] = { "ROPE debugging commands." };
static KmMenu _DEBUG = { &_GE,  (KmMenu*)0, "/DEBUG", "DEBUG", 1,
 &_DEBUG_ROSIZE, 1, _DEBUG_guidance, 0, (char**)0, 0, (char**)0 };

static char *_FO_guidance[] = { "Interactive commands for Forward detector" };
static KmMenu _FO = { &_DEBUG, &_FO_FORW, "/FO", "FO", 1, &_FO_FDBAT, 1,
 _FO_guidance, 0, (char**)0, 0, (char**)0 };

static char *_MU_guidance[] = { "Interactive commands for Muon chamber." };
static KmMenu _MU = { &_FO, &_MU_MUON, "/MU", "MU", 1, &_MU_MBBAT, 1,
 _MU_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HC_guidance[] = {
 "Interactive commands for Hadronic Calorimeter." };
static KmMenu _HC = { &_MU, &_HC_HCAL, "/HC", "HC", 1, &_HC_HBBAT, 1,
 _HC_guidance, 0, (char**)0, 0, (char**)0 };

static char *_EC_guidance[] = {
 "Interactive commands for Electro-magnetic Calorimeter." };
static KmMenu _EC = { &_HC, &_EC_ECAL, "/EC", "EC", 1, &_EC_TBBAT, 1,
 _EC_guidance, 0, (char**)0, 0, (char**)0 };

static char *_CD_guidance[] = { "Interactive commands for Central Detector." };
static KmMenu _CD = { &_EC, &_CD_CENTRAL, "/CD", "CD", 1, &_CD_CVBAT, 1,
 _CD_guidance, 0, (char**)0, 0, (char**)0 };

static char *_CHARGINO_guidance[] = {
 "Set/print cut parameters, rerun selection code (ROCHSE)" };
static KmMenu _CHARGINO = { &_CD, &_CHARGINO_Setcuts, "/CHARGINO", "CHARGINO",
 1, &_CHARGINO_Rerun, 1, _CHARGINO_guidance, 0, (char**)0, 0, (char**)0 };

static char *_ROPE_guidance[] = { "ROPE interactive commands: main menu" };
static KmMenu _ROPE = { &_CHARGINO,  (KmMenu*)0, "/ROPE", "ROPE", 1,
 &_ROPE_TRIG, 1, _ROPE_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_ROPE, 950303 );
}



