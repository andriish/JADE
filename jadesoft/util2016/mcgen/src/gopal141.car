C GOPAL   1.41/11   990302  18:00  The OPAL/GEANT3 Monte Carlo
*
+PATCH,HISTORY
*
*   Pam file co-ordinator:  C.P.Ward     Cavendish Laboratory, Cambridge
*                                        CPW1@HEP.PHY.CAM.AC.UK
*                                        Pat.Ward@cern.ch
*                                        1223 337228
*
+DECK,V141.
*  MCP mods to UGINIT                            S.W.O'Neale  02-Mar-99.
*  Set quadrupole field accoring to Ebeam        C.P.Ward     24-Feb-99.
*  Update FFCONS                                 B.Surrow     16-Feb.99.
*  Modify FFMPAR                                 C.P.Ward     12-Feb-99.
*  Update sequence FFHD                          B.Surrow     11-Feb-99.
*  Modify FFMPAR                                 B.Surrow     10-Feb-99.
*  Add calls to FFHITS, FFDIGI                   C.P.Ward     03-Feb-99.
*  Add call to FFIFFR in GOIFFR                  C.P.Ward     01-Feb-99.
*  New sequences FFHD,FFMPAR,FFCONS              B.Surrow     01-Feb-99.
*  Increase dz for OPAL volume                   C.P.Ward     29-Jan-99.
*  Update beam spot for 1999                     C.P.Ward     20-Jan-99.
*  Increase maximum # tracks in KIDISK           C.P.Ward     21-Sep-98.
+DECK,V140.
*  Extend FDT- in ECAPAR for mip plug            J.E.Conboy    6-Mar-98.
*  Calculate Ecm for every event in KIDISK       C.P.Ward     18-Feb-98.
*  Remove READONLY from SGI part of OC file      M.Schroder    9-Feb-98.
*  Remove common TEDBUG                          S.Bentvelsen  4-Feb-98.
*  Mods to TE sequences                          S.Bentvelsen 30-Jan-98.
*  Mods to GOROPS for TE                         S.Bentvelsen 30-Jan-98.
*  Modify ECAPAR to redefine inner edge of FTC-  J.E.Conboy   30-Jan-98.
+DECK,V139.
*  GTIME : Initialize NOVER and TIMAX to 0       M.Schroder    5-Dec-97.
*  Remove extraneous parentheses                 M.Schroder    3-Dec-97.
*  Increase space for FFREAD (as ROPE414)        C.P.Ward     17-Nov-97.
+DECK,V138.
*  Remove extra variables from GCTIME            C.P.Ward     14-Mar-97.
*  Include MCP spy code, with Patchy flag MCP    S.W.O'Neale  26-Feb-97.
*  More routines for OPLOAD                      S.W.O'Neale  26-Feb-97.
+DECK,V137.
*  JTPTOF --> array in GOTRIG                    C.P.Ward      9-Sep-96.
+DECK,V136.
*  Explicitly remove ID=91,92,95 from Ecm calc   C.P.Ward     19-Apr-96.
*  Fix first event run/event if no RUNG card     C.P.Ward     18-Apr-96.
*  Update OPALLEGO job                           N.Watson     15-Apr-96.
*  Mod to PDGCHG for code 110                    C.P.Ward     29-Mar-96.
*  Mod to GOLIFE for photons from quarks         C.P.Ward     26-Mar-96.
*  Add TE sequences                              C.P.Ward     21-Mar-96.
+DECK,V135.
*  New routine GOTORD to order TREE              C.P.Ward     18-Mar-96.
*  Add SUSY particle codes to PDGCHG             C.P.Ward     29-Feb-96.
*  Mods to GOHFIL for EB                         T.Mashimo    19-Feb-96.
*  Minor fix in GUSTEP for SMCD                  C.P.Ward     16-Feb-96.
+DECK,V134.
*  Add calls to ROCHIN, HIINIT,HISETR            C.P.Ward     25-Oct-95.
*  Preliminary 1995 LEP1 beam spot pars          C.P.Ward     29-Sep-95.
*  Set train number in REV/header                C.P.Ward     29-Sep-95.
*  New sequence SITMED                           V.Gibson     25-Sep-95.
*  Mods to GOGINT and GOLIFE for PYTHIA events   C.P.Ward     05-Sep-95.
*  Implement GOPAL133 cradle                     C.P.Ward     12-Jun-94.
+DECK,V133.
*  Increase NHMAX in FDIGWK                      J.E.Conboy   23-Jan-95.
*  Modify radius of CVS+ to avoid overlap        G.Wilson     16-Jan-95.
*  Multi-cpu mode for DECstations, Alpha-OSF     C.P.Ward     12-Jan-95.
*  Fix o/p of OD SIW blocks                      C.P.Ward     11-Jan-95.
*  Move OPLOAD to patch OBASE                    C.P.Ward     11-Jan-95.
*  Update example jobs                           C.P.Ward     03-Jan-95.
*  New PE sequences                              A.Stahl      19-Dec-94.
*  New sequence CJDXPAR                          M.Hauschild  17-Dec-94.
*  Change fix for stuck particles in GUSTEP      C.P.Ward     16-Dec-94.
*  Remove SI for expt 6                          C.P.Ward     02-Dec-94.
*  Make o/p of compressed data work              M.Redmond    30-Nov-94.
*  Set IGYEAR correctly for expt.ge.6            J.E.Conboy   14-Nov-94.
*  1994 beam spot info from S. de Jong           C.P.Ward     08-Nov-94.
*  Update lifetimes in GOLIFE                    C.P.Ward     03-Nov-94.
*  Restrict CJKONS to 19 continuation lines      M.Redmond    31-Oct-94.
*  Update sequences CJCODS, CJKONS               M.Hauschild  31-Oct-94.
*  Add calls LMINIT etc.                         C.P.Ward     11-Oct-94.
*  Add QMVAOS switch (Alpha OSF 32-bit)          D.R.Ward     10-Oct-94.
*  Add calls to TE                               C.P.Ward     28-Sep-94.
*  CSINIT --> CSINIR                             C.P.Ward     21-Sep-94.
*  Interactive version of main program           C.P.Ward     21-Sep-94.
*  Remove external declaration of GFTITL         C.P.Ward      9-Aug-94.
*  Modify use of FD card                         C.P.Ward     18-Jul-94.
*  GDGIRL --> GDWMN1 for GEANT321                C.P.Ward      7-Jul-94.
*  Add HIGZ Patchy switch, modify UGINIT         D.R.Ward      5-Jul-94.
*  Remove bootstrap code                         C.P.Ward     07-Jun-94.
*  New routine GOGFFR to decode geom cards       C.P.Ward     07-Jun-94.
*  New routine GOBEAM for default beam spots     C.P.Ward     19-May-94.
*  Mods to GOLIFE, GOGINT for Pythia events      C.P.Ward     16-May-94.
*  Mods to GOKINE, GOCOUT                        C.P.Ward     12-May-94.
*  Mods to PDGCHG, GOKINE                        C.P.Ward     10-May-94.
*  Mod to GOROPS for ROPE407                     M.Redmond    06-May-94.
*  Mods to OPLOAD calls                          C.P.Ward     26-Apr-94.
*  Tidy code                                     C.P.Ward     11-Apr-94.
*  Modify MEMXPA and GUSTFU - ME one set only    C.P.Ward     30-Mar-94.
*  Tidy GOIFFR                                   J.E.Conboy   30-Mar-94.
+DECK,V132.
*  Drop SW working banks before writing DDST     C.P.Ward     19-Jan-94.
*  Set expt no. in IUHEAD in GOROPS              C.P.Ward     22-Dec-93.
*  Update example jobs                           C.P.Ward     21-Dec-93.
*  Mods to treatment of SAVE card                C.P.Ward     20-Dec-93.
*  Remove various unused variables               C.P.Ward      8-Dec-93.
*  Update sequences GOTPAR, GOTRIG               S.Hillier     8-Dec-93.
*  1993 beam spot info from S.de.Jong            C.P.Ward     22-Nov-93.
*  Call RODSWP to drop SI DST banks before o/p   C.P.Ward     19-Nov-93.
*  Mods to SW sequences                          D.L.Wagner   16-Nov-93.
*  Mods to GOKING for electrons                  C.P.Ward     11-Nov-93.
*  Mods to GOTPAR, FDTCON, GOSTAT                C.P.Ward     10-Nov-93.
*  Implement time dependent mixing               R.W.L.Jones   3-Nov-93.
*  Update B lifetime                             S.L.Lloyd    27-Oct-93.
*  New EB KEEP sequences                         T.Mashimo     8-Oct-93.
*  Update GOTSTP for FD/SW                       J.E.Conboy   27-Sep-93.
*  Implement GOPAL131 cradle.                    C.P.Ward     27-Sep-93.
+DECK,V131.
*  Fix bug in GOLIFE.                            C.P.Ward     12-Aug-93.
*  Fixes in GOIFFR, UGLAST.                      C.P.Ward      9-Aug-93.
*  Remove unused TT sequences                    C.P.Ward     30-Jul-93.
*  Implement GOPAL130 cradle                     D.R.Ward      7-Jun-93.
+DECK,V130.
*  Fix bug in EVWRIT                             D.R.Ward     14-May-93.
*  SW sequences                                  D.L.Wagner   13-May-93.
*  Update beam sizes (info from S. de Jong)      D.R.Ward     11-May-93.
*  HB sequences                                  R.Lahmann    10-May-93.
*  SW sequences                                  D.L.Wagner    6-May-93.
*  SW sequences                                  D.L.Wagner   30-Apr-93.
*  FD (related) sequences                        J.E.Conboy   29-Apr-93.
*  Add calls to SW Rope code                     D.R.Ward     11-Mar-93.
*  Permit RUNG to be omitted if KIDISK used      D.R.Ward      5-Mar-93.
*  Some hooks for DC                             D.R.Ward      5-Mar-93.
*  Changes to make Lumi runs easier              J.E.Conboy   24-Feb-93.
*  Fixes for Alpha                               A.Buijs      29-Jan-93.
*  Add calls to SW                               D.R.Ward     17-Dec-92.
*  Move USGEOM to GOPAG                          D.R.Ward     17-Dec-92.
+DECK,V129.
*  Update GOTREE/GOGINT to handle COJETS         J.W.Gary     21-Sep-92.
*  Update beam spread                            R.Kowalewski 17-Sep-92.
*  Update lifetimes                              S.L.Lloyd    17-Sep-92.
*  Update example jobs                           D.R.Ward     27-Aug-92.
*  Add hooks for FLUKA (+USE,FLUKA. / HADR 4)    D.R.Ward     26-Aug-92.
*  Update Beam Spot                              D.R.Ward     24-Aug-92.
*  Update sequence EBXTR                         T.Mashimo    18-Aug-92.
*  Minor mods to pacify the CRAY compiler        D.R.Ward     18-Aug-92.
*  GGET/GSAVE --> GRIN/GROUT                     D.R.Ward     17-Aug-92.
*  Fix problem on RS6000                         R.Howard     17-Aug-92.
*  Fix bad bug in KIDISK                         D.R.Ward     31-Jul-92.
*  Clean up CE interface                         D.R.Ward     29-Jul-92.
*  Remove use of TIMAL on IBM                    D.R.Ward     23-Jul-92.
*  Minor tidying of CZ sequences                 B.Lorazo     15-Jul-92.
*  Implement 'L' option on Unix machines         D.R.Ward      1-Jun-92.
*  Fix compilation on DECS, IBMRT               D.Lellouch/DRW 1-Jun-92.
+DECK,V128.
*  Fix to timing for GEANT314                    D.R.Ward     26-Mar-92.
*  Store delta rays in SIDE In TREE              D.R.Ward     27-Feb-92.
*  TIMEL --> TIMAL on IBM                        D.R.Ward     26-Feb-92.
*  Revert to HADR 1 by default                   D.R.Ward     25-Feb-92.
*  set IFUPDT before ROPTPR called               C.M.Hawkes   21-Feb-92.
*  Bug fix -- stop overwiting LMC+15             G.Quast      17-Feb-92.
*  Mods to Report                                A.Buijs      14-Feb-92.
*  Fixes to QNEXT for GEANT315                   D.R.Ward     14-Feb-92.
*  Add argument to RCASET (ROPE402 change)       D.R.Ward     13-Feb-92.
*  Remove GEANT313/ROPE312 switches              D.R.Ward     13-Jan-92.
*  Flag FULL/SMEA mode etc in MC bank            D.R.Ward     13-Jan-92.
*  Permit Ascii (FA) output                      D.R.Ward      8-Jan-92.
*  Improve KIDISK error handling?                D.R.Ward      8-Jan-92.
*  Implement internal file definition option     D.R.Ward      6-Jan-92.
*  Permit binary KIDISK file                     D.R.Ward      6-Jan-92.
*  Implement RBITFUNC                            D.R.Ward      3-Jan-92.
*  Expunge IMPLICIT NONE                         D.R.Ward     10-Dec-91.
*  Update GOTPAR                                 R.Lahmann     5-Dec-91.
*  Move SMCDES to GOPAS128                       D.R.Ward      5-Dec-91.
*  Minor bug fixes                               D.R.Ward      5-Dec-91.
+DECK,V127.
*  Update CVGOFF                                 R.W.L.Jones  20-Sep-91.
*  Update SMCDES; call SMBEG etc                 D.R.Ward     16-Sep-91.
*  Conditional calling of ROPE routines          D.R.Ward      6-Sep-91.
*  ME bank documentation                         P.Hattersley 23-Aug-91.
*  CJKONS update                                 E.Prebys     23-Aug-91.
+DECK,V126.
*  Fill HEADER before USBAT in NODE mode         J.R.Batley    2-Aug-91.
*  Call USBAT(0) in NODE mode                    J.R.Batley    1-Aug-91.
*  Fix CZ COMMON names; bank doc.                B.Lorazo     31-Jul-91.
*  Update list of externals                      S.W.O'Neale  30-Jul-91.
*  Select FIFAST by default                      D.R.Ward     22-Jul-91.
*  Fix problem with EECALR when NOROPE           D.R.Ward     19-Jul-91.
*  Call OP/FI                                    D.R.Ward     18-Jul-91.
*  Fix up EXTERNALs for CRAY etc                 S.W.O'Neale  16-Jul-91.
*  Call FI/TRINIT,SETR,FIN                       D.R.Ward     16-Jul-91.
*  Update SM                                     S.L.Lloyd    12-Jul-91.
*  Call LLINIT,LLSETR,LLFIN                      D.R.Ward     11-Jul-91.
*  Update examples, Primer                       D.R.Ward     10-Jul-91.
*  Update stuck particle bodge.  Document XTRA   D.R.Ward      8-Jul-91.
*  Update GOTREE                                 J.W.Gary      4-Jul-91.
*  HADR 3 the dafault                            D.R.Ward      4-Jul-91.
*  CRAY OPEN statements etc                      S.O'Neale     4-Jul-91.
*  Update SMCDES                                 S.Lloyd       2-Jul-91.
*  Trivial change in GOTREE                      J.W.Gary      2-Jul-91.
*  Try to fix GET 'INIT'                         D.R.Ward     13-Jun-91.
*  LLCZWT changed to 18.                         B.Lorazo     04-Jun-91.
*  Fix GET INIT for FD                           J.E.Conboy   12-Jun-91.
*  Update ZSTATE for the CRAY's convenience      D.R.Ward      7-Jun-91.
*  Update FD sequences                           J.E.Conboy    7-Jun-91.
*  PB sequence update                            S.Gensler     3-Jun-91.
*  Fix Apollo error handling                     J.N.Banks    31-May-91.
*  Modify TB sequences                           G.W.Wilson   31-May-91.
*  Allow DD to handle CJ cheat info              D.R.Ward     29-May-91.
*  Mods to GUSTFU for FD                         J.E.Conboy   28-May-91.
*  Update CV sequence                            R.W.L.Jones  10-May-91.
*  Update CZ sequences                           B.Lorazo      9-May-91.
*  Rename duplicate COMMON                       R.Kowalewski  9-May-91.
*  Tidy up bank doc                              O.Schaile     9-May-91.
*  Add XTRA bank                                 S.L.Lloyd     9-May-91.
*  Fill IUHEAD before ROPEing                    D.R.Ward      9-May-91.
+DECK,V125.
*  Update SMCDES                                 S.L.Lloyd    26-Apr-91.
*  Clean up DDST output                          D.R.Ward     24-Apr-91.
*  PB sequence updates                           S.Gensler    23-Apr-91.
*  Implement LIFE bank; ROPE version no.         D.R.Ward     17-Apr-91.
*  GEANT314 cradle fix in GFPART                 D.R.Ward     17-Apr-91.
*  Fix up SI statistics                          V.Gibson     16-Apr-91.
*  Sequence changes ME, CJ, SM                   Various      15-Apr-91.
*  Remove some Cj calibration stuff              O.Biebel     15-Apr-91.
*  CJ --> JC if ROPE400                          D.R.Ward     28-Mar-91.
*  Mods to CV sequences                          R.W.L.Jones  22-Mar-91.
*  Mods to CZ sequences                          B.Lorazo     22-Mar-91.
*  Fix GOROPS, GUVIEW                            D.R.Ward     22-Mar-91.
*  Bug fix in GOGINT etc                         B.Lorazo     20-Mar-91.
*  Change to GOHITS                              G.Wilson     19-Mar-91.
*  Minor changes to ZED geometry                 B.Lorazo     12-Mar-91.
*  New ZED MC calibration banks                  B.Lorazo     12-Mar-91.
*  Experiment number 1002 if SI selected         D.R.Ward     12-Mar-91.
*  Remember to close DDST output file            D.R.Ward      4-Mar-91.
*  Unchange RZ default LRECL                     D.R.Ward      4-Mar-91.
*  Add RANLAN,DSTLAN to NOGENLIB                 D.R.Ward      1-Mar-91.
*  Fix constants for DDST                        D.R.Ward      1-Mar-91.
*  Tidy up statistics                            D.R.Ward     26-Feb-91.
*  Permit DDST output                            D.R.Ward     25-Feb-91.
*  SI, CS, DX calls for ROPEing                  D.R.Ward     25-Feb-91.
*  Changes for ROPE400                           D.R.Ward     22-Feb-91.
*  Change blocksize in HROPEN call               S.Weisz/DRW  20-Feb-91.
*  Bug fix in GOPST2                             M.Redmond    18-Feb-91.
*  Changed to CJ calib MC                        O.Biebel     15-Feb-91.
*  Update SMCDES                                 S.Lloyd      15-Feb-91.
*  Change IMULS default to 2 (Moliere)           D.R.Ward      8-Feb-91.
*  Rechristen COMMON/CJSTAT/ (SG problem)        D.R.Ward     29-Jan-91.
*  Minor bug fix in GOROPB                       D.R.Ward      8-Jan-91.
*  Scale mag field by 0.55%                      D.R.Ward      8-Jan-91.
*  Minor bug fix in GUOUT                        D.R.Ward      4-Jan-91.
*  Update sequence PBPARD                        S.Gensler    18-Dec-90.
*  Add GEANT313 switch                           D.R.Ward      3-Dec-90.
*  Remove SI sequences                           V.Gibson      2-Dec-90.
*  Fix Apollo open statements                    J.Banks       2-Dec-90.
*  Mods for GE314                                D.R.Ward      2-Dec-90.
+DECK,V124.
*  HPRA bank documentation                       D.Hochman    29-Oct-90.
*  FIx FUNRAN problem                            D.R.Ward     29-Oct-90.
*  Add OPALLEGO patch + example                  D.R.Ward     25-Oct-90.
*  Allow o/p of FD dense data                    J.E.Conboy   25-Oct-90.
*  Fix 'HIST' on IBM                             S.L.Lloyd    23-Oct-90.
*  Regularize bank documentation                 D.R.Ward     23-Oct-90.
*  Fix GOROPI, Primer                            D.R.Ward     19-Oct-90.
*  Update EVWRIT                                 J.W.Gary     16-Oct-90.
*  Fix problem in QNEXT                          D.R.Ward     12-Oct-90.
*  Add *SKIP and *SELECT cards                   D.R.Ward      5-Oct-90.
*  Tidy up file handling                         D.R.Ward      5-Oct-90.
*  Fix VAX file opening for exchange mode        D.R.Ward     28-Sep-90.
*  Update GUVIEW                                 R.Hemingway  24-Sep-90.
*  Update beam spot for 1990 values              R.Hemingway  24-Sep-90.
*  Update beam spot for 1990 values              D.R.Ward     10-Sep-90.
*  Update FD CDES                                J.E.Conboy   10-Sep-90.
*  Fix for stuck particles on DN10K              J.N.Banks     3-Sep-90.
*  CJ calibration mods                           O.Biebel     28-Aug-90.
*  Updates to GOIFFR, GOLIFE, GOROPB             S.L.Lloyd    28-Aug-90.
*  Small APOLLO fix                              P.Schenk     28-Aug-90.
*  Fix IBM OPCAL opening                         D.R.Ward     28-Jul-90.
*  Update Si CDES                                V.Gibson     25-Jul-90.
*  Update CJ sequence                            P.Pfister    25-Jul-90.
*  Mods for SI                                   V.Gibson/DRW 17-Jul-90.
*  Try to fix *FILE 'HIST'                       D.R.Ward      9-Jul-90.
*  Mods to GOFLD                                 D.R.Ward      6-Jul-90.
*  Mods to SMEAr mode                            S.L.Lloyd     5-Jul-90.
*  Allow CONS o/p on DST stream                  D.R.Ward      3-Jul-90.
*  Improvements to graphics                      R.Hemingway   3-Jul-90.
*  Fix bug in GOTRCO                             S.L.Lloyd    26-Jun-90.
*  Fix trailing blank problem                    R.Hemingway  18-Jun-90.
*  Change Apollo OPEN statements                 P.Schenk     12-Jun-90.
*  Handle MELINK if GET INIT                     D.R.Ward      5-Jun-90.
*  Mods to GOGINE                                J.W.Gary     30-May-90.
*  New CV sequence                               R.W.L.Jones  25-May-90.
*  New ME sequence                               P.Hattersley 25-May-90.
*  Mods to TT sequences                          C.M.Roach    24-May-90.
*  Mods to GUVIEW                                R.Hemingway  21-May-90.
*  Mods to histogram handling                    D.R.Ward      1-May-90.
*  Mods to FD sequences                          J.Conboy     30-Apr-90.
*  Add OC data card                              D.R.Ward     27-Apr-90.
*  Mods for DD processor                         D.R.Ward     18-Apr-90.
*  Mods to KIDISK                                J.W.Gary     17-Apr-90.
*  Corrections to GOPAL123                       Various      17-Apr-90.
+DECK,V123.
*  Mods to GUVIEW for new ME geometry            D.R.Ward      7-Mar-90.
*  set IODVER for SMEA mode                      D.R.Ward      7-Mar-90.
*  modify MEPAT sequence                         N.K.Watson    6-Mar-90.
*  Add sequence EBXTR                            T.Mashimo     1-Mar-90.
*  Update NOGENLIB patch (EISRS1 etc)            D.R.Ward      1-Mar-90.
*  Apollo error handling                         J.N.Banks    26-Feb-90.
*  Declare OD TOF block                          D.R.Ward     23-Feb-90.
*  Add EEGFFR sequence                           C.P.Ward     22-Feb-90.
*  Small mods for ROPE309                        D.R.Ward     19-Feb-90.
*  Update ME sequences etc                       N.K.Watson   19-Feb-90.
*  Mods to PB sequences; GOHFIL                  M.Redmond    15-Feb-90.
*  New CZ sequences                              B.Lorazo     12-Feb-90.
*  New FD sequences                              J.E.Conboy   12-Feb-90.
*  Bug fix in GOLINT                             D.Lellouch    9-Feb-90.
*  Mods to TR sequences                          D.R.Ward      2-Feb-90.
*  New statistics on timing and event sizes      D.R.Ward     16-Jan-90.
*  New data cards ZLOG ZVER and PNAM             D.R.Ward     16-Jan-90.
*  SI hooks                                      D.R.Ward     16-Jan-90.
*  New trigger sequences                         D.R.Ward      8-Jan-90.
*  Changes for interactive mode                  D.R.Ward      5-Jan-90.
*  Multi-cpu version for VAXes                   D.R.Ward      4-Jan-90.
*  Set IRDEXP in GOROPS                          D.R.Ward      4-Jan-90.
+DECK,V122.
*  Remove ICAVFL, set IFBOOK                     D.R.Ward      4-Dec-89.
*  Update CJPACK sequences                       D.R.Ward     30-Nov-89.
*  Update default beam spot                      D.R.Ward     30-Nov-89.
*  Mods to detector status word                  D.R.Ward     30-Nov-89.
*  Type CVCDIM                                   R.W.L.Jones  30-Nov-89.
*  Mods to CJ sequences                          H.Kreutzmann 29-Nov-89.
*  Mods to FD bootstrap                          C.Chang      29-Nov-89.
*  Add user routine USSLCT                       D.R.Ward      6-Nov-89.
*  Implement *FILE 'PROD'                        D.R.Ward      1-Nov-89.
+DECK,V121.
*  Change a format statement                     D.R.Ward     11-Oct-89.
*  mod in GOROPS                                 D.R.Ward      7-Oct-89.
*  change GOSMR (new SMRMOM)                     D.R.Ward      4-Oct-89.
*  call REINIT (ROPE308 change)                  D.R.Ward     23-Sep-89.
*  Fix VAX file opening in KIDISK                D.R.Ward     14-Sep-89.
*  Erase HPMEAS sequence                         D.Hochman    14-Sep-89.
*  FD bootstrap                                  C.Y.Chang    24-Aug-89.
*  CRAY fix                                      S.W.O'Neale  15-Aug-89.
+DECK,V120.
*  PB, CZ bank documentation                     Losty/Redmond31-Jul-89.
*  Mods for SMEAr mode                           J.N.Banks    31-Jul-89.
*  ME bank documentation                         P.Hattersley 28-Jul-89.
*  Mods to GOTRPR                                D.R.Ward     26-Jul-89.
*  Tidy bank documentation                       D.R.Ward     24-Jul-89.
*  Add SHARED to a couple of VAX OPEN stmts      D.R.Ward     24-Jul-89.
*  Small CRAY fix                                S.W.O'Neale  20-Jul-89.
*  Mods because of HT/HS tidying in ROPE         S.Weisz      19-Jul-89.
*  Add second argument to FIEL card              D.R.Ward     18-Jul-89.
*  Small changes to file opening                 D.R.Ward     17-Jul-89.
*  New FTDIGL sequence                           B.Kennedy    16-Jul-89.
*  Unduplicate HT bank doc                       A.Buijs      14-Jul-89.
*  Update FD sequences                           B.Kennedy    12-Jul-89.
*  CZ bank documentation updated                 B. Lorazo     4-Jul-89.
*  Mods for CZ                                   B.Lorazo      4-Jul-89.
*  Small graphics corrections                    D.R.Ward      3-Jul-89.
*  Update GOHFIL for new FD format               B.W.Kennedy   1-Jul-89.
*  New FD sequence                               B.W.Kennedy  29-Jun-89.
*  LUND generator withdrawn (PCG instructions)   D.R.Ward     29-Jun-89.
*  Small fix to TB trigger                       G.W.Wilson   29-Jun-89.
*  Fix GOHFIL for new TB; banks doc.             G.W.Wilson   28-Jun-89.
*  Bug fix in GUSTFU                             D.R.Ward     28-Jun-89.
*  Tweak raw data histos                         D.R.Ward     28-Jun-89.
*  New sequence MEGEPA                           P.Hattersley 27-Jun-89.
*  Mods for CZ                                   B.Lorazo     27-Jun-89.
*  New HB and HE KEEP sequences.                 A.Buijs      26-Jun-89.
*  Changes to GOSMR, mods to GOROP*              J.N.Banks    23-Jun-89.
*  Initialize GOSLNK                             J.N.Banks    20-Jun-89.
*  Use +SEQ,DECLARE                              D.R.Ward     19-Jun-89.
*  Mods to KIDISK etc                            J.W.Gary     16-Jun-89.
*  Write RST                                     D.R.Ward     15-Jun-89.
*  Implement *FILE 'KINE'                        D.R.Ward     15-Jun-89.
*  Bug fix in GUOUT                              S.W.O'Neale   9-Jun-89.
*  Changes for CJ RZ handling                    H.Kreutzmann  8-Jun-89.
*  CZ sequences + changes                        B.Lorazo      7-Jun-89.
*  Change GOSMR                                  J.N.Banks     6-Jun-89.
*  More header changes                           D.R.Ward      6-Jun-89.
*  Changes for ROPE307 - new header / GNCT bank  D.R.Ward      2-Jun-89.
*  Changes for GEANT313 - r.n. generator         D.R.Ward      1-Jun-89.
*    (NOT documented in detail)
*  Permit use of *FILE cards                     D.R.Ward      1-Jun-89.
*  Mods to ROPE interface (GOROPB etc)           D.R.Ward     19-May-89.
*  Update GOTREE                                 D.R.Ward     17-May-89.
*  Remove CERNVAX  option                        D.R.Ward     17-May-89.
*  Fix CJ bug                                    D.R.Ward     17-May-89.
*  Drop KINE/VERT banks from output              D.R.Ward     11-May-89.
*  Store neutrinos in TREE (sometimes)           D.R.Ward     11-May-89.
*  Update GOSMR sequence; mod to GUSTEP          J.Banks      10-May-89.
*  Trap "stuck" particles                        D.R.Ward      9-May-89.
*  Set MC expt number to 1001                    D.R.Ward      9-May-89.
*  Bug fix for tracks reentering CD              D.R.Ward      9-May-89.
*  Remove GEANT311 option                        D.R.Ward     26-Apr-89.
*  Remove PIGS/GD3 option                        D.R.Ward     26-Apr-89.
*  Remove TATINA   option                        D.R.Ward     26-Apr-89.
*  Remove CASCADE  option                        D.R.Ward     26-Apr-89.
*  Bug fix in GUTREV                             D.R.Ward     26-Apr-89.
*  Extend MC bank                                A.Buijs      26-Apr-89.
*  Mods to KIDISK code                           W.J.Gary     26-Apr-89.
+DECK,V119.
*  Fix TRigger common block problem              D.Charlton   20-Apr-89.
*  Changes to Apollo OPEN statements             S.Weisz      20-Apr-89.
*  Set IPAOLD in GUKINE (suspected bug)          D.R.Ward     18-Apr-89.
*  New trigger CDES                              Roach/Dittmar18-Apr-89.
*  Card file generator interface                 W.J.Gary     18-Apr-89.
+DECK,V118.
*  Update examples                               D.R.Ward      7-Apr-89.
*  Update CJ documentation of banks              H.Kreutzman   7-Apr-89.
*  Correction for changes in ROPE306             D.R.Ward      6-Apr-89.
*  Update PRIMER                                 D.R.Ward      6-Apr-89.
*  Mods to GOHFIL for FD                         B.W.Kennedy   5-Apr-89.
*  Tidy up bank documentation                    D.R.Ward      5-Apr-89.
*  Changes to ZTELUS                             S.L.Lloyd     5-Apr-89.
*  Mods to GOHFIL for new PE                     D.Hochman     5-Apr-89.
*  New PE bank documentation                     D.Hochman     4-Apr-89.
*  New FD sequences                              B.W.Kennedy   4-Apr-89.
*  Increment r.n. seed each event                D.R.Ward      3-Apr-89.
*  Mods to GOHFIL for new EE data format         C.P.Ward      3-Apr-89.
*  New CV bank documentation                     S.L.Lloyd    22-Mar-89.
*  Mods to GOHFIL for new MB data format         D.R.Ward     21-Mar-89.
*  new MMCHEA sequence                           R.J.Barlow   20-Mar-89.
*  Initialize IOREV properly                     D.R.Ward     15-Mar-89.
*  Mods for OD302                                D.R.Ward     13-Mar-89.
*  New CJ sequences                              H.Kreutzmann  9-Mar-89.
*  Add CJ data packing option                    D.R.Ward      9-Mar-89.
*  Fix problem with output of ROPE control?      D.R.Ward      9-Mar-89.
*  Change setting of ZEBRA phase.                D.R.Ward      9-Mar-89.
*  Initialize IOREV                              D.R.Ward      8-Mar-89.
*  Initialize RZ top bank names                  D.R.Ward      7-Mar-89.
*  Minor bug fixes                               Lloyd/Oneale  2-Mar-89.
*  Remove HBOOK3 (=> +USE,HBOOK4 not needed)     D.R.Ward      1-Mar-89.
*  Sundry bug fixes                              D.R.Ward     28-Feb-89.
*  Fix bug in GUSTEP logic                       D.R.Ward     26-Feb-89.
*  Add calls to ROSUMM in SMEAr mode             D.R.Ward     26-Feb-89.
*  Mods for ME in GOHFIL                         ????????     26-Feb-89.
*  Transfer GOPAR from ROPE                      D.R.Ward     25-Feb-89.
*  CV Mods                                       R.W.L.Jones  25-Feb-89.
*  Change to TREE (PDG codes)                    S.L.Lloyd    24-Feb-89.
*  Mods to GOHFIL for PB                         M.Redmond    24-Feb-89.
*  Initialize REPORT                             S.Weisz      24-Feb-89.
*  Update Primer, examples                       D.R.Ward     23-Feb-89.
*  Mods for ROPE306                              D.R.Ward     21-Feb-89.
*  Upgrade of the SMEA routines                  J.N.Banks    15-Feb-89.
*  Mods for new EB data structure                T.Mashimo    14-Feb-89.
*  Update beamspot                               D.R.Ward      9-Feb-89.
*  Clean up interface to ROPE                    S.Weisz       9-Feb-89.
*  Update lifetimes                              S.L.Lloyd     7-Feb-89.
*  Mods for ROPE306                              D.R.Ward      6-Feb-89.
*  Mods to Track trigger CDES                    C.M.Roach     2-Feb-89.
*  Mods to CJ mods                               H.Kreutzmann 26-Jan-89.
*  Fix new (since 19/12/88) bugs in GOTRUP       D.R.Ward     24-Jan-89.
*  Mods to allow CJ use of RZ file               H.Kreutzmann 24-Jan-89.
*  CRAY mods                                     S.W.O'Neale  24-Jan-89.
*  Mods to EE bank documentation                 C.P.Ward     20-Jan-89.
*  Still working on new CJ code                  D.R.Ward      4-Jan-89.
*  Mods for new CJ code                          H.Kreutzmann  3-Jan-89.
*  Changes to setting of CE levels.              D.R.Ward     21-Dec-88.
*  Fix bug in GOROPS                             J.Banks      19-Dec-88.
*  Problem with muons in TREE                    S.Lloyd      19-Dec-88.
*  Fix GDHITS bug                                A.Buijs      14-Nov-88.
*  Fix bugs in GOPRIN, UGLAST                    D.R.Ward      4-Nov-88.
+DECK,V117.
*  Update GOPRIMER, examples                     D.R.Ward     27-Oct-88.
*  Modify GOSMR sequence                         R.J.Barlow   18-Oct-88.
*  Small mods to GUSTEP logic                    D.R.Ward     18-Oct-88.
*  Small mods to GUSTEP logic                    D.R.Ward     14-Oct-88.
*  More changes for GEANT312!! (GGET/GSAVE)      D.R.Ward     13-Oct-88.
*  Mods to MULS for GEANT312                     D.R.Ward     11-Oct-88.
*  Fix antisigma bug                             D.Lellouch    7-Oct-88.
*  Mods to GOBANK                                D.R.Ward      3-Oct-88.
*  Fix REV I/O characteristic                    D.R.Ward     27-Sep-88.
*  Fix bugs in KIPION, GOLINT                    D.R.Ward     27-Sep-88.
*  Mods to KINE handling (GEANT312)              D.R.Ward     26-Sep-88.
*  Introduce NODEtector mode                     A.Buijs      26-Sep-88.
*  Enable ROPE FFREAD cards                      D.R.Ward     26-Sep-88.
*  Various minor fixes                           D.R.Ward     26-Sep-88.
*  Changes for ROPE305/OD301                     D.R.Ward     26-Sep-88.
*  EXTERNAL GUNEAR in MAIN                       D.R.Ward     16-Sep-88.
*  More mods for GEANT312                        D.R.Ward     12-Sep-88.
*  Link for trigger bank                         D.R.Ward     12-Sep-88.
*  IUSET => IHSET                                D.R.Ward     12-Sep-88.
*  Small changes to GUSTEP                       D.R.Ward      9-Sep-88.
*  More GEANT312 changes                         D.R.Ward      9-Sep-88.
*  Fix EE bug in GUSTFU                          D.R.Ward      9-Sep-88.
*  Set IRSTOP                                    D.R.Ward      8-Sep-88.
*  Some fixes for GEANT312                       D.R.Ward      6-Sep-88.
*  Fix ZTELUS problem                            D.R.Ward      6-Sep-88.
*  Updates to SMEAr code/sequences               R.J.Barlow    5-Sep-88.
*  Bug fix in GOHFL2                             D.R.Ward      1-Sep-88.
*  Add call to invoke trigger code               D.R.Ward      1-Sep-88.
*  Add CDES for trigger simulation               D.R.Ward     31-Aug-88.
*  Bug fix in GUSTEP (debug printing)            D.R.Ward     15-Aug-88.
*  Modify GUSTEP for new fast CD geometry        D.R.Ward      8-Aug-88.
*  Small update to Primer                        J.Allison     8-Aug-88.
*  Remove GOHEAD                                 D.R.Ward      8-Aug-88.
+DECK,V116.
*  Change Apollo OPEN statements (again)         J.Allison     4-Aug-88.
*  Small change to geometric cuts in GOKING      D.R.Ward      3-Aug-88.
*  Apollo examples in PRIMER                     J.Allison     3-Aug-88.
*  Minor bug fix in GUSTEP                       D.R.Ward      3-Aug-88.
*  Small update to examples                      D.R.Ward      2-Aug-88.
*  Test for end-of-file from GGET                D.R.Ward      1-Aug-88.
*  Further fix for random numbers                D.R.Ward      1-Aug-88.
*  Use standard Title form in GOVERS             S.W.O'Neale  30-Jul-88.
*  Retain LUND DPAR(16)=0.5 (advice requested).  S.W.O'Neale  29-Jul-88.
*  Set Electroweak and Fragmentation Parameters  J.W.Gary     27-Jul-88.
*  in GOLUNI. Add LUD0BR,LUDCBR for D Decays.    J.Chrin      27-Jul-88.
*  Protect log(rndm)                             M.Dittmar    26-Jul-88.
*  Add LASTMO to sequence GOVERS                 S.W.O'Neale  26-Jul-88.
*  Set blocksize=8100 for exchange mode          S.W.O'Neale  26-Jul-88.
*  Small updates to examples                     D.R.Ward     26-Jul-88.
*  Update the HSTA 'RAWD' histograms             D.R.Ward     25-Jul-88.
*  Update PRIMER and examples                    D.R.Ward     25-Jul-88.
*  Correction to Apollo mods                     J.Allison    25-Jul-88.
*  Handle random number repeat problem better    D.R.Ward     25-Jul-88.
*  Fix MMCHEA documentation                      P.Hinde      25-Jul-88.
*  Hang REV from JHEAD-1 (allow reread of KINE?) D.R.Ward     22-Jul-88.
*  Handle random number repeat problem?          D.R.Ward     22-Jul-88.
*  Add call to CEFIN                             D.R.Ward     22-Jul-88.
*  New OPEN statements for Apollo                J.Allison    22-Jul-88.
*  Fix DRW bugs in IBM error handling            D.R.Ward     22-Jul-88.
*  Prevent CEINIT messing up GOPAL settings      D.R.Ward     21-Jul-88.
*  Introduce GOLUNI to set OPAL LUND defaults    D.R.Ward     19-Jul-88.
*  Fix small bugs regarding TREE                 S.L.Lloyd    19-Jul-88.
*  Update HB/E sequences                         A.Buijs      18-Jul-88.
*  Tidy up some bank names (Schailes)            D.R.Ward     15-Jul-88.
*  Update GOHFIL for new CV banks                R.Hemingway  15-Jul-88.
*  Add CV sequences                              A.McPherson  15-Jul-88.
*  Remove TEX comments from CV                   D.R.Ward     15-Jul-88.
*  Update ME                                     P.Hattersley 12-Jun-88.
*  Improve IBM error handling                    S.W.O'Neale  11-Jul-88.
*  Update BOOTGEN for EB                         K.Kawagoe    11-Jul-88.
*  Modify GOSMR sequence                         J.N.Banks    11-Jul-88.
*  Rationalize use of NOROPE switch              S.W.O'Neale  11-Jul-88.
*  Fix bugs for CRAY                          G.Patrick/SWO'N 11-Jul-88.
*  Add MM sequence                               P.Hinde      11-Jul-88.
*  Add HP sequence                               D.Hochman    11-Jul-88.
*  Fix (temporary) bug in REVBOK                 D.Schaile     2-Jun-88.
*  Enable CE/CA/AS                               D.R.Ward      2-Jun-88.
*  Small mods in GOHFL2, GUSTEP                  D.R.Ward      1-Jun-88.
*  Set some logicals at initialization time;
*    modify control for SM; add SEQuences.       R.J.Barlow   30-May-88.
*  Move SM.... routines to GOPAH PAMfile         D.R.Ward     30-May-88.
*
+DECK,V115.
*  Add patch GOPRIMER                            D.R.Ward     26-May-88.
*  Tidy up GOBANK (only includes banks that are
*     not documented in ROPE)                    D.R.Ward     26-May-88.
*  Update example jobs etc                       D.R.Ward     26-May-88.
*  Add NOROPE PAtchy switch                      D.R.Ward     26-May-88.
*  Further bug in GUOUT                          D.R.Ward     25-May-88.
*  Fix bug with pilot (GUOUT)                    D.R.Ward     25-May-88.
*  Further mods to CJ                            H.Kreutzmann 25-May-88.
*  Write out whole DATC structure                D.R.Ward     24-May-88.
*  Modify GOHFIL for the new CZ bank structure   D.R.Ward     19-May-88.
*  Update bank doc                               B.Lorazo     19-May-88.
*  OPEN statements for Apollo                    D.Schaile    18-May-88.
*  Changes for OD203                             D.R.Ward     18-May-88.
*  Rename COMMON/TBCONS/ (clash with rope)       D.R.Ward     18-May-88.
*  Changes for APOLLO                            D.Schaile    17-May-88.
*  Changes for ROPE302                           D.R.Ward     17-May-88.
*  Fix bug in GOTRUP; small improvement in GOKINGD.R.Ward     17-May-88.
*  Protect MZPUSH call                           D.R.Ward     12-May-88.
*  TIDY code in OBASE using FLOPPY               D.R.Ward     11-May-88.
*  Set endpoints in TREE                         D.R.Ward     10-May-88.
*  Add HSTA 'DST ' option                        D.R.Ward     10-May-88.
*  Bug fix in GOTRCO, mods to GUSTEP,GOKING      D.R.Ward     10-May-88.
*  A little tidying up in GUSTEP                 D.R.Ward      9-May-88.
*  Mods in GOKING                                D.R.Ward      9-May-88.
*  Several minor bug fixes.                      D.R.Ward      6-May-88.
*  Graphics fixes                                R.J.Hemingway 6-May-88.
*  Assorted bug fixes to new KINE code           S.L.Lloyd     5-May-88.
*  Add hooks for SMEAr routines                  D.R.Ward      4-May-88.
*  Add DST option to the SAVE card               D.R.Ward      3-May-88.
*  Add ERRSETs for VAX; fix printing in GOIFFR   D.R.Ward      3-May-88.
*  Modify format of PILOT record                 A.Buijs       2-May-88.
*  Allow IHADR=0 possibility                     R.J.Hemingway 2-May-88.
*  Modify division initialization                D.R.Ward     29-Apr-88.
*  Tidy up use of GENLIB                         D.R.Ward     28-Apr-88.
*  Update FD code                                M.DallaValle 27-Apr-88.
*  More strong typing                            D.R.Ward     26-Apr-88.
*  Fix minor bug in KICOSM                       P.M.Watkins  25-Apr-88.
*  More strong typing                            D.R.Ward     25-Apr-88.
*  Introduce new KINE routines                   S.L.Lloyd    25-Apr-88.
*  Start strong typing OBASE                     D.R.Ward     22-Apr-88.
*  Fix max number of CJ points                   H.Kreutzmann 21-Apr-88.
*  Call ROPE processors from inside GOPAL.       D.R.Ward     19-Apr-88.
*  If you don't want this you have to
*  link to the DUMMY rope library.
*  Otherwise you choose which ROPE processors
*  you require by linking to the relevant ROPE libraries.
*  Update CJ sequences + bank descriptions.      H.Kreutzmann 18-Apr-88.
*  Fix bug in GOIFFR                             D.R.Ward     15-Apr-88.
*  Modify to use ROPE version of REPORT          D.R.Ward     14-Apr-88.
*  Modify LINKRA to use the ROPE sequence ROLINK D.R.Ward     13-Apr-88.
*  Rename LCD (clash with ROPE)                  D.R.Ward     11-Apr-88.
*  Kill GEANT output if SAVE not selected        D.R.Ward     25-Mar-88.
*  Add type declarations to sequences            D.R.Ward     24-Mar-88.
*  Add GCUNIT to GOIGR                           O.Biebel     24-Mar-88.
*  Fix bugs in GOHFIL, VTXMOD                    D.R.Ward     11-Mar-88.
*  Bug - add sequence GCONST in GOIFFR           D.R.Ward      8-Mar-88.
*  HBOOK4 option in BOOTGEN                      D.R.Ward      2-Mar-88.
*  Fix equivalencing bug in BOOTGEN              K.Kawagoe     2-Mar-88.
*  Bug - add sequence GOFLD in GOIFFR            D.R.Ward     26-Feb-88.
+DECK,V114.
************************************************************
*                                                          *
*      GOPAL 1.14/21 Released 24 February 1988             *
*                                                          *
************************************************************
*  Update bank documentation                     D.R.Ward     24-Feb-88.
*  Add dummy graphics routined to P=MAIN         D.R.Ward     23-Feb-88.
*  Update example jobs                           D.R.Ward     23-Feb-88.
*  Update GOHFIL (new ME data structure)         D.R.Ward     10-Feb-88.
*  Add shower tracking routines (for future use) D.R.Ward     10-Feb-88.
*  User routine USIFFR added.                    D.R.Ward      9-Feb-88.
*  Call GLUNDI at initialization                 S.O'Neale     9-Feb-88.
*  Add EXTERNAL statement in MAIN                D.R.Ward      8-Feb-88.
*  Store GOPAL version number in event record    D.R.Ward      2-Feb-88.
*  Update some CJ CDES                           H.Kreutzmann  1-Feb-88.
*  Useful version of VTXMOD                      M.Hansroul   29-Jan-88.
*  Some mods in GOIFFR, GUOUT                    D.R.Ward     29-Jan-88.
*  Test on IEORUN in MAIN/UGINIT                 D.R.Ward     27-Jan-88.
*  New data cards CD CAL PSAM FD NODE            D.R.Ward     26-Jan-88.
*    (pending introduction of fast simulation options).
*  Reorganize UGINIT                             D.R.Ward     19-Jan-88.
*  Cosmic event generator KICOSM                 P.M.Watkins  18-Jan-88.
*  Fix up timing (in QNEXT)                      R.Yaari       9-Jan-88.
*  Bug fix for UNIT card                         H.Kreutzmann  7-Jan-88.
*  Tidy up printing in GOPSTA                    D.R.Ward     18-Dec-87.
*  Include CJ laser calibration material         R.Hospes     16-Dec-87.
*  GOPAL split into 4 pam files! namely:         D.R.Ward     15-Dec-87.
*     GOPALXxx   CDES, OBASE, documentation, examples etc.
*     GOPAGXxx   The geometry and field map routines.
*     GOPAHXxx   The HITS code.
*     GOPADXxx   The DIGITS code.
+DECK,V113.
*  Update example jobs                           D.R.Ward     10-Dec-87.
*  Change some STMINs in OPGEOM                  D.R.Ward     10-Dec-87.
*  Don't store mu from stopping pi               D.R.Ward      2-Dec-87.
*  Test on IEOTRI in GUDIGI                      D.R.Ward      2-Dec-87.
*  PRSTEP removed (not used)                     D.R.Ward     30-Nov-87.
*  Include REPORT routine to tally errors      DRW/A.Buijs    30-Nov-87.
*  Fix bug in PESIZE                             D.Lellouch   27-Nov-87.
*  Add statistics routines                       D.R.Ward     27-Nov-87.
*  Option IKINE=5 : calls G1PART (q.v.)          D.R.Ward     27-Nov-87.
*  PATCHY switch HBOOK4 added                    D.R.Ward     25-Nov-87.
*  Option 'RAWD' on SAVE card allowed            D.R.Ward     25-Nov-87.
*  Fix small bug in EEFGEO                       R.Yaari      24-Nov-87.
*  New versions of HBCDES, HBGEOM                A.Buijs      18-Nov-87.
*  Random number seeds stored in MC bank         D.R.Ward     11-Nov-87.
*  Update PE code                                D.Lellouch    5-Nov-87.
*  Mods in UGINIT to fix Ottawa compiler problem R.Hemingway  21-Oct-87.
*  New BPFGEO                                    D.R.Ward     21-Oct-87.
*  New HBFGEO/HEFGEO routines                    J.Layter     21-Oct-87.
*  FD bank documentation                         M.Dallavalle 21-Oct-87.
*  Sundry bug fixes in OPGEOM                    D.R.Ward     21-Oct-87.
*  Bug fix in BAGEOM (when BD only selected)     A.Possoz      8-Oct-87.
*  Cheat words for ME/MB                         P.M.Watkins   6-Oct-87.
*  New version of CVGEOM                         A.McPherson   6-Oct-87.
*  Add patch GOBANK                              D.R.Ward      6-Oct-87.
*  Change bank names in GOKING, GUDIGI           D.R.Ward      1-Sep-87.
*  Write raw data only if SAVE 'DIGI'            D.R.Ward      1-Sep-87.
*  'OPAL' default on VIEW card                   D.R.Ward      1-Sep-87.
*  Tidy up SUBROUTINE headers                    D.R.Ward     31-Aug-87.
+DECK,V112.
*           Tidy up graphics attributes          D.R.Ward     21-Jul-87.
*           Add call to user routine USSTEP      D.R.Ward     20-Jul-87.
*           Tidy up documentation                D.R.Ward     18-Jul-87.
*           Mods to MBGEOM                       G.Lafferty   16-Jul-87.
*           Lift constants structure for ROPE    D.R.Ward     15-Jul-87.
*           Full field map now the default       D.R.Ward      7-Jul-87.
*           First version of PEGEOM              D.Lellouch    7-Jul-87.
*           Update some CJ sequences             H.Kreutzmann  3-Jul-87.
*           New MBGEOM                           G.Lafferty    3-Jul-87.
*           Mods to GUTREV                       B.Lorazo     21-Jun-87.
*           Mods to CZ code                      B.Lorazo      4-Jun-87.
*           Updates of HB/HE code                A.Buijs       2-Jun-87.
*           New version of EBGEOM etc,           T.Mashimo     1-Jun-87.
*           New options in GUVIEW                B.Lorazo      1-Jun-87.
*           Changes to TB geom, hits, raw data   A.Possoz     28-May-87.
*           Allow CV CJ CZ CP on GEOM card       D.R.Ward     12-May-87.
*            (CD still allowed)
*           Eliminate NORRAN                     D.R.Ward     11-May-87.
*           Updates to CJ digitiz'n              H.Kreutzmann 11-May-87.
*           New HPDIGI (raw data)                D.Hochman    11-May-87.
*           Lift and output RAW data banks.      D.R.Ward     16-Apr-87.
*             (output to stream 21 by default)
*           UNIT card to change I/O units        D.R.Ward     16-Apr-87.
*           Introduce skeleton bootstrap for EB  D.R.Ward     13-Mar-87.
*             (parametrizations only preliminary)
*           Fix problem in MBGEOM                S.O'Neale    24-Feb-87.
*           Allow to change SAVE/GET streams     D.R.Ward     23 Feb 87.
*           FAST geometry option                 D.R.Ward     23 Feb 87.
*             (Skeleton only, for users to improve)
*           Fix bug in ECGEOM                    D.R.Ward     12 Feb 87.
*
*     Version 1.12 - pam file is too big - split into two:
*                    GOPAL contains OBASE, OGEOM, field map and
*                          examples etc.
*                    GOPAD contains OHITS and ODIGI.
*
+DECK,V111.
*           Tidy up DZDOC comments               D.R.Ward      9 Feb 87.
*           Update examples etc.                 D.R.Ward      4 Feb 87.
*           New version of EEQUAD                G.Patrick     3 Feb 87.
*           New versions of HB and HE code      A.Buijs/C.Chang2 Feb 87.
*           Tidy up TMED definitions             D.R.Ward      2 Feb 87.
*           Remove some more holleriths          D.R.Ward      2 Feb 87.
*           CZ raw data banks                    B.Lorazo     30 Jan 87.
*           ZEBRA error recovery                 S.W.O'Neale  28 Jan 87.
*           CHEAt data card (a la DIGI)          D.R.Ward     28 Jan 87.
*           Link area for raw data in LINKRA     D.R.Ward     28 Jan 87.
*           'EXCH' option on SAVE/GET cards      D.R.Ward     28 Jan 87.
*           New ME geom/hits/raw data            P.Hattersley 26 Jan 87.
*           New CJ hits/digits code              H.Kreutzmann 21 Jan 87.
*           New PB code                          A.Possoz     21 Jan 87.
*           Improvements to Bootstrap            D.R.Ward     12 Jan 87.
*           Fix GUFLD                            G.Patrick     9 Jan 87.
*           Add FIEL data card                   A.McPherson/DRW  "
*           Update HB geom, hits, digits         C.Chang      19 Dec 86.
*           Add "BOOTSTRAP" option for EE        D.R.Ward     18 Dec 86.
*           Bug fix in GUSTEP                    T.Mashimo    12 Dec 86.
*           CV digits                            A.McPherson  11 Dec 86.
*           Raw data banks in EEDIGI             D.R.Ward      5 Dec 86.
*           Numbering in HPHITS                  D.Hochman     5 Dec 86.
*           Add PE FD and HP to GEOM card        D.R.Ward     30 Nov 86.
*           Update representation of beam pipe   D.R.Ward      8 Nov 86.
*           More use of workspace in DIGI routines.D.R.Ward    5 Nov 86.
*           New EEAVPE (much faster)             D.R.Ward     25 Oct 86.
*           Improvements to funny shaped EE blocks D.R.Ward   20 Oct 86.
*           Changes in GOKING                    D.R.Ward     20 Oct 86.
+DECK,V110.
*           Improvements to TB                   A.Possoz      6 Oct 86.
*           Various changes aimed at speeding    D.R.Ward     16 Sep 86.
*           up execution...
*           Supervolumes ECA- BRL- now declared 'ONLY', and don't overla
*           other volumes
*           User search feature used for lead glass blocks in EE
*           Inefficient PGONs removed in CD
*           Improvements in beam pipe
*           DATR bank added to HEAD structure to S.O'Neale    16 Sep 86.
*           be used in the transition from GEANT data
*           structures to OPAL detector structures.
*           USGEOM call and dummy routine added  S.O'Neale    16 Sep 86.
*           Corrections to CJ Digits             R.Krieger    16 Sep 86.
*           CODE cleaning for I/O via GMAIL and  S.O'Neale    14 Sep 86.
*           PRNTid, and Zebradoc (MBGEOM to CDHITS)
*           OGEANT Patch added, Improvements     S.O'Neale    25 Aug 86.
*           to GEANT 310 routines for OPAL use.
*           CERNVAX option to print during init. S.O'Neale    22 Aug 86.
*           HPGEOM and HBHITS modified.          S.O'Neale    20 Aug 86.
*           HPGEOM and HBHITS modified.          D.Hochman    19 Aug 86.
*           HBGEOM and HBHITS re-written         C.Chang       9 Aug 86.
*           CDHITS CJ sector number modified.    S.O'Neale    23 Jul 86.
*           PE introduced from PEGOPAL macros    S.O'Neale     6 Jul 86.
*           developed by N.Wermes.
*           EB update for Geant 309 adapted for  S.O'Neale     5 Jul 86.
*           Geant 3.10 and Gopal 1.10.
*           Light guides introduced to geometry.
*           Digitizing added. Reference: presentation to
*           the offline software group, 26 May 86.  T.Kawamoto
+DECK,V109.
*
*   GOPAL is under constant (but slow) development.
*   Work inhand but not completed when this version was released
*   includes:    Re-writing HB geometry          C.Y.Chang
*                GMAIL for terminal I/O.         S.O'Neale
*                Zebra Documentation framework.  S.O'Neale
*                PE  Presampler endcap.          S.O'Neale
*                Update of CERN install and
*                example run files.              S.O'Neale
*
*                    =================================
*           Add DECKS for the endcap presampler. S.O'Neale    23 May 86.
*           Insert program structure information S.O'Neale    19 May 86.
*           for use by DZDOC.
*           Rename Forward Detector as 'FD'.     S.O'Neale    19 May 86.
*           GIPLAN YC argument set to single     R.Brun       13 May 86.
*           precision.
*           Unused CDC ONLY SORTZV calls cleaned S.O'Neale    12 May 86.
*           Routine headers added for DZDOC.     S.O'Neale     2 May 86.
*           HISTORY Patch added                  S.O'Neale    29 Apr 86.
*           added, HISTORY patch added.
*           GEOMetry data cards                  M.Hansroul   23 Apr 86.
*           Corrections to Z chamber digits      B.Lorazo     26 Mar 86.
*           Re-order code to calculate charge    V.Winterer   22 Mar 86.
*           integrals in CJDIGI.
*           Correcting fortran errors in CZDIGI  S.O'Neale    14 Feb 86.
*           CZGEOM and CZDIGI updated.           B.Lorazo     10 Feb 86.
*           EEQUAD updated for EE Geometry       G.N.Patrick  28 Feb 86.
*           N.B. need to change EEGEOM
*           Graphics display of hits             S.W.O'Neale  10 Feb 86.
*           GOKING: electrons below 10 Mev are   S.W.O'Neale   8 Feb 86.
*           not kept on the permanent stack. GSKING replaces
*           GSSTAK so that TOF information is maintained.
*           New EEDIGI and STMIN = 0.03 for 74.  C.P.Ward      4 Feb 86.
*           Correct fortran violations found     S.O'Neale    29 Jan 86.
*           on Apollo and Vax compilers (order of statements)
*           Lead Glass Barrel parameterisation.  A.Sato       27 Jan 86.
*           KIne routines check default values.  S.W.O'Neale  27 Jan 86.
*           GSLUND and other options are now in  S.W.O'Neale  26 Jan 86.
*           GEANT 3.10.  LUND commons may be overriden from the cradle.
*           Common block definitions changed in  S.W.O'Neale  26 Jan 86.
*           the main routine (BATCH,MAIN) for GEANT 3.10
*           Update PB documentation.             S.W.O'Neale  21 Jan 86.
*           Debugging HBDIGI code.               S.W.O'Neale  20 Jan 86.
*           Changes to HP hits and digits.       D.Hochman    19 Jan 86.
*           Partial implementation of MEDIGI     S.W.O'Neale  18 Jan 86.
*           BIGWS working space put into digits  S.W.O'Neale  13 Jan 86.
*           routines. (Geant WS is too small).
*           Gopal runs with ZEBRA 3.40 (MBDIGI converted)
*           HP digi working space reduced.       D.Hochman    13 Jan 86.
*           Introduce MB digitising              R.Barlow      8 Jan 86.
*           Introduce ME digitising              P.Hattersley  8 Jan 86.
*           Introduce new HB digitising          C.Chang       8 Dec 85.
*           CDHITS modified to keep Y co-ord     A.McPherson   2 Dec 85.
*           positive when calling GIPLAN.
*           Vertex detector with stereo cells    A.McPherson   7 Nov 85.
*
*                    GOPAL version 1.08 (October 1985)
*                    =================================
*
*       This version REQUIRES the corrections in the GEANT3 BUGS
*                      correction file of 13/08/85
*
*
*           Add GOPALDOC Patch              J.J.Dumont    10 Oct  85.
*           Add KINE data card options.     S.O'Neale      8 Oct  85.
*           GWORK used for EE digits.       S.O'Neale      7 Oct  85.
*           Add INSTALL and EXAMPLES Patches.
*           DOCUMENT Patch added for CZ.    B.Lorazo      24 Sep  85.
*           Update ME geometry and hits.    P.Hattersley  24 Sep  85.
*           Use GWORK in HB,HE,HP digits    S.O'Neale     14 Sep  85.
*           routines, suggest re-design of HPDIGI (needs 1Mbyte).
*           Modify HP code for Gopal108     S.O'Neale     14 Sep  85.
*           Update HP code                  D.Hochman     14 Sep  85.
*           General debugging               S.O'Neale     13 Sep  85.
*           HE Rotation matrix 9 has co-planar axes
*           GCKINE removed from PBDIGI to avoid over-writes.
*           All positions are either 'ONLY' or 'MANY'.
*           Update Beam Pipe geometry       P.Hobson      12 Sep  85.
*           EE Digitisation code            P.Ward         9 Sep  85.
*           JETSET61 selection for new Lund S.W.O'Neale    9 Sep  85.
*           Some media corrections.
*           Reduce EB hit scale factors     A.Possoz       2 Sep  85.
*           Add Zebra and GKS selections.   S.W.O'Neale   22 Aug  85.
*           Organise decks into PATCHes     S.W.O'Neale   20 Aug  85.
*           GOCDES,BATCH,OBASE,OGEOM,OHITS,
*           ODIGI,GUFLDFUL,GUFLDMEA,NOGENLIB,OLDGOPAL.
*           Protect TOF digits from hits of zero momentum
*           [] i.e. below hit resolution of 10 Mev.
*           Use of character variables for  S.W.O'Neale   19 Aug  85.
*           the names of hits and digits introduced.
*           GSLUND and GFLUND added to store and fetch the
*           the variables of the LUND common /LUJETS/.
*           FAST or FULL may be given on    J.J.Dumont    19 Aug  85.
*           the VIEW card (select complexity)
*           Add user flags to /GOFLAG/.     S.W.O'Neale   18 Aug  85.
*           KIUSER called for KINE 4, for private routines.
*           Maximum number of steps with no hit or change of
*           medium, NSTEPM, added to GUSTEP. DBUGSTEP may be
*           selected to assist in tracing errors and anomalies.
*           DBUGMEMO checks the data structure at a number of points.
*           Select user debug code via Patchy
*           USE select PRNTuser and DBUGuser.
*           Move all GSTMED calls to GEOPAL.
*           Avoid user coding if a GWORK call fails.
*           Mark [] changes made pending communication
*           with the authors of the code.
*           Rename TOF and PSAM to TB and   A.Possoz &    12 Aug  85.
*           PB and minor reorganisations.   S.W.O'Neale
*           Correct Fortran violations and  S.W.O'Neale   19 July 85.
*           general debugging. Routines
*           modified CDHITS,FHITS,FSCDIG,FTCDIG,
*           GETWIP,TSHITS.
*           Central detector update GECJ -  J.J.Dumont    12 July 85.
*           GECZ,CDHITS,CJDIGI...CZDIGI.    & W.Gebel
*           Update Pre-sampler              A.Possoz      12 July 85.
*           Forward detector V203           F.Bullock      9 July 85.
*           Faster magnetic field routine   F.Bullock      7 July 85.
*           Remove user analysis code       S.O'Neale      6 July 85.
*           Update coil                     A.Possoz      30 June 85.
*           Update Pre-sampler              A.Possoz      21 June 85.
*           New beam pipe routine GEBPIP -  P.Hobson      18 June 85.
*           NOGENLIB Patch added with fortran versions    18 June 85.
*           of Cern Genlib routines used by users code.
*           In general you are recommended to use the
*           GENLIB version which may be tuned for your computer.
*           CZ digitizing /0.0 protection   J.J.Dumont    18 June 85.
*           EB inner radius set to 245.0 -  S.O'Neale []  17 June 85.
*           Hadron Barrel & Endcap HB HE -  A.M.Rossi     14 June 85.
*           updated (Geom,Digi,Analysis)    & P.Zanarini
*           ME chambers in new arrangement  P.Hattersley  13 June 85.
*           Central detector updated and -  J.J.Dumont    12 June 85.
*           CZ digitization added           & W.Gebel
*           Hadron poletip (HP) updated  -  D.Hochman,    11 June 85.
*           Time of Flight updated       -  J.Mallet,     10 June 85.
*           Coil,Presampler,TOF updated  -  A.Possoz,     10 May  85.
*           Hadron barrel and endcap (HB,HE) hits and digits updated.
*           Version 2.2 - April 1985 -  A.Rossi and P.Zanarini.
*           Foreward Detector Geometry, Hits and Digits updated.
*           F.Bullock (UCL) Mar 85.
*           Coil,time-of-flight and barrel presampler added  (CTP-)
*           (Geometry,Hits and Digits code) from A.Possoz in decks
*           GECTP,GECOIL,GEPSAM,GETOP,PHITS,PDIGI. (Use CTP- for
*           geometry and sets, PDIG for digit selection.)
*           Fdet medium number 61 changed to 69
*           Tracking step reduced in OPAL (To see FL in Fdet).
*           Magnetic field patches GUFLDFULl and GUFLDMEAn replace
*           GUFIELD.
*                    GOPAL version 1.07 (February 1985)
*                    ==================================
*
*           This version is released for distribution at the OPAL
*           plenary week of 11th February 1985.
*
*           The vertex detector, central detector and z chambers
*           have undergone some optimisation of the geometry code
*           and the tracking parameters.
*           The electromagnetic detectors EB EE and F have been
*           completely updated and make use of the calorimeter hit
*           technique to avoid keeping large amounts of data for
*           each track segment.
*           The hadronic barrel, endcap and poletip have been
*           completely updated.
*           Minor changes have been made to the muon system.
*
*           The HITS code for the EB EE F HB HE MB ME detectors
*           is now stable. The DIGI code should not be used.
*           Digitisation code is currently being developed by
*           the Hadronic Calorimetry working group.
*
*
*           Patchy use selection may now be employed to select
*           program options. The major options are :-
*
*            IBM,ERRREP.        use IBM extended error recovery.
*                               (essential if Gheisha is used)
*            GHEISHA.           use the Gheisha hadronic package.
*            FLUKA.             use the Fluka hadronic package.
*
*
*
*           The pam file contains the following patches.
*
*            GOCDES             Gopal sequences.
*            BATCH              Example main routine for batch use.
*            GOPAL              Main body of code.
*            GUFIELD            Magnetic field mapping.
*            GECTP              update to Gopal 105 for the coil,
*            GECTP0             TOF and Presample system (A.Possez)
*
*           The last three patches have not yet been incorporated
*           into the current body of GOPAL code, they are merely
*           made available for private use at this stage.
*
*                    Mods in 1.06 (NOVEMBER    1984)
*                    ================================
*
*    The purpose of this release is to make as much of the
*    detector as possible accessible to the Hadron Calorimetry
*    Milestone group in a short time scale.
*    It is released in order to 'catch a plane' to Maryland.
*
*    In hand at the moment are the pressure vessel flanges,
*    the support plates for the EE glass, the gamma catcher
*    and forward detector in general. There is code not yet
*    copied from tape from A.Possez for the Coil,ToF and
*    presampler
*
*    The pole tip (HP) has been moved (see GEECAP).
*
*    The DEFINITIVE 0.4 Tesla GUFLD parameterisation arrived
*    on 6 Dec at 18.07, it has been compiled but not tested at CERN.
*    It is available in the patch GUFIELD.
*
*
*    GEC    Geometry of the Central detector.
*    GECV   Geometry of the Vertex Chambers.
*    GECJ   Geometry of the Jet Chamber.
*    GECZ   Geometry of the Zed Chambers.
*    GECP   Geometry of the Pressure Vessel.
*
*    GECZ   Geometry of the Z chambers.
*    GEEB   Geometry of the Electromagnetic Barrel.
*    GEEE   Geometry of the Electromagnetic Endcap.
*    GEHB   Geometry of the Hadron Barrel.
*    GEHE   Geometry of the Hadron Endcap.
*    HPGEOM Geometry of the Hadron Pole tip.
*
*    EBHITS Hits for the Electromagnetic Barrel.
*    EEHITS Hits for the Electromagnetic Endcap.
*
*    HBHITS Hits for the Hadron Barrel.
*    HEHITS Hits for the Hadron Endcap.
*
*    HPHITS Hits for the Hadron Pole tip.
*
*    HPDIGI Digitization routine for the Hadron Pole tip.
*           <N.B. Digits are not stored in the data structure >
*           <     See inline comments for analysis suggestions>
*
*
*
*    GFISID added to fetch ISET,IDET given IUSET,IUDET.
*    GOKING energy cut corrected to use Kinetic Energy
*    GUDIGI re-written, THITS removed.
*
*    The possibility to select graphics options when compiling
*    the library or at run time has been started. A flag from the
*    interactive version (to initialise graphics routines) is
*    required  (this is not currently available). If the BATCH patch
*    and PIGS are (USE) selected then UGINIT calls TVCAP(-3)
*    (write only to capture file).
*
*
*
*                    Mods in 1.05 (October 1st 1984)
*                    ================================
*
*               Adapted to run with GEANT305
*               New routine GUDIGI (called by GEANT)
*               calling CJPDIG (digitisation of the JETC)
*               Many corrections in the Geometry and Drawing
*               Detector set HCAL replaced by two sets HE,HB
*               New GEME and MEHITS
*               New GEHPOL, with associated changes in GEECAP
*               and GEBARL
*
*               New Patchy sequence /GOFLAG/IUDIGI,IUHITS,IUTRAK
*               New GOPAL specific data cards TRAK,HITS and DIGI
*               By default IUTRAK=1 (Tracking is performed)
*                          IUHITS=1 (Hits are processed and tracking)
*                          IUDIGI=1 (digitisation is performed)
*               To skip the Tracking/Hits step give data card HITS 0
*               To skip the digitisation step  give data card DIGI 0
*
*                   Mods in 1.04 (June 20 1984)
*                   ===========================
*
*               Adapted to run with GEANT304
*               New GEANT routine GSMIXT used for mixtures
*               New PATCH,GCDES
*               Use new GEANT data cards system
*               COMMON/GOPLOT/ obsolete  (use /GCLIST/)
*               Ne replaced by Ar in CDET
*               New versions of GEHCAL/GEHCAP, renamed GEHB/GEHE
*               Z chamber geometry now described in GEZCHA; GECDET
*               and CDHITS modified accordingly
*               New versions of GEECAL and GEMB
*               ECAL and PSAM dimensions modified
*
*                   MODS IN 1.03 (March 10 1984)
*                   ============================
*
*               ADAPTED TO RUN WITH GEANT303
*               NEW DEFINITION OF VERT USING ROUTINE GEVERT. GECDET AND
*               CDHITS CHANGED ACCORDINGLY.
*               BUG CORRECTED IN DEFINITION OF MEDIUM 4.
*               NEW MATERIALS ; 20 = ALUMINUM MYLAR FOR VERT
*               MATERIALS 21 AND 22 (IRON SCINTILLATOR AND LEAD GLASS)
*               REDEFINED USING ROUTINE GHMIX (EFFECTIVE ATOMIC WEIGHT
*               FOR A MIXTURE) AND FUNCTION GHSTDAL ( HADRONIC
*               INTERACTION LENGTH ).
*               The volume BTUB is now in BARL and not CDET
*               That was a big bug and affects the routines
*               GEBARL,GECDET
*               FIELD CHANGED FROM 5. TO 4. KGAUSS
*               CALL GSDVN2 INSTEAD OF GSDIV IN GECDET.
*               New geometry routines for HCAP, HCAL, MUON(MB), OCDE.
*               New hits routine for MB (MBHITS), and associated changes
*               in GUSTEP.
*
*          MODS IN 1.02
*
*          GOPAL ADAPTED TO RUN WITH GEANT302
*          CHANGES IN THE GEOMETRY DEFINITION OF ECAP AND ECAL
*          PARAMETERS FOR LEAD GLASS HAVE BEEN REDEFINED
*          NEW ROUTINES THITS/CDHITS TO COMPUTE HITS
*          IN THE CENTRAL DETECTOR
*          THE PATCH,INTER HAS BEEN REMOVED (IN GEANT NOW)
*
*          MODS IN 1.01
*
*       MATERIAL 5 DEFINITION ADDED (BERILIUM)
*       GSTMED PARAMETERS OPTIMISED IN GEOPAL
*       MODS IN GUSTEP FOR CALORIMETRY
*       NEW USER ROUTINES UINIT,UOUT,ULAST
*       TUNING OF NWPA,NWSA FOR ALL DETECTORS
*       PARAMETERS TO GOKING NOW TRANSFERRED VIA COMMON/GCKING/
*       MODS FOR GRAPHICS IN MAIN,GUTREV,UGLAST
*
+PATCH,GOCDES.
+DECK,CAFILE.
+KEEP,CAFILE.
      CHARACTER   CHFILE*(*)
      PARAMETER   (CHFILE = 'CJMC')
+SELF,IF=DOC.
+SEQ,CAFILE.
*      Character constant, calicration top level directory name for RZ
*
*            CHFILE : character paramater with name of top directory
*
+DECK,CJACTP.
+KEEP,CJACTP.
      INTEGER         ISECT    , ICELL
      REAL            VDRIF    , VDMEAN
     +,               SROTAN   , CROTAN
     +,               SMROTA   , CMROTA
     +,               SCORLO   , CCORLO
     +,               SMEALO   , CMEALO
     +,               WLEFF
      COMMON /CJACTP/ ISECT    , ICELL
     +,               VDRIF(2) , VDMEAN
     +,               SROTAN   , CROTAN
     +,               SMROTA   , CMROTA
     +,               SCORLO(2), CCORLO(2)
     +,               SMEALO   , CMEALO
     +,               WLEFF
+SELF,IF=DOC.
+SEQ,CJACTP.
*
*        actual variables often referenced but not easy accessible
*        ( especially to avoid very long argument lists on CALL
*          statements ! )
*
*        ISECT  : Current sector number
*        ICELL  : Current cell number
*        VDRIF  : array with drift velocities on right (2) and left (1)
*                 hand side of anode plane [cm/nsec]
*        VDMEAN : mean value of the two drift velocities [cm/nsec]
*        SROTAN : sine of default rotation angle to lorentz inclined
*                 drift cell reference frame
*        CROTAN : dito the cosine
*        SMROTA : as SROTAN but mean lorentz angle xMEALO
*        CMROTA : dito the cosine
*        SCORLO : array with sines of correction angles for right (1)
*                 and left (2) side of anode plane wrt to the defaults
*                 ( xROTAN ) above.
*        CCORLO : dito the cosines
*        SMEALO : sine of mean lorentz angle in vicinity of sense wire
*        CMEALO : dito cosine of this angle
*        WLEFF  : effective wire length
+SELF.
+DECK,CJCMC.
+KEEP,CJCMC.
      INTEGER     LESAGG     , LGSAGG     , LABOW      , LWIRD
     +,           LJRS       , LCTORS     , LALOR      , LVDRIF
      PARAMETER ( LESAGG =  1, LGSAGG =  2, LABOW  =  3, LWIRD  =  4
     +,           LJRS   =  5, LCTORS =  6, LALOR  =  7, LVDRIF =  8 )
C
      INTEGER     LT0TRG     , LT0ROU     , LT0REL     , LBFD
     +,           LPTOF      , LSPRO      , LNAEF      , LNCEF
     +,           LCCLK
      PARAMETER ( LT0TRG =  1, LT0ROU =  2, LT0REL =  3, LBFD  =  4
     +,           LPTOF  =  5, LSPRO  =  6, LNAEF  =  7, LNCEF =  8
     +,           LCCLK  = 10 )
C
      INTEGER     LGAIN      , LWEFFL     , LWBOTL     , LTRAD
     +,           LATTCH     , LPEDS
      PARAMETER ( LGAIN  =  1, LWEFFL =  2, LWBOTL =  3, LTRAD =  4
     +,           LATTCH =  5, LPEDS  =  6 )
C
      INTEGER          ICJGEF    , ICJTEF    , ICJQEF
      LOGICAL           CJGEF    ,  CJTEF    ,  CJQEF
     +,                 CJCCAL   ,  CJLASR
      COMMON /CJCMC/   ICJGEF(15), ICJTEF(15), ICJQEF(15)
     +,                 CJGEF(15),  CJTEF(15),  CJQEF(15)
     +,                 CJCCAL   ,  CJLASR
+SELF,IF=DOC.
+SEQ,CJCMC.
*
*        variables for special CJ Calibration-MC data cards
*
*        LESAGG : position of electrostat. sagging-flag in Cal.-MC array
*        LGSAGG : position of gravitational sagg.-flag in Cal.-MC array
*        LABOW  : position of anode bowing-flag in Cal.-MC array
*        LWIRD  : position of wire displacement-flag in Cal.-MC array
*        LJRS   : position of JRS-flag in Cal.-MC selection array
*        LCTORS : position of cone torsion-flag in Cal.-MC array
*        LALOR  : position of lorentz angle-flag in Cal.-MC array
*        LVDRIF : position of drift velocity-flag in Cal.-MC array
*
*        LT0TRG : position of T0trig-flag in Cal.-MC selection array
*        LT0ROU : position of T0readout-flag in Cal.-MC selection array
*        LT0REL : position of T0relX-flag in Cal.-MC selection array
*        LBFD   : position of barrel field degrader-flag in array
*        LPTOF  : position of particle ToF-flag in selection array
*        LSPRO  : position of signal propagation-flag in selection array
*        LNAEF  : position of near anode effects-flag in selection array
*        LNCEF  : position of near cathode effects-flag in array
*
*        LGAIN  : position of gain effects-flag in Cal.-MC array
*        LWEFFL : position of eff. wire length-flag in Cal.-MC array
*        LWBOTL : position of wine bottle-flag in Cal.-MC array
*        LTRAD  : position of track angle dependence-flag in array
*        LATTCH : position of attachment-flag in Cal.-MC selection array
*        LATTCH : position of pedestal error-flag in selection array
*
*        ICJGEF : parameters of data card CJGEff ( geom.  effects )
*        ICJTEF : parameters of data card CJTEff ( time   effects )
*        ICJQEF : parameters of data card CJQEff ( charge effects )
*         CJGEF : flags that select an effect for Cal.-MC ( geom.  )
*         CJTEF : flags that select an effect for Cal.-MC ( time   )
*         CJQEF : flags that select an effect for Cal.-MC ( charge )
*
*        CJCCAL : flag that selects creation of the calibration-DS
*        CJLASR : flag that selects special treatment for laser
+SELF.
+DECK,CJCODS. Sequence to define CJ constants data structure.
+KEEP,CJCODS. Sequence to define CJ constants data structure.
C
C--   CJCODS holds the bank I-O descriptors of those constants banks
C--          which are defined by MZFORM during the program execution.
      COMMON / CJCODS / ITCJDP, ITROTM, ITVOLP, ITVOLU
C
      CHARACTER*4    NACJCO
      INTEGER        NLCJCO, NSCJCO, NDCJCO, ITCJCO, JBCJCO
      PARAMETER      ( NACJCO = 'CJCO' )
      PARAMETER      ( NLCJCO = 5, NSCJCO = 5, NDCJCO = 5 )
      PARAMETER      ( ITCJCO = 2 )
      PARAMETER      ( JBCJCO = 2 )
C
      CHARACTER*4    NACJGP
      INTEGER        NLCJGP, NSCJGP, NDCJGP, ITCJGP, JBCJGP
      PARAMETER      ( NACJGP = 'CJGP' )
      PARAMETER      ( NLCJGP = 2, NSCJGP = 2, NDCJGP = 2 )
      PARAMETER      ( ITCJGP = 2 )
      PARAMETER      ( JBCJGP = 1 )
C
      CHARACTER*4    NACJVD
      INTEGER        NLCJVD, NSCJVD, NDCJVD, ITCJVD, JBCJVD
      PARAMETER      ( NACJVD = 'CJVD' )
      PARAMETER      ( NLCJVD = 8, NSCJVD = 8, NDCJVD = 1 )
      PARAMETER      ( ITCJVD = 2 )
      PARAMETER      ( JBCJVD = 1 )
C
      CHARACTER*4    NAVOLU
      INTEGER        ITVOLU
      PARAMETER      ( NAVOLU = 'CJVO' )
C
      CHARACTER*4    NAVOLP
      INTEGER        NLVOLP, NSVOLP, NDVOLP, ITVOLP
      PARAMETER      ( NAVOLP = 'CJVP' )
      PARAMETER      ( NLVOLP = 0, NSVOLP = 0, NDVOLP = 5 )
C
      CHARACTER*4    NACJRM
      INTEGER        NLCJRM, NSCJRM, NDCJRM, ITCJRM, JBCJRM
      PARAMETER      ( NACJRM = 'CJRM' )
      PARAMETER      ( NLCJRM = 5, NSCJRM = 5, NDCJRM = 1 )
      PARAMETER      ( ITCJRM = 2 )
      PARAMETER      ( JBCJRM = 2 )
C
      CHARACTER*4    NAROTM
      INTEGER        NLROTM, NSROTM, NDROTM, ITROTM
      PARAMETER      ( NAROTM = 'CJRO' )
      PARAMETER      ( NLROTM = 0, NSROTM = 0, NDROTM = 8 )
C
      CHARACTER*4    NACJDP
      INTEGER        NLCJDP, NSCJDP, ITCJDP, JBCJDP
      PARAMETER      ( NACJDP = 'CJPD' )
      PARAMETER      ( NLCJDP = 1, NSCJDP = 1 )
      PARAMETER      ( JBCJDP = 2 )
C
      CHARACTER*4    NACJTE
      INTEGER        NLCJTE, NSCJTE, NDCJTE, ITCJTE, JBCJTE
      PARAMETER      ( NACJTE = 'CJDK' )
      PARAMETER      ( NLCJTE = 1, NSCJTE = 1, NDCJTE = 200 )
      PARAMETER      ( ITCJTE = 2 )
      PARAMETER      ( JBCJTE = 1 )
C
      CHARACTER*4    NACJSE
      INTEGER        NLCJSE, NSCJSE, NDCJSE, ITCJSE, JBCJSE
      PARAMETER      ( NACJSE = 'CJDD' )
      PARAMETER      ( NLCJSE = 0, NSCJSE = 0, NDCJSE = 600 )
** *  PARAMETER      ( ITCJSE = 3 )
      PARAMETER      ( JBCJSE = 1 )
C
      CHARACTER*4    NACJCP
      INTEGER        NLCJCP, NSCJCP, NDCJCP, ITCJCP, JBCJCP
      PARAMETER      ( NACJCP = 'CJCP' )
      PARAMETER      ( NLCJCP = 0, NSCJCP = 0, NDCJCP = 0 )
      PARAMETER      ( ITCJCP = 0 )
      PARAMETER      ( JBCJCP = 3 )
C
      CHARACTER*4    NACJHP
      INTEGER        NLCJHP, NSCJHP, NDCJHP, ITCJHP, JBCJHP
      PARAMETER      ( NACJHP = 'CJHP' )
      PARAMETER      ( NLCJHP = 0, NSCJHP = 0, NDCJHP = 0 )
      PARAMETER      ( ITCJHP = 0 )
      PARAMETER      ( JBCJHP = 4 )
C
      CHARACTER*4    NACJTP
      INTEGER        NLCJTP, NSCJTP, NDCJTP, ITCJTP, JBCJTP
      PARAMETER      ( NACJTP = 'CJTP' )
      PARAMETER      ( NLCJTP = 3, NSCJTP = 3, NDCJTP = 3 )
      PARAMETER      ( ITCJTP = 2 )
      PARAMETER      ( JBCJTP = 5 )
C
+SELF, IF = DOC.
+SEQ, CJCODS.
*     CJCODS holds the bank I-O descriptors of those constants banks
*            which are defined by MZFORM during the program execution.
*
*     The following constants are supposed to describe the
*     Jet Chamber constants data structures. This is but a
*     first proposal on how one might do it. It was implemented
*     to do a quick storing of the jet chamber geometry related
*     constants.
*
*     Definition of the jet chamber constants top bank.
*
*        NACJCO : Name of the bank.
*        NLCJCO : Number of links of the bank.
*        NSCJCO : Number of structural links of the bank.
*        NDCJCO : Number of data words of the bank.
*        ITCJCO : I-O descriptor of the bank.
*        JBCJCO : Position of the supporting link in the link area of
*                 the mother bank.
*
*     Definition of the jet chamber geometry constants top bank.
*
*        NACJGP : Name of the bank.
*        NLCJGP : Number of links of the bank.
*        NSCJGP : Number of structural links of the bank.
*        NDCJGP : Number of data words of the bank.
*        ITCJGP : I-O descriptor of the bank.
*        JBCJGP : Position of the supporting link in the link area of
*                 the mother bank.
*
*     Definition of the jet chamber volume parameters top bank.
*
*        NACJVD : Name of the bank.
*        NLCJVD : Number of links of the bank.
*        NSCJVD : Number of structural links of the bank.
*        NDCJVD : Number of data words of the bank.
*        ITCJVD : I-O descriptor of the bank.
*        JBCJVD : Position of the supporting link in the link area of
*                 the mother bank.
*
*     Definition of the jet chamber volume parameters bank.
*
*        NAVOLU : Name of the bank.
*        ITVOLU : I-O descriptor of the bank, to be defined at execu-
*                 tion time.
*        The number of structural/ reference links as well as the number
*        of data words of this bank must be defined at execution time.
*        The relative position of the supporting link in the link area
*        of the mother bank has to be defined at execution time.
*
*     Definition of the jet chamber volume position bank.
*
*        NAVOLP : Name of the bank.
*        NLVOLP : Number of links of the bank.
*        NSVOLP : Number of structural links of the bank.
*        NDVOLP : Number of data words of the bank.
*        ITVOLP : I-O descriptor of the bank, to be defined at execu-
*                 tion time.
*        The relative position of the supporting link in the link area
*        of the mother bank has to be defined at execution time.
*
*     Definition of the jet chamber rotation matrix top bank.
*
*        NACJRM : Name of the bank.
*        NLCJRM : Number of links of the bank.
*        NSCJRM : Number of structural links of the bank.
*        NDCJRM : Number of data words of the bank.
*        ITCJRM : I-O descriptor of the bank.
*        JBCJRM : Position of the supporting link in the link area of
*                 the mother bank.
*
*     Definition of the jet chamber rotation matrix banks.
*
*        NAROTM : Name of the bank.
*        NLROTM : Number of links of the bank.
*        NSROTM : Number of structural links of the bank.
*        NDROTM : Number of data words of the bank.
*        ITROTM : I-O descriptor of the bank, to be defined at execu-
*                 tion time.
*        The relative position of the supporting link in the link area
*        of the mother bank has to be defined at execution time.
*
*     Definition of the jet chamber geometry related constants bank
*     ( detector parameters ).
*
*        NACJDP : Name of the bank.
*        NLCJDP : Number of links of the bank.
*        NSCJDP : Number of structural links of the bank.
*        ITCJDP : I-O descriptor of the bank, to be defined at execu-
*                 tion time.
*        JBCJDP : Position of the supporting link in the link area of
*                 the mother bank.
*        The number of data words of this bank is defined at execution
*        time.
*
*     Definition of the jet chamber program setup and detector effect
*     parameters top bank.
*
*        NACJTE : Name of the bank.
*        NLCJTE : Number of links of the bank.
*        NSCJTE : Number of structural links of the bank.
*        NDCJTE : Number of data words of the bank.
*        ITCJTE : I-O descriptor of the bank.
*        JBCJTE : Position of the supporting link in the link area of
*                 the mother bank.
*
*        This bank contains the references to each set of parameters
*        in the daughter bank.
*
*     Definition of the jet chamber program setup and detector effect
*     parameters bank.
*
*        NACJSE : Name of the bank.
*        NLCJSE : Number of links of the bank.
*        NSCJSE : Number of structural links of the bank.
*        NDCJSE : Number of data words of the bank.
*        ITCJSE : I-O descriptor of the bank (set in CJDCBK).
*        JBCJSE : Position of the supporting link in the link area of
*                 the mother bank.
*
*     Definition of the jet chamber calibration parameters bank.
*     This bank may be used to store the parameters used by the
*     calibration programs.
*
*        NACJCP : Name of the bank.
*        NLCJCP : Number of links of the bank.
*        NSCJCP : Number of structural links of the bank.
*        NDCJCP : Number of data words of the bank.
*        ITCJCP : I-O descriptor of the bank.
*        JBCJCP : Position of the supporting link in the link area of
*                 the mother bank.
*
*     Definition of the jet chamber hit analysis parameters bank.
*     This bank may be used to store the parameters used by the
*     hit analysis programs.
*
*        NACJHP : Name of the bank.
*        NLCJHP : Number of links of the bank.
*        NSCJHP : Number of structural links of the bank.
*        NDCJHP : Number of data words of the bank.
*        ITCJHP : I-O descriptor of the bank.
*        JBCJHP : Position of the supporting link in the link area of
*                 the mother bank.
*
*     Definition of the jet chamber track finding parameters bank.
*     This bank may be used to store the parameters used by the
*     pattern recognition programs (e.g. segments finding, segments
*     merging and tracks merging).
*
*        NACJTP : Name of the bank.
*        NLCJTP : Number of links of the bank.
*        NSCJTP : Number of structural links of the bank.
*        NDCJTP : Number of data words of the bank.
*        ITCJTP : I-O descriptor of the bank.
*        JBCJTP : Position of the supporting link in the link area of
*                 the mother bank.
*
+SELF.
+DECK,CJDDAT.
+KEEP,CJDDAT.
      INTEGER         IHTSID   , ISTSID   , IUPLOW
      REAL            HITSID
      REAL            SLOREN   , CLOREN
      REAL            SINBET   , COSBET   , STHETA
C
      COMMON /CJDDAT/ IHTSID   , ISTSID   , IUPLOW, HITSID
     +,               SLOREN(2), CLOREN(2)
     +,               SINBET   , COSBET   , STHETA
+SELF,IF=DOC.
+SEQ,CJDDAT.
*
*     special COMMON with data that is in CJDRIT
*
*        IHTSID : side of hit wrt anode         ( 1=left,  2=right )
*        HITSID : dito but                       +1=left, -1=right
*        ISTSID : side of mech. wire staggering ( 1=left,  2=right )
*        IUPLOW : flags if hit is in upper (1) or lower (2) half of
*                 drift space if left of anode plane else vice versa
*        xLOREN : (co-)sine of corrected lorentz angle
*        COSBET : cosine of track angle beta
*        SINBET : dito sine
*        STHETA : sine( theta ) polar track angle
+SELF.
+DECK,CJDFLG. Sequence to define flag bits set by the simulation.
+KEEP,CJDFLG. Sequence to define flag bits set by the simulation.
      INTEGER     IFLDOH, IFLCOR, IFNOIS, IFLCIN, IFLINE
      INTEGER     IFLNOQ, IFSYRA, IFOFFM, IFLDOR, IBLR
      PARAMETER   ( IFLDOH =  1, IFLCOR =  2, IFNOIS =  3, IFLCIN =  4 )
      PARAMETER   ( IFLINE =  5, IFLNOQ =  6, IFSYRA =  7, IFOFFM =  8 )
      PARAMETER   ( IFLDOR =  9, IBLR   = 10 )
C
      INTEGER     IBSIGN, IBFIRS, IBLAST, IFRDDR
      INTEGER     IBDIRZ, IFMHPZ, IFMHMZ, IFOVSS
      INTEGER     IFOVHT
      PARAMETER   ( IBSIGN = 11, IBFIRS = 12, IBLAST = 13, IFRDDR = 14 )
      PARAMETER   ( IBDIRZ = 15, IFMHPZ = 16, IFMHMZ = 17, IFOVSS = 18 )
      PARAMETER   ( IFOVHT = 19 )
C
      INTEGER     IBLOST
      PARAMETER   ( IBLOST = 25 )
C
+SELF, IF = DOC.
+SEQ, CJDFLG.
*     Definitions of Flags ( Bits set in the DIGIT/ HIT flag word )
*     which are used by CJDIGI to keep control on each
*     digit and which are saved in the the cheat words flag bank.
*
*      1 IFLDOH : Flag value to identify double hit.
*      2 IFLCOR : Flag value to identify correlated noise.
*      3 IFNOIS : Flag value to identify uncorrelated noise.
*      4 IFLCIN : Flag value to identify hit not found due to hit
*                 analysis inefficiencies.
*      5 IFLINE : Flag value to identify global chamber inefficiencies.
*      6 IFLNOQ : Flag reserved for "digits" generating non
*                 sufficient charge.
*      7 IFSYRA : Flag to indicate that a digit is generated by
*                 synchroton radiation.
*      8 IFOFFM : Flag to indicate that a digit is generated by
*                 tracks from interactions of off momentum electrons.
*      9 IFLDOR : Flag to identify resolved double hits.
*     10 IBLR   : Bit IBLR set if hit right of anode ( negative y ).
*     11 IBSIGN : Bit IBSIGN set if track entering drift cell from
*                    top.
*     12 IBFIRS : Flag for first digit on track segment.
*     13 IBLAST : Flag for last digit on track segment.
*     14 IFRDDR : Flags whether the resolution is degraded by deltas.
*     15 IBDIRZ : This flag is set when the Z- component of the
*                 momentum in the drift cell is negative.
*     16 IFMHPZ : This flag is set for missing hit +z
*     17 IFMHMZ : This flag is set for missing hit -z
*     18 IFOVSS : This flag is set for overflow +Z (signal side)
*     19 IFOVHS : This flag is set for overflow -Z (high tension side)
*
*     25 IBLOST : Flag LOST digit.
*
+SELF.
+DECK,CJDILI. CJDIGI temporary link area.
+KEEP,CJDILI. CJDIGI temporary link area.
      INTEGER     MWSDIG
      INTEGER     LITRA, LNUMBV, LHITCJ, LRWDCJ, LCJDFL
      INTEGER     LCHAOS, LSORTI
      INTEGER     LCJDRF
      INTEGER     LHTCJ2
      INTEGER     LDIGEV, LCHEEV, LHITEV
      INTEGER     LDIGS,  LCHEAT, LDLOST, LHITS
      INTEGER     LWSTAD, LWDICO
      INTEGER     LWIRE,  LTIME,  LDIGZ,  LCHARG, LQUAL,  LPULS
      INTEGER     LTRAN,  LTRAS,  LDDRIF, LDFLAG
     1,           LPMOMX, LPMOMY, LPMOMZ, LXHIT,  LYHIT,  LZHIT
      INTEGER     MWIRE,  MTIME,  MDIGZ,  MCHARG
     1,           MTRAN,  MTRAS,  MDDRIF, MDFLAG
     2,           MPMOMX, MPMOMY, MPMOMZ, MXHIT,  MYHIT,  MZHIT
      INTEGER     LHITX,  LHITY,  LHITZ
      INTEGER     LCJDRL
C
      COMMON / CJDILI / MWSDIG(2)
     1,                    LITRA, LNUMBV, LHITCJ, LRWDCJ, LCJDFL
     2,                    LCHAOS, LSORTI
     3,                 LCJDRF
     4,                    LHTCJ2(3)
     5,                    LDIGEV, LCHEEV, LHITEV
     6,                    LDIGS,  LCHEAT, LDLOST, LHITS
     7,                    LWSTAD, LWDICO
     8,                    LWIRE,  LTIME,  LDIGZ,  LCHARG, LQUAL,  LPULS
     9,                    LTRAN,  LTRAS,  LDDRIF, LDFLAG
     +,                    LPMOMX, LPMOMY, LPMOMZ, LXHIT,  LYHIT,  LZHIT
     1,                    LHITX,  LHITY,  LHITZ
     2,                    MWIRE,  MTIME,  MDIGZ,  MCHARG
     3,                    MTRAN,  MTRAS,  MDDRIF, MDFLAG
     4,                    MPMOMX, MPMOMY, MPMOMZ, MXHIT,  MYHIT,  MZHIT
     5,                 LCJDRL
C
+SELF,IF=DOC.
+SEQ,CJDILI.
*        MWSDIG : Status word of link area.
*        LITRA  : Structural link supporting track number list.
*        LNUMBV : Structural link supporting volume number list.
*        LHITCJ : Structural link supporting hit list.
*        LRWDCJ : Structural link supporting raw digits list.
*        LCJDFL : Structural link supporting flag list.
*        LCHAOS : Structural link supporting unsorted drift time list.
*        LSORTI : Structural link supporting sorting index list.
*
*        LCJDRF : First reference link.
*
*        LHTCJ2 : Three special links to three very special working
*                    banks (NEXT links from LHITCJ).
*        LDIGEV : Reference link containing address of the digits event
*                    bank.
*        LCHEEV : Reference link containing address of the cheat words
*                    event bank.
*        LHITEV : Reference link containing address of the hits
*                    event bank.
*        LDIGS  : Reference link containing address of the digits sector
*                    bank.
*        LCHEAT : Reference link containing address of the cheat word
*                    sector header bank.
*        LDLOST : Reference link containing address of the lost digits
*                    sector header bank.
*        LHITS  : Reference link containing address of the hits
*                    sector header bank.
*
*     Links to the digits banks are:
*
*        LWSTAD : Link to wire start address bank.
*        LWDICO : Link to wire digits count bank.
*        LWIRE  : Link to wire digits count bank.
*        LTIME  : Link to drift time bank.
*        LDIGZ  : Link to Z- coordinate bank.
*        LCHARG : Link to charge on wire bank.
*        LQUAL  : Link to quality flag bank.
*        LPULS  : Link to pulse shape reference bank.
*
*     Links to the cheat words banks are:
*
*        LDFLAG : Link to digits flag bank.
*        LTRAN  : Link to track number bank.
*        LTRAS  : Link to track segment number bank.
*        LDDRIF : Link to drift distance bank.
*        LPMOMx : Link to momentum component banks.
*        LxHIT  : Link to hit coordinates banks.
*
*     Links to the smeared hits banks.
*
*        LHITX  : Link to the X- coordinates.
*        LHITY  : Link to the Y- coordinates.
*        LHITZ  : Link to the Z- coordinates.
*
*     Links to the "lost" digits/ hits banks are:
*
*        MWIRE  : Link to wire number bank.
*        MTIME  : Link to drift time bank.
*        MDIGZ  : Link to Z- coordinate bank.
*        MCHARG : Link to charge on wire bank.
*        MTRAN  : Link to track number bank.
*        MTRAS  : Link to track segment number bank.
*        MDDRIF : Link to drift distance bank.
*        MDFLAG : Link to digits flag bank.
*        MPMOMx : Link to momentum component banks.
*        MxHIT  : Link to hit coordinates banks.
*
*        LCJDRL : Last reference link.
+SELF.
+DECK,CJDIWS.
+KEEP,CJDIWS.
      INTEGER     NTRMAX, NWPVCJ, NWPHCJ, NWPRWD
      INTEGER     NWBHCJ
      PARAMETER   ( NTRMAX =   1, NWPVCJ =  2 )
      PARAMETER   ( NWPHCJ =  10, NWPRWD = 13 )
      PARAMETER   ( NWBHCJ =   8)
      INTEGER     NDIDEF, NDIMAX, NDIINC
      PARAMETER   ( NDIDEF = 3000, NDIMAX = 10000, NDIINC = 1000 )
      INTEGER     NBKSIZ
      INTEGER     NDLOST
C
      COMMON / CJDIWS / NBKSIZ, NDLOST
C
+SELF,IF=DOC.
+SEQ,CJDIWS.
*     The sequence CJDIWS describes the structure of the jet chamber
*     data structures used by the working banks of the jet chamber
*     detector response simulation (digitisation and "hits"generation).
*
*     The working banks are used to retrieve the tracking information
*     (Geant HITS at present) and to stack the "raw" digits and
*     hits until they are processed. At the end the raw digit/ hit
*     information is stored in the jet chamber digits/ hits
*     data structures.
*
*     Definitions of the number of elements per entry in the working
*     banks:
*
*        NTRMAX describes the number words per Geant hit reserved for
*               the Geant track numbers.
*        NWPVCJ describes the number words per Geant hit reserved for
*               the Geant volume numbers.
*        NWPHCJ describes the number words per Geant hit reserved for
*               the Geant hits.
*        NWPRWD describes the number words reserved for each raw digit.
*        NWBHCJ is a special working bank element size, used for the
*               calibration simulation.
*
*     The following parameters define the range of the dynamic
*     memory in units of the above quantities.
*
*        NDIDEF is the default size of the working banks.
*        NDIMAX is the maximum size of the working banks.
*        NDIINC is the incrementing of the working banks, when more
*               space is reserved.
*
*     CJDIWS This common block contains the actual size of the
*            jet chamber digitization working bank system and
*            some counting information on the contents of the
*            working banks.
*
*        NBKSIZ is the size of of the jet chamber working banks
*               in units of "raw digits/ raw hits".
*        NDLOST : Number of raw digits discarded during digitisation.
*
+SELF.
+DECK,CJDPAR.    Global geometry related constants.
+KEEP,CJDPAR.    Global geometry related constants.
      INTEGER     NSECCJ, NCELCJ
      PARAMETER   ( NSECCJ = 24, NCELCJ = 159 )
      CHARACTER*4 CNASET, CNADET, CNASEC
      INTEGER     NAMSET, NAMDET, NAMSEC, IDSET, IDDET,  IDASEC
      INTEGER     NSECT,  NWIRES
C
      REAL        ANGLOR, RADLOR, SINLOR, COSLOR
      REAL        RWZERO, DWIRES, XWZERO, DCELLX, CELRAD
      REAL        W0HLEN
      REAL        DCATHW, WHLCAT, RW0CAT
      REAL        AINC,   RADINC, TAINC
      REAL        STMMAX, STEMAX, STGMAX
      REAL        TICRAD
      REAL        APHI,   PHIHOP, TANHOP, CTGHOP, SINHOP, COSHOP
      REAL        SINSEC, COSSEC
      REAL        XWPINC, YWPINC, WIHLEN, YCAMIN , YCAMAX
      REAL        VDRIFT
      REAL        BFIELD, TSCALE, ZSCALE, ZOFSET, QSCALE
C
      COMMON / CJCDPA / CNASET, CNADET, CNASEC(NSECCJ)
      COMMON / CJDPAR / NAMSET, NAMDET, NAMSEC(NSECCJ), IDSET,  IDDET
     1,                 IDASEC(NSECCJ), NSECT,  NWIRES
     2,                 ANGLOR, RADLOR, COSLOR, SINLOR
     3,                 RWZERO, DWIRES, XWZERO, DCELLX, CELRAD, TICRAD
     4,                 W0HLEN
     5,                 DCATHW, WHLCAT, RW0CAT
     6,                 AINC,   RADINC, TAINC
     7,                 APHI,   PHIHOP, TANHOP, CTGHOP, SINHOP, COSHOP
     8,                 SINSEC(2, NSECCJ), COSSEC(2, NSECCJ)
     9,                 STMMAX, STEMAX, STGMAX
     +,                 VDRIFT
     1,                 BFIELD, TSCALE, ZSCALE, ZOFSET, QSCALE
     2,                 XWPINC(0:NCELCJ+1), YWPINC(0:NCELCJ+1)
     3,                 WIHLEN(0:NCELCJ+1)
     4,                 YCAMIN(0:NCELCJ+1), YCAMAX(0:NCELCJ+1)
C
+SELF, IF = DOC.
+SEQ, CJDPAR.
*     Because a mixture of character strings and other variable
*     type is not allowed in standard FORTRAN 77, the sequence
*     CJDPAR contains the following two COMMON blocks:
*
*     CJCDPA to hold the geometry related character strings
*
*     and
*
*     CJDPAR to hold geometry related variables of non- character
*            data type.
*
*     WARNING : These common blocks MUST NOT be overwritten in any
*               case. It contains essential information for all
*               stages of the jet chamber simulation.
*               The results will be unpredictable if the global
*               variables in these common block are undefined.
*
*        NSECCJ : Number of sectors in the jet chamber.
*        NCELCJ : Number of drift cells in a jet chamber sector.
*
*        CNASET : Character string to hold the GEANT set name.
*        CNADET : Character string to hold the GEANT detector name.
*        CNASEC : Character strings to hold the GEANT detector aliases.
*        NAMSET : Hollerith string to hold the GEANT set name.
*        NAMDET : Hollerith string to hold the GEANT detector name.
*        NAMSET : Hollerith strings to hold the GEANT detector aliases.
*        IDSET  : Geant set identifier for jet chamber.
*        IDDET  : Geant detector identifier for jet chamber.
*        IDASEC : Geant detector alias identifiers for the sectors.
*
*        NSECT  : Number of sectors in jet chamber.
*        NWIRES : Number of drift cells in a sector.
*
*        ANGLOR : Nominal value of Lorentz angle in degrees.
*        RADLOR : Nominal value of Lorentz angle in radians.
*        COSLOR : Cosine of Lorentz angle.
*        SINLOR : Sine of Lorentz angle.
*
*        RWZERO : Nominal distance of wire Zero from origin of
*                 OPAL master reference frame in cm.
*        DWIRES : Nominal distance between two wires in cm.
*        XWZERO : Nominal x- position of wire Zero in Lorentz inclined
*                 detector reference frame (DRS) in cm.
*        DCELLX : Nominal distance in x between two wires in DRS in cm.
*        CELRAD : Half width of a drift cell in units of cm.
*        TICRAD : Half width of a drift cell in units of nanoseconds.
*
*        W0HLEN : Half length of wire Zero in cm.
*
*        DCATHW : Distance between cathode wires.
*        WHLCAT : Half length of cathode wire zero.
*        RW0CAT : Radial position of cathode wire zero.
*
*        AINC   : Inclination angle of the cones in degrees.
*        RADINC : Inclination angle of the cones in radians.
*        TAINC  : Tangent of the inclination angle of the cones.
*
*        APHI   : Half opening angle of a sector in degrees.
*        PHIHOP : Half opening angle of a sector in radians.
*        TANHOP : Tangent(PHIHOP).
*        CTGHOP : Cotangent(PHIHOP).
*        SINHOP : Sine(PHIHOP).
*        COSHOP : Cosine(PHIHOP).
*        SINSEC : SINSEC and COSSEC describe the rotation matrices
*        COSSEC      for transformations to the local coordinate
*                    frames of a sector (XXXSEC(2, ISECT)) and a
*                    drift cell (XXXSEC(1, ISECT), ISECT is the
*                    sector number).
*
*     Remark: For simplicity reasons the following arrays contain
*             the values for the (non- existing) drift cells 0
*             and 160 as well.
*
*        XWPINC contains the X- coordinates of the drift cell center
*               in the Lorentz inclined reference frame.
*        YWPINC contains the Y- coordinates of the drift cell center
*               in the Lorentz inclined reference frame.
*
*        WIHLEN contains the half length of all wires.
*
*        YCAMIN contains the Y- coordinates of the lower drift cell
*               boundary in the Lorentz inclined reference frame.
*
*        YCAMAX contains the Y- coordinates of the upper drift cell
*               boundary in the Lorentz inclined reference frame.
*
*     The following constants are not purely geometrically. For
*     reasons of simplicity they are stored here as well.
*
*        STMMAX : Mechanical staggering.
*        STEMAX : Maximum electrostatic sagging.
*        STGMAX : Maximum gravitational sagging.
*
*        VDRIFT : Nominal drift velocity.
*
*        BFIELD : Nominal value of the magnetic field in the jet
*                 chamber.
*
*        TSCALE : Scale used to store the drift time after the
*                 digitization. Differing from a previous announcement,
*                 this constant will be kept in the future.
*        ZSCALE : Scale used to store the Z- coordinate after the
*                 digitization.
*        ZSCALE : Offset used to store the Z- coordinate after the
*                 digitization.
*        QSCALE : Scale used to store the charge after the
*                 digitization.
*
*
+SELF.
+DECK,CJDXPAR.
+KEEP,CJDXPAR.
      INTEGER        NDXPAR
      PARAMETER     (NDXPAR=10)
*
      REAL           DXPAR
*
      COMMON  /CJDX/ DXPAR(NDXPAR)
*
+SELF,IF=DOC.
+SEQ,CJDXPAR.
*
*        dE/dx parameters for CJDEDX
*
*        DXPAR(1) : XI      =>
*        DXPAR(2) : AKAPPA  => Sternheimer-Peierls parameters
*        DXPAR(3) : XA      => with density effect
*        DXPAR(4) : AA      =>
*        DXPAR(5) : PRES    pressure (bars)
*        DXPAR(6) : PFAC    momentum scaling factor
*        DXPAR(7) : EXPB    exponential factor for 1/beta**expb
*
+DECK,CJEFCT.
+KEEP,CJEFCT.
      INTEGER          ISLCRL
      REAL                     PCUT
      REAL             CORPB1
      REAL             S1, S2, S3 ,S4, PDRDEG, SDRFAC
      REAL             SIGZ1,  SZ2FAC, PERZ2
      REAL             SIGPHI, SIGTHE
      LOGICAL          LSLRDH
      INTEGER          ISLEDH
      REAL                     EDHR00, EDHR08
      REAL             SGCHAR
      REAL             PRONOF
      INTEGER          NSYRAV
      REAL             SIGRPH, RESFAC, SIGZAV
      REAL             EHIT, ETRACK
      INTEGER          MSCAT
      REAL             SCATVA
      REAL             DPTPT2
      REAL             SYSFAC
C
      COMMON /CJEFCT/  ISLCRL, PCUT,
     1                 CORPB1,
     2                 S1, S2, S3, S4, PDRDEG, SDRFAC,
     3                 SIGZ1,  SZ2FAC, PERZ2,
     4                 SIGPHI, SIGTHE,
     5                 LSLRDH,
     6                 ISLEDH, EDHR00, EDHR08,
     7                 SGCHAR,
     8                 PRONOF,
     9                 NSYRAV,
     A                 SIGRPH, RESFAC, SIGZAV,
     B                 EHIT, ETRACK,
     C                 MSCAT, SCATVA,
     E                 DPTPT2,
     F                 SYSFAC
C
+SELF, IF = DOC.
+SEQ, CJEFCT.
*     Common  which is filled by the data cards
*     for detector effects.
*
*     Data card  CJCURL  for treatment of curling tracks with
*                        momentum p < PCUT (GEV)
*             parameters:  ISLCLR  := 0  No treatment at all.
*                                  := 1  Parametrization is used.
*                                  := 2  A detailed treatment is applied
*
*                          PCUT    := Pcut is the upper limit in GEV
*                                     for tracks,which should be treated
*                                     as specified by ISLCRL value.
*
*     Data card  CJCORN  simulates correlated noise.
*             parameters:  CORPB1  := Fraction of hits that are not
*                                     split.
*
*     Data card  CJRESDD defines resolution as a function of
*                        drift distance.
*             parameters:  S1      := Resolution of the wire in {cm}.
*                          S2      := Minimum resolution in {cm}.
*                          S3      := Resolution at 10 cm drift distance
*                                     in {cm}.
*                          S4      := Drift distance at the best
*                                     resolution in {cm}.
*                          PDRDEG  := Probability that the resolution
*                                     is degraded by delta rays.
*                          SDRFAC  := Multiplicative factor for
*                                     distortion.
*
*     Data card  CJRESZ  defines the z-resolution as a fraction of
*                        the wirelength at the outermost wire, z=0
*                        and a  perpendicular crossing is assumed.
*             parameters:  SIGZ1   := fraction (first gaussian)
*                          SZ2FAC  := factor for second gaussian in
*                                     units of SIGZ1
*                          PERZ2   := fraction of hits in second
*                                     gaussian
*
*
*     Data card  CJSIGTA defines the factor for degrading the resolution
*
*             parameters:  SIGPHI  := Resolution at phi of 45 degrees.
*                          SIGTHE  := Resolution in theta (not impl).
*
*
*     Data card  CJR2PR  switches the degradation of space  resolution
*                        due to double hits on/off.
*             parameters:  LSLRDH  := True or false switch.
*
*
*     Data card  CJDOUB  defines  the degradation of space  resolution
*                        due to double hits on/off.
*             parameters:  ISLEDH  := 1 Step function is taken.
*                                  := 2 Efficiency function is taken.
*                          EDHR00  := 0 % efficiency {mm}
*                          EDHR08  :=80 % efficiency {mm}
*
*     Data card  CJDEDX  defines  the parametrization of the charges
*                        measured.
*             parameters:  SGCHAR  := Charge resolution {%}   .
*
*
*     Data card  CJHEFF  defines  the efficiency for hit finding
*
*             parameters:  PRONOF  := efficiency.
*
*
*     Data card  CJSYRA  defines the number of hits generated through
*                        radiation.
*             Parameters:  NSYRAF  := number of hits.
*
*     Data card  CJRESO  defines the resolution used for the smeared
*                        mode.    .
*             Parameters:  SIGRPH  := average sigma in r-phi {microns}.
*                          RESFAC  := resolution factor for hadrons
*                          SIGZAV  := Sigma z average. {cm}.
*
*     Data card  CJEFFI  defines the efficiency for hit and track
*                        finding (smeared mode).
*             Parameters:  EHIT    := efficiency for hit finding.
*                          ETRACK  := Efficiency for track finding.
*
*     Data card  CJMSCA  defines the multiple scattering usage
*                                (smeared mode).
*             Parameters:  MSCAT   := Switch for turning it on=1 (off=0)
*                          SCATVA  := Value in percent for multiple
*                                     scattering.
*
*     Data card  CJPTP2  Delta pt/(pt)**2
*                                (smeared mode).
*             Parameters:  DPTPT2  := Value in percent.
*
*     Data card  CJSYFA  defines systematic factors.
*                                (smeared mode).
*             Parameters:  SYSFAC  := Value
*
+SELF
+DECK,CJEFC2.
+KEEP,CJEFC2.
C--   This common block contains the parametrizations which had
C--   to be calculated from the data cards parameters.
C
      INTEGER          NCORNT
      PARAMETER      ( NCORNT = 10 )
C
      REAL             CORNTB
      REAL             SIG0,SIG1,SIG2,SCUT,SIG0PR,SIG1PR
      REAL             CHGSAT, DELTCG, DELCG2
      REAL             FACANG
      REAL             EDCM00, EDCM08, EDCM10,  DBSLOP, DBINTC
      REAL             SCELOS
      COMMON /CJEFC2/  CORNTB(NCORNT),
     1                 CHGSAT, DELTCG, DELCG2,
     2                 SIG0,SIG1,SIG2,SCUT,SIG0PR,SIG1PR,
     3                 FACANG,
     4                 EDCM00, EDCM08, EDCM10, DBSLOP, DBINTC,
     5                 SCELOS
C
+SELF, IF=DOC.
+SEQ,  CJEFC2.
*
*     Common CJEFC2 contains information directly needed in the
*     subroutines simulating the response of the jet chamber
*     They are based on the conditions set by the data cards
*     but are directly applicable to the calculations whereas
*     the data cards sometimes require parameters the user is
*     familiar with
*
*     CORNTB   = Probabilities for splitting one hit into n hits
*     SIG0     = Space resolution: constant  term s<sc
*     SIG1     = Space resolution: linear    term s<sc
*     SIG2     = Space resolution: quadratic term s<sc
*     SCUT     = Space resolution: driftdistance at which quad. into
*                                  linear dependence
*     SIG0PR   = Space resolution: constant  term s>sc
*     SIG1PR   = Space resolution: linear    term s>sc
*     CHGSAT   = Charge at which measuremnt is saturated
*     DELTCG   = Resolution of charge measurement
*     DELCG2   = Resolution of charge measurement (2. function).
*     FACANG   = Factor denoting the degradation of r-phi resolution
*                at an angle of 45 deg in phi.
*     EDCM00   = Distance of 0 % probablility for two particle sep.(cm)
*     EDCM08   = Distance of 80 % probablility for two particle sep.(cm)
*     EDCM10   = Distance of 100% probablility for two particle sep.(cm)
*     DBSLOP   = Slope in parametrization of double hit efficiency (cm)
*     DBINTC   = Intercept in the parametrization
*     SCELOS   = scale for energy loss to get the required resolution
*
*
+SELF.
+DECK,CJKONS.
+KEEP,CJKONS.
      REAL        PRES      , PRSCAL
     +,           CNTKEV
      PARAMETER ( PRES = 4.0, PRSCAL = 4.0/PRES
     +,           CNTKEV = 10.0/244.00*PRSCAL )
** * +,           CNTKEV = 10.0/212.20*PRSCAL )
      REAL        T0GLB1, T0GLB2, T0GLB3, SMT0G1, SMT0G2, SMT0G3
     +,           T0LIN1, T0LIN2, SMT0L1, SMT0L2
     +,           ST0REL, CRTJMP, ST0ROU
     +,           SRELGA, SGACOR, WBOTTL, SWBOTL
     +,           WIRDSP, SAGITH, SAGITS, TORSIO
     +,           XIJRS,  THEJRS, PHIJRS, VECJRS, ROTMAT
     +,           SIPROP
     +,           TRADCH, ATTACH, SDPATH, SATTAC
     +,           SMVDRI, VD    , AL
     +,           SMWLEN, SMESTG, VESTG,  SMMSTG, VMSTG,  SMGSAG, VGSAG
     +,           RCELLA, RNWEFF, DTANLN
     +,           A0,     A1,     A2,     A3
     +,           C0,     C1,     C2
     +,           DY1H,   DYLH,   DXAH
     +,           DY1S,   DYLS,   DXAS
     +,           SMPEDS    
     +,           CJTSMR
     +,           FMAPSP,FMAPSM
      COMMON  /CJKONS/
     +            T0GLB1(NCJSCT), T0GLB2(NCJSCT), T0GLB3(NCJSCT)
     +,           SMT0G1        , SMT0G2        , SMT0G3
     +,           T0LIN1(NCJSCT), T0LIN2(NCJSCT), SMT0L1        , SMT0L2
     +,           ST0REL        , CRTJMP        , ST0ROU
     +,           SRELGA        , SGACOR        , WBOTTL        , SWBOTL
     +,           WIRDSP        , SAGITH(NCJSCT), SAGITS(NCJSCT)
     +,           TORSIO        , XIJRS         , THEJRS        , PHIJRS
     +,           VECJRS(3)     , ROTMAT(10)    , SIPROP
     +,           TRADCH(6)     , ATTACH        , SDPATH        , SATTAC
     +,           SMVDRI        , VD            , AL
     +,           SMWLEN        , SMESTG        , VESTG
     +,           SMMSTG        , VMSTG         , SMGSAG        , VGSAG
     +,           RCELLA(4)     , RNWEFF        , DTANLN
     +,           A0(4)         , A1(4)         , A2(4)         , A3(4)
     +,           C0            , C1            , C2
     +,           DY1H(NCJSCT)  , DYLH(NCJSCT)  , DXAH(NCJSCT)
     +,           DY1S(NCJSCT)  , DYLS(NCJSCT)  , DXAS(NCJSCT)
     +,           SMPEDS        , CJTSMR
     +,           FMAPSP(NCJSCT), FMAPSM(NCJSCT)
+SELF,IF=DOC.
+SEQ,CJKONS.
*
*        some parameters of general interest
*
*        PRES   : pressure in bar
*        PRSCAL : pressure / 4 bar
*        CNTKEV : conversion factor to get keV/cm from counts
*                 ( see CERN-EP/87-97 tab. 1 )
*
*        variables for special CJ data cards
*
*        T0GLB1 : 24 global T0s                                   (nsec)
*        T0GLB2 : 24 T0fine                                       (nsec)
*        T0GLB3 : 24 spares                                       (nsec)
*        SMT0G1 : width of gaussian smearing of T0GLB1            (nsec)
*        SMT0G2 : width of gaussian smearing of T0GLB2            (nsec)
*        SMT0G3 : width of gaussian smearing of T0GLB3            (nsec)
*        T0LIN1 : 24 tlinear values                               (nsec)
*        T0LIN2 : 24 spare values                                 (nsec)
*        SMT0L1 : width of gaussian smearing of T0LIN1            (nsec)
*        SMT0L2 : width of gaussian smearing of T0LIN2            (nsec)
*        ST0REL : width of gaussian smearing of rel. wire t0      (nsec)
*        CRTJMP : probability of crate jumps by 10 nsec           (nsec)
*        ST0ROU : width of gaussian smearing of 10 nsec jump      (nsec)
*        SRELGA : width of gaussian smearing of rel. gains
*        SGACOR : width of gaussian smearing of wire to wire gains
*        WBOTTL : mean value of wine bottle effect
*        SWBOTL : width of gaussian smearing of wine bottle effect
*        WIRDSP : wire placement error                              (cm)
*        SAGITH : 24 sagitta values of anode combs H-side           (cm)
*        SAGITS : 24 sagitta values of anode combs S-side           (cm)
*        TORSIO : torsion of cones                              (radian)
*        XIJRS  : xi    angle  of Jetchamber Reference System   (radian)
*        THEJRS : theta angle  of Jetchamber Reference System   (radian)
*        PHIJRS : phi   angle  of Jetchamber Reference System   (radian)
*        VECJRS : shift vector of Jetchamber Reference System       (cm)
*                 ( XIJRS, THEJRS, PHIJRS and VECJRS are wrt to MRS )
*                 Note: the rotations are as follows :
*                       first  around z  -axis by angle XIJRS
*                       second around y' -axis by angle THEJRS
*                       third  around z''-axis by angle PHIJRS
*        ROTMAT : 3x3+1 rotation matrix JRS-->MRS (+flag notrivial rot)
*        SIPROP : signal propagation velocity                  (nsec/cm)
*        TRADCH : 6 values to describe track angle dependence of charge
*        ATTACH : attachment of gas
*        SDPATH : drift path length for which ATTACH is given       (cm)
*        SATTAC : width of gaussian smearing of attachment
*        SMVDRI : width of gaussian smearing of drift velocity (cm/nsec)
*        VD     : drift velocity                               (cm/nsec)
*        AL     : lorentz angle                                 (radian)
*        SMWLEN : width of gaussian smearing of eff. wire length    (cm)
*        SMESTG : width of gaussian smearing of elec. staggering    (cm)
*        VESTG  : value of elec. staggering                         (cm)
*        SMMSTG : width of gaussian smearing of mech. staggering    (cm)
*        VMSTG  : value of mech. staggering                         (cm)
*        SMGSAG : width of gaussian smearing of gravit. sagging     (cm)
*        VGSAG  : value of gravit. sagging                          (cm)
*        RCELLA : 4 radii of Drift Time Aberation (JADE-approx.)    (cm)
*        RNWEFF : circular region of near wire effects at anode     (cm)
*        DTANLN : spare for nonlinear contribution to DTA eff.
*        A0     : 4 values for nonlinearity near anode wire         (cm)
*        A1     : 4 values for nonlinearity near anode wire       (1/cm)
*        A2     : 4 values for nonlinearity near anode wire    (1/cm**2)
*        A3     : 4 values for nonlinearity near anode wire
*        C0     : size of near cathode wire effects            (nsec/cm)
*        C1     : region around cathode with near wire effects      (cm)
*        C2     : spare
*        DY1H   : y-shift of first wire  H-side                     (cm)
*        DYLH   : y-shift of last  wire  H-side                     (cm)
*        DXAH   : x-shift of all   wires H-side                     (cm)
*        DY1S   : y-shift of first wire  S-side                     (cm)
*        DYLS   : y-shift of last  wire  S-side                     (cm)
*        DXAS   : x-shift of all   wires S-side                     (cm)
*        SMPEDS : width of gaussian smearing of pedestals       (counts)
*        CJTSMR : width of gaussian smearing of track theta        (rad)
*        FMAPSx : scale factors for field map in each sector         (1)
*                 x=P,M for positive/negative phi angle
*
+DECK,CJLASR.
+KEEP,CJLASR.
      REAL               CHDMEA, CHDRMS
     +,                  PINTCO, PINTPA
     +,                  CUTTOC, CUTWEC
C
      COMMON / CJLASR /  CHDMEA, CHDRMS
     +,                  PINTCO, PINTPA
     +,                  CUTTOC, CUTWEC
+SELF,IF=DOC.
+SEQ,CJLASR.
*     COMMON to store data on charge distribution generated
*            by laser :
*
*        CHDMEA : mean value of charge distibution
*        CHDRMS : r.m.s value of charge distibution
*        these values are used to manipulate a Landau like
*        distribution function which fits the real charge distribution
*        quite good.
*
*        PINTCO : intensity of major laser beam ( second beam fade out
*                                                         completely )
*        PINTPA : intensity of major laser beam ( second beam fade out
*                                                         partially  )
*        CUTTOC : cut value for total ( sum ) charge    ( counts )
*        CUTWEC : cut value for charge at each wire end ( counts )
+SELF.
+DECK,CJRUNC.
+KEEP,CJRUNC.
C--   Common block for the jet chamber run control parameters.
C
      INTEGER     ISMALL
      PARAMETER   (ISMALL = -55553255)
      LOGICAL     LMRNDI, LMRNHI, LMRNSM, LMRNND
      LOGICAL     IFCHEA, IFSTLS
      LOGICAL     LBUTCD
      INTEGER     LEVPRT, MODE
      INTEGER     ICHLEV
      INTEGER     ITRDEP, IFREC, NPTMIN
      REAL        DEVXY, DEVZS, FRDUMM
C
      COMMON /CJRUNC/  LEVPRT, MODE,   LMRNDI, LMRNHI, LMRNSM, LMRNND
     1,                IFCHEA, IFSTLS, ICHLEV
     2,                IFREC,  ITRDEP, NPTMIN, DEVXY,  DEVZS,  FRDUMM
     3,                LBUTCD
C
+SELF, IF = DOC.
+SEQ, CJRUNC.
*
*     ISMALL is a small integer number.
*
*     Common CJRUNC contains the run and print conditions for
*       the CJ- processor run
*
*       LEVPRT :=  print level
*               =  0   no print output is created
*               =  1   the changed default parameters are printed
*                      only.
*               =  2   all parameters are printed out
*               =  3   all parameters and additional constants are
*                      printed out.
*
*        LMRNDI  = (TRUE/FALSE)   flag for digits to be calculated.
*        LMRNHI  = (TRUE/FALSE)   flag for hits to be calculated.
*        LMRNSM  = (TRUE/FALSE)   flag for smearing of kinematics .
*        LMRNND  = (TRUE/FALSE)   flag for no detector mode of run.
*
*        LBUTCD  if this flag is set, then the tracking is stopped
*                outside the central detector.
*
*        IFCHEA flags whether cheat words are to be stored.
*        IFSTLS flags whether 'lost' points are to be stored.
*        ICHLEV is an index for the level of detail of the cheat words.
*
*     Data card  CJFREC  used for the Fake pattern recognition.
*
*             parameters:  IFREC   := 1  switches fake pattern rec. on.
*                                  := 0   "        "      "         off.
*                          ITRDEP  := number of iteration steps.
*                          NPTMIN  := Minimal number of points required
*                                     for a track.
*                          DEVXY   := Cut on the maximal deviation of
*                                     points from fit in r-phi direction
*                          DEVXY   := Cut on the maximal deviation of
*                                     points from fit in r-phi direction
*                          FRDUMM  := not used now.
*
+SELF.
+DECK,CJPALI.
+KEEP,CJPALI.
C--   Link area for the jet chamber data packing procedures.
C
      INTEGER     MPALIS
      INTEGER     LSECT
      INTEGER     LPRFFI, LPRFLA
      INTEGER     LEVENT, LSHELP, LINKSH
C
      COMMON / CJPALI / MPALIS(2)
     1,                 LSECT
     2,              LPRFFI
     3,                LEVENT, LSHELP, LINKSH(20)
     4,              LPRFLA
C
+SELF, IF = DOC.
+SEQ,CJPALI.
*
*     This sequence is used by the jet chamber data packing procedures
*     as a link area.
*
*        MPALIS is the status word of the link area.
*
*        LSECT  is a structural link to temporarily hold the packed
*               sector data.
*
*        LPRFFI is the first reference link of the link area.
*
*        LEVENT is a copy of the actual jet chamber event link.
*        LSHELP is a copy of the actual jet chamber sector link.
*        LINKSH is an array to hold the actual sector dependant links.
*
*        LPRFLA is the last reference link of the link area.
*
+SELF.
+DECK,CJPACO. Global constants used by the (un)packing procedures.
+KEEP,CJPACO. Global constants used by the (un)packing procedures.
      INTEGER     NBMAX
      PARAMETER   ( NBMAX = 32 )
      INTEGER     NCELEM, NDELEM, NHELEM
      PARAMETER   ( NCELEM = 2, NDELEM = 4, NHELEM = 4 )
      INTEGER     NPERMX
      PARAMETER   ( NPERMX = 10 )
      REAL        HUNDEF
      PARAMETER   ( HUNDEF = -1.0E35 )
      INTEGER     LIMIT
      INTEGER     NBDIGI, NDPERR, OFDIGI, IFACHA, NTDIGI
      INTEGER     NBCHEA, NCPERR, NTCHEA
      INTEGER     NBHITS, NHPERR, NTHITS
      REAL        OFHITS, SCHITS
      INTEGER     CPNAME, DPNAME, HPNAME
C
      COMMON / CJPACO / LIMIT(NBMAX)
     1,        NBDIGI(NDELEM), NDPERR(NDELEM), OFDIGI(NDELEM)
     2,        IFACHA,                                         NTDIGI
     3,        NBCHEA(NCELEM), NCPERR(NCELEM),                 NTCHEA
     4,        NBHITS(NHELEM), NHPERR(NHELEM), OFHITS(NHELEM)
     5,        SCHITS(NHELEM),                                 NTHITS
     6,        CPNAME, DPNAME, HPNAME
C
+SELF, IF = DOC.
+SEQ, CJPACO.
*     The sequence CJPACO contains constants used by the packing and
*     unpacking procedures.
*
*        NBMAX  is the maximum number of bits per word.
*        NCELEM is number of cheat word parameters to be packed.
*        NDELEM is number of digit parameters to be packed.
*        NHELEM is number of hit parameters to be packed.
*        NPERMX is the maximum number of error messages per error.
*        HUNDEF is the value assigned to undefined hit elements.
*
*        LIMIT  is an array contining the upper limit of all bits
*               representations.
*        NBDIGI is an array describing the number of bits of
*               the digit elements which will be packed.
*        NDPERR is the number of error messages per digit element.
*        OFDIGI is the offset used to store a digit element.
*        IFACHA factor used for packing/ unpacking the charge.
*        NTDIGI is the total number of bits needed for a set of digit
*               parameters.
*
*        NBCHEA is an array describing the number of bits of
*               the cheat word elements which will be packed.
*        NCPERR is the number of error messages per cheat word element.
*        NTCHEA is the total number of bits needed for a set of cheat
*               word parameters.
*
*        NBHITS is an array describing the number of bits of
*               the hit elements which will be packed.
*        NHPERR is the number of error messages per hit element.
*        OFHITS is the offset used to store a hit element.
*        SCHITS is the scale used to store a hit element.
*        NTHITS is the total number of bits needed for a set of hit
*               parameters.
*
*        CPNAME is the name of the packed cheat words bank (Hollerith).
*        DPNAME is the name of the packed digits bank (Hollerith).
*        HPNAME is the name of the packed hits bank (Hollerith).
*
+SELF.
+SELF.
+SELF.      Pointer to datawords in CJSD and CJOC bank
+SELF.
+DECK,CJSEED.
+KEEP,CJSEED.
      INTEGER           ISEED1, ISEED2, ISAVE1, ISAVE2
      COMMON / CJSEED / ISEED1, ISEED2, ISAVE1, ISAVE2
+SELF,IF=DOC.
*******************************************************************
*     /CJSEED/  seed variables used to initialize random number
*               generator during setup of CJ calibration DS
*               and setting of calibration constants
*
*      ISEEDx : seed values      for random number generator (x=1,2)
*      ISAVEx : saved seed values of random number generator (x=1,2)
*******************************************************************
+SEQ,CJSEED.
+SELF.
+DECK,CJSTLI.
+KEEP,CJSTLI.
      INTEGER     LPOINT
      COMMON / CJSTLI / LPOINT
+DECK,CJSTWS.
+KEEP,CJSTWS.
      INTEGER     NWPPCJ
      PARAMETER   ( NWPPCJ = 8 )
      INTEGER     NPTDEF, NPTMAX, NPTINC
      PARAMETER   ( NPTDEF = 500, NPTMAX = 1000, NPTINC = 500 )
      INTEGER     NBKSIZ
C
      COMMON / CJSTWS / NBKSIZ
C
+SELF,IF=DOC.
+SEQ,CJSTWS.
*     Sequence to define the range of the dynamic memory used by the
*     CJSTEP/ CJHITS packages.
*
*        NWPPCJ : Defines the number of words per entry in the point
*                 list bank.
*        NPTDEF : Default size of the working banks.
*        NPTMAX : Maximum size of the working banks.
*        NPTINC : Increment size of the working banks.
*
*        NBKSIZ : Actual size of the working banks.
*
+SELF.
+DECK,CJTRKC.       Temporay link area for CJFREC.
+KEEP,CJTRKC.       Temporay link area for CJFREC.
C--   Status word.
      INTEGER     MFRLAS
C
C--   Event level links.
      INTEGER     LHITEV, LTRAEV, LCHETO, LCJCHT
C
C--   Track dependant links
      INTEGER     LCJTRK, LCJTLP, LCJTEP, LCJTFH, LCJTSN, LCJEHB
      INTEGER     LCJTF1, LCJRRP, LCJZSP
      INTEGER     LFRFRL, LFRLRL
C
C--   Track dependant help links.
      INTEGER     LCHTRK, LCHTLP, LCHTEP, LCHTFH, LCHTSN, LCHEHB
      INTEGER     LCHTF1, LCHRRP, LCHZSP
C
C--   CJ hits event banks links.
      INTEGER     LCJHTB, LCJHSB, LCJHSX, LCJHSY, LCJHSZ
C
C--   Link to bank containing Track status information.
C--   This bank is temporary booked in CJFREC only.
      INTEGER     LTRSTA
C
C--   Links to bank containing Track hit status information.
C--   These banks are temporary booked in CJFREC only.
      INTEGER     LTHSTA
C
      COMMON / CJTRKC / MFRLAS(2)
     1,                 LTHSTA, LTRSTA
     2,              LFRFRL
     3,                 LHITEV, LTRAEV, LCHETO, LCJCHT
     4,                 LCJTRK
     5,                 LCJTLP, LCJTEP, LCJTFH, LCJTSN, LCJEHB
     6,                 LCJTF1
     7,                 LCJRRP, LCJZSP
     8,                 LCHTRK
     9,                 LCHTLP, LCHTEP, LCHTFH, LCHTSN, LCHEHB
     +,                 LCHTF1
     1,                 LCHRRP, LCHZSP
     2,                 LCJHTB, LCJHSB, LCJHSX, LCJHSY, LCJHSZ
     3,              LFRLRL
C
C--   Status word possibly stored in track status information bank
C--
C--      NOTEPO      track has not enough points ( < IMIHNT )
C--      ISBADF      fit for this track is bad
      INTEGER     NOTEPO
      INTEGER     ISBADF
      PARAMETER   ( NOTEPO = 10 )
      PARAMETER   ( ISBADF = 20 )
C
C--   Status word possibly stored in track hit status information bank
C--
C--      NOTACC      hit is not accepted
      INTEGER     NOTACC
      PARAMETER   ( NOTACC = 100 )
C
C--       DEFHIT    is the default value for the sector coordinate banks
      REAL        DEFHIT
      PARAMETER ( DEFHIT = -1.0E35 )
C
C--      NUMCTR : Defines current number of 'good' tracks.
C--      ITRPOI : Is the track pointer.
      INTEGER     NUMCTR
      INTEGER     ITRPOI
C
      COMMON / CJSTA2 / NUMCTR, ITRPOI
C
+SELF, IF = DOC.
+SEQ, CJTRKC.
*
*     Link area for the fake reconstruction programs.
*
*        MFRLAS is the status word of the link area.
*
*        LFRFRL is the first reference link of the link area.
*        LFRLRL is the last reference link of the link area.
*
*     Event level links.
*
*        LHITEV : Jet chamber hits bank.
*        LTRAEV : Jet chamber tracks bank.
*        LCHETO : Jet chamber cheat words top bank.
*        LCJCHT : Jet chamber tracks cheat words bank.
*
*     Track bank links
*
*        LCJTRK : Link to CJ track bank                   ! LTRAEV
*        LCJTLP : Link to list of encoded hit pointers    ! LCJTRK
*        LCJTEP : Link to track endpoint information      ! LCJTRK
*        LCJTFH : Link to track fit header bank           ! LCJTRK
*        LCJTSN : Link to track segment number list       ! LCJTRK
*        LCJEHB : Link to track extrapolation header bank ! LCJTRK
*
*        LCJTF1 : Link to track fit information           ! LCJTFH
*        LCJRRP : Link to CJ residuals in r-phi projection! LCJTF1
*        LCJZSP : Link to CJ residuals in z-s projection  ! LCJTF1
*
*        Links to CJ top level hits event bank.
*
*        LCJHTB : Link to CJ top level hits event bank         ! LCJ
*        LCJHSB : Link to header bank for CJ hits in one sector! LCJHTB
*        LCJHSX : Link to x-coordinates in one sector          ! LCJHSB
*        LCJHSY : Link to y-coordinates in one sector          ! LCJHSB
*        LCJHSZ : Link to z-coordinates in one sector          ! LCJHSB
*
*        LTRSTA : Link to bank of track status information.
*        LTHSTA : Link to bank of hit status information.
*
+DECK,CVCDIM.
+KEEP,CVCDIM.
      INTEGER ICVIF, ICVCF, ICVST, ICVCP, ICVAGP, ICVSGP, ICVGAS
      INTEGER ICVG10, ICVAL, ICVPC, ICVWC
      PARAMETER ( ICVIF=41, ICVCF=42, ICVST=43, ICVCP=45, ICVAGP=48,
     + ICVSGP=49, ICVGAS=50, ICVG10=44, ICVAL=38, ICVPC=39, ICVWC=40 )
      INTEGER ICVTIF, ICVTCF, ICVTST, ICVTCP, ICVTAG, ICVTSG, ICVTGA
      INTEGER ICVTG1, ICVTAL, ICVTPC, ICVTWC
      PARAMETER ( ICVTIF=20, ICVTCF=22, ICVTST=21, ICVTCP=24,
     + ICVTAG=25, ICVTSG=18, ICVTGA=19, ICVTG1=23, ICVTAL=15,
     + ICVTPC=16, ICVTWC=17 )
      REAL DCVLI, DCVAI, DCVMLC, DCVMSC, DCVAC, DCVCFS, DCVKAS, DCVAS
      REAL DCVI, DCVC, DCVS, DCVG10, DCVALT, DCVPCB, DCVALP, DCVWCA
      REAL RADCVI, RADCVC, RADCVS, RADCVT, DCVZAT, DCVZWC
      PARAMETER ( DCVLI=0.0250, DCVAI=0.0050, DCVMLC=0.02, DCVMSC=0.01,
     + DCVAC=0.005, DCVCFS=0.15, DCVKAS=0.01, DCVAS=0.0025, DCVI=0.03,
     + DCVC=0.035, DCVS=0.1625, DCVG10=3.3, DCVALT=0.2, DCVPCB=31.0,
     + DCVALP=1.8, DCVWCA=1.0,
     + RADCVI=8.85, RADCVC=17.5, RADCVS=23.385, RADCVT=23.4 )
      PARAMETER ( DCVZAT=109.2, DCVZWC=89.1 )
      REAL CVRCAT, CVSCAT, CVRGRD, CVSGRA, CVSGRS
      PARAMETER ( CVRCAT=0.00625, CVSCAT=0.1, CVRGRD=0.01,
     + CVSGRA=0.5308, CVSGRS=0.5 )
      INTEGER NCVZIS, NCVPIS
      PARAMETER ( NCVZIS=10, NCVPIS=3*NCVZIS+3 )
+SELF,IF=DOC.
*
*--
*--      PARAMETER ( ICVIF=41, ICVCF=42, ICVST=43, ICVCP=45, ICVAGP=48,
*--     + ICVSGP=49, ICVGAS=50, ICVG10=44, ICVAL=38, ICVPC=39, ICVWC=40
*--      PARAMETER ( ICVTIF=20, ICVTCF=22, ICVTST=21, ICVTCP=24,
*--     + ICVTAG=25, ICVTSG=18, ICVTGA=19, ICVTG1=23, ICVTAL=15,
*--     + ICVTPC=16, ICVTWC=17 )
*--      PARAMETER ( DCVLI=0.0250, DCVAI=0.0050, DCVMLC=0.02, DCVMSC=0.0
*--     + DCVAC=0.005, DCVCFS=0.15, DCVKAS=0.01, DCVAS=0.0025, DCVI=0.03
*--     + DCVC=0.035, DCVS=0.1625, DCVG10=3.3, DCVALT=0.2, DCVPCB=31.0,
*--     + DCVALP=1.8, DCVWCA=1.0,
*--     + RADCVI=8.85, RADCVC=17.5, RADCVS=23.385, RADCVT=23.4 )
*--      PARAMETER ( DCVZAT=109.2, DCVZWC=89.1 )
*--      PARAMETER ( CVRCAT=0.00625, CVSCAT=0.1, CVRGRD=0.01,
*--     + CVSGRA=0.5308, CVSGRS=0.5 )
*--      PARAMETER ( NCVZIS=10, NCVPIS=3*NCVZIS+3 )
*--
*--          Meanings of PARAMETER defined constants.
*--
*--           GEANT Material Numbers.
*--           ICVIF  = Inner foil.
*--           ICVCF  = Centre foil.
*--           ICVST  = Support tube.
*--           ICVCP  = Cathode plane.
*--           ICVAGP = Axial guard plane.
*--           ICVSGP = Stereo guard plane.
*--           ICVGAS = CV gas.
*--           ICVG10 = End cap G10.
*--           ICVAL  = End cap Aluminium support tubes and plate.
*--           ICVPC  = End cap PC board volume.
*--           ICVWC  = End cap wire cabling volume.
*--
*--           GEANT Tracking Medium Numbers.
*--           ICVTIF = Inner foil.
*--           ICVTCF = Centre foil.
*--           ICVTST = Support tube.
*--           ICVTCP = Cathode plane.
*--           ICVTAG = Axial guard plane.
*--           ICVTSG = Stereo guard plane.
*--           ICVTGA = CV gas.
*--           ICVTG1 = End cap G10.
*--           ICVTAL = End cap Aluminium support tubes and plate.
*--           ICVTPC = End cap PC board volume.
*--           ICVTWC = End cap wire cabling volume.
*--
*--           Thicknesses of material.
*--           DCVLI  = Lexan in inner foil.
*--           DCVAI  = Aluminium on inner foil.
*--           DCVMLC = Mylar in centre foil.
*--           DCVMSC = Mylar string spacer in centre foil.
*--           DCVAC  = Aluminium on centre foil.
*--           DCVCFS = Carbon fibre support tube.
*--           DCVKAS = Kapton on support tube.
*--           DCVAS  = Aluminium on support tube.
*--           DCVI   = Total thickness of inner foil.
*--           DCVC   = Total thickness of centre foil.
*--           DCVS   = Total thickness of support tube.
*--           DCVG10 = Thickness (in z) of end cap G10.
*--           DCVALT = Thickness (in R) of end cap outer Aluminium tube.
*--           DCVPCB = Thickness (in z) of end cap PCB volume.
*--           DCVALP = Thickness (in z) of end cap Aluminium plate.
*--           DCVWCA = Thickness (in R) of end cap wire cabling volume.
*--
*--           Radial positions.
*--           RADCVI = Centre of inner foil.
*--           RADCVC = Centre of centre foil.
*--           RADCVS = Centre of Carbon fibre support tube.
*--           RADCVT = Centre of outer Aluminium support tube.
*--
*--           Z extents.
*--           DCVZAT = Z extent of end cap outer Aluminium support tube.
*--           DCVZWC = Z extent of end cap wire cabling volume.
*--
*--           Wire plane quantities.
*--           CVRCAT = Radius of cathode wires.
*--           CVSCAT = Spacing of cathode wires.
*--           CVRGRD = Radius of guard wires.
*--           CVSGRA = Spacing of anode guard wires.
*--           CVSGRS = Spacing of stereo guard wires.
*--
*--           Inner end cap support tube quantities.
*--           NCVZIS = Number of z positions used to define the
*--                    polycone for the Aluminium end cap inner
*--                    support tube.
*--           NCVPIS = Number of parameters to which this translates.
*--
+SELF.
+DECK,CVCDIST.
+KEEP,CVCDIST.
      REAL CVPIST(NCVPIS)
      DATA CVPIST/0.0, 360.0, NCVZIS, 0.0, 8.98, 9.18,
     + 6.07, 8.98, 9.18, 6.07, 8.98, 9.69, 8.0, 8.98, 9.69,
     + 8.0, 9.515, 9.69, 24.9, 9.515, 9.69, 25.6, 10.1, 10.3,
     + 29.0, 10.1, 10.3, 30.4, 10.1, 11.7, DCVPCB, 10.1, 11.7/
+SELF,IF=DOC.
*
*--
*--      REAL CVPIST(NCVPIS)
*--      DATA CVPIST/0.0, 360.0, NCVZIS, 0.0, 8.98, 9.18,
*--     + 6.07, 8.98, 9.18, 6.07, 8.98, 9.69, 8.0, 8.98, 9.69,
*--     + 8.0, 9.515, 9.69, 24.9, 9.515, 9.69, 25.6, 10.1, 10.3,
*--     + 29.0, 10.1, 10.3, 30.4, 10.1, 11.7, DCVPCB, 10.1, 11.7/
*--
*--          Declaration and data statement for array CVPIST to specify
*--          GEANT parameters for the inner end cap Aluminium support
*--          tube.
*--
*--
+SELF.
+DECK,CVGOFF.
+KEEP,CVGOFF.
*.
*.  ANOISE CV noise per wire.
*.  RES    CV two-track resolution parameters.
*.  EFF    CV first hit efficiency.
*.  VRES   CV spatial resolution parameters.
*.
      INTEGER NNOISE, NRES, NEFF, NVRES
      PARAMETER (NNOISE=18,NRES=12,NEFF=18,NVRES=18)
      REAL ANOISE(NNOISE),RES(NRES),EFF(NEFF),VRES(NVRES)
      COMMON /CVGOFF/ ANOISE,RES,EFF,VRES
*
+DECK,CZGDAT.
+KEEP,CZGDAT.
*     -- ZED support --
      DATA PCZS /24.22 ,25.87 ,202.20 ,6.25 ,29. ,190.25 ,0. ,0.   ,3./
      DATA PCZST/24.85 ,25.25 ,202.20 ,1.55 ,27. ,0.     ,0. ,4.7  ,0./
      DATA PCZSB/22.08 ,22.46 ,202.20 ,1.60 ,27. ,0.     ,0. ,-4.5 ,0./
*     -- ZED panel --
      DATA PCZP /24.09 ,24.85 ,197.75 ,2.95 ,90. ,0.     ,0. ,0.2  ,0./
*     -- ZED cell --
      DATA PCZC  /2.39 ,23.75 ,196.0 ,27. ,0. ,0. ,-0.08 ,4./
*     -- ZED detector --
      DATA PCZZD /1.95 ,23.75 ,24.5  ,27. ,4*0./
*     -- Anode module --
      DATA PCZZA /1.95 ,23.75 ,0.50  ,28. ,4*0./
      DATA PCZZB /1.45 ,23.20 ,0.50  ,27. ,4*0./
*     -- Aluminum window --
      DATA PCZZW /1.95 ,23.75 ,12.0  ,27. ,4*0./
      DATA PCZZX /1.45 ,23.20 ,12.0  ,27. ,4*0./
*     -- G10 board --
      DATA PCZZG /0.16 ,11.75 ,13.75 ,28. ,4*0./
*     ------
      DATA UPARZ/24. ,6. ,188.53 ,0.4 ,48*0./
      DATA NBITHZ/8*0/
      DATA ORIG/6*1000. ,0. ,10./
      DATA FACT/3*10000. ,3*1000. ,10000. ,1./
      DATA NBITVZ/6 ,6/
*
+SELF.
*
+DECK,CZGI.
+KEEP,CZGI.
*--    CZ 'GEANT volume offsets' bank
      INTEGER NLCZGI ,NSCZGI ,NDCZGI ,NICZGI ,IOCZGI
      PARAMETER ( NLCZGI =0 ,NSCZGI =0 ,NDCZGI =40
     +,           NICZGI =0 ,IOCZGI =2 )
*
+SELF.
+DECK,CZGF.
+KEEP,CZGF.
*--    CZ 'Wire efficiency' bank
      INTEGER NLCZGF ,NSCZGF ,NDCZGF ,NICZGF ,IOCZGF
      PARAMETER ( NLCZGF =0 ,NSCZGF =0 ,NDCZGF =NCZWIR
     +,           NICZGF =0 ,IOCZGF =3 )
*
+SELF.
+DECK,CZGN.
+KEEP,CZGN.
*--    CZ 'GEANT volume names' bank
      INTEGER NLCZGN ,NSCZGN ,NDCZGN ,NICZGN ,IOCZGN
      PARAMETER ( NLCZGN =0 ,NSCZGN =0 ,NDCZGN =80
     +,           NICZGN =0 ,IOCZGN =5 )
*
+SELF.
+DECK,CZGR.
+KEEP,CZGR.
*--    CZ 'GEANT volume parameters' bank
      INTEGER NLCZGR ,NSCZGR ,NDCZGR ,NICZGR ,IOCZGR
      PARAMETER ( NLCZGR =0 ,NSCZGR =0 ,NDCZGR =200
     +,           NICZGR =0 ,IOCZGR =3 )
*
+SELF.
+DECK,CZGS.
+KEEP,CZGS.
*--    CZ 'Wire Status' bank
      INTEGER IOFFGS
      PARAMETER ( IOFFGS =NCZPAN )
      INTEGER NLCZGS ,NSCZGS ,NDCZGS ,NICZGS ,IOCZGS
      PARAMETER ( NLCZGS =0 ,NSCZGS =0 ,NDCZGS =1 +IOFFGS +NCZPAN*NCZCEL
     +,           NICZGS =0 ,IOCZGS =2 )
*
+SELF.
+DECK,CZGZ.
+KEEP,CZGZ.
*--    CZ 'Cell z-resolution' bank
      INTEGER NLCZGZ ,NSCZGZ ,NDCZGZ ,NICZGZ ,IOCZGZ
      PARAMETER ( NLCZGZ =0 ,NSCZGZ =0 ,NDCZGZ =3*NCZCEL
     +,           NICZGZ =0 ,IOCZGZ =3 )
*
+SELF.
+DECK,CZGO1.
+KEEP,CZGO1.
      INTEGER IGCAL ,NDEADW ,LDEADW
      DIMENSION LDEADW(NCZPAN)
      COMMON /CZDEAD/ IGCAL ,NDEADW ,LDEADW
*
      REAL DSTAG ,D2PRS ,EFFIC ,SIGMA
      DIMENSION EFFIC(NDCZGF) ,SIGMA(2 +NDCZGZ)
      COMMON /CZGOCA/ DSTAG ,D2PRS ,EFFIC ,SIGMA
*
+SELF.
+DECK,CZGO2.
+KEEP,CZGO2.
*--    CZ 'GOPAL top' bank
      INTEGER LCZGN  ,LCZGI  ,LCZGR  ,LCZGA  ,LCZGF
     +,       LCZGS  ,LCZGV  ,LCZGY  ,LCZGZ
      INTEGER LLCZGN ,LLCZGI ,LLCZGR ,LLCZGA ,LLCZGF
     +,       LLCZGS ,LLCZGV ,LLCZGY ,LLCZGZ
      PARAMETER (LLCZGN=1 ,LLCZGI=2 ,LLCZGR=3 ,LLCZGA=4 ,LLCZGF=5
     +,          LLCZGS=6 ,LLCZGV=7 ,LLCZGY=8 ,LLCZGZ=9)
      INTEGER NLCZGO ,NSCZGO ,NDCZGO ,NICZGO ,IOCZGO
      PARAMETER ( NLCZGO =9 ,NSCZGO =9 ,NDCZGO =100
     +,           NICZGO =0 ,IOCZGO =3 )
+SEQ,CZGI.
+SEQ,CZGN.
+SEQ,CZGR.
+SEQ,CZGF.
+SEQ,CZGS.
+SEQ,CZGZ.
*
+SELF.
+DECK,CZGO3.
+KEEP,CZGO3.
      INTEGER    NCZS    ,NCZST   ,NCZSB   ,NCZP    ,NCZC
     +,          NCZZD   ,NCZZA   ,NCZZB   ,NCZZW   ,NCZZX   ,NCZZG
      PARAMETER (NCZS =9 ,NCZST=9 ,NCZSB=9 ,NCZP=9  ,NCZC =8
     +,          NCZZD=8 ,NCZZA=8 ,NCZZB=8 ,NCZZW=8 ,NCZZX=8 ,NCZZG=8)
*
      INTEGER NPARZ
      PARAMETER (NPARZ=4+2*NCZPAN)
*
      INTEGER NWPVCZ ,NWPHCZ
*     -- Meaning of parameters is
*                NWPVCZ : number of words per volume
*                NWPHCZ : number of words per hit --
      PARAMETER (NWPVCZ=2 ,NWPHCZ=8)
*
      INTEGER LCZVOL ,NCZVOL
      PARAMETER (LCZVOL=5  ,NCZVOL=11)
*
+SELF.
+DECK,CZWD.
+KEEP,CZWD.
      INTEGER NLCZWD ,NSCZWD ,NDCZWD ,NICZWD ,IOCZWD
      PARAMETER (NLCZWD=3*MXGRP ,NSCZWD=3*MXGRP ,NICZWD=1
     +,          NDCZWD=NICZWD +2*MXGRP ,IOCZWD=2)
*
+SELF.
+DECK,CZWG.
+KEEP,CZWG.
      INTEGER NLCZWG ,NSCZWG ,NDCZWG ,NICZWG ,IOCZWG
      PARAMETER (NLCZWG=19, NSCZWG=19 ,NICZWG=1
     +,          NDCZWG=NICZWG +2*NCZWIR ,IOCZWG=2)
*
+SELF.
+DECK,CZWK.
+KEEP,CZWK.
      INTEGER NLCZWK ,NSCZWK ,NDCZWK ,IOCZWK
      PARAMETER (NLCZWK=5 ,NSCZWK=5 ,NDCZWK=5 ,IOCZWK=2)
*
+SELF.
+DECK,CZWM.
+KEEP,CZWM.
      INTEGER MXMPAN ,MXMCEL ,MXMPC ,MOFFP ,MOFFC ,NSTC
      PARAMETER (MXMPAN=2, MXMCEL=2 ,MXMPC=MXMPAN*MXMCEL)
      PARAMETER (MOFFP=4 ,MOFFC=4)
      PARAMETER (NSTC=NCZCEL/MOFFC)
      INTEGER NLCZWM ,NSCZWM ,NDCZWM ,NICZWM ,IOCZWM
      PARAMETER (NLCZWM=0 ,NSCZWM=0 ,NICZWM=10
     +,          NDCZWM=NICZWM +3*(4*MXGRP) ,IOCZWM=2)
*
+SELF.
+DECK,CZW.
+KEEP,CZW.
+SEQ,LCZWLN.
+SEQ,CZWK.
+SEQ,CZWD.
+SEQ,CZWG.
+SEQ,CZWM.
+SELF.
+DECK,DCLLINKRA.   NO LONGER NEEDED DRW 25/3/88
+KEEP,DCLLINKRA.   NO LONGER NEEDED DRW 25/3/88
+DECK,EBANGL.
+KEEP,EBANGL.
      DOUBLE PRECISION R, THT, PSI, ALP, DTHT
      COMMON /EBANGL/ R(30), THT(30), PSI(30), ALP(30), DTHT
+DECK,EBGPAR.
+KEEP,EBGPAR.
      DOUBLE PRECISION BL, BL30, D, W
      COMMON /EBGPAR/ BL, BL30, D, W
+DECK,EBPSTN.
+KEEP,EBPSTN.
      DOUBLE PRECISION Z, X, P, Q, A, B, U, V, ZC
      COMMON /EBPSTN/ Z(30), X(30), P(30), Q(30)
     +       ,A(30), B(30), U(30), V(30), ZC(30)
+DECK,EBSIZE.
+KEEP,EBSIZE.
      DOUBLE PRECISION WIDTH
      COMMON /EBSIZE/ WIDTH(6,30)
+DECK,EBXTR.                                                                    
+KEEP,EBXTR.                                                                    
      INTEGER LEBTR                                                             
      PARAMETER (LEBTR = 1337)                                                  
      REAL    EBTREQ(2*LEBTR)                                                   
     +       ,EBTRL0(160,5)                                                     
     +       ,EBTRA0(40,5)                                                      
     +       ,EBTRP0(24,5), EBTRO0(8,5)                                         
     +       ,EBTRM0(24,6), EBTRR0(24), EBTRQ0(8), EBTRB0                       
     +       ,EBTRL(160,5)                                                      
     +       ,EBTRA(40,5)                                                       
     +       ,EBTRP(24,5),  EBTRO(8,5)                                          
     +       ,EBTRM(24,6),  EBTRR(24),  EBTRQ(8),  EBTRB                        
      COMMON /EBXTR / EBTREQ                                                    
      EQUIVALENCE                                                               
     +        (EBTREQ(1),EBTRL0)                                                
     +       ,(EBTREQ(801),EBTRA0)                                              
     +       ,(EBTREQ(1001),EBTRP0), (EBTREQ(1121),EBTRO0)                      
     +       ,(EBTREQ(1161),EBTRM0), (EBTREQ(1305),EBTRR0)                      
     +       ,(EBTREQ(1329),EBTRQ0), (EBTREQ(1337),EBTRB0)                      
     +       ,(EBTREQ(LEBTR+1),EBTRL)                                           
     +       ,(EBTREQ(LEBTR+801),EBTRA)                                         
     +       ,(EBTREQ(LEBTR+1001),EBTRP), (EBTREQ(LEBTR+1121),EBTRO)            
     +       ,(EBTREQ(LEBTR+1161),EBTRM), (EBTREQ(LEBTR+1305),EBTRR)            
     +       ,(EBTREQ(LEBTR+1329),EBTRQ), (EBTREQ(LEBTR+1337),EBTRB)            
+SELF,IF=DOC.                                                                   
+SEQ,EBXTR.                                                                     
*                                                                               
*  COMMON EBXTR  used by subroutine TREB (EB trigger simulation)                
*                                                                               
*  The arrays are put together in the COMMON rather than being                  
*  declared as internal arrays inside TREB, so that an external                 
*  routine can monitor the activity of the TREB.                                
*                                                                               
*  The arrays suffixed with "0" contain the summed signal without               
*  any simulated noises.  This is for enabling an external routine              
*  to do some checks easily, e.g. to make efficiency curves.                    
*                                                                               
+SELF.                                                                          
+DECK,ECAPAR.
+KEEP,ECAPAR.
*-              Parameters fixing boundary of ECA- logical volumes
*
*-      139.02    Furthe reduction of RFTC1                06-Mar-98  JEC
*-      139.01    Reduce RFTC1 to accomodate Mip plug vol FM-; 
*                 RFTC11 = old value of RFTC1              30-Jan-98  JEC
*
      REAL        RFD0, RFD1, RFD2, RFD3, RCPW1, RCPW2
      REAL        ZFD0, ZFD1, ZFD2, ZFD3, ZCPW1, ZCPW2, DZCPW
      REAL        ZFTC1, ZFTC2, RFTC1, RFTC11, RFTC2
*
      PARAMETER   ( RFD0 =   8.4, RFD1 =  25.0,
     +              RFD2 =  48.4, RFD3 =  50.0 )
      PARAMETER   ( ZFD0 = 184.,  ZFD1 = 191.0,
     +              ZFD2 = 205.0, ZFD3 = 212.0 )
*
      PARAMETER   ( RCPW1 = 8.75, RCPW2 = 24.95, DZCPW = 4.,
     +              ZCPW1 = 202.5 , ZCPW2 = ZCPW1 + 2.*DZCPW )
*
      PARAMETER   (   ZFTC1 =  ZFD3, ZFTC2 = 237.1,
     +                RFTC1 =   9.2, RFTC11=10.9, RFTC2 = RFD3 )
*
+DECK,EEDRW.
+KEEP,EEDRW.
      INTEGER IEEDRW,JBLOCK
      REAL ZBLO,ZBHI
      COMMON/EEDRW/IEEDRW,JBLOCK(40,40),ZBLO(20,20),ZBHI(20,20)
+SELF,IF=DOC.
+SEQ,EEDRW.
* --- Private COMMON for EE user search.
*     IEEDRW : Flag to indicate whether initialization has happened.
*     JBLOCK : Volume number of block I,J
*     ZBLO   : Lower z limit of block (one quadrant only stored)
*     ZBHI   : Upper z limit of block (one quadrant only stored)
+DECK,EEGFFR.
+KEEP,EEGFFR.
      INTEGER IFEESM
      COMMON/EEGFFR/IFEESM
+SELF,IF=DOC.
+SEQ,EEGFFR.
*
*        IFEESM : Flag to control smearing of EE calibrations:
*                      0 = no smearing
*                      1 = smear using calibration coefficient errors if
*                          available, else CPW estimates (default)
*
+SELF.
+DECK,EENUMB.
+KEEP,EENUMB.
      INTEGER LOOKL,LOOKR,EEIYIX,EECALS
      COMMON/EENUMB/LOOKL(39,39),LOOKR(39,39)
     +,EEIYIX(1248),EECALS(1248,2)
+DECK,EETPMS.
+KEEP,EETPMS.
       REAL EETP,CHARGE
      COMMON/EETPMS/EETP(2,24),CHARGE(2)
+DECK,FDBUF.
+KEEP,FDBUF.
*DRW add LUNPHO, LUNPOS
      COMMON/ FDBUF / IDRC,FDCAL,FKSET,FKDET,FPSET,FPDET,ZSHWR,
     +  IFKZP,IFPZP,BOTSHW,LUNPHO,LUNPOS
      REAL  DRC(2,1000),ZSHWR,SCALE,ECUTS
      INTEGER  IDRC(2,1000), FDCAL(3), FKSET, FKDET, FPSET, FPDET
      INTEGER  IFKZP,IFPZP,LUNPHO,LUNPOS
      LOGICAL BOTSHW
      EQUIVALENCE (IDRC, DRC), ( SCALE, FDCAL(2)), (ECUTS, FDCAL(3))
*
+DECK,FDCDES.
+KEEP,DOC_FDCDE.
*
*       FDCDES
*                  CDEs for GOPAL123, to run FDET code
*
*.
*.  AUTHOR    : J.E.Conboy, University College London UCLVC::JEC
*.  VERSION   : 123.3
*.  CREATED   : 18-May-90
*.  LAST MOD  : 10-Nov-93
*.
*.  Modification Log
*.
*.  10-Nov-93  J.E.Conboy    new FDTCON
*.  05-Sep-90  J.E.C         Added FKCPAR - FK calibn bank parameters
*.  04-Sep-90  J.E.C         FDMPAR - ADD MFBGAS
*.  31-Aug-90  J.E.C         new FDTCON; added FKPED, FKCALI
*.  20-Aug-90  J.E.C         Change ROCDES to ROPE311
*.  30-Jul-90  J.E.Conboy    Added  FDPBEQ sequence
*.  08-Jul-90  J.E.Conboy    Added  FPDZ, FKDZ to FDGPAR
*
***********************************************************************
*
*   Naming convention..
*.
*.    FDxPAR       Parameter statements
*.    FDxCON       Common blocks
*.    FDxDAT       Data statements
*.    FDxDEF        "        "      - local default values
*.
*.  where  x  =  G   Geometry
*.               M   Materials & Media
*.               H   Hits
*.               D   Digitization
*.               T   Trigger
*.               B   Bank structure
*.               C   Calibration
*.
*.    Modification records for all sequences are collected above.
+SELF.
+DECK,FDBPAR.
+KEEP,FDBPAR.
*==                Constants (??) describing FD data banks..  123.00  18-MAY-90
*
      INTEGER      NWFBCL, NWFKCL, IOFBCL, IOFKCL, IOFLTD,
     +             IAFKE, IAFKR, IAFKPH, IAFKSG
*                  Number of words/cluster
      PARAMETER  ( NWFBCL = 6, NWFKCL = 9 )
*                  Offset of 0'th word of cluster in bank
      PARAMETER  ( IOFBCL = 1, IOFKCL = 1 )
*                  Offset of TDC info in FL data bank ..
      PARAMETER  ( IOFLTD = 22 )
*
      PARAMETER  ( IAFKE = 1, IAFKR = 5, IAFKPH = 7, IAFKSG = 9 )
*                  Offset of Energy, Radius, Phi, Seg no in FK cluster
+DECK,FDDCON.
+KEEP,FDDCON.  ( +REPL,GOCDES,FDCDES,C=55-79.
*.                      FDDCON      Vn 126.00                      05-Jun-91
*.    Constants for FDET digitization
*.
      INTEGER           NFDSD
      INTEGER           IXFE, IXFL, IXFP, IXFK, IXFB, IXFT, IXFKL
      REAL              FDDIGF, FDCAL0, FDPED0, FDPEDW, FDDIGW
      LOGICAL           SWCAL
*
      PARAMETER        (NFDSD = 8 )
      PARAMETER        ( IXFE=1, IXFL=2, IXFP=4, IXFK=5, IXFB=6,
     +                   IXFT=7, IXFKL=8 )
*
*
      COMMON / FDDCON / FDDIGF( 2, NFDSD ), FDCAL0( 2, NFDSD),
     +                  FDPED0( 2, NFDSD ), FDPEDW( 2, NFDSD),
     +                  SWCAL ( NFDSD ),    FDDIGW( 2, NFDSD)
*
*     FDDIGF   is the nominal digitization factor for each subdet
*     FDCAL0   is the corresponding nominal calibration constant
*     FDPED0   is the nominal pedestal, and FDPEDW the width
*     SWCAL    is .TRUE. if calibration data may be available; it is
*              reset in S/R FDDIGC if data is not present
*     FDDIGW   is the RMS variation of FDDIGF
*
*     Eclus  =  Ehit * FDDIGF  =  Iadc * FDCAL0
*
*     FDxxxx  Subscripts :
*         (1,1)    FE readout
*         (1,2)    FLPF, FLPB  ADC Low gain
*         (2,2)                    High gain - not used, so same as Low
*         (1,3)                TDC Side 1 (RH)
*         (2,3)                         2 (LH)  ( T0 may differ )
*         (1,4)    FP readout
*         (1,5)    FK outer
*         (2,5)    FK inner
*         (1,6)    FB
*         (1,7)    FT
*         (1,8)    FKLS  Calo light guide, not required
*--------------------------------------------------------------------------
*
+SELF.
+DECK,FDGPAR.
+KEEP,FDGPAR.
      REAL           FKR1, FKR2, FDFEDX, FKDZ, FPDZ
      PARAMETER     (FKR1 = 10.683, FKR2 = 40.358, FDFEDX = 0.180 )
*                    Calorimeter inner & outer radii, width of divider
      PARAMETER     (FKDZ = 16.94, FPDZ = 3.075 )
*
+DECK,FDGCON.
+KEEP,FDGCON.
*..           Position & dimensions of FD subdetector         Vn 139.0/429.0
*
      REAL              PFDOFF, PFDZ, FPZMN,FPZMX, FKZMN,FKZMX,
     +                  PFBZ, PFTZ, PFEZ, PFLZ,
     +                  DZPB, DZSC, DZSEG, DZFEM
*
      INTEGER        IFDEXP, NWGCON
      PARAMETER      ( NWGCON = 32 )
      REAL           GCON(NWGCON)
      EQUIVALENCE    (GCON(1), IFDEXP )
*
      COMMON / FDGCON / IFDEXP, PFDOFF(3,2), PFDZ( 2),
     +                  PFBZ( 2), PFTZ(2,2), PFEZ(2), PFLZ(2,2),
     +                  FPZMN(2), FPZMX(2), FKZMN(2), FKZMX(2),
     +                  DZPB, DZSC, DZSEG, DZFEM
*
+SELF,IF=DOC.
+SEQ,FDGCON.
*...FDGCON sequence:    Positions of FD subdetectors.
*
*   /FDGCON/ is initialised by FDGSET ( Rope ) or FDxxGE ( GOPAL )
*
*.   IFDEXP       Experiment number for which FDGCON has been initialised
*.   PFDOFF(3,2)  Offset (X/Y/Z, Side)  from nominal FD position
*.   PFDZ(2)      Z coord of FD reference plane, front surface of presampler
*.   PFBZ(2)      Z coord of FB reference plane
*.   PFTZ(2,2)               FT ref. plane; 1st index is 1 for lowest Z
*.                           chamber ( TC1 or SARC )
*.   PFEZ(2)      Z Coord of Gamma catcher
*.   PFLZ(2)                 FL counter
*.
*.   FPZMN(2)                Z limits of presampler ( used by FDGAMA
*.   FPZMX(2)                                 "
*.   FKZMN(2)                            main calo.
*.   FKZMX(2)                                 "
*.   DZPB         Z thickness of lead
*.   DZSC                        scintillator
*.   DZSEG                       calorimeter segment
*.   DZFEM                       FE- volume
*.............................................................................
+SELF.
+DECK,FDMCON.
+KEEP,FDMCON.
*.                      FDCONS      Vn 123.00                      18-MAY-90
*.    Constants for FDET Media & materials
*.
      REAL              FDPBME, FDPBUS, FDSCME
*
      COMMON / FDMCON / FDPBME(5), FDPBUS(10), FDSCME(6)
*
+DECK,FDMDAT.
+KEEP,FDMDAT.
*
      INTEGER       NFDPBU
      PARAMETER   ( NFDPBU  =  4)
*
      REAL          FDPBME(5), FDPBUS(NFDPBU), FDSCME(5)
*
*                            TMAX  DMAX  DEEM  EPSI  STMIN
      DATA          FDPBME / 10.0,  0.5,  0.1,  0.1, 0.128 /
     +              FDSCME / 10.0, 0.05,  0.1,  0.1, 0.2   /
*--         Parameters for FD scint & Lead;
*                           NBREM  STMIN  STMAX  THETA
      DATA          FDPBUS /  4.0, 0.056, 0.128, 0.085  /
*
+DECK,FDPBEQ.
+KEEP,FDPBEQ.
      REAL          FDPBUS(4), PBREMX, PBSTMN, PBSTMX, PBTHET
*
      EQUIVALENCE  (FDPBUS(1), PBREMX ),( FDPBUS(2), PBSTMN ),
     +             (FDPBUS(3), PBSTMX ),( FDPBUS(4), PBTHET )
+DECK,FDMPAR.
+KEEP,FDMPAR.
*.                  FDET tracking media 123.1  04-Sep-90   JEC
      INTEGER        MAL, MFDPB, MFDSC, MFDAIR, MBPCF, MBPAL, MBPFE,
     +               MFDFPB, MFBGAS
      PARAMETER     (MAL  =  7, MFDPB = 9, MFDSC = 10, MFDAIR = 13 )
      PARAMETER     (MFDFPB = 67, MFBGAS=51 )
      PARAMETER     (MBPCF = 96, MBPAL = 99, MBPFE = 97 )
*
*--         TMED nos for Al, Pb, Scint, Air, Fast Pb, Beam pipe C/Fibre
*                        Beam pipe Al, Beam pipe iron
*
      INTEGER        MATPB, MAFDSC
      PARAMETER     (MATPB = 13, MAFDSC = 24 )
*--         Material nos for FD lead, scint
*
+DECK,FDTCON.
+KEEP,FDTCON.
*.                      FDTCON      Vn 132.00                      02-NOV-93
*.    Constants for FDET  trigger; HIOR added 11-12-92
*.
      REAL              ASUMTH, ASEGTH, FLTRTH, TRSCFK, TRSCFP,
     +                  ESUMTH, ESEGTH, ECHITH, ACHITH,
     +                  ECFETH, ACFETH
*
      COMMON / FDTCON / ASUMTH, ASEGTH, FLTRTH,
     +                  TRSCFK, TRSCFP, ESUMTH, ESEGTH, 
     +                  ECHITH, ACHITH, ECFETH, ACFETH
*
*.
+DECK,FDIGWK.       Working space configuration for FDET digitisation
+KEEP,FDIGWK.       Working space configuration for FDET digitisation
*==   FDDIGWK  133.0
*     20-Jan-95  J.E.Conboy   Increase NHMAX to 600 ( more hits with Ge121 )
      INTEGER        NDET, IZPL, IZMI, IAF, IAG, NADC
      PARAMETER     (NDET = 8, IZPL = 1, IZMI = 2 )
      PARAMETER     (IAF = 5, IAG = 6, NADC = 32 )
*.
      INTEGER       IWK1, NVDIM, NHDIM, NHDIMB, NHMAX, NHMAXB, NWK
      PARAMETER    (IWK1=31, NVDIM=5, NHDIM=6, NHDIMB=7 )
      PARAMETER    (NHMAX  =  600 )
      PARAMETER    (NHMAXB =  (NHMAX*NHDIM)/NHDIMB )
      PARAMETER    (NWK    =  IWK1 + (NVDIM+NHDIM+1)*NHMAX )
*
      INTEGER       ITRA(NHMAX), NUMBV(NVDIM,NHMAX)
      REAL          WK(0:NWK),  HITS(NHDIM,NHMAX), HITSB( NHDIMB,NHMAX)
      EQUIVALENCE  (WK(0)              ,  WS(IWK1)  )
      EQUIVALENCE  (WK(0)              ,  ITRA(1)   )
      EQUIVALENCE  (WK(NHMAX)          ,  NUMBV(1,1))
      EQUIVALENCE  (WS(NHMAX*(NVDIM+1)),  HITS(1,1),  HITSB(1,1) )
*
      INTEGER       IDET, ISIDE, IPHI, NHITS, ND, IPL
      EQUIVALENCE  (IDET,  WS(22)),(ISIDE, WS(23)),(IPHI, WS(24)),
     +             (NHITS, WS(25)),(ND,    WS(26)),(IPL,  WS(27))
*
+DECK,FFCONS.
+KEEP,FFCONS.
*
*     FFREAD cards for FF and beam pipe
*
      REAL XDISP,YDISP
      REAL QS0	
      REAL ROTRF,ROTRN,ROTLF,ROTLN
      REAL SURVEY 
      REAL PROB
      COMMON/FFCONS/XDISP,YDISP,QS0(10),ROTRF(6),ROTRN(6),
     +              ROTLF(6),ROTLN(6),SURVEY(12),PROB(5)
*
+DECK,FFHD.
+KEEP,FFHD.
*
*     FF HITS AND DIGITIZATION VARIABLES
*
      INTEGER NCHITP,NCHITD
      PARAMETER(NCHITP=16,NCHITD=9)
*
+DECK,FFMPAR.
+KEEP,FFMPAR.
*
*     FF material IDs
*
      INTEGER FFAIR,FFAL,FFPB,FFSCI,FFCU,FFFE
      PARAMETER(FFAIR=125,FFAL=126,FFPB=127,FFSCI=128,FFCU=129)
      PARAMETER(FFFE=130)
*
+DECK,FKCPAR.
+KEEP,FKCPAR.
*       Offsets into LFKPE
      INTEGER     JAPPRE, JAPOUT, JAPIN, JAPSIG
      PARAMETER ( JAPPRE = 0, JAPOUT = 16, JAPIN = 32 , JAPSIG = 48)
*       Offsets into LFKCA
      INTEGER     JACOUT, JACPRE, JACETA, JACAB
      PARAMETER ( JACOUT = 0, JACPRE = 16, JACETA = 32, JACAB = 48 )
+DECK,GOCAIO.
+KEEP,GOCAIO.
      INTEGER         LRECRZ         , IUCDEF
      PARAMETER     ( LRECRZ = 4*1024, IUCDEF = 3 )
      INTEGER         IUCALR, NCJCGT, LCJCGT, MCJCGT
     +,                       NCJCPT, LCJCPT, MCJCPT
      PARAMETER                             ( MCJCGT = 40
     +,                                       MCJCPT = 60 )
      INTEGER         IAUTHR   , ICOMNT
      COMMON /GOCAIO/ IUCALR   , NCJCGT   , LCJCGT( MCJCGT )
     +,                          NCJCPT   , LCJCPT( MCJCPT )
     +,               IAUTHR(4), ICOMNT(5)
+SELF,IF=DOC.
+SEQ,GOCAIO.
*     COMMON of variables to handle reading / writing
*            of calibration RZ-file
*
*        LRECRZ : record length of the RZ-file ( = 4kByte )
*        IUCDEF : default fortran unit no. of the RZ-file
*        IUCALR : fortran unit no. of the RZ-file
*        NCJCGT : no. of arguments on CJCGET datacard
*        LCJCGT : keeps the arguments of the CJCGET datacard
*        NCJCPT : no. of arguments on CJCPUT datacard
*        LCJCPT : keeps the arguments of the CJCPUT datacard
*        IAUTHR : hollerith array for authorname of cal.-RZfile mods.
*        ICOMNT : hollerith array for comments on modifications
*--
+SELF.
+DECK,GOCART
+KEEP,GOCART
      REAL         CAVXYZ,CAOPAL
      COMMON/GOCART/CAVXYZ(6),CAOPAL(3)
*
+DECK,GOFLAG
+KEEP,GOFLAG
*-    19-FEB-93  Change IFLGFC,IFLGFT to  IFLGFD, IFLGLM        ( JEC
*-               Add IGYEAR, year number
      INTEGER NDIGI,NUFLAG,IUHITS,IUTRAK,IUFLAG,LDIGI,NCHEAT,LCHEAT,
     +NFAST,LFAST,NGUN,LGUN,NCDET,LCDET,NCAL,LCAL,NPSAM,LPSAM,NFDET,   
     +LFDET,NSILI,LSILI,NODET,LSMEAR,NSMEAR,ICJPAK,IGOEXP   
*
      INTEGER IFLGKI,IFLGBP,IFLGCV,IFLGCJ,IFLGCZ,IFLGCP,IFLGTB,IFLGPB, 
     +IFLGEB,IFLGHB, IFLGMB,IFLGPE,IFLGEE,IFLGHE,IFLGME,IFLGHP,IFLGFD, 
     +IFLGLM,IFLG19,IFLG20,JZLOGL,JZVERI,IVAXPN,LLOC,NNOC,IESKIP,
     +IGYEAR
*
      COMMON/GOFLAG/NDIGI,NUFLAG,IUHITS,IUTRAK,IUFLAG(20),LDIGI(20),   
     +NCHEAT,LCHEAT(20),NFAST,LFAST(20),LGUN(20),NGUN,NCDET,LCDET(10), 
     +NCAL,LCAL(10),NPSAM,LPSAM(10),NFDET,LFDET(10),NSILI,LSILI(10),   
     +NODET,LSMEAR(10),NSMEAR,ICJPAK,IGOEXP,JZLOGL,JZVERI(10),IVAXPN,   
     +LLOC(20),NNOC,IESKIP,IGYEAR
      PARAMETER(IFLGKI= 1,IFLGBP= 2,IFLGCV= 3,IFLGCJ= 4,IFLGCZ= 5)  
      PARAMETER(IFLGCP= 6,IFLGTB= 7,IFLGPB= 8,IFLGEB= 9,IFLGHB=10)  
      PARAMETER(IFLGMB=11,IFLGPE=12,IFLGEE=13,IFLGHE=14,IFLGME=15)  
      PARAMETER(IFLGHP=16,IFLGFD=17,IFLGLM=18,IFLG19=19,IFLG20=20)  
*   
+DECK,GOFILE.
+KEEP,GOFILE.
      INTEGER MFILE
      INTEGER NFILE
      LOGICAL LUOPEN,LUEVER
      PARAMETER (MFILE=20)
      INTEGER IONAME,IOUNIT,IOLREC,IOFCHO,IODCHO
      COMMON/GOFILE/NFILE,IONAME(MFILE),IOUNIT(MFILE),IOLREC(MFILE),
     +      IOFCHO(MFILE),IODCHO(MFILE),LUOPEN(MFILE),LUEVER(MFILE)
      CHARACTER*80 IOFNAM(MFILE)
      COMMON/GOFILC/IOFNAM
+DECK,GOFLD
+KEEP,GOFLD
      INTEGER IFLD,JFLD
      REAL FLDFAC,FLDSGN,BZ000,F0
      COMMON/ GOFLD/ FLDFAC,FLDSGN,IFLD,BZ000,JFLD,F0
+SELF,IF=DOC.
+SEQ,GOFLD.
*            FLDFAC = scale factor by which all magnetic fields for
*                     GSTMED will be multiplied.
*            FLDSGN = sign of field at origin (+1 or -1)
*            IFLD   = field flag, normally 1 but set to 0 when
*                     FLDFAC = 0.
*            BZ000  = Bz at the origin (signed).
*
+DECK,GOHITS
+KEEP,GOHITS
      INTEGER NPOINT,NPLENG
      REAL POINTS
      PARAMETER (NPLENG=1000)
      COMMON/GOHITS/NPOINT,POINTS(10,NPLENG)
*
+DECK,GOHTOP.
+KEEP,GOHTOP.
      CHARACTER*7 GOTOP
      COMMON/GOHTOP/GOTOP
*     Top directory for GOPAL histograms
*     (should be //HISTO if *FILE 'HIST' card; //PAWC otherwise).
+DECK,GOKIDI.
+KEEP,GOKIDI.
      LOGICAL NORUNG
      COMMON /GOKIDI/ NORUNG
+DECK,GOLIFC.
+KEEP,GOLIFC.
      INTEGER MXLIFE
      PARAMETER (MXLIFE=13)
      REAL TXLIFE
      COMMON /GOLIFC/ TXLIFE(MXLIFE)
+DECK,GOLOGI
+KEEP,GOLOGI.
      COMMON/GOLOGI/LCDFU,LCDFA,LCDSM,LCALFU,LCALFA,LCALSM,LFDFU,LPSFU,
     +    LALLFU,LALLFA,LALLSM,LSMTRK,LSMCE,LSIFU,LSIFA,LSISM,
     +    LFDFA,LFDSM
*
      LOGICAL LCDFU,LCDFA,LCDSM,LCALFU,LCALFA,LCALSM,LFDFU,LPSFU,
     +    LALLFU,LALLFA,LALLSM,LSMTRK,LSMCE,LSIFU,LSIFA,LSISM,
     +    LFDFA,LFDSM
*
+DECK,GOPAR.
+KEEP,GOPAR.
      INTEGER   NLMC  ,NSMC  ,NDMC  ,NIMC  ,IOMC  ,
     +          LLGENE,LLVERT,LLKINE,LLCHEA,
     +          IIKINE,INVERT,INKINE,IFCHEA
      INTEGER
     +          LLTREE,LLJETS,LLXTRA,
     +          INGEN ,ILENT
      INTEGER
     +          ITRTY ,ITRPX ,ITRPY ,ITRPZ ,ITRE  ,ITRCH ,
     +          ITRSX ,ITRSY ,ITRSZ ,ITREX ,ITREY ,ITREZ
      INTEGER                 NDVERT,NIVERT,IOVERT,
     +          IGOVNV,LLGOVU,
     +          IGOVX ,IGOVY ,IGOVZ ,IGOVTF,IGOVKB,IGOVKT,IGOVNT
      INTEGER                 NDKINE,NIKINE,IOKINE,
     +          IGOKNT,LLGOKU,
     +          IGOKPX,IGOKPY,IGOKPZ,IGOKE ,IGOKTY,IGOKVO,IGOKND
      PARAMETER(NLMC  =  6,NSMC  =  6,NDMC  = 20,NIMC  =  8,IOMC  =  2,
     +          LLGENE=  1,LLVERT=  2,LLKINE=  3,LLCHEA=  4,
     +          IIKINE=  1,INVERT=  2,INKINE=  3,IFCHEA=  4)
      PARAMETER(
     +          LLTREE=  1,LLJETS = 2,LLXTRA =  3,
     +          INGEN =  1,ILENT =  5,
     +          ITRTY =  1,ITRPX = 11,ITRPY = 12,ITRPZ = 13,ITRE  = 14,
     +          ITRCH = 16,
     +          ITRSX = 17,ITRSY = 18,ITRSZ = 19,ITREX = 20,ITREY = 21,
     +          ITREZ = 22)
      PARAMETER(                      NDVERT=  1,NIVERT=  1,IOVERT=  2,
     +          IGOVNV=  1,LLGOVU=  1,
     +          IGOVX =  1,IGOVY =  2,IGOVZ =  3,IGOVTF=  4,IGOVKB=  5,
     +          IGOVKT=  6,IGOVNT=  7)
      PARAMETER(                      NDKINE=  1,NIKINE=  1,IOKINE=  2,
     +          IGOKNT=  1,LLGOKU=  1,
     +          IGOKPX=  1,IGOKPY=  2,IGOKPZ=  3,IGOKE =  4,IGOKTY=  5,
     +          IGOKVO=  6,IGOKND=  7)
+SELF,IF=DOC,GODOC.
******************************************************************
*
*                  Sequence GOPAR
*
******************************************************************
*
*                  Parameter for Gopal top bank MC
* NLMC  : Number of links
* NSMC  : Number of structural links
* NDMC  : Number of data words
* NIMC  : Number of integer data words
* IOMC  : IO characteristic
*
*                  Offsets in the link part of MC
* LLGENE: To GENE bank
* LLVERT: To Kinematic GEANT vertex data structure VERT
* LLKINE: To Kinematic GEANT track data structure KINE
* LLCHEA: To "Cheat Words"
*
*                  Offsets in the data part of MC
* IIKINE: To LUNDevent type (IKINE data word in GOPAL)
* INVERT: To number of vertices
* INKINE: To number of tracks
* IFCHEA: To flag for "Cheat Words" (to be defined)
*
*                  Parameter for GENE bank
*                  Offset in the link part of GENE
* LLTREE: To TREE bank
* LLJETS: To jets bank
*
*                  Offset in the data part of GENE
* INGEN : To No of TREE tracks in GENE
* ILENT : To No of parameters for each track in TREE bank
*
*                  Parameter for TREE bank
*                  Offset in the data part of TREE
* ITRxx : To track parameters in TREE bank
*
*                  Parameter for Gopal vertex bank VERT
* NDVERT: Number of data words
* NIVERT: Number of integer data words
* IOVERT: IO characteristic
*
*                  Offsets in the data part of VERT
* IGOVNV: To number of vertices stored in structure VERT
*
*                  Offsets in vertex bank pointed by JV=LQ(LVERT-KV)
*                  Link part
* LLGOVU: To User Words
*                  Data part
* IGOVX : To X position
* IGOVY : To Y position
* IGOVZ : To Z position
* IGOVTF: To T-O-F
* IGOVKB: To beam track
* IGOVKT: To target track
* IGOVNT: To number of tracks from this vertex
*
*                  Parameter for Gopal track bank KINE
* NDKINE: Number of data words
* NIKINE: Number of integer data words
* IOKINE: IO characteristic
*
*                  Offsets in the data part of KINE
* IGOKNT: To number of tracks stored in structure KINE
*
*                  Offsets in track bank pointed by LT=LQ(LKINE-KT)
*                  Link part
* LLGOKU: To User Words
*                  Data part
* IGOKPX: To PX
* IGOKPY: To PY
* IGOKPZ: To PZ
* IGOKE : To track energy
* IGOKTY: To track type
* IGOKVO: To origin vertex of track
* IGOKND: To number of vertex along track
*
*******************************************************************
+SEQ ,GOPAR.
+DECK,GOSEED.
+KEEP,GOSEED.
      INTEGER JSEED
      COMMON/GOSEED/JSEED(2)
+SELF,IF=DOC.
+SEQ,GOSEED.
*            JSEED  = Random number seed of event at end of GUKINE.
+DECK,GOSMR.
+KEEP,GOSMR.
* Add to PARCL                   - DRW  3/5/90
* 6 extra CD words               - DRW 4/10/89
* Add CT errors                  - JNB 14/6/89
* Add FSPAC2 for new function    - JNB 23/5/89
* New EMCL bank format           - JNB  9/5/89
* 2 extra CD words               - JNB  8/5/89
* Reinstate ROPE stuff (for now) - DRW 15/2/89
* Extra words, remove ROPE stuff - JNB  8/2/89
* NCLMAX increase                - RJB 17/10/88
* MMTR IO descriptor             - JNB 26/9/88
* Calorimeter additions          - RJB 16/8/88
      INTEGER MAXMU,NPARMU,MAXNCD,NPARCD,MAXCL,NPARCL
      PARAMETER(MAXNCD=100)
      PARAMETER(MAXMU=20)
      PARAMETER(NPARMU=18)
      PARAMETER(NPARCD=20)
      PARAMETER(MAXCL=200)
      PARAMETER(NPARCL=9)
      COMMON/GOSMR1/NCD,NMU,NCL,PARMU,PARCD,PARCL,FSPACE,FSPAC2
     +             ,NTREX,NTRLE,NTRST
     +             ,IOWORD,NCTTS,IOHMPS,IOMMTR,IOEMCL
      INTEGER IOWORD(50),NCTTS,IOHMPS,IOMMTR,IOEMCL
      INTEGER NCD,NMU,NCL,NTREX,NTRLE,NTRST
      INTEGER IPARMU(NPARMU,MAXMU),IPARCD(NPARCD,MAXNCD)
      INTEGER IPARCL(NPARCL,MAXCL)
      REAL PARMU(NPARMU,MAXMU),PARCD(NPARCD,MAXNCD),PARCL(NPARCL,MAXCL)
      REAL FSPACE(100),FSPAC2(100)
      EQUIVALENCE(IPARMU(1,1),PARMU(1,1))
      EQUIVALENCE(IPARCD(1,1),PARCD(1,1))
      EQUIVALENCE(IPARCL(1,1),PARCL(1,1))
+DECK,GOSTAT
+KEEP,GOSTAT
      INTEGER NEVTS,NVO,KVOLU,KMEC,NVPRIM,MVPRIM
      REAL    SDET,SKIN
      COMMON/GOSTAT/NEVTS,SDET(10,17),SKIN(50,12,2) ,NVO,KVOLU(200,2),
     +KMEC(30),NVPRIM,MVPRIM
+SELF,IF=DOC.
+SEQ,GOSTAT.
*            NEVTS  = Number of events for which statistics accumulated
*            SDET   = Statistics on Raw Data banks
*            SKIN   = Statistics on tracks
*            NVO    = Number of volumes entered in KVOLU
*            KVOLU  = Statistics on secondary vertex volumes
*            KMEC   = Statistics on secondary vertex mechanisms
*            NVPRIM = number of "primary vertices" in present event
*            MVPRIM = statistics on no of primary vertices
+DECK,GOTPAR.
+KEEP,GOTPAR.
*--Track trigger
      INTEGER JBTM1,JBTM2,JBTM3,JBTBM1,JBTBM2,JBTBM3,JBVXH,JBJ1H,JBJ2H,
     +        JBJ3H
      PARAMETER (JBTM1=1,JBTM2=2,JBTM3=3,JBTBM1=4,JBTBM2=5,JBTBM3=6,
     +           JBVXH=7,JBJ1H=8,JBJ2H=9,JBJ3H=10)
*--ToF
      INTEGER JBTOFO,JBTFMY,JBTOFM
      PARAMETER (JBTOFO=16,JBTFMY=17,JBTOFM=18)
*--EB
      INTEGER JBEBXL,JBEBXH,JBEBOL,JBEBOH,JBEBQL,JBEBQH,JBEBTL,JBEBTH
      PARAMETER (JBEBXL=21,JBEBXH=22,JBEBOL=23,JBEBOH=24,JBEBQL=25,
     +           JBEBQH=26,JBEBTL=27,JBEBTH=28)
*--EE
      INTEGER JBEELR,JBEELL,JBEERL,JBEELH,JBEERH,JBEELP,JBEERP
      PARAMETER (JBEELR=31,JBEELL=32,JBEERL=33,JBEELH=34,JBEERH=35,
     +           JBEELP=36,JBEERP=37)
*--Muon
      INTEGER JBMBH,JBMEL,JBMER,JBMELR,JBMU
      PARAMETER (JBMBH=41,JBMEL=42,JBMER=43,JBMELR=44,JBMU=45)
*--Fdet
      INTEGER JBFSUM,JBFSEG,JBFCSU,JBFCSE,JBFSMA,JBFSGA,JBFCUA,JBFCEA,
     +        JBFFAR,JBFSPC,JBLCAL,JBRCAL,JBFEL, JBFER
      PARAMETER (JBFSUM=51,JBFSEG=52,JBFCSU=53,JBFCSE=54,JBFSMA=55,
     +           JBFSGA=56,JBFCUA=57,JBFCEA=58,JBFFAR=59,JBFSPC=60,
     +           JBLCAL=61,JBRCAL=62,JBFEL=63,JBFER=64)
*--HT
      INTEGER JBHBL,JBHEP,JBHEL,JBHPL,JBHBT,JBHET,JBHAB,JBHA1,JBHA2,
     +        JBHAL,JBHAR, JBHACL
      PARAMETER (JBHBL=65,JBHEP=66,JBHEL=67,JBHPL=68,JBHBT=69,
     +           JBHET=70,JBHAB=99,JBHA1=100,JBHA2=101,JBHAL=110,
     +           JBHAR=111,JBHACL=119)
*--SiW
      INTEGER JBSSGL,JBSSGR,JBSLOL,JBSLOR,JBSWH,JBSSEG,JBSSGA,
     +        JBSSUM,JBSSMA
      PARAMETER (JBSSGL=121,JBSSGR=122,JBSLOL=123,JBSLOR=124,JBSWH=125,
     +           JBSSEG=127,JBSSGA=128,JBSSUM=129,JBSSMA=130)
+SELF,IF=DOC.
+SEQ,GOTPAR.
*     Standard numbers for PAM input signals...
+DECK,GOTRIG.
+KEEP,GOTRIG.
      INTEGER JPAM,JTPTT,JTPTOF,JTPEM,JTPHC,JTPMU
      COMMON/GOTRIG/JPAM(150),JTPTT(6),JTPTOF(3),JTPEM(6),JTPHC(6),
     +              JTPMU(5)
+SELF,IF=DOC.
+SEQ,GOTRIG.
*
*     JPAM(JBxxxx) contains the PAM input signal (0 or 1) xxxx
*     e.g. JPAM(JBTBM1)=1 if TBM1 fires, otherwise zero.
*
*     JTPTT  contains track trigger theta-phi inputs
*            theta bin 1, phi=1 to 24 in JTPTT(1) ...
*            theta bin 6, phi=1 to 24 in JTPTT(6)
*     JTPTOF contains ToF theta-phi inputs (bits 1-24)
*            N.B. changed to dimension(3) in GOPAL137 (9/9/96)
*     JTPEM  contains ECal theta-phi inputs
*            theta bin 1, phi=1 to 24 in JTPEM(1) ...
*            theta bin 6, phi=1 to 24 in JTPEM(6)
*     JTPHC  contains HCal theta-phi inputs
*            theta bin 1, phi=1 to 24 in JTPHC(1) ...
*            theta bin 6, phi=1 to 24 in JTPHC(6)
*     JTPMU  contains Muon theta-phi inputs
*            ME theta bin 1, phi=1 to 24 in JTPMU(1)
*            ME theta bin 2, phi=1 to 24 in JTPMU(2)
*            MB              phi=1 to 24 in JTPMU(3)
*            ME theta bin 5, phi=1 to 24 in JTPMU(4)
*            ME theta bin 6, phi=1 to 24 in JTPMU(5)
+DECK,GOXMIX.
+KEEP,GOXMIX.
      INTEGER MXXMIX
      PARAMETER (MXXMIX=2)
      REAL XMIX
      SAVE /GOXMIX/
      COMMON /GOXMIX/ XMIX(MXLIFE)
+DECK,GOUNIT.
+KEEP,GOUNIT.
      INTEGER LGSAVE,LGGET,LGCAP,LGRAW
      COMMON/GOUNIT/LGSAVE,LGGET,LGCAP,LGRAW
      CHARACTER*4 CCSAVE(20),CCGET(20)
      COMMON/GOCSAV/CCSAVE,CCGET
+SELF,IF=DOC.
+SEQ,GOUNIT.
*-- Logical units for SAVE, GET , CAPture file and RAW data
+DECK,GOVERS.
+KEEP,GOVERS.
      INTEGER IGOVER,IGOSVE,IGEVER,LASTMO
      COMMON/GOVERS/IGOVER,IGOSVE,IGEVER,LASTMO
+SELF,IF=DOC.
*     IGOVER = GOPAL version number
*     IGOSVE = GOPAL sub-version number
*     IGEVER = GEANT version number
*     LASTMO = date of last CRADLE modification of GOPAL.
+DECK,GOXTRA.
+KEEP,GOXTRA.
      INTEGER MXXTRA
      PARAMETER (MXXTRA=100)
      INTEGER NWXTRA
      REAL RXTRA
      COMMON /GOXTRA/ NWXTRA,RXTRA(MXXTRA)
+DECK,HBDLNT.
+KEEP,HBDLNT.
C     29-APR-93: Add links LHTXB, LHTXD
      INTEGER LHBTMP
      INTEGER LHTSB,LHTTB,LHTSD,LHTTD,LLAST,LHTXB,LHTXD
      COMMON/HBDLNT/LHBTMP(2),LHTSB(2),LHTTB(2),LHTSD,LHTTD,
     +LHTXB(2),LHTXD,LLAST
*
      INTEGER NWHTSD
      INTEGER JIFLAG,JIMCTR,JXLOC, JYLOC
      INTEGER JANGLE,JYPROJ,JXCELL,JQIND
      PARAMETER (NWHTSD=8)
      PARAMETER (JIFLAG=1,JIMCTR=2,JXLOC=3, JYLOC=4,
     +           JANGLE=5,JYPROJ=6,JXCELL=7,JQIND=8)
*
      INTEGER NWHTTD
      PARAMETER (NWHTTD=9)
+SELF,IF=DOC.
+SEQ,HBDLNT.
*
*  Sequence HBDLNT.
*
*  Temporary link area /HBDLNT/, used in HBDIGI:
*  LHTSB  Link to temporary strip bank, one per wedge end.
*  LHTTB  Link to temporary tower bank, one per halfwedge.
*  LHTXB  Link to temporary tower X-talk bank, one per halfwedge.
*  LHTSD  Link to temporary strip data bank.
*  LHTTD  Link to temporary tower data bank.
*  LHTXD  Link to temporary tower X-talk data bank.
*
*  Parameters to describe the temporary strip bank:
*  NWHTSD  Number of words per strip hit.
*
*  Offsets in HTSB, see bank description.
+SELF.
+DECK,HBLDXY.
+KEEP,HBLDXY.
      COMMON /HBLDXY/ COSTH(18),XWEDGE(9),NWIREL(9),Z0PACK(9)
      INTEGER NWIREL
      REAL    COSTH, XWEDGE, Z0PACK
      INTEGER    NHDIM, NDDIM
      PARAMETER (NHDIM = 10, NDDIM = 2)
      REAL       XWIDTH, XDEAD
C     Change XWIDTH, XDEAD (9-MAY-93)
      PARAMETER (XWIDTH = 1.0, XDEAD = 0.1)
C      PARAMETER (XWIDTH = 1.1, XDEAD = 0.15)
      REAL       OBSL, PCMEAN, PCSIG
      PARAMETER (OBSL = 0.55, PCMEAN = 8.0, PCSIG  = 6.0)
      INTEGER    IADCMX, IADCMN
      REAL       PCADC, PED, PEDSG
      PARAMETER (IADCMX = 4096, IADCMN = 20)
      PARAMETER (PCADC  = 0.50, PED    = 10.0, PEDSG = 2.0)
+SELF,IF=DOC.
+SEQ,HBLDXY.
*
*  HBLDXY     Common block(s) with Hadron Barrel specific quantities.
*
*  COSTH     The cosine theta values of the Tower boundaries.
*            There are 17 towers, hence 18 values.
*  XWEDGE    The halfwidth of the wedge at each of the nine layers,
*            or the maximum X value in local wedge coordinates.
*  NWIREL    The number of wires in each layer, divided by
*            two for left-right symmetry.
*  Z0PACK    The Z coordinate (in the Master frame) of the
*            division between two packages. Tower 9 belongs
*            to END 1 or 2 depending on the layer.
*
*  All quantities are initialized in HBGINT.
*
*    Parameters:
*
*  NHDIM     The number of values in the HIT banks:
*            (1-3): X,Y,Z  (4-6): Px, Py, Pz  (7): IPART
*            (8): PLPARL, (9): PLPERP, (10): XLOC
*  XWIDTH    The width (and height) of a Iarocci tube.
*  XDEAD     The thickness of a wall between two tubes.
*  OBSL      The obscuration length, unit of length in which
*            roughly one streamer is produced.
*  PCMEAN    Mean charge in picoCoulomb deposited by one streamer.
*  PCSIG     RMS value on PCMEAN.
*  IADCMN    Minimum ADC counts.
*  IADCMX    Maximum ADC counts.
*  PCADC     Number of picoCoulombs per ADC count.
*  PED       ADC pedestal
*  PEDSG     spread in the pedestal.
*
*     ******************************************************************
+SELF.
+DECK,HEDLNT.
+KEEP,HEDLNT.
      INTEGER LHETMP
      INTEGER LHTSB,LHTTB,LHTSD,LHTTD,LLAST
      COMMON/HEDLNT/LHETMP(2),LHTSB(4),LHTTB(4),LHTSD,LHTTD,LLAST
*
      INTEGER NWHTSD
      INTEGER JIFLAG,JIMCTR,JXM,   JYM
      INTEGER JANGLE,JXPROJ,JYCELL,JQIND
      PARAMETER (NWHTSD=8)
      PARAMETER (JIFLAG=1,JIMCTR=2,JXM=3,JYM=4,
     +           JANGLE=5,JXPROJ=6,JYCELL=7,JQIND=8)
*
      INTEGER NWHTTD
      PARAMETER (NWHTTD=8)
+SELF,IF=DOC.
+SEQ,HEDLNT.
*
*  Sequence HEDLNT.
*
*  Temporary link area /HEDLNT/, used in HEDIGI:
*  LHTSB  Link to temporary strip bank, one for each quadrant.
*  LHTTB  Link to temporary tower bank, one for each quadrant.
*  LHTSD  Link to temporary strip data bank.
*  LHTTD  Link to temporary tower data bank.
*
*  Parameters to describe the temporary strip bank:
*  NWHTSD  Number of words per strip hit.
*
*  Offsets in HTSB, see bank description.
+SELF.
+DECK,HELDXY.
+KEEP,HELDXY.
      COMMON /HELDXY/ COSTH(3)
      REAL    COSTH
      INTEGER    NWIREL, NWPSLC
      PARAMETER (NWIREL = 298, NWPSLC=50)
      INTEGER    NHDIM, NDDIM
      PARAMETER (NHDIM = 10, NDDIM=2)
      REAL       XWIDTH, XDEAD
      PARAMETER  (XWIDTH = 1.1, XDEAD = 0.15)
      REAL       OBSL, PCMEAN, PCSIG
      PARAMETER  (OBSL = 0.45, PCMEAN = 8.0, PCSIG  = 6.0)
      INTEGER    IADCMX, IADCMN
      REAL       PCADC, PED, PEDSG
      PARAMETER  (IADCMX = 4096, IADCMN = 20)
      PARAMETER  (PCADC  = 0.50, PED    = 10.0, PEDSG = 2.0)
+SELF,IF=DOC.
+SEQ,HELDXY.
*     ****************************************************************
*
*  HELDXY     Common block(s) with Hadron Endcap specific quantities.
*
*  COSTH     The cosine theta values of the Tower boundaries.
*            There are 2 towers, hence 3 values. (tower 1 is
*            close to the beampipe, on both ends.)
*
*  All quantities are initialized in HEGINT.
*
*  Parameters:
*
*  NWIREL    Number of wires in upper half part of the C.
*  NWPSLC    Wires per slice.
*  NHDIM     The number of values in the HIT banks:
*            (1-3): X,Y,Z  (4-6): Px, Py, Pz  (7): IPART
*            (8): PPARP, (9): PPERP,  (10): YLOC,
*            PPARP being the projected track length along the
*            wire, PPERP perpendicular to it and
*            YLOC proportional to the tube number.
*  XWIDTH    The width (and height) of a Iarocci tube.
*  XDEAD     The thickness of a wall between two tubes.
*  OBSL      The obscuration length, unit of length in which
*            roughly one streamer is produced.
*  PCMEAN    Mean charge in picoCoulomb deposited by one streamer.
*  PCSIG     RMS value on PCMEAN.
*  IADCMN    Minimum ADC counts.
*  IADCMX    Maximum ADC counts.
*  PCADC     Number of picoCoulombs per ADC count.
*  PED       ADC pedestal
*  PEDSG     spread in the pedestal.
*
*     ******************************************************************
+SELF.
+DECK,LCZWLN.
+KEEP,LCZWLN.
      INTEGER LLCZWD ,LLCZWM
      PARAMETER (LLCZWD=2 ,LLCZWM=3)
*
      INTEGER LLCZWX ,LLCZWY ,LLCZWZ ,LLCZWR ,LLCZWL ,LLCZWU
     +,       LLCZWV ,LLCZWS ,LLCZWW ,LLCZWQ ,LLCZWO ,LLCZWT
      PARAMETER (LLCZWX=1  ,LLCZWY=2  ,LLCZWZ=3  ,LLCZWR=4
     +,          LLCZWL=5  ,LLCZWU=6  ,LLCZWV=7  ,LLCZWS=10
     +,          LLCZWW=13 ,LLCZWQ=15 ,LLCZWO=19 ,LLCZWT=18)
*
      INTEGER LCZWLN ,LCZWK ,LCZWD ,LCZWM
     +,       LCZWG ,LCZWX ,LCZWY ,LCZWZ ,LCZWR ,LCZWL
     +,       LCZWU ,LCZWV ,LCZWS ,LCZWW ,LCZWQ ,LCZWO ,LCZWT
      COMMON/LCZWLN/LCZWLN(2) ,LCZWK ,LCZWD ,LCZWM
     +,             LCZWG ,LCZWX ,LCZWY ,LCZWZ ,LCZWR ,LCZWL
     +,             LCZWU ,LCZWV ,LCZWS ,LCZWW ,LCZWQ ,LCZWO
     +,             LCZWT
*
+SELF.
+DECK,LINKGO.
+KEEP,LINKGO.
      INTEGER LTEMP,LMCCO,LCHEA,IOWDS
      EQUIVALENCE (LMCCO,LMCC)
      COMMON/ROLINK/LTEMP,LCHEA,IOWDS(10)
+SELF,IF=DOC.
+SEQ,LINKGO
*
* --- /ROLINK/ GOPAL-specific links for the ROPE input data structure
*
+SELF.
+DECK,LINKRA.
+KEEP,LINKRA.
+SEQ,LINKGO.
+SEQ,RCLINK.
+DECK,MBGOCH
+KEEP,MBGOCH
      INTEGER NCHAMS,IDENT
      COMMON/MBGOCH/NCHAMS,IDENT(112)
*
+DECK,MCPSPY.
+KEEP,MCPSPY.
      COMMON /MCPSPY/ SPYLVL,SPYDES,MCPTRAP,MCPETraps,TrigDone,TrigJob,
     +                TimeLeft,TimeLjob,FileSize,FileLimit,DayTime,
     +                StartDate,StartTime,StartRun,StartEvent,
     +                SeedOne,SeedTwo,
     +                LastDate,LastTime,LastRun,LastEvent,
     +                Hostname,JobName,JobId 
      INTEGER      SPYLVL    ! 0 No spying,  1 First and Last
      INTEGER      SPYDES    ! File Handle for spy file
      INTEGER      MCPTRAP   ! 1 Invoke trap for EXTERNAL errors
      INTEGER      MCPETraps ! Count trapped EXTERNAL errors
      INTEGER      TrigJob,TrigDone
      INTEGER      StartDate,StartTime,StartRun,StartEvent
      INTEGER      LastDate,LastTime,LastRun,LastEvent
      INTEGER      SeedOne,SeedTwo
      REAL         TimeLjob,TimeLeft,FileSize,FileLimit,DayTime
      CHARACTER    Hostname*(8),JobName*(12),JobId*(16)
+DECK,MECHPA.
+KEEP,MECHPA.
      REAL PLRES, PPRES, BGRES, PHMAX0, PHCUT
      PARAMETER (PLRES=2.0, PPRES=1.0, BGRES=10.0,
     +    PHMAX0=4000.0, PHCUT=40.0 )
+SELF,IF=DOC.
+SEQ,MECHPA.
*    Muon Endcap CHamber PArameters.
*       PLRES - Gaussian width of peak in parallel strips.
*       PPRES - Gaussian width of peak in perpendicular strips.
*       BGRES - Gaussian width of wider background.
*       PHMAX0- maximum pulse height on a strip.
*       PHCUT - minimum pulse height detected on a strip.
+SELF.
+DECK,MEGEPA.
+KEEP,MEGEPA.
      REAL SWID,SWIPL,CMEME,CMEMD,SMAGAP
      REAL EDGLO(4,6,2)
*
      REAL GSQDXL,GSQDYL,GSPAXL,GSPAYL
      REAL QDXLEN,PAXLEN,QDYLEN,PAYLEN,QDZLEN
      REAL PMEX,PMEY,PMEZ,PMODY,PMODYH,PMODZ,GASY,GASZ
      REAL PME(3), PMEQD(3), PMEPA(3)
      REAL PMEM1(3),PMEM2(3),PMEM3(3),PMEM4(3),PMEM5(3)
      REAL PMEG1(3),PMEG2(3),PMEG3(3),PMEG4(3),PMEG5(3)
*
      PARAMETER (GSQDXL=264.65, GSQDYL=304.05,
     +           GSPAXL=135.05, GSPAYL=118.05)
      PARAMETER(PMEX=690.0,PMEY=660.0,PMEZ=45.0)
      PARAMETER(QDXLEN=270.8,PAXLEN=135.05,QDYLEN=304.65,PAYLEN=118.3,
     +      QDZLEN=1.9)
      PARAMETER(PMODY=33.5,PMODYH=16.75,PMODZ=0.92,GASY=0.45,GASZ=0.45)
+SELF,IF=DOC.
+SEQ,MEGEPA.
*    Muon Endcap GEometric PArameters.
*    Version of 19 June 89.
*       QDXLEN,QDYLEN,QDZLEN,PAXLEN,PAYLEN- are the half-lengths (as
*               required by GEANT) in X,Y,Z of the QuaDrants and
*               PAtches.
*       GSQDXL, GSQDYL, GSPAXL, GSPAYL - are the half-lengths of the
*               gas tubes that go inside the above Quads & Patches.
*       PMEX,PMEY,PMEZ- ditto for the Muon Endcap.
*       EDGLO(n,n,n)- working edges are set for the chambers; they
*               are calculated from the Frame reference positions of
*               the Muon Endcap, and are labelled as follows :
*  Muon Endcap: Definitions of the edges, EDGLO(a,b,c).
*                               Y
*    a=KPL (flatbed no.)        |
*                       (a,1,1)     (a,6,1)       (a,2,1)
*           ----------------|   |    --|-------------|
*          |                |   |   |  |             |
*          |                |       |  |             |
*          |              -------------|             |
*          |  (b=1)      |  |       |  |    (b=2)    |
*          |             |  | (b=6) |  |             |
*          |             |  |       |  |             |
*          |              -------------  <<(a,6,2)   |
*  X <<----|----------------|       |----------------|
* (a,1,2)>>|----------------|       |----------------| <<(a,2,2)
*          |              -------------              |
*          |             |  |       |  |             |
*          |             |  | (b=5) |  |    (b=3)    |
*          |  (b=4)      |  |       |  |             |
*          |              -------------| <<(a,5,2)   |
*          |                |       |  |             |
*          |                |       |  |             |
* (a,4,2)>> ----------------|        --|-------------| <<(a,3,2)
*                           |          |             |
*                        (a,4,1)    (a,5,1)       (a,3,1)
*
*   ME  is the envelope, a box, of the Muon Endcap at the
*        end of Opal. The size is defined by PME(3), which give the
*        the half-lengths of the volume as required by GEANT.
*   Each ME is filled with QuaDrants MEQD plus small patches MEPA.
*     PMEQD(3) gives the half-lengths of the envelope of the quadrants.
*   MEPA are positioned below and above the beam pipe.
*     PMEPA(3) gives the half-lengths of the envelope.
*   PMEMn give the sizes of the chamber-modules. There are 5 such
*       modules - 4 different lengths, and 1 of half-width.
*   The modules, MEMn, are divided into units, MEUn.
*   The active gas-tubes, MEGn, are placed in the units, MEUn.
*       PMEGn gives half-lengths of MEGn. There are 4 different
*              lengths (with an extra module of half-width).
+SELF.
+DECK,MEMXPA.
+KEEP,MEMXPA.
      INTEGER NHMAX, NSTRMX, ITRS, NUMVS(4)
      INTEGER NUMVS1,NUMVS2,NUMVS3,NUMVS4
      PARAMETER (NHMAX=100,NSTRMX=100)
      PARAMETER(ITRS=0)
      PARAMETER(NUMVS1=0,NUMVS2=0,NUMVS3=0,NUMVS4=0)
+SELF,IF=DOC.
+SEQ,MEMXPA.
*    Muon Endcap MaXimum value PArameters.
*       NHMAX - maximum number of hits in a detector.
*       NSTRMX- maximum number of strips with signal in a plane.
*       Set tracks (ITRS) and detectors (NUMVSn).(0 means all)
*         (NUMVSn will be set to NUMVS(n) in program.)
+SELF.
+DECK,MEPAT.
+KEEP,MEPAT.
      INTEGER         IPATD,  NPAT, IPAT
      LOGICAL         PATCH
      PARAMETER      (IPATD=1,NPAT=1)
      COMMON /MEPATI/ IPAT
      COMMON /MEPATL/ PATCH
+SELF,IF=DOC.
*
*    MEPATCH defines whether or not ME "patch" chambers are
*            to be included in the simulation. This is the
*            default for GOPAL123. To run WIHTOUT "patch"
*            chambers, one must specify the data card
*            MEPATCH    0
*    IPAT    >  0   ==> patch chambers ARE in GOPAL (default).
*            <= 0             "        NOT      "
*
+SELF.
+DECK,METRTH.
+KEEP,METRTH.
*
*    METRTH Card to set Muon Endcap trigger thresholds.
*             1st = Perpendicular Threshold       (default = 350)
*             2nd = Parallel Threshold            (default = 350)
*
      INTEGER         NMETRT
      PARAMETER      (NMETRT=2)
      INTEGER         JTHRPP,JTHRPL
      COMMON /METRTH/ JTHRPP,JTHRPL
+DECK,MMCHEA.
+KEEP,MMCHEA.
*--
*--        MUON BARREL/ENDCAP CHEAT BANK
*--
*--         Q(LMBCH+1) is the MMCHLN, the number of words per hit.
*--         Q(LMBCH+2) is the total number of hits (MB or ME) for the ev
*--  Following this,
*--  For each original GOPAL hit, MMCHLN words as follows:-
*--     1 - 3: x, y, z.
*--     4 - 6: Px, Py, Pz.
*--         7: length of track in sensitive volume.
*--         8: particle identity (GEANT convention).
*--         9: track number (GEANT track no. of track causing hit or of
*--            generating track causing hit, since
*--            GEANT does not keep all tracks).
*--        10: vertex number (GEANT vertex no. of track... etc.).
*--
          INTEGER MMCHLN,JMCHXX,JMCHYY,JMCHZZ,JMCHPX,JMCHPY,JMCHPZ,
     +            JMCHLN,JMCHTY,JMCHTK,JMCHVX
          PARAMETER(MMCHLN=10, JMCHXX=1, JMCHYY=2, JMCHZZ=3,
     +              JMCHPX=4,  JMCHPY=5, JMCHPZ=6, JMCHLN=7,
     +              JMCHTY=8,  JMCHTK=9, JMCHVX=10 )
+DECK,PBPARG
+KEEP,PBPARG
*--
      INTEGER IPEXGR ,IPEXLN ,IPEXTT ,IPCELH ,IPWALH , IPCELW ,IPWALW ,
     +IPSHFT ,IPPCLN ,IPPCW1 , IPPCW2 ,IPPCW3 ,IPPCW4 ,IPPCT1 ,IPPCT2 ,
     +IPRMIN ,IPPCR1 ,IPPCR2 ,IPPCR3 ,IPPCR4 , IPEXRI ,IPEXRO ,IPCEWI ,
     +IPWTWI ,IPCEWO , IPWTWO ,IPEXWI ,IPEXWO ,IPEINT ,IPSEWI , IPSEWO ,
     +IPDPHI , NGPAR
      REAL GPAR
      PARAMETER (IPEXGR= 1,IPEXLN= 2,IPEXTT= 3,IPCELH= 4,IPWALH= 5,
     +IPCELW= 6,IPWALW= 7,IPSHFT= 8,IPPCLN= 9,IPPCW1=10, IPPCW2=11,
     +IPPCW3=12,IPPCW4=13,IPPCT1=14,IPPCT2=15, IPRMIN=16,IPPCR1=17,
     +IPPCR2=18,IPPCR3=19,IPPCR4=20, IPEXRI=21,IPEXRO=22,IPCEWI=23,
     +IPWTWI=24,IPCEWO=25, IPWTWO=26,IPEXWI=27,IPEXWO=28,IPEINT=29,
     +IPSEWI=30, IPSEWO=31,IPDPHI=32, NGPAR=32)
      DIMENSION GPAR(NGPAR)
+DECK,PBPARD.
+KEEP,PBPARD.
*--
      INTEGER JEXGR ,JEXRI ,JEXRO ,JPICCB ,JTOADC , JUVTOW ,JADTYP ,
     +JADUVW,JADSEC,JADFLG , JEXGWI ,JDTW1I ,JWTOWI ,JSTRWI ,JOBSLN ,
     +JEFFIN,JEFFOU,JZPREC ,JDZONE ,JDBLPB , JDBLAM ,JSIGAV ,JSIGST ,
     +JUVREL ,JPEDFL, JTRSHS ,JTRSHW ,JWLEN2 ,JCQDIV ,JADU , JADV ,
     +JADWI,JADWO ,JEXGWO ,JWTOWO , JSTRWO ,JDTW1O ,JRPHSF ,JRPMII ,
     +JRPMIO, JRPHWI ,JRPHWO, JSIGWZ, JWACO, JPEDFS, JSIGSA, JSIGSL,
     +JSIGSH, JZSLOP, JDEDX1, JDEDXM, JLSUPP, JSOFFS, JSUPP1, JSUPP2,
     +JPPREC, NDPAR
      REAL DPAR
      PARAMETER (JEXGR = 1,JEXRI = 2,JEXRO = 3,JPICCB= 4,JTOADC= 5,
     + JUVTOW= 6,JADTYP= 7,JADUVW= 8,JADSEC= 9,JADFLG=10,JEXGWI=11,
     + JDTW1I=12,JWTOWI=13,JSTRWI=14,JOBSLN=15,JEFFIN=16,JEFFOU=17,
     + JZPREC=18,JDZONE=19,JDBLPB=20,JDBLAM=21,JSIGAV=22,JSIGST=23,
     + JUVREL=24,JPEDFL=25,JTRSHS=26,JTRSHW=27,JWLEN2=28,JCQDIV=29,
     + JADU  =30,JADV  =31,JADWI =32,JADWO =33,JEXGWO=34,JWTOWO=35,
     + JSTRWO=36,JDTW1O=37,JRPHSF=38,JRPMII=39,JRPMIO=40,JRPHWI=41,
     + JRPHWO=42,JSIGWZ=43,JWACO =44,JPEDFS=45,JSIGSA=46,JSIGSL=47,
     + JSIGSH=48,JZSLOP=49,JDEDX1=50,JDEDXM=51,JLSUPP=52,JSOFFS=53,
     + JSUPP1=54,JSUPP2=55,JPPREC=56,NDPAR =56)
      DIMENSION DPAR(NDPAR)
*
+DECK,PECALI.
+KEEP,PECALI.
***********************************************************************
* Constants for the calibration of the signals in PE
* Note that a slight nonlinearity of the signals has been found in data.
* To approximately simulate this, the signals are assumed to be
* perfectly linear, but with an offset (PEDESTAL).
*     COMMON-block PECALI with variables PECAYY and PEOFYY.
*     PECAYY are the calibration constants and PEOFYY the pedestals.
*     For the meaning of YY see DECK PESIGN.
*
***********************************************************************
      REAL PECABP, PECABS, PECABW, PECASP, PECASS
      REAL PEOFBP, PEOFBS, PEOFBW, PEOFSP, PEOFSS
      COMMON /PECALI/ PECABP, PECABS, PECABW, PECASP, PECASS,
     +                PEOFBP, PEOFBS, PEOFBW, PEOFSP, PEOFSS
*
+DECK,PECDIF.
+KEEP,PECDIF.
***********************************************************************
* Constants for the simulation of charge diffusion in the graphit layer.
*
*     It is
*       PERCHB  The radius of the carge distribution in the bag chambers
*       PERCHS  same for the small chamber.
*
***********************************************************************
      REAL PERCHB, PERCHS
      COMMON /PECDIF/ PERCHB, PERCHS
*
+DECK,PEGPAR.
+KEEP,PEGPAR.
***********************************************************************
* Paremeters of PE for use by TE
*
*  PARPE   Parameters of PE polycone
*  TESPAC  Shift of PE to make room for TE
*
***********************************************************************
      REAL PARPE,TESPAC
      DIMENSION PARPE(24)
      COMMON/PEGPAR/PARPE,TESPAC
*
+SELF.
+DECK,PENOIS.
+KEEP,PENOIS.
***********************************************************************
* Constants for the simulation of noise clusters in PE
*     COMMON-block PENOIS with variables PEXXYY
*     It is
*       XX   NC: number of noise clusters
*            PH: pulseheight of noise clusters
*            ML: multiplicity of noise clusters
*       YY   BP: pads of big chambers
*            BS: strips of big chambers
*            BW: wires of big chambers
*            SP: pads of small chambers
*            SS: strips of small chambers
*     In those varibales the probabilities to get a certain number of
*     clusters,pulseheight or multiplicity is stored where the number
*     of cluisters, the pulseheight or the multiplicity is given by
*     the index of the array.
*     (For the pulseheights this is only true for the minimal
*      pulseheight stored in PEPHYY(4). The probability is stored in
*     PEPHYY(1). For higher pulses an exponential parametrisation is
*     used. It is given by PEPHYY(2)*exp(-PEPHYY(3)*pulseheight).)
*     For example PENCBS(2) gives the probability to find two noise
*     clusters on the strips.
*     The probabilities are given per event and per sector.
*     They are assumed to be equal for all sectors.
*
*     !Attention! Probabilities in PENCYY above 1% are not suported.
*                 They are automatically cut to 1%!
*
***********************************************************************
      REAL PENCBP, PENCBS, PENCBW, PENCSP, PENCSS
      REAL PEPHBP, PEPHBS, PEPHBW, PEPHSP, PEPHSS
      REAL PEMLBP, PEMLBS, PEMLBW, PEMLSP, PEMLSS
      DIMENSION PENCBP(5), PENCBS(5), PENCBW(5), PENCSP(5), PENCSS(5)
      DIMENSION PEPHBP(4), PEPHBS(4), PEPHBW(4), PEPHSP(4), PEPHSS(4)
      DIMENSION PEMLBP(5), PEMLBS(5), PEMLBW(5), PEMLSP(5), PEMLSS(5)
      COMMON /PENOIS/ PENCBP, PENCBS, PENCBW, PENCSP, PENCSS,
     +                PEPHBP, PEPHBS, PEPHBW, PEPHSP, PEPHSS,
     +                PEMLBP, PEMLBS, PEMLBW, PEMLSP, PEMLSS
*
+DECK,PERESO.
+KEEP,PERESO.
***********************************************************************
* Constants for the simulation of the resolution of the signals.
* The width of the signals is assumed to increase linear with the
* pulseheight with a constant term added in quadrature.
*
*     It is
*       PERSYY(1)   The constant term.
*       PERSYY(2)   The slope.
*     For the meaning of YY see DECK PESIGN.
*
***********************************************************************
      REAL PERSBP, PERSBS, PERSBW, PERSSP, PERSSS
      DIMENSION PERSBP(2), PERSBS(2), PERSBW(2), PERSSP(2), PERSSS(2)
      COMMON /PERESO/ PERSBP, PERSBS, PERSBW, PERSSP, PERSSS
*
+DECK,PESIGN.
+KEEP,PESIGN.
***********************************************************************
* Constants for the simulation of primary signals in PE
*     COMMON-block PESIGN with variables PESIYY
*     It is
*       YY   BP: pads of big chambers
*            BS: strips of big chambers
*            BW: wires of big chambers
*            SP: pads of small chambers
*            SS: strips of small chambers
*     The signals of PE are parametrized by Landau distributions.
*     The widths of these Landau distributions are stored in here.
*
***********************************************************************
      REAL PESIBP, PESIBS, PESIBW, PESISP, PESISS
      COMMON /PESIGN/ PESIBP, PESIBS, PESIBW, PESISP, PESISS
*
+DECK,PESIZE.
+KEEP,PESIZE.
      INTEGER      ISIZPE,NBSEN ,NSSEN ,NUMPAD,NUMDAP
      REAL CHL ,CHWT ,CHWB ,SHL ,SHWT ,SHWB , ZVERTF,ZVERTB,RMI ,ZSMI ,
     +ZSMA ,RSMA , CHTH ,EBW ,EBT ,EBSTA ,EBSTO ,EBET , TCU ,TG10 ,
     +CEDGE ,SEDGE ,DELTAW,RMIWIR, RMIPAD,RMAPAD
      PARAMETER(ISIZPE=82)
      COMMON/PESIZE/ CHL,CHWT,CHWB,SHL,SHWT,SHWB ,ZVERTF,ZVERTB,RMI,
     +ZSMI,ZSMA,RSMA,CHTH ,EBW,EBT,EBSTA,EBSTO,EBET,TCU,TG10 ,CEDGE
     +(4,3),SEDGE(4,2),NBSEN(4),NSSEN(2),DELTAW ,RMIWIR,RMIPAD,RMAPAD,
     +NUMPAD(16),NUMDAP(16)
*
+DECK,PETHRS.
+KEEP,PETHRS.
***********************************************************************
* Readout thresholds and saturation
*     It is
*       PETHYY   thresold for readout
*       PESAYY   threshold for saturation (maximum ADC count)
*     For the meaning of YY see DECK PESIGN.
*
***********************************************************************
      REAL PETHBP, PETHBS, PETHBW, PETHSP, PETHSS
      REAL PESABP, PESABS, PESABW, PESASP, PESASS
      COMMON /PETHRS/ PETHBP, PETHBS, PETHBW, PETHSP, PETHSS,
     +                PESABP, PESABS, PESABW, PESASP, PESASS
*
+DECK,RCEREP,IF=IBM,APOLLO.
+KEEP,RCEREP,IF=IBM,APOLLO.
      INTEGER         NERTOT,NEREVT
      COMMON /RCEREP/ NERTOT,NEREVT
+DECK,SITMED.
+KEEP,SITMED.
* Values for tracking media.
*  MEDAIR			Air
*  MEDAL			Aluminium
*  MEDBEO			Berylium Oxide (same as for ceramic previously)
*  MEDBR			EE Brass
*  MEDFE			Iron
*  MEDG10			G10
*  MEDSGL			Glass - general
*  MEDSI			Silicon
*  MEDSIP			Silicon Plastics
*  MEDSIW			Silicon Detector and chips
*
      INTEGER    MEDAIR,   MEDAL,    MEDBEO,    MEDBR
      PARAMETER (MEDAIR=1, MEDAL=99, MEDBEO=83, MEDBR=72)
      INTEGER    MEDFE,    MEDG10,     MEDSGL,    MEDSI
      PARAMETER (MEDFE=97, MEDG10=106, MEDSGL=83, MEDSI=89)
      INTEGER    MEDSIP, MEDSIW
      PARAMETER (MEDSIP=84, MEDSIW=87)
+DECK,SWMCPM.
+KEEP,SWMCPM.
      INTEGER IDBGLV
      REAL CUTGAM, DEEMAX, GAIN, VGAIN, VTHR, PEDVAL, PEDWID
      LOGICAL LMKRAW
      COMMON /SWMCPM/ IDBGLV, CUTGAM, DEEMAX, GAIN, VGAIN, VTHR,
     +                PEDVAL, PEDWID, LMKRAW
      SAVE /SWMCPM/
+SELF,IF=DOC.
*-- IDBGLV - Debugging level
*-- CUTGAM - GEANT CUTGAM value for SW media
*-- DEEMAX - GEANT DEEMAX value for SW media
*-- GAIN   - Conversion factor from keV to digitizer counts
*-- VGAIN  - Fudge factor to make low- and high-energy regions agree
*-- VTHR   - Threshold for applying the above fudge factor
*-- PEDVAL - Base digitizer pedestal value
*-- PEDWID - Width of the pedestal variation
*-- LMKRAW - Make raw data banks instead of corrected banks
+SEQ,SWMCPM.
+DECK,SWSTOR.
+KEEP,SWSTOR.
      INTEGER IPTR, JLAYER, JWEDGE, JPAD
      COMMON /SWSTOR/ IPTR, JLAYER, JWEDGE, JPAD
      SAVE   /SWSTOR/
+SELF,IF=DOC.
*-- IPTR    - Index into the SWRX bank
*-- JLAYER  - Last layer stored in SWRX
*-- JWEDGE  - Last wedge stored in SWRX
*-- JPAD    - Last pad stored in SWRX
+SEQ,SWSTOR.
+DECK,TBSPEC.
+KEEP,TBSPEC.
      INTEGER NVT,NHT,NHMAXT,NDT,NDMAXT,NTRMAX,NTBAR,NBITT,IDMEDT,ITRST,
     +NUMVST,NHITT,NBITHT,NDIGIT,LTRADT,KDIGIT,NBITDT
      REAL    TPAR,TRAP,ORIGHT,FACTHT
      PARAMETER(NVT=1,NHT=12,NHMAXT=1000,NDT=4,NDMAXT=100,NTRMAX=5)
      COMMON /TBSPEC/ TPAR(3),TRAP(4),NTBAR, NBITT(NVT),IDMEDT
     +,ITRST,NUMVST(NVT),NHITT
     +,NBITHT(NHT),ORIGHT(NHT),FACTHT(NHT)
     +,NDIGIT,LTRADT(NTRMAX),KDIGIT(NDT,NDMAXT)
     +,NBITDT(NDT)
*
      CHARACTER*(4)   NAMT(NVT),NAMHT(NHT),NAMDT(NDT)
      COMMON /TBNAME/ NAMT,NAMHT,NAMDT
+SELF,IF=DOC.
+SEQ,TBSPEC.
*==========================   VOLUMES  =================================
*
*  nvt         : # of  hits or digits referenced volumes   (1)
*  numvst(i)   : level volumes referenced
*  nbvht(i,j)  : # of volume i of hit j
*
*==========================   HITS  ====================================
*
*  nht         : # of elementary information per hit   (12)
*  nhmaxt      : max # of hits per event             (1000)
*  nhitt       : # of hits of current event
*  hitt(i,j)   : value of elementary info i of hit j
*  ltraht(i)   : # of track responsible of hit i
*  namht(i)    : string name of elementary info i
*      (xin ,yin ,zin ,xout,yout,zout,de  ,tofin ,pin ,dlen,sleng,tofout)
*  nbitht(i)   : # of bits to store elementary info i
*               ( 16, 16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 32)
*  oright(i)   : offset origin to store integers
*  factht(i)   : scale factor to store integers
*
*==========================   DIGITS  ==================================
*
*  ndt         : # of elementary information per digi      (4)
*  ndmaxt      : max # of digit per event                (100)
*  ntrmax      : max # of track contributing to a digit    (5)
*  ndigit      : # of digit of current event
*  ltradt(i)   : list of tracks contributing to 1 digit
*  ntradt      : max # of tracks  contributing to 1 digit
*  kdigit(i,j) : value of elementary info i of digit j
*  namdt(i)    : string name of elementary info i   (adc1,adc2,tdc1,tdc2
*  nbitdt(i)   : # of bits to store elementary info i    (32,32,32,32)
*                (realistic will be 12,12,12,12)
*
*=======================================================================
+DECK,TBCONS.
+KEEP,TBCONS.
      REAL            ADCSCL,TDCSCL,VSINV,SSINV
     +,ATTCO   ,SIGCO   ,PEGEV,TGATE,ADCMIN
      COMMON /TBCON2/ ADCSCL,TDCSCL,VSINV,SSINV
     +,ATTCO(5),SIGCO(5),PEGEV,TGATE,ADCMIN
+SELF,IF=DOC.
+SEQ,TBCONS.
*     ADCSCL    adc scale factor (adc-channel/photo-electron)
*     TDCSCL    TDC scale factor (tdc-channel/pico-second)
*     ATTCO     attenuation length coeficients in scintillator
*     SIGCO     time resolution coefficients as distance function
*     SSINV     inverse light speed in scintillator (pico-second/cm)
*     PEGEV     photo-electrons/GeV of NE110 (including cathode
*               efficiency but no attenuation length)
*     TGATE     gate width for ADC
*     ADCMIN    minimum amplitude for TDC
*
+SELF.
+DECK,TEDATA.
+KEEP,TEDATA.
*
* -- Values for the dimensions of the tiles.
* -- Tile-1   bw=17.014, tw=23.133,thickn=1.0, length=23.239
* -- Tile-2   bw=10.87,  tw=16.85, thickn=1.0, length=47.83
* -- Tile-3   bw=16.85,  tw=22.53, thickn=1.0, length=45.33
* half values for the dimensions of the tiles.
      DATA PTILE1  / 8.507, 11.5665,0.5,  11.6195/
      DATA PTILE2  / 5.435,  8.425, 0.5,  23.915 /
      DATA PTILE3  / 8.245, 11.265, 0.5,  22.665 /
* -- Now the aluminium plate dimensions: plate1=inner small plate
* --                                     plate2=outer small plate
* --                                     plate3=inner big plate
* --                                     plate4=outer big plate
*
      DATA PLATE1  / 8.507, 11.5665,0.05,  11.6195/
      DATA PLATE2  / 8.507, 11.5665, 0.1,  11.6195/
      DATA PLATE3  / 5.651, 11.4616,0.05,  49.73 /
      DATA PLATE4  / 5.651, 11.4616, 0.1,  49.73 /
*
      DATA AIRSEP / 0.5 /
      DATA MEDTIL / 10 /
      DATA NMVLST / 0, 0 /
      DATA NBITVS / 2, 12 /
      DATA NBITHS / 6*16,6*0,0 /
      DATA NBITDS / 2*0 /
      DATA ORIGST / 2*250.,400.,2*250.,400.,6*0.,0. /
      DATA FACTST / 6*50.,1.E+06,1.E+12,1.E+06,100.,10.,1.E+12,1. /
      DATA ITRSST / 0 /
      DATA NMVST1 / 'ECA-','TET1' /
      DATA NMVST2 / 'ECA-','TET2' /
      DATA NMVST3 / 'ECA-','TET3' /
      DATA NAMHST / 'XIN ','YIN ','ZIN ','XOUT','YOUT','ZOUT','DE  ',
     +              'TOFI','PIN ','DLEN','SLEN','TOFO','ID  ' /
      DATA NAMDST / 'TDC ','ADC ' /
      DATA PEGEV  / 5.E+4 /
      DATA TGATE  / 2.E+5 /
      DATA ADCSCL / 0.5 /
      DATA TDCSCL / 0.02 /
      DATA ITDCDF / -1 /
*
+DECK,TEDISEQ.
+KEEP,TEDISEQ.
*
      INTEGER ADCMAX,TDCMAX
      REAL ADCINI, ADCHAF,DTDSCN,DTDSCP,DTTDCN,DTTDCP
      REAL ADCMIN,TFACT,EFACT,DAONE
      PARAMETER (ADCINI = 5.,ADCHAF=12.,DTDSCN = 0.,ADCMIN=24.)
      PARAMETER (DTDSCP = 5000.,DTTDCN = 0.,DTTDCP = 500.)
      PARAMETER (ADCMAX=4095,TDCMAX=2047)
      PARAMETER (TFACT=1.E+12,EFACT=1.E+03,DAONE=5.)
*
+DECK,TESPEC.
+KEEP,TESPEC.
*                                                        VERS date jan-98
* -- These are the common blocks used in various TE routines.
* -- This sequence should always be put before the TEDATA sequence,
* -- and in conjunction with it.
*
      INTEGER     NVST,NHST,NHMXST,NDST,NTRMAX
      PARAMETER  (NVST=2,NHST=13,NHMXST=50,NDST=2,NTRMAX=5)
      REAL        PTILE1,PTILE2,PTILE3,AIRSEP,PLATE1,PLATE2,
     +            PLATE3,PLATE4
      INTEGER     MEDTIL
      DIMENSION   PTILE1(4),PTILE2(4),PTILE3(4),PLATE1(4),PLATE2(4),
     +            PLATE3(4),PLATE4(4)
C      COMMON / TEGEOD / PTILE1(4),PTILE2(4),PTILE3(4),
C     +                  AIRSEP,MEDTIL,PLATE1(4),PLATE2(4),
C     +                  PLATE3(4),PLATE4(4)
      INTEGER     ITRSST
      INTEGER     NBITVS,NBITHS,NBITDS,NMVLST
      REAL        ORIGST,FACTST
      DIMENSION   NBITVS(NVST),NMVLST(NVST),NBITHS(NHST),ORIGST(NHST),
     +            FACTST(NHST),NBITDS(NDST)
C      COMMON / TEDIGD / NBITVS(NVST),NMVLST(NVST),ITRSST,NHITST,
C     +NBITHS(NHST),ORIGST(NHST),FACTST(NHST),NBITDS(NDST)
*
      CHARACTER*4 NAMHST,NAMDST,NMVST1,NMVST2,NMVST3
      DIMENSION   NAMHST(NHST),NAMDST(NDST),
     +            NMVST1(NVST),NMVST2(NVST),NMVST3(NVST)
      REAL        PEGEV,TGATE,ADCSCL,TDCSCL,ITDCDF
*
+DECK,TELCAL.
+KEEP,TELCAL.        Links for the calibration banks
* Sequence TELCAL:
*      COMMON /TELCAL/
*      SAVE   /TELCAL/
*      INTEGER
*      PARAMETER ()
*      PARAMETER ()
*      PARAMETER ()
*      PARAMETER ()
*. +SELF,IF=TEDOC,DOC.
*-- LTE... - Pointer to TE calibration top bank
*-- LTE...  - Pointer to ...
+DECK,TELCHE.
+KEEP,TELCHE.        Links for the cheat banks
* Sequence TELCHE:
*
      INTEGER LTEMC, LTEN, LTED, LTECHZ
      COMMON /TELCHE/ LTEMC, LTEN, LTED, LTECHZ
      SAVE   /TELCHE/
      INTEGER LLTEMC, LLTEN, LLTED
      PARAMETER (LLTEMC = 1)
      PARAMETER (LLTEN  = 1)
      PARAMETER (LLTED  = 1)
*. +SELF,IF=TEDOC,DOC.
*-- LTEMC - Pointer to TE top cheat bank
*-- LTEN  - Pointer to ...
*-- LTED  - Pointer to ...
+DECK,TELDAT.
+KEEP,TELDAT.        Links for the data banks
* Sequence TELDAT:
*
      INTEGER LTERA, LTERD, LTEDZZ
      COMMON /TELDAT/ LTERA, LTERD, LTEDZZ
      SAVE   /TELDAT/
      INTEGER LLTERD
      PARAMETER (LLTERD = 1)
*. +SELF,IF=TEDOC,DOC.
*-- LTERA  - Pointer to TE raw data top bank
*-- LTERD  - Pointer to ...

+DECK,TEBNKS.
+KEEP,TEBNKS.
      INTEGER    NWAMX
      PARAMETER (NWAMX = 150)
      INTEGER    NWTMX
      PARAMETER (NWTMX = 150)
      INTEGER    NWTQ, NWTT
      INTEGER    TEAA, TEAQ, TETA, TET0, TETW
      COMMON / TEBNK / NWTQ, NWTT,  TEAA(NWAMX), TEAQ(NWAMX),
     +                 TETA(NWTMX), TET0(NWTMX), TETW(NWTMX)
C
C..   NWAMAX:     MAXIMUM NUMBER OF TE+MIPPLUG ADC  HITS
C..   NWTMAX:     MAXIMUM NUMBER OF TE+MIPPLUG TIME HITS
C..   NWTQ  :     NUMBER OF TE+MIPPLUG ADC HITS
C..   TEAA  :     ARRAY WITH TE+MIPPLUG ADDRESS FOR ADC HITS
C..   TEAQ  :     ARRAY WITH TE+MIPPLUG CHARGE
C..   NWTT  :     NUMBER OF TE+MIPPLUG TIME HITS
C..   TETA  :     ARRAY WITH TE+MIPPLUG ADDRESS FOR TIME HITS
C..   TET0  :     ARRAY WITH TE+MIPPLUG TIME-ZERO HITS
C..   TETW  :     ARRAY WITH TE+MIPPLUG TIME-WIDTH HITS
C
+KEEP, TESMBK.
      INTEGER NPMTMX
      PARAMETER (NPMTMX = 200)
      INTEGER NPMTHT
      REAL    PMTXI,  PMTYI
      REAL    PMTZI,  PMTXO
      REAL    PMTYO,  PMTZO
      REAL    PMTDE,  PMTTI
      REAL    PMTPI,  PMTDL
      REAL    PMTSL,  PMTTO, PMTID
      COMMON / TESMBK / NPMTHT,
     +                  PMTXI(NPMTMX),PMTYI(NPMTMX),
     +                  PMTZI(NPMTMX),PMTXO(NPMTMX),
     +                  PMTYO(NPMTMX),PMTZO(NPMTMX),
     +                  PMTDE(NPMTMX),PMTTI(NPMTMX),
     +                  PMTPI(NPMTMX),PMTDL(NPMTMX),
     +                  PMTSL(NPMTMX),PMTTO(NPMTMX),PMTID(NPMTMX)
C
C..   NPMTMX:     MAXIMUM NUMBER OF HITS FOR ONE PMT CHANNEL
C..   NPMTHT:     CURRENT NUMBER OF HITS
C
+KEEP,TEDBUG.
      INTEGER NTEPRM
      PARAMETER (NTEPRM=10)
      LOGICAL LTEBUG
C      COMMON /TEDBUG/ LTEBUG
C
C..   TE DEBUG FLAG, SET TO TRUE IF DEBUG IS NEEDED.
C..   THE FLAG IS SET FOR THE FIRST NTEPRM EVENTS
C..   IN THE ROUTINE TEDIGI
C

+DECK,TTASSG
+KEEP,TTASSG
C Jet Lorentz, and Sector Phi angles
      REAL ANLOJ,THETAJ
      ANLOJ=3.14159*15.0/180.0
      THETAJ=3.14159*7.5/180.0
C Range in z/r
      RANGE=3.2
C Jet extension to z/r range
      CJDRA=RANGE*((COS(THETAJ)/COS(THETAJ+ANLOJ))-1)
C Flag enables a calculation of NBIN, and the jet,vertex thresholds
C If set, then JTHR1-3,IVTHR,NBIN are all ignored
      ITHFLG=0
      JTHR1=4
      JTHR2=5
      JTHR3=6
      IVTHR=4
      IHMAX=4
      NBIN=18
C Smearing
      ISM=2
C Vertex enable
C Extra CV , CJ z resolution, efficiency
      VSIGZ=0.0
      CJSIGZ=0.0283
      VEFF=1.0
      CJEFF=1.0
C Translation of the IP ZIP=0.0
C Coincidence parameters
      IOFF=0
      IWIN=2
C Combinatorial Logic
      ICOMB=2
+DECK,TTCAL.
+KEEP,TTCAL.
C
C /TTCAL/ Contains the track trigger calibration constants
C in an unpacked form.
C
C  1....  IHMAX ...This is the no of passes we are dealing with.
C  2....  ICVZR(11,12,36) ... The Z/R LUT Packed in 5 bit chunks
C  3....  ISM   ...The theta smearing.
C  4....  VTHRE(32,24) .. The vertex thresholds.
C  5....  JTHRE(32,24) .. Jet thresholds, packed into 8 bit chunks
C  6....  ICOMB.. The jet combinatorial logic.
C  7....  JRING(12,24).. The Jet ring to which a wire in a given
C   ....   sector belongs. rings 1-3  in bytes 1-3
C  8....  IWIN window size in the coincidence array
C  9....  IOFF offset in the coincidence array
C 10....  IENCV(2) CV sector enable switches Bits 1-18 each word
C 11....  IENCJ(3) CJ sector enable switches bits 1-24 for sector
C 12....  THL(6) THL(I) contains the leftmost TT theta bin
C   ....  in the I'th THETA matrix theta bin (1-32)
C 13....  THR(6) THR(I) contains the rightmost TT theta bin
C   ....  in the I'th THETA matrix theta bin (1-32)
C 14....  BARREL this is the word containing the barrel register.
C 15....  ZSTA(36) is the Z STATUS array for the CV wires (bits 1-12)
C 16....  RANGE is the range in z/r for the processor.
C 17....  NBIN is the no of theta bins used.
C 18....  JPRE bit i is 1 if the Jet axis coinc chip i is preset
C 19....  VPRE bit i is 1 if the Vertex axis of coinc chip i is preset
C 20....  HCTH(4) the Hit Count thresholds for CV and CJ rings 1 to 3
C
      INTEGER ISM,NBIN,IHMAX,ICOMB,IWIN,IOFF,BARREL
      INTEGER VTHRE,JTHRE,ICVZR,JRING,IENCV,IENCJ,THL,THR
      INTEGER ZSTA,JPRE,VPRE,HCTH
      REAL RANGE
      COMMON/TTCAL/RANGE,ISM,NBIN,IHMAX,ICOMB,IWIN,IOFF,BARREL,
     + VTHRE(32,24),JTHRE(32,24),ICVZR(11,12,36),
     + JRING(12,24),IENCV(2),
     + IENCJ(3),THL(6),THR(6),ZSTA(36),JPRE,VPRE,
     + HCTH(4)
+DECK,TTCOMM.
+KEEP,TTCOMM.
      INTEGER ICV,ICJ,ICVS,ICJS,CVDEC,CJDEC
      INTEGER DEC,THMAT,PHIPR,THEPR,DILPR,DIRPR
      COMMON/TTTF/ICVS(32,24),ICJS(32,24),CVDEC(24),CJDEC(24)
      COMMON/TTTRAK/DEC(24),THMAT(24)
      COMMON/TTPROJ/PHIPR(2),THEPR(2),DILPR(2),DIRPR(2)
      COMMON/TTZR/ICV(32,36),ICJ(32,24)
C         TTVAL(1) is the multiplicity
C         TTVAL(2) is the barrel multiplicity
C         TTVAL(3) is the CV hit count
C         TTVAL(4) is the CV wire count
C         TTVAL(5) is the CJ1 hit count
C         TTVAL(6) is the CJ1 wire count
C         TTVAL(7) is the CJ2 hit count
C         TTVAL(8) is the CJ2 wire count
C         TTVAL(9) is the CJ3 hit count
C         TTVAL(10) is the CJ3 wire count
C
      INTEGER TTVAL
      COMMON/TTOINT/ TTVAL(10)
+DECK,TTVARI.
+KEEP,TTVARI.
      INTEGER JTHR1,JTHR2,JTHR3,IVTHR,ITHFLG
      REAL VSIGZ,CJSIGZ,VEFF,CJEFF,ZIP,CVDRA,CJDRA
      COMMON/TTCHAM/VSIGZ,CJSIGZ,VEFF,CJEFF,ZIP,CVDRA,CJDRA
      COMMON/TTTHPS/JTHR1,JTHR2,JTHR3,IVTHR,ITHFLG
+DECK,TTZRSI.
+KEEP,TTZRSI.
      INTEGER NWIR,ISZR,IHSIM,IWSIM
      COMMON/SIM/ NWIR(36,12),ISZR(36,12,6),IHSIM(36),
     +IWSIM(36)
+PATCH,BATCH.
+DECK,MAIN.
      PROGRAM GOPAL
*.
*...MAIN   The main routine for the BATCH version of GOPAL.
*.
*.
*. COMMON    : BLANKC GCBANK GCFLAG
*. CALLS     : ERRREP ERRSET GRUN   GZEBRA HLIMIT TVBGN  TVCAP
*. CALLS     : UGINIT UGLAST
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.10
*. CREATED   : 22-Jun-85
*. LAST MOD  : 26-Feb-97
*.
*.
*.
*. Modification Log.
*. 26-Feb-97   S.W.O'Neale     More EXTERNALs and OPLOAD calls.
*. 21-Sep-94   C.P.Ward        Mods for interactive version with GEANT321
*. 26-Apr-94   C.P.Ward        Mods to OPLOAD calls for ROPE407 processors
*.  3-Mar-92   D.R.Ward        Take all error handling from ROPE
*. 16-Jul-91   S.W.O'Neale     Add calls to OPLOAD
*. 30-May-91   J.N.Banks       Apollo error handling which actually works
*. 26-Feb-90   J.N.Banks       Apollo error handling
*.  5-Jan-90   D.R.Ward        Move EXTERNALs, REBANK init'n to UGINIT
*. 23-Sep-89   D.R.Ward        Initialize REPORT store
*.  9-Mar-89   D.R.Ward        Remove ZPHASE(-1)
*.  1-Mar-89   D.R.Ward        Remove HBOOK3
*. 26-Sep-88   D.R.Ward        Set PHASE for new REPORT
*. 16-Sep-88   D.R.Ward        Add external GUNEAR
*.  6-Sep-88   D.R.Ward        Graphics initialization into UGINIT
*. 21-Jul-88   S.W.O'Neale     Better error handling for IBM
*.  3-May-88   D.R.Ward        A few ERRSET calls for VAX
*. 22-Apr-88   D.R.Ward        Strong type
*.  8-Feb-88   D.R.Ward        Add EXTERNAL
*. 27-Jan-88   D.R.Ward        Test on IEORUN
*. 25-Nov-87   D.R.Ward        Add HBOOK4 option
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*
*
*
+SEQ,DECLARE.
      INTEGER JSPACE,KSPACE
      REAL GEANTS,HBOOKS
+SEQ,GCFLAG.
+SELF,JSPACE.
      PARAMETER (JSPACE=999999)
+SELF.
+SELF,KSPACE.
      PARAMETER (KSPACE= 50000)
+SELF.
*
      COMMON/GCBANK/GEANTS(JSPACE)
      COMMON/PAWC/HBOOKS(KSPACE)
      EXTERNAL GUDIGI
      EXTERNAL GUDTIM
      EXTERNAL GUFLD
      EXTERNAL GUHADR
      EXTERNAL GUKINE
      EXTERNAL GUNEAR
      EXTERNAL GUOUT
      EXTERNAL GUPHAD
      EXTERNAL GUSKIP
      EXTERNAL GUSTEP
      EXTERNAL GUSTFU
      EXTERNAL GUSWIM
      EXTERNAL GUTRAK
      EXTERNAL GUTREV
      EXTERNAL GUVIEW
      EXTERNAL GUPARA
      EXTERNAL GUIGET
      EXTERNAL GUINME
      EXTERNAL GUINTI
      EXTERNAL JUCOMP
      EXTERNAL ZTELUS
      EXTERNAL ZEND
      EXTERNAL QNEXT
      EXTERNAL REPORT
      EXTERNAL RMAIL
      EXTERNAL RFUSER
+SELF,IF=INTERACT.
      EXTERNAL UGINIT
+SELF,IF=GORO.               GORO externals
      EXTERNAL ROUPON
      EXTERNAL ROUVER
      EXTERNAL CVDDUT
      EXTERNAL JCCFTI
      EXTERNAL JCCFSZ
      EXTERNAL JCPACK
      EXTERNAL JCFNTT
      EXTERNAL JCZQER
      EXTERNAL JCZTIM
      EXTERNAL CJBRE4
      EXTERNAL CJDDT4
      EXTERNAL CJFON4
      EXTERNAL CTFXJZ
      EXTERNAL CZPNTR
      EXTERNAL CZUDIG
      EXTERNAL EECAL
      EXTERNAL HPFMUB
      EXTERNAL HPFNMU
      EXTERNAL RGETEB   
      EXTERNAL TRIVSG   
      EXTERNAL TRPGTE   
      EXTERNAL TRINCH   
      EXTERNAL TRPSUM   
      EXTERNAL ODSIPR   
      EXTERNAL TRGANA   
      EXTERNAL PXSORV,PXCONE,PXMAGV   
      EXTERNAL YKERN,YYJET,YNJET,YASSO  
      EXTERNAL RIOSEL   
      EXTERNAL TRPDNZ   
      EXTERNAL ODCSLD   
      EXTERNAL ODDRTR   
      EXTERNAL OPFCSR   
      EXTERNAL TRPIUS   
      EXTERNAL ODCSPR   
      EXTERNAL ODRAD1   
      EXTERNAL TRPANA   
      EXTERNAL SUHC96   
      EXTERNAL RODATE   
      EXTERNAL TRGSUM   
      EXTERNAL ODDXBT,ODR1SI,ODBXYZ,ODTHPH,ODNBCT,ODUPNG  
      EXTERNAL TRSCTL   
      EXTERNAL OPFILT  
+SELF.
+SEQ,RECOVERDEC,IF=-NOERRECO.
+SEQ,RECOVERCODE,IF=-NOERRECO.
      CALL OPLOAD(GUDIGI,'GUDIGI','GOPAL ')
      CALL OPLOAD(GUDTIM,'GUDTIM','GOPAL ')
      CALL OPLOAD(GUFLD ,'GUFLD ','GOPAL ')
      CALL OPLOAD(GUHADR,'GUHADR','GOPAL ')
      CALL OPLOAD(GUIGET,'GUIGET','GOPAL ')
      CALL OPLOAD(GUINME,'GUINME','GOPAL ')
      CALL OPLOAD(GUINTI,'GUINTI','GOPAL ')
      CALL OPLOAD(GUKINE,'GUKINE','GOPAL ')
      CALL OPLOAD(GUNEAR,'GUNEAR','GOPAL ')
      CALL OPLOAD(GUOUT ,'GUOUT ','GOPAL ')
      CALL OPLOAD(GUPHAD,'GUPHAD','GOPAL ')
      CALL OPLOAD(GUSKIP,'GUSKIP','GOPAL ')
      CALL OPLOAD(GUSTEP,'GUSTEP','GOPAL ')
      CALL OPLOAD(GUSTFU,'GUSTFU','GOPAL ')
      CALL OPLOAD(GUSWIM,'GUSWIM','GOPAL ')
      CALL OPLOAD(GUTRAK,'GUTRAK','GOPAL ')
      CALL OPLOAD(GUTREV,'GUTREV','GOPAL ')
      CALL OPLOAD(GUVIEW,'GUVIEW','GOPAL ')
      CALL OPLOAD(GUPARA,'GUPARA','GOPAL ')
*--   If we run GOPAL or GORO we must have Gopal versions of the
*--   event loop, trap and reporting routines.
      CALL OPLOAD(REPORT,'REPORT','GOPAL ')
      CALL OPLOAD(RMAIL ,'RMAIL ','GOPAL ')
      CALL OPLOAD(JUCOMP,'JUCOMP','GOPAL ')
      CALL OPLOAD(ZTELUS,'ZTELUS','GOPAL ')
      CALL OPLOAD(ZEND  ,'ZEND  ','GOPAL ')
      CALL OPLOAD(QNEXT ,'QNEXT ','GOPAL ')
+SELF,IF=INTERACT.
      CALL OPLOAD(UGINIT,'UGINIT','GOPAL ')
+SELF,IF=GORO.
      CALL OPLOAD(RFUSER,'RFUSER','GORO  ')
      CALL OPLOAD(ROUPON,'ROUPON','GORO  ')
      CALL OPLOAD(ROUVER,'ROUVER','GORO  ')
      CALL OPLOAD(CVDDUT,'CVDDUT','GORO  ')
      CALL OPLOAD(JCCFTI,'JCCFTI','GORO  ')
      CALL OPLOAD(JCCFSZ,'JCCFSZ','GORO  ')
      CALL OPLOAD(JCPACK,'JCPACK','GORO  ')
      CALL OPLOAD(JCFNTT,'JCFNTT','GORO  ')
      CALL OPLOAD(JCZQER,'JCFNTS','GORO  ')
      CALL OPLOAD(JCZTIM,'JCFNTP','GORO  ')
      CALL OPLOAD(CJBRE4,'CJBRE4','GORO  ')
      CALL OPLOAD(CJDDT4,'CJDDT4','GORO  ')
      CALL OPLOAD(CJFON4,'CJFON4','GORO  ')
      CALL OPLOAD(CTFXJZ,'CTFXJZ','GORO  ')
      CALL OPLOAD(CZPNTR,'CZPNTR','GORO  ')
      CALL OPLOAD(CZUDIG,'CZUDIG','GORO  ')
      CALL OPLOAD(EECAL ,'EECAL ','GORO  ')
      CALL OPLOAD(HPFMUB,'HPFMUB','GORO  ')
      CALL OPLOAD(HPFNMU,'HPFNMU','GORO  ')
      CALL OPLOAD(  RGETEB ,' ','GORO')
      CALL OPLOAD(  TRIVSG ,' ','GORO')
      CALL OPLOAD(  TRPGTE ,' ','GORO')
      CALL OPLOAD(  TRINCH ,' ','GORO')
      CALL OPLOAD(  TRPSUM ,' ','GORO')
      CALL OPLOAD(  ODSIPR ,' ','GORO')
      CALL OPLOAD(  TRGANA ,' ','GORO')
      CALL OPLOAD(  PXSORV ,' ','GORO')
      CALL OPLOAD(  PXCONE ,' ','GORO')
      CALL OPLOAD(  PXMAGV ,' ','GORO')
      CALL OPLOAD(  RIOSEL ,' ','GORO')
      CALL OPLOAD(  TRPDNZ ,' ','GORO')
      CALL OPLOAD(  ODCSLD ,' ','GORO')
      CALL OPLOAD(  ODDRTR ,' ','GORO')
      CALL OPLOAD(  ODR1SI ,' ','GORO')
      CALL OPLOAD(  ODBXYZ ,' ','GORO')
      CALL OPLOAD(  ODTHPH ,' ','GORO')
      CALL OPLOAD(  ODUPNG ,' ','GORO')
      CALL OPLOAD(  ODNBCT ,' ','GORO')
      CALL OPLOAD(  OPFCSR ,' ','GORO')
      CALL OPLOAD(  YKERN ,' ','GORO')
      CALL OPLOAD(  YYJET ,' ','GORO')
      CALL OPLOAD(  YNJET ,' ','GORO')
      CALL OPLOAD(  YASSO ,' ','GORO')
      CALL OPLOAD(  TRPIUS ,' ','GORO')
      CALL OPLOAD(  ODCSPR ,' ','GORO')
      CALL OPLOAD(  ODRAD1 ,' ','GORO')
      CALL OPLOAD(  TRPANA ,' ','GORO')
      CALL OPLOAD(  SUHC96 ,' ','GORO')
      CALL OPLOAD(  RODATE ,' ','GORO')
      CALL OPLOAD(  TRGSUM ,' ','GORO')
      CALL OPLOAD(  ODDXBT ,' ','GORO')
      CALL OPLOAD(  TRSCTL ,' ','GORO')
      CALL OPLOAD(  OPFILT ,' ','GORO')
+SELF,IF=INTERACT,IF=MOTIF.
      CALL GPAWPP(JSPACE,KSPACE)
+SELF,IF=INTERACT,IF=-MOTIF.
      CALL GPAW(JSPACE,KSPACE)
+SELF,IF=-INTERACT.
      CALL TIMEST(1.0E+06)
*--
*--  Define the space in the common block GCBANK handled by ZEBRA.
      CALL GZEBRA(JSPACE)
*--  Define the space in the common block /    / used by HBOOK.
      CALL HLIMIT(-KSPACE)
*--
*--  Initialisation phase - Call UGINIT.
      CALL UGINIT
*
*     IEORUN .NE. 0 ==> A fatal error has occurred in the initialization
*
      IF(IEORUN.NE.0) GO TO 10
*--
*--  Processing phase - Call GRUN.
      CALL ZPHASE(0)
      CALL GRUN
*--
*--  Termination phase.      Call  UGLAST.
      CALL ZPHASE(-3)
      CALL UGLAST
   10 STOP
+SELF.
      END
+DECK,GODUM,IF=-GKS,IF=-HIGZ.
      SUBROUTINE GUVIEW(I1,I2,I3,I4)
      INTEGER I1,I2,I3,I4
*     Dummy graphics routines - makes the executable file smaller if
*     you don't need them
      END
      SUBROUTINE GDCXYZ
      END
      SUBROUTINE GDSHOW(I1)
      INTEGER I1
      END
      SUBROUTINE GDOPT(I1,I2)
      INTEGER I1,I2
      END
      SUBROUTINE GDPART(I1,I2,I3)
      INTEGER I1,I2,I3
      END
      SUBROUTINE GDHITS(C1,C2,I3,I4,I5)
      INTEGER I3,I4,I5
      CHARACTER*(*) C1,C2
      END
      SUBROUTINE GDCHIT(C1,C2,I1,I2,I3,I4,I5,I6)
      INTEGER I1,I2,I3,I4,I5,I6
      CHARACTER*(*) C1,C2
      END
      SUBROUTINE GDXYZ(I1)
      INTEGER I1
      END
      SUBROUTINE GDCOL(I1)
      INTEGER I1
      END
      SUBROUTINE GDINIT
      END
      SUBROUTINE HPLSOF(I1,I2,C1,I3,I4,I5,I6)
      INTEGER I1,I2,I3,I4,I5,I6
      CHARACTER*(*) C1
      END
      SUBROUTINE IGINIT(I1)
      INTEGER I1
      END
      SUBROUTINE IGSSE(I1,I2)
      INTEGER I1,I2
      END
      SUBROUTINE IGMETA(I1,I2)
      INTEGER I1,I2
      END
      SUBROUTINE ICLRWK(I1,I2)
      INTEGER I1,I2
      END
      SUBROUTINE IGEND
      END
      SUBROUTINE IPM(I1,I2,I3)
      INTEGER I1,I2,I3
      END
      SUBROUTINE ISPMCI(I1)
      INTEGER I1
      END
+DECK,RODUM,IF=NOROPE.
      SUBROUTINE GOROPB
*     The PATCHY switch NOROPE stops GOPAL calling routines from ROPE
*     (apart from utilities).
*     n.b. note GOROPI is still needed - it initializes divisions,
*     data structures etc.
      END
      SUBROUTINE GOROPS
+SEQ,DECLARE.
+SEQ,RCHTOP.
*     May need this to keep EECALR quiet!
      CHTREE='    '
      END
      SUBROUTINE RFUSER
      END
      SUBROUTINE GOROPF
      END
+DECK,RNDM,IF=RNDM.
      FUNCTION RNDM(I)
*
*     Routines to test GEANT313 which uses GRNDM
*
      REAL RNDM,R
      INTEGER I,NSOFAR
+SEQ,RCREP.
      SAVE NSOFAR
      DATA NSOFAR/0/
      NSOFAR=NSOFAR+1
      IF(NSOFAR.LT.1000) THEN
         CHREP='RNDM called !!!'
         CALL REPORT('RNDM',1,'I')
      ELSEIF(NSOFAR.EQ.1000) THEN
         CHREP='> 1000 calls to RNDM - stop REPORTing'
         CALL REPORT('RNDM',2,'I')
      ENDIF
      CALL GRNDM(R,1)
      RNDM=R
      END
      SUBROUTINE RANNOR(R1,R2)
      REAL R1,R2
+SEQ,RCREP.
      CHREP='RANNOR called !!!'
      CALL REPORT('RANNOR',1,'I')
      CALL GRANOR(R1,R2)
      END
      SUBROUTINE RDMOUT(JSEED)
      INTEGER JSEED,KSEED
+SEQ,RCREP.
      CHREP='RDMOUT called !!!'
      CALL REPORT('RDMOUT',1,'I')
      CALL GRNDMQ(JSEED,KSEED,1,'G')
      END
      SUBROUTINE RDMIN(JSEED)
      INTEGER JSEED,KSEED
+SEQ,RCREP.
      CHREP='RDMIN called !!!'
      CALL REPORT('RDMIN',1,'I')
      CALL GRNDMQ(JSEED,KSEED,1,'S')
      END
+PATCH,OBASE
+DECK,CHECK
      SUBROUTINE CHECK(CTEST,HBUF,NBUF,CFLAG)
*.
*...CHECK    Check if CTEST is/is not in HBUF, and add/remove it if wron
*.
*. INPUT     : CTEST    Character strings to search for
*. INPUT     : HBUF     Array of hollerith strings
*. INPUT     : NBUF     Dimension of HBUF
*. INPUT     : CFLAG    'Yes' => make sure CTEST is in HBUF
*.                      'No'  => make sure CTEST is not in HBUF
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : UCTOH  IUCOMP
*. CALLED    : GOIFFR
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 132.2
*. CREATED   : 22-Jan-88
*. LAST MOD  : 20-Jul-95
*.
*. Modification Log.
*. 20-Jul-95   M.Hapke       Fix length of character string in uctoh call
*. 23-Mar-94   J.E.Conboy    Test more than one string; strings must be
*.                           4 characters exactly
*. 22-Apr-88   D.R.Ward      Strong type
*. 22-Jan-88   D.R.Ward      Introduce to GOPAL
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      CHARACTER*(*) CTEST,CFLAG
      INTEGER   HBUF(20)
      INTEGER   NBUF,HTEST,I,J,IUCOMP,ITEST,NTEST,NC,LEN
      EXTERNAL IUCOMP
*
*-        Determine number of strings 
*
      NC  =  LEN( CTEST )
      NTEST = (NC+1)/4
      NC    = 1
      DO 20 ITEST=1,NTEST
        CALL UCTOH(CTEST(NC:NC+3),HTEST,4,4)
        NC  =  NC  + 4
        I = IUCOMP(HTEST,HBUF,NBUF)
        IF(CFLAG(1:1).EQ.'Y' .AND. I.EQ.0) THEN
           NBUF = NBUF+1
           HBUF(NBUF) = HTEST
        ELSEIF(CFLAG(1:1).EQ.'N' .AND. I.NE.0) THEN
           DO 10 J=I,NBUF-1
   10        HBUF(J) = HBUF(J+1)
           NBUF = NBUF-1
        ENDIF
   20 CONTINUE
      END
+DECK,COSANG.
      SUBROUTINE COSANG(JDIST,RESULT)
*.
*...COSANG   SERVICE ROUTINE FOR KICOSM PROVIDES VARIOUS ANGULAR DISTNS
*.
*. INPUT     : JDIST (RANGE 1 TO 4) CHOOSES  DISTRIBUTION
*.    DISTRIBUTIONS ARE =1 COS**3  =2 SIN* COS**2
*.                      =3 SIN     =4 COS
*. OUTPUT    : RESULT  SAMPLED ANGLE FROM CHOSEN DISTRIBUTION
*.
*.
*. COMMON    : GCONST
*. CALLS     : GRNDM
*. CALLED    : KICOSM
*.
*. AUTHOR    : P.Watkins
*. VERSION   : 1.00
*. CREATED   : 29-Jul-87
*. LAST MOD  : 11-Apr-94
*.
*. Modification Log.
*. 11-Apr-94  C.P.Ward  Fix mixed mode arithmetic.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCONST.
      REAL      CF(20,4),STEP(4),START(4),R,FRACT,RESULT
      INTEGER   NN,MAXNO,NBIN,J,JDIST,I,IBIN
*  STORED VALUES OF EACH DISTRIBUTION 20 BINS EACH
*     DISTRIBUTIONS ARE =1 COS**3  =2 SIN* COS**2
*                       =3 SIN     =4 COS
      DATA NN/0/
      DATA CF/ .22676E-04,.20408E-03,.81633E-03,.22676E-02,.51020E-02, .
     +10000E-01,.17778E-01,.29388E-01,.45918E-01,.68594E-01, .98776E-01,
     +.13796E+00,.18778E+00,.25000E+00,.32653E+00, .41941E+00,.
     +53082E+00,.66306E+00,.81859E+00,.10000E+01, .64644E-03,.32224E-02,
     +.89818E-02,.19128E-01,.34796E-01, .57023E-01,.86733E-01,.
     +12470E+00,.17152E+00,.22757E+00, .29298E+00,.36754E+00,.45067E+00,
     +.54126E+00,.63759E+00, .73600E+00,.83554E+00,.92695E+00,.
     +99991E+00,.10000E+01, .12312E-01,.36632E-01,.72362E-01,.11862E+00,
     +.17427E+00, .23794E+00,.30807E+00,.38292E+00,.46065E+00,.
     +53935E+00, .61709E+00,.69194E+00,.76206E+00,.82573E+00,.88138E+00,
     +.92764E+00,.96337E+00,.98769E+00,.10000E+01,.10000E+01, .
     +12311E-01,.36632E-01,.72361E-01,.11862E+00,.17427E+00, .23794E+00,
     +.30807E+00,.38292E+00,.46065E+00,.53935E+00, .61708E+00,.
     +69193E+00,.76206E+00,.82573E+00,.88138E+00, .92764E+00,.96337E+00,
     +.98769E+00,.10000E+01,.10000E+01/
      NN = NN +1
      IF(NN.EQ.1)THEN
*   FIRST TIME THROUGH SET UP USEFUL VARIABLES
         MAXNO = 4
         NBIN = 20
         DO 10 J = 1,MAXNO
            START(J) = 0.
            IF(J.EQ.4)START(J) = - PIBY2
            IF(J.LE.2)STEP(J) = 1./FLOAT(NBIN)
            IF(J.GT.2)STEP(J) = PI/FLOAT(NBIN)
   10    CONTINUE
      ENDIF
*    NOW SAMPLE CHOSEN DISTRIBUTION
      J = JDIST
      CALL GRNDM(R,1)
      DO 20 I = 1,NBIN
         IF(R.LE.CF(I,J))GO TO 30
   20 CONTINUE
      I= NBIN
   30 IBIN = I
      IF(IBIN.GT.1) THEN
         FRACT = (R-CF(IBIN-1,J))/(CF(IBIN,J)-CF(IBIN-1,J))
      ELSE
         FRACT = R/CF(IBIN,J)
      ENDIF
      RESULT= FRACT * STEP(J) + FLOAT(IBIN -1) * STEP(J) +START(J)
      RETURN
      END
+DECK,DUMMYCJ,IF=-OCJ.
      SUBROUTINE CJFREC
*
*     Dummy routine - to be included if OCJ (the CJ-specific routines
*                     from the GOPAJ PAMfile) are not requested.
*
+SEQ,RCREP.
      CHREP='Warning - dummy CJFREC has been called !!!'
      CALL REPORT('CJFREC',1,'I')
      END
+DECK,DUMMYTR,IF=-OTRIG.
      SUBROUTINE OPTRIG
*
*     Dummy routine - to be included if OTRIG (the trigger routines
*                     from the GOPAT PAMfile) are not requested.
*
+SEQ,RCREP.
      CHREP='Warning - dummy OPTRIG has been called !!!'
      CALL REPORT('OPTRIG',1,'I')
      END
+DECK,EVWRIT.
      SUBROUTINE EVWRIT (NTRAK,ITKDM,MXTRK,PTRAK,IDTRAK,IHSTRY,
     +                   VTX,IRUN,IEVT,IZRN,LUN,COPTN,IERR)
*.
*...EVWRIT
*.
*. Routine to write an event record to a file in a relatively compact
*. ascii form, or to read it back.  This simple routine has the
*. peculiarity for read mode (COPTN='R') that if the number of records
*. in any event between the first event of the file and the event to be
*. read is larger than MXTRK, the maximum number of records reserved for
*. PTRAK, the reading routine gets "lost"  (an error message will be
*. written in this case). The user must ensure that MXTRK is larger
*. than the number of event record entries for all events in the file.
*. MXTRK=400 is certainly sufficient for a multi-hadronic event
*. generated at a center-of-mass energy of 92 GeV.
*.
*. SEQUENCE  : RCREP GOXTRA
*. IN/OUTPUT : NTRAK   The number of entries in the event record
*. IN/OUTPUT : ITKDM   The first dimension of PTRAK
*. INPUT     : MXTRK   The maximum number of entries in PTRAK
*. IN/OUTPUT : PTRAK   The 5-momenta array of the event record (Px,Py,Pz,E,M)
*. IN/OUTPUT : IDTRAK  The IDs of the particles in the event record
*. IN/OUTPUT : IHSTRY  The history of the particles in the event record
*. IN/OUTPUT : VTX     The vertex position for the event (for all particles)
*. INPUT     : IRUN    For COPTN='W' : the run number, to label the record
*.                     For COPTN='R' : the run number to read
*. INPUT     : IEVT    For COPTN='W' : the event number, to label the record
*.                     For COPTN='R' : the event to read
*. INPUT     : IZRN    The random number seed for the event
*. INPUT     : LUN     The logical unit for read or for write
*. INPUT     : COPTN   = 'W' to write,
*.                     = 'F' to read the event labeled IEVT
*.                     = 'R' to read the next event regardless of IEVT value
*.                     = 'WB' 'FB' 'RB' for binary file option.
*. OUTPUT    : IERR    = -1 if there is a problem
*.                     =  0 if all is OK
*.                     =  1 if end of file
*. CALLS     : REPORT
*. CALLED    : By User
*.
*. AUTHOR    :  J.W.Gary
*. CREATED   :  17-Mar-89
*. LAST MOD  :  14-May-93
*.
*. Modification Log.
*. 14-May-93  Fix bug in previous modification          D.R.Ward
*.  5-Mar-93  Disable checking of run/event if no RUNG card D.R.Ward      
*.  8-Jan-92  Improve (?) error trapping                D.R.Ward
*.  3-Jan-92  Add binary option                         D.R.Ward
*. 26-Apr-91  write or read the contents of /GOXTRA/    S.L.Lloyd
*. 15-Oct-90  increase maximum possible event number    J.W.Gary
*. 15-Apr-90  add protection against bad event records  J.W.Gary
*. 11-May-89  various improvements for flexibility      J.W.Gary
*.
**********************************************************************
+SEQ,DECLARE.
+SEQ,GOXTRA.
+SELF,IF=-STLONE.
+SEQ,RCREP.
+SELF,IF=STLONE.
      INTEGER CHREP
      PARAMETER (CHREP=6)
+SELF.
      INTEGER  MXEVT,MXRUN
      PARAMETER  (MXEVT=999999,MXRUN=100000)
      INTEGER  IDTRAK (*),IHSTRY (*)
      INTEGER  NTRAK,ITKDM,LUN,IP,IERR,IX,IRUN,IEVT,IZRN,
     +         IRUNL,IEVTL,MXTRK,IH1,IH2,IPSAV,IHSAV
      REAL  PTRAK (ITKDM,*),VTX (*)
      CHARACTER*(*) COPTN
      CHARACTER*5  LABEL,CHEADR
      CHARACTER*2  TAG,CDUM
      DATA  LABEL / 'EVENT' /,TAG / 'ZZ' /

      IERR = 0
*
*-- Reading.
*
      IF (COPTN(1:1).EQ.'F'.OR.COPTN(1:1).EQ.'R') THEN
          IF (IEVT.GT.MXEVT.OR.IRUN.GT.MXRUN) THEN
              WRITE (CHREP,FMT='('' Event, Run number must'',
     +            '' be less than'',2I8)') MXRUN+1,MXEVT+1
              CALL REPORT ('EVWRIT',1,'C')
              IERR = -1
              GO TO 990
          END IF
  110     IF(LEN(COPTN).GE.2 .AND. COPTN(2:2).EQ.'B') THEN
             READ (LUN,ERR=1000,END=1020) CHEADR,IRUNL,IEVTL,
     +         CDUM,NTRAK,IZRN,(VTX (IX),IX=1,3)
          ELSE
             READ (LUN,1080,ERR=1000,END=1020) CHEADR,IRUNL,IEVTL,
     +         CDUM,NTRAK,IZRN,(VTX (IX),IX=1,3)
          ENDIF
Comment          WRITE (6,FMT='(''EVWRIT '',A6,3I8,I12)')
Comment     +           CHEADR,IRUNL,IEVTL,NTRAK,IZRN
          IF (COPTN(1:1).EQ.'F'.AND.IRUNL.NE.IRUN) THEN
              WRITE (CHREP,FMT='('' Error, Run on file='',
     +          I7,'', requested='',I7)') IRUNL,IRUN
              CALL REPORT ('EVWRIT',2,'C')
              IERR = -1
              GO TO 990
          END IF
          IF (COPTN(1:1).EQ.'F'.AND.(IEVTL.GT.IEVT)) THEN
              WRITE (CHREP,FMT='('' Error, Requested event number ='',
     +          I7,'', smaller than that on file ='',I7)') IEVT,IEVTL
              CALL REPORT ('EVWRIT',6,'C')
              IERR = -1
              GO TO 990
          END IF
*
          IF (CDUM.EQ.'XX') THEN
            IF (NTRAK.GT.MXXTRA) THEN
              WRITE (CHREP,FMT='('' Error, Max.Nr.of extra words ='',
     +          I10,'' exceeded'')') MXXTRA
              CALL REPORT ('EVWRIT',8,'W')
              NWXTRA = MXXTRA
            ELSE
              NWXTRA = NTRAK
            ENDIF
            IF(LEN(COPTN).GE.2 .AND. COPTN(2:2).EQ.'B') THEN
               READ (LUN,ERR=1000) (RXTRA(IX),IX=1,NWXTRA)
            ELSE
               READ (LUN,1070,ERR=1000) (RXTRA(IX),IX=1,NWXTRA)
            ENDIF
            GO TO 110
*
          ELSE
            IF (NTRAK.GT.MXTRK) THEN
              WRITE (CHREP,FMT='('' Error, Max.Nr.of tracks ='',
     +          I10,'' exceeded'')') MXTRK
              CALL REPORT ('EVWRIT',3,'C')
              IERR = -1
              GO TO 990
            END IF
*
            DO 140 IP = 1,NTRAK
              IF(LEN(COPTN).GE.2 .AND. COPTN(2:2).EQ.'B') THEN
                 READ (LUN,ERR=1001) IDTRAK (IP),IHSTRY (IP),
     +             (PTRAK (IX,IP),IX=1,5)
              ELSE
                 READ (LUN,1090,ERR=1001) IDTRAK (IP),IHSTRY (IP),
     +             (PTRAK (IX,IP),IX=1,5)
              ENDIF
              IF (IDTRAK (IP).EQ.91.OR.IDTRAK (IP).EQ.92) THEN
                 IH1 = MOD (IHSTRY (IP),1000)
                 IH2 = NINT (FLOAT (IHSTRY (IP)) / 1000.)
                 IF (IH1.GE.IP.OR.IH2.GE.IP.OR.
     +               IH1.LT.0.OR.IH2.LT.0) THEN
                    IPSAV = IP
                    IHSAV = IHSTRY (IP)
                    IERR = -1
                 END IF
              ELSE IF (IHSTRY (IP).GE.IP.OR.IHSTRY(IP).LT.0) THEN
                 IPSAV = IP
                 IHSAV = IHSTRY (IP)
                 IERR = -1
              END IF
              GO TO 140
*
 1001         IF(COPTN(1:1).EQ.'F'.AND.IEVTL.EQ.IEVT) GO TO 1000
*
  140       CONTINUE
*
            IF (COPTN(1:1).EQ.'F'.AND.IEVTL.NE.IEVT) THEN
               IERR=0
               GO TO 110
            ENDIF
*
            IF (IERR.NE.0) THEN
              WRITE (CHREP,FMT='('' Error, Bad History record'',
     +          '' IPSAV,IHSAV='',2I6)') IPSAV,IHSAV
              CALL REPORT ('EVWRIT',3,'F')
              GO TO 990
            END IF
          ENDIF
*
          IF (COPTN(1:1).EQ.'F'.AND.IEVTL.NE.IEVT) GO TO 110
          IRUN=IRUNL
          IEVT=IEVTL
*
*-- Writing
*
      ELSE IF (COPTN(1:1).EQ.'W') THEN
          IF (NWXTRA.GT.0) THEN
            IF(LEN(COPTN).GE.2 .AND. COPTN(2:2).EQ.'B') THEN
               WRITE (LUN) LABEL,IRUN,IEVT,'XX',NWXTRA,
     +             IZRN,(VTX (IX),IX=1,3)
               WRITE (LUN) (RXTRA(IX),IX=1,NWXTRA)
            ELSE
               WRITE (LUN,1080) LABEL,IRUN,IEVT,'XX',NWXTRA,
     +             IZRN,(VTX (IX),IX=1,3)
               WRITE (LUN,1070) (RXTRA(IX),IX=1,NWXTRA)
            ENDIF
          ENDIF
*
          IF(LEN(COPTN).GE.2 .AND. COPTN(2:2).EQ.'B') THEN
             WRITE (LUN) LABEL,IRUN,IEVT,TAG,NTRAK,
     +           IZRN,(VTX (IX),IX=1,3)
             DO 161 IP = 1,NTRAK
                 WRITE (LUN) IDTRAK (IP),IHSTRY (IP),
     +                 (PTRAK (IX,IP),IX=1,5)
  161        CONTINUE
          ELSE
             WRITE (LUN,1080) LABEL,IRUN,IEVT,TAG,NTRAK,
     +           IZRN,(VTX (IX),IX=1,3)
             DO 160 IP = 1,NTRAK
                 WRITE (LUN,1090) IDTRAK (IP),IHSTRY (IP),
     +                 (PTRAK (IX,IP),IX=1,5)
  160        CONTINUE
          ENDIF
*
*-- Something else ?
*
      ELSE
          WRITE (CHREP,FMT='('' COPTN ='',A6,
     +          '' option unknown'')')  COPTN
          CALL REPORT ('EVWRIT',4,'F')
          IERR = -1
          GO TO 990
      END IF
 
  990 RETURN
 1000 WRITE (CHREP,FMT='('' Error reading LUN '',I6)') LUN
      CALL REPORT ('EVWRIT',5,'C')
      IERR = -1
      RETURN
 1020 WRITE (CHREP,FMT='('' End-of-file, LUN '',I6)') LUN
      CALL REPORT ('EVWRIT',7,'C')
      IERR =  1
      RETURN
 1070 FORMAT (1X,6E13.7)
 1080 FORMAT (1X,A5,2I6,A2,I6,I12,1X,3E13.7)
 1090 FORMAT (1X,I7,I6,1X,5E13.7)
      END
+DECK,GFISID.
      SUBROUTINE GFISID(IUSET,IUDET,ISET,IDET)
*.
*...GFISID   Fetch detector and set numbers given character values.
*.
*.
*. INPUT     : IUSET  Set identifier
*. INPUT     : IUDET  Detector identifier
*. OUTPUT    : ISET   Set number
*. OUTPUT    : IDET   Detector number
*.
*. COMMON    :
*. SEQUENCE  : GCBANK
*. CALLS     : GLOOK
*. CALLED    : CJDIGI CZDIGI EEDIGI FDIGI  FSCDIG HBDIGI HEDIGI HPDIGI
*. CALLED    : MBDIGI MEDIGI PBDIGI
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 26-Nov-84
*. LAST MOD  : 12-Sep-88
*.
*. Modification Log.
*. 12-Sep-88   D.R.Ward        IUSET, IUDET type character
*. 22-Apr-88   D.R.Ward        Strong type
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*. 23-Feb-86   C.P.Ward        Correct access to the count of the data
*.                             data words C.P.Ward
*. 13-Jan-86   S.W.O'Neale     Zebra 3.40 required
*.
*.**********************************************************************
*.
*
*--   Note: This routine is provided primarily to assist
*--   users writing code for DIGItisation. In the HITS code
*--   the values of IUSET,IUDET,ISET and IDET are available
*--   in common blocks. This is not the case for GSDIGI but as
*--   this routine is called for each digitization it would be
*--   very in-efficient to search the data structure for IUSET
*--   and IUSET.  The user is recommended to obtain these variables
*--   once and store them in local variables in his/her digitization
*--   code.
*
*     Call GLOOK (using UCTOH) to be independent of the use of
*     character (or hollerith) values of IUSET and IUDET.
*                  26-Nov-84  S.W.O'Neale
+SEQ,DECLARE.
      CHARACTER*4 IUSET,IUDET
      INTEGER IDET,ISET,NSET,LDET,NDET
+SEQ,GCBANK.
*
*--
*--   Find ISET and  IDET from IUSET and IUDET.
*
      IDET       = 0
      IF (JSET.LE.0) GOTO 10
      NSET=IQ(JSET-1)
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET.LE.0) GOTO 10
      LDET=LQ(JSET-ISET)
      IF (LDET.LE.0) GOTO 10
      NDET=IQ(LDET-1)
      CALL GLOOK(IUDET,IQ(LDET+1),NDET,IDET)
      IF (IDET.EQ.0) GOTO 10
*
      RETURN
   10 ISET=0
      RETURN
      END
+DECK,GOBEAM
      SUBROUTINE GOBEAM
*.
*...GOBEAM   Define average beam spot parameters for each year.          
*.
*. COMMON    :
*. SEQUENCE  : GCUNIT GOFLAG GOCART 
*. CALLS     : GMAIL  
*. CALLED    : GOIFFR
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : C.P.Ward
*. VERSION   : 1.0  
*. CREATED   : 19-May-94
*. LAST MOD  : 20-Jan-99
*.
*. Modification Log.
*. 20-Jan-99  C.P.Ward  values for 1999 from R.Hawkings
*. 29-Sep-95  C.P.Ward  preliminary 1995 LEP1 values from R.Hawkings
*. 08-Nov-94  C.P.Ward  1994 parameters from S. de Jong.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCUNIT.
+SEQ,GOCART.
+SEQ,GOFLAG.
*
      INTEGER NEXPT,I
      PARAMETER (NEXPT=11)
      REAL    XYZ(6,NEXPT)
      DATA XYZ/
*-- 1990 averages from SUBEAM 8-Jul-1991
     + -0.0007, 0.0838, 0.3113, 0.0155, 0.0012, 1.12,
*-- 1991 averages from SUBEAM 3-Aug-1992
     + -0.0879, 0.1194, 0.4403, 0.0155, 0.0012, 1.12,
*-- 1992 averages from SUBEAM 11-May-1993,
*--      beam sizes based on E-mail from Sijbrand
     + 0.0390, 0.0484, 0.4339, 0.0100, 0.0012, 0.75,
*-- 1993 P51 onwards averages from Sijbrand 22-Nov-1993
     + -0.0390, 0.0353, 0.3980, 0.0160, 0.0016, 0.84,
*-- 1994 P59-62 pass2 averages from Sijbrand 8-Nov-1994
     + -0.0211, 0.0434, 0.464 , 0.0127, 0.0012, 0.70,
*-- repeat for expt 6
     + -0.0211, 0.0434, 0.464 , 0.0127, 0.0012, 0.70,
*-- 1995 P69-74 pass1 preliminary averages from Richard Hawkings 29-Sep-1995
     + -0.03  , 0.105 , 0.3   , 0.0150, 0.0010, 0.70,
*-- repeat for expt 8 (1996)
     + -0.03  , 0.105 , 0.3   , 0.0150, 0.0010, 0.70,
*-- repeat for expt 9 (1997)
     + -0.03  , 0.105 , 0.3   , 0.0150, 0.0010, 0.70,
*-- repeat for expt 10 (1998)
     + -0.03  , 0.105 , 0.3   , 0.0150, 0.0010, 0.70,
*-- suggestion for expt 11 (1999) from Richard Hawkings 19-Jan-99
*--      based on 1998 data
     + -0.03  , 0.08  , 0.3   , 0.0110, 0.0020, 0.79/
*
*-- Copy default beam spot position and size to CAVXYZ if no VERT
*-- data card has been given.
*
      IF(CAVXYZ(1).EQ.99999.) THEN
         I = MOD(IGOEXP,1000)
         IF(I.GT.NEXPT) I = NEXPT
         CALL UCOPY(XYZ(1,I),CAVXYZ(1),6)
      ENDIF
*
      WRITE(CHMAIL,1001) CAVXYZ(1),CAVXYZ(2),CAVXYZ(3)
      CALL GMAIL(1,1)
      WRITE(CHMAIL,1002) CAVXYZ(4),CAVXYZ(5),CAVXYZ(6)
      CALL GMAIL(1,1)
 1001 FORMAT(' <<<< Average interaction point = (',F8.4,',',
     +       F8.4,',',F8.4,') cm. >>>>')
 1002 FORMAT(' <<<< Average spread in I/P     = (',F8.4,',',
     +       F8.4,',',F8.4,') cm. >>>>')
      END
+DECK,GOFFUS.
      SUBROUTINE GOFFUS(KEYW)
*.
*...GOFFUS   Called when a * FFREAD card is read
*.
*.
*. INPUT     : KEYW   keyword read on the card
*. OUTPUT    :
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : UHTOC
*. CALLED    :
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 18-Dec-86
*. LAST MOD  : 07-Jun-94
*.
*. Modification Log.
*.  7-Jun-94   C.P.Ward        Remove bootstrap code
*.  5-Mar-93   D.R.Ward        Prepare for compressed data
*.  1-Mar-93   J.E.Conboy      Keywords are now 8 Character
*.                             Call USFFUS  for user intervention
*.  3-Jan-92   D.R.Ward        Implement internal file definition
*. 22-Feb-91   S.Weisz         Mods for ROPE400
*.  5-Oct-90   D.R.Ward        Implement *SKIP and *SELECT
*.  4-Jan-89   D.R.Ward        Renamed from FFUSER
*. 23-Aug-89   D.R.Ward        Handle FD Boot cards
*. 30-May-89   D.R.Ward        Deal with *FILE card
*. 22-Apr-88   D.R.Ward        Strong type
*. 18-Nov-86   D.R.Ward        Introduced into GOPAL111
*.
*.**********************************************************************
*.
*  -------------------------------------------------------------------
*--called when a *NAME card is read;
*  -------------------------------------------------------------------
+SEQ,DECLARE.
+SEQ,RCNTRL.
+SEQ,GOFILE.
+SEQ,RCREP.
      INTEGER NUKMAX,LIOKEY,I
      PARAMETER (NUKMAX=6)
      DIMENSION LIOKEY(NUKMAX)
      EQUIVALENCE (LIOKEY,LFITYP)
      INTEGER KEYW
      CHARACTER*4 CEYW,CNAME,CDIRN
      CALL UHTOC(KEYW,4,CEYW,8)
      IF (CEYW.EQ.'BOOT') THEN
         CHREP = 'Bootstrap no longer available'
         CALL REPORT('GOFFUS',1,'W')
      ELSEIF (CEYW.EQ.'SKIP' .OR. CEYW.EQ.'SELE') THEN
         CALL GOSELI(CEYW)
      ELSEIF (CEYW.EQ.'FILE') THEN
         CALL UHTOC(LIOKEY(1),4,CNAME,4)
         IF(CNAME(1:4).EQ.'CNST') CNAME='CONS'
         IF(CNAME(1:4).EQ.'RAWD') CNAME='DATA'
         CALL UHTOC(LIOKEY(2),4,CDIRN,4)
*
*     Check it's a recognized combination
*
         IF(CNAME(1:3).EQ.'INI' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'INI' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'CON' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'DAT' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'PRO' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'DST' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'DDS' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'MET' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'EBE' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'EBP' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'EBG' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'EEE' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'EEP' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'EEG' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'FDP' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'FDG' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'HIS' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'HIS' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'HIS' .AND. CDIRN(1:1).EQ.'U') GO TO 10
         IF(CNAME(1:3).EQ.'CAL' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'CAL' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:3).EQ.'CAL' .AND. CDIRN(1:1).EQ.'U') GO TO 10
         IF(CNAME(1:3).EQ.'KIN' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'RUN' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'DIC' .AND. CDIRN(1:1).EQ.'I') GO TO 10
         IF(CNAME(1:3).EQ.'CDS' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:4).EQ.'CDDS' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:4).EQ.'CDDI' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         IF(CNAME(1:4).EQ.'CDDO' .AND. CDIRN(1:1).EQ.'O') GO TO 10
         CHREP='Unrecognized FILE requested: '//CNAME//' '//CDIRN
         CALL REPORT('FFUSER',2,'W')
         GO TO 99
*
   10    NFILE=NFILE+1
         IF(NFILE.GT.MFILE) THEN
            CHREP='Too many *FILE cards - remainder ignored'
            CALL REPORT('FFUSER',1,'W')
            GO TO 99
         ENDIF
         IF(CNAME(1:4).EQ.'CDST') CNAME(1:3)='CD0'
         IF(CNAME(1:4).EQ.'CDDS') CNAME(1:3)='CD3'
         IF(CNAME(1:4).EQ.'CDDI') CNAME(1:3)='CD2'
         IF(CNAME(1:4).EQ.'CDDO') CNAME(1:3)='CD1'
         CALL UCTOH(CNAME(1:3)//CDIRN(1:1),IONAME(NFILE),4,4)
         IOUNIT(NFILE)=LIOKEY(3)
         IOLREC(NFILE)=LIOKEY(4)
         IOFCHO(NFILE)=LIOKEY(5)
         IF(IOFCHO(NFILE).EQ.0) THEN
            IF(CDIRN(1:1).EQ.'U') THEN
               CALL UCTOH('IO  ',IOFCHO(NFILE),4,4)
            ELSE
               CALL UCTOH(CDIRN(1:1)//'   ',IOFCHO(NFILE),4,4)
            ENDIF
         ENDIF
         IODCHO(NFILE)=LIOKEY(6)
         IF(LFINAM(1).NE.0) THEN
            CALL UHTOC(LFINAM,4,IOFNAM(NFILE),80)
            DO 20 I=1,20
               CALL UCTOH('    ',LFINAM(I),4,4)
  20        CONTINUE
            CALL VZERO(LIOKEY,6) 
         ELSE
            IOFNAM(NFILE)='    '
         ENDIF
      ELSE
          CALL USFFUS( KEYW )
      ENDIF
*
  99  END
+DECK,GOGFFR
      SUBROUTINE GOGFFR
*.
*...GOGFFR   Validate geometrical data cards and take appropriate action.
*.
*. COMMON    :
*. SEQUENCE  : GCLIST GCUNIT GOFLAG GOFLD  GOLOGI RCREP
*. CALLS     : GMAIL  REPORT UCTOH  IUCOMP JUCOMP
*. CALLED    : GOIFFR
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : C.P.Ward
*. VERSION   : 133.0
*. CREATED   : 23-May-94
*. LAST MOD  : 02-Dec-94
*.
*. Modification Log.
*. 02-Dec-94  C.P.Ward  Remove SI for expt 6, and make TE expt.ge.8
*. 28-Sep-94  C.P.Ward  Add TE.
*. 18-Jul-94  C.P.Ward  Modify treatment of FDET card.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCLIST.
+SEQ,GCUNIT.
+SEQ,GOFLAG.
+SEQ,GOFLD.
+SEQ,GOLOGI.
+SEQ,RCREP.
      INTEGER NGEOMO,NSETSO,NDIGIO,LALL,MBLANK,JGEOM,JFAST,L,
     +        I,J,IUCOMP,JUCOMP
      EXTERNAL IUCOMP,JUCOMP
      PARAMETER (NGEOMO=20,NSETSO=17,NDIGIO=17)
      INTEGER   LGEOMO(NGEOMO),LSETSO(NSETSO),LDIGIO(NDIGIO)
*
      CHARACTER*(*)       CDGEOM, CDDET, CALDET
*
*--   The CD  card defines the geometry of the detectors CDGEOM and
*                  controls digitization of detectors CDDET
*--   The CAL card controls digitization of Calorimeters CALDET
*
      PARAMETER  ( CDGEOM = 'CD  CV  CJ  CZ  BP  CP  ' )
      PARAMETER  ( CDDET  = 'CV  CJ  CZ  ')
      PARAMETER  ( CALDET = 'EB  EE  HB  HE  HP  MB  ME  FD  SW  TE  ' )
*
      CALL UCTOH  ('ALL CD  CV  CJ  CZ  CP  EB  EE  HE  HB  MB  ME  '//
     +'BD  BP  HP  FD  PE  SI  SW  TE  ',LGEOMO,4,4*NGEOMO)
      CALL UCTOH  ('CV  CJ  CZ  TB  PB  EB  HB  MB  FD  PE  EE  HE  '//
     +'HP  ME  SI  SW  TE  ',LSETSO,4,4*NSETSO)
      CALL UCTOH  ('CV  CJ  CZ  TB  PB  EB  HB  MB  FD  PE  EE  HE  '//
     +'HP  ME  SI  SW  TE  ',LDIGIO,4,4*NDIGIO)
*
      CALL UCTOH('ALL ',LALL  ,4,4)
      CALL UCTOH('    ',MBLANK,4,4)
*
*-- Initialise logical flags: 
*
      LCDFU=.FALSE.
      LCDFA=.FALSE.
      LCDSM=.FALSE.
      LCALFU=.FALSE.
      LCALFA=.FALSE.
      LCALSM=.FALSE.
      LSIFU=.FALSE.
      LSIFA=.FALSE.
      LSISM=.FALSE.
      LFDFU=.FALSE.
      LFDFA=.FALSE.
      LFDSM=.FALSE.
      LPSFU=.FALSE.
      LALLFU=.FALSE.
      LALLFA=.FALSE.
      LALLSM=.FALSE.
      LSMTRK=.FALSE.
      LSMCE=.FALSE.
*
*-- In NODEtector mode we have very little to do
*
      IF(NODET.EQ.1) THEN
         CHMAIL='**** NO DEtector mode selected - no geometry '//
     +          ' will be set up. ****'
         CALL GMAIL(1,1)
         GO TO 150
      ENDIF
*
*-- Check if new or old method data cards; if both we ignore the
*   old ones
*
      IF(NCDET.GT.0 .OR. NCAL.GT.0 .OR. NSILI.GT.0 .OR.
     +   NPSAM.GT.0 ) THEN
           IF(NGEOM.GT.0 .OR. NFAST.GT.0 .OR. NSETS.GT.0 .OR.
     +        NDIGI.GT.0) THEN
                 CHREP = 'Old geometrical data cards ignored'
                 CALL REPORT('GOGFFR',1,'W')
                 NGEOM = 0
                 NFAST = 0
                 NSETS = 0
                 NDIGI = 0
           ENDIF
           GO TO 100
      ELSEIF(NGEOM.EQ.0 .AND. NFAST.EQ.0) THEN
           CHREP='Must specify geometry or NODEtector mode'
           CALL REPORT('GOGFFR',2,'C')
           STOP
      ENDIF
*
*-- Here for old style cards
*
*-- Set LALLFU and LCALFU to .TRUE. to enable full tracking in GUSTEP
*-- and CE respectively
*
      LALLFU = .TRUE.
      LCALFU = .TRUE.
*
*-- Validate GEOM data card                                           GEOM
*-- =======================                                           ====
*
      IF(NGEOM.EQ.0) GO TO 11
      DO 10 JGEOM=1,NGEOM
         IF(IUCOMP(LGEOM(JGEOM),LGEOMO,NGEOMO).EQ.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' GEOM option #'',I2,2X,A4,'' is not defined. Ignored.''
     +       )') JGEOM,LGEOM(JGEOM)
            CALL REPORT('GOGFFR',3,'W')
         ENDIF
   10 CONTINUE
*
      IF((MOD(IGOEXP,1000).LE.1 .OR. MOD(IGOEXP,1000).EQ.6) .AND. 
     +   JUCOMP('SI  ',LGEOM,NGEOM).NE.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' SI not allowed for expt '',I4,''. Ignored.'')') IGOEXP
            CALL REPORT('GOGFFR',4,'W')
            CALL CHECK('SI  ',LGEOM,NGEOM,'NO')
      ENDIF
      IF(MOD(IGOEXP,1000).LE.3 .AND. 
     +   JUCOMP('SW  ',LGEOM,NGEOM).NE.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' SW not allowed for expt '',I4,''. Ignored.'')') IGOEXP
            CALL REPORT('GOGFFR',5,'W')
            CALL CHECK('SW  ',LGEOM,NGEOM,'NO')
      ENDIF
      IF(MOD(IGOEXP,1000).LE.7 .AND. 
     +   JUCOMP('TE  ',LGEOM,NGEOM).NE.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' TE not allowed for expt '',I4,''. Ignored.'')') IGOEXP
            CALL REPORT('GOGFFR',6,'W')
            CALL CHECK('TE  ',LGEOM,NGEOM,'NO')
      ENDIF
*
      IF(IUCOMP(LALL ,LGEOM,NGEOM).NE.0) THEN
         CALL UCOPY(LGEOMO,LGEOM,NGEOMO)
         CALL GETNUM(LGEOM,NGEOM)
         CALL CHECK('ALL ',LGEOM,NGEOM,'NO')
         IF(MOD(IGOEXP,1000).LE.1) CALL CHECK('SI  ',LGEOM,NGEOM,'NO')
         IF(MOD(IGOEXP,1000).EQ.6) CALL CHECK('SI  ',LGEOM,NGEOM,'NO')
         IF(MOD(IGOEXP,1000).LE.3) CALL CHECK('SW  ',LGEOM,NGEOM,'NO')
         IF(MOD(IGOEXP,1000).LE.7) CALL CHECK('TE  ',LGEOM,NGEOM,'NO')
      ENDIF
*
*-- If CD selected then set CV CJ CZ CP (if not already done).
*
      IF(JUCOMP('CD  ',LGEOM,NGEOM).NE.0) 
     +    CALL CHECK( 'CV  CJ  CZ  CP  ', LGEOM, NGEOM, 'YES' )
   11 CONTINUE
*
*-- Deal with FAST data card                                          FAST
*-- ========================                                          ====
*
      IF(NFAST.EQ.0) GO TO 22
      DO 20 JFAST=1,NFAST
         IF(IUCOMP(LFAST(JFAST),LGEOMO,NGEOMO).EQ.0) THEN
            WRITE(CHREP , FMT=
     +      '('' FAST option #'',I2,2X,A4,'' is not defined. Ignored.''
     +       )') JFAST,LFAST(JFAST)
            CALL REPORT('GOGFFR',7,'W')
         ENDIF
   20 CONTINUE
*
*
      IF((MOD(IGOEXP,1000).LE.1 .OR. MOD(IGOEXP,1000).EQ.6) .AND. 
     +   JUCOMP('SI  ',LFAST,NFAST).NE.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' SI not allowed for expt '',I4,''. Ignored.'')') IGOEXP
            CALL REPORT('GOGFFR',4,'W')
            CALL CHECK('SI  ',LFAST,NFAST,'NO')
      ENDIF
      IF(MOD(IGOEXP,1000).LE.3 .AND. 
     +   JUCOMP('SW  ',LFAST,NFAST).NE.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' SW not allowed for expt '',I4,''. Ignored.'')') IGOEXP
            CALL REPORT('GOGFFR',5,'W')
            CALL CHECK('SW  ',LFAST,NFAST,'NO')
      ENDIF
      IF(MOD(IGOEXP,1000).LE.7 .AND. 
     +   JUCOMP('TE  ',LFAST,NFAST).NE.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' TE not allowed for expt '',I4,''. Ignored.'')') IGOEXP
            CALL REPORT('GOGFFR',6,'W')
            CALL CHECK('TE  ',LFAST,NFAST,'NO')
      ENDIF
*
      IF(NFAST.EQ.1 .AND. LFAST(1).EQ.LALL) THEN
         CALL UCOPY(LGEOMO,LFAST,NGEOMO)
         CALL GETNUM(LFAST,NFAST)
         CALL CHECK('ALL ',LFAST,NFAST,'NO')
         IF(MOD(IGOEXP,1000).LE.1) CALL CHECK('SI  ',LFAST,NFAST,'NO')
         IF(MOD(IGOEXP,1000).EQ.6) CALL CHECK('SI  ',LFAST,NFAST,'NO')
         IF(MOD(IGOEXP,1000).LE.3) CALL CHECK('SW  ',LFAST,NFAST,'NO')
         IF(MOD(IGOEXP,1000).LE.7) CALL CHECK('TE  ',LFAST,NFAST,'NO')
      ENDIF
*
*-- If CD selected then set CV CJ CZ CP (if not already done).
*
      IF(JUCOMP('CD  ',LFAST,NFAST).NE.0) 
     +    CALL CHECK( 'CV  CJ  CZ  CP  ', LFAST, NFAST, 'YES' )
*
*-- Turn off GEOM for those declared FAST.
      DO 21 I=1,NFAST
         L=IUCOMP(LFAST(I),LGEOM,NGEOM)
         IF(L.NE.0) LGEOM(L)=MBLANK
   21 CONTINUE
*
   22 CONTINUE
*
*-- Declare all detector SETS if 'ALL ' is specified.                 SETS
*                        ====                                         ====
*
      IF(NSETS.EQ.1 .AND. LSETS(1).EQ.LALL) THEN
         CALL UCOPY(LSETSO,LSETS,NSETSO)
         CALL GETNUM(LSETS,NSETS)
         CALL CHECK('ALL ',LSETS,NSETS,'NO')
         IF(MOD(IGOEXP,1000).LE.1) CALL CHECK('SI  ',LSETS,NSETS,'NO')
         IF(MOD(IGOEXP,1000).EQ.6) CALL CHECK('SI  ',LSETS,NSETS,'NO')
         IF(MOD(IGOEXP,1000).LE.3) CALL CHECK('SW  ',LSETS,NSETS,'NO')
         IF(MOD(IGOEXP,1000).LE.7) CALL CHECK('TE  ',LSETS,NSETS,'NO')
      ENDIF
*
*--      Declare all detector DIGI if 'ALL ' is specified.            DIGI
*                             ===                                     ====
      IF(NDIGI.EQ.1 .AND. LDIGI(1).EQ.LALL) THEN
         CALL UCOPY(LDIGIO,LDIGI,NDIGIO)
         CALL GETNUM(LDIGI,NDIGI)
         CALL CHECK('ALL ',LDIGI,NDIGI,'NO')
         IF(MOD(IGOEXP,1000).LE.1) CALL CHECK('SI  ',LDIGI,NDIGI,'NO')
         IF(MOD(IGOEXP,1000).EQ.6) CALL CHECK('SI  ',LDIGI,NDIGI,'NO')
         IF(MOD(IGOEXP,1000).LE.3) CALL CHECK('SW  ',LDIGI,NDIGI,'NO')
         IF(MOD(IGOEXP,1000).LE.7) CALL CHECK('TE  ',LDIGI,NDIGI,'NO')
      ENDIF
*
      GO TO 200
*
*-- Here for the new style cards; as we go through these we modify
*-- the logical symbols used to speed tracking appropriately.
*
*-- CD card                                                           CD
*-- =======                                                           ==
*
  100 LALLFU = .TRUE.
      LALLFA = .TRUE.
      LALLSM = .TRUE.
      IF(NCDET.EQ.0) GO TO 30
      IF(JUCOMP('FULL',LCDET,NCDET).NE.0) LCDFU=.TRUE.
      IF(JUCOMP('FAST',LCDET,NCDET).NE.0) LCDFA=.TRUE.
      IF(JUCOMP('SMEA',LCDET,NCDET).NE.0) LCDSM=.TRUE.
      IF(LCDFU) THEN
        CHMAIL=' **** FULL CD simulation has been selected ****'
        CALL GMAIL(1,1)
        CALL CHECK( CDGEOM , LGEOM , NGEOM , 'YES')
        CALL CHECK( CDGEOM , LFAST , NFAST , 'NO')
        CALL CHECK( CDDET  , LSETS , NSETS , 'YES')
        CALL CHECK( CDDET  , LDIGI , NDIGI , 'YES')
        LALLFA = .FALSE.
        LALLSM = .FALSE.
*
      ELSEIF(LCDFA .OR. LCDSM) THEN
        IF(LCDFA) THEN
          CHMAIL=' ** FAST CD simulation has been selected   **'
          CALL GMAIL(1,0)
          CHMAIL=' ** Hence FAST CD geometry will be chosen. **'
          CALL GMAIL(0,0)
          CHMAIL=' ** WARNING - option not fully implemented **'
          CALL GMAIL(0,1)
          LALLFU = .FALSE.
          LALLSM = .FALSE.
        ELSE
          CHMAIL=' ** SMEAr CD simulation has been selected   **'
          CALL GMAIL(1,0)
          CHMAIL=' ** Hence FAST CD geometry will be chosen. **'
          CALL GMAIL(0,1)
          LALLFU = .FALSE.
          LALLFA = .FALSE.
        ENDIF
        CALL CHECK( CDGEOM , LGEOM , NGEOM , 'NO')
        CALL CHECK( CDGEOM , LFAST , NFAST , 'YES')
        CALL CHECK( CDDET  , LSETS , NSETS , 'NO')
        CALL CHECK( CDDET  , LDIGI , NDIGI , 'NO')
      ELSE
        CHREP =' Must specify FULL FAST or SMEA on the CD card'
        CALL REPORT('GOGFFR' , 8,'W')
      ENDIF
      IF(JUCOMP('FIT ',LCDET,NCDET).NE.0) THEN
         CHMAIL=' Ideal pattern recognition and track fitting will'//
     +   ' be performed on CD tracks'
         CALL GMAIL(1,0)
         CHMAIL=' *** WARNING - this option not yet implemented'
         CALL GMAIL(0,1)
      ENDIF
*
*-- SI CARD                                                           SI
*-- =======                                                           ==
*-- The SI simulation level defaults to that of CD
*
   30 IF(MOD(IGOEXP,1000).LE.1 .OR. MOD(IGOEXP,1000).EQ.6) THEN
         IF(NSILI.GT.0) THEN
            WRITE(CHREP ,FMT= '(
     +      '' SI not allowed for expt '',I4,''. Ignored.'')') IGOEXP
            CALL REPORT('GOGFFR',4,'W')
         ENDIF
         GO TO 40
      ENDIF
*
      IF(NSILI.EQ.0) THEN
         LSIFU = LCDFU
         LSIFA = LCDFA
         LSISM = LCDSM
      ELSE
         IF(JUCOMP('FULL',LSILI,NSILI).NE.0) LSIFU=.TRUE.
         IF(JUCOMP('FAST',LSILI,NSILI).NE.0) LSIFA=.TRUE.
         IF(JUCOMP('SMEA',LSILI,NSILI).NE.0) LSISM=.TRUE.
         IF(LSISM.AND..NOT.LCDSM) THEN
            CHREP='Si can''t be in SMEAr mode if CD is not.'
            CALL REPORT('GOGFFR',9,'C')
            STOP
         ENDIF
         IF(LCDSM.AND..NOT.LSISM) THEN
            CHREP='Si can''t be in FULL/FAST mode if CD in SMEar'
            CALL REPORT('GOGFFR',10,'C')
            STOP
         ENDIF
      ENDIF
*
      IF(LSIFU) THEN
        CHMAIL=' **** FULL SI simulation has been selected ****'
        CALL GMAIL(1,1)
        CALL CHECK('SI  BP  ',LGEOM,NGEOM,'YES')
        CALL CHECK('SI  BP  ',LFAST,NFAST,'NO' )
        CALL CHECK('SI  ',LSETS,NSETS,'YES')
        CALL CHECK('SI  ',LDIGI,NDIGI,'YES')
        LALLFA  =  .FALSE.
        LALLSM  =  .FALSE.
      ELSEIF(LSIFA .OR. LSISM) THEN
        IF(LSIFA) THEN
          CHMAIL=' ** FAST SI simulation has been selected   **'
          CALL GMAIL(1,0)
          CHMAIL=' ** Hence FAST SI geometry will be chosen. **'
          CALL GMAIL(0,0)
          CHMAIL=' ** WARNING - option not yet implemented   **'
          CALL GMAIL(0,1)
          LALLFU  =  .FALSE.
          LALLSM  =  .FALSE.
        ELSE
          CHMAIL=' ** SMEAr SI simulation has been selected  **'
          CALL GMAIL(1,0)
          CHMAIL=' ** Hence FAST SI geometry will be chosen. **'
          CALL GMAIL(0,1)
          LALLFU  =  .FALSE.
          LALLFA  =  .FALSE.
        ENDIF
        CALL CHECK('SI  ',LGEOM,NGEOM,'NO ')
        CALL CHECK('SI  ',LFAST,NFAST,'YES')
        CALL CHECK('SI  ',LSETS,NSETS,'NO ')
        CALL CHECK('SI  ',LDIGI,NDIGI,'NO ')
      ELSEIF(NSILI.GT.0) THEN
        CHREP =' Must specify either FULL FAST or SMEA on the SI card'
        CALL REPORT('GOGFFR',11,'W')
      ENDIF
*
*-- CAL CARD                                                          CAL
*-- ========                                                          ===
*
   40 IF(NCAL.EQ.0) GO TO 50
      IF(JUCOMP('FULL',LCAL ,NCAL ).NE.0) LCALFU=.TRUE.
      IF(JUCOMP('FAST',LCAL ,NCAL ).NE.0) LCALFA=.TRUE.
      IF(JUCOMP('SMEA',LCAL ,NCAL ).NE.0) LCALSM=.TRUE.
      IF(LCALFU) THEN
        CHMAIL=' *** FULL calorimeter simulation has been selected ***'
        CALL GMAIL(1,1)
        CALL CHECK( CALDET, LGEOM, NGEOM, 'YES')
        CALL CHECK( CALDET, LFAST, NFAST, 'NO ')
        CALL CHECK( CALDET, LSETS, NSETS, 'YES')
        CALL CHECK( CALDET, LDIGI, NDIGI, 'YES')
        IF(MOD(IGOEXP,1000).LE.3) THEN
           CALL CHECK('SW  ',LGEOM,NGEOM,'NO ')
           CALL CHECK('SW  ',LSETS,NSETS,'NO ')
           CALL CHECK('SW  ',LDIGI,NDIGI,'NO ')
        ENDIF
        IF(MOD(IGOEXP,1000).LE.7) THEN
           CALL CHECK('TE  ',LGEOM,NGEOM,'NO ')
           CALL CHECK('TE  ',LSETS,NSETS,'NO ')
           CALL CHECK('TE  ',LDIGI,NDIGI,'NO ')
        ENDIF
        LALLFA  =  .FALSE.
        LALLSM  =  .FALSE.
*
      ELSEIF(LCALFA .OR. LCALSM) THEN
        IF(LCALFA) THEN
         CHMAIL=' **** FAST calorimeter simulation selected ****'
         CALL GMAIL(1,0)
         CHMAIL=' ** Hence FAST calorimeter geometry will be chosen. **'
         CALL GMAIL(0,0)
         CHMAIL=' ** WARNING - this option not fully implemented yet **'
         CALL GMAIL(0,1)
         CALL CHECK( CALDET, LFAST, NFAST, 'YES')
         IF(MOD(IGOEXP,1000).LE.3) CALL CHECK('SW  ',LFAST,NFAST,'NO ')
         IF(MOD(IGOEXP,1000).LE.6) CALL CHECK('TE  ',LFAST,NFAST,'NO ')
         LALLFU = .FALSE.
         LALLSM = .FALSE.
        ELSE
          CHMAIL=' **** SMEA calorimeter simulation selected ****'
          CALL GMAIL(1,0)
          CHMAIL=' ** Hence no calorimeter geometry will be set up. **'
          CALL GMAIL(0,1)
        ENDIF
        CALL CHECK( CALDET, LGEOM, NGEOM, 'NO')
        CALL CHECK( CALDET, LSETS, NSETS, 'NO')
        CALL CHECK( CALDET, LDIGI, NDIGI, 'NO')
      ELSE
        CHREP =' Must specify FULL FAST or SMEA on the CAL card'
        CALL REPORT('GOGFFR' , 12,'W')
      ENDIF
*
*-- PSAM  CARD                                                        PSAM
*-- ==========                                                        ====
*-- The presample simulation defaults to that of the calorimeters
*
   50 IF(NPSAM.EQ.0) THEN
         LPSFU = LCALFU
      ELSE
         IF(JUCOMP('FULL',LPSAM,NPSAM).NE.0) LPSFU = .TRUE.
      ENDIF
      IF(LPSFU) THEN
        CHMAIL=' **** FULL presampler simulation selected ****'
        CALL GMAIL(1,1)
        CALL CHECK('BD  PE  ',LGEOM,NGEOM,'YES')
        CALL CHECK('BD  PE  ',LFAST,NFAST,'NO')
        CALL CHECK('TB  PB  PE  ',LSETS,NSETS,'YES')
        CALL CHECK('TB  PB  PE  ',LDIGI,NDIGI,'YES')
        IF(MOD(IGOEXP,1000).GE.8) THEN
          CALL CHECK('TE  ',LGEOM,NGEOM,'YES')
          CALL CHECK('TE  ',LFAST,NFAST,'NO')
          CALL CHECK('TE  ',LSETS,NSETS,'YES')
          CALL CHECK('TE  ',LDIGI,NDIGI,'YES')
        ENDIF
        LALLFA  =  .FALSE.
        LALLSM  =  .FALSE.
      ELSEIF(LCALFA .OR. LCALSM) THEN
        CHMAIL=' **** FAST presampler simulation selected ****'
        CALL GMAIL(1,0)
        CHMAIL=' ** WARNING - this option not fully implemented yet **'
        CALL GMAIL(0,1)
        IF(LCALFA) THEN
          CALL CHECK('BD  PE  ',LFAST,NFAST,'YES')
          IF(MOD(IGOEXP,1000).GE.7) CALL CHECK('TE  ',LFAST,NFAST,'YES')
          LALLFU = .FALSE.
          LALLSM = .FALSE.
        ELSE
          LALLFU = .FALSE.
          LALLFA = .FALSE.
        ENDIF
        CALL CHECK('BD  PE  ',LGEOM,NGEOM,'NO')
        CALL CHECK('TB  PB  PE  ',LSETS,NSETS,'NO')
        CALL CHECK('TB  PB  PE  ',LDIGI,NDIGI,'NO')
        IF(MOD(IGOEXP,1000).GE.8) THEN
          CALL CHECK('TE  ',LGEOM,NGEOM,'NO')
          CALL CHECK('TE  ',LSETS,NSETS,'NO')
          CALL CHECK('TE  ',LDIGI,NDIGI,'NO')
        ENDIF
      ENDIF
*
*-- FDET CARD                                                         FDET
*   =========                                                         ====
*-- The forward detector geometry is determined by the GEOM or CAL
*-- cards, and the tracking mode defaults to that of the calorimeters.
*-- However, the tracking mode can be set independently by using
*-- the FDET card.
*
  200 IF( NFDET .EQ. 0 )  THEN
         LFDFU  =  LCALFU
         LFDFA  =  LCALFA
         LFDSM  =  LCALSM
      ELSE
         IF(JUCOMP('FULL',LFDET,NFDET).NE.0) LFDFU=.TRUE.
         IF(JUCOMP('FAST',LFDET,NFDET).NE.0) LFDFA=.TRUE.
         IF(JUCOMP('SMEA',LFDET,NFDET).NE.0) LFDSM=.TRUE.
      ENDIF
*
      IF(LFDFU) THEN
        CHMAIL=' **** FULL FD simulation has been selected ****'
        CALL GMAIL(1,1)
        LALLFA = .FALSE.
        LALLSM = .FALSE.
        IF(MOD(IGOEXP,1000).GE.4) THEN
          CHMAIL=' **** FULL SW simulation has been selected ****'
          CALL GMAIL(1,1)
        ENDIF
      ELSEIF(LFDFA .OR. LFDSM) THEN
         IF(LFDFA) THEN
            CHMAIL=' ** FAST FD simulation has been selected   **'
            CALL GMAIL(1,0)
            CHMAIL=' ** WARNING - option not yet implemented   **'
            CALL GMAIL(0,1)
            LALLFU = .FALSE.
            LALLSM = .FALSE.
            IF(MOD(IGOEXP,1000).GE.4) THEN 
              CHMAIL=' ** FAST SW simulation has been selected   **'
              CALL GMAIL(1,0)
              CHMAIL=' ** WARNING - option not yet implemented   **'
            ENDIF
         ELSE
            CHMAIL=' ** SMEAr FD simulation has been selected  **'
            CALL GMAIL(1,0)
            LALLFU = .FALSE.
            LALLFA = .FALSE.
            IF(MOD(IGOEXP,1000).GE.4) THEN
              CHMAIL=' ** SMEAr SW simulation has been selected  **'
              CALL GMAIL(0,1)
            ENDIF
         ENDIF
      ELSEIF(NFDET.GT.0) THEN
         CHREP =' Must specify FULL FAST or SMEA on the FD card'
         CALL REPORT('GOGFFR',13,'W')
      ENDIF
*
*-- SMEA  CARD                                                        SMEA
*-- ==========                                                        ====
*
      IF(         NSMEAR.NE.0
     +    .AND. ( LFDSM .OR. LCALSM .OR. LCDSM ) )        THEN
*
*     In SMEAr mode - then the SMEAr card may be used
*
         IF(JUCOMP('FAST',LSMEAR,NSMEAR).NE.0) THEN
            LSMTRK=.TRUE.
         ENDIF
         IF(JUCOMP('FULL',LSMEAR,NSMEAR).NE.0) THEN
            LSMTRK=.FALSE.
         ENDIF
         IF(JUCOMP('DOCE',LSMEAR,NSMEAR).NE.0) THEN
            LSMCE =.TRUE.
         ENDIF
         IF(JUCOMP('NOCE',LSMEAR,NSMEAR).NE.0) THEN
            LSMCE =.FALSE.
         ENDIF
      ENDIF
*
      IF(LALLSM) THEN
         CHMAIL=' +---------------------------------+'
         CALL GMAIL(1,0)
         CHMAIL=' |** All detectors in SMEAr mode **|'
         CALL GMAIL(0,0)
         IF(LSMCE) THEN
            CHMAIL=' |** Will fill CT,EM,HC,MU banks **|'
            CALL GMAIL(0,0)
            CHMAIL=' |** and call CEBAT/ODBAT.       **|'
            CALL GMAIL(0,0)
         ELSE
            CHMAIL=' |** Will fill OD banks directly **|'
            CALL GMAIL(0,0)
         ENDIF
         IF(LSMTRK) THEN
            CHMAIL=' |** Simplified "FAST" tracking  **|'
            CALL GMAIL(0,0)
            CHMAIL=' |** No geometry will be set up  **|'
            CALL GMAIL(0,0)
         ELSE
            CHMAIL=' |** "FULL" Geant tracking chosen *|'
            CALL GMAIL(0,0)
         ENDIF
         CHMAIL=' +---------------------------------+'
         CALL GMAIL(0,1)
      ENDIF
*
*--   NODEtector mode - pretty much nothing to do.
*
  150 IF(NODET.EQ.1 .OR. LSMTRK) THEN
         CALL VFILL(LGEOM,20,MBLANK)
         NGEOM=0
         CALL VFILL(LFAST,20,MBLANK)
         NFAST=0
         CALL VFILL(LDIGI,20,MBLANK)
         NDIGI=0
         IUTRAK=0
         IUHITS=0
         IFLD=0
         GO TO 99
      ENDIF
*
*--      Declare all detector cheat words if 'ALL ' is specified.
      IF(NCHEAT.EQ.1 .AND. LCHEAT(1).EQ.LALL) THEN
         CALL UCOPY(LDIGIO,LCHEAT,NDIGIO)
         CALL GETNUM(LCHEAT,NCHEAT)
      ENDIF
*
*--      Display modified running configuration.
*
      CHMAIL=' Summary of options chosen for this run'
      CALL GMAIL(3,0)
      CHMAIL=' ======================================'
      CALL GMAIL(0,0)
      IF(NGEOM.NE.0) THEN
      CHMAIL=' The following parts of the detector will have FULL'//
     +' geometrical representation:-'
        CALL GMAIL(1,0)
        WRITE(CHMAIL,FMT='(1X,20A5)') (LGEOM(J),J=1,NGEOM)
        CALL GMAIL(0,0)
      ENDIF

      IF(NFAST.NE.0) THEN
      CHMAIL=' The following parts of the detector will have FAST'//
     +' geometrical representation:-'
        CALL GMAIL(1,0)
         WRITE(CHMAIL,FMT='(1X,20A5)') (LFAST(J),J=1,NFAST)
        CALL GMAIL(0,0)
      ENDIF
*
      IF(NSETS.NE.0) THEN
      CHMAIL=' HITS will be stored for the following'// ' detectors:-'
         CALL GMAIL(1,0)
         WRITE(CHMAIL,FMT='(1X,20A5)') (LSETS(J),J=1,NSETS)
         CALL GMAIL(0,0)
      ENDIF
*
      IF(NDIGI.NE.0) THEN
      CHMAIL=' DIGIts (raw data) will be stored for the following'//
     +' detectors:-'
         CALL GMAIL(1,0)
         WRITE(CHMAIL,FMT='(1X,20A5)') (LDIGI(J),J=1,NDIGI)
         CALL GMAIL(0,0)
      ENDIF
*
      IF(NCHEAT.NE.0) THEN
      CHMAIL=' CHEAt words will be stored for the following detectors:-'
         CALL GMAIL(1,0)
         WRITE(CHMAIL,FMT='(1X,20A5)') (LCHEAT(J),J=1,NCHEAT)
         CALL GMAIL(0,0)
      ENDIF
*
C      WRITE(6,*) ' CDFU,CDFA,CDSM    ',LCDFU,LCDFA,LCDSM
C      WRITE(6,*) ' SIFU,SIFA,SISM    ',LSIFU,LSIFA,LSISM
C      WRITE(6,*) ' CALFU,CALFA,CALSM ',LCALFU,LCALFA,LCALSM
C      WRITE(6,*) ' PSFU              ',LPSFU
C      WRITE(6,*) ' FDFU,FDFA,FDSM    ',LFDFU,LFDFA,LFDSM
C      WRITE(6,*) ' ALLFU,ALLFA,ALLSM ',LALLFU, LALLFA, LALLSM
*
   99 RETURN
      END
+DECK,GOGINT.
      SUBROUTINE GOGINT (NTRAK,ITKDM,PTRAK,IDTRAK,IHSTRY,VTX)
*.
*...GOGINT
*.
*. Routine to book and fill the GOPAL event generator TREE and JET banks,
*. given a "generic" event generator record which is passed as
*. an argument list (in order to eliminate generator dependence).
*. This is a modified version of the subroutine GOLINT.
*. The author of GOLINT is S.L.Lloyd.
*.
*. SEQUENCE  : GCBANK LINKRA RCREP GOPAR GOXTRA
*. CALLS     : GOTORD MZBOOK REPORT PDGCHG PRIJET
*. CALLED    :
*.
*. BANKS L   : GENE TREE JETS
*.
*. IN/OUTPUT : NTRAK   The number of entries in the event record
*. IN/OUTPUT : ITKDM   The first dimension of PTRAK
*. IN/OUTPUT : PTRAK   The 5-momenta array (Px,Py,Pz,E,M)
*. IN/OUTPUT : IDTRAK  The IDs of the particles in the event record
*. IN/OUTPUT : IHSTRY  The history of the particles in the event record
*. INPUT     : VTX     The vertex location for the event
*.
*. This routine has been tested for
*.   (1) Multi-hadronic events (5 flavors), Jetset71 and 72
*.   (2) Multi-hadronic events (5 flavors), Herwig32 and 43
*.   (3) Top quark multi-hadronic events, Jetset71
*.   (4) Top quark multi-hadronic events, Herwig32
*.
*. AUTHOR    : J.W.Gary,  modified from GOLINT
*.                        The author of GOLINT is S.L.Lloyd.
*. CREATED   : 18-Mar-89
*. LAST MOD  : 18-Mar-96
*.
*. Modification Log.
*. 18-Mar-96  C.P.Ward  Add call to GOTORD to order TREE
*.  5-Sep-95  C.P.Ward  Another fix for Pythia events
*. 28-Apr-95  S.Lloyd   Fix bug - allow one-particle decays (K0)
*. 16-May-94  C.P.Ward  Fix for Pythia events.
*. 08-Dec-93  C.P.Ward  Remove unused variables.
*. 17-Sep-92  J.W.GARY  Add option for COJETS            
*. 31-May-90  J.W.GARY  Fix for Jetset parton history    
*. 03-May-91  S.L.Lloyd Book and fill XTRA bank          
*. 08-May-89  Various modifications to handle top production in Jetset71
*.
*.*********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCBANK.
+SEQ,LINKRA.
+SEQ,GOPAR.
+SEQ,GOXTRA.
      INTEGER  NTRAK,ITKDM,IID,IL,IJ,ILABL,IQ1,IQ2,IQQ1,IQQ2,INDX,
     +         IPARNT,IPOS,IPRCNT
      INTEGER  IDTRAK (*),IHSTRY (*),IDKMPS (6)
      REAL  PTRAK (ITKDM,*),VTX (*)
      INTEGER NGEN,NPRIM,NJET,NSJET,NP,NJ,LGENE,LENT,LENJ,IOTREE,
     +        LTREE,LJETS,KH,NADD,NJJ,LPAR,LL,NSEC,
     +        IOJETS,ICHRG,LXTRA
      LOGICAL  DKPRTN,DKHDRN,PRMJT,DIQRK
 
*  fix for parton history of Jetset72 events
*  --- --- ------ ------- -- -------- ------
      IPOS = 0
      IF (IDTRAK (1).EQ.22) IPOS = 1
      DO 105 IJ = IPOS+1,IPOS+4
         IF (IABS (IDTRAK (IJ)).GT.5) GO TO 106
 105  CONTINUE
      IF (IDTRAK (IPOS+5).EQ.92.OR.IDTRAK (IPOS+5).EQ.91) THEN
         IF (IHSTRY (IPOS+5).LT.2.OR.IHSTRY (IPOS+5).GT.3) GO TO 106
         IHSTRY (IPOS+4) = IPOS + 2
         IHSTRY (IPOS+5) = 4003
         IF (IPOS.EQ.1) IHSTRY (IPOS+5) = 5004
      END IF
*  determine space required for banks
*  --------- ----- -------- --- -----
 106  NP = 0
      NJ = 0
      DO 110 IL=1,NTRAK
         IID = IABS (IDTRAK (IL))
*      C.M. energy documentation in Jetset71
*      ---- ------ ------------- -- --------
         IF (IID.EQ.93) GO TO 110
*      partons, ID=92 is string, ID=91 a cluster, ID=95 independent frag.
*      -------  ----- -- ------  ----- - -------  ----- ----------- ----
         DIQRK = .FALSE.
         CALL IDECOD (IID,IDKMPS)
         IF (IDKMPS (2).EQ.0.AND.IDKMPS (4).NE.0) DIQRK = .TRUE.
         IF ((IID.LE.8.OR.IID.EQ.21.OR.DIQRK).OR.
     +       (IID.EQ.91.OR.IID.EQ.92.OR.IID.EQ.95)) THEN
            NJ = NJ + 1
         ELSE
            NP = NP + 1
         ENDIF
 110  CONTINUE
*  create particle and jet banks; include extra space for tracking
*  ------ -------- --- --- -----  ------- ----- ----- --- --------
      NP = 2*NP
      LGENE = LQ (LMC-1)
      LENT = IQ (LGENE+5)
      LENJ = IQ (LGENE+6)
      IOTREE = IQ (LGENE+7)
      IOJETS = IQ (LGENE+8)
      CALL MZBOOK(IXDIV,LTREE,LGENE,-LLTREE,'TREE',0,0,NP*LENT,IOTREE,0)
      CALL MZBOOK(IXDIV,LJETS,LGENE,-LLJETS,'JETS',0,0,NJ*LENJ,IOJETS,0)
      IF (NWXTRA.GT.0) THEN
        CALL MZBOOK(IXDIV,LXTRA,LGENE,-LLXTRA,'XTRA',0,0,NWXTRA,3,0)
        CALL UCOPY (RXTRA,Q(LXTRA+1),NWXTRA)
      ENDIF
      LTREE = LQ(LGENE-LLTREE)
      LJETS = LQ(LGENE-LLJETS)
*  loop over event record, enter partons, strings and clusters into jet    bank;
*  location 2 of jet bank temporarily holds their event record positions
*  -------- - -- --- ---- ----------- ----- ----- ----- ------ ---------
      NJET  = 0
      DO 130 IL=1,NTRAK
         IID = IABS (IDTRAK (IL))
         IF (IID.EQ.93) GO TO 130
         DIQRK = .FALSE.
         CALL IDECOD (IID,IDKMPS)
         IF (IDKMPS (2).EQ.0.AND.IDKMPS (4).NE.0) DIQRK = .TRUE.
         IF ((IID.LE.8.OR.IID.EQ.21.OR.DIQRK).OR.
     +       (IID.EQ.91.OR.IID.EQ.92.OR.IID.EQ.95)) THEN
            NJET = NJET + 1
            NADD = LJETS + (NJET-1)*LENJ
            DO 120 IJ=1,5
               Q (NADD+3+IJ) = PTRAK (IJ,IL)
 120        CONTINUE
            IQ (NADD+1) = IDTRAK (IL)
            IQ (NADD+2) = IL
*          change independent fragmentation code to PDG standard 93
*          ------ ----------- ------------- ---- -- --- -------- --
            IF (IDTRAK (IL).EQ.95) IQ (NADD+1) = 93
         END IF
 130  CONTINUE
*  loop  over jet bank entries, find directly produced hadrons;
*  location 3 of tree bank temporarily holds their event record positions
*  -------- - -- ---- ---- ----------- ----- ----- ----- ------ ---------
      IPRCNT = 0
      NPRIM = 0
      NSJET = 0
      NJJ = NJET
*CPW mod 5/9/95 Start loop at zero so primary particles appear before
*               final state photons in Pythia events
      DO 180 NJ=0,NJJ
         IF (NJ.NE.0) THEN
            IPOS = IQ (LJETS+(NJ-1)*LENJ+2)
            KH = IHSTRY (IPOS)
            CALL  PRIJET (IPOS,IDTRAK,IHSTRY,PRMJT)
            IF (.NOT.PRMJT) NSJET = NSJET + 1
*         use location 3 of jet bank for parton history (temporary)
*         --- -------- - -- --- ---- --- ------ -------  ---------
            IF (KH.EQ.0.OR.NJ.EQ.1) THEN
               IQ (LJETS+(NJ-1)*LENJ+3) = 0
            ELSE
*            string or cluster history
*            ------ -- ------- -------
               IID = IABS (IDTRAK (IPOS))
               IF (IID.EQ.91.OR.IID.EQ.92) THEN
                  IQ1 = NINT (FLOAT (KH)/1000.)
                  IQ2 = MOD (KH,1000)
                  IQQ1 = 0
                  IQQ2 = 0
                  DO 140 IJ=1,NJ-1
                     ILABL = IQ (LJETS+(IJ-1)*LENJ+2)
                     IF (ILABL.EQ.IQ1) IQQ1 = IJ
                     IF (ILABL.EQ.IQ2) IQQ2 = IJ
 140              CONTINUE
                  IQ (LJETS+(NJ-1)*LENJ+3) = IQQ1 + (1000*IQQ2)
                  IF (IQQ1.EQ.0.OR.IQQ2.EQ.0) THEN
                     WRITE (CHREP,FMT='('' One of IQQ1,IQQ2='',
     +                 2I6,'' is zero'')') IQQ1,IQQ2
                     CALL REPORT('GOGINT',1,'W')
                  END IF
               ELSE
*               parton shower history
*               ------ ------ -------
                  DO 150 IJ=1,NJ-1
                     ILABL = IQ (LJETS+(IJ-1)*LENJ+2)
                     IF (KH.EQ.ILABL) THEN
                        IQ (LJETS+(NJ-1)*LENJ+3) = IJ
                     END IF
 150              CONTINUE
               END IF
            END IF
         ELSE
            PRMJT = .TRUE.
         END IF
*      enter the direct hadrons into tree bank
*      ----- --- ------ ------- ---- ---- ----
         DO 170 IL=1,NTRAK
            IID = IABS (IDTRAK (IL))
            KH = IHSTRY (IL)
            IF (IID.EQ.93) GO TO 170
            DIQRK = .FALSE.
            CALL IDECOD (IID,IDKMPS)
            IF (IDKMPS (2).EQ.0.AND.IDKMPS (4).NE.0) DIQRK = .TRUE.
            IF ((IID.LE.8.OR.IID.EQ.21.OR.DIQRK).OR.
     +          (IID.EQ.91.OR.IID.EQ.92.OR.IID.EQ.95)) GO TO 170
*         photon in onium decays or single particles
*         ------ -- ----- ------ -- ------ ---------
            IF (KH.EQ.0.AND.NJ.EQ.0) GO TO 155
*         skip if parent is not this jet or if there are no jets
*         ---- -- ------ -- --- ---- --- -- -- ----- --- --- ---
            IF (NJ.EQ.0.OR.KH.NE.IPOS) GO TO 170
 155        CONTINUE
C**CPW 16/5/94            IF (PRMJT) IPRCNT = IPRCNT + 1
            IF (PRMJT .OR. KH.EQ.0) IPRCNT = IPRCNT + 1
            NPRIM = NPRIM + 1
            NADD = LTREE + (NPRIM-1)*LENT
            DO 160 IJ=1,5
               Q (NADD+10+IJ) = PTRAK (IJ,IL)
 160        CONTINUE
            CALL PDGCHG (IDTRAK (IL),ICHRG)
            Q (NADD+10+6) = NINT (FLOAT (ICHRG) / 3.)
            Q (NADD+10+7) = VTX (1)
            Q (NADD+10+8) = VTX (2)
            Q (NADD+10+9) = VTX (3)
            IQ (NADD+3) = IL
            IQ (NADD+1) = IDTRAK (IL)
            IQ (NADD+6) = NJ
            IF (KH.EQ.0) IQ (NADD+6) = 0
            IQ (NADD+9) = 1
            IF (ICHRG.EQ.0) THEN
               IQ (NADD+10) = 0
            ELSE
               IQ (NADD+10) = 1
            ENDIF
 170     CONTINUE
 180  CONTINUE
*  find the decay products of the direct hadrons
*  ---- --- ----- -------- -- --- ------ -------
      NP = 0
      NGEN = NPRIM
 200  NP = NP + 1
      DKPRTN = .FALSE.
      DKHDRN = .FALSE.
      LPAR = IQ (LTREE+(NP-1)*LENT+3)
      IQ (LTREE+(NP-1)*LENT+3) = 0
      LL = LPAR + 1
      NSEC = 0
      DO 280 IL=LL,NTRAK
         KH = IHSTRY (IL)
*      skip if parent not this particle
*      ---- -- ------ --- ---- --------
         IF (KH.NE.LPAR) GO TO 280
*      decay flag for parent
*      ----- ---- --- ------
         NSEC = NSEC + 1
         NADD = LTREE + (NP-1)*LENT
         IF (NSEC.EQ.1) IQ (NADD+10) = -1
*      secondary partons (partons produced in the decay of a hadron)
*      --------- -------  ------- -------- -- --- ----- -- - ------
         IID = IABS (IDTRAK (IL))
         DIQRK = .FALSE.
         CALL IDECOD (IID,IDKMPS)
         IF (IDKMPS (2).EQ.0.AND.IDKMPS (4).NE.0) DIQRK = .TRUE.
         IF ((IID.LE.8.OR.IID.EQ.21.OR.DIQRK).OR.
     +       (IID.EQ.91.OR.IID.EQ.92.OR.IID.EQ.95)) GO TO 240
*      enter "hadron" decay daughters into tree bank
*      -----  ------  ----- --------- ---- ---- ----
         DKHDRN = .TRUE.
         NGEN = NGEN + 1
         IF (NSEC.EQ.1) IQ (NADD+3) = NGEN
         IQ (NADD+4) = IQ (NADD+4) + 1
         NADD = LTREE + (NGEN-1)*LENT
         DO 210 IJ=1,5
            Q (NADD+10+IJ) = PTRAK (IJ,IL)
 210     CONTINUE
         CALL PDGCHG (IDTRAK (IL),ICHRG)
         Q (NADD+10+6) = NINT (FLOAT (ICHRG) / 3.)
         Q (NADD+10+7) = VTX (1)
         Q (NADD+10+8) = VTX (2)
         Q (NADD+10+9) = VTX (3)
         IQ (NADD+1) = IDTRAK (IL)
         IQ (NADD+2) = NP
         IQ (NADD+3) = IL
         IQ (NADD+6) = IQ (LTREE+(NP-1)*LENT+6)
         IQ (NADD+9) = 2
         IF (ICHRG.EQ.0) THEN
            IQ (NADD+10) = 0
         ELSE
            IQ (NADD+10) = 1
         ENDIF
         GO TO 280
*      pointer to parton decay daughters in jet bank
*      ------- -- ------ ----- --------- -- --- ----
 240     DKPRTN = .TRUE.
         IQ (NADD+4) = IQ (NADD+4) + 1
         DO 260 IJ = 1,NJET
            INDX = LJETS + (IJ-1)*LENJ
            IPOS = IQ (INDX+2)
            IF (IPOS.EQ.IL) THEN
               IQ (INDX+3) = -NP
               IF (NSEC.EQ.1) IQ (NADD+3) = -IJ
               GO TO 280
            END IF
 260     CONTINUE
 280  CONTINUE
*   a hadron can decay to both hadrons and partons in top events
*   - ------ --- ----- -- ---- ------- --- ------- -- --- ------
      IF (DKHDRN.AND.DKPRTN) THEN
         WRITE (CHREP,FMT='('' Tree entry'',I6,'', ID ='',I8,
     +     '' has both hadron and parton daughters'')') NP,
     +     IQ (LTREE+(NP-1)*LENT+1)
         CALL REPORT('GOGINT',2,'I')
      END IF
 290  IF (NP.LT.NGEN) GO TO 200
*   move parton shower history to position 2 in jet bank
*   ---- ------ ------ ------- -- -------- - -- --- ----
      IF (NJET.NE.0) THEN
         DO 310 IJ=1,NJET
            INDX = LJETS + (IJ-1)*LENJ + 3
            IPARNT = IQ (INDX)
            IF (IPARNT.GE.0) THEN
               IQ (INDX-1) = IQ (INDX)
               IQ (INDX) = 0
            ELSE
               IQ (INDX-1) = 0
               IQ (INDX) = - IQ (INDX)
            END IF
 310     CONTINUE
      END IF
      NJET = NJET - NSJET
      IQ (LGENE+1) = NGEN
      IQ (LGENE+2) = IPRCNT
      IQ (LGENE+3) = NJET
      IQ (LGENE+4) = NSJET
*
*--- Sort TREE entries into order if necessary
*
      CALL GOTORD
* 
      RETURN
      END
+DECK,GOHBOK
      SUBROUTINE GOHBOK
*.
*...GOHBOK   Book standard histograms (if requested)
*.
*. COMMON    :
*. SEQUENCE  : GCKINE GCLIST
*. CALLS     : HBOOK2
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : C.M.Roach/W.J.Murray
*. VERSION   : 1.00
*. CREATED   : 27-Nov-87
*. LAST MOD  : 28-Jun-89
*.
*. Modification Log.
*. 28-Jun-89   D.R.Ward      Change some more limits
*. 25-Jul-88   D.R.Ward      Modify limits; add PE
*. 10-May-88   D.R.Ward      Add 'DST ' option
*. 26-Apr-88   D.R.Ward      Strong type
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER JUCOMP
      EXTERNAL JUCOMP
*
+SEQ,GCLIST.
+SEQ,GCKINE.
      IF(JUCOMP('RAWD',LHSTA,NHSTA).NE. 0.AND. IKINE.EQ.5) THEN
         CALL HBOOK2(-101,'N hits in CV vs theta$', 90,0.,180.,50,0.,
     +   150.,31.)
         CALL HBOOK2(-102,'N hits in CJ vs theta$', 90,0.,180.,50,0.,
     +   500.,31.)
         CALL HBOOK2(-103,'N hits in CZ vs theta$', 90,0.,180.,20,0.,
     +   20.,31.)
         CALL HBOOK2(-104,'Amplitude in TOF vs theta$' ,90,0.,180.,50,
     +   0.,5000.,31.)
         CALL HBOOK2(-105,
     +   'Amplitude in U strips of presampler vs theta$' ,90,0.,180.,25,
     +   0.,5000.,31.)
         CALL HBOOK2(-106,
     +   'Amplitude in V strips of presampler vs theta$' ,90,0.,180.,25,
     +   0.,5000.,31.)
         CALL HBOOK2(-107,'Amplitude in W wires of presampler vs theta$'
     +   ,90,0.,180.,25,0.,7000.,31.)
         CALL HBOOK2(-108,'N hits in MB vs theta$', 90,0.,180.,10,0.,
     +   10.,31.)
         CALL HBOOK2(-109,'N hits in ME vs theta$', 90,0.,180.,25,0.,
     +   75.,31.)
         CALL HBOOK2(-112,'GeV in EE 1 vs theta$', 90,0.,180.,25,0.,1.,
     +   31.)
         CALL HBOOK2(-113,'GeV in EE 2 vs theta$', 90,0.,180.,25,0.,1.,
     +   31.)
         CALL HBOOK2(-114,'Signal in PE vs theta$',90,0.,180.,25,0.,
     +   25.,31.)
         CALL HBOOK2(-116,'GeV in EB vs theta$', 90,0.,180.,25,0.,.8,
     +   31.)
         CALL HBOOK2(-117,'pCOULOMBS in HB vs theta$', 90,0.,180.,25,0.,
     +  1250.,31.)
         CALL HBOOK2(-118,'pCOULOMBS in HE vs theta$', 90,0.,180.,25,
     +   0.,800.,31.)
         CALL HBOOK2(-119,'pCOULOMBS in HP vs theta$', 90,0.,180.,25,
     +   0.,800.,31.)
      ENDIF
*
      IF(JUCOMP('DST ',LHSTA,NHSTA).NE.0) THEN
         CALL HBOOK1(9001,'Number of CD tracks',100,0.,100.,0.)
         CALL HBOOK1(9002,'Number of EM clusters',100,0.,100.,0.)
         CALL HBOOK1(9003,'Number of HC clusters',50,0.,50.,0.)
         CALL HBOOK1(9004,'Number of MUon tracks',50,0.,50.,0.)
         CALL HBOOK1(9011,'CD track momentum (signed by charge)', 100,
     +   -50.,50.,0.)
         CALL HBOOK1(9012,'CD track momentum (signed by charge)', 100,
     +   -5.,5.,0.)
         CALL HBOOK1(9013,'CD track cos(theta*)',100,-1.,1.,0.)
         CALL HBOOK1(9014,'CD track chisq (r-phi)',100,0.,100.,0.)
         CALL HBOOK1(9021,'Energy of ECAL clusters',100,0.,50.,0.)
         CALL HBOOK1(9022,'Energy of ECAL clusters',100,0.,5.,0.)
         CALL HBOOK1(9023,'Sum ECAL energy',100,0.,100.,0.)
         CALL HBOOK1(9031,'Sum HCAL energy',100,0.,100.,0.)
      ENDIF
*
      RETURN
      END
+DECK,GOHFIL.
      SUBROUTINE GOHFIL
*.
*...GOHFIL   Accumulate statistics and (optionally) fill standard histog
*.
*. COMMON    : GOSTAT
*. SEQUENCE  : CZRA   CZRT   EBPARM EBXLNC FDDCON
*. SEQUENCE  : GCBANK GCKINE GCLIST GCNUM  GCTRAK GOSTAT LINKRA
*. SEQUENCE  : HSLINT HSPAR  HTLINT HTPAR  LCZWLN
*. SEQUENCE  : RCREP  ROCPAR ROPAR  RBITFUNC
*. SEQUENCE  : SILINK TBRAWCOM TBRAWPAR
*. CALLS     : GFKINE HFILL
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : W.J.Murray/C.M.Roach/D.R.Ward
*. VERSION   : 2.00
*. CREATED   : 27-Nov-87
*. LAST MOD  : 18-Feb-96
*.
*. Modification Log.
*. 18-Feb-96   T.Mashimo     Use EBCC bank instead of hard-coded values
*.                           for (ADC counts->GeV).
*. 11-Apr-94   C.P.Ward      Fix mixed mode arithmetic.
*. 08-Dec-93   C.P.Ward      Remove unused variables
*. 16-Apr-91   V.Gibson      Handle SI FASTBUS format
*. 28-Jul-90   D.R.Ward      Ped subtract FD
*. 18-Jul-90   D.R.Ward      Add SI
*. 17-Apr-90   G.W.Wilson    TB mods
*. 15-Feb-90   M.Redmond     Mods for PB
*. 15-Aug-89   S.W.O'Neale   Cray division problem
*. 19-Jul-89   S.Weisz       Tidy up HT/HS
*.  1-Jul-89   B.W.Kennedy   Unpack FD calorimeter data before summing.
*. 28-Jun-89   G.W.Wilson    Mods for TB - preliminary
*. 26-Jun-89   A.Buijs       Modify HB and HE statistics.
*.  7-Jun-89   D.R.Ward      LLCZTD not declared - try to fix???
*.  7-Jun-89   B.Lorazo      CZ statistics now deals with multiplexed hits
*.  1-Jun-89   D.R.Ward      KINE/VERT no longer hang on MC
*.  5-Apr-89   B.Kennedy     Mods for FD
*.  5-Apr-89   D.Hochman     Mods for PE
*. 21-Mar-89   C.P.Ward      Mods for EE
*. 21-Mar-89   D.R.Ward      Mods for MB
*. 28-Feb-89   D.R.Ward      Check # links on VERT
*. 26-Feb-89   ?????????     Mode for new ME data format
*. 21-Feb-89   M.Redmond     Update for new PB raw data bank format
*. 14-Feb-89   T.Mashimo     Mods for new EB data format
*. 27-Sep-88   D.R.Ward      Protection in NODE mode.
*. 25-Jul-88   D.R.Ward      Fix sundry things that have stopped working
*. 15-Jul-88   R.Hemingway   Update for new CV raw data bank format
*. 12-Jul-88   P.Hattersley  New ME bank format
*. 19-May-88   D.R.Ward      New CZ raw data structure
*.  6-May-88   D.R.Ward      Deal with multiple primary vertices
*. 25-Apr-88   D.R.Ward      Strong typing
*. 11-Mar-88   D.R.Ward      Fix a few bugs
*. 10-feb-88   D.R.Ward      Handle new ME data structure
*. 18-Dec-87   D.Hochman     Protect ATAN2
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,GCTRAK.
+SEQ,GCBANK.
+SEQ,GCNUM .
+SEQ,LINKRA.
+SEQ,GCLIST.
+SEQ,GCKINE.
+SEQ,GOSTAT.
+SEQ,RCREP.
+SEQ,ROCPAR.
+SEQ,ROPAR.
+SEQ,FDDCON.
+SEQ,CZRA.
+SEQ,CZRT.
+SEQ,LCZWLN.
+SEQ,TBRAWPAR.
+SEQ,TBRAWCOM.
+SEQ,EBPARM.
+SEQ,EBXLNC.
+SEQ,HTPAR.
+SEQ,HTLINT.
+SEQ,HSPAR.
+SEQ,HSLINT.
+SEQ,SILINK.
+SEQ,RBITFUNC.
      INTEGER LKINH,NTRAK,LTRAK,IP,IVORIG,LVERH,NVERT,JVERT,LVERT,
     +LVERU,II,ND,JJ,LDATR,LCVDH,NCVHIT,NDATA,NHIT,IWIRE,
     +LCJRA,LCJDE,NCJHIT,JSEC,LCJDS,LCZRA,NCZHIT,NGRP, IZGP,LTBRA,IAMP,
     +N,IBAR,LPBRA,ILOC,IAMU,IAMV,IAMW,IADDR, JADDR,KADDR,LEN,KU,KV,KW,
     +LMBRA,NMBHIT,LMERA,NSIG,JLAY,LEERA,NBLOCK,
     +MBLOCK,LEERE,LEBRA,IWORD,IADRS,IADC,LHPRA,LHPT,
     +JTOWER,IPULSE,LPERA, LINK,IAD,I,J,K,LFDRA,IEND,LFDRI,JUCOMP,
     +ITRAK,IUCOMP, NUBUF,JBYT,LCZRT,NTWOBT,IODD,IPSW,LFDHI,
     +NSTRIP,NQDPL,NOFF,NEXTRA,NTRIG
      REAL     CIACOA,TBIADC,TEIADC
      INTEGER NTBRED
      INTEGER  IDEV
      EXTERNAL IUCOMP,JUCOMP,JBYT
      REAL AVERT(3),PMOM(4),UBUF(2),PMO,THETA,PHI,SUMSIG,GEV,
     +TPULSE,PH,SUM,ADC
      LOGICAL IFHIST
      INTEGER NRAHD, NCCHD, IADCDA, IADCLO
      REAL    ENERGY
*
*--   The statistics will always be accumulated.  The histograms will
*--   only be filled if
*--   (a) You select option 'RAWD' on the HSTA card
*--   (b) The single particle generator G1PART is selected (IKINE=5)
*
      IFHIST=.FALSE.
      IF(JUCOMP('RAWD',LHSTA,NHSTA).NE. 0.AND. IKINE.EQ.5) IFHIST=.TRUE.
      NEVTS=NEVTS+1
*
*     Look at the KINE banks.
*
      LKINH=JKINE
      NTRAK=NTRACK
      IF(LKINH.EQ. 0.OR. NTRAK.EQ.0) GO TO 20
      DO 10 ITRAK=1,NTRAK
         LTRAK=LQ(LKINH-ITRAK)
         IF(LTRAK.EQ.0) GO TO 10
         PMO=SQRT(Q(LTRAK+1)**2+Q(LTRAK+2)**2+Q(LTRAK+3)**2)
         IP=3
         IF(PMO.GT.0.03) IP=4
         IF(PMO.GT.0.1) IP=5
         IF(PMO.GT.0.2) IP=6
         IF(PMO.GT.0.3) IP=7
         IF(PMO.GT.1.0) IP=8
         IF(PMO.GT.2.0) IP=9
         IF(PMO.GT.5.0) IP=10
         IF(PMO.GT.10.) IP=11
         IF(PMO.GT.20.) IP=12
         IPART=Q(LTRAK+5)
         IF(IPART.LE. 0.OR. IPART.GE.50) IPART=50
         IVORIG=Q(LTRAK+6)
         IF(IVORIG.LE.NVPRIM) THEN
            IVORIG=1
         ELSE
            IVORIG=2
         ENDIF
         SKIN(IPART,1,IVORIG)=SKIN(IPART,1,IVORIG)+1.
         SKIN(IPART,2,IVORIG)=SKIN(IPART,2,IVORIG)+PMO
         SKIN(IPART,IP,IVORIG)=SKIN(IPART,IP,IVORIG)+1.
   10 CONTINUE
   20 CONTINUE
*
*     and VERT banks
*
      LVERH=JVERTX
      NVERT=NVERTX
      MVPRIM=MVPRIM+NVPRIM
      IF(LVERH.EQ. 0.OR. NVERT.LE.NVPRIM) GO TO 50
      DO 40 JVERT=NVPRIM+1,NVERT
         LVERT=LQ(LVERH-JVERT)
         IF(LVERT.EQ.0) GO TO 40
         IF(IQ(LVERT-3).EQ.0) GO TO 40
         LVERU=LQ(LVERT-1)
         IF(LVERU.EQ.0) GO TO 40
         II=IUCOMP(IQ(LVERU+1),KVOLU,NVO)
         IF(II.EQ.0) THEN
            IF(NVO.LT.199) THEN
               NVO=NVO+1
               KVOLU(NVO,1)=IQ(LVERU+1)
               KVOLU(NVO,2)=1
            ELSE
               KVOLU(200,2)=KVOLU(200,2)+1
            ENDIF
         ELSE
            KVOLU(II,2)=KVOLU(II,2)+1
         ENDIF
         ND=IQ(LVERU-1)
         IF(ND.GT.30) ND=30
         DO 30 JJ=2,ND
            II=IUCOMP(IQ(LVERU+JJ),NAMEC,30)
            IF(II.EQ.0) GO TO 30
            KMEC(II)=KMEC(II)+1
   30    CONTINUE
   40 CONTINUE
   50 CONTINUE
*
*     First find theta and phi for the original particle.
*     Call GFKINE for track # 1 (assuming only single particles generate
*
      IF(NTRACK.GT.0) THEN
         CALL GFKINE(1,AVERT,PMOM,IPART,NVERT,UBUF,NUBUF)
*--    Standard problem with Cray division so ensure number is in range
         THETA=ACOS(MAX(-1.0,MIN(1.0,
     +             (PMOM(3)/SQRT(PMOM(1)**2+PMOM(2)**2+PMOM(3)**2)))))
         THETA=THETA*180./3.14159
         PHI=0.
         IF(PMOM(1).NE.0. .AND. PMOM(2).NE.0.)
     +      PHI=ATAN2(PMOM(2),PMOM(1))
      ENDIF
*
*     Next look at the CV raw data banks.
*
      LDATR=LQ(LREV-3)
      IF(LDATR.EQ.0) GO TO 480
      LCVDH=LQ(LDATR-1)
      IF(LCVDH.EQ.0) GO TO 80
      NCVHIT=0
      NDATA=IQ(LCVDH-1)
      IF(NDATA.EQ.0) GO TO 80
      N=0
  55  CONTINUE
      N=N+1
      IWORD=IQ(LCVDH+N)
      NHIT=JBYT(IWORD,17,16)
      NHIT=(NHIT-1)/2
      IF(NHIT.EQ.0) GO TO 70
      DO 60 I=1,NHIT
         N=N+1
         IWORD=IQ(LCVDH+N)
         IWIRE=JBYT(IWORD,1,5)
         IF(IWIRE.LE.12) SDET(1,1)=SDET(1,1)+1.
         IF(IWIRE.GT.12) SDET(2,1)=SDET(2,1)+1.
         NCVHIT=NCVHIT+1
  60  CONTINUE
  70  CONTINUE
      IF(N.LT.NDATA) GO TO 55
      IF(IFHIST) CALL HFILL(-101,THETA,FLOAT(NCVHIT),1.)
*
*     Now look at the CJ raw data banks
*
   80 LCJRA=LQ(LDATR-2)
      IF (LCJRA.EQ.0) GO TO 100
      LCJDE=LQ(LCJRA-3)
      IF (LCJDE.EQ.0) GO TO 100
      NCJHIT=0
      DO 90 JSEC=1,24
         LCJDS=LQ(LCJDE-JSEC)
         IF (LCJDS.EQ.0) GO TO 90
         NCJHIT=NCJHIT+IQ(LCJDS+1)
   90 CONTINUE
      SDET(1,2)=SDET(1,2)+FLOAT(NCJHIT)
      IF(IFHIST) CALL HFILL(-102,THETA,FLOAT(NCJHIT),1.)
*
*    Now the CZ raw data banks
*
  100 LCZRA =LQ(LDATR -LLCZRA)
      NCZHIT =0
      IF(LCZRA .EQ. 0) GOTO 115
      LCZRT =LQ(LCZRA -LLCZRT)
      IF(LCZRT .EQ. 0) GOTO 115
*     -- NCZHIT is the number of multiplexed hits --
      NGRP =IQ(LQ(LCZRT -LLCZWD) +1)
      DO 110 IZGP =1 ,NGRP
        NCZHIT =NCZHIT +IQ(LQ(LCZRT -LLCZWD) +1 +NGRP +IZGP)
  110 CONTINUE
  115 SDET(1,3)=SDET(1,3)+FLOAT(NCZHIT)
      IF(IFHIST) CALL HFILL(-103,THETA,FLOAT(NCZHIT),1.)
*
*    Now for Time Of Flight
*
  120 LTBRA=LQ(LDATR-4)
      IAMP=0
      IF (LTBRA.EQ.0) GO TO 140
      NWSBTO = IQ(LTBRA+1)
      IF(NWSBTO.LE.1) GOTO 140
      NTBRED = 1
  130 IBAR=IQ(LTBRA+MBAR+NTBRED)
 
      IAMP=IAMP+IQ(LTBRA+MADCL+NTBRED)+IQ(LTBRA+MADCR+NTBRED)
      SDET(1,4)=SDET(1,4)+1.
      SDET(2,4)=SDET(2,4)+
     +            FLOAT(IQ(LTBRA+MADCL+NTBRED)+IQ(LTBRA+MADCR+NTBRED))
      NTBRED=NTBRED + NDATTO
      IF(NTBRED.LT.NWSBTO)GO TO 130
  140 IF(IFHIST) CALL HFILL(-104,THETA,FLOAT(IAMP),1.)
*
*    Next over to the em presampler barrel
*
  150 LPBRA=LQ(LDATR-5)
      IAMU=0
      IAMV=0
      IAMW=0
      IF (LPBRA.EQ.0) GO TO 210
*   ILOC is a location counter
      ILOC=LPBRA+1
      NTWOBT=IQ(LPBRA+1)
      IWORD=0
  160 IODD=MOD(IWORD,2)
      IADDR=IBITS(IQ(ILOC+1),16*(1-IODD),16)
      IF (IADDR.EQ.-1 .OR. IADDR.EQ.65535) THEN
        IF (IWORD.GE.NTWOBT-4) THEN
          IF (IQ(ILOC+1).EQ.-1) GOTO 210
          CHREP = 'PB Raw Data Termination Mark not found'
          CALL REPORT('GOHFIL',1,'E')
          GOTO 210
        ENDIF
        IWORD=IWORD+1
        ILOC=LPBRA+1+IWORD/2
        GOTO 160
      ENDIF
      JADDR=MOD(IADDR,2048)
      KADDR=JADDR-MOD(JADDR,512)
      LEN=IBITS(IQ(ILOC+1+IODD),IODD*16,16)
      IF (KADDR.EQ.0) THEN
         DO 170 KU=0,LEN-1
            IAMP=IBITS(IQ(ILOC+(KU+IODD)/2+2),MOD(KU+IODD+1,2)*16,16)
            IAMP = IAMP - 1024
            IF (BTEST(IAMP,15)) IAMP = IBITS(IAMP,0,12)*8
            SDET(1,5)=SDET(1,5)+1.
            SDET(4,5)=SDET(4,5)+FLOAT(IAMP)
            IAMU=IAMU+IAMP
  170    CONTINUE
         GOTO 200
      ENDIF
      IF (KADDR.EQ.512) THEN
         DO 180 KV=0,LEN-1
            IAMP=IBITS(IQ(ILOC+(KV+IODD)/2+2),MOD(KV+IODD+1,2)*16,16)
            IAMP = IAMP - 1024
            IF (BTEST(IAMP,15)) IAMP = IBITS(IAMP,0,12)*8
            SDET(2,5)=SDET(2,5)+1.
            SDET(5,5)=SDET(5,5)+FLOAT(IAMP)
            IAMV=IAMV+IAMP
  180    CONTINUE
         GOTO 200
      ELSE
         DO 190 KW=0,LEN/2-1
            IAMP=IBITS(IQ(ILOC+KW+2+IODD),IODD*16,16)
            IAMP = IAMP - 2048
            IF (BTEST(IAMP,15)) IAMP = IBITS(IAMP,0,13)*8
            SDET(3,5)=SDET(3,5)+1.
            SDET(6,5)=SDET(6,5)+FLOAT(IAMP)
            IAMW=IAMW+IAMP
  190    CONTINUE
      ENDIF
  200 IWORD=IWORD+LEN+2
      ILOC=LPBRA+1+IWORD/2
      GOTO 160
  210 IF(IFHIST) CALL HFILL(-105,THETA,FLOAT(IAMU),1.)
      IF(IFHIST) CALL HFILL(-106,THETA,FLOAT(IAMV),1.)
      IF(IFHIST) CALL HFILL(-107,THETA,FLOAT(IAMW),1.)
*
*    Now we turn to the muon barrel
*
  220 LMBRA=LQ(LDATR-12)
      IF (LMBRA.EQ.0) GO TO 230
      NMBHIT=IQ(LMBRA+3)
      SDET(1,12)=SDET(1,12)+FLOAT(NMBHIT)
      IF(IFHIST) CALL HFILL(-108,THETA,FLOAT(NMBHIT),1.)
*
*   The muon end-caps
*
  230 LMERA=LQ(LDATR-13)
      IF (LMERA.EQ.0) GO TO 270
      NSIG=0.
      SUMSIG=0.
      NTRIG=IQ(LMERA+1)
      NEXTRA=IQ(LMERA+NTRIG+2)
      NOFF=NTRIG+NEXTRA+3
      NQDPL=IQ(LMERA+NOFF)
      IF(NQDPL.EQ.0) GOTO 270
      DO 260 JLAY=1,NQDPL
         NOFF=NOFF+1
         NSTRIP=IQ(LMERA+NOFF)
         NSIG=NSIG+NSTRIP
         DO 250 JJ=1,NSTRIP
            NOFF=NOFF+1
            SUMSIG=SUMSIG+MOD(IQ(LMERA+NOFF),4096)
  250    CONTINUE
  260 CONTINUE
      SDET(1,13)=SDET(1,13)+FLOAT(NSIG)
      SDET(2,13)=SDET(2,13)+SUMSIG
      IF(IFHIST) CALL HFILL(-109,THETA,FLOAT(NSIG),1.)
*
* Examine Lead glass end-caps.
*
  270 LEX=LQ(LREV-1)
      LEERA=LQ(LDATR-8)
  280 IF (LEERA.EQ.0) GO TO 310
      J=IQ(LEERA+2)
      NBLOCK=IQ(LEERA+12)
      MBLOCK=0
      GEV=0
      LEERE=LQ(LEERA-3)
      DO 290 I=1,NBLOCK
         GEV=GEV+FLOAT(IQ(LEERE+I))/1000.
         IF(IQ(LEERE+I).GT.50) MBLOCK=MBLOCK+1
  290 CONTINUE
      IF(IFHIST) CALL HFILL(-111-J,THETA,GEV,1.)
      SDET(1,8)=SDET(1,8)+FLOAT(NBLOCK)
      SDET(2,8)=SDET(2,8)+FLOAT(MBLOCK)
      SDET(3,8)=SDET(3,8)+GEV
      LEERA=LQ(LEERA)
  300 GO TO 280
*
* Examine Lead glass barrel.
*
  310 LEBRA=LQ(LDATR-6)
      IF (LEBRA.EQ.0) GO TO 330
      LEBCT=LQ(LDAC-LLEBCT)
      LEBCC=LQ(LEBCT-LLEBCC)
      NCCHD=IQ(LEBCC+1)
      GEV=0
      NRAHD=IQ(LEBRA+1)
      NBLOCK=IQ(LEBRA+NRAHD+1)/2
      MBLOCK=0
      DO 320 I=1,NBLOCK
         IADDR=IQ(LEBRA+NRAHD+2*I)
         IADCDA=IQ(LEBRA+NRAHD+1+2*I)
         IADCLO=MOD(IADCDA,65536)
         ENERGY = FLOAT(IADCLO)*Q(LEBCC+NCCHD+IADDR)*0.001
         GEV=GEV+ENERGY
         IF(ENERGY .GT. 0.050) MBLOCK=MBLOCK+1
  320 CONTINUE
      SDET(1,6)=SDET(1,6)+FLOAT(NBLOCK)
      SDET(2,6)=SDET(2,6)+FLOAT(MBLOCK)
      SDET(3,6)=SDET(3,6)+GEV
      IF(IFHIST) CALL HFILL(-116,THETA,GEV,1.)
*
* Examine Hadron calorimeter barrel and endcaps in one.
*
  330 CONTINUE
      LHTRA=LQ(LDATR-LLHTRA)
      IF(LHTRA.LE.0) GO TO 350
      LHTRD=LQ(LHTRA-LLHTRD)
      IF(LHTRD.LE.0) GO TO 350
      LHTEA=LQ(LHTRD-LLHTEA)
      IF(LHTEA.LE.0) GO TO 350
      LHTET=LQ(LHTRD-LLHTET)
      IF(LHTET.LE.0) GO TO 350
      TBIADC=0.
      TEIADC=0.
      ND=IQ(LHTRD+IHTNRA)
      IF(ND.LE.0) GO TO 350
      DO 340 I=1,ND
        IADRS=IQ(LHTEA+I)
        IADC =IQ(LHTET+I)
        IDEV =IADRS/2**27
        CIACOA=FLOAT(IADC/2**16)
        IF(IDEV.EQ.1) THEN
          SDET(1,9)=SDET(1,9)+1.
          SDET(3,9)=SDET(3,9)+CIACOA
          TBIADC=TBIADC+CIACOA
        ELSEIF(IDEV.EQ. 2) THEN
          SDET(1,10)=SDET(1,10)+1.
          SDET(3,10)=SDET(3,10)+CIACOA
          TEIADC=TEIADC+CIACOA
        ENDIF
  340 CONTINUE
      IF(IFHIST) THEN
        CALL HFILL(-117,THETA,TBIADC,1.)
        CALL HFILL(-118,THETA,TEIADC,1.)
      END IF
  350 CONTINUE
      LHSRA=LQ(LDATR-LLHSRA)
      IF(LHSRA.LE.0) GO TO 360
      LHSRB=LQ(LHSRA-LLHSRB)
      IF(LHSRB.LE.0) GO TO 360
      DO 352 I=1,32
        LHSRD=LQ(LHSRB-I)
        IF(LHSRD.LE.0) GO TO 352
        LHSEA=LQ(LHSRD-LLHSEA)
        IF(LHSEA.LE.0) GO TO 352
        ND=IQ(LHSRD+IHSNRA)
        IF(ND.LE.0) GO TO 352
        DO 354 J=1,ND
          IADRS=IQ(LHSEA+J)
          IDEV =IADRS/2**29
          IF(IDEV.EQ.1) SDET(2,9) =SDET(2,9) +1.
          IF(IDEV.EQ.2) SDET(2,10)=SDET(2,10)+1.
  354   CONTINUE
  352 CONTINUE
  360 CONTINUE
*     Now HP
      LHPRA=LQ(LDATR-11)
      TPULSE=0
      IF (LHPRA.EQ.0) GO TO 390
      DO 380 I=1,4
         LHPT=LQ(LHPRA-I)
         IF (LHPT.EQ.0) GO TO 380
         ND=IQ(LHPT-1)
         DO 370 J=1,ND
            IWORD=IQ(LHPT+J)
            JTOWER=JBYT(IWORD,17,16)
            IPULSE=JBYT(IWORD,1,16)
            IF(MOD(I,2).EQ.1) THEN
               TPULSE=TPULSE+FLOAT(IPULSE)
               SDET(1,11)=SDET(1,11)+1.
               SDET(3,11)=SDET(3,11)+FLOAT(IPULSE)
            ELSE
               SDET(2,11)=SDET(2,11)+1.
            ENDIF
  370    CONTINUE
  380 CONTINUE
  390 IF(IFHIST) CALL HFILL(-119,THETA,TPULSE,1.)
*
*
*     Next PE
*
  400 LPERA=LQ(LDATR-7)
      SUMSIG=0.
      IF(LPERA.EQ.0) GO TO 420
         LINK=LQ(LPERA-1)
         IF(LINK.EQ.0) GO TO 420
         ND=IQ(LINK-1)
         DO 410 K=1,ND
            PH=JBYT(IQ(LINK+K),1,16)
            IAD=JBYT(IQ(LINK+K),17,16)
            IF(PH.GT.0.) THEN
                         CALL CBYT(IAD,1,IPSW,1,8)
                         IF(IPSW.GE.1.AND.IPSW.LE.10)    J = 4
                         IF(IPSW.GE.11.AND.IPSW.LE.32)   J = 5
                         IF(IPSW.GE.33.AND.IPSW.LE.142)  J = 3
                         IF(IPSW.GE.145.AND.IPSW.LE.160) J = 1
                         IF(IPSW.GE.161.AND.IPSW.LE.192) J = 2
                         SDET(J,7)=SDET(J,7)+1.0
                         SDET(J+5,7)=SDET(J+5,7)+PH
                         IF(J.EQ.1) SUMSIG=SUMSIG+PH
            ENDIF
  410    CONTINUE
  420 CONTINUE
      IF(IFHIST) CALL HFILL(-114,THETA,SUMSIG,1.)
*     Finally the Forward detector
*
      LFDRA=LQ(LDATR-14)
      IF(LFDRA.EQ.0) GO TO 470
      DO 460 IEND=1,2
      LFDHI = LQ(LFDRA-IEND)
      IF (LFDHI .EQ. 0) GOTO 460
      LFDRI = LQ(LFDHI-1)
      IF (LFDRI .EQ. 0) GOTO 460
*
*    Loop over detectors : 1=Gamma catcher, 2=Lumi, 3=tracking, 4=tubes,
*                          5=calorimeter
         DO 450 J=1,5
            LINK = LQ(LFDRI-J)
            ND   = IQ(LFDRI+J)
            IF(LINK.EQ. 0.OR. ND.EQ.0) GO TO 450
            SUM=0.
            DO 440 K=1,ND
               IF (J .NE. 5) THEN
                  ADC = MOD(IQ(LINK+K),10000)
               ELSE
*..               Calorimeter data: 2 ADC words per ZEBRA word.
                  IAD = MOD(IQ(LINK+K),2**16)
                  IAD = IAD + IQ(LINK+K)/2**16
*drw 12/10/90     ADC = FLOAT(IAD)-FDPED0(1,5)
               END IF
                  IF(K.LE.16) THEN
                     ADC = FLOAT(IAD)-FDPED0(2,5)
                  ELSEIF(K.LE.32) THEN
                     ADC = FLOAT(IAD)-FDPED0(1,5)
                  ELSE
                     ADC = FLOAT(IAD)-FDPED0(1,4)
                  ENDIF
               SUM=SUM+ADC
  440       CONTINUE
            SDET(J,14)=SDET(J,14)+SUM
  450    CONTINUE
  460 CONTINUE
  470 CONTINUE
  480 CONTINUE
*
* Really finally - Si microvertex
*
      LSIRA=LQ(LDATR-LLSIRA)
      IF (LSIRA.EQ.0) GO TO 550
         LSIRD=LQ(LSIRA-LLSIRD)
 540     IF(LSIRD.LE.0) GO TO 530
         IF(JBYT(IQ(LSIRA+3),9,8).EQ.0) THEN
            SDET(2,15)=SDET(2,15)+FLOAT(IQ(LSIRD+3)/2)
         ELSE
            SDET(2,15)=SDET(2,15)+FLOAT(JBYT(IQ(LSIRD+3),1,16))
         ENDIF
         LSIRD=LQ(LSIRD)
         GO TO 540
 530     SDET(1,15)=SDET(1,15)+FLOAT(JBYT(IQ(LSIRA+3),17,8))
 550     CONTINUE
      END
+DECK,GOHFL2.
      SUBROUTINE GOHFL2
*.
*...GOHFL2   Fill standard DST histograms
*.
*. COMMON    : GOSTAT
*. SEQUENCE  : GCBANK GCKINE GCLIST GCTRAK LINKRA
*. CALLS     : HFILL
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 10-May-87
*. LAST MOD  : 08-Dec-93
*.
*. Modification Log.
*. 08-Dec-93   C.P.Ward      Remove unused variables
*. 26-Sep-88   D.R.Ward      Modify for OD301
*.  1-Sep-88   D.R.Ward      Fix bug in Hcal energy
*. 10-May-88   D.R.Ward      Add DST histograms
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,GCBANK.
+SEQ,LINKRA.
+SEQ,GCLIST.
+SEQ,RCREP.
+SEQ,ROPAR.
+SEQ,ODPAR.
*
      REAL    RG(NRGNRL),RC(NRCTRK),RE(NRECAL),RH(NRHCAL)
      INTEGER IG(NIGNRL),IC(NICTRK),IE(NIECAL),IH(NIHCAL),
     +NIM,NRM,NCTRK,NECAL,NHCAL,NMUON,I,JUCOMP
      REAL SUM,PMOM
      EXTERNAL JUCOMP
*
*--   Now look at DST banks if requested
*
      IF(JUCOMP('DST ',LHSTA,NHSTA).EQ.0) GO TO 50
      IF(LQ(LREV-LLOD).EQ.0) GO TO 50
*
*     Get General block
*
      CALL ODFBLK('GNRL',0,NIGNRL,IG,NIM,NRGNRL,RG,NRM)
      IF(NIM.EQ. 0.OR. NRM.EQ.0) THEN
         CHREP = ' GNRL block not found'
         CALL REPORT('GOHFL2',1,'E')
         GO TO 50
      ENDIF
      NCTRK=IG(JGNCTR)
      NHCAL=IG(JGNHCA)
      NECAL=IG(JGNECA)
      NMUON=IG(JGNMUO)
      CALL HFILL(9001,FLOAT(NCTRK),0.,1.)
      CALL HFILL(9002,FLOAT(NECAL),0.,1.)
      CALL HFILL(9003,FLOAT(NHCAL),0.,1.)
      CALL HFILL(9004,FLOAT(NMUON),0.,1.)
*
*     Get CD track blocks
*
      DO 10 I=1,NCTRK
         CALL ODFBLK('CTRK',I,NICTRK,IC,NIM,NRCTRK,RC,NRM)
         IF(NIM.EQ. 0.OR. NRM.EQ.0) THEN
            CHREP = ' CTRK block not found'
            CALL REPORT('GOHFL2',2,'E')
            GO TO 10
         ENDIF
         CALL HFILL(9014,RC(JCCHIR),0.,1.)
         IF(RC(JCCHIR).GE.999.) GO TO 10
         PMOM=SQRT(RC(JCPX)**2+RC(JCPY)**2+RC(JCPZ)**2)
         CALL HFILL(9011,RC(JCQ)*PMOM   ,0.,1.)
         CALL HFILL(9012,RC(JCQ)*PMOM   ,0.,1.)
         IF(PMOM.NE.0.) CALL HFILL(9013,RC(JCPZ)/PMOM,0.,1.)
   10 CONTINUE
*
*     Get EM cluster blocks
*
      SUM=0.
      DO 20 I=1,NECAL
         CALL ODFBLK('ECAL',I,NIECAL,IE,NIM,NRECAL,RE,NRM)
         IF(NIM.EQ. 0.OR. NRM.EQ.0) THEN
            CHREP = ' ECAL block not found'
            CALL REPORT('GOHFL2',3,'E')
            GO TO 20
         ENDIF
         CALL HFILL(9021,RE(JEE),0.,1.)
         CALL HFILL(9022,RE(JEE),0.,1.)
         SUM=SUM+RE(JEE)
   20 CONTINUE
      CALL HFILL(9023,SUM,0.,1.)
*
*     Get HC cluster blocks
*
      SUM=0.
      DO 30 I=1,NHCAL
         CALL ODFBLK('HCAL',I,NIHCAL,IH,NIM,NRHCAL,RH,NRM)
         IF(NIM.EQ. 0.OR. NRM.EQ.0) THEN
            CHREP = ' HCAL block not found'
            CALL REPORT('GOHFL2',4,'E')
            GO TO 30
         ENDIF
         SUM=SUM+RH(JHE)
   30 CONTINUE
      CALL HFILL(9031,SUM,0.,1.)
      GO TO 50
   50 CONTINUE
      END
+DECK,GOIFFR
      SUBROUTINE GOIFFR
*.
*...GOIFFR   Define GOPAL FFREAD data cards, read them, and take appropr
*.           action.
*.
*. COMMON    :
*. SEQUENCE  : GOFLAG GOCART GOUNIT GCLIST GCUNIT GCPHYS GCBANK 
*. SEQUENCE  : GCCUTS GOLIFC GOXMIX
*. CALLS     : GMAIL  FFKEY  VFILL  VZERO  UCTOH  GFFGO  GETNUM IUCOMP
*. CALLS     : JUCOMP UCOPY  CJRING CVIFFR USIFFR GOBEAM
*. CALLED    : UGINIT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 133.0
*. CREATED   : 19-Jan-88
*. LAST MOD  : 01-Feb-99
*.
*. Modification Log.
*. 01-Feb-99   C.P.Ward      Add call to FFIFFR
*. 29-Jan-99   C.P.Ward      Set OPAL volume dz = 900.
*. 26-Feb-97   S.W.O.Neale   Add MCPS and MCPT data cards
*. 28-Sep-94   C.P.Ward      Add TE.
*. 23-May-94   C.P.Ward      Remove BOOT card.
*.                           Move validation of geometrical cards to
*.                           GOGFFR.
*. 19-May-94   C.P.Ward      Move setting of default vertex to GOBEAM.
*. 23-Mar-94   J.E.Conboy    Use new version of CHECK which processes detector
*.                           lists. Define lists for CD and CAL cards. 
*.                           Add FD and SW to CAL list
*.                           Remove FD BOOT mode, which is unsupported
*. 08-Dec-93   C.P.Ward      Remove unused variables.
*. 22-Nov-93   C.P.Ward      Include 1993 beam spot info from Sijbrand
*.                           (P51 onwards values).
*. 21-Oct-93   R.W.J.Jones   Add GOXMIX sequence and XMIX FFREAD card.
*. 09-Aug-93   C.P.Ward      Default expt=2 if SI on GEOM card.
*. 11-May-93   D.R.Ward      Update default beam sizes (info from Sijbrand)
*. 10-May-93   D.R.Ward      Mods in case CD/CAL not specified
*. 17-Sep-92   R.Kowalewski  Update default beam spreads
*. 24-Aug-92   D.R.Ward      Update vertex positions
*. 25-Feb-92   D.R.Ward      IHADR=1 by default
*.  5-Dec-91   D.R.Ward      Fix minor problems in SMEAr mode.
*.  2-Jul-91   S.L.Lloyd     Add 'NOEP' 'DOEP' to SMEAR card.
*.  4-Jul-91   D.R.Ward      IHADR=3 by default
*. 26-Apr-91   R.Kowalewski  Add 'NOZC' 'DOZC' to SMEAR card.
*. 22-Mar-91   B.Lorazo      Call CZIFFR
*. 22-Feb-91   S.Weisz       Mods for ROPE400
*.  8-Jan-91   D.R.Ward      Change FLDFAC to correspond to "real" OPAL field
*.  5-Oct-90   D.R.Ward      Implement *SKIP, *SELECT
*. 24-Sep-90   R.J.Hemingway Update beam spot
*. 03-Aug-90   S.L.Lloyd     Add LIFE card.
*. 02-Aug-90   S.L.Lloyd     Add 'NOCX' 'DOCX' 'IDEA' to SMEAR card.
*. 17-Jul-90   V.Gibson      Add Si
*. 10-Jul-90   D.R.Ward      Set IDETFG
*.  6-Jul-90   D.R.Ward      Check of FLDFAC etc. here.
*. 18-Jun-90   R.J.Hemingway Fix problem with trailing blanks.
*.  1-May-90   D.R.Ward      Small change to LALLSM logic
*. 19-Feb-90   D.R.Ward      Call MEIFFR
*. 16-Jan-90   D.R.Ward      Enable SI data card (as CD and CAL)
*. 12-Jan-90   D.R.Ward      New data cards ZLOG and ZVER
*.  4-Dec-89   D.R.Ward      Set IFBOOK
*. 30-Nov-89   D.R.Ward      Suitable defaults for VERT card?
*. 17-Jul-89   D.R.Ward      EXPT data card to set experiment number
*. 29-Jun-89   D.R.Ward      Disable LUND (PCG instructions)
*. 31-May-89   D.R.Ward      Pick up BOOT units from *FILE cards if exist.
*. 30-May-89   D.R.Ward      Add *FILE
*.  9-Mar-89   D.R.Ward      New data card CJPK
*. 28-Feb-89   D.R.Ward      Slight changes to SETS logic
*. 28-Feb-89   D.R.Ward      Slight changes to GEOM logic
*. 15-Feb-89   D.R.Ward      Mods for SMEAr mode
*. 14-Feb-89   R.W.L.Jones   Call CVIFFR to define CV GOPAL cards
*.  3-Jan-89   H.Kreutzmann  Call  CJRING
*. 25-Oct-88   D.R.Ward      Modify some printing
*. 26-Sep-88   D.R.Ward      Enable brems in SMEA/FAST modes
*. 19-Jul-88   D.R.Ward      Replace GLUNDI by GOLUNI
*. 30-May-88   R.J.Barlow    Evaluate logical switches in GOLOGI
*.  3-May-88   D.R.Ward      Fix printing of options
*. 25-Apr-88   D.R.Ward      Strong typing
*. 15-Apr-88   D.R.Ward      Default GEOM not ALL if CD or CAL cards pre
*. 14-Apr-88   D.R.Ward      Use CHREP for REPORT
*.  8-Mar-88   D.R.Ward      add sequence GCONST
*. 26-Feb-88   D.R.Ward      add sequence GOFLD
*.  9-Feb-88   D.R.Ward      Call USIFFR
*.  9-Feb-88   S.O'Neale     Call GLUNDI
*.  3-Feb-88   D.R.Ward      Set DCUT, BCUT
*. 29-Jan-88   M.Hansroul    Mods to VERT card
*. 29-Jan-88   D.R.Ward      Reset mechanisms in fully FAST mode
*. 29-Jan-88   D.R.Ward      FD defaults to same as CAL
*. 22-Jan-88   D.R.Ward      Introduce new data cards, CD CAL PSAM FD NO
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCLIST.
+SEQ,GOCART.
+SEQ,GOUNIT.
+SEQ,GOFILE.
+SEQ,GOFLAG.
+SEQ,GOFLD.
+SEQ,GOLIFC.
+SEQ,GOXMIX.
+SEQ,GCUNIT.
+SEQ,GCPHYS.
+SEQ,GCCUTS.
+SEQ,ROBANK.
+SEQ,GCKINE.
+SEQ,GOKIDI.
+SEQ,GCFLAG.
+SEQ,GOLOGI.
+SEQ,MEPAT.
+SEQ,RCNTRL.
+SEQ,ROCPAR.
+SEQ,FDBUF.
+SEQ,MCPSPY,IF=MCP.
      INTEGER NGEOMO,NSETSO,NDIGIO,MBLANK,JGEOM,JFAST,I,L,III,JMED,
     +IUCOMP,JUCOMP,KTEST,JBMED,NBMED,J
      INTEGER LGNCT,LMAGF
      REAL    XYZ(3),BXYZ(3)
      EXTERNAL IUCOMP,JUCOMP
      PARAMETER (NGEOMO=20,NSETSO=17,NDIGIO=17)
      INTEGER   LGEOMO(NGEOMO),LSETSO(NSETSO),LDIGIO(NDIGIO)
      CHARACTER*4 TEST
      INTEGER NUKMAX,LIOKEY
      PARAMETER (NUKMAX=6)
      DIMENSION LIOKEY(NUKMAX)
      EQUIVALENCE (LIOKEY,LFITYP)
*
      DATA XYZ/0.,0.,0./
*
      CALL UCTOH  ('ALL CD  CV  CJ  CZ  CP  EB  EE  HE  HB  MB  ME  '//
     +'BD  BP  HP  FD  PE  SI  SW  TE  ',LGEOMO,4,4*NGEOMO)
      CALL UCTOH  ('CV  CJ  CZ  TB  PB  EB  HB  MB  FD  PE  EE  HE  '//
     +'HP  ME  SI  SW  TE  ',LSETSO,4,4*NSETSO)
      CALL UCTOH  ('CV  CJ  CZ  TB  PB  EB  HB  MB  FD  PE  EE  HE  '//
     +'HP  ME  SI  SW  TE  ',LDIGIO,4,4*NDIGIO)
*
*--   Set default or initial values.
*
      IFBOOK=1
*
*     GOPAL flags...
      IKINE =1
      IUTRAK=1
      IUHITS=1
      NDIGI =0
      NUFLAG=0
      NODET=0
      NSMEAR=0
      CALL VZERO(IUFLAG,20)
      JZLOGL=0
      IVAXPN=1
*
*     Logical units for I/O
      LGGET=1
      LGSAVE=2
      LGCAP=3
      LGRAW=21
*
*     Blank out hollerith buffers
      CALL UCTOH('    ',MBLANK,4,4)
      CALL VFILL(LGEOM,20,MBLANK)
      CALL VFILL(LFAST,20,MBLANK)
      CALL VFILL(LDIGI,20,MBLANK)
      CALL VFILL(LCHEAT,20,MBLANK)
      CALL VFILL(LLOC,20,MBLANK)
      CALL VFILL(LCDET,10,MBLANK)
      CALL VFILL(LCAL,10,MBLANK)
      CALL VFILL(LSILI,10,MBLANK)
      CALL VFILL(LPSAM,10,MBLANK)
      CALL VFILL(LFDET,10,MBLANK)
      CALL VFILL(LSMEAR,10,MBLANK)
      CALL VFILL(LGUN,20,MBLANK)
      CALL VFILL(JZVERI,10,MBLANK)
*
*     VERT and OPAL cards
      CAVXYZ(1)=99999.
*
      CAOPAL(1)=700.
      CAOPAL(2)=700.
      CAOPAL(3)=900.
*
*     Full field map
      FLDFAC=-1.0055
      FLDSGN=+1.
*
*     Pack CJ data by default
      ICJPAK=1
*
*     Default experiment number
      IGOEXP=1001
*
      NFILE=0
      CALL VZERO(LIOKEY,NUKMAX)
      DO 2020 I=1,20
         CALL UCTOH('    ',LFINAM(I),4,4)
 2020 CONTINUE
*
*     Lifetimes and mixing parameters
      CALL VFILL (TXLIFE,MXLIFE,-1.0)
*     x_d
      XMIX(1)=0.7
*     x_s
      XMIX(2)=999.
*
      CALL VZERO(FDCAL,3)
      BOTSHW = .FALSE.
*
*--   Read data cards via the FFREAD package.
*     Define keys for private GOPAL data cards.
*
      CALL FFKEY('TRAK',IUTRAK,1,'INTEGER')
      CALL FFKEY('HITS',IUHITS,1,'INTEGER')
      CALL FFKEY('DIGI',LDIGI ,20,'HOLL')
      CALL FFKEY('CHEA',LCHEAT,20,'HOLL')
      CALL FFKEY('OC  ',LLOC  ,20,'HOLL')
      CALL FFKEY('FAST',LFAST ,20,'HOLL')
      CALL FFKEY('FLAG',IUFLAG,24,'INTEGER')
      CALL FFKEY('OPAL',CAOPAL,3,'REAL')
      CALL FFKEY('FIEL',FLDFAC,2,'REAL')
      CALL FFKEY('VERT',CAVXYZ,6,'REAL')
      CALL FFKEY('UNIT',LGUN,20,'MIXED')
      CALL FFKEY('CD  ',LCDET,10,'HOLL')
      CALL FFKEY('CAL ',LCAL ,10,'HOLL')
      CALL FFKEY('SI  ',LSILI,10,'HOLL')
      CALL FFKEY('PSAM',LPSAM,10,'HOLL')
      CALL FFKEY('FD  ',LFDET,10,'HOLL')
      CALL FFKEY('NODE',NODET,1,'INTEGER')
      CALL FFKEY('SMEA',LSMEAR,10,'HOLL')
      CALL FFKEY('CJPK',ICJPAK,1,'INTEGER')
      CALL FFKEY('EXPT',IGOEXP,1,'INTEGER')
      CALL FFKEY('FILE',LIOKEY,NUKMAX+20,'MIXED')
      CALL FFKEY('FCAL',FDCAL,3,'MIXED')
      CALL FFKEY('ZLOG',JZLOGL,1,'INTEGER')
      CALL FFKEY('ZVER',JZVERI,10,'MIXED')
      CALL FFKEY('PNAM',IVAXPN,1,'INTEGER')
      CALL FFKEY('SKIP',IESKIP,1,'INTEGER')
      CALL FFKEY('SELECT',IESKIP,1,'INTEGER')
      CALL FFKEY('LIFE',TXLIFE,MXLIFE,'REAL')
      CALL FFKEY('XMIX',XMIX,MXXMIX,'REAL')
+SELF,IF=MCP.
      CALL FFKEY('MCPS',SPYLVL,1,'INTEGER')
      SPYLVL=1               ! Default to simple monitor in GORO cradle
      CALL FFKEY('MCPT',MCPTRAP,1,'INTEGER')
      MCPTRAP=0              ! Defaults to no trapping on EXTERNAL
+SELF.
*
*     call GOLUNI to enable data cards to modify LUND parameters
*
*     CALL GOLUNI
*
*--   Define some detector data cards.
*
      CALL SIIFFR
      CALL CVIFFR
      CALL CJRING
      CALL CZIFFR
      CALL EEIFFR
      CALL FDIFFR
      CALL FFIFFR
      CALL MEIFFR
      CALL SWIFFR
      CALL TRIFFR
*
*--   Data cards for SMear mode
*
      CALL SMIFFR
*
*--   allow user to define private data cards
*
      CALL USIFFR
*
*--   Set up sensible defaults for physics mechanisms in GEANT.
      IPAIR=1
      ICOMP=1
      IPHOT=1
      IPFIS=0
      IDRAY=1
      IANNI=1
      IBREM=1
      IHADR=1
      IMUNU=0
      IDCAY=1
      ILOSS=1
      IMULS=2
*
      IDRUN=-337242
*
*--   Now read the data cards.
*
      CALL GFFGO
*
      NORUNG=.FALSE.
      IF(IDRUN.EQ.-337242) THEN
         IDRUN=1
         NORUNG=.TRUE.
      ENDIF
*
      CALL MZLOGL(IXSTOR,JZLOGL)
      IF(JUCOMP('ALL ',JZVERI,10).NE.0)
     +  CALL UCTOH('INITOUT DIGIROPE',JZVERI,4,16)
*
*--   Figure out how many data items on each card
*
      CALL GETNUM(LDIGI,NDIGI)
      CALL GETNUM(LCHEAT,NCHEAT)
      CALL GETNUM(LGEOM,NGEOM)
      CALL GETNUM(LFAST,NFAST)
      CALL GETNUM(LLOC,NNOC)
      CALL GETNUM(IUFLAG,NUFLAG)
      CALL GETNUM(LGUN,NGUN)
      CALL GETNUM(LCDET,NCDET)
      CALL GETNUM(LCAL,NCAL)
      CALL GETNUM(LSILI,NSILI)
      CALL GETNUM(LPSAM,NPSAM)
      CALL GETNUM(LFDET,NFDET)
      CALL GETNUM(LSMEAR,NSMEAR)
*
*--   Validate the geometrical data cards
*
      CALL GOGFFR
*
*--   If no detector is running in full mode turn off less 
*--   important physics mechanisms
*
      IF(.NOT.LCDFU .AND. .NOT.LCALFU .AND. .NOT.LFDFU .AND.
     +   .NOT.LSIFU .AND. .NOT.LPSFU ) THEN
         ICOMP=2
         IPHOT=2
         IDRAY=2
         IANNI=2
         IBREM=1
         DCUTE=999.
         DCUTM=999.
         BCUTE=0.05
         BCUTM=999.
         CHMAIL=' *** All detectors in FAST or SMEAr mode, so   ***'
         CALL GMAIL(1,0)
         CHMAIL=' *** COMP, PHOT, DRAY, ANNI and BREM disabled. ***'
         CALL GMAIL(0,0)
      ENDIF
*
*--   Initialisation for NODEtector and SMEAr modes
      IF(NODET.EQ.1) CALL ODNODI
      IF(LCDSM .OR. LCALSM) CALL SMINIT
*
*--   Use of the FIEL data card - it has one real argument FLDFAC
*--   If no FIEL card is present the default is the full field map.
*--   If FLDFAC=0 there is zero field.
*--   If FLDFAC>0 the constant field is multiplied by FLDFAC
*--   If FLDFAC<0 the field map coded in GUFLD is invoked.
*--
      JFLD=0
      F0=0.
      IF(FLDFAC.EQ.0.0) THEN
        IFLD=0
        CHMAIL=' >>> Zero magnetic field selected <<<'
        CALL GMAIL(1,1)
      ELSEIF(FLDFAC.GT.0.) THEN
        IFLD=3
        FLDFAC=FLDFAC*4.326/4.00
        CHMAIL=' >>> Constant magnetic field selected <<<'
        CALL GMAIL(1,1)
      ELSEIF(LCDSM.AND..NOT.LCALFU) THEN
        IFLD=3
        FLDFAC=ABS(FLDFAC)*4.326/4.00
        CHMAIL=' >>> All in SMEAr mode, therefore     <<<'
        CALL GMAIL(1,0)
        CHMAIL=' >>> Constant magnetic field selected <<<'
        CALL GMAIL(0,1)
      ELSE
        IFLD=2
        JFLD=2
        F0=4.*ABS(FLDFAC)
        CHMAIL=' >>> Full magnetic field map selected <<<'
        CALL GMAIL(1,1)
      ENDIF
      FLDFAC=SIGN(ABS(FLDFAC),FLDSGN)
      F0=SIGN(F0,FLDSGN)
      IF(IFLD.EQ.2 .OR. IFLD.EQ.1) THEN
         CALL GUFLD(XYZ,BXYZ)
         BZ000=BXYZ(3)
      ELSE
         BZ000=4.*FLDFAC
      ENDIF
      WRITE(CHMAIL,'('' Central magnetic field ='',F8.4,'' kG'')')
     +      BZ000
      CALL GMAIL(0,1)
*
*     Store field in MAGF bank
*
      IF(LDAC.GT.0) THEN
         LGNCT=LQ(LDAC-LLGNCT)
         IF(LGNCT.GT.0) THEN
            LMAGF=LQ(LGNCT-LLMAGF)
            IF(LMAGF.GT.0) Q(LMAGF+IMEANB)=BZ000
         ENDIF
      ENDIF
*
*--   Interpret results from MEPATCH card.
*
      IF (IPAT.GT.0) THEN
         PATCH=.TRUE.
      ELSE
         PATCH=.FALSE.
      ENDIF
*
*--   Set default beam spot position and size.
*
      CALL GOBEAM
*
      END
+DECK,GOIGR,IF=GKS,HIGZ.
      SUBROUTINE GOIGR
*.
*...GOIGR    Initialize graphics views for GOPAL
*.
*. COMMON    :
*. SEQUENCE  : GCLIST
*. CALLS     : GMAIL  UCTOH  IUCOMP GUVIEW DZVERI
*. CALLED    : UGINIT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 19-Jan-88
*. LAST MOD  : 25-Apr-88
*.
*. Modification Log.
*. 25-Apr-88   D.R.Ward      Strong typing
*. 24-Mar-88   O.Biebel      Fix bug - add GCUNIT.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCUNIT.
+SEQ,GCLIST.
      CHARACTER*4 ICFAST,ICFULL,ICMPLX
      INTEGER   ICTEST(8),IUCOMP
      EXTERNAL IUCOMP
      DATA ICFAST/'FAST'/,ICFULL/'FULL'/
      ICMPLX=ICFAST
      CALL UCTOH ('OPALCDETVERTFULLFRONSIDETOP MIXE',ICTEST,4,32)
      IF (IUCOMP (ICTEST(4) ,LVIEW ,20) .NE. 0) ICMPLX=ICFULL
*     ----------------
*     -- OPAL views --
*     ----------------
      IF (IUCOMP (ICTEST(1) ,LVIEW ,20) .NE.  0.OR. (IUCOMP(ICTEST(2),
     +LVIEW,20).EQ. 0.AND. IUCOMP(ICTEST(3),LVIEW,20).EQ.0) ) THEN
         IF (IUCOMP (ICTEST(5) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('OPAL' ,
     +   'FRON' ,ICMPLX ,1)
         IF (IUCOMP (ICTEST(6) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('OPAL' ,
     +   'SIDE' ,ICMPLX ,2)
         IF (IUCOMP (ICTEST(7) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('OPAL' ,
     +   'TOP ' ,ICMPLX ,3)
         IF (IUCOMP (ICTEST(8) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('OPAL' ,
     +   'MIXE' ,ICMPLX ,4)
      ENDIF
*     ----------------
*     -- CDET views --
*     ----------------
      IF (IUCOMP(ICTEST(2),LVIEW,20).NE.0) THEN
         IF (IUCOMP (ICTEST(5) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('CDET' ,
     +   'FRON' ,ICMPLX ,5)
         IF (IUCOMP (ICTEST(6) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('CDET' ,
     +   'SIDE' ,ICMPLX ,6)
         IF (IUCOMP (ICTEST(7) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('CDET' ,
     +   'TOP ' ,ICMPLX ,7)
         IF (IUCOMP (ICTEST(8) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('CDET' ,
     +   'MIXE' ,ICMPLX ,8)
      ENDIF
*     ----------------
*     -- VERT views --
*     ----------------
      IF (IUCOMP(ICTEST(3),LVIEW,20).NE.0) THEN
         IF (IUCOMP (ICTEST(5) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('VERT' ,
     +   'FRON' ,ICMPLX ,9)
         IF (IUCOMP (ICTEST(6) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('VERT' ,
     +   'SIDE' ,ICMPLX ,10)
         IF (IUCOMP (ICTEST(7) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('VERT' ,
     +   'TOP ' ,ICMPLX ,11)
         IF (IUCOMP (ICTEST(8) ,LVIEW ,20) .NE. 0) CALL GUVIEW ('VERT' ,
     +   'MIXE' ,ICMPLX ,12)
      ENDIF
+SELF,IF=DBUGMEMO.
      CALL DZVERI(' GOPAL: Verification of view banks',IXSTOR,'CFLSU')
+SELF.
      END
+DECK,GOIIO.
      SUBROUTINE GOIIO
*.
*...GOIIO    Initialize I/O units for GOPAL
*.
*. COMMON    :
*. SEQUENCE  : GCLIST GOUNIT GCUNIT GOFLAG
*. CALLS     : UCTOH  IUCOMP GOPEN  GMAIL
*. CALLED    : UGINIT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 2.00
*. CREATED   : 19-Jan-88
*. LAST MOD  :  9-Feb-98
*.
*. Modification Log.
*.  9-Feb-98   M.Schroder    Remove READONLY from SGI part of OC file
*. 30_nov-94   M.Redmond     Add 'CD0O' to list of recognized o/p streams
*. 20-Dec-93   C.P.Ward      Mods to handling of SAVE card
*. 17-Sep-93   C.P.Ward      Enable C i/o for Apollo
*.                           Default LREC = 8100 in exchange mode
*. 30-May-92   D.R.Ward      Implement 'L' option
*. 23-May-92   D.Lellouch    OPEN statement different on IBMT RISC
*.  3-Jan-92   D.R.Ward        Implement internal file definition
*. 25-Feb-91   D.R.Ward      Implement DDST output
*. 23-Oct-90   S.L.Lloyd     Fix 'HIST' on IBM
*. 27-Jul-90   D.R.Ward      Standardize database opening on IBM
*.  3-Jul-90   D.R.Ward      Allow CONS o/p to DST stream
*. 20-Dec-89   D.R.Ward      Don't open output files yet
*.  1-Nov-89   D.R.Ward      Implement 'PROD'
*. 19-Jul-89   S.Weisz       Fix DRW bug
*. 17-Jul-89   D.R.Ward      OPEN CALI file
*.  4-Jul-89   B.Lorazo      Apollo OPEN statement for RAWD corrected.
*. 30-May-89   D.R.Ward      Major rewrite to make use of *FILE cards
*. 20-Apr-89   S.Weisz       Modify OPEN statements for Apollo
*.  4-Aug-88   J.Allison     New OPEN statements for Apollo.
*. 26-Jul-88   S.W.O'Neale   Blocksize=8100 for exchange mode
*. 21-Jul-88   J.Allison     New OPEN statements for Apollo.
*. 18-May-88   D.Schaile     OPEN statements for Apollo
*. 25-Apr-88   D.R.Ward      Strong typing
*. 25-Mar-88   D.R.Ward      Don't open GEANT SAVE file if only RAWD req
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER II,JJJ,IER,ISTAT
      INTEGER  JUCOMP
      EXTERNAL JUCOMP
      CHARACTER*4 CHOPT
      CHARACTER*4 CHNAME(6)
      CHARACTER*80 CHFNAM
      CHARACTER*10 CHCALI
+SEQ,GCLIST.
+SEQ,GOUNIT.
+SEQ,GCUNIT.
+SEQ,GOHTOP.
+SEQ,GCFLAG.
+SEQ,GOFLAG.
+SEQ,GOFILE.
+SEQ,RCREP.
      INTEGER IQUEST
      COMMON/QUEST/IQUEST(100)
      DATA CHNAME/'DATO','DSTO','CONO','PROO','DDSO','CD0O'/
*
*     The old UNIT card is obsolete.  Better warn users though!
*
         IF(NGUN.GT.0) THEN
            CHREP='UNIT card is obsolete - use *FILE instead'
            CALL REPORT('GOIIO',1,'W')
         ENDIF
*
*     First deal with GEANT (GET 'INIT' etc.) input.
*     GET card now merely specifies which data structures to GET
*
      IF(NGET .GT.0) THEN
         DO 10 II=1,NGET
            CALL UHTOC(LGET(II),4,CCGET(II),4)
            IF(LGET(II).GT. 0.AND. LGET(II).LE.99) THEN
               CHREP='Can''t change units on GET card - use *FILE'
               CALL REPORT('GOIIO',2,'W')
            ENDIF
   10    CONTINUE
         IF(JUCOMP('EXCH',LGET,NGET).NE.0) THEN
            CHREP='EXCH on GET card no longer supported - use *FILE'
            CALL REPORT('GOIIO',3,'W')
         ENDIF
      ENDIF
      JJJ=JUCOMP('INII',IONAME,NFILE)
      IF(JJJ.EQ.0) THEN
         IF(NGET.NE.0) THEN
            CHREP='GET card, but no *FILE ''INIT'' ''IN  '' card'
            CALL REPORT('GOIIO',4,'W')
         ENDIF
      ELSE
         IF(NGET.EQ.0) THEN
            CALL UCTOH('INIT',LGET(1),4,4)
            CCGET(1)='INIT'
            NGET=1
            CHREP='*FILE ''INIT'' ''IN  '' card, but no GET card'
            CALL REPORT('GOIIO',5,'I')
            CHREP='GET ''INIT'' assumed'
            CALL REPORT('GOIIO',6,'I')
         ENDIF
         LGGET=IOUNIT(JJJ)
         CALL UHTOC(IOFCHO(JJJ),4,CHOPT,4)
+SELF,IF=IBM.
         IF(INDEX(CHOPT,'X').NE.0) CALL RADDOP(CHOPT,'Y')
+SELF.
+SELF,IF=VAX,DECS,QMVAOS.
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(LGGET,STATUS='OLD',FORM='UNFORMATTED',READONLY,SHARED)
         ELSE
            OPEN(LGGET,STATUS='OLD',FORM='UNFORMATTED',READONLY,SHARED,
     +           FILE=IOFNAM(JJJ))
         ENDIF
+SELF,IF=SGI.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=9760
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(LGGET,RECL=  IOLREC(JJJ),FORM='UNFORMATTED')
         ELSE
            OPEN(LGGET,RECL=  IOLREC(JJJ),FORM='UNFORMATTED',
     +           FILE=IOFNAM(JJJ))
         ENDIF
+SELF,IF=APOLLO,SUN,HPUX.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=9760
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(LGGET,RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
         ELSE
            OPEN(LGGET,RECL=4*IOLREC(JJJ),FORM='UNFORMATTED',
     +           FILE=IOFNAM(JJJ))
         ENDIF
+SELF,IF=IBMRT.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=9760
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(LGGET,FORM='UNFORMATTED')
         ELSE
            OPEN(LGGET,FORM='UNFORMATTED',
     +           FILE=IOFNAM(JJJ))
         ENDIF
+SELF.
         CALL GOPEN(LGGET,CHOPT,IOLREC(JJJ),IER)
      ENDIF
*
*     Next deal with GEANT (SAVE 'INIT' etc.) output.
*     SAVE card now merely specifies which data structures to SAVE
*     Make sure INIT is last, so can be removed from list once written
*
      IF(NSAVE .GT. 0) THEN
         JJJ = 1
         DO 20 II=1,NSAVE
            CALL UHTOC(LSAVE(II),4,CCSAVE(JJJ),4)
            IF(CCSAVE(JJJ).EQ.'INIT') GO TO 20
            IF(LSAVE(II).GT. 0.AND. LSAVE(II).LE.99) THEN
               CHREP='Can''t change units on SAVE card - use *FILE'
               CALL REPORT('GOIIO',7,'W')
            ELSEIF(CCSAVE(JJJ).EQ.'EXCH') THEN
               CHREP='EXCH on SAVE card no longer supported - use *FILE'
               CALL REPORT('GOIIO',8,'W')
            ELSEIF(CCSAVE(JJJ).EQ.'RAWD') THEN
               CHREP='RAWD on SAVE card no longer supported - use *FILE'
               CALL REPORT('GOIIO',9,'W')
            ELSEIF(CCSAVE(JJJ).EQ.'DST ') THEN
               CHREP='DST  on SAVE card no longer supported - use *FILE'
               CALL REPORT('GOIIO',10,'W')
            ELSE
               JJJ = JJJ + 1
            ENDIF
   20    CONTINUE
         NSAVE = JJJ
         CCSAVE(NSAVE) = 'INIT'
      ENDIF
      JJJ=JUCOMP('INIO',IONAME,NFILE)
      IF(JJJ.EQ.0) THEN
         IF(NSAVE.NE.0) THEN
            CHREP='SAVE card, but no *FILE ''INIT'' ''OUT '' card'
            CALL REPORT('GOIIO',11,'W')
         ENDIF
      ELSE
         IF(NSAVE.EQ.0) THEN
            CALL UCTOH('INIT',LSAVE(1),4,4)
            NSAVE=1
            CCSAVE(1)='INIT'
            CHREP='*FILE ''INIT'' ''OUT '' card, but no SAVE card'
            CALL REPORT('GOIIO',12,'I')
            CHREP='SAVE ''INIT'' assumed'
            CALL REPORT('GOIIO',13,'I')
         ENDIF
         LGSAVE=IOUNIT(JJJ)
         CALL UHTOC(IOFCHO(JJJ),4,CHOPT,4)
+SELF,IF=IBM.
         IF(INDEX(CHOPT,'X').NE.0) CALL RADDOP(CHOPT,'Y')
+SELF.
         IF(INDEX(CHOPT,'X').NE.0) THEN
+SELF,IF=VAX,DECS,QMVAOS.
            IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
            IF(IOFNAM(JJJ).EQ.'    ') THEN
              OPEN(LGSAVE,STATUS='NEW',RECORDTYPE='FIXED',
     +        RECL=IOLREC(JJJ),BLOCKSIZE=4*IOLREC(JJJ),
     +        FORM='UNFORMATTED')
            ELSE
              OPEN(LGSAVE,STATUS='NEW',RECORDTYPE='FIXED',
     +        RECL=IOLREC(JJJ),BLOCKSIZE=4*IOLREC(JJJ),
     +        FORM='UNFORMATTED',FILE=IOFNAM(JJJ))
            ENDIF
+SELF,IF=APOLLO,SUN,HPUX.
            IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(LGSAVE,STATUS='NEW'
     +          ,RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
            ELSE
               OPEN(LGSAVE,STATUS='NEW',FILE=IOFNAM(JJJ)
     +          ,RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
            ENDIF
+SELF,IF=IBMRT.
            IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(LGSAVE,STATUS='NEW'
     +          ,FORM='UNFORMATTED')
            ELSE
               OPEN(LGSAVE,STATUS='NEW',FILE=IOFNAM(JJJ)
     +          ,FORM='UNFORMATTED')
            ENDIF
+SELF,IF=SGI.
            IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(LGSAVE,STATUS='NEW'
     +          ,RECL=IOLREC(JJJ),FORM='UNFORMATTED')
            ELSE
               OPEN(LGSAVE,STATUS='NEW',FILE=IOFNAM(JJJ)
     +          ,RECL=IOLREC(JJJ),FORM='UNFORMATTED')
            ENDIF
+SELF.
         ELSE
+SELF,IF=VAX,DECS,QMVAOS.
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(LGSAVE,STATUS='NEW',
     +         FORM='UNFORMATTED')
            ELSE
               OPEN(LGSAVE,STATUS='NEW',FILE=IOFNAM(JJJ),
     +         FORM='UNFORMATTED')
            ENDIF
+SELF,IF=APOLLO,SUN,HPUX.
            IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=2440
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(LGSAVE,STATUS='NEW',
     +         RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
            ELSE
               OPEN(LGSAVE,STATUS='NEW',FILE=IOFNAM(JJJ),
     +         RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
            ENDIF
+SELF,IF=IBMRT.
            IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=2440
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(LGSAVE,STATUS='NEW',
     +         FORM='UNFORMATTED')
            ELSE
               OPEN(LGSAVE,STATUS='NEW',FILE=IOFNAM(JJJ),
     +         FORM='UNFORMATTED')
            ENDIF
+SELF,IF=SGI.
            IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=2440
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(LGSAVE,STATUS='NEW',
     +         RECL=IOLREC(JJJ),FORM='UNFORMATTED')
            ELSE
               OPEN(LGSAVE,STATUS='NEW',FILE=IOFNAM(JJJ),
     +         RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
            ENDIF
+SELF.
         ENDIF
         CALL GOPEN(LGSAVE,CHOPT,IOLREC(JJJ),IER)
      ENDIF
*
*     Other ZEBRA output files - call FZFILE once here - OPEN later
*
      DO 30 II=1,6
         JJJ=JUCOMP(CHNAME(II),IONAME,NFILE)
         IF(JJJ.EQ.0) GO TO 30
         IF(CHNAME(II).EQ.'CONO' .AND. JUCOMP('DSTO',IONAME,NFILE).NE.0
     +   .AND. IOUNIT(JJJ).EQ.IOUNIT(JUCOMP('DSTO',IONAME,NFILE)))
     +   GO TO 30
         CALL UHTOC(IOFCHO(JJJ),4,CHOPT,4)
+SELF,IF=IBM.
         IF(INDEX(CHOPT,'X').NE.0) CALL RADDOP(CHOPT,'Y')
+SELF.
         IF(INDEX(CHOPT,'X').NE.0 .AND. IOLREC(JJJ).EQ.0) 
     +                                         IOLREC(JJJ)=8100
         IF(CHNAME(II)(4:4).EQ.'O') CALL RADDOP(CHOPT,'O')
         IF(CHNAME(II)(4:4).EQ.'I') CALL RADDOP(CHOPT,'I')
+SELF,IF=APOLLO,HPUX,DECS,SUN,SGI,IBMRT.
         IF(INDEX(CHOPT,'L').NE.0) THEN
            IF(INDEX(CHOPT,'T').NE.0) THEN
               CALL CFOPEN(IQUEST(1),1,0,'w',0,IOFNAM(JJJ),IER)
            ELSE
               CALL CFOPEN(IQUEST(1),0,0,'w',0,IOFNAM(JJJ),IER)
            ENDIF
         ENDIF
+SELF.
         CALL FZFILE(IOUNIT(JJJ),IOLREC(JJJ),CHOPT)
  30  CONTINUE
 
*
*     Metafile - dealt with in UGINIT
*
*     Histogram file
*
      GOTOP=' //PAWC'
      JJJ=JUCOMP('HISI',IONAME,NFILE)
      CHOPT=' '
      IF(JJJ.EQ.0) THEN
         JJJ=JUCOMP('HISO',IONAME,NFILE)
         CHOPT='NQ'
         IF(JJJ.NE.0) THEN
            IQUEST(10)=IODCHO(JJJ)
            IF(IQUEST(10).EQ.0) IQUEST(10)=65000
         ENDIF
      ENDIF
      IF(JJJ.EQ.0) THEN
         JJJ=JUCOMP('HISU',IONAME,NFILE)
         CHOPT='U'
      ENDIF
      IF(JJJ.NE.0) THEN
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=1024
         II=0
         GOTOP='//HISTO'
         IF(IOFNAM(JJJ).EQ.'    ') THEN
+SELF,IF=VAX.
            CALL HROPEN(IOUNIT(JJJ),'HISTO','GOHIST',CHOPT,
     +               IOLREC(JJJ),II)
+SELF,IF=-VAX.
            CALL HROPEN(IOUNIT(JJJ),'HISTO','GOPAL.HISTO',CHOPT,
     +               IOLREC(JJJ),II)
+SELF.
         ELSE
            CALL HROPEN(IOUNIT(JJJ),'HISTO',IOFNAM(JJJ),CHOPT,
     +               IOLREC(JJJ),II)
         ENDIF
         IF(II.NE.0) THEN
            WRITE(CHREP,'('' Error #'',I4,''  in HROPEN'')') II
            CALL REPORT('GOIIO',20,'E')
         ENDIF
      ENDIF
*
*     OC file
*
      JJJ=JUCOMP('CALI',IONAME,NFILE)
      IF(JJJ.NE.0) THEN
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=4096
+SELF,IF=IBM.
*-- Get filename (lifted blindly from ROPE)
         WRITE(CHCALI,1000) IOUNIT(JJJ)
 1000    FORMAT('DATABASE',I2.2)
         CALL VMREXX('F',CHCALI,CHFNAM,ISTAT)
         IF(ISTAT.NE.0)                                        GO TO 999
         CALL FILEINF(ISTAT,'MAXREC',2)
         IF(ISTAT.NE.0)                                        GO TO 999
         OPEN(UNIT=IOUNIT(JJJ),FILE='/'//CHFNAM,ACCESS='DIRECT',
     +   STATUS='UNKNOWN',RECL=IOLREC(JJJ)*4,
     +   FORM='UNFORMATTED',IOSTAT=ISTAT)
         IF(ISTAT.NE.0)                                        GO TO 999
         CLOSE(UNIT=IOUNIT(JJJ))
         CALL FILEINF(ISTAT,'MAXREC',16777215)
         IF(ISTAT.NE.0)                                        GO TO 999
         OPEN(UNIT=IOUNIT(JJJ),FILE='/'//CHFNAM,ACCESS='DIRECT',
     +   STATUS='OLD',RECL=IOLREC(JJJ)*4,
     +   FORM='UNFORMATTED',IOSTAT=ISTAT)
+SELF,IF=VAX,DECS,QMVAOS.
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        ORGANIZATION='RELATIVE',
     +        RECL=IOLREC(JJJ),READONLY,SHARED,STATUS='OLD')
         ELSE
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        ORGANIZATION='RELATIVE',FILE=IOFNAM(JJJ),
     +        RECL=IOLREC(JJJ),READONLY,SHARED,STATUS='OLD')
         ENDIF
+SELF,IF=APOLLO,SUN,HPUX.
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        RECL=4*IOLREC(JJJ),STATUS='READONLY')
         ELSE
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        RECL=4*IOLREC(JJJ),STATUS='READONLY',FILE=IOFNAM(JJJ))
         ENDIF
+SELF,IF=IBMRT.
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        RECL=4*IOLREC(JJJ),STATUS='OLD')
         ELSE
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        RECL=4*IOLREC(JJJ),STATUS='OLD',FILE=IOFNAM(JJJ))
         ENDIF
+SELF,IF=SGI.
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        RECL=IOLREC(JJJ))
         ELSE
            OPEN(IOUNIT(JJJ),ACCESS='DIRECT',FORM='UNFORMATTED',
     +        RECL=IOLREC(JJJ),FILE=IOFNAM(JJJ))
         ENDIF
+SELF.
         CALL OCINI(IOUNIT(JJJ),'MAIN','GOPAL','GOPAL',' ')
      ENDIF
*
  999 END
+DECK,GOISTA
      SUBROUTINE GOISTA
*.
*...GOISTA   Initialize statistics for GOPAL
*.
*. COMMON    : GOSTAT
*. SEQUENCE  :
*. CALLS     : VZERO
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 27-Nov-87
*. LAST MOD  : 28-Sep-94
*.
*. Modification Log.
*. 28-Sep-94   C.P.Ward      Increase size of SDET array
*. 25-Apr-88   D.R.Ward      Strong typing
*. 21-Jan-88   D.R.Ward      Initialize NEVTS
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,GOSTAT.
      NEVTS=0
      MVPRIM=0
      CALL VZERO(SDET,170)
      CALL VZERO(SKIN,1200)
      NVO=0
      CALL VZERO(KVOLU,400)
      CALL VZERO(KMEC,30)
      END
+DECK,GOKINE.
      SUBROUTINE GOKINE
*.
*...GOKINE initializes GEANT kinematics from GOPAL generated particle ba
*.
*. SEQUENCE  : GCBANK LINKRA RCREP
*. CALLS     : GSVERT GSKINE IUCOMP
*. CALLED    :
*.
*. BANKS U   : GENE
*. BANKS M   : TREE
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 18-Apr-88
*. LAST MOD  : 27-Feb-97
*.
*. Modification Log.
*. 27-Feb-97   C.P.Ward      Fix REPORT message
*. 29-Feb-96   C.P.Ward      Add codes +-52,54,56,71 for possible LSPs
*. 28-Apr-95   S.Lloyd       Undecayed Ks/Kl fixed.
*. 12-May-94   C.P.Ward      Add code -18 
*. 10-May-94   C.P.Ward      Add code 18
*. 28-Feb-89   J.Banks       Bug fix
*. 22-Feb-89   S.L.Lloyd     Change to PDG particle codes.
*   7-Oct-88   D.Lellouch    Bug in antisigma
*. 05-May-88   S.L.Lloyd     Sort out error messages and treat K0
*. 25-Apr-88   D.R.Ward      Strong type
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,GCBANK.
+SEQ,LINKRA.
+SEQ,RCREP.
      REAL V(3),X,Y,Z,RNDM
      INTEGER ISEL(51),JSEL(51)
      INTEGER LGENE,LTREE,NGEN,LENT,NTRK,N,NADD,NVTX,IJK, IGTYPE,
     +NT,NSEL,IUCOMP
      EXTERNAL IUCOMP
*   Conversion table between PDG particle codes and GEANT.
      DATA NSEL/51/
      DATA ISEL/ 22,-11, 11, 12,-12,-13, 13, 14,-14, 16,-16, 211,-211,
     + 321,-321, 310, 130,2212,-2212,2112,-2112,3222,-3222,3112,-3112,
     + 3322,-3322,3312,-3312,3122,-3122,3334,-3334, 15,-15,3212,-3212,
     + 221,-221,111,-111,18,-18,52,-52,54,-54,56,-56,71,-71/
      DATA JSEL/ 1, 2, 3, 4, 4, 5, 6, 4, 4, 4, 4, 8, 9, 11, 12, 16, 10,
     +14, 15, 13, 25, 19, 27, 21, 29, 22, 30, 23, 31, 18, 26, 24, 32,
     +34, 33, 20, 28, 17, 17, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4/
*
      LGENE = LQ(LMC-1)
      IF (LGENE.LE.0) GO TO 30
      LTREE = LQ(LGENE-1)
*
      NGEN  = IQ(LGENE+1)
      IF (NGEN.EQ.0) GO TO 30
*
      LENT  = IQ(LGENE+5)
*
   10 CONTINUE
*
      NTRK = 0.0
*
*-- Count all tracks coming from the same vertex.
*
      DO 20 N=1,NGEN
         NADD = LTREE + (N-1)*LENT
         IF (IQ(NADD+10).LT.0) GO TO 20
         IF (IQ(NADD+7).NE.0) GO TO 20
         X = Q(NADD+10+7)
         Y = Q(NADD+10+8)
         Z = Q(NADD+10+9)
*
*-- Tell GEANT about this vertex.
*
         IF (NTRK.EQ.0) THEN
            V(1) = X
            V(2) = Y
            V(3) = Z
            CALL GSVERT (V,0,0,0,0,NVTX)
            IF (NVTX.EQ.0) THEN
               WRITE (CHREP,1000)
               CALL REPORT ('GOKINE',1,'ERROR')
               GO TO 20
            ENDIF
         ENDIF
*
         IF (X.NE.V(1).OR.Y.NE.V(2).OR.Z.NE.V(3)) GO TO 20
*
*-- Convert from PDG particle code to GEANT.
*-- If a K0 or anti-K0 make a Ks or Kl.
*
         IF (ABS(IQ(NADD+1)).EQ.311) THEN
            CALL GRNDM(RNDM,1)
            IF (RNDM.LE.0.5) THEN
               IGTYPE = 10 
               IQ(NADD+1) = 130
            ELSE
               IGTYPE = 16
               IQ(NADD+1) = 310
            ENDIF
            WRITE (CHREP,1300) 
            CALL REPORT ('GOKINE',4,'WARNING')
         ELSE
            IJK = IUCOMP(IQ(NADD+1),ISEL,NSEL)
            IF (IJK.EQ.0) THEN
               WRITE (CHREP,1200) IQ(NADD+1)
               CALL REPORT ('GOKINE',3,'ERROR')
               GO TO 20
            ENDIF
            IGTYPE = JSEL(IJK)
         ENDIF
*
         NTRK = NTRK + 1
*
*-- Tell GEANT about this track.
*
         CALL GSKINE (Q(NADD+10+1),IGTYPE,NVTX,0,0,NT)
         IF (NT.EQ.0) THEN
            WRITE (CHREP,1100)
            CALL REPORT ('GOKINE',2,'ERROR')
            GO TO 20
         ENDIF
         IQ(NADD+7) = NT
*
   20 CONTINUE
*
      IF (NTRK.GT.0) GO TO 10
*
      GO TO 30
*
   30 CONTINUE
*
*
 1000 FORMAT (1X,'GOKINE - Error creating Vertex')
 1100 FORMAT (1X,'GOKINE - Error creating Track')
 1200 FORMAT (1X,'GOKINE - Particle code',I5,' not known')
 1300 FORMAT (1X,'GOKINE - K0/anti-K0 converted to Ks/Kl')
      END
+DECK,GOKING.
      SUBROUTINE GOKING
*.
*...GOKING   User routine to handle new generation of particles.
*.
*.     Routine called by GUSTEP when
*.     a Physics process KCASE has generated new tracks
*.     Track parameters are in common /GCKING/
*.     Here the user can decide to
*.        a,to store the NGKINE generated tracks into the GEANT
*.          data structures JVERTX,JKINE
*.        b,to store the NGKINE generated tracks in the stack
*.        c,to not store the NGKINE tracks but still take care
*.          of a correct energy balance.
*.
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCKINE GCKING GCONST GCTMED GCTRAK GCUNIT GCVOLU
*. CALLS     : GMAIL  GSKINE GSKING GSVERT UHTOC GOTRUP
*. CALLED    : GUSTEP
*. BANKS L   : VERT   KINE
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 11-Nov-93
*.
*. Modification Log.
*. 11-Nov-93   C.P.Ward        Do not store permanently electrons below 1MeV
*. 27-Feb-92   D.R.Ward        Add SIDE to sensitive detectors in CD
*. 11-May-89   D.R.Ward        Store neutrinos (TREE only) if anything else
*. 26-Sep-88   D.R.Ward        Always call GSKING (GEANT312)
*.  4-Jul-88   D.R.Ward        Small change to geometric cuts defining C
*. 17-May-88   D.R.Ward        Update TREE once only if stacking
*. 10-May-88   D.R.Ward        Store low energy delta rays if in CD sens
*.  9-May-88   D.R.Ward        Small change to logic of storing secondar
*.                             in the CD region
*.  5-May-88   D.R.Ward        Fix small bug with stack
*. 25-Apr-88   D.R.Ward        Strong typing
*. 21-Apr-88   S.L.Lloyd       Call GOTRUP to update tree.
*. 14-Apr-88   D.R.Ward        Use CHREP for REPORT
*.  2-Dec-87   D.R.Ward        Do no store permanantly mu from stopped p
*. 30-Nov-87   D.R.Ward        Use of REPORT
*.  1-Sep-87   D.R.Ward        Set data type of user bank to hollerith
*. 20-Oct-86   D.R.Ward        Don't store low energy photons
*.                             Change selection on ISVOL to geometric cu
*.                             Store volume and mechanisms with vertex
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*. 10-Feb-86   S.O'Neale       Use the temporary stack for low momentum
*.                             (To avoid too many delta rays.)
*.                             GSKING replaces GSSTAK.
*. 12-Sep-85   S.O'Neale       Remove Energy Cut, add error
*.                             messages for GSt/v failures.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,RCREP.
+SEQ,GCVOLU
+SEQ,GCTMED
+SEQ,GCKINE
+SEQ,GCTRAK
+SEQ,GCKING
+SEQ,GCUNIT
+SEQ,GCBANK
+SEQ,GCONST
*
      REAL    RRR,ZZZ
      INTEGER IVBUF(30),NVTX,I,KPART,NVBUF,J,LVER,LVERU,NLNK
      INTEGER IUCOMP,NT,IICVPC,IICVSC,IICJET,IICZZD,IISIDE,IENT,ITROLD
      INTEGER NNEU,NTREE
      LOGICAL IFTRUP
      EXTERNAL IUCOMP
      SAVE IENT
      DATA IENT/0/
      IF(IENT.EQ.0) THEN
         IENT=1
         CALL UCTOH('CVPC',IICVPC, 4, 4)
         CALL UCTOH('CVSC',IICVSC, 4, 4)
         CALL UCTOH('CJET',IICJET, 4, 4)
         CALL UCTOH('CZZD',IICZZD, 4, 4)
         CALL UCTOH('SIDE',IISIDE, 4, 4)
      ENDIF
*--
*    The Report Conditions and Lifted Banks are to exercise
*    the ZEBRA Writeup package.
*--
      NVTX   = 0
      IFTRUP=.FALSE.
*--  Loop over the newly generated particles - -
      NNEU=0
      NTREE=0
      DO 60 I = 1,NGKINE
         KPART = GKIN(5,I)
*--        Do not track neutrinos - -
         IF (KPART.EQ.4) THEN
            NNEU=NNEU+1
            GO TO 50
         ENDIF
*--        Always keep muons (biased selection by S.O'Neale) - -
*--   except for those from pi decays at rest
         IF ((KPART.EQ. 5.OR. KPART.EQ.6) .AND. IUCOMP(30,LMEC,NMEC).EQ.
     +   0) GOTO 20
*--      Stack low momentum photons  in any volume.
*--      (This is to avoid keeping bremsstrahlung etc) - -
         IF(KPART.EQ. 1.AND. GKIN(4,I).LT.0.010) GO TO 10
*--      Stack very low energy (K.E. < 1 MeV) electrons and positrons
*--      in any volume; this is to reduce number of permanently 
*--      stored delta rays in SI.
         IF((KPART.EQ.2 .OR. KPART.EQ.3) .AND. 
     +      (GKIN(4,I)-EMASS).LT.0.001) GO TO 10
*--      Stack low momentum (<10 MeV) electrons and positrons in any 
*--      volume except CD sensitive volumes.
*--      (This is to avoid keeping too many delta rays etc) - -
         IF((KPART.EQ.2 .OR. KPART.EQ.3) .AND. NAMES(NLEVEL).NE.IICVPC
     +   .AND. NAMES(NLEVEL).NE.IICVSC .AND. NAMES(NLEVEL).NE.IICJET
     +   .AND. NAMES(NLEVEL).NE.IICZZD .AND. NAMES(NLEVEL).NE.IISIDE 
     +   .AND.(GKIN(4,I).LT.0.010))
     +   GOTO 10
*--      Keep other tracks within the sensitive CD region
         RRR=SQRT(VECT(1)**2+VECT(2)**2)
         ZZZ=ABS(VECT(3))
         IF(RRR.LT.23.5) THEN
            IF(ZZZ.GT.50.) GO TO 10
            GO TO 20
         ELSEIF(RRR.LT.200.) THEN
            IF(ZZZ.GT.147. +0.26795*RRR) GO TO 10
            GO TO 20
         ENDIF
   10    CALL GSKING(I)
         GO TO 50
*
   20    IF (NVTX.NE.0)GO TO 40
*--
*--    Store a new vertex.
*--    Use the user words to store the volume name in which the
*--    vertex occurred, and the mechanism(s).
         IVBUF(1)=NAMES(NLEVEL)
         NVBUF=1
         DO 30 J=1,NMEC
            IF(LMEC(J).LE.4) GO TO 30
            NVBUF=NVBUF+1
            IVBUF(NVBUF)=NAMEC(LMEC(J))
   30    CONTINUE
         CALL GSVERT(VECT,ITRA,0,IVBUF,NVBUF,NVTX)
         IF (NVTX.EQ.0) THEN
*--    Issue an error message in case of failure (no ZQTELL yet).
            WRITE(CHREP ,FMT='('' Failed to store VERTEX '')')
            CALL REPORT('GOKING',1,'E')
            GOTO 70
         ENDIF
*     Try to set the user words bank to hollerith
         LVER=LQ(JVERTX-NVTX)
         LVERU=LQ(LVER-1)
         NLNK=IQ(LVERU-3)
         IQ(LVERU-NLNK-9)=IQ(LVERU-NLNK-9)+131072
*--
*--    Store a new track on the permanent store.
   40    CALL GSKINE(GKIN(1,I),KPART,NVTX,0,0,NT)
         IF (NT.EQ.0) THEN
*--    Issue an error message in case of failure (no ZQTELL yet).
            WRITE(CHREP ,FMT='('' Failed to store TRACK '')')
            CALL REPORT('GOKING',2,'E')
            GOTO 70
         ENDIF
*
*--   Also must add to stack if we want to track it.
*--   also need to fool GEANT as to the track number
*
      ITROLD=ITRA
      ITRA=-NT
      CALL GSKING(I)
      ITRA=ITROLD
*
*-- Update particle tree.
*
         CALL GOTRUP (ITRA,VECT,KCASE,KPART,NT,GKIN(1,I))
         NTREE=NTREE+1
         GO TO 60
*
   50    CONTINUE
         IF(IFTRUP) GO TO 60
         IFTRUP=.TRUE.
         IF(ISTAK.EQ.0) CALL GOTRUP (ITRA,VECT,KCASE,KPART,0,GKIN(1,I))
*
*    End of the loop over tracks.
   60 CONTINUE
*
*    If there were any neutrinos, and if anything else was stored in the TREE
*    put the neutrinos there too...
*
      IF(NNEU.EQ.0 .OR. NTREE.EQ.0) GO TO 70
      DO 80 I=1,NGKINE
         KPART=GKIN(5,I)
         IF(KPART.EQ.4)CALL GOTRUP(ITRA,VECT,KCASE,KPART,999,GKIN(1,I))
  80  CONTINUE
*
   70 RETURN
      END
+DECK,GOLIFE.
      SUBROUTINE GOLIFE
*
*...GOLIFE puts finite lifetimes into the generated particle bank.
*.
*. SEQUENCE  : GCBANK RCREP LINKRA GOCART GOFLD GOLIFC GOXMIX
*. CALLS     : GRANOR GRNDM REPORT GUFLD
*. CALLED    : GUKINE
*.
*. BANKS U   : GENE
*. BANKS M   : TREE
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 18-Apr-88
*. LAST MOD  : 26-Mar-96
*.
*. Modification Log.
*. 26-Mar-96   C.P.Ward      Another mod for photons from quarks
*. 18-Mar-96   C.P.Ward      Check parent before daughters in TREE.
*. 05-Sep-95   C.P.Ward      Allow for direct photons from quarks.
*. 23-Mar-95   C.P.Ward      Minor fix to swimmimg of daughters.
*. 03-Nov-94   C.P.Ward      Update lifetimes.
*. 16-May-94   C.P.Ward      Fix for particles from jets.
*. 08-Dec-93   C.P.Ward      Remove unused variables.
*. 27-Oct-93   R.W.L.Jones   Change b lifetime defaults to 1.5ps.
*. 21-Oct-93   R.W.L.Jones   Impliment time dependent mixing.
*. 12-Aug-93   C.P.Ward      Fix swimming of daughters.
*. 17-Aug-92   S.L.Lloyd     Update lifetimes for PDG 1992 + New OPAL B.
*.  3-Aug-90   S.L.Lloyd     Modify lifetimes from LIFE card.
*.  6-Jul-90   D.R.Ward      Use BZ000
*. 30-Nov-89   D.R.Ward      Defaults for VERT card now set in GOIFFR
*. 17-Jul-89   D.R.Ward      Fix mag field usage
*.  2-Jun-89   D.R.Ward      Fill vertex position in BEAM bank
*. 03-Apr-89   J.W.Gary      Give lifetimes to bottomed baryons etc.
*. 22-Feb-89   S.L.Lloyd     Change to PDG particle codes.
*.  9-Feb-89   D.R.Ward      Update beam spot (main change is z)
*.  7-Feb-89   S.L.Lloyd     Update for PDG 1988
*. 26-Jul-88   M.Dittmar     Protect log(rndm)
*. 11-Jul-88   S.W.O'Neale   Fixes for CRAY
*. 05-May-88   S.L.Lloyd     Tidy up primary vertex and field
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.**********************************************************************
*
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,ROBANK.
+SEQ,GCONST.
+SEQ,GOFLD.
+SEQ,GOCART.
+SEQ,GOLIFC.
+SEQ,GOXMIX.
+SEQ,LINKGO.
+SEQ,ROCPAR.
      DOUBLE PRECISION DARC,DALP
      REAL FIELD,SFIELD,CTTOP,DUMMY,CTAU,PP,T,XMASS,PT,R0,ARC,
     +PHIO, PHID,PTD,GARNDM,DUM1,SVXR,SVYR,SVZR
      EXTERNAL GARNDM
      INTEGER NNFLIP
      PARAMETER (NNFLIP=9)
      INTEGER LGENE,LTREE,NGEN,I,NADD,LENT,IPAR,NADDP,NDEC,IPART,ND,J,
     +NADDD,IPOS,IX,IM,MIXDAD,NADDJ,NADDJP,IJET,IPJET,IPJ1,LENJ,LJETS
      INTEGER MIXERS(4),NOFLIP(NNFLIP)
      SAVE MIXERS,NOFLIP
      INTEGER INFLIP,I4,I3,I2
      INTEGER IUCOMP
      REAL BXYZ(3)
      INTEGER  NXLIFE
      PARAMETER  (NXLIFE=29)
      INTEGER  IDLIFE (NXLIFE)
      REAL  XLIFE (NXLIFE), RLIFE, XBBMIX
      INTEGER KILROY,LGNCT,LBEAM,LLIFE
      LOGICAL FIRST
      SAVE KILROY, FIRST, IDLIFE, XLIFE, CTTOP
      DATA FIRST/.TRUE./
      DATA KILROY/0/
*
*   Lifetimes of heavy particles:
*       1994 Particle Data Book if measured, but updated values
*       for b mesons and baryons from R.Kowalewski; otherwise guesses.
*           Tau,    D+,     D0,    Ds,   B0,   B+,   Bs,   Bc,
*        Lam_c+, Xi_c0,  Xi_c+, Om_c0, Strange Charmed Baryons,
*        Lam_b0, Xi_b-,  Xi_b0, Om_b-,
*        Bottom Bottom Baryons, Bottom Charmed Baryons.
*
* These are objects that are self-conjugate and not q1(q1bar)
*
      DATA NOFLIP/9,21,22,23,25,35,36,130,310/
      DATA MIXERS/511,-511,531,-531/
      DATA  IDLIFE /
     +       15,   411,    421,   431,  511,  521,  531,  541,
     +     4122,  4132,   4232,  4332, 4412, 4422, 4432, 4444,
     +     5122,  5132,   5232,  5332,
     +     5512,  5522,   5532,  5542, 5554, 5142, 5242, 5342, 5442/
      DATA  XLIFE /
     +  0.00886,0.0317,0.01244,0.0140,0.048,0.048,0.048,0.030,
     +   0.0060,0.0029, 0.0106, 0.007,0.007,0.007,0.007,0.007,
     +   0.036, 0.036,  0.036, 0.036,
     +   0.036, 0.036,  0.036, 0.030,0.036,0.030,0.030,0.030,0.030 /
      DATA  CTTOP /0.0/
*
*-- First event - update lifetimes from LIFE card.
*
      IF (FIRST) THEN
        FIRST = .FALSE.
        DO 1 IX=1,9
          IF (TXLIFE(IX).GE.0.0) THEN
            WRITE (CHREP,2001) IDLIFE(IX),XLIFE(IX),TXLIFE(IX)
            CALL REPORT ('GOLIFE',1,'W')
            XLIFE(IX) = TXLIFE(IX)
          ENDIF
    1   CONTINUE
*
        IF (TXLIFE(10).GE.0.0) THEN
          DO 2 IX=10,16
            WRITE (CHREP,2001) IDLIFE(IX),XLIFE(IX),TXLIFE(10)
            CALL REPORT ('GOLIFE',1,'W')
            XLIFE(IX) = TXLIFE(10)
    2     CONTINUE
        ENDIF
*
        IF (TXLIFE(11).GE.0.0) THEN
          DO 3 IX=17,25
            WRITE (CHREP,2001) IDLIFE(IX),XLIFE(IX),TXLIFE(11)
            CALL REPORT ('GOLIFE',1,'W')
            XLIFE(IX) = TXLIFE(11)
    3     CONTINUE
        ENDIF
*
        IF (TXLIFE(12).GE.0.0) THEN
          DO 4 IX=26,29
            WRITE (CHREP,2001) IDLIFE(IX),XLIFE(IX),TXLIFE(12)
            CALL REPORT ('GOLIFE',1,'W')
            XLIFE(IX) = TXLIFE(12)
    4     CONTINUE
        ENDIF
*
        IF (TXLIFE(13).GE.0.0) THEN
          WRITE (CHREP,2002) CTTOP,TXLIFE(13)
          CALL REPORT ('GOLIFE',2,'W')
          CTTOP = TXLIFE(13)
        ENDIF
      ENDIF
*
*     First event - store beam position in BEAM bank
*
      IF(KILROY.EQ.0 .AND. LDAC.GT.0) THEN
         KILROY=1
         LGNCT=LQ(LDAC-LLGNCT)
         IF(LGNCT.GT.0) THEN
            LBEAM=LQ(LGNCT-LLBEAM)
            IF(LBEAM.GT.0) THEN
               Q(LBEAM+IXBEAM)=CAVXYZ(1)
               Q(LBEAM+IYBEAM)=CAVXYZ(2)
               Q(LBEAM+IZBEAM)=CAVXYZ(3)
               Q(LBEAM+IDXBEA)=CAVXYZ(4)
               Q(LBEAM+IDYBEA)=CAVXYZ(5)
               Q(LBEAM+IDZBEA)=CAVXYZ(6)
            ENDIF
            LLIFE=LQ(LGNCT-LLLIFE)
            IF(LLIFE.GT.0) CALL UCOPY(XLIFE,Q(LLIFE+1),NXLIFE)
         ENDIF
      ENDIF
*
      LGENE = LQ(LMC-1)
      IF (LGENE.LE.0) GO TO 30
*
      LTREE = LQ(LGENE-1)
      LJETS = LQ(LGENE-2)
*
      NGEN  = IQ(LGENE+1)
      LENT  = IQ(LGENE+5)
      LENJ  = IQ(LGENE+6)
*
*-- Generates primary interaction point.
*
      CALL GRANOR(SVXR,SVYR)
      CALL GRANOR(SVZR,DUMMY)
      BXYZ(1) = CAVXYZ(1) + SVXR * CAVXYZ(4)
      BXYZ(2) = CAVXYZ(2) + SVYR * CAVXYZ(5)
      BXYZ(3) = CAVXYZ(3) + SVZR * CAVXYZ(6)
*
*-- Find magnetic field.
*
      FIELD=BZ000
      SFIELD =SIGN(1.0,FIELD)
*
*   Loop over all particles in tree.
*
      DO 20 I=1,NGEN
         NADD = LTREE + (I-1)*LENT
*
*-- Secondary particles start at their parent's decay point.
*
         IF (IQ(NADD+9).GT.1 .OR. I.GT.IQ(LGENE+2)) THEN
            IPAR = IQ(NADD+2)
            IF (IPAR.EQ.0) THEN
*
*-- Particle came via the jets bank. We find the jet (IJET) which
*-- should be a string or cluster. We find the parent jets (IPJET) which
*-- are coded IPJ2 + 1000*IPJ1 and look for the tree parent of the first
*-- one (IPAR). Then we are there !
*-- CPW 16/5/94 follow history up jets bank if necessary
*-- CPW  5/9/95 mod for parton with no parent
*-- CPW 26/3/96 use mod(ipjet,1000) instead of ipjet/1000, so valid
*--             for strings or bare partons 
*
               IJET = IQ(NADD+6)
               IF (IJET.GT.0) THEN
                  NADDJ = LJETS + (IJET-1)*LENJ
                  IPJET = IQ(NADDJ+2)
                  IF (IPJET.GT.0) THEN
                     IPJ1 = MOD(IPJET,1000)
  50                 IF (IPJ1.GT.0) THEN
                        NADDJP = LJETS + (IPJ1-1)*LENJ
                        IPAR = IQ(NADDJP+3)
                        IF (IPAR.LE.0) THEN
                           IPJ1 = IQ(NADDJP+2)
                           GO TO 50 
                        ENDIF
                     ELSE
                        GO TO 5
                     ENDIF
                  ELSE
                     IPAR = IQ(NADDJ+3)
                  ENDIF
               ELSE
                  GO TO 5
               ENDIF
*
            ENDIF
            IF(IPAR.GT.I) THEN
              WRITE(CHREP,2003) I,IPAR
              CALL REPORT('GOLIFE',3,'E')
            ENDIF
            NADDP = LTREE + (IPAR-1)*LENT
            Q(NADD+10+7) = Q(NADDP+10+10)
            Q(NADD+10+8) = Q(NADDP+10+11)
            Q(NADD+10+9) = Q(NADDP+10+12)
            MIXDAD = IQ(NADDP+8)
            GOTO 6
 5          CONTINUE
*
* No parent can be found - this is probably an upsilon
* Report it, and leave the GOTREE comemnted for now
* Regard the parent as unmixed - which will be true in
* the upsilon case.
*
            CHREP = ' Secondary without a parent '
            CALL REPORT('GOLIFE',4,'W')
C           CALL GOTREE(0)
            Q(NADD+10+7) = BXYZ(1)
            Q(NADD+10+8) = BXYZ(2)
            Q(NADD+10+9) = BXYZ(3)
            MIXDAD = 0
 6          CONTINUE
*
*-- Primary particles start at the interaction point.
*
         ELSE
            Q(NADD+10+7) = BXYZ(1)
            Q(NADD+10+8) = BXYZ(2)
            Q(NADD+10+9) = BXYZ(3)
            MIXDAD = 0
         ENDIF
*
*
         IPART = ABS(IQ(NADD+1))
         INFLIP = IUCOMP(IPART,NOFLIP,NNFLIP)
         IF (INFLIP.EQ.0) THEN
           I4=MOD(IPART,10000)/1000
           I3=MOD(IPART,1000)/100
           I2=MOD(IPART,100)/10
           IF (I4.EQ.0.AND.I3.NE.0) THEN
* This is a meson
              IF (I3.EQ.I2) THEN
* This guy is self-conjugate
                 INFLIP = 1
              ENDIF
           ENDIF
         ENDIF
         IF (MIXDAD.EQ.1) THEN
*
* Parent has mixed - the sins of the fathers are vested on their children
*
            IQ(NADD+8) = 1
            IF (INFLIP.EQ.0) THEN
               IQ(NADD +  1) = -1*IQ(NADD +  1)
                Q(NADD + 16) = -1.*Q(NADD + 16)
*  Fix-up the mass and energy too?
*     CALL GFPART (IQ(NADD+1),CHPART,ITRTYP,AMASS,CHARGE,TLIFE,UB,NWB)
*               Q(NADD + 15) = AMASS
*               Q(NADD + 14) = (Q(NADD + 14)+XMASS)*(Q(NADD + 14)-XMASS)
*               Q(NADD + 14) = SQRT(Q(NADD + 14)+AMASS*AMASS)
            ENDIF
         ENDIF
*
         NDEC = IQ(NADD+4)
         IF (NDEC.EQ.0) GO TO 20
*
*-- If the particle decays, get its lifetime.
*
         IPOS=-1
         DO 7 IX=1,NXLIFE
            IF(IPART.EQ.IDLIFE(IX)) THEN
               IPOS = IX
               GO TO 8
            END IF
 7       CONTINUE
 8       CTAU = 0.0
         IF (IPOS.NE.-1) THEN
            CTAU = XLIFE(IPOS)
         ELSE IF (IPART/1000.EQ.6.AND.MOD(IPART,10).EQ.1) THEN
            CTAU = CTTOP
         ENDIF
*
*-- If the lifetime is zero then the end point is the start point.
*
         IF (CTAU.EQ.0.0) THEN
            Q(NADD+10+10) = Q(NADD+10+7)
            Q(NADD+10+11) = Q(NADD+10+8)
            Q(NADD+10+12) = Q(NADD+10+9)
            GO TO 20
         ELSE
*
*-- If the lifetime is non zero work out its decay time etc.
*
            PP = SQRT(Q(NADD+10+1)**2+Q(NADD+10+2)**2+Q(NADD+10+3)**2)
            RLIFE = GARNDM(DUM1)
            T =  CTAU*RLIFE
            XMASS = Q(NADD+10+5)
         ENDIF
*
*-- See if there is mixing
*
         IF (MIXDAD.NE.1) THEN
*
* The parent has not mixed, should this particle?
*
            IM = IUCOMP(IQ(NADD+1),MIXERS,4)
            IF (IM.GT.0) THEN
               IF (IM.LT.3) THEN
                  XBBMIX = XMIX(1)
               ELSE IF (IM.GT.2) THEN
                  XBBMIX = XMIX(2)
               ENDIF
* Does it mix?
               CALL GRNDM(DUM1,1)
               IF (SIN(0.5*XBBMIX*RLIFE)**2.GT.DUM1) THEN
                 IQ(NADD+8) = 1
               ENDIF
            ENDIF
         ENDIF
*
*-- Neutral particles or zero field have straight trajectories.
*
         IF (Q(NADD+10+6).EQ.0.0.OR.FIELD.EQ.0.0) THEN
            Q(NADD+10+10) = Q(NADD+10+7) + T*Q(NADD+10+1)/XMASS
            Q(NADD+10+11) = Q(NADD+10+8) + T*Q(NADD+10+2)/XMASS
            Q(NADD+10+12) = Q(NADD+10+9) + T*Q(NADD+10+3)/XMASS
*
*-- Charged particles have curved trajectories.
*
         ELSE
            PT = SQRT(Q(NADD+10+1)**2+Q(NADD+10+2)**2)
            R0 = PT/(0.0003*FIELD)
            ARC = T*(0.0003*FIELD)/XMASS
            PHIO = ATAN2(Q(NADD+10+2),Q(NADD+10+1))
            DALP = PHIO-SFIELD*Q(NADD+10+6)*PIBY2
            DARC = ARC*SFIELD*Q(NADD+10+6)
*
            Q(NADD+10+10) = Q(NADD+10+7) + R0*(COS(DALP)-COS(DALP-DARC))
            Q(NADD+10+11) = Q(NADD+10+8) + R0*(SIN(DALP)-SIN(DALP-DARC))
            Q(NADD+10+12) = Q(NADD+10+9) + T*Q(NADD+10+3)/XMASS
*
*-- Swim all daughters to decay point.
*
            DO 10 ND=1,NDEC
               J = IQ(NADD+3) + ND - 1
               NADDD = LTREE + (J-1)*LENT
               IF (Q(NADDD+10+1).EQ.0.0 .AND. Q(NADDD+10+2).EQ.0.0) 
     +                                                      GO TO 10
               PHID = ATAN2(Q(NADDD+10+2),Q(NADDD+10+1))
               PHID = PHID - SFIELD*Q(NADD+10+6)*ARC
               PTD = SQRT(Q(NADDD+10+1)**2+Q(NADDD+10+2)**2)
               Q(NADDD+10+1) = PTD*COS(PHID)
               Q(NADDD+10+2) = PTD*SIN(PHID)
   10       CONTINUE
*
         ENDIF
*
   20 CONTINUE
*
   30 CONTINUE
*
 2001 FORMAT ('Lifetime of particle',I5,' changed from',F8.4,' to',F8.4)
 2002 FORMAT ('Lifetime of top particles changed from',F8.4,' to',F8.4)
 2003 FORMAT ('Tree entry',I3,' occurs before parent, entry',I3)
*
      END
+DECK,GOLINT.
      SUBROUTINE GOLINT
*.
*...GOLINT converts from the LUND common to GOPAL generated particle ban
*.
*. SEQUENCE  : GCBANK LUJETS LINKRA RCREP GOXTRA
*. CALLS     : MZFORM MZBOOK LUCHGE REPORT GOLPDG
*. CALLED    :
*.
*. BANKS L   : GENE TREE JETS
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 15-Apr-88
*. LAST MOD  :  3-May-91
*.
*. Modification Log.
*.  3-May-91   S.L.Lloyd     Add XTRA bank
*.  9-Feb-90   D.Lellouch    Bug fix.
*. 25-Feb-89   D.R.Ward      Use GOPAR
*. 22-Feb-89   S.L.Lloyd     Call GOLPDG to convert to PDG codes.
*. 27-Sep-88   D.R.Ward      Fix bug for jetless events
*. 05-May-88   S.L.Lloyd     Double spare bank space
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCBANK.
+SEQ,LUJETS.
+SEQ,LINKRA.
+SEQ,GOPAR.
+SEQ,GOXTRA.
      INTEGER NGEN,NPRIM,NJET,NSJET,NP,NJ,L,LGENE,LENT,LENJ,IOTREE,
     +LTREE,LJETS,K2A,KS,KH,NADD,J,NJTOT,NJJ,NUMJET,LPAR,LL, NSEC,LPAR2,
     +NSEC2,LL2,L2,IOJETS,LUCHGE,LXTRA
      EXTERNAL LUCHGE
*
*  Count number of particles and jets.
*
      NGEN  = 0
      NPRIM = 0
      NJET  = 0
      NSJET = 0
*
      NP = 0
      NJ = 0
*
      DO 10 L=1,N
         IF(IABS(K(L,2)).GE.500.AND.IABS(K(L,2)).LE.588) THEN
            NJ = NJ + 1
         ELSE
            NP = NP + 1
         ENDIF
   10 CONTINUE
*
*-- Creates generated particle and jet banks.
*   Include an extra 100% for expansion during tracking.
*
      NP = 2*NP
      LGENE = LQ(LMC-1)
      LENT = IQ(LGENE+5)
      LENJ = IQ(LGENE+6)
      IOTREE = IQ(LGENE+7)
      IOJETS = IQ(LGENE+8)
      CALL MZBOOK(IXDIV,LTREE,LGENE,-LLTREE,'TREE',0,0,NP*LENT,IOTREE,0)
      CALL MZBOOK(IXDIV,LJETS,LGENE,-LLJETS,'JETS',0,0,NJ*LENJ,IOJETS,0)
      IF (NWXTRA.GT.0) THEN
        CALL MZBOOK(IXDIV,LXTRA,LGENE,-LLXTRA,'XTRA',0,0,NWXTRA,3,0)
        CALL UCOPY (RXTRA,Q(LXTRA+1),NWXTRA)
      ENDIF
      LTREE = LQ(LGENE-LLTREE)
      LJETS = LQ(LGENE-LLJETS)
*
*-- Loops over all LUND particles/jets and find the primary jets.
*   Primary jets have IABS(K2) = 500->588 and KH = 0.
*   Bank location 2 in the JETS temporarily holds the LUND particle numb
*
      DO 30 L=1,N
         K2A = IABS(K(L,2))
         IF (K2A.LT.500.OR.K2A.GT.588) GO TO 30
         KS = K(L,1)/10000
         KH = K(L,1)-KS*10000
         KH = MOD(KH,1000)
         IF (KH.NE.0) GO TO 30
         NJET = NJET + 1
         NADD = LJETS + (NJET-1)*LENJ
         DO 20 J=1,5
            Q(NADD+3+J) = P(L,J)
   20    CONTINUE
         IF (K(L,2).GE.500) IQ(NADD+1) = K(L,2)-500
         IF (K(L,2).LT.-500) IQ(NADD+1) = K(L,2)+500
         IQ(NADD+2) = L
   30 CONTINUE
      NJTOT = NJET
*
*-- Loops over all primary jets looking for primary fragments.
*   These have K1 = number of primary jet.
*   Bank location 3 in the TREE bank temporarily holds the LUND particle
*
      NJJ = NJET
      IF (NJET.EQ.0) NJJ=1
*
      DO 80 NJ=1,NJJ
         IF(NJET.NE.0) THEN
            NUMJET = IQ(LJETS+(NJ-1)*LENJ+2)
            IQ(LJETS+(NJ-1)*LENJ+2) = 0
         ENDIF
*
         DO 70 L=1,N
            KS = K(L,1)/10000
            KH = K(L,1)-KS*10000
            KH = MOD(KH,1000)
            K2A = IABS(K(L,2))
*   Skip if primary jet.
            IF (K2A.GE.500.AND.K2A.LE.588.AND.KH.EQ.0) GO TO 70
*   Special case of photon in onium decays or single particles.
            IF (KH.EQ.0.AND.NJ.EQ.1) GO TO 40
*   Skip if parent is not this jet or there are no jets.
            IF (NJET.EQ.0.OR.KH.NE.NUMJET) GO TO 70
*   Special case if non primary jet.
            IF (K2A.GE.500.AND.K2A.LE.588) GO TO 60
   40       CONTINUE
*
            NPRIM = NPRIM + 1
            NADD = LTREE + (NPRIM-1)*LENT
            DO 50 J=1,5
               Q(NADD+10+J) = P(L,J)
   50       CONTINUE
            Q(NADD+10+6) = LUCHGE(K(L,2))/3
            IQ(NADD+3) = L
            IQ(NADD+1) = K(L,2)
            IQ(NADD+6) = NJ
            IF (KH.EQ.0) IQ(NADD+6) = 0
            IQ(NADD+9) = 1
            IF (LUCHGE(K(L,2))/3.EQ.0) THEN
               IQ(NADD+10) = 0
            ELSE
               IQ(NADD+10) = 1
            ENDIF
            GO TO 70
*
   60       CONTINUE
            WRITE (CHREP,1000) L
            CALL REPORT ('GOLINT',1,'ERROR')
   70    CONTINUE
   80 CONTINUE
*
      NGEN = NPRIM
*
*-- Goes through each particle so far in the tree and looks for its
*-- decay products.
*
      NP = 0
   90 CONTINUE
      NP = NP + 1
      LPAR = IQ(LTREE+(NP-1)*LENT+3)
      IQ(LTREE+(NP-1)*LENT+3) = 0
      LL = LPAR + 1
      NSEC = 0
      IF (LL.GE.N) GO TO 170
      DO 160 L=LL,N
         KS = K(L,1)/10000
         KH = K(L,1)-KS*10000
         KH = MOD(KH,1000)
         K2A = IABS(K(L,2))
*   Skip if primary jet.
         IF (K2A.GE.500.AND.K2A.LE.588.AND.KH.EQ.0) GO TO 160
*   Skip if parent not this particle.
         IF (KH.NE.LPAR) GO TO 160
*   Special case if non primary jet.
         IF (K2A.GE.500.AND.K2A.LE.588) GO TO 110
         NSEC = NSEC + 1
         NGEN = NGEN + 1
         NADD = LTREE + (NP-1)*LENT
         IF (NSEC.EQ.1) IQ(NADD+3) = NGEN
         IF (NSEC.EQ.1) IQ(NADD+10) = -1
         IQ(NADD+4) = IQ(NADD+4) + 1
         NADD = LTREE + (NGEN-1)*LENT
         DO 100 J=1,5
            Q(NADD+10+J) = P(L,J)
  100    CONTINUE
         Q(NADD+10+6) = LUCHGE(K(L,2))/3
         IQ(NADD+1) = K(L,2)
         IQ(NADD+2) = NP
         IQ(NADD+3) = L
         IQ(NADD+6) = IQ(LTREE+(NP-1)*LENT+6)
         IQ(NADD+9) = 2
         IF (LUCHGE(K(L,2))/3.EQ.0) THEN
            IQ(NADD+10) = 0
         ELSE
            IQ(NADD+10) = 1
         ENDIF
         GO TO 160
*
*   Secondary jet found.
*
  110    CONTINUE
         NSJET = NSJET + 1
         NJTOT = NJTOT + 1
         NADD = LJETS+(NJTOT-1)*LENJ
         DO 120 J=1,5
            Q(NADD+3+J) = P(L,J)
  120    CONTINUE
         IF (K(L,2).GE.500) IQ(NADD+1) = K(L,2)-500
         IF (K(L,2).LT.-500) IQ(NADD+1) = K(L,2)+500
         IQ(NADD+2) = NP
*   Now look for secondaries from this jet.
         LPAR2 = L
         NSEC2 = 0
         LL2 = L + 1
         DO 150 L2=LL2,N
            KS = K(L2,1)/10000
            KH = K(L2,1)-KS*10000
            KH = MOD(KH,1000)
            K2A = IABS(K(L2,2))
*   Skip if primary jet.
            IF (K2A.GE.500.AND.K2A.LE.588.AND.KH.EQ.0) GO TO 150
*   Skip if parent is not this jet.
            IF (KH.NE.LPAR2) GO TO 150
*   Special case if non primary jet.
            IF (K2A.GE.500.AND.K2A.LE.588) GO TO 140
            NSEC = NSEC + 1
            NSEC2 = NSEC2 + 1
            NGEN = NGEN + 1
            NADD = LTREE + (NP-1)*LENT
            IF (NSEC.EQ.1) IQ(NADD+3) = NGEN
            IF (NSEC.EQ.1) IQ(NADD+10) = -1
            IF (NSEC2.EQ.1) IQ(LJETS+(NJTOT-1)*LENJ+3) = NGEN
            IQ(NADD+4) = IQ(NADD+4) + 1
            NADD = LTREE + (NGEN-1)*LENT
            DO 130 J=1,5
               Q(NADD+10+J) = P(L2,J)
  130       CONTINUE
            Q(NADD+10+6) = LUCHGE(K(L2,2))/3
            IQ(NADD+1) = K(L2,2)
            IQ(NADD+2) = NP
            IQ(NADD+3) = L2
            IQ(NADD+6) = IQ(LTREE+(NP-1)*LENT+6)
            IQ(NADD+9) = 2
            IF (LUCHGE(K(L2,2))/3.EQ.0) THEN
               IQ(NADD+10) = 0
            ELSE
               IQ(NADD+10) = 1
            ENDIF
            GO TO 150
*
  140       CONTINUE
            WRITE (CHREP,1100) L2
            CALL REPORT ('GOLINT',2,'ERROR')
  150    CONTINUE
  160 CONTINUE
  170 CONTINUE
*
      IF (NP.LT.NGEN) GO TO 90
*
      IQ(LGENE+1) = NGEN
      IQ(LGENE+2) = NPRIM
      IQ(LGENE+3) = NJET
      IQ(LGENE+4) = NSJET
*
*-- Calls GOLPDG to convert from Lund to PDG particle codes.
*
      CALL GOLPDG
*
 1000 FORMAT('Jet',I4,' is a fragmentation jet from a primary jet')
 1100 FORMAT('Jet',I4,' is a jet from a decay jet')
      END
+DECK,GOLPDG.
      SUBROUTINE GOLPDG
*.
*...GOLPDG changes tree particle codes from Lund to Particle Data Group.
*.
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.18
*. CREATED   : 21-Feb-89
*. LAST MOD  :  2-Feb-89
*.
*. Modification Log.
*.  2-Feb-89   S.L.Lloyd    ISIGN-->JSIGN
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,GCBANK.
+SEQ,LINKRA.
+SEQ,RCREP.
*
      INTEGER IPDGJ(0:6),IPDG1(90),IPDG2(9),IPDG3(9),IPDG4(34),
     +        IPDG5(16),IPDG6(36)
      INTEGER LGENE,LTREE,LJETS,NGEN,NJET,NSJET,LENT,LENJ,NADD,
     +        ICODE,JSIGN,N
      DATA IPDGJ/21, 2, 1, 3, 4, 5, 6/
      DATA IPDG1/  22,  23,  24,  25,   0,   0,  11,  12,  13,  14,
     +             15,  16,  17,  18,   0,   0, 211, 321, 311, 421,
     +            411, 431, 111, 221, 331, 441, 213, 323, 313, 423,
     +            413, 433, 113, 223, 333, 443, 310, 130,   0,   0,
     +           2212,2112,3222,3212,3112,3322,3312,4222,4212,4112,
     +           4322,4312,4332,4422,4412,4432,3122,4122,4232,4132,
     +           2224,2214,2114,1114,3224,3214,3114,3324,3314,3334,
     +           4224,4214,4114,4324,4314,4334,4424,4414,4434,4444,
     +              0,   0, 551, 661,   0,   0, 553, 663,   0,   0/
      DATA IPDG2/-521,-511,-531,-541, 621, 611, 631, 641, 651/
      DATA IPDG3/-523,-513,-533,-543, 623, 613, 633, 643, 653/
      DATA IPDG4/5222,5212,5112,5322,5312,5332,5422,5412,5432,5442,
     +           5522,5512,5532,5542,6222,6212,6112,6322,6312,6332,
     +           6422,6412,6432,6442,6522,6512,6532,6542,6552,6622,
     +           6612,6632,6642,6652/
      DATA IPDG5/5122,5232,5132,5422,5412,5432,6122,6232,6132,6422,
     +           6412,6432,6522,6512,6532,6542/
      DATA IPDG6/5224,5214,5114,5324,5314,5334,5424,5414,5434,5444,
     +           5524,5514,5534,5544,5554,6224,6214,6114,6324,6314,
     +           6334,6424,6414,6434,6444,6524,6514,6534,6544,6554,
     +           6624,6614,6634,6644,6654,6664/
*
      LGENE = LQ(LMC-1)
      IF (LGENE.LE.0) GO TO 999
      LTREE = LQ(LGENE-1)
      LJETS = LQ(LGENE-2)
*
      NGEN  = IQ(LGENE+1)
      NJET  = IQ(LGENE+3)
      NSJET = IQ(LGENE+4)
      LENT  = IQ(LGENE+5)
      LENJ  = IQ(LGENE+6)
*
*-- Loops over all partons, changing u,d,g to Particle Data Group codes.
*
      DO 10 N=1,NJET+NSJET
        NADD = LJETS + (N-1)*LENJ
        ICODE = ABS(IQ(NADD+1))
        JSIGN = SIGN(1,IQ(NADD+1))
        IF (ICODE.LT.0.OR.ICODE.GT.6) THEN
          WRITE (CHREP,1001) IQ(NADD+1)
          CALL REPORT ('GOLPDG',1,'ERROR')
          IQ(NADD+1) = 0
        ELSE
          IQ(NADD+1) = JSIGN*IPDGJ(ICODE)
        ENDIF
   10 CONTINUE
*
*-- Loops over all particles in the tree,
*-- changing from Lund to Particle Data Group codes.
*
      DO 20 N=1,NGEN
        NADD = LTREE + (N-1)*LENT
        ICODE = ABS(IQ(NADD+1))
        JSIGN = SIGN(1,IQ(NADD+1))
*
        IF (ICODE.GE.1.AND.ICODE.LE.90) THEN
          IQ(NADD+1) = JSIGN*IPDG1(ICODE)
        ELSE IF (ICODE.GE.101.AND.ICODE.LE.109) THEN
          IQ(NADD+1) = JSIGN*IPDG2(ICODE-100)
        ELSE IF (ICODE.GE.123.AND.ICODE.LE.131) THEN
          IQ(NADD+1) = JSIGN*IPDG3(ICODE-122)
        ELSE IF (ICODE.GE.145.AND.ICODE.LE.178) THEN
          IQ(NADD+1) = JSIGN*IPDG4(ICODE-144)
        ELSE IF (ICODE.GE.241.AND.ICODE.LE.256) THEN
          IQ(NADD+1) = JSIGN*IPDG5(ICODE-240)
        ELSE IF (ICODE.GE.293.AND.ICODE.LE.328) THEN
          IQ(NADD+1) = JSIGN*IPDG6(ICODE-292)
        ELSE
          WRITE (CHREP,1002) IQ(NADD+1)
          CALL REPORT ('GOLPDG',2,'ERROR')
          IQ(NADD+1) = 0
        ENDIF
   20 CONTINUE
*
  999 CONTINUE
*
 1001 FORMAT ('Unknown Lund parton code ',I8)
 1002 FORMAT ('Unknown Lund particle code ',I8)
*
      END
+DECK,GOOOUT.
      SUBROUTINE GOOOUT(CHNAME,INEW)
*.
*...GOOOUT   Open/close output files for GOPAL
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 20-Dec-89
*. LAST MOD  : 12-Jan-95
*.
*. Modification Log.
*. 12-Jan-95   C.P.Ward      Treat DECS, QMVAOS as VAX
*. 30-May-92   D.R.Ward      Implement 'L' option?
*. 23-May-92   D.Lellouch    OPEN statement different on IBMT RISC
*.  8-Jan-92   D.R.Ward      Implement Ascii output
*.  3-Jan-92   D.R.Ward      Implement internal file definition
*. 28-Sep-90   D.R.Ward      Appending doesn't work for exchange mode.
*. 17-Apr-90   J.N.Banks     Apollo corrections
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GOFILE.
+SEQ,RCREP.
+SELF,IF=VAX.
      INCLUDE '($FORIOSDEF)'
+SELF,IF=DECS,QMAVOS.
      INCLUDE '/usr/include/foriosdef.f'
+SELF
      CHARACTER*(*) CHNAME
      CHARACTER*4   CHOPT
      INTEGER JJJ,JUCOMP,INEW,IOSTAT,INDEX,NTRY
      EXTERNAL JUCOMP
      CHARACTER*4 CHNAM1(4)
      INTEGER II,I,KILROY
      DATA KILROY/0/
      DATA CHNAM1/'DAT ','DST ','CON ','PRO '/
*
      IF(KILROY.EQ.0) THEN
         DO 90 I=1,MFILE
            LUOPEN(I)=.FALSE.
            LUEVER(I)=.FALSE.
  90     CONTINUE
         KILROY=1
      ENDIF
*
*     Open (or reopen) Raw Data, PROD, DST and ROpe Constants outputs...
*
      INEW=1
      NTRY=0
      II=0
      DO 10 I=1,4
         IF (CHNAME(1:3).EQ.CHNAM1(I)(1:3)) II=I
 10   CONTINUE
*
      JJJ=JUCOMP(CHNAME,IONAME,NFILE)
      IF(JJJ.EQ.0) THEN
         CHREP='Called for undefined stream '//CHNAME
         CALL REPORT('GOOOUT',1,'W')
         GO TO 30
      ENDIF
      IF(LUOPEN(JJJ)) GO TO 30
      LUOPEN(JJJ)=.TRUE.
      CALL UHTOC(IOFCHO(JJJ),4,CHOPT,4)
      IF(INDEX(CHOPT,'L').NE.0) GO TO 30
      IF(INDEX(CHOPT,'X').NE.0) THEN
*** Exchange mode ***
         INEW=1
+SELF,IF=VAX,DECS,QMVAOS.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
*  Tape only
         IF(INDEX(CHOPT,'T').NE.0) THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',RECORDTYPE='FIXED',
     +        RECL=IOLREC(JJJ),BLOCKSIZE=4*IOLREC(JJJ),
     +        FORM='UNFORMATTED',IOSTAT=IOSTAT)
            LUEVER(JJJ)=.TRUE.
         ENDIF
*  Disk -
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',RECORDTYPE='FIXED',
     +        RECL=IOLREC(JJJ),BLOCKSIZE=4*IOLREC(JJJ),
     +        FORM='UNFORMATTED',IOSTAT=IOSTAT)
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',RECORDTYPE='FIXED',
     +        RECL=IOLREC(JJJ),BLOCKSIZE=4*IOLREC(JJJ),
     +        FORM='UNFORMATTED',IOSTAT=IOSTAT,FILE=IOFNAM(JJJ))
         ENDIF
         LUEVER(JJJ)=.TRUE.
+SELF,IF=APOLLO,SUN,HPUX.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',
     +         RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +         RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
         ENDIF
         LUEVER(JJJ)=.TRUE.
+SELF,IF=IBMRT.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',
     +          FORM='UNFORMATTED')
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +          FORM='UNFORMATTED')
         ENDIF
         LUEVER(JJJ)=.TRUE.
+SELF,IF=SGI.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=8100
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',
     +         RECL=IOLREC(JJJ),FORM='UNFORMATTED')
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +         RECL=IOLREC(JJJ),FORM='UNFORMATTED')
         ENDIF
         LUEVER(JJJ)=.TRUE.
+SELF.
      ELSEIF(INDEX(CHOPT,'A').NE.0) THEN
*** Ascii mode ***
         INEW=1
+SELF,IF=VAX,DECS,QMVAOS.
*  Disk; APPEND unless first ever call and not in multicpu mode.
         IF(JUCOMP('RUNI',IONAME,NFILE).EQ.0 .AND. .NOT.LUEVER(JJJ))
     +                      THEN
            INEW=1
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='FORMATTED')
            ELSE
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='FORMATTED',
     +              FILE=IOFNAM(JJJ))
            ENDIF
            LUEVER(JJJ)=.TRUE.
            GO TO 30
         ENDIF
         LUEVER(JJJ)=.TRUE.
  89     IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='OLD',FORM='FORMATTED',
     +        ACCESS='APPEND',IOSTAT=IOSTAT)
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='OLD',FORM='FORMATTED',
     +        ACCESS='APPEND',IOSTAT=IOSTAT,FILE=IOFNAM(JJJ))
         ENDIF
         IF(IOSTAT.EQ.FOR$IOS_FILNOTFOU) THEN
            INEW=1
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='FORMATTED')
            ELSE
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='FORMATTED',
     +              FILE=IOFNAM(JJJ))
            ENDIF
         ELSEIF(IOSTAT.EQ.FOR$IOS_UNIALROPE .OR.
     +          IOSTAT.EQ.FOR$IOS_OPEFAI)    THEN
            NTRY=NTRY+1
+SELF,IF=VAX.
            CALL WAIT_2SEC
+SELF,IF=DECS,QMVAOS.
            CALL SLEEP(2)
+SELF,IF=VAX,DECS,QMVAOS.
            IF(NTRY.LT.1000) GO TO 89
            CHREP='Failed to open o/p unit'
            CALL REPORT('GOOOUT',3,'C')
         ENDIF
+SELF,IF=APOLLO,SUN,HPUX,IBMRT,SGI,DECS,QMVAOS.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=80
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='FORMATTED')
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +           FORM='FORMATTED')
         ENDIF
         LUEVER(JJJ)=.TRUE.
+SELF.
      ELSE
*** Native mode ***
+SELF,IF=VAX,DECS,QMVAOS.
         INEW=0
*  Tape only
         IF(INDEX(CHOPT,'T').NE.0) THEN
            INEW=1
            OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='UNFORMATTED')
            LUEVER(JJJ)=.TRUE.
            GO TO 30
         ENDIF
*  Disk; APPEND unless first ever call and not in multicpu mode.
         IF(JUCOMP('RUNI',IONAME,NFILE).EQ.0 .AND. .NOT.LUEVER(JJJ))
     +                      THEN
            INEW=1
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='UNFORMATTED')
            ELSE
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='UNFORMATTED',
     +              FILE=IOFNAM(JJJ))
            ENDIF
            LUEVER(JJJ)=.TRUE.
            GO TO 30
         ENDIF
         LUEVER(JJJ)=.TRUE.
  81     IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='OLD',FORM='UNFORMATTED',
     +        ACCESS='APPEND',IOSTAT=IOSTAT)
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='OLD',FORM='UNFORMATTED',
     +        ACCESS='APPEND',IOSTAT=IOSTAT,FILE=IOFNAM(JJJ))
         ENDIF
         IF(IOSTAT.EQ.FOR$IOS_FILNOTFOU) THEN
            INEW=1
            IF(IOFNAM(JJJ).EQ.'    ') THEN
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='UNFORMATTED')
            ELSE
               OPEN(IOUNIT(JJJ),STATUS='NEW',FORM='UNFORMATTED',
     +              FILE=IOFNAM(JJJ))
            ENDIF
         ELSEIF(IOSTAT.EQ.FOR$IOS_UNIALROPE .OR.
     +          IOSTAT.EQ.FOR$IOS_OPEFAI)    THEN
            NTRY=NTRY+1
+SELF,IF=VAX.
            CALL WAIT_2SEC
+SELF,IF=DECS,QMVAOS.
            CALL SLEEP(2)
+SELF,IF=VAX,DECS,QMVAOS.
            IF(NTRY.LT.1000) GO TO 81
            CHREP='Failed to open o/p unit'
            CALL REPORT('GOOOUT',3,'C')
         ENDIF
+SELF,IF=APOLLO,SUN,HPUX.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=2440
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',
     +      RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +      RECL=4*IOLREC(JJJ),FORM='UNFORMATTED')
         ENDIF
         INEW=1
+SELF,IF=IBMRT.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=2440
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',
     +      FORM='UNFORMATTED')
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +      FORM='UNFORMATTED')
         ENDIF
         INEW=1
+SELF,IF=SGI.
         IF(IOLREC(JJJ).EQ.0) IOLREC(JJJ)=2440
         IF(IOFNAM(JJJ).EQ.'    ') THEN
            OPEN(IOUNIT(JJJ),STATUS='NEW',
     +      RECL=IOLREC(JJJ),FORM='UNFORMATTED')
         ELSE
            OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +      RECL=IOLREC(JJJ),FORM='UNFORMATTED')
         ENDIF
         INEW=1
+SELF.
      ENDIF
  30  CONTINUE
      RETURN
      END
+DECK,GOCOUT.
      SUBROUTINE GOCOUT(CHNAME)
*.
*...GOCOUT   Close output files for GOPAL (VAX only)
*.
*. COMMON    :
*. SEQUENCE  : GOFILE RCREP
*. CALLS     :
*. CALLED    : GUOUT  UGLAST
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : ??
*. LAST MOD  : 12-Jan-95
*.
*. Modification Log.
*. 12-Jan-95  C.P.Ward  Treat DECS, QMAVOS as VAX.
*. 12-May-94  C.P.Ward  Do not close A format files.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GOFILE.
      CHARACTER*4 CHOPT
      CHARACTER*(*) CHNAME
      INTEGER JJJ,JUCOMP
      EXTERNAL JUCOMP
*
      JJJ=JUCOMP(CHNAME,IONAME,NFILE)
      IF(JJJ.EQ.0) THEN
         CHREP='Called for undefined stream '//CHNAME
         CALL REPORT('GOCOUT',1,'W')
         GO TO 40
      ENDIF
      CALL UHTOC(IOFCHO(JJJ),4,CHOPT,4)
*  Close (only for disk).
+SELF,IF=VAX,DECS,QMVAOS.
      IF(INDEX(CHOPT,'T').EQ.0 .AND. INDEX(CHOPT,'X').EQ.0 .AND.
     +   INDEX(CHOPT,'A').EQ.0) THEN
         LUOPEN(JJJ)=.FALSE.
         CLOSE(IOUNIT(JJJ))
      ENDIF
+SELF.
  40  CONTINUE
      RETURN
      END
+DECK,GOPRIN.
      SUBROUTINE GOPRIN
*.
*...GOPRIN   Routine to print constants in GEANT banks.
*.
*.
*. COMMON    :
*. SEQUENCE  : GCLIST
*. CALLS     : GPRINT UCTOH
*. CALLED    : UGINIT
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*.
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  :  9-Jan-91
*.
*. Modification Log.
*.  9-Jan-91   D.R.Ward      Fix PRIN 'SETS'
*.  4-Nov-88   D.R.Ward      Mods for GEANT312
*. 25-Apr-88   D.R.Ward      Strong typing
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER IJTEST,IUCOMP
      EXTERNAL IUCOMP
+SEQ,GCLIST
*
*-- Examine the options specified on the PRIN data card.
*-- The following data structures may be printed.
*--
*--       PART   The particle codes.
*--       MATE   The properties of the materials of OPAL.
*--       TMED   The parameters of the tracking media.
*--       SETS   The detectors and their storage schemes.
*--       ROTM   The rotation matrices defining the OPAL geometry.
*--       VOLU   The volumes used in the construction of OPAL.
*--
      IF(NPRIN.LE.0)GO TO 10
      CALL UCTOH('PART',IJTEST,4,4)
      IF(IUCOMP(IJTEST,LPRIN,NPRIN).NE.0)CALL GPRINT('PART',0)
      CALL UCTOH('MATE',IJTEST,4,4)
      IF(IUCOMP(IJTEST,LPRIN,NPRIN).NE.0)CALL GPRINT('MATE',0)
      CALL UCTOH('TMED',IJTEST,4,4)
      IF(IUCOMP(IJTEST,LPRIN,NPRIN).NE.0)CALL GPRINT('TMED',0)
      CALL UCTOH('SETS',IJTEST,4,4)
*drw  IF(IUCOMP(IJTEST,LPRIN,NPRIN).NE.0)CALL GPRINT('SETS','*   ')
      IF(IUCOMP(IJTEST,LPRIN,NPRIN).NE.0)CALL GPSETS('*   ','*   ')
      CALL UCTOH('ROTM',IJTEST,4,4)
      IF(IUCOMP(IJTEST,LPRIN,NPRIN).NE.0)CALL GPRINT('ROTM',0)
      CALL UCTOH('VOLU',IJTEST,4,4)
      IF(IUCOMP(IJTEST,LPRIN,NPRIN).NE.0)CALL GPRINT('VOLU',0)
*
   10 RETURN
      END
+DECK,GOPSTA
      SUBROUTINE GOPSTA
*.
*...GOPSTA   Print out statistics at the end of the run.
*.
*. COMMON    : GOSTAT
*. SEQUENCE  : GCTRAK GCUNIT
*. CALLS     : GFPART GMAIL
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 27-Nov-87
*. LAST MOD  :  3-Dec-97
*.
*. Modification Log.
*.  3-Dec-97 M.Schroder     Remove extraneous parentheses
*.  7-May-90   D.R.Ward      Extra sig figs.
*.  6-May-88   D.R.Ward      Handle multiple primary vertices.
*. 25-Apr-88   D.R.Ward      Strong typing
*. 18-Dec-87   D.R.Ward      Tidy up formatting
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,GCTRAK.
+SEQ,GCUNIT.
+SEQ,GOSTAT.
+SEQ,GOFLAG.
      CHARACTER*20 NAPART
      INTEGER I,ITRTYP,NUBUF,J,II,NSECV,JJ
      REAL    UBUF(20),AMASS,CHARGE,TLIFE
*
      CHMAIL='1================================================= '
      CALL GMAIL(1,1)
      CHMAIL=' Statistics on contents of the KINE banks ...  '
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' Number of events processed ='',I6)') NEVTS
      CALL GMAIL(0,0)
      IF(NEVTS.EQ.0) GO TO 70
      WRITE(CHMAIL,FMT='('' Average number of "primary" vertices '//
     +'from the event generator ='',F6.2)') FLOAT(MVPRIM)/NEVTS
      CALL GMAIL(1,1)
      CHMAIL=' <<<< particles at the primary '//
     +'(event generator) vertices >>>       '
      CALL GMAIL(0,1)
      CHMAIL='                               Momentum (p) in GeV/c '
      CALL GMAIL(0,0)
      CHMAIL='                               -------------------  <n>'
     +//' in momentum bins  --------------------------'
      CALL GMAIL(0,0)
      CHMAIL=' Particle   <n>/event    <p>    <.03  .03-.1   .1-.2   '
     +//'.2-.5   .5-1.   1.-2.   2.-5.   5.-10   10-20     >20'
      CALL GMAIL(0,0)
      CHMAIL=' ========   =========   ====    ====  ======   =====   '
     +//'=====   =====   =====   =====   =====   =====     === '
      CALL GMAIL(0,0)
      DO 10 I=1,50
         IF(SKIN(I,1,1).EQ.0.) GO TO 10
         CALL GFPART(I,NAPART,ITRTYP,AMASS,CHARGE,TLIFE,UBUF,NUBUF)
         WRITE(CHMAIL,FMT='(1X,A12,F8.3,F7.3,10F8.3)') NAPART(1:12)
     +   ,SKIN(I,1,1)/NEVTS,SKIN(I,2,1)/SKIN(I,1,1), (SKIN(I,J,1)
     +   /NEVTS,J=3,12)
         CALL GMAIL(0,0)
   10 CONTINUE
      NSECV=0
      DO 20 II=1,NVO
   20 NSECV=NSECV+KVOLU(II,2)
      IF(NSECV.EQ.0) GO TO 60
      WRITE(CHMAIL,FMT=
     +'(''  Number of secondary (GEANT) vertices stored/event'',F7.2)')
     +FLOAT(NSECV)/NEVTS
      CALL GMAIL(2,0)
      CHMAIL='  --------------------------------------------'
      CALL GMAIL(0,0)
      CHMAIL='  Statistics by mechanism:'
      CALL GMAIL(1,0)
      JJ=1
      CHMAIL=' '
      DO 30 II=1,30
         IF(KMEC(II).EQ.0) GO TO 30
         WRITE(CHMAIL(JJ:JJ+14),FMT='(4X,A4,F7.3)') NAMEC(II), FLOAT
     +   (KMEC(II))/NEVTS
         JJ=JJ+15
         IF(JJ.LT.100) GO TO 30
         CALL GMAIL(0,0)
         JJ=1
         CHMAIL=' '
   30 CONTINUE
      CALL GMAIL(0,0)
      CHMAIL='  Statistics by volume:   '
      CALL GMAIL(1,0)
      JJ=1
      CHMAIL=' '
      DO 40 II=1,NVO
         WRITE(CHMAIL(JJ:JJ+14),FMT='(4X,A4,F7.3)') KVOLU(II,1), FLOAT
     +   (KVOLU(II,2))/NEVTS
         JJ=JJ+15
         IF(JJ.LT.100) GO TO 40
         CALL GMAIL(0,0)
         JJ=1
         CHMAIL=' '
   40 CONTINUE
      CALL GMAIL(0,0)
      CHMAIL='  <<<  permanently stored (non-stack) secondary' //
     +' particles >>>  '
      CALL GMAIL(2,1)
      CHMAIL='                               Momentum (p) in GeV/c '
      CALL GMAIL(0,0)
      CHMAIL='                               -------------------  <n>'
     +//' in momentum bins  --------------------------'
      CALL GMAIL(0,0)
      CHMAIL=' Particle   <n>/event    <p>    <.03  .03-.1   .1-.2   '
     +//'.2-.5   .5-1.   1.-2.   2.-5.   5.-10   10-20     >20'
      CALL GMAIL(0,0)
      CHMAIL=' ========   =========   ====    ====  ======   =====   '
     +//'=====   =====   =====   =====   =====   =====     === '
      CALL GMAIL(0,0)
      DO 50 I=1,50
         IF(SKIN(I,1,2).EQ.0.) GO TO 50
         CALL GFPART(I,NAPART,ITRTYP,AMASS,CHARGE,TLIFE,UBUF,NUBUF)
         WRITE(CHMAIL,FMT='(1X,A12,F8.3,F7.3,10F8.3)') NAPART(1:12)
     +   ,SKIN(I,1,2)/NEVTS,SKIN(I,2,2)/SKIN(I,1,2), (SKIN(I,J,2)
     +   /NEVTS,J=3,12)
         CALL GMAIL(0,0)
   50 CONTINUE
   60 IF(NDIGI.EQ.0) GO TO 70
      CHMAIL='1================================================= '
      CALL GMAIL(1,1)
      CHMAIL=' Statistics on contents of the raw data banks ...  '
      CALL GMAIL(0,1)
      WRITE(CHMAIL,FMT='('' Number of events processed ='',I6)') NEVTS
      CALL GMAIL(0,0)
      IF(NEVTS.EQ.0) GO TO 70
      WRITE(CHMAIL,FMT='('' SI:       <ladders>/event ='',F7.1)') SDET
     +(1,15)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''        <strips hit>/event ='',F7.1)') SDET
     +(2,15)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' CV:  <axial digits>/event ='',F7.1)') SDET
     +(1,1)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''     <stereo digits>/event ='',F7.1)') SDET
     +(2,1)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' CJ:        <digits>/event ='',F7.0)') SDET
     +(1,2)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='('' CZ:        <digits>/event ='',F7.1)') SDET
     +(1,3)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='('' TB:      <bars hit>/event ='',F7.1)') SDET
     +(1,4)/NEVTS
      CALL GMAIL(1,0)
      IF(SDET(1,4).NE.0.) WRITE(CHMAIL,FMT=
     +'(''        <pulse height>/bar ='',F7.1)') SDET(2,4)/SDET(1,4)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' PB:    <u clusters>/event ='',F7.1)') SDET
     +(1,5)/NEVTS
      CALL GMAIL(1,0)
      IF(SDET(1,5).NE.0.) WRITE(CHMAIL,FMT=
     +'(''        <signal>/u-cluster ='',F7.1)') SDET(4,5)/SDET(1,5)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''        <v clusters>/event ='',F7.1)') SDET
     +(2,5)/NEVTS
      CALL GMAIL(1,0)
      IF(SDET(2,5).NE.0.) WRITE(CHMAIL,FMT=
     +'(''        <signal>/v-cluster ='',F7.1)') SDET(5,5)/SDET(2,5)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''        <w clusters>/event ='',F7.1)') SDET
     +(3,5)/NEVTS
      CALL GMAIL(1,0)
      IF(SDET(3,5).NE.0.) WRITE(CHMAIL,FMT=
     +'(''        <signal>/w-cluster ='',F7.0)') SDET(6,5)/SDET(3,5)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' EB:        <blocks>/event ='',F7.1)') SDET
     +(1,6)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''      <blocks>50MeV>/event ='',F7.1)') SDET
     +(2,6)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''      <energy (GeV)>/event ='',F7.2)') SDET
     +(3,6)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' PE: <big pad clust>/event ='',F7.1)') SDET
     +(1,7)/NEVTS
      CALL GMAIL(1,0)
      IF(SDET(1,7).NE.0.) WRITE(CHMAIL,FMT=
     +'(''     <signal>/big pad clus ='',F7.1)') SDET(6,7)/SDET(1,7)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''     <big strip clu>/event ='',F7.1)') SDET
     +(2,7)/NEVTS
      CALL GMAIL(0,0)
      IF(SDET(2,7).NE.0.) WRITE(CHMAIL,FMT=
     +'(''     <signal>/big strip cl ='',F7.1)') SDET(7,7)/SDET(2,7)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''     <big wire clus>/event ='',F7.1)') SDET
     +(3,7)/NEVTS
      CALL GMAIL(0,0)
      IF(SDET(3,7).NE.0.) WRITE(CHMAIL,FMT=
     +'(''     <signal>/big wire clu ='',F7.1)') SDET(8,7)/SDET(3,7)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''     <small pad clu>/event ='',F7.1)') SDET
     +(4,7)/NEVTS
      CALL GMAIL(0,0)
      IF(SDET(4,7).NE.0.) WRITE(CHMAIL,FMT=
     +'(''     <signal>/small wire c ='',F7.1)') SDET(9,7)/SDET(4,7)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''     <small str clu>/event ='',F7.1)') SDET
     +(5,7)/NEVTS
      CALL GMAIL(0,0)
      IF(SDET(5,7).NE.0.) WRITE(CHMAIL,FMT=
     +'(''     <signal>/small str cl ='',F7.1)') SDET(10,7)/SDET(5,7)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' EE:        <blocks>/event ='',F7.1)') SDET
     +(1,8)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''      <blocks>50MeV>/event ='',F7.1)') SDET
     +(2,8)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''      <energy (GeV)>/event ='',F7.2)') SDET
     +(3,8)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' HB:          <pads>/event ='',F7.1)') SDET
     +(1,9)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''            <strips>/event ='',F7.1)') SDET
     +(2,9)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''           <pC pads>/event ='',F7.1)') SDET
     +(3,9)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' HE:          <pads>/event ='',F7.1)') SDET
     +(1,10)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''            <strips>/event ='',F7.1)') SDET
     +(2,10)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''           <pC pads>/event ='',F7.1)') SDET
     +(3,10)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' HP:          <pads>/event ='',F7.1)') SDET
     +(1,11)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''            <strips>/event ='',F7.1)') SDET
     +(2,11)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='(''            <signal>/event ='',F7.2)') SDET
     +(3,11)/NEVTS
      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' MB:        <digits>/event ='',F7.1)') SDET
     +(1,12)/NEVTS
      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='('' ME:        <digits>/event ='',F7.1)') SDET
     +(1,13)/NEVTS
      CALL GMAIL(1,0)
      IF(SDET(1,13).NE.0.) THEN
         WRITE(CHMAIL,FMT='(''        <pulse height>/hit ='',F7.0)')
     +   SDET(2,13)/SDET(1,13)
         CALL GMAIL(0,0)
      ENDIF
      WRITE(CHMAIL,FMT='('' FD:   <catcher ADC>/event ='',F7.1)') SDET
     +(1,14)/NEVTS
***      CALL GMAIL(1,0)
      WRITE(CHMAIL,FMT='(''    <luminosity ADC>/event ='',F7.1)') SDET
     +(2,14)/NEVTS
***      CALL GMAIL(0,0)
      WRITE(CHMAIL,FMT='('' FD:  <calorim. ADC>/event ='',F7.1)') SDET
     +(5,14)/NEVTS
      CALL GMAIL(1,0)
   70 END
+DECK,GOPST2.
      SUBROUTINE GOPST2
*.
*...GOPST2 Print GOPAL statistics on times and event sizes.
*.
*.
*. COMMON    :
*. SEQUENCE  : ROBANK GCUNIT
*. CALLS     : GMAIL
*. CALLED    : UGLAST
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 12-Jan-90
*. LAST MOD  : 28-Sep-94
*.
*. Modification Log.
*. 28-Sep-94   C.P.Ward      Add TE
*. 26-Feb-91   D.R.Ward      Add SI
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,GCFLAG.
+SEQ,GOFLAG.
+SEQ,GCUNIT.
+SEQ,GOFILE.
+SEQ,RCREP.
      LOGICAL LWDATA,LWDST,LWPROD,LWDDST
      INTEGER J,JUCOMP
      EXTERNAL JUCOMP
      CHARACTER*2  CNAME(19),CNAM2(18),CNAM3(18)
      DATA CNAME/'SI','CV','CJ','CZ','TB','PB','EB','PE','EE','HT','HS',
     +           'HP','MB','ME','FD','TR','TT','FI','SC'/
      DATA CNAM3/'CV','CJ','CZ','TB','PB','EB','PE','EE','HT','HS','HP',
     +           'MB','ME','FD','TR','SI','SW','TE'/
      DATA CNAM2/'BP','CD','CO','TB','PB','EB','CP','PE','EE','HB','HE',
     +           'HP','MB','ME','FD','OP','SW','TE'/
*
      IF(LMCS.LE.0) GO TO 99
      CHMAIL='1Detailed timing of GOPAL run:'
      CALL GMAIL(1,0)
      CHMAIL=' ============================='
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' Time in initialization'',F7.2,''sec.'')')
     +     0.01*IQ(LMCS+2)
      CALL GMAIL(0,0)
      IF(IQ(LMCS+1).LE.0) GO TO 10
      WRITE(CHMAIL,'('' Time in kinematics    '',F7.2,''sec./event'')')
     +     (0.01*IQ(LMCS+3))/IQ(LMCS+1)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' Time in tracking      '',F7.2,''sec./event'')')
     +     (0.01*IQ(LMCS+4))/IQ(LMCS+1)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'(5X,9(A2,'':'',F6.2,1X))',ERR=3)
     +  (CNAM2(J),(0.01*IQ(LMCS+90+J))/IQ(LMCS+1),J=1,9)
   3  CALL GMAIL(0,0)
      WRITE(CHMAIL,'(5X,9(A2,'':'',F6.2,1X))',ERR=4)
     +  (CNAM2(J),(0.01*IQ(LMCS+90+J))/IQ(LMCS+1),J=10,18)
   4  CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' Time in digitization  '',F7.2,''sec./event'')')
     +     (0.01*IQ(LMCS+5))/IQ(LMCS+1)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'(5X,9(A2,'':'',F5.2,1X))',ERR=1)
     +  (CNAM3(J),(0.01*IQ(LMCS+10+J))/IQ(LMCS+1),J=1,9)
   1  CALL GMAIL(0,0)
      WRITE(CHMAIL,'(5X,9(A2,'':'',F5.2,1X))',ERR=2)
     +  (CNAM3(J),(0.01*IQ(LMCS+10+J))/IQ(LMCS+1),J=10,18)
   2  CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' Time in ROPEing       '',F7.2,''sec./event'')')
     +     (0.01*IQ(LMCS+7))/IQ(LMCS+1)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' Time in output        '',F7.2,''sec./event'')')
     +     (0.01*IQ(LMCS+6))/IQ(LMCS+1)
      CALL GMAIL(0,0)
  10  CONTINUE
      LWDATA=JUCOMP('DATO',IONAME,NFILE).GT.0
      LWPROD=JUCOMP('PROO',IONAME,NFILE).GT.0
      LWDST =JUCOMP('DSTO',IONAME,NFILE).GT.0
      LWDDST=JUCOMP('DDSO',IONAME,NFILE).GT.0
      IF(.NOT.(LWDATA.OR.LWPROD.OR.LWDST.OR.LWDDST)) GO TO 99
      CHMAIL=' Size of output data structures:'
      CALL GMAIL(2,0)
      CHMAIL=' ==============================='
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' Constants (RCO...)'',I7  ,'' words.'')')
     +          IQ(LMCS+31)
      CALL GMAIL(0,0)
      IF(IQ(LMCS+1).LE.0) GO TO 99
      IF(LWDATA) THEN
        WRITE(CHMAIL,'('' DATA output       '',I7  ,'' words/event'')')
     +     IQ(LMCS+32)/IQ(LMCS+1)
        CALL GMAIL(0,0)
      ENDIF
      IF(LWPROD) THEN
        WRITE(CHMAIL,'('' PROD output       '',I7  ,'' words/event'')')
     +     IQ(LMCS+33)/IQ(LMCS+1)
        CALL GMAIL(0,0)
      ENDIF
      IF(LWDDST) THEN
        WRITE(CHMAIL,'('' DDST  output      '',I7  ,'' words/event'')')
     +     IQ(LMCS+30)/IQ(LMCS+1)
        CALL GMAIL(0,0)
      ENDIF
      IF(LWDST ) THEN
        WRITE(CHMAIL,'('' DST  output       '',I7  ,'' words/event'')')
     +     IQ(LMCS+34)/IQ(LMCS+1)
        CALL GMAIL(0,0)
      ENDIF
      IF(LWDATA.OR.LWPROD.OR.LWDST.OR.LWDDST) THEN
        WRITE(CHMAIL,'('' EX structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+81)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'('' UT structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+82)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'('' TREE/JETS banks   '',I7  ,'' words/event'')')
     +     IQ(LMCS+35)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        IF(NCHEAT.NE.0) THEN
        WRITE(CHMAIL,'('' CHEAt banks       '',I7  ,'' words/event'')')
     +     IQ(LMCS+59)/IQ(LMCS+1)
          CALL GMAIL(0,0)
          WRITE(CHMAIL,'(5X,8(A2,'':'',I6  ,1X))',ERR=11)
     +    (CNAME(J),IQ(LMCS+59+J)/IQ(LMCS+1),J=1,8)
  11      CALL GMAIL(0,0)
          WRITE(CHMAIL,'(5X,8(A2,'':'',I6  ,1X))',ERR=12)
     +    (CNAME(J),IQ(LMCS+59+J)/IQ(LMCS+1),J=9,16)
  12      CALL GMAIL(0,0)
        ENDIF
        WRITE(CHMAIL,'('' DST structure     '',I7  ,'' words/event'')')
     +     IQ(LMCS+90)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'('' DD structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+89)/IQ(LMCS+1)
        CALL GMAIL(0,0)
      ENDIF
      IF(LWDATA.OR.LWPROD) THEN
        WRITE(CHMAIL,'('' Raw data(DA) banks'',I7  ,'' words/event'')')
     +     IQ(LMCS+83)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'(5X,8(A2,'':'',I6  ,1X))',ERR=13)
     +    (CNAME(J),IQ(LMCS+39+J)/IQ(LMCS+1),J=1,8)
  13    CALL GMAIL(0,0)
        WRITE(CHMAIL,'(5X,8(A2,'':'',I6  ,1X))',ERR=14)
     +    (CNAME(J),IQ(LMCS+39+J)/IQ(LMCS+1),J=9,16)
  14    CALL GMAIL(0,0)
      ENDIF
      IF(LWDATA) THEN
        WRITE(CHMAIL,'('' CD structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+84)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'('' EC structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+85)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'('' HC structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+86)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'('' MU structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+87)/IQ(LMCS+1)
        CALL GMAIL(0,0)
        WRITE(CHMAIL,'('' FO structure      '',I7  ,'' words/event'')')
     +     IQ(LMCS+88)/IQ(LMCS+1)
        CALL GMAIL(0,0)
      ENDIF
  99  END
+DECK,GOROPB,IF=-NOROPE.
      SUBROUTINE GOROPB
*.
*...GOROPB    Steer the ROPE xxBAT routines from GOPAL.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 14-Apr-88
*. LAST MOD  : 18-Jul-91
*.
*. Modification Log.
*. 18-Jul-91   D.R.Ward      Try to call OP before FI
*. 16-Jul-91   D.R.Ward      Add call to FIBAT
*. 17-Jun-91   D.R.Ward      Protect against usage of random numbers in ROPE.
*.  9-May-91   D.R.Ward      Fill header
*. 23-Apr-91   D.R.Ward      Check IFUPDT set
*.  7-Jan-91   D.R.Ward      Don't call SMGNRL if in NOCE mode.
*.  6-Aug-90   S.L.Lloyd     Fix bug
*.  5-Jul-90   D.R.Ward      Call SMGNRL
*.  7-Mar-90   D.R.Ward      Set IODVER if SMEAr mode
*. 25-Jun-89   J.Banks       Add call for ODPHYS for fast smear mode
*. 17-May-89   D.R.Ward      Call ROPBAT to handle ROPE processing
*. 26-Feb-89   D.R.Ward      Add calls to ROSUMM in SMEAr mode.
*. 15-Feb-89   D.R.Ward      Handle different SMEAr levels
*.  8-Feb-89   J.Banks       Call SMASSC for smear association
*.  6-Feb-89   D.R.Ward      Mods for ROPE306
*. 21-Dec-88   D.R.Ward      Decision on CE level moved to GOROPS
*. 27-Sep-88   D.R.Ward      Move GOHFL2 call
*. 26-Sep-88   D.R.Ward      Call xxDROP routines (as in ROPE305)
*.  9-Aug-88   J.Banks       Allow SM extrapolation
*.  2-Jun-88   D.R.Ward      Turn on CE/CA/AS
*. 30-May-88   R.J.Barlow    Add USBAT; test on logicals.
*. 17-May-88   D.R.Ward      Move setting of IRDEVT etc to REVBOK
*.  6-May-88   D.R.Ward      Test if input exists before calling ROPE ro
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,ROPAR.
+SEQ,ROBANK.
+SEQ,CRO.
+SEQ,CRVER.
+SEQ,RCNTRL.
+SEQ,GCFLAG.
+SEQ,GOLOGI.
+SEQ,ROCPAR.
+SEQ,ODPAR.
      LOGICAL LOK
      INTEGER NIMOV,NRMOV,JSEED(2),LFIRA
+SELF,IF=VAX.
*     For PE - else problems with linking order on VAX.
      EXTERNAL GDTOM
*     For CE
*DRW      EXTERNAL CETKSM,CEXTR
+SELF.
*
*
*-- First call some SMEA processors if appropriate.
*
      IF(.NOT.LSMCE .AND. LALLSM) CALL SMGNRL
      IF(LCDSM) THEN
         IF(LSMCE .OR. .NOT.LALLSM) THEN
            CALL SMCDOD('CT')
         ELSE
            CALL SMCDOD('OD')
         ENDIF
      ENDIF
      IF(LCALSM) THEN
         IF(LSMCE .OR. .NOT.LALLSM) THEN
            CALL SMCLRP
            LEM=LQ(LEC-LLEM)
            CALL SMMURP
          ELSE
            CALL SMCLOD
            CALL SMMUOD
         ENDIF
      ENDIF
*
      CALL UCOPY(IQ(LREV+1),IUHEAD,NUHMAX)
      IF(.NOT.LSMCE .AND. LALLSM) THEN
         IF(LCALSM) CALL SMASSC
         CALL ODPHYS
         CALL ROEVTY
         CALL ODSWRD('GNRL',1,JGEVTY,IQ(LREV+IIEVTY),NIMOV,0,0,NRMOV)
         CALL ROSUMM(IIFODC)
         CALL USBAT(0)
      ELSE
*-- Now ROPBAT should call all the ROPE processors we want, with any luck.
*-- But call FIBAT by hand first.  This allows us to copy the results
*-- (such as they are) into the REV bank before we get into USBAT.
*
         IRSTOP=0
         IFUPDT=1
         CALL GRNDMQ(JSEED(1),JSEED(2),1,'G')
         IF(IVOP.GT.0) CALL OPFCRO(LOK)
*         CALL FIBAT
*         IF(LDA.GT.0) THEN
*            LFIRA=LQ(LDA-LLFIRA)
*            IF(LFIRA.GT.0) THEN
*               IQ(LREV+IIFITY)=IQ(LFIRA+8)
*            ENDIF
*         ENDIF
         CALL ROPBAT
         CALL GRNDMQ(JSEED(1),JSEED(2),1,'S')
      ENDIF
*
      IF(IRDEBU.GT.0) CALL ODPEVT
*
      END
+DECK,GOROPF,IF=-NOROPE.
      SUBROUTINE GOROPF
*.
*...GOROPF    Steer the ROPE xxFIN routines from GOPAL.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 14-Apr-88
*. LAST MOD  : 29-Jan-99
*.
*. Modification Log.
*. 29-Jan-99   C.P.Ward      Add TEFIN
*. 11-Oct-94   C.P.Ward      Add LMFIN
*. 25-Jul-89   J.Banks       Use seperate HB,HE,HP banks in smear mode
*. 19-Jun-89   J.Banks       Add FDET in smear mode
*.  6-Jun-89   J.Banks       Call USFIN in smear mode
*. 19-May-89   D.R.Ward      Changes for SMEAr mode
*.  9-Feb-89   D.R.Ward      Call **FIN
*. 22-Jul-88   D.R.Ward      Call CEFIN
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GOLOGI.
+SEQ,ROBANK.
+SEQ,ROCPAR.
+SEQ,CRVER.
*
*     In SMEAr mode need to con ROSUMF into printing the statistics
*
      IF(LCDSM .AND. (LSMCE .OR. .NOT.LALLSM)) THEN
         IQ(LCDC+IIFCTC)=1
         IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
      ENDIF
      IF(LCALSM .AND. (LSMCE .OR. .NOT.LALLSM)) THEN
         IQ(LECC+IIFEMC)=1
         IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
         IQ(LHCC+IIFHBC)=1
         IQ(LHCC+IIFHEC)=2
         IQ(LHCC+IIFHPC)=3
         IQ(LRCO+IIFHCC)=IQ(LRCO+IIFHCC)+3
         IQ(LMUC+IIFMMC)=1
         IQ(LRCO+IIFMUC)=IQ(LRCO+IIFMUC)+1
         IQ(LRCO+IIFFOC)=1
         IQ(LFOC+IIFFDC)=IQ(LFOC+IIFFDC)+1
      ENDIF
      CALL ROSUMF
*
      IF(LALLSM .AND. .NOT. LSMCE) GO TO 999
      IF(IVCV.NE.0) CALL CVFIN
      IF(IVJC.NE.0) CALL JCFIN
      IF(IVCZ.NE.0) CALL CZFIN
      IF(IVCT.NE.0) CALL CTFIN
      IF(IVCX.NE.0) CALL CXFIN
      IF(IVSI.NE.0) CALL SIFIN
      IF(IVCS.NE.0) CALL CSFIN
      IF(IVDX.NE.0) CALL DXFIN
      IF(IVTB.NE.0) CALL TBFIN
      IF(IVTE.NE.0) CALL TEFIN
      IF(IVPB.NE.0) CALL PBFIN
      IF(IVPE.NE.0) CALL PEFIN
      IF(IVEB.NE.0) CALL EBFIN
      IF(IVEE.NE.0) CALL EEFIN
      IF(IVEM.NE.0) CALL EMFIN
      IF(IVHB.NE.0) CALL HBFIN
      IF(IVHE.NE.0) CALL HEFIN
      IF(IVHM.NE.0) CALL HMFIN
      IF(IVMB.NE.0) CALL MBFIN
      IF(IVME.NE.0) CALL MEFIN
      IF(IVMM.NE.0) CALL MMFIN
      IF(IVFD.NE.0) CALL FDFIN
      IF(IVSW.NE.0) CALL SWFIN
      IF(IVCE.NE.0) CALL CEFIN
      IF(IVDD.NE.0) CALL DDFIN
      IF(IVDC.NE.0) CALL DCFIN
      IF(IVOD.NE.0) CALL ODFIN
      IF(IVLL.NE.0) CALL LLFIN
      IF(IVLM.NE.0) CALL LMFIN
      IF(IVTR.NE.0) CALL TRFIN
      IF(IVFI.NE.0) CALL FIFIN
 999  CALL USFIN
*
      END
+DECK,GOROPI.
      SUBROUTINE GOROPI
*.
*...GOROPI    Perform ROPE initialization in GOPAL.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 14-Apr-88
*. LAST MOD  : 08-Dec-93
*.
*. Modification Log.
*. 08-Dec-93   C.P.Ward      Remove unused variables
*. 18-Oct-90   D.R.Ward      OC division not Contained
*. 23-Sep-89   D.R.Ward      Call REINIT
*. 17-Jul-89   D.R.Ward      Book OC division for future use.
*. 25-Feb-89   D.R.Ward      Use GOPAR
*.  9-Feb-88   S.Weisz       Call RBKRCO + other mods for ROPE306
*.  7-Feb-88   D.R.Ward      Call RBKSTA + other mods for ROPE306
*. 24-May-88   D.R.Ward      Lift DAC , MCCO; hang from RUNG
*. 17-May-88   D.R.Ward      Lift OD constants/statistics headers
*. 29-Apr-88   D.R.Ward      IXCONS, IROCON the same.
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER MINCON,MAXCON
+SEQ,ROBANK.
+SEQ,ROPAR,ROCPAR,ROSPAR.
+SEQ,GOPAR.
      INTEGER IXOCD
      COMMON/OCBANK/IXOCD
*
*-- Creates one long range division (reverse) to store ROPE statistics.
*
      MINCON=2000
      MAXCON=8*NZEBRA/10
      CALL MZDIV(IXSTOR,IROSTA,'R_STATIS',MINCON,MAXCON,'LRC')
      CALL MZDIV(IXSTOR,IXOCD ,'R_OPCAL ',MINCON,MAXCON,'LR')
      CALL MZXREF(IROSTA,IXSTOR+22,'C')
*
*-- Inside GOPAL we want ROPE to run in the same event/constants
*-- division as GEANT.
*
      IROCON=IXCONS
      IRODIV=IXDIV
*
*-- Lifts ZEBRA structure for ROPE constants (hangs from JRUNG-1)
*
      CALL MZBOOK(IROCON,LRCO,JRUNG,-1,'RCO ',NLRCO,NSRCO,NDRCO,
     +IORCO,0)
*
*-- Lift calibration constants header
      CALL MZBOOK(IROCON,LDAC,LRCO,-LLDAC,'DAC ',NLDAC,NSDAC,NDDAC,
     +IODAC,0)
*
*-- Book Statistics and Constant structure using ROPE routines.
*
      CALL RBKSTA
      CALL RBKTMP
      CALL RBKRCO
*
*     Initialize REPORT
*
      CALL REINIT
*
*-- Lift MC constants header
      CALL MZBOOK(IROCON,LMCC ,LEXC,-LLMC,'MCC ',NLMC,NSMC,NDMC,IOMC,0)
      END
+DECK,GOROPS,IF=-NOROPE.
      SUBROUTINE GOROPS
*.
*...GOROPS    Steer the ROPE xxSETR and xxINIT calls from GOPAL.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 14-Apr-88
*. LAST MOD  : 25-Jan-98
*.
*. Modification Log.
*. 25-Jan-98   S.Bentvelsen  Activate calls to the TE set (TE+MIPPLUG)
*. 12-Oct-95   C.P.Ward      Add calls to ROCHIN, HIINIT, HISETR
*. 12-Jun-95   C.P.Ward      Move call to DCINIT after ODINIT
*. 11-Jan-95   C.P.Ward      Declare OD SIW block
*. 11-Oct-94   C.P.Ward      Add LMINIT, LMSETR.
*. 21-Sep-94   C.P.Ward      CSINIT --> CSINIR to avoid conflict with COMIS.
*. 06-May-94   M.Redmond     Call RCPREP before RGETCA (for ROPE407).
*. 22-Dec-93   C.P.Ward      Set expt no. in IUHEAD.
*.  8-Dec-93   C.P.Ward      Remove unused variables.
*.  5-Mar-93   D.R.Ward      DC hooks
*. 29-Jul-92   D.R.Ward      Clean up CE interface
*. 21-Feb-92   C.Hawkes      Set IFUPDT before ROPTPR called
*. 13-Feb-92   A.Buijs       Change the dummy printout for init.
*.  6-Jan-92   D.R.Ward      Move RCASET call
*. 16-Sep-91   D.R.Ward      Initialize CX for CD SMear
*. 18-Jul-91   D.R.Ward      Call OPINIT
*. 22-Mar-91   D.R.Ward      Fix bug when both RERUN and CENTRAL cards selected
*. 15-Mar-91   D.R.Ward      Reorder CENTRAL processors
*. 25-Feb-91   D.R.Ward      Hooks for SI CS DX
*.  7-Mar-90   D.R.Ward      Set IODVER lest ODBAT not called (SMEAr/NODE mode)
*. 23-Feb-90   D.R.Ward      Declare OD TOF block
*. 19-Feb-90   D.R.Ward      Declare RFUSER to be the FFUSER routine
*.  4-Jan-90   D.R.Ward      Declare FFUSER to be the FFUSER routine
*.  4-Jan-90   D.R.Ward      Set IRDEXP (needed by TBCALR!)
*.  7-Oct-89   D.R.Ward      If we don't call INIT then some CALRs fall over
*. 19-Jun-89   J.Banks       Add FDET in smear mode
*. 17-May-89   D.R.Ward      Set control structure so can call ROPBAT
*. 17-Apr-89   D.R.Ward      Enable CE/CA summary
*.  6-Apr-89   D.R.Ward      Fix for another of Sylvain's changes in ROPE
*. 13-Mar-89   D.R.Ward      Mods for OD302
*.  7-Mar-89   D.R.Ward      Initialize RZ directory names
*.  9-Feb-89   S.Weisz       Call ROINIT, RFLSET in ROPE306.
*.                           ** RFLSET will change its default       **
*.                           ** Things folowing RFLSET to be removed **
*.  7-Feb-89   D.R.Ward      Call xxCALR
*.  2-Feb-89   D.R.Ward      Mods for ROPE306
*. 21-Dec-88   D.R.Ward      Changes for CE302
*. 19-Dec-88   J.Banks       Set IOODBK
*. 20-Oct-88   D.R.Ward      Declare one dummy key to keep FFREAD happy
*. 26-Sep-88   D.R.Ward      Enable FFREAD cards
*. 26-Sep-88   D.R.Ward      Mods for OD301
*. 21-Jul-88   D.R.Ward      Save GCCUTS and GCPHYS before calling CEINI
*.  2-Jun-88   D.R.Ward      Turn on CE/CA/AS
*. 30-May-88   R.J.Barlow    Use logicals
*. 18-May-88   D.R.Ward      Mods for OD203
*. 17-May-88   D.R.Ward      Call MMINIT and MMSETR
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER J,NOD,JUCOMP,NFIRST
      EXTERNAL JUCOMP
      REAL SCCUTS(16),SCPHYS(48)
+SEQ,GOVERS.
+SEQ,CRO.
+SEQ,CRVER.
+SEQ,GCUNIT.
+SEQ,RCREP.
+SEQ,ROPAR.
+SEQ,ROCPAR.
+SEQ,ROBANK.
+SEQ,RECNTL.
+SEQ,GOLOGI.
+SEQ,GOFILE.
+SEQ,RCNTRL.
+SEQ,CCE.
+SEQ,GOFLAG.
+SEQ,ODPAR,ODCOM1.
+SEQ,GCCUTS.
+SEQ,CXCNTL.
+SEQ,CXPAR.
      INTEGER IFIFST
      COMMON/FIFFRD/IFIFST
      INTEGER OPMODE
      COMMON/OPSTEE/OPMODE
      LRIN=LIN
      LROUT=LOUT
      IRBEAM=0
      IRINTR=0
      IVGOPA=IGOVER
      IRDEXP=IGOEXP
      IF(IRDEXP.LT.1000) IRDEXP=IRDEXP+1000
      IUHEAD(IIEXPT) = IRDEXP
*
*     call the relevant INIT and SETR routines from ROPE
*
      NCHDUM=1
      CHDUMM=' '
      CALL ROINIT
*
      CALL CVINIT
      CALL JCINIT
      CALL CZINIT
      CALL CTINIT
      CALL CXINIT
      CALL DXINIT
      CALL SIINIT
      CALL CSINIR
      CALL TBINIT
      CALL TEINIT
      CALL PBINIT
      CALL PEINIT
      CALL EBINIT
      CALL EEINIT
      CALL EMINIT
      CALL HBINIT
      CALL HEINIT
      CALL HPINIT
      CALL HMINIR
      CALL MBINIT
      CALL MEINIT
      CALL MMINIT
      CALL FDINIT
      CALL SWINIT
      CALL LLINIT
      CALL LMINIT
      CALL TRINIT
      CALL FIINIT
      CALL OPINIT
      IF(IVOP.NE.0 .AND. LDAC.NE.0 .AND. LQ(LDAC-2).NE.0) CALL OPPCL4
      IFIFST=1
      CALL ROCHIN
      CALL HIINIT
*
*     CEINIT will mess up our cuts if we aren't careful.
*     Believed no longer needed 29/7/92
*
*drw  CALL UCOPY(IPAIR,SCPHYS,48)
*drw  CALL UCOPY(CUTGAM,SCCUTS,16)
      CALL CEINIT
*drw  CALL UCOPY(SCPHYS,IPAIR,48)
*drw  CALL UCOPY(SCCUTS,CUTGAM,16)
*
*     Set extrapolation level - defined by calorimeter simulation level.
*
      IF(LCALFA) CALL UCTOH('FAST',MCEGEO,4,4)
      IF(LCALFU) CALL UCTOH('FULL',MCEGEO,4,4)
      IF(LCALSM) CALL UCTOH('SMEA',MCEGEO,4,4)
*
*     Tell CE to extrapolate CT tracks, to everywhere
*     The user can use the ROPE data cards to change this.
*     These should be the CE defaults these days, so don't bother 29/7/92
*
*drw  CALL UCTOH('CT  ',MCEXTR,4,4)
*drw  CALL UCTOH('DEDXTOF ECALHCALMUON',MCEASS,4,20)
*
      CALL DDINIT
      CALL ODINIT
      CALL DCINIT
      IODVER=IVOD
      IDDBAT=1
*
*-- Print the dummy processors.
*
      IF (NCHDUM .GT. 1) THEN
        NFIRST=1
   10   CHREP='Dummies called for '//
     +        CHDUMM(NFIRST:MIN(NFIRST+35,NCHDUM))
        CALL REPORT('GOROPS',1,'I')
        IF (NFIRST+35 .LT. NCHDUM) THEN
          NFIRST=NFIRST+36
          GOTO 10
        ENDIF
      ENDIF
*
*     Now see if any more data cards.
*
      CHMAIL=' Second call to FFGO to read ROPE data cards (if any)...'
      CALL GMAIL(1,1)
      CALL FFGO
*
*-- Decode ROPE Ffread cards.
*
      CALL RFLSET
*
      CALL RCASET('MAIN')
*
      IF(IVOP.NE.0 .AND. OPMODE.EQ.0) OPMODE=2
      IF(IVFI.NE.0) IFIBAT=1
*-- Enable CD processing, if processors linked and no ROPE data cards.
      IF(.NOT.LCDSM) THEN
         IF(NCENT.EQ.0) THEN
            IF(IVCV.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFCVC)=IQ(LRCO+IIFCDC)
            ENDIF
            IF(IVCJ.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFCJC)=IQ(LRCO+IIFCDC)
            ENDIF
            IF(IVCZ.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFCZC)=IQ(LRCO+IIFCDC)
            ENDIF
            IF(IVCT.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFCTC)=IQ(LRCO+IIFCDC)
            ENDIF
            IF(IVDX.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFDXC)=IQ(LRCO+IIFCDC)
            ENDIF
            IF(IVCX.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFCXC)=IQ(LRCO+IIFCDC)
            ENDIF
            IF(IVSI.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFSIC)=IQ(LRCO+IIFCDC)
            ENDIF
            IF(IVCS.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+1
               IQ(LCDC+IIFCSC)=IQ(LRCO+IIFCDC)
            ENDIF
         ENDIF
         IF(IVCV.NE.0) CALL CVSETR
         IF(IVJC.NE.0) CALL JCSETR
         IF(IVCZ.NE.0) CALL CZSETR
         IF(IVCT.NE.0) CALL CTSETR
         IF(IVCX.NE.0) CALL CXSETR
         IF(IVDX.NE.0) CALL DXSETR
         IF(IVSI.NE.0) CALL SISETR
         IF(IVCS.NE.0) CALL CSSETR
      ENDIF
*
      IF(LCDSM) THEN
         IF (JUCOMP('DOCX',LSMEAR,NSMEAR).NE.0) THEN
            ICXUSE = ICXUOD
            CALL CXSETR
         ENDIF
      ENDIF
*
      IF((.NOT. LCALSM) .OR. LPSFU) THEN
         IF(NECAL.EQ.0) THEN
            IF(IVTB.NE.0) THEN
               IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
               IQ(LECC+IIFTBC)=IQ(LRCO+IIFECC)
            ENDIF

            IF(IVTE.NE.0) THEN
               IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
               IQ(LECC+IIFTEC)=IQ(LRCO+IIFECC)
            ENDIF

            IF(IVPB.NE.0) THEN
               IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
               IQ(LECC+IIFPBC)=IQ(LRCO+IIFECC)
            ENDIF
            IF(IVPE.NE.0) THEN
               IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
               IQ(LECC+IIFPEC)=IQ(LRCO+IIFECC)
            ENDIF
         ENDIF
         IF(IVTB.NE.0) CALL TBSETR
         IF(IVTE.NE.0) CALL TESETR
         IF(IVPB.NE.0) CALL PBSETR
         IF(IVPE.NE.0) CALL PESETR
      ENDIF
      IF(.NOT. LCALSM) THEN
         IF(NECAL.EQ.0) THEN
            IF(IVEB.NE.0) THEN
               IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
               IQ(LECC+IIFEBC)=IQ(LRCO+IIFECC)
            ENDIF
            IF(IVEE.NE.0) THEN
               IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
               IQ(LECC+IIFEEC)=IQ(LRCO+IIFECC)
            ENDIF
            IF(IVEM.NE.0) THEN
               IQ(LRCO+IIFECC)=IQ(LRCO+IIFECC)+1
               IQ(LECC+IIFEMC)=IQ(LRCO+IIFECC)
            ENDIF
         ENDIF
         IF(NHCAL.EQ.0) THEN
            IF(IVHB.NE.0) THEN
               IQ(LRCO+IIFHCC)=IQ(LRCO+IIFHCC)+1
               IQ(LHCC+IIFHBC)=IQ(LRCO+IIFHCC)
            ENDIF
            IF(IVHE.NE.0) THEN
               IQ(LRCO+IIFHCC)=IQ(LRCO+IIFHCC)+1
               IQ(LHCC+IIFHEC)=IQ(LRCO+IIFHCC)
            ENDIF
            IF(IVHP.NE.0) THEN
               IQ(LRCO+IIFHCC)=IQ(LRCO+IIFHCC)+1
               IQ(LHCC+IIFHPC)=IQ(LRCO+IIFHCC)
            ENDIF
            IF(IVHM.NE.0) THEN
               IQ(LRCO+IIFHCC)=IQ(LRCO+IIFHCC)+1
               IQ(LHCC+IIFHMC)=IQ(LRCO+IIFHCC)
            ENDIF
         ENDIF
         IF(NMUON.EQ.0) THEN
            IF(IVMB.NE.0) THEN
               IQ(LRCO+IIFMUC)=IQ(LRCO+IIFMUC)+1
               IQ(LMUC+IIFMBC)=IQ(LRCO+IIFMUC)
            ENDIF
            IF(IVME.NE.0) THEN
               IQ(LRCO+IIFMUC)=IQ(LRCO+IIFMUC)+1
               IQ(LMUC+IIFMEC)=IQ(LRCO+IIFMUC)
            ENDIF
            IF(IVMM.NE.0) THEN
               IQ(LRCO+IIFMUC)=IQ(LRCO+IIFMUC)+1
               IQ(LMUC+IIFMMC)=IQ(LRCO+IIFMUC)
            ENDIF
         ENDIF
         IF(IVEB.NE.0) CALL EBSETR
         IF(IVEE.NE.0) CALL EESETR
         IF(IVEM.NE.0) CALL EMSETR
         IF(IVHB.NE.0) CALL HBSETR
         IF(IVHM.NE.0) CALL HMSETR
         IF(IVHE.NE.0) CALL HESETR
         IF(IVHP.NE.0) CALL HPSETR
         IF(IVMB.NE.0) CALL MBSETR
         IF(IVME.NE.0) CALL MESETR
         IF(IVMM.NE.0) CALL MMSETR
      ENDIF
      IF((.NOT. LCALSM) .OR. LFDFU) THEN
         IF(NFORW.EQ.0) THEN
            IF(IVFD.NE.0) THEN
               IQ(LRCO+IIFFOC)=IQ(LRCO+IIFFOC)+1
               IQ(LFOC+IIFFDC)=IQ(LRCO+IIFFOC)
            ENDIF
            IF(IVSW.NE.0) THEN
               IQ(LRCO+IIFFOC)=IQ(LRCO+IIFFOC)+1
               IQ(LFOC+IIFSWC)=IQ(LRCO+IIFFOC)
            ENDIF
         ENDIF
         IF(IVFD.NE.0) CALL FDSETR
         IF(IVSW.NE.0) CALL SWSETR
      ENDIF
*--dE/dx only for full CD
      IF(LSMCE .OR. .NOT. (LCDSM .AND. LCALSM)) THEN
         IF(NCENT.EQ.0) THEN
            IF(IVCE.NE.0) THEN
               IQ(LRCO+IIFCDC)=IQ(LRCO+IIFCDC)+2
               IQ(LCDC+IIFCEC)=IQ(LRCO+IIFCDC)-1
               IQ(LCDC+IIFCAC)=IQ(LRCO+IIFCDC)
            ENDIF
         ENDIF
      ENDIF
      IF(IVCE.NE.0) CALL CESETR
*
      IF(LCDSM .AND. (LSMCE .OR. .NOT.LALLSM)) THEN
         IF(IQ(LRCO+IIFCDC).EQ.0) IQ(LRCO+IIFCDC)=1
      ENDIF
      IF(LCALSM .AND. (LSMCE .OR. .NOT.LALLSM)) THEN
         IF(IQ(LRCO+IIFECC).EQ.0) IQ(LRCO+IIFECC)=1
         IF(IQ(LRCO+IIFHCC).EQ.0) IQ(LRCO+IIFHCC)=1
         IF(IQ(LRCO+IIFMUC).EQ.0) IQ(LRCO+IIFMUC)=1
         IF(IQ(LRCO+IIFFOC).EQ.0) IQ(LRCO+IIFFOC)=1
      ENDIF
*
*    Select appropriate OD blocks to be filled in this run.
*      CALL UCTOH('ALL ',LODBLK(1),4,4)
*
      CALL UCTOH('GNRL',LODBLK(1),4,4)
      NOD=2
      IF(IQ(LCDC+IIFCJC).NE.0 .OR. IQ(LCDC+IIFCTC).NE.0) THEN
         CALL UCTOH('CTRK',LODBLK(NOD),4,4)
         NOD=NOD+1
         IF(IQ(LCDC+IIFCXC).NE.0) THEN
            CALL UCTOH('ATRK',LODBLK(NOD),4,4)
            CALL UCTOH('VRTX',LODBLK(NOD+1),4,4)
            NOD=NOD+2
         ENDIF
      ENDIF
      IF(IQ(LECC+IIFPBC).NE.0 .OR. IQ(LECC+IIFPEC).NE.0) THEN
         CALL UCTOH('PRES',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF
      IF(IQ(LECC+IIFEMC).NE.0) THEN
         CALL UCTOH('ECAL',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF


      IF(IQ(LECC+IIFTEC).NE.0) THEN
         CALL UCTOH('DTE ',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF




      IF(IQ(LECC+IIFTBC).NE.0) THEN
         CALL UCTOH('TOF ',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF
      IF(IQ(LHCC+IIFHMC).NE.0) THEN
         CALL UCTOH('HCAL',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF
      IF(IQ(LMUC+IIFMMC).NE.0) THEN
         CALL UCTOH('MUON',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF
      IF(IQ(LFOC+IIFFDC).NE.0) THEN
         CALL UCTOH('FDET',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF
      IF(IQ(LFOC+IIFSWC).NE.0) THEN
         CALL UCTOH('SIW ',LODBLK(NOD),4,4)
         NOD=NOD+1
      ENDIF
      IF(LCDSM .AND. (LSMCE .OR. .NOT.LALLSM)) THEN
         CALL UCTOH('CTRK',LODBLK(NOD),4,4)
         CALL UCTOH('ATRK',LODBLK(NOD+1),4,4)
         CALL UCTOH('VRTX',LODBLK(NOD+2),4,4)
         NOD=NOD+3
      ENDIF
      IF(LCALSM .AND. (LSMCE .OR. .NOT.LALLSM)) THEN
         CALL UCTOH('ECAL',LODBLK(NOD),4,4)
         CALL UCTOH('HCAL',LODBLK(NOD+1),4,4)
         CALL UCTOH('MUON',LODBLK(NOD+2),4,4)
         CALL UCTOH('FDET',LODBLK(NOD+3),4,4)
         NOD=NOD+4
      ENDIF
*
      IF(IVDD.NE.0) CALL DDSETR
      IF(IVDC.NE.0) THEN
         J=JUCOMP('DICI',IONAME,NFILE)
         IF(J.NE.0) THEN
            OPEN (UNIT=IOUNIT(J),FILE=IOFNAM(J),STATUS='OLD'
+SELF,IF=VAX.
     +         ,READONLY,SHARED
+SELF.
     +         ,FORM='FORMATTED')
            CALL DCRDIC(IOUNIT(J))
         ENDIF
         CALL DCSETR
      ENDIF
      IF(IVOD.NE.0) CALL ODSETR
      IF(LSMCE .OR. .NOT.LALLSM)    THEN
         IF(NODBLK.NE.0) THEN
            IF(IVOD.NE.0) THEN
               IQ(LRCO+IIFODC)=IQ(LRCO+IIFODC)+1
            ENDIF
         ENDIF
      ENDIF
      IF(IVLL.NE.0) CALL LLSETR
      IF(IVLM.NE.0) CALL LMSETR
      IF(IVTR.NE.0) CALL TRSETR
      IF(IVFI.NE.0) CALL FISETR
      CALL HISETR
      CALL USSETR
*
*     Call calibration stuff; some ROPE processors rely on this to set
*     up links etc.  Anyway, should be a good investment for the future.
*
      CALL RCPREP
      CALL RGETCA
*
*     And print what we've done.
*
      IFUPDT=1
      CALL RPRTVS
      CALL ROPTPR
      END
+DECK,GOSELI.
      SUBROUTINE GOSELI(CNAME)
*.
*...GOSELI   Handle SKIP/SELECT cards
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  5-Oct-90
*. LAST MOD  :
*.
*. Modification Log.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,ROBANK.
+SEQ,GOFLAG.
      CHARACTER*(*) CNAME
      INTEGER LMCDO
*
      IF(LMCC.LE.0) THEN
         CHREP='No MCC bank found'
         CALL REPORT('GOSELI',1,'W')
         GO TO 99
      ENDIF
*
      LMCDO=LQ(LMCC-2)
      IF(LMCDO.LE.0) THEN
         CALL MZBOOK(IROCON,LMCDO,LMCC,-2,'MCDO',0,0,10,2,0)
         IF(CNAME.EQ.'SKIP') IQ(LMCDO+1)=1
         IF(CNAME.EQ.'SELE') IQ(LMCDO+1)=2
      ENDIF
      IF( ( CNAME.EQ.'SKIP' .AND. IQ(LMCDO+1).NE.1 ) .OR.
     +    ( CNAME.EQ.'SELE' .AND. IQ(LMCDO+1).NE.2 ) ) THEN
         CHREP='You can''t mix *SELECT and *SKIP cards, *'//
     +          CNAME//' ignored.'
         CALL REPORT('GOSELI',2,'W')
         GO TO 99
      ENDIF
*
      IQ(LMCDO+2)=IQ(LMCDO+2)+1
      IF(IQ(LMCDO+2)+2.GT.IQ(LMCDO-1))
     +          CALL MZPUSH(IXSTOR,LMCDO,0,10,'I')
      IQ(LMCDO+IQ(LMCDO+2)+2)=IESKIP
*
  99  END
+DECK,GOSELQ.
      SUBROUTINE GOSELQ(IFLAG)
*.
*...GOSELI   Handle SKIP/SELECT cards
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  5-Oct-90
*. LAST MOD  :
*.
*. Modification Log.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,RCREP.
+SEQ,GCFLAG.
      INTEGER IFLAG,IUCOMP,I,LMCDO
      EXTERNAL IUCOMP
*
      IFLAG=0
      IF(LMCC.LE.0) GO TO 99
      LMCDO=LQ(LMCC-2)
      IF(LMCDO.LE.0) GO TO 99
      IF(IQ(LMCDO+1).EQ.1) THEN
* SKIP
  10     IF(IUCOMP(IDEVT,IQ(LMCDO+3),IQ(LMCDO+2)).EQ.0) GO TO 99
         WRITE(CHREP,'(''Event #'',I6,''  skipped.'')',ERR=11) IDEVT
  11     CALL REPORT('GOSELQ',2,'I')
         IDEVT=IDEVT+1
         NEVENT=NEVENT-1
         GO TO 10
      ELSE
* SELECT
         DO 20 I=3,2+IQ(LMCDO+2)
            IF(IQ(LMCDO+I).LT.IDEVT) GO TO 20
            IDEVT=IQ(LMCDO+I)
            WRITE(CHREP,'(''Event #'',I6,''  selected.'')',ERR=21)
     +                   IDEVT
   21       CALL REPORT('GOSELQ',3,'I')
            GO TO 99
   20    CONTINUE
         IFLAG=1
      ENDIF
*
  99  END
+DECK,GOTORD.
      SUBROUTINE GOTORD
*.
*...GOTORD
*.
*. Check entries in TREE bank are in order, and reorder if necessary     
*.
*. SEQUENCE  : GCBANK LINKRA RCREP GOPAR GOXTRA
*. CALLS     : REPORT PDGCHG 
*. CALLED    :
*.
*. BANKS L   : 
*.
*. INPUT     : 
*. OUTPUT    :
*.
*. AUTHOR    : C.P.Ward
*. CREATED   : 18-Mar-96
*. LAST MOD  :  
*.
*. Modification Log.
*.
*.*********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCBANK.
+SEQ,LINKRA.
+SEQ,GOPAR.
+SEQ,GOXTRA.
*
      INTEGER  NWMAX
      PARAMETER (NWMAX=5000)
      REAL     WSP
      DIMENSION WSP(NWMAX)
      EQUIVALENCE (WS(21),WSP(1))
*
      INTEGER  LGENE,LTREE,LJETS,NGEN,NJET,LENT,LENJ,I,IPAR,IPJ,
     +         IP1,IP2,NW,J,IP,IS
*
*--- Working space for copying arrays
*
      CALL GWORK(NWMAX)
*
*--- Links to TREE bank etc.
*
      LGENE = LQ(LMC-1)
      LTREE = LQ(LGENE-LLTREE)
      LJETS = LQ(LGENE-LLJETS)
      NGEN = IQ(LGENE+1)
      NJET = IQ(LGENE+3) + IQ(LGENE+4)
      LENT = IQ(LGENE+5)
      LENJ = IQ(LGENE+6)
*
*--- Loop over all particles in TREE bank
*
      DO 100 I=1,NGEN
*
*--- Find parent in TREE, via JETS bank if necessary
*
    1 IPAR = IQ(LTREE+(I-1)*LENT+2)
      IF(IPAR.LE.0) THEN
        IPJ = IQ(LTREE+(I-1)*LENT+6)
        IF(IPJ.GT.0) THEN
    2     IPJ = MOD(IPJ,1000)
          IPAR = IQ(LJETS+(IPJ-1)*LENJ+3)
          IPJ = IQ(LJETS+(IPJ-1)*LENJ+2)
          IF(IPJ.GT.0) GO TO 2
        ENDIF
      ENDIF
      IF(IPAR.LT.I) GO TO 100
*
*--- Parent is lower down tree - need to do swap
*--- Find siblings of parent,as have to move whole block
*
      IP1 = 0
      IP2 = 0
      DO 10 J=1,NGEN
      IF(IQ(LTREE+(J-1)*LENT+2).NE.IQ(LTREE+(IPAR-1)*LENT+2)) GO TO 10
      IF(IP1.EQ.0) IP1 = J
      IP2 = J
   10 CONTINUE
*
*--- Number of words to copy
*
      NW = (IP2-IP1+1)*LENT
      IF(NW.GT.NWMAX) THEN
        WRITE(CHREP,1000) NW,NWMAX
        CALL REPORT('GOTORD',1,'E')
        GO TO 999
      ENDIF
*
*--- Copy these to working space
*
      CALL UCOPY(Q(LTREE+(IP1-1)*LENT+1),WSP(1),NW)
*
*--- Shuffle particles above down
*
      DO 20 J=IP1-1,I,-1
      CALL UCOPY(Q(LTREE+(J-1)*LENT+1),Q(LTREE+(J-1)*LENT+1+NW),LENT)
   20 CONTINUE
*
*--- Move first lot up
*
      CALL UCOPY(WSP(1),Q(LTREE+(I-1)*LENT+1),NW)
*
*--- And reset all the pointers
*
      DO 30 J=1,NJET
      IP = LJETS+(J-1)*LENJ+3
      IF(IQ(IP).GE.I .AND. IQ(IP).LT.IP1) THEN
        IQ(IP) = IQ(IP)+(IP2-IP1+1)
      ELSEIF(IQ(IP).GE.IP1 .AND. IQ(IP).LE.IP2) THEN
        IQ(IP) = IQ(IP)-(IP1-I)
      ENDIF
   30 CONTINUE
*
      DO 40 J=1,NGEN
      IP = LTREE+(J-1)*LENT+2
      IS = LTREE+(J-1)*LENT+3
      IF(IQ(IP).GE.I .AND. IQ(IP).LT.IP1) THEN
        IQ(IP) = IQ(IP)+(IP2-IP1+1)
      ELSEIF(IQ(IP).GE.IP1 .AND. IQ(IP).LE.IP2) THEN
        IQ(IP) = IQ(IP)-(IP1-I)
      ENDIF
      IF(IQ(IS).GE.I .AND. IQ(IS).LT.IP1) THEN
        IQ(IS) = IQ(IS)+(IP2-IP1+1)
      ELSEIF(IQ(IS).GE.IP1 .AND. IQ(IS).LE.IP2) THEN
        IQ(IS) = IQ(IS)-(IP1-I)
      ENDIF
   40 CONTINUE
*
      WRITE(CHREP,2000) IP1,IP2,I
      CALL REPORT('GOTORD',2,'I')
*
*--- Need to check new particle I
*
      GO TO 1
*
  100 CONTINUE
*
 1000 FORMAT('Too many words to copy, NW,NWMAX=',2I8)
 2000 FORMAT('TREE entries',I3,'-',I3,' moved to position',I3)
*
  999 RETURN
      END
+DECK,GOTRCO.
      SUBROUTINE GOTRCO
*.
*...GOTRCO counts the number of particles in the particle tree.
*.
*. SEQUENCE  : GCBANK LINKRA ROSPAR
*. COMMON    :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   : TRCO MCS
*. BANKS U   : GENE TREE
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 19-Apr-88
*. LAST MOD  : 21-Jun-90
*.
*. Modification Log.
*. 21-Jun-90   S.L.Lloyd     Change K0 to PDG particle codes !
*. 12-Jan-90   D.R.Ward      Move MCS bank booking to UGINIT
*. 22-Feb-89   S.L.Lloyd     Change to PDG particle codes.
*. 10-May-88   D.R.Ward      Fix a couple of bugs
*. 27-Apr-88   D.R.Ward      Recompute LTRCO each time
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,ROSPAR.
+SEQ,LINKGO.
      LOGICAL FIRST
      REAL    PBINS(11),PP
      INTEGER JCODE(25),LGENE,LTREE,NGEN,LENT,N,NADD,J,IPART,IJ,LTRCO ,
     +IPAREN,NADDD
      DATA PBINS/0.0,0.5,1.0,2.0,3.0,4.0,5.0,10.0,20.0,30.0,50.0/
      DATA JCODE/211,111,321,311,411,421,431,113,213,223,333,221,331,
     +           323,313,2212,2112,3122,3312,2224,11,13,15,22,99/
      DATA   FIRST/.TRUE./
*
*-- Creates tree count bank.
*
      IF(LMCS.EQ.0) GO TO 60
      IF (FIRST) THEN
         CALL MZBOOK (IROSTA,LTRCO,LMCS,-1,'TRCO',0,0,301,2,0)
         FIRST = .FALSE.
      ENDIF
*
      LTRCO = LQ(LMCS-1)
      IQ(LTRCO+301) = IQ(LTRCO+301) + 1
*
*-- Find generated particle bank.
*
      IF (LMC.LE.0) GO TO 60
      LGENE = LQ(LMC-1)
      IF (LGENE.LE.0) GO TO 60
      LTREE = LQ(LGENE-1)
*
      NGEN  = IQ(LGENE+1)
      LENT  = IQ(LGENE+5)
*
      DO 50 N=1,NGEN
         NADD = LTREE + (N-1)*LENT
         IF (IQ(NADD+9).GE.3) GO TO 50
*
*-- Find particle type.
*
         IPART = ABS(IQ(NADD+1))
         DO 10 J=1,25
            IF (J.EQ.4.AND.(IPART.EQ.130.OR.IPART.EQ.310)) THEN
               IPAREN=IQ(NADD+2)
               NADDD=LTREE+(IPAREN-1)*LENT
               IF (ABS(IQ(NADDD+1)).NE.311) GO TO 20
               GO TO 10
            ENDIF
            IF (IPART.EQ.JCODE(J)) GO TO 20
   10    CONTINUE
         GO TO 50
*
   20    CONTINUE
         IJ=J
         IQ(LTRCO+(IJ-1)*12+12) = IQ(LTRCO+(IJ-1)*12+12) + 1
*
*-- Find momentum bin.
*
         PP = SQRT(Q(NADD+10+1)**2+Q(NADD+10+2)**2+Q(NADD+10+3)**2)
*
         DO 30 J=1,10
            IF (PP.GE.PBINS(J).AND.PP.LT.PBINS(J+1)) GO TO 40
   30    CONTINUE
         IQ(LTRCO+(IJ-1)*12+11) = IQ(LTRCO+(IJ-1)*12+11) + 1
         GO TO 50
*
   40    CONTINUE
         IQ(LTRCO+(IJ-1)*12+J) = IQ(LTRCO+(IJ-1)*12+J) + 1
*
   50 CONTINUE
*
   60 CONTINUE
*
      END
+DECK,GOTREE.
      SUBROUTINE GOTREE(KTREE)
*.
*...GOTREE prints out the generated particle tree.
*.
*. INPUT     : KTREE  0 => full tree; >0 => just this line;
*.                   <0 => this line's ancestors and descendents
*. SEQUENCE  : GCBANK GCUNIT GCFLAG LINKRA
*. CALLS     : GMAIL
*. CALLED    :
*.
*. BANKS U   : GENE TREE JETS
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 15-Apr-88
*. LAST MOD  : 15-Apr-96
*.
*. Modification Log.
*. 15-Apr-96   C.P.Ward      Print heading for secondary partons
*. 23-Mar-95   C.P.Ward      Protect against LMC unset
*. 18-Sep-92   J.W.Gary      Small modification for ID=93
*.  3-Jul-91   J.W.Gary      Use stable particles to calculate sums
*.  2-May-89   D.R.Ward      Add input argument
*. 04-Apr-89   J.W.Gary      Parton shower history
*. 22-Feb-89   S.L.Lloyd     Change format for PDG particle codes.
*. 05-May-88   S.L.Lloyd     Sort out sums and restructure
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,GCBANK.
+SEQ,GCFLAG.
+SEQ,GCUNIT.
+SEQ,LINKRA.
      INTEGER LGENE,LTREE,LJETS,NGEN,NPRIM,NJET,NSJET,LENT,LENJ,IJ,N1,
     +N2,NADD,ISQ,N,L,K,KTREE,MMM,MADD,NEVG
      DOUBLE PRECISION SX,SY,SZ,SE
*
      IF(KTREE.EQ.0) THEN
         WRITE (CHMAIL,1000) IDEVT
         CALL GMAIL (1,1)
      ENDIF
*
      IF(LMC.LE.0) GO TO 40   
*
      LGENE = LQ(LMC-1)
      IF (LGENE.LE.0) GO TO 40
      LTREE = LQ(LGENE-1)
      LJETS = LQ(LGENE-2)
*
      NGEN  = IQ(LGENE+1)
      NPRIM = IQ(LGENE+2)
      NJET  = IQ(LGENE+3)
      NSJET = IQ(LGENE+4)
      LENT  = IQ(LGENE+5)
      LENJ  = IQ(LGENE+6)
*
      IF(KTREE.NE.0) GO TO 50
      IF (NJET.GT.0) THEN
         WRITE (CHMAIL,1100)
         CALL GMAIL (0,1)
         WRITE (CHMAIL,1110)
         CALL GMAIL (0,1)
         DO 10 IJ=1,NJET
            NADD = LJETS + (IJ-1)*LENJ
            WRITE (CHMAIL,1200) IJ,IQ(NADD+1),(Q(NADD+3+L),L=1,5),
     +          IQ(NADD+2),IQ(NADD+3)
            CALL GMAIL (0,0)
   10    CONTINUE
      ENDIF
*
      IF (NSJET.GT.0) THEN
         N1 = NJET + 1
         N2 = NJET + NSJET
         WRITE (CHMAIL,1300)
         CALL GMAIL (1,1)
         WRITE (CHMAIL,1110)
         CALL GMAIL (0,1)
         DO 20 IJ=N1,N2
            NADD = LJETS + (IJ-1)*LENJ
            WRITE (CHMAIL,1200) IJ,IQ(NADD+1),(Q(NADD+3+L),L=1,5),
     +          IQ(NADD+2),IQ(NADD+3)
            CALL GMAIL (0,0)
   20    CONTINUE
      ENDIF
*
   50 WRITE (CHMAIL,1500)
      IF(KTREE.EQ.0) THEN
         CALL GMAIL (1,0)
      ELSE
         CALL GMAIL (0,0)
      ENDIF
      SX=0.D0
      SY=0.D0
      SZ=0.D0
      SE=0.D0
      ISQ=0
*
      NEVG = 0
      DO 25 N=1,NGEN
         NADD = LTREE + (N-1)*LENT
         IF (IQ (NADD+9).LE.2) NEVG = NEVG + 1
 25   CONTINUE
*
      DO 30 N=1,NGEN
         IF(KTREE.GT.0) THEN
            IF(KTREE.NE.N) GO TO 30
         ELSEIF(KTREE.LT.0) THEN
            IF(-KTREE.LT.N) THEN
               MMM=N
  31           MADD=LTREE+(MMM-1)*LENT
               MMM=IQ(MADD+2)
               IF(MMM.LT.-KTREE) GO TO 30
               IF(MMM.GT.-KTREE) GO TO 31
            ELSEIF(-KTREE.GT.N) THEN
               MMM=-KTREE
  32           MADD=LTREE+(MMM-1)*LENT
               MMM=IQ(MADD+2)
               IF(MMM.LT.N) GO TO 30
               IF(MMM.GT.N) GO TO 32
            ENDIF
         ENDIF
         NADD = LTREE + (N-1)*LENT
         IF (N.LE.NEVG) THEN
            IF (IQ (NADD+4).EQ.0.OR.IQ (NADD+3).GT.NEVG) THEN
               SX = SX + Q(NADD+10+1)
               SY = SY + Q(NADD+10+2)
               SZ = SZ + Q(NADD+10+3)
               SE = SE + Q(NADD+10+4)
               ISQ = ISQ + INT(Q(NADD+10+6))
            END IF
         END IF
         IF (N.LE.NPRIM) THEN
*
            IF (IQ(NADD+10).NE.0.AND.IQ(NADD+10).NE.1) THEN
               WRITE(CHMAIL,1600) N,IQ(NADD+1), (IQ(NADD+K),K=3,10),(Q
     +         (NADD+10+K),K=1,5), INT(Q(NADD+10+6)), (Q(NADD+10+K),K=7,
     +         12)
            ELSE
               WRITE(CHMAIL,1700) N,IQ(NADD+1), (IQ(NADD+K),K=3,10),(Q
     +         (NADD+10+K),K=1,5), INT(Q(NADD+10+6)), (Q(NADD+10+K),K=7,
     +         9)
            ENDIF
            CALL GMAIL (0,0)
*
         ELSE
*
            IF (IQ(NADD+10).NE.0.AND.IQ(NADD+10).NE.1) THEN
               WRITE (CHMAIL,1800)N,IQ(NADD+1),IQ(NADD+2), (IQ(NADD+K),K
     +         =3,10),(Q(NADD+10+K),K=1,5), INT(Q(NADD+10+6)), (Q
     +         (NADD+10+K),K=7,12)
            ELSE
               WRITE (CHMAIL,1900)N,IQ(NADD+1),IQ(NADD+2), (IQ(NADD+K),K
     +         =3,10),(Q(NADD+10+K),K=1,5), INT(Q(NADD+10+6)), (Q
     +         (NADD+10+K),K=7,9)
            ENDIF
            CALL GMAIL (0,0)
         ENDIF
*
   30 CONTINUE
*
      IF(KTREE.NE.0) GO TO 40
      WRITE (CHMAIL,2000) SX,SY,SZ,SE,ISQ
      CALL GMAIL (0,1)
*
   40 CONTINUE
*
*
 1000 FORMAT(1X,'History of generated particles - Event number',I5)
 1100 FORMAT(1X,'Primary partons (ID=91 is a cluster; ',
     +       ' ID=92 a string; ID=93 indep.frag.)')
 1110 FORMAT (7X,'   ID      PX        PY        PZ      Energy',
     +        '     Mass    Par(jet) Par(tree)')
 1200 FORMAT(1X,I3,I8,5F10.3,2I8)
 1300 FORMAT(1X,'Secondary partons (ID=91 is a cluster; ',
     +       ' ID=92 a string; ID=93 indep.frag.)')
 1500 FORMAT(1X, '     Code Par Sec  N DST Jt Kin Sp St En',
     +'       PX       PY       PZ   Energy    Mass  Q',
     +'      Start point           End point')
 1600 FORMAT(1X,I3,I6,4X,I4,I3,I4,I3,I4,I3,2I3,4F9.3,F8.3,I3,6F7.2)
 1700 FORMAT(1X,I3,I6,4X,I4,I3,I4,I3,I4,I3,2I3,4F9.3,F8.3,I3,3F7.2)
 1800 FORMAT(1X,I3,I6,I4,I4,I3,I4,I3,I4,I3,2I3,4F9.3,F8.3,I3,6F7.2)
 1900 FORMAT(1X,I3,I6,I4,I4,I3,I4,I3,I4,I3,2I3,4F9.3,F8.3,I3,3F7.2)
 2000 FORMAT(1X,34X,'Totals',4F9.3,8X,I3)
      END
+DECK,GOTRPR.
      SUBROUTINE GOTRPR
*.
*...GOTRPR prints out a summary of the particle tree.
*.
*. SEQUENCE  : GCBANK GCUNIT ROSPAR LINKRA
*. CALLS     : GMAIL
*. CALLED    :
*.
*. BANKS U   : TRCO
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 19-Apr-88
*. LAST MOD  : 22-Feb-89
*.
*. Modification Log.
*. 22-Feb-89   S.L.Lloyd     Dont print lines with zero total.
*. 19-Jul-88   S.L.Lloyd     Protect if no tree
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,ROSPAR.
+SEQ,LINKRA.
      CHARACTER*8 NAME(25)
      INTEGER LTRCO,NEVT,J,L
      REAL    RATIO,ERROR
      DATA NAME/'Pi +/-  ','Pizero  ','K +/-   ','Kzero   ','D +/-   ',
     +'D 0     ','D S     ','Rho 0   ','Rho +/- ','Omega   ', 'Phi     '
     +,'Eta     ','Eta prim','K* +/-  ','K* 0    ', 'p/pbar  ',
     +'n/nbar  ','Lambda  ','Cascade-','Delta ++', 'e+/-    ','Mu+/-   '
     +,'Tau+/-  ','Photon  ','Unknown '/
*
      IF (LMCS.LE.0) GO TO 20
      LTRCO = LQ(LMCS-1)
      IF (LTRCO.LE.0) GO TO 20
      NEVT = IQ(LTRCO+301)
      IF (NEVT.EQ.0) GO TO 20
*
      WRITE (CHMAIL,1000) NEVT
      CALL GMAIL (1,2)
*
      WRITE (CHMAIL,1100)
      CALL GMAIL (0,1)
*
      DO 10 J=1,24
         IF (IQ(LTRCO+(J-1)*12+12).EQ.0) GO TO 10
         RATIO = REAL(IQ(LTRCO+(J-1)*12+12))/REAL(NEVT)
         ERROR=SQRT(REAL(IQ(LTRCO+(J-1)*12+12)))/REAL(NEVT)
         WRITE (CHMAIL,1200) NAME(J),(IQ(LTRCO+(J-1)*12+L),L=1,12),
     +   RATIO,ERROR
         CALL GMAIL (0,0)
   10 CONTINUE
*
   20 CONTINUE
*
*
 1000 FORMAT (1X,'Number of particles generated in momentum bins',
     +' for',I6,' events')
 1100 FORMAT (1X,
     +'Particle 0.0-0.5 0.5-1.0 1.0-2.0 2.0-3.0 3.0-4.0 4.0-5.0',
     +'  5 - 10 10 - 20 20 - 30 30 -  50  >50.0   Total',
     +'   Number per event')
 1200 FORMAT (1X,A8,12I8,F8.3,'+/-',F8.3)
      END
+DECK,GOTRUP.
      SUBROUTINE GOTRUP (JTRA,VEC,KCASE,KPART,NT,GKIN)
*.
*...GOTRUP updates the generator banks when new particles are created.
*.
*. INPUT     : JTRA   Parent particle number.
*. INPUT     : VEC   x y z of interaction/decay.
*. INPUT     : KCASE  Reason for new particle generated.
*. INPUT     : KPART  Daughter particle type.
*. INPUT     : NT     Daughter particle number.
*. INPUT     : GKIN   Px Py Pz of daughter.
*.
*. SEQUENCE  : GCBANK LINKRA RCREP GCTRAK
*. CALLS     : REPORT GFPART UHTOC IUCOMP
*. CALLED    : GOKING CJKING
*.
*. BANKS M   : GENE TREE
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 3.01
*. CREATED   : 21-Apr-88
*. LAST MOD  : 08-Dec-93
*.
*. Modification Log.
*. 08-Dec-93   C.P.Ward      Remove unused variables.
*. 11-May-90   S.L.Lloyd     Bug fix
*. 22-Feb-89   S.L.Lloyd     Change to PDG particle codes.
*. 23-Jan-89   D.R.Ward      Problem - overwriting CHARGE!
*. 19-Dec-88   S.L.Lloyd     Problem with muon pair production
*.  7-Oct-88   D.Lellouch    Bug for antisigmas
*. 17-May-88   D.R.Ward      Recompute NADD after PUSH
*. 12-May-88   D.R.Ward      Return if no TREE extant.
*. 05-May-88   S.L.Lloyd     Extend Lund codes and start/end flags
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCBANK.
+SEQ,GCTRAK.
+SEQ,GCKINE.
+SEQ,LINKRA.
      REAL VEC(*),GKIN(*),UB(10),AMAS,CHARG,TLIF
      INTEGER ISEL(47),JSEL(47),JSTOP,IPAREN,L,JTRA
      INTEGER KCASE,KPART,NT,NPUSH,IEND,ISTART,LGENE,LTREE, LENGTH,
     +NGEN,LENT,N,NADD,NADDD,IJK,ILTYPE,NWB, NSEL,IUCOMP,ITRTY
      EXTERNAL IUCOMP
      CHARACTER*20 CHPART
      CHARACTER*4 NAME
*   Conversion table between PDG particle codes and GEANT.
      DATA NSEL/47/
      DATA ISEL/ 22,-11, 11, 12,-12,-13, 13, 14,-14, 16,-16, 211,-211,
     + 321,-321, 310, 130,2212,-2212,2112,-2112,3222,-3222,3112,-3112,
     + 3322,-3322,3312,-3312,3122,-3122,3334,-3334, 15,-15,3212,-3212,
     + 221,-221,111,-111, 95,-95, 96,-96, 97, -97/
      DATA JSEL/ 1, 2, 3, 4, 4, 5, 6, 4, 4, 4, 4, 8, 9, 11, 12, 16, 10,
     +14, 15, 13, 25, 19, 27, 21, 29, 22, 30, 23, 31, 18, 26, 24, 32,
     +34, 33, 20, 28, 17, 17, 7, 7, 45, 45, 46, 46, 47, 47/
*
      DATA NPUSH/25/
*
      CALL UHTOC (KCASE,4,NAME,4)
*
*-- Decide if process stops the particle and if so what flag to give it.
*
      IF (NAME.EQ.'DCAY'.OR.(NAME.EQ.'PAIR'.AND.IPART.EQ.1)
     +.OR.NAME.EQ.'PHOT'.OR. NAME
     +.EQ.'ANNI'.OR.NAME.EQ.'HADR'.OR.NAME.EQ.'STOP') THEN
         JSTOP = 1
      ELSE
         JSTOP = 0
      ENDIF
*
      IF (NAME.EQ.'STAK') THEN
         ISTART = 3
      ELSE
         L = IUCOMP(KCASE,NAMEC,30)
         IF (L.GE.4) THEN
            ISTART = L
            IEND = -L
         ELSE
            WRITE (CHREP,1300) NAME
            CALL REPORT ('GOTRUP',4,'ERROR')
            ISTART = 4
         ENDIF
      ENDIF
*
      IF (LMC.LE.0) GO TO 30
      LGENE = LQ(LMC-1)
      IF (LGENE.EQ.0) GO TO 30
*
      LTREE = LQ(LGENE-1)
      IF(LTREE.EQ.0) GO TO 30
      LENGTH = IQ(LTREE-1)
*
      NGEN = IQ(LGENE+1)
      LENT = IQ(LGENE+5)
*
*-- Loop round tree looking for parent particle.
*
      DO 10 N=1,NGEN
         NADD = LTREE + (N-1)*LENT
         IF (IQ(NADD+7).EQ.JTRA) GO TO 20
   10 CONTINUE
*
      WRITE (CHREP,1000) JTRA
      CALL REPORT ('GOTRUP',1,'ERROR')
      ISTART = 4
      IPAREN = 0
*
   20 CONTINUE
      IPAREN = 1
*
*-- Stop this particle if process is stopping.
*
      IF (JSTOP.EQ.1.AND.IQ(NADD+10).GE.0) THEN
         IQ(NADD+10) = IEND
         Q(NADD+10+10) = VEC(1)
         Q(NADD+10+11) = VEC(2)
         Q(NADD+10+12) = VEC(3)
      ENDIF
*
*-- Store a new particle in the tree if required.
*
      IF (NT.GT.0) THEN
*
*-- Push the tree bank if necessary.
*
         IF (LENGTH.LE.NGEN*LENT) THEN
            NADD=NADD-LTREE
            CALL MZPUSH (IXSTOR,LTREE,0,NPUSH*LENT,' ')
            NADD=NADD+LTREE
            WRITE (CHREP,1100) NPUSH
            CALL REPORT ('GOTRUP',2,'INFORMATION')
            LGENE = LQ(LMC-1)
         ENDIF
*
         NGEN = NGEN + 1
         IQ(LGENE+1) = NGEN
         NADDD = LTREE + (NGEN-1)*LENT
*
*-- Convert from GEANT particle code to PDG.
*
         IJK = IUCOMP (KPART,JSEL,NSEL)
         IF (IJK.EQ.0) THEN
            WRITE (CHREP,1200) KPART
            CALL REPORT ('GOTRUP',1,'ERROR')
            ILTYPE = 99
         ELSE
            ILTYPE = ISEL(IJK)
         ENDIF
*
*-- Find out what the charge and mass are.
*
         CALL GFPART (KPART,CHPART,ITRTY,AMAS , CHARG ,TLIF ,UB,NWB)
*
*-- Fill the particle tree entries.
*
         IF (IPAREN.EQ.1) THEN
            IF (IQ(NADD+4).EQ.0) IQ(NADD+3) = NGEN
            IQ(NADD+4) = IQ(NADD+4) + 1
            IQ(NADDD+6) = IQ(NADD+6)
         ENDIF
*
         IQ(NADDD+1) = ILTYPE
         IQ(NADDD+2) = N
         IQ(NADDD+7) = NT
         IQ(NADDD+9) = ISTART
         IF (CHARG .NE.0) IQ(NADDD+10) = 1
         Q(NADDD+10+1) = GKIN(1)
         Q(NADDD+10+2) = GKIN(2)
         Q(NADDD+10+3) = GKIN(3)
         Q(NADDD+10+4) = SQRT(GKIN(1)**2+GKIN(2)**2+GKIN(3)**2+ AMAS
     +   **2)
         Q(NADDD+10+5) = AMAS
         Q(NADDD+10+6) = CHARG
         Q(NADDD+10+7) = VEC(1)
         Q(NADDD+10+8) = VEC(2)
         Q(NADDD+10+9) = VEC(3)
      ENDIF
*
   30 CONTINUE
*
*
 1000 FORMAT ('KINE track',I4,' is not in particle tree')
 1100 FORMAT ('TREE bank pushed by',I4)
 1200 FORMAT ('Particle type',I5,' not in PDG table')
 1300 FORMAT ('Unknown mechanism ',A4)
      END
+DECK,GOTSTE.
      SUBROUTINE GOTSTE
*.
*...GOTSTE   Time GOPAL tracking
*.
*. COMMON    :
*. SEQUENCE  :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    : GUTREV
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 16-Jan-90
*. LAST MOD  : 19-Feb-90
*.
*. Modification Log.
*. 22-Feb-90  J.Banks  Extract from GOTSTP
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,ROBANK.
      COMMON /GOTIME/ TT1,TT0,ILAST
      REAL TT1,TT0
      INTEGER ILAST
      CALL TIMEX(TT1)
      IF(ILAST.NE.0) IQ(LMCS+ILAST)=IQ(LMCS+ILAST)+INT(100.*(TT1-TT0))
      TT0=TT1
      ILAST=0
      RETURN
      END
+DECK,GOTSTP
      SUBROUTINE GOTSTP
*.
*...GOTSTP   Time GOPAL tracking
*.
*. COMMON    :
*. SEQUENCE  :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    : GUSTEP
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 131.0
*. CREATED   : 16-Jan-90
*. LAST MOD  : 28-Sep-94  
*.
*. Modification Log.
*. 28-Sep-94   C.P.Ward      Add TE
*. 24-Sep-93   J.E.Conboy    Reset volumes & levels for FD,SW & BP
*. 17-Dec-92   D.R.Ward      Add SW ???
*. 20-Sep-91   D.R.Ward      Fix FD level
*. 19-Feb-90   D.R.Ward      Mods for MEL/MER
*. 22-Feb-90   J.Banks       GOTSTE -> seperate routine for Apollo
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCVOLU.
+SEQ,ROBANK.
      COMMON /GOTIME/ TT1,TT0,ILAST
      REAL TT1,TT0
      INTEGER ILAST
      LOGICAL KILROY
      INTEGER NNAME,I,ICURR
      PARAMETER (NNAME=31)
      INTEGER  INAME(NNAME),JNDEX(NNAME),ILEV(NNAME)
      CHARACTER*4 CNAME(NNAME)
*
      INTEGER         IX0, IXBP, IXCD, IXCO, IXTB, IXPB, IXEB,
     +                     IXCP, IXPE, IXEE, IXHB, IXHE, IXHP,
     +                     IXMB, IXME, IXFD, IXOP, IXSW, IXTE
*
      PARAMETER       (IX0=90)
      PARAMETER       ( IXBP=IX0+ 1, IXCP=IX0+ 7, IXMB=IX0+13,
     +                  IXCD=IX0+ 2, IXPE=IX0+ 8, IXME=IX0+14,
     +                  IXCO=IX0+ 3, IXEE=IX0+ 9, IXFD=IX0+15,
     +                  IXTB=IX0+ 4, IXHB=IX0+10, IXOP=IX0+16,
     +                  IXPB=IX0+ 5, IXHE=IX0+11, IXSW=IX0+17,
     +                  IXEB=IX0+ 6, IXHP=IX0+12, IXTE=IX0+18)
*
*-    NB  FDT-, FDC- volumes ( FD tracking ) must preceed their
*       Mothers ( FDR-, FDL- ) which are Beampipe.
*
      DATA CNAME/'EB  ','EE  ','C   ','COI+','HB  ','SWFD',
     +           'CP0+','CP1+','CP2+','CP3+','CP4+','HP  ',
     +           'FDT-','FDC-','BTU1','TB  ','PB  ','HBPV',
     +           'HE  ','EES1','EES2','PE  ','HST+','HSB+',
     +           'HRO+','MEL ','MER ','MB  ','FDR-','FDL-',
     +           'TE  '/
*
      DATA JNDEX/  IXEB,  IXEE,  IXCD,  IXCO,  IXHB,  IXSW,  
     +             5*IXCP,                            IXHP,  
     +             IXFD,  IXFD,  IXBP,  IXTB,  IXPB,  IXHB,  
     +             IXHE,  2*IXEE,       IXPE, 3*IXHE, 
     +                    IXME,   IXME, IXMB,  IXBP,  IXBP,
     +             IXTE /
*
      DATA ILEV/      3,  4,  3,  4,  2,  4,  
     +                3,  4,  4,  4,  4,  4,  
     +                4,  4,  3,  4,  4,  2,  
     +                2,  4,  4,  4,  2,  2,  
     +                3,  2,  2,  2,  3,  3,
     +                4 /
      DATA KILROY/.FALSE./
*
      IF(.NOT.KILROY) THEN
         DO 10 I=1,NNAME
            CALL UCTOH(CNAME(I),INAME(I),4,4)
  10     CONTINUE
         KILROY=.TRUE.
         ILAST=0
      ENDIF
*
      DO 20 I=1,NNAME
         IF(NAMES(ILEV(I)).EQ.INAME(I) .AND. NLEVEL.GE.ILEV(I)) THEN
            ICURR=JNDEX(I)
            GO TO 21
         ENDIF
  20  CONTINUE
      ICURR=106
  21  IF(ICURR.NE.ILAST) THEN
        CALL TIMEX(TT1)
        IF(ILAST.NE.0) IQ(LMCS+ILAST)=IQ(LMCS+ILAST)+INT(100.*(TT1-TT0))
        TT0=TT1
        ILAST=ICURR
      ENDIF
      RETURN
      END
+DECK,GOVRSN.
      SUBROUTINE GOVRSN
*.
*...GOVRSN  Print the GOPAL version number and compilation date.
*.
*. COMMON    :
*. SEQUENCE  : DATEQQ GCUNIT        QFTITL TIMEQQ   GOVERS
*. CALLS     : GMAIL
*. CALLED    : UGINIT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.01
*. CREATED   : 25-Dec-84
*. LAST MOD  : 26-Jul-88
*.
*. Modification Log.
*.  2-Dec-90   D.R.Ward        Protect for incompatible versions
*. 26-Jul-88   S.W.O'Neale     Use LASTMO
*. 25-Apr-88   D.R.Ward        Strong typing
*.  2-Feb-88   D.R.Ward        Store GOPAL version number in COMMON
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.  9-May-86   S.O'Neale       Introduce GMAIL for printing.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER I1,I2,I3,IDATQQ,ITIMQQ
+SEQ,GCBANK
+SEQ,GOVERS.
+SEQ,GCUNIT.
+SEQ,DATEQQ
+SEQ,TIMEQQ
*--
*--  Patchy provides the date and time and the PAM file title
*--  when the source code is assembled from the material on the
*--  PAM file. The header card on the GOPAL Pam conforms to the
*--  format required by the Patchy auxillary programs.
*--
      WRITE(CHMAIL,1100)
      CALL GMAIL(1,0)
      READ(CHMAIL,1000) I1,I2,I3
      IGOVER=100*I1+I2
      IGOSVE=I3
      IGEVER=100.*GVERSN
+SELF,LASTMOD.
      LASTMO=0
+SELF.
      WRITE(CHMAIL,1200) IDATQQ,ITIMQQ
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1300) LASTMO
      CALL GMAIL(0,1)
      IF(IGEVER.LT.314) THEN
         CHMAIL=' >>>> This version of GOPAL needs GEANT >=314 '
         CALL GMAIL(1,1)
         CHMAIL=' >>>> Aborting the run !!!!!!!!!!!!!!!!!!!! '
         CALL GMAIL(1,1)
         STOP
      ENDIF
 1000 FORMAT(20X,I1,1X,I2,1X,I2)
 1100 FORMAT(' *****      ',
+SEQ,QFTITLE,N=24.
     +       ,'       *****')
 1200 FORMAT(' *****  Library compiled on ',I6,' at ',I4,' *****')
 1300 FORMAT(' *****  Last modifications dated ',I6,'    *****')
      END
+DECK,GRUN.
      SUBROUTINE GRUN
*.
*...GRUN     GEANT routine - code moved to QNEXT.
*.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : QNEXTE
*. CALLED    : GEANT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 31-Dec-86
*. LAST MOD  : 25-Apr-88
*.
*. Modification Log.
*. 25-Apr-88   D.R.Ward      Strong typing
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      CALL QNEXTE
      RETURN
      END
+DECK,GTIME.
      LOGICAL FUNCTION GTIME( IDUMMY)
*.
*.
*...GTIME   Check CPU limits, and keep track of frequency of
*.          calls. If call interval exceeds end of run time (TIMEND)
*.          then TIMEND is increased to FTIME*TIMAX, the largest 
*.          recorded interval
*.
*.  CALLS     : TIMEL ( KERNLIB ), REPORT
*.
*.  CALLED    : QNEXT 
*.
*.  AUTHOR    : J.E.Conboy, University College London UCLVA::JEC
*.  VERSION   : 1.00
*.  CREATED   : 19-6-1989
*.  LAST MOD  :  5-Dec-97
*.
*. Modification log
*.  5-Dec-97 M.Schroder Initialise NOVER and TIMAX to 0
*. 14-Mar-97  C.P.Ward Remove extra words from GCTIME and use local
*.                     variables instead
*.
*.**********************************************************************
*
+CDE,GCUNIT,GCTIME,GCFLAG,RCREP.
*.
      REAL     TIMLAS, TIMAX, DTIME
      INTEGER  NTIMES, NOVER, NOVLIM
      SAVE     TIMLAS, TIMAX, DTIME, NTIMES, NOVER
      LOGICAL INI
*.
      REAL TIMNOW, FTIME
*.
      DATA INI / .TRUE. /
+SELF,Z=NOVLIM.
      DATA  NOVLIM / 3 /, FTIME / 1.25 /
+SELF.
*.
      CALL TIMEL( TIMNOW)
*.
      IF ( INI  )                                  THEN
           NTIMES  =  0
           INI     =  .FALSE.
           TIMLAS  =  TIMNOW
           NOVER   = 0
           TIMAX   = 0
                                                   ENDIF
      NTIMES  =  NTIMES  + 1
      DTIME   =  TIMLAS - TIMNOW
      TIMAX   =  AMAX1( TIMAX, DTIME )
      IF( DTIME .GT. TIMEND )    NOVER  =  NOVER + 1
*.
*.              Check for significant excess times..
*.
      IF( NOVER .GT. NOVLIM )                      THEN
          WRITE( CHREP, 1010) NOVER,TIMEND, FTIME*TIMAX
          CALL REPORT( 'GTIME', 1, 'WARNING')
+SELF,Z=GTIME_RESET.
          TIMEND  =  FTIME*TIMAX
          NOVER  =  0
+SELF.
                                                   ENDIF
*.
      IF( TIMNOW .GT. TIMEND )                     THEN
           GTIME  =  .TRUE.
+SELF,IF=*DEBUG.
D           IF( IDEBUG .NE. 0)                    THEN
D             WRITE( CHMAIL, 1002) TIMNOW
D             CALL GMAIL( 0, 2 )
D                                                 ENDIF
+SELF.
      ELSE
*.
           GTIME  =  .FALSE. 
           WRITE( CHREP, 1000) TIMNOW
           CALL REPORT( 'GTIME', 2, 'W' )
           WRITE( CHREP, 1001) NTIMES, TIMAX
           CALL REPORT( 'GTIME', 3, 'I' )
      ENDIF
*.
      TIMLAS  =  TIMNOW
      RETURN
 1000 FORMAT( 'Terminating job, only ',F8.2
     F,                    ' seconds remaining ')
 1001 FORMAT( I20,' calls were made, max interval ',F8.2,' secs')
 1002 FORMAT( F8.2,' secs remain ')
 1010 FORMAT( I3,' call intervals exceeded ',F8.2,' secs;'
     F,          ' TIMEND reset to ',F8.2,' secs ')
      END
+DECK,GUDIGI.
      SUBROUTINE GUDIGI
*.
*...GUDIGI  User routine to organise digitization
*.
*.   User subroutine GUDIGI is called when all tracking is performed
*.   to steer the calculation of the various digits which would be
*.   generated in the OPAL detector.
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCFLAG GCKINE GCLIST GCLUND GCNUM  GOFLAG LINKRA
*. CALLS     : CJDIGI CVDIGI CZDIGI DATIME DZSHOW EBDIGI EEDIGI FDDIGI
*. CALLS     : GMAIL  GPRINT GRLEAS HBDIGI HEDIGI HPDIGI MBDIGI MEDIGI
*. CALLS     : MZBOOK MZIOCH PBDIGI PEDIGI TBDIGI UCTOH  ZPHASE ZSHUNT
*. CALLS     : GOHFIL MZPUSH GOTRCO
*. CALLED    : GTRIG
*.
*. BANKS L   : CHEA   DA     EX     MC     REV
*. BANKS U   : GENE
*. BANKS M   : TREE
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  :  3-Feb-99
*.
*. Modification Log.
*.  3-Feb-99   C.P.Ward        Add FFDIGI call
*. 28-Sep-94   C.P.Ward        Add TEDIGI call
*. 11-Apr-94   C.P.Ward        Remove unused sequences;
*.                             fix mixed mode arithmetic.
*. 17-Dec-92   D.R.Ward        Add SWDIGI call
*. 16-Jan-90   D.R.Ward        Add SIDIGI call
*. 12-Jan-90   D.R.Ward        Add timing; DZVERI
*.  7-Jun-89   D.R.Ward        Move 40
*. 11-May-89   D.R.Ward        Don't shunt KINE/VERT banks into event structure
*.  3-Jan-88   H.Kreutzmann    Add call to CJEVEN
*. 26-Sep-88   D.R.Ward        Add call to ODNODE
*.  1-Sep-88   D.R.Ward        Call OPTRIG to simulate the trigger
*.  1-Aug-88   D.R.Ward        Move call to GOHFIL
*. 19-Jul-88   S.L.Lloyd       Don't skip SM routines if no TREE
*.  4-May-88   D.R.Ward        Add calls to SM routines
*. 25-Apr-88   D.R.Ward        Strong typing
*. 21-Apr-88   S.L.Lloyd       Implement generator banks.
*. 14-Apr-88   D.R.Ward        Use CHREP for REPORT
*. 14-Feb-88   D.R.Ward        Move booking of REV etc to REVBOK.
*. 16-Feb-88   S.W.O'Neale     Minor bug fixed
*.  2-Feb-88   D.R.Ward        Add version numbers to MC bank
*.  2-Dec-87   D.R.Ward        Test on IEOTRI
*.  1-Dec-87   D.R.Ward        Shunt UTHD (if it exists)
*. 30-Nov-87   D.R.Ward        Use of REPORT
*. 27-Nov-87   D.R.Ward        Call GOHFIL
*. 11-Nov-87   D.R.Ward        store random number seeds in MC bank
*.  1-Sep-87   D.R.Ward        reset names of banks SHUNTed to raw data
*. 13-Mar-87   D.R.Ward        drop old raw data if present.
*. 28-Jan-87   D.R.Ward        add LINKRA
*. 31-Dec-86   S.O'Neale       set operation phase for ZEBRA recovery
*. 11-Dec-86   A.C.McPherson   Call CVDIGI
*. 16-Sep-86   S.O'Neale       Add DATR header bank for Raw Data in the
*.                             style of ROPE.
*. 26-May-86   S.O'Neale       Introduce PE digitization call.
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*. 10-May-86   S.O'Neale       Introduce GMAIL for printing.
*. 11-Jun-85   J.J.Dumont      Call digits for CZ
*. 10-Jun-85   J.Mallet        Call digits for TB T-o-F
*. 10-May-85   A.Possoz        Call digits for PB presampler
*. 21-Dec-84   S.O'Neale       Call digits for HB and HE.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,RCREP.
+SEQ,ROBANK
+SEQ,GCUNIT
+SEQ,GCLIST
+SEQ,GCFLAG
+SEQ,GOFLAG
+SEQ,GCLUND
+SEQ,GCKINE
+SEQ,GCNUM
+SEQ,LINKGO
+SEQ,CRO.
      REAL TIM0,TIM1,TIM2
      LOGICAL LZVERI
      INTEGER IITEST(17),LGENE,LTREE,NGEN,LENT,LENGTH,LESS,IJTEST,IGET
      INTEGER IUCOMP,JUCOMP
      EXTERNAL IUCOMP,JUCOMP
      CALL TIMEX(TIM0)
      LZVERI=.FALSE.
      IF(JUCOMP('DIGI',JZVERI,10).NE.0) LZVERI=.TRUE.
      IF(LZVERI) CALL DZVERI('Entry to GUDIGI',IXDIV,'CLSU')
*--   Set operation phase 30 for ZEBRA recovery.
      CALL ZPHASE(30)
*
*--  Tidy up the kinematics stage.
*
      IF (LMC.LE.0) GO TO 10
*
*--  Save the GEANT VERTX structure
*
      IQ(LMC+2)=NVERTX
*     CALL ZSHUNT(IXSTOR,JVERTX,LMC,-2,1)
*     JVERTX=LQ(LMC-2)
*     CALL UCTOH('VERH',IQ(JVERTX-4),4,4)
*
*--  and the GEANT KINE structure
*
      IQ(LMC+3)=NTRACK
*     CALL ZSHUNT(IXSTOR,JKINE,LMC,-3,1)
*     JKINE=LQ(LMC-3)
*     CALL UCTOH('KINH',IQ(JKINE-4),4,4)
*
      LGENE = LQ(LMC-1)
      IF (LGENE.LE.0) GO TO 10
*
*--  Reverse push the generator banks if necessary.
*
      LTREE = LQ(LGENE-1)
      IF (LTREE.LE.0) GO TO 10
      NGEN = IQ(LGENE+1)
      LENT = IQ(LGENE+5)
      LENGTH = IQ(LTREE-1)
      LESS = NGEN*LENT - LENGTH
      CALL MZPUSH (IXSTOR,LTREE,0,LESS,' ')
*
*--  Accumulate generated particle statistics.
*
      CALL GOTRCO
*
*--  Skip digitisation if digits are read from tape
*--  or if not required by DIGI card
*
   10 CONTINUE
*
*--   NODEtector mode - call ODNODE is all we have to do.
*
      IF(NODET.EQ.1) THEN
         CALL ODNODE
         CHREP='ODNODE called successfully'
         CALL REPORT('GUDIGI',30,'S')
         CALL UCOPY(IQ(LREV+1),IUHEAD,NUHMAX)
         CALL USBAT(0)
         GO TO 40
      ENDIF
*
*--  If SMEA calorimeter simulation - finish up the job.
*
      IF(JUCOMP('SMEA',LCAL,NCAL).NE.0) THEN
         CALL SMEMMG
         CALL SMHCMG
      ENDIF
*
      IF(NGET.LE.0)GO TO 20
      CALL UCTOH('DIGI',IJTEST,4,4)
      IGET=IUCOMP(IJTEST,LGET,NGET)
      IF(IGET.NE.0)GO TO 30
   20 IF(NDIGI.EQ.0) GOTO 40
*
*--
*--  Call the detector's digitising routine if the detector
*--  is specified via the DIGI data card.
*--
*--  Routines are provided for
*--  SI CJ CV CZ EB EE FD HB HE HP MB ME PB PE TB SW TE
*--
*--  Consult the documentation provided by the detector group
*--  to find the status of the DIGI code.
*--
      IF(LZVERI) CALL DZVERI('Before xxDIGI calls',IXDIV,'CLSU')
 
      CALL UCTOH(
     +'CV  CJ  CZ  EB  EE  FD  HB  HE  HP  '//
     +'MB  ME  PB  PE  TB  SI  SW  TE  ',
     +IITEST,4,68)
      IF(IUCOMP(IITEST(1),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL CVDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='CVDIGI called successfully'
         CALL REPORT('GUDIGI',1,'S')
         IF(LZVERI) CALL DZVERI('After CVDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+11)=IQ(LMCS+11)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(2),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL CJEVEN
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='CJEVEN called successfully'
         CALL REPORT('GUDIGI',2,'S')
         IF(LZVERI) CALL DZVERI('After CJDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+12)=IQ(LMCS+12)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(3),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL CZDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='CZDIGI called successfully'
         CALL REPORT('GUDIGI',3,'S')
         IF(LZVERI) CALL DZVERI('After CZDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+13)=IQ(LMCS+13)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(4),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL EBDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='EBDIGI called successfully'
         CALL REPORT('GUDIGI',4,'S')
         IF(LZVERI) CALL DZVERI('After EBDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+16)=IQ(LMCS+16)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(5),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL EEDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='EEDIGI called successfully'
         CALL REPORT('GUDIGI',5,'S')
         IF(LZVERI) CALL DZVERI('After EEDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+18)=IQ(LMCS+18)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(6),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL FDDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='FDDIGI called successfully'
         CALL REPORT('GUDIGI',6,'S')
         IF(LZVERI) CALL DZVERI('After FDDIGI',IXDIV,'CLSU')
         CALL FFDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='FFDIGI called successfully'
         CALL REPORT('GUDIGI',7,'S')
         IF(LZVERI) CALL DZVERI('After FFDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+24)=IQ(LMCS+24)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(7),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL HBDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='HBDIGI called successfully'
         CALL REPORT('GUDIGI',8,'S')
         IF(LZVERI) CALL DZVERI('After HBDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+19)=IQ(LMCS+19)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(8),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL HEDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='HEDIGI called successfully'
         CALL REPORT('GUDIGI',9,'S')
         IF(LZVERI) CALL DZVERI('After HEDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+20)=IQ(LMCS+20)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(9),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL HPDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='HPDIGI called successfully'
         CALL REPORT('GUDIGI',10,'S')
         IF(LZVERI) CALL DZVERI('After HPDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+21)=IQ(LMCS+21)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(10),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL MBDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='MBDIGI called successfully'
         CALL REPORT('GUDIGI',11,'S')
         IF(LZVERI) CALL DZVERI('After MBDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+22)=IQ(LMCS+22)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(11),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL MEDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='MEDIGI called successfully'
         CALL REPORT('GUDIGI',12,'S')
         IF(LZVERI) CALL DZVERI('After MEDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+23)=IQ(LMCS+23)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(12),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL PBDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='PBDIGI called successfully'
         CALL REPORT('GUDIGI',13,'S')
         IF(LZVERI) CALL DZVERI('After PBDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+15)=IQ(LMCS+15)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(13),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL PEDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='PEDIGI called successfully'
         CALL REPORT('GUDIGI',14,'S')
         IF(LZVERI) CALL DZVERI('After PEDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+17)=IQ(LMCS+17)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(14),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL TBDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='TBDIGI called successfully'
         CALL REPORT('GUDIGI',15,'S')
         IF(LZVERI) CALL DZVERI('After TBDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+14)=IQ(LMCS+14)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(15),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL SIDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='SIDIGI called successfully'
         CALL REPORT('GUDIGI',16,'S')
         IF(LZVERI) CALL DZVERI('After SIDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+26)=IQ(LMCS+26)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(16),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL SWDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='SWDIGI called successfully'
         CALL REPORT('GUDIGI',17,'S')
         IF(LZVERI) CALL DZVERI('After SWDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+27)=IQ(LMCS+27)+INT(100.*(TIM2-TIM1))
      ENDIF
      IF(IUCOMP(IITEST(17),LDIGI,NDIGI).NE.0) THEN
         CALL TIMEX(TIM1)
         CALL TEDIGI
         IF(IEOTRI.NE.0) GO TO 40
         CHREP ='TEDIGI called successfully'
         CALL REPORT('GUDIGI',18,'S')
         IF(LZVERI) CALL DZVERI('After TEDIGI',IXDIV,'CLSU')
         CALL TIMEX(TIM2)
         IQ(LMCS+28)=IQ(LMCS+28)+INT(100.*(TIM2-TIM1))
      ENDIF
*--
*--  Release unused space in JDIGI
      CALL GRLEAS(JDIGI)
*--
*--  Now call the trigger simulation
*
      CALL TIMEX(TIM1)
      CALL OPTRIG
      CALL TIMEX(TIM2)
      IQ(LMCS+25)=IQ(LMCS+25)+INT(100.*(TIM2-TIM1))
      CHREP='Trigger simulation performed'
      CALL REPORT('GUDIGI',19,'S')
      IF(LZVERI) CALL DZVERI('After OPTRIG',IXDIV,'CLSU')
*__
*--  Print the DIGI data structure if the debug flag is on
*--  together with SWITch 4 non zero.
   30 CONTINUE
      CHREP='DIGITizations completed.'
      CALL REPORT('GUDIGI',20,'S')
   40 CONTINUE
      IF(IDEBUG.NE.0)THEN
         IF(ISWIT(4).NE.0) THEN
            CALL GMAIL(1,1)
            CALL GPRINT('DIGI','*   ')
            CALL DZSHOW('Raw data structure',IXSTOR,LREV,'LV',0,0,0,0)
         ENDIF
      ENDIF
*
*--   Accumulate statistics
*
      CALL HCDIR('//PAWC/GOPAL',' ')
      CALL GOHFIL
      CALL HCDIR('//PAWC',' ')
      CALL TIMEX(TIM1)
      IQ(LMCS+5)=IQ(LMCS+5)+INT(100.*(TIM1-TIM0))
      RETURN
      END
+DECK,GUHADR.
      SUBROUTINE GUHADR
*.
*...GUHADR  Hadronic interactions for the current step.
*.
*.    GUHADR is a GEANT3 user routine called when a hadronic process
*.    has been selected in the current step.
*.
*. COMMON    :
*. SEQUENCE  : GCUNIT
*. CALLS     : GHCASC GHEISH GHTATI GMAIL
*. CALLED    : GMUNU  GPFIS  GTHADR GTNEUT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 25-Aug-92
*.
*. Modification Log.
*. 25-Aug-92   D.R.Ward      Include HADR 4 (FLUKA) option.
*.  2-May-88   R.J.Hemingway Remove all hadronic secondaries if IHADR=0.
*. 25-Apr-88   D.R.Ward      Strong typing
*. 23-Aug-86   S.O'Neale       Tidy SELF selections and documentation.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,GCUNIT,IF=-GHEISHA.
+SEQ,GCPHYS.
+SEQ,GCTRAK.
+SEQ,GCKING.
      IF(IHADR.EQ.0)THEN
         ISTOP=2
         KCASE=NAMEC(12)
         DESTEP=DESTEP+GEKIN
         GO TO 10
      ENDIF
*--  Call GHEISH if GHEISHA is USE selected from the patchy cradle.
      IF(IHADR.NE.4) THEN
+SELF,IF=GHEISHA.
         CALL GHEISH
+SELF.
      ELSE
+SELF,IF=FLUKA.
         CALL FLUFIN
+SELF.
      ENDIF
+SELF,IF=-GHEISHA,IF=-FLUKA.
*--   If the user calls GUHADR and no hadronic interaction package
*--   is defined then the program is stopped.
      CHMAIL=' GUHADR: NO HADRONIC INTERACTION PACKAGE IN USE '
      CALL GMAIL(1,1)
      STOP 16
+SELF.
   10 RETURN
      END
+DECK,GUKINE.
      SUBROUTINE GUKINE
*.
*...GUKINE  Produce primary vertex and tracks.
*.
*. COMMON    :
*. SEQUENCE  : GCFLAG GCKINE GCLIST GCUNIT GOUNIT RCREP GCBANK
*. SEQUENCE  : LINKRA GOSEED GOXTRA
*. CALLS     : GGET   KILUND GMAIL  KIMUON KIPION KIUSER UCTOH  VTXMOD
*. CALLS     : ZPHASE  PHASE GOLIFE GOKINE KISING
*. CALLED    : GTRIG
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 24-Feb-99
*.
*. Modification Log.
*. 24-Feb-99   C.P.Ward        Set quadrupole field according to Ebeam
*. 12-Jan-95   C.P.Ward        Run files allowed for DECS,QMVAOS
*. 30-Nov-94   C.P.Ward        Call GFIN with opt 'K'
*. 17-Aug-92   D.R.Ward        GGET --> GFIN
*. 16-Sep-91   D.R.Ward        Call SMBEG
*.  3-May-91   S.L.Lloyd       Zero NWXTRA counter.
*. 12-Jan-90   D.R.Ward        Add timing calls; set proc name (VAX)
*. 20-Dec-89   D.R.Ward        Use of RUN file for multiprocessing
*.  4-Dec-89   D.R.Ward        Set IFBOOK
*. 09-Jun-89   J.W.Gary        Remove call to GOLIFE for KIDISK
*. 18-Apr-89   D.R.Ward        Set IPAOLD
*. 05-Apr-89   J.W.Gary        Add call to KIDISK
*.  8-Feb-89   J.Banks         Don't call GOKINE is all smear mode
*. 26-Sep-88   D.R.Ward        Don't call GOKINE if NODEtector
*.  1-Aug-88   D.R.Ward        Store seed at end of GUKINE.
*.  1-Aug-88   D.R.Ward        Test for GGET eof
*. 25-Jul-88   D.R.Ward        Move random number fixup to QNEXT
*. 22-Jul-88   D.R.Ward        Handle random number repeat problem?
*.  9-May-88   D.R.Ward        Add GCNUM
*.  6-May-88   D.R.Ward        Store # primary vertices in GOSTAT
*. 25-Apr-88   D.R.Ward        Strong typing
*. 19-Apr-88   S.L.Lloyd       Change to KILUND and add GULIFE and GOKIN
*. 14-Apr-88   D.R.Ward        Use CHREP for REPORT
*. 14-Feb-88   D.R.Ward        Call REVBOK
*. 18-Jan-88   P.M.Watkins     Add call to KICOSM (IKINE=6)
*. 30-Nov-87   D.R.Ward        Use of REPORT
*. 27-Nov-87   D.R.Ward        Call G1PART if IKINE=5
*. 31-Dec-86   S.O'Neale       Set operation phase for ZEBRA recovery
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*. 10-May-86   S.O'Neale       Introduce GMAIL for printing.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCNUM.
+SEQ,GCKINE
+SEQ,GCFLAG
+SEQ,GCLIST
+SEQ,GCUNIT
+SEQ,GOUNIT
+SEQ,ROBANK
+SEQ,ROPAR.
+SEQ,RCNTRL
+SEQ,LINKGO
+SEQ,GOSTAT
+SEQ,GOSEED
+SEQ,GOFLAG
+SEQ,GOLOGI
+SEQ,GOFILE.
+SEQ,GOXTRA.
+SEQ,FFCONS.
      CHARACTER*15 PNAME
      REAL    TIM0,TIM1
      INTEGER LENT,LENJ,IOTREE,IOJETS,ITRY,IDENT,IER,IJTEST,LGENE
      INTEGER IUCOMP,J
      EXTERNAL IUCOMP
+SELF,IF=VAX,DECS,QMVAOS.
      INTEGER JUCOMP
      EXTERNAL JUCOMP
+SELF.
      PARAMETER (LENT=22, LENJ=8)
      LOGICAL FIRST
      DATA FIRST/.TRUE./
*
      CALL TIMEX(TIM0)
      IQ(LMCS+1)=IQ(LMCS+1)+1
      IF (FIRST) THEN
         CALL MZFORM ('TREE','/ 10I 12F',IOTREE)
         CALL MZFORM ('JETS','/ 3I 5F',IOJETS)
         FIRST = .FALSE.
      ENDIF
*
*--   Set operation phase 10 for ZEBRA recovery.
*
      IFBOOK=1
      CALL ZPHASE(10)
*
*--   Check SKIP/SELECT cards
*
      J=0
      CALL GOSELQ(J)
      IF(J.NE.0) THEN
         IEOTRI=1
         IEORUN=1
         GO TO 40
      ENDIF
+SELF,IF=VAX.
      IF(IVAXPN.NE.0) THEN
         WRITE(PNAME,'(I5,'':'',I6.6)',ERR=199) IDRUN,IDEVT
 199     CALL SYS$SETPRN(PNAME)
      ENDIF
+SELF.
*
*--   Lift ROPE top banks
*
      CALL REVBOK
*
*--   Read data from unit 1 if data card GET specified
*
      IF(NGET.EQ.0)GO TO 20
      ITRY=0
   10 ITRY=ITRY+1
      IF(ITRY.GT.2)GO TO 20
*
*drw  CALL GGET(LGGET,CCGET,NGET,IDENT,IER)
      IER=0
      IDENT=-1
      IF(NGET.GT.0) THEN
         CALL GFIN(LGGET,CCGET,NGET,0,'K',IER)
         IF(IER.GE.0) IDENT=0
      ENDIF
*drw      IF(IER.GT.2) THEN
      IF(IER.LT.0) THEN
         CHREP='Unexpected end of GET input - stop the run'
         LREV=0
         CALL REPORT('GUKINE',3,'F')
         IEOTRI=1
         IEORUN=1
         GO TO 40
      ENDIF
*
      IF(IDENT.LE.0)GO TO 10
      CALL UCTOH('KINE',IJTEST,4,4)
      IF(IUCOMP(IJTEST,LGET,NGET).NE.0) THEN
         LREV=LQ(JHEAD-1)
         LDA=LQ(LREV-3)
         LEX=LQ(LREV-1)
         LUT=LQ(LREV-2)
         LMC=LQ(LEX-2)
         LCHEA=LQ(LMC-4)
         LCD=LQ(LREV-4)
         LEC=LQ(LREV-5)
         LHC=LQ(LREV-6)
         LMU=LQ(LREV-7)
         LFO=LQ(LREV-8)
         LOD=LQ(LREV-10)
         CHREP='Kinematics GOT'
         GO TO 30
      ENDIF
*
*--   Kinematic generators may be seleceted according to the
*--   first variable (IKINE) on the KINE data card.
*--   IKINE  Generator routine
*--
*--       1  KILUND Generates e+e- --> Hadrons with the LUND generator.
*--                 By default a mixture of flavours are generated
*--                 at 94 GeV centre of mass energy.
*--
*--       2  KIPION Generates a few pions.
*--
*--       3  KIMUON Generates a single muon.
*--
*--       4  KIUSER This allows the user to write his own generator
*--                 without adding to the maintenance load for
*--                 GOPAL and GEANT.
*--
*--       5  KISING Call single particle generator (useful for debugging
*--                 and testing)
*--
*--       6  KICOSM Cosmic ray generator
*--
*--       7  KIDISK read generator event record from disk,
*--                 fill TREE and JET banks, call GOLIFE
*--
*
   20 CONTINUE
*
*--   Book generated particle top bank.
*
      CALL MZBOOK (IXDIV,LGENE,LMC,-1,'GENE',3,3,8,2,0)
*
      IQ(LGENE+5) = LENT
      IQ(LGENE+6) = LENJ
      IQ(LGENE+7) = IOTREE
      IQ(LGENE+8) = IOJETS
*
      IQ(LMC+1) = IKINE
*
      NWXTRA = 0
*
      IF(IKINE.EQ.1) THEN
         CALL KILUND
         CALL GOLIFE
      ELSEIF(IKINE.EQ.2) THEN
         CALL KIPION
      ELSEIF(IKINE.EQ.3) THEN
         CALL KIMUON
      ELSEIF(IKINE.EQ.4) THEN
         CALL KIUSER
      ELSEIF(IKINE.EQ.5) THEN
         CALL KISING
      ELSEIF(IKINE.EQ.6) THEN
         CALL KICOSM
      ELSEIF(IKINE.EQ.7) THEN
         CALL KIDISK
*WJG 9/6/89    CALL GOLIFE
      ELSE
         WRITE(CHREP,FMT='('' No generator for KINE'',I6)') IKINE
         CALL REPORT('GUKINE',1,'C')
         IEOTRI=1
         IEORUN=1
         GO TO 40
      ENDIF
*
*-- Set quadrupole field strength according to beam energy
*
      IF(IQ(LREV+IIEBEA).GT.0.) QS0(2) = FLOAT(IQ(LREV+IIEBEA))/1000.
*
*-- Create GEANT kinematics banks from GOPAL generator bank.
*
      IF(NODET.NE.1 .AND. .NOT. LSMTRK) CALL GOKINE
*
*--  Print the VERTex and KINEmatics (track) banks if debugging
*--  is selected for this event and data card SWIT (1) is 1.
*
      CHREP =' Kinematics generated'
   30 CALL REPORT('GUKINE',2,'S')
      NVPRIM=NVERTX
      IF(IDEBUG.EQ.0)GO TO 40
      IF(MOD(ISWIT(1),10).NE.1)GO TO 40
      CALL GPRINT('VERT',0)
      CALL GPRINT('KINE',0)
*
   40 CALL GRNDMQ(JSEED(1),JSEED(2),1,'G')
+SELF,IF=VAX,DECS,QMVAOS.
      J=JUCOMP('RUNI',IONAME,NFILE)
      IF(J.NE.0) THEN
         REWIND IOUNIT(J)
         WRITE(IOUNIT(J),'(5I12)')IDRUN,IDEVT,JSEED(1),JSEED(2),IEVENT
         CLOSE(IOUNIT(J))
      ENDIF
+SELF.
*     Bodge to circumvent corruption of GCKINE in CJHIDI, or in generators.
      IPAOLD=-1
   99 CALL TIMEX(TIM1)
      IQ(LMCS+3)=IQ(LMCS+3)+INT(100.*(TIM1-TIM0))
      IF(LCDSM.OR.LCALSM) CALL SMBEG
      END
+DECK,GUOUT.
      SUBROUTINE GUOUT
*.
*...GUOUT  User routine called at the end of each event.
*.
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCFLAG GCLIST GOUNIT LINKRA
*. CALLS     : FZOUT  GFHSTA GSAVE  USOUT  ZPHASE GOTREE
*. CALLED    : GTRIG
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 26-Feb-97
*.
*. Modification Log.
*. 26-Feb-97   S.W.O.Neale     Add MCP spy code
*. 12-Jan-95   C.P.Ward        File opening/closing for DECS,QMVAOS as VAX
*. 11-Apr-94   C.P.Ward        Remove unused sequences;
*.                             fix mixed mode arithmetic.
*. 19-Jan-94   C.P.Ward        Drop SW working banks before o/p
*. 20-Dec-93   C.P.Ward        Fix call to GFOUT
*. 19-Nov-93   C.P.Ward        Call RODSWP to drop SI DST banks before o/p
*. 19-Feb-93   J.E.Conboy      Dont output constants for Luminosity runs
*. 17-Aug-92   D.R.Ward        GSAVE --> GFOUT
*. 29-May-91   D.R.Ward        Allow DD to handle CJ cheat
*. 25-Feb-91   D.R.Ward        Implement DDST; don't drop CHEAt words for DDST
*.  2-Dec-90   J.N.Banks       Fix APOLLO file opening
*. 19-Oct-90   J.E.Conboy      Save FDD (dense data ) on DST ( Cf ROEVNTA )
*. 18-Apr-90   D.R.Ward        Keep DD banks (if any)
*. 12-Jan-90   D.R.Ward        Add timing, bank size statistics
*.  4-Jan-90   D.R.Ward        Close o/p file each event (VAX DISK o/p only)
*.  6-Nov-89   D.R.Ward        Implement USSLCT
*.  1-Nov-89   D.R.Ward        Implement 'PROD' output
*.  9-Jun-89   S.W.O'Neale     Move REPORT call before event output
*.  2-Jun-89   D.R.Ward        Mods for new header
*. 31-May-89   D.R.Ward        Mods for use of *FILE cards
*. 17-May-89   D.R.Ward        Add argument to GOTREE
*. 15-Mar-89   D.R.Ward        Remove IOREV initialization
*. 10-Mar-89   D.R.Ward        Zero ROPE control flags before writing
*.  9-Mar-89   D.R.Ward        Call CJPACK
*.  8-Mar-89   D.R.Ward        Initialize IOREV
*. 13-Oct-88   D.R.Ward        Mods for GEANT312 (GSAVE)
*. 27-Sep-88   D.R.Ward        skip GOROPB if NODEtector; call GOHFL2
*.  8-Aug-88   D.R.Ward        Remove GOHEAD
*. 11-Jul-88   S.W.O'Neale     Error handling for IBM
*. 25-May-88   D.R.Ward        Don't drop KINE, VERTX structures!
*. 25-May-88   D.R.Ward        Fix bug with pilot record.
*. 24-May-88   D.R.Ward        Write RCO structure (instead of TEMP)
*. 17-May-88   D.Schaile       Remove free format write
*.  3-May-88   D.R.Ward        Option of output of DST only.
*.  2-May-88   A.Buijs         Change the Pilot record.
*.                             Fix small bugs due to misindentation.
*. 25-Apr-88   D.R.Ward        Strong typing
*. 22-Apr-88   S.L.Lloyd       Call GOTREE
*. 19-Apr-88   D.R.Ward        Call GOROPB
*. 14-Apr-88   D.R.Ward        Use CHREP for REPORT
*. 29-Jan-88   D.R.Ward        Don't call GSAVE if nothing to SAVE
*.  2-Dec-87   D.R.Ward        Use of REPORT
*. 25-Nov-87   D.R.Ward        Output raw data if 'RAWD' or 'DIGI' speci
*.  1-Sep-87   D.R.Ward        Output raw data only if 'DIGI' on SAVE ca
*. 15-Jul-87   D.R.Ward        Output constants banks for ROPE
*. 31-Dec-86   S.O'Neale       Set operation phase for ZEBRA recovery
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,RCEREP,IF=IBM.
+SEQ,RCREP
+SEQ,GCFLAG
+SEQ,GCLIST
+SEQ,ROBANK
+SEQ,GCUNIT
+SEQ,GOUNIT
+SEQ,GOFLAG
+SEQ,ROCPAR
+SEQ,LINKGO
+SEQ,ROPAR
+SEQ,GOFILE.
+SEQ,CRO.
+SEQ,ODPAR.
+SEQ,MCPSPY,IF=MCP.
      INTEGER IQUEST
      COMMON/QUEST/IQUEST(100)
      REAL     RG(NRGNRL),RT(NRECAL),TIM0,TIM1
      INTEGER  IG(NIGNRL),IT(NIECAL),NIM,NRM,NCLU
      INTEGER  ISRCO(NDRCO),ISCDC(NDCDC),ISECC(NDECC),ISHCC(NDHCC),
     +         ISFOC(NDFOC),ISODC(NDODC),ISMUC(NDMUC)
      INTEGER  KILROY,IER,I,J,JUCONS,INEW,K,LCJCH,LCJCE,LCJSH
      INTEGER  N, JBIT
      INTEGER  NBANKS,NDATAS,NLINKS,NWORDS
      CHARACTER*4 CNAME(9)
      LOGICAL  WANTED,LWDATA,LWPROD,LWDST,LWDDST
      INTEGER  JUCOMP
      EXTERNAL JUCOMP
      DATA CNAME/'CONO','DATO','PROO','DDSO','DSTO','CD0O','CD1O',
     +           'CD2O','CD3O'/
      DATA LWDATA/.FALSE./,LWPROD/.FALSE./,
     +     LWDST/.FALSE./,LWDDST/.FALSE./
      DATA KILROY/0/
      CALL TIMEX(TIM0)
*--   Set operation phase 40 for ZEBRA recovery.
      CALL ZPHASE(40)
*--
*--  Call GEANT system routine for histograms
*
      CALL HCDIR('//PAWC/GEANT',' ')
      CALL GFHSTA
      CALL HCDIR('//PAWC',' ')
*
*--  Call User's end of event routine
*
      CALL USOUT
*
*--  Save banks on tape
*    First the GEANT banks.
*
      IF(NSAVE.GT.0) THEN
         CALL GFOUT(LGSAVE,CCSAVE,NSAVE,1,' ',IER)
         WRITE(CHREP ,FMT='('' GEANT banks SAVEd on unit'',I5)')
     +   LGSAVE
         CALL REPORT('GUOUT',1,'S')
      ENDIF
      IUHEAD(IIRUN )=IQ(LREV+IIRUN )
      IUHEAD(IIEVT )=IQ(LREV+IIEVT )
*
*--   Write constants if this is our first time through.
*--   (this needs to be done elsewhere probably!)
*--   However, don't want to write out the ROPE processing flags,
*--   otherwise ROPE may get confused, so save them, zero them and then
*--   restore.
*
      IF(KILROY.EQ.0) THEN
         KILROY=999
         CALL MZIOCH(IOHEAD,2,'5I 9B -I')
         NUHEAD = NUHMAX
         CALL VZERO(IUHEAD,NUHEAD)
         IUHEAD(IIDAT )=105
         IUHEAD(IIEXPT)=IQ(LREV+IIEXPT)
         IUHEAD(IIDATE)=IQ(LREV+IIDATE)
         IUHEAD(IITIME)=IQ(LREV+IITIME)
*
*--   Save constants structure if *FILE 'CONS' 'DATA' 'DST ' or 'PROD'
         K=0
      N = 9
*-          Dont store the constants on Lumi DDST
      IF( JBIT( IUFLAG( IFLGLM), 1 ) .EQ. 1 )  N  =  3
      DO 5 I=1,N
            J=JUCOMP(CNAME(I),IONAME,NFILE)
            IF(J.NE.0) THEN
               JUCONS=IOUNIT(J)
               IF(K.EQ.0) THEN
                  CALL UCOPY(IQ(LRCO+1),ISRCO,NDRCO)
                  CALL UCOPY(IQ(LCDC+1),ISCDC,NDCDC)
                  CALL UCOPY(IQ(LECC+1),ISECC,NDECC)
                  CALL UCOPY(IQ(LHCC+1),ISHCC,NDHCC)
                  CALL UCOPY(IQ(LMUC+1),ISMUC,NDMUC)
                  CALL UCOPY(IQ(LFOC+1),ISFOC,NDFOC)
                  CALL UCOPY(IQ(LODC+1),ISODC,NDODC)
                  CALL VZERO(IQ(LRCO+1),NDRCO)
                  CALL VZERO(IQ(LCDC+1),NDCDC)
                  CALL VZERO(IQ(LECC+1),NDECC)
                  CALL VZERO(IQ(LHCC+1),NDHCC)
                  CALL VZERO(IQ(LMUC+1),NDMUC)
                  CALL VZERO(IQ(LFOC+1),NDFOC)
                  CALL VZERO(IQ(LODC+1),NDODC)
                  CALL ROSIZE(LRCO,'    ',NBANKS,NDATAS,NLINKS,NWORDS)
                  IQ(LMCS+31)=NWORDS
                  K=1
               ENDIF
+SELF,IF=VAX,DECS,QMVAOS.
               CALL GOOOUT(CNAME(I),INEW)
               IF(INEW.EQ.1) THEN
+SELF.
+SELF,IF=APOLLO,SUN,SGI,HPUX,IBMRT.
                 CALL GOOOUT(CNAME(I),INEW)
+SELF.
                 CALL FZOUT(JUCONS,IXCONS,LRCO ,1,' ',IOHEAD,
     +                      NUHEAD,IUHEAD)
                 WRITE(CHREP ,FMT=
     +           '('' Constants banks written to unit'','//'I5)') JUCONS
                 CALL REPORT('GUOUT',2,'I')
+SELF,IF=VAX,DECS,QMVAOS.
               ENDIF
               CALL GOCOUT(CNAME(I))
+SELF.
            ENDIF
   5     CONTINUE
         IF(K.NE.0) THEN
            CALL UCOPY(ISRCO,IQ(LRCO+1),NDRCO)
            CALL UCOPY(ISCDC,IQ(LCDC+1),NDCDC)
            CALL UCOPY(ISECC,IQ(LECC+1),NDECC)
            CALL UCOPY(ISHCC,IQ(LHCC+1),NDHCC)
            CALL UCOPY(ISMUC,IQ(LMUC+1),NDMUC)
            CALL UCOPY(ISFOC,IQ(LFOC+1),NDFOC)
            CALL UCOPY(ISODC,IQ(LODC+1),NDODC)
         ENDIF
      ENDIF
*
*--   Now drop all the GEANT banks, so ROPE can have the space.
*
      CALL MZDROP(IXSTOR,JHITS ,'L')
      CALL MZDROP(IXSTOR,JDIGI ,'L')
      CALL MZDROP(IXSTOR,JXYZ  ,'L')
      CALL MZDROP(IXSTOR,JSTAK ,'L')
*
*--   Next call ROPE (unless NODEtector mode).
*
      IF(JUCOMP('ROPE',JZVERI,10).NE.0)
     +     CALL DZVERI('Before ROPE called',IXDIV,'CLSU')
      CALL TIMEX(TIM1)
      IQ(LMCS+6)=IQ(LMCS+6)+INT(100.*(TIM1-TIM0))
      TIM0=TIM1
      IF(NODET.NE.1) THEN
        CALL GOROPB
        CALL TIMEX(TIM1)
        IQ(LMCS+7)=IQ(LMCS+7)+INT(100.*(TIM1-TIM0))
        TIM0=TIM1
      ENDIF
      CALL HCDIR('//PAWC/GOPAL',' ')
      CALL GOHFL2
      CALL HCDIR('//PAWC',' ')
*
*--   Store some DST info in header, if available.
*
      IF(LQ(LREV-LLOD).LE.0) GO TO 80
      IF(LQ(LOD-1).LE.0) GO TO 80
      CALL ODFBLK('GNRL',0,NIGNRL,IG,NIM,NRGNRL,RG,NRM)
      IF(NIM.EQ.0) GO TO 80
      IQ(LREV+IINCTR)=IG(JGNCTR)
      IQ(LREV+IINMUO)=IG(JGNMUO)
      IQ(LREV+IINVTX)=IG(JGNVTX)+1
      IQ(LREV+IIECAL)=0.
      NCLU=IG(JGNECA)
      DO 81 I=1,NCLU
         CALL ODFBLK('ECAL',I,NIECAL,IT,NIM,NRECAL,RT,NRM)
         IF(NRM.EQ.0) GO TO 81
         IQ(LREV+IIECAL)=IQ(LREV+IIECAL)+INT(RT(JEE)*1000.)
  81  CONTINUE
      IQ(LREV+IIHCAL)=0.
      NCLU=IG(JGNHCA)
      DO 82 I=1,NCLU
         CALL ODFBLK('HCAL',I,NIHCAL,IT,NIM,NRHCAL,RT,NRM)
         IF(NRM.EQ.0) GO TO 82
         IQ(LREV+IIHCAL)=IQ(LREV+IIHCAL)+INT(RT(JHE)*1000.)
  82  CONTINUE
  80  CONTINUE
*
*--  Print the generated particle tree if required.
*
      IF (IDEBUG.NE.0.AND.ISWIT(1).GE.10) THEN
         CALL GOTREE(0)
      ENDIF
*
*    REPORT any IBM errors now so the info gets attached to the event
*
+SELF,IF=IBM.
      IF(NEREVT.GT.0) THEN
         WRITE(CHREP,4000) NEREVT
         CALL REPORT('IBMERR',2,'WARNING')
         NEREVT=0
      ENDIF
 4000 FORMAT('IBM Run time errors (',I6,') occured in this event.')
+SELF.
*
*--  Drop DST banks with SI information to save space.
*
      CALL RODSWP
*
*    DATA output - all ROPE banks (if any)
*
      IF(JUCOMP('OUT ',JZVERI,10).NE.0)
     +     CALL DZVERI('Before ROPE called',IXDIV,'CLSU')
      J=JUCOMP('DATO',IONAME,NFILE)
      IF(J.NE.0) THEN
         LWDATA=.TRUE.
         WANTED=.TRUE.
         CALL USSLCT('DATA',WANTED)
         IF(WANTED) THEN
*--   (If compact CJ data required call CJPACK - if there are any data)
         IF(ICJPAK.NE.0 .AND. LQ(LDA-LLCJRA).NE.0) CALL CJPACK
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOOOUT('DATO',INEW)
+SELF.
         CALL FZOUT(IOUNIT(J),IXDIV,LREV,1,' ',IOHEAD,NDREV,IQ(LREV+1))
         WRITE(CHREP ,
     +     FMT='('' Raw data + ROPE o/p (if any) written to unit'','//
     +     'I5)') IOUNIT(J)
         CALL REPORT('GUOUT',3,'S')
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOCOUT('DATO')
+SELF.
         ENDIF
      CALL ROSIZE(LREV,'    ',NBANKS,NDATAS,NLINKS,NWORDS)
      IQ(LMCS+32)=IQ(LMCS+32)+NWORDS
      DO 110 I=4,8
        CALL ROSIZE(LQ(LREV-I),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
        IQ(LMCS+80+I)=IQ(LMCS+80+I)+NWORDS
 110  CONTINUE
      ENDIF
*
*    PROD output (raw data +DST only)
*
      J=JUCOMP('PROO',IONAME,NFILE)
      IF(J.NE.0) THEN
         LWPROD=.TRUE.
         WANTED=.TRUE.
         CALL USSLCT('PROD',WANTED)
         IF(WANTED) THEN
*--   (If compact CJ data required call CJPACK - if there are any data)
         IF(ICJPAK.NE.0 .AND. LQ(LDA-LLCJRA).NE.0) CALL CJPACK
*
*--   Drop any ROPE working banks
*
         DO 20 I = 1,IQ(LREV-2)
            IF (I .EQ. LLOD) GOTO 20
            IF (I .EQ. LLDD) GOTO 20
            IF (I .EQ. LLDA) GOTO 20
            IF (I .EQ. LLEX) GOTO 20
            IF (I .EQ. LLUT) GOTO 20
            IF (I .EQ. LLFO) THEN
               LFO  =  LQ( LREV-I)
               IF(LFO .LE. 0)GOTO 20
               IF( LQ(LFO-LLFD) .GE. 1)
     +              CALL MZDROP( IXSTOR, LQ(LFO-LLFD),'L' )
               IF( LQ(LFO-LLSW) .GE. 1)
     +              CALL MZDROP( IXSTOR, LQ(LFO-LLSW),'L' )
               GO TO 20
            ENDIF
            IF (LQ(LREV-I) .EQ. 0) GOTO 20
            CALL MZDROP(IXSTOR,LQ(LREV-I),'L')
   20    CONTINUE
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOOOUT('PROO',INEW)
+SELF.
         CALL FZOUT(IOUNIT(J),IXDIV,LREV,1,' ',IOHEAD,NDREV,IQ(LREV+1))
         WRITE(CHREP ,FMT='('' "PROD" output written to unit'','//
     +     'I5)') IOUNIT(J)
         CALL REPORT('GUOUT',5,'S')
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOCOUT('PROO')
+SELF.
         ENDIF
         CALL ROSIZE(LREV,'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+33)=IQ(LMCS+33)+NWORDS
      ENDIF
      IF(LWDATA.OR.LWPROD) THEN
         CALL ROSIZE(LQ(LREV-3),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+83)=IQ(LMCS+83)+NWORDS
         DO 120 I=1,15
           CALL ROSIZE(LQ(LDA-I),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
           IQ(LMCS+40+I)=IQ(LMCS+40+I)+NWORDS
 120     CONTINUE
           CALL ROSIZE(LQ(LDA-20),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
           IQ(LMCS+40)=IQ(LMCS+40)+NWORDS
      ENDIF
      IF(JUCOMP('DSTO',IONAME,NFILE).NE.0) LWDST=.TRUE.
      IF(JUCOMP('DDSO',IONAME,NFILE).NE.0) LWDDST=.TRUE.
      IF(LWDATA.OR.LWPROD.OR.LWDST.OR.LWDDST)  THEN
         CALL ROSIZE(LQ(LREV-1),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+81)=IQ(LMCS+81)+NWORDS
         CALL ROSIZE(LQ(LREV-2),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+82)=IQ(LMCS+82)+NWORDS
         CALL ROSIZE(LQ(LREV-10),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+90)=IQ(LMCS+90)+NWORDS
         CALL ROSIZE(LQ(LREV-9),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+89)=IQ(LMCS+89)+NWORDS
         CALL ROSIZE(LQ(LMC-1),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+35)=IQ(LMCS+35)+NWORDS
         LMC=LQ(LEX-LLMC)
         IF (LMC .GE. 1) THEN
            IF (LQ(LMC-2) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-2),'L')
            IF (LQ(LMC-3) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-3),'L')
         ENDIF
         IF(NCHEAT.NE.0) THEN
            LCHEA=LQ(LMC-4)
            IF(LCHEA.GT.0) THEN
*--   (If compact CJ data required call CJPACK - if there are any data)
               IF(ICJPAK.NE.0 .AND. LQ(LCHEA-LLCJRA).NE.0) THEN
                  LCJCH=LQ(LCHEA-LLCJRA)
                  LCJCE=LQ(LCJCH-3)
                  IF(LCJCE.GT.0) THEN
                     DO 139 I=1,24
                        LCJSH=LQ(LCJCE-I)
                        IF(LCJSH.GT.0 .AND. LQ(LCJSH-1).GT.0)
     +                    CALL MZDROP(IXSTOR,LQ(LCJSH-1),'L')
                        IF(LCJSH.GT.0 .AND. LQ(LCJSH-3).GT.0)
     +                    CALL MZDROP(IXSTOR,LQ(LCJSH-3),'L')
 139                 CONTINUE
                     CALL CJPACK
                  ENDIF
               ENDIF
            ENDIF
         DO 130 I=1,15
           CALL ROSIZE(LQ(LCHEA-I),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
           IQ(LMCS+60+I)=IQ(LMCS+60+I)+NWORDS
 130     CONTINUE
           CALL ROSIZE(LQ(LCHEA-20),'    ',NBANKS,NDATAS,NLINKS,NWORDS)
           IQ(LMCS+60)=IQ(LMCS+60)+NWORDS
         ENDIF
         CALL ROSIZE(LCHEA,'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+59)=IQ(LMCS+59)+NWORDS
      ENDIF
*
      J=JUCOMP('DDSO',IONAME,NFILE)
      IF(J.NE.0) THEN
         LWDDST=.TRUE.
         WANTED=.TRUE.
         CALL USSLCT('DDST',WANTED)
         IF(WANTED) THEN
*
*-- If DDST selected then...
*-- Clear all links from LREV, except the DST header AND the MC tree
*-- This means:
*-- throw out the TRIG and LEP banks from LEX, and KINE, VERT banks
*-- from LMC.
*
         WRITE(CHREP ,FMT='('' DDST banks written to unit'','//
     +     'I5)') IOUNIT(J)
         CALL REPORT('GUOUT',44,'S')
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOOOUT('DDSO',INEW)
+SELF.
         DO 19 I = 1,IQ(LREV-2)
            IF (I .EQ. LLOD) GOTO 19
            IF (I .EQ. LLDD) GOTO 19
            IF (LQ(LREV-I) .EQ. 0) GOTO 19
            IF (I .EQ. LLEX) THEN
               IF (LQ(LEX-1) .GT. 0) CALL MZDROP(IXSTOR,LQ(LEX-1),'L')
               IF (LQ(LEX-3) .GT. 0) CALL MZDROP(IXSTOR,LQ(LEX-3),'L')
               LMC=LQ(LEX-LLMC)
               IF (LMC .LT. 1) GOTO 19
               IF (LQ(LMC-2) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-2),'L')
               IF (LQ(LMC-3) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-3),'L')
               GOTO 19
            END IF
            IF (I .EQ. LLFO) THEN
               LFO  =  LQ( LREV-I)
               IF(LFO .LE. 0)GOTO 19
               IF( LQ(LFO-LLFD) .GE. 1)
     +              CALL MZDROP( IXSTOR, LQ(LFO-LLFD),'L' )
               IF( LQ(LFO-LLSW) .GE. 1)
     +              CALL MZDROP( IXSTOR, LQ(LFO-LLSW),'L' )
               GO TO 19
            ENDIF
            CALL MZDROP(IXSTOR,LQ(LREV-I),'L')
   19    CONTINUE
         IF(LCHEA.GT.0) CALL MZDROP(IXSTOR,LQ(LCHEA-LLCJRA),'L')
*
*-- Write out. For now, leave the header and LREV as is, just
*-- change the data type to type 6.
*
         IQ(LREV+IIDAT ) = 6
         CALL FZOUT(IOUNIT(J),IXDIV,LREV,1,' ',IOHEAD,NDREV,IQ(LREV+1))
+SELF,IF=MCP.
         FileSize=(IQUEST(15)+IQUEST(14)*1000000)/256.  ! KBytes
+SELF.
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOCOUT('DDSO')
+SELF.
         ENDIF
         CALL ROSIZE(LREV,'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+30)=IQ(LMCS+30)+NWORDS
      ENDIF
*
      J=JUCOMP('DSTO',IONAME,NFILE)
      IF(J.NE.0) THEN
         LWDST=.TRUE.
         WANTED=.TRUE.
         CALL USSLCT('DST ',WANTED)
         IF(WANTED) THEN
*
*-- If DST selected then...
*-- Clear all links from LREV, except the DST header AND the MC tree
*-- This means:
*-- throw out the TRIG and LEP banks from LEX, and KINE, VERT and CHEA banks
*-- from LMC.
*
         WRITE(CHREP ,FMT='('' DST banks written to unit'','//
     +     'I5)') IOUNIT(J)
         CALL REPORT('GUOUT',4,'S')
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOOOUT('DSTO',INEW)
+SELF.
         DO 10 I = 1,IQ(LREV-2)
            IF (I .EQ. LLOD) GOTO 10
            IF (LQ(LREV-I) .EQ. 0) GOTO 10
            IF (I .EQ. LLEX) THEN
               IF (LQ(LEX-1) .GT. 0) CALL MZDROP(IXSTOR,LQ(LEX-1),'L')
               IF (LQ(LEX-3) .GT. 0) CALL MZDROP(IXSTOR,LQ(LEX-3),'L')
               LMC=LQ(LEX-LLMC)
               IF (LMC .LT. 1) GOTO 10
               IF (LQ(LMC-2) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-2),'L')
               IF (LQ(LMC-3) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-3),'L')
               IF (LQ(LMC-4) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-4),'L')
               GOTO 10
            END IF
            CALL MZDROP(IXSTOR,LQ(LREV-I),'L')
   10    CONTINUE
*
*-- Write out. For now, leave the header and LREV as is, just
*-- change the data type to type 6.
*
         IQ(LREV+IIDAT ) = 6
         CALL FZOUT(IOUNIT(J),IXDIV,LREV,1,' ',IOHEAD,NDREV,IQ(LREV+1))
+SELF,IF=MCP.
         FileSize=(IQUEST(15)+IQUEST(14)*1000000)/256.  ! KBytes
+SELF.
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOCOUT('DSTO')
+SELF.
         ENDIF
         CALL ROSIZE(LREV,'    ',NBANKS,NDATAS,NLINKS,NWORDS)
         IQ(LMCS+34)=IQ(LMCS+34)+NWORDS
      ENDIF
*
*     Compressed data
*
      DO 123 K=9,6,-1
       J=JUCOMP(CNAME(K),IONAME,NFILE)
       IF(J.NE.0) THEN
         WANTED=.TRUE.
         CALL USSLCT(CNAME(K),WANTED)
         IF(WANTED) THEN
*
*-- If DST selected then...
*-- Clear all links from LREV, except the DST header AND the MC tree and DD
*-- This means:
*-- throw out the TRIG and LEP banks from LEX, and KINE, VERT and CHEA banks
*-- from LMC.
*
         WRITE(CHREP ,FMT='(A4,'' banks written to unit'','//
     +     'I5)') CNAME(K),IOUNIT(J)
         CALL REPORT('GUOUT',40+K,'S')
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOOOUT(CNAME(K),INEW)
+SELF.
         DO 410 I = 1,IQ(LREV-2)
            IF (I .EQ. LLOD) GOTO 410
            IF (I .EQ. LLDD .AND. K.NE.6) GOTO 410
            IF (LQ(LREV-I) .EQ. 0) GOTO 410
            IF (I .EQ. LLEX) THEN
               IF (LQ(LEX-1) .GT. 0) CALL MZDROP(IXSTOR,LQ(LEX-1),'L')
               IF (LQ(LEX-3) .GT. 0) CALL MZDROP(IXSTOR,LQ(LEX-3),'L')
               LMC=LQ(LEX-LLMC)
               IF (LMC .LT. 1) GOTO 410
               IF (LQ(LMC-2) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-2),'L')
               IF (LQ(LMC-3) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-3),'L')
               IF (LQ(LMC-4) .GT. 0) CALL MZDROP(IXSTOR,LQ(LMC-4),'L')
               GOTO 410
            END IF
            CALL MZDROP(IXSTOR,LQ(LREV-I),'L')
  410    CONTINUE
*
*-- Write out. For now, leave the header and LREV as is, just
*-- change the data type to type 6.
*
         IQ(LREV+IIDAT ) = 6
         CALL DCWRIT(IOUNIT(J),K-6)
         IF(IQUEST(1).NE.0) THEN
            CHREP='Data compression failed'
            CALL REPORT('USOUT',410,'E')
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOCOUT(CNAME(K))
+SELF.
         ENDIF
         ENDIF
       ENDIF
 123  CONTINUE

*
*--   Set operation phase 50 for ZEBRA recovery.
      CALL ZPHASE(50)
      CALL TIMEX(TIM1)
      IQ(LMCS+6)=IQ(LMCS+6)+INT(100.*(TIM1-TIM0))
      END
+DECK,GUPHAD.
      SUBROUTINE GUPHAD
*.
*...GUPHAD Evaluate the next hadronic interaction point.
*.
*.
*.      GEANT3 user routine called at each step
*.      to evaluate the next hadronic interaction point
*.
*.               (GHEISHA)uses the GHEISHA cross-sections
*.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : GPGHEI GPHADR
*. CALLED    : GMUNU  GPFIS  GTHADR GTNEUT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.09
*. CREATED   : 25-Dec-84
*. LAST MOD  : 25-Aug-92
*.
*. Modification Log.
*. 25-Aug-92   D.R.Ward      Include HADR 4 (FLUKA) option.
*. 25-Apr-88   D.R.Ward        Strong typing
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCPHYS.
*--  Call GPGHEI if GHEISHA is USE selected.
*--              GPGHEI uses the GHEISHA cross-sections
      IF(IHADR.NE.4) THEN
+SELF,IF=GHEISHA.
         CALL GPGHEI
+SELF.
      ELSE
+SELF,IF=FLUKA.
         CALL FLDIST
+SELF.
      ENDIF
*
      RETURN
      END
+DECK,GUSTEP.
      SUBROUTINE GUSTEP
*.
*...GUSTEP  User routine for the end of each tracking step.
*.
*. COMMON    :
*. COMMON    :
*. SEQUENCE  : GCFLAG GCKINE GCKING GCLIST GCNUM  GCSETS GCTRAK
*. SEQUENCE  : GCUNIT GCVOLU GOFLAG GOHITS RCREP.
*. CALLS     : GDCXYZ GOKING GPCXYZ GSXYZ  GUSTFU REPORT SHCREA SHSTEP
*. CALLS     : SMCD   SMEM   SMHC   SMMU   UCOPY  UCTOH  USSTEP
*. CALLED    : GMENEW GTRACK GTVOL
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 2.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 16-Feb-96
*.
*. Modification Log.
*. 16-Feb-96   C.P.Ward        Fix to setting of XYZ0
*. 16-Dec-94   C.P.Ward        Change stuck particle bodge: do not
*.                             count steps where secondary produced.
*.  7-Jun-94   C.P.Ward        Mods for FD smear mode
*. 11-Apr-94   C.P.Ward        Remove unused sequences;
*.                             fix mixed mode arithmetic.
*. 08-Dec-93   C.P.Ward        Remove unused variables.
*. 22-Feb-93   J.E.Conboy      Call USSDBG, if IDEBUG><0, IF=*USSDBG
*. 29-Jan-93   A.Buijs         Alpha fixes
*.  8-Jul-91   D.R.Ward        Change stuck particles bodge.
*.  3-Sep-90   J.N.Banks       Fix for particles stuck on DN10K
*. 10-Jul-90   D.R.Ward        Quick bodge for Si SMear
*. 16-Jan-90   D.R.Ward        Call GOTSTP
*.  3-Jul-89   D.R.Ward        Check on *FILE META card
*. 31-May-89   D.R.Ward        Slight change to "Stuck" test
*. 10-May-89   J.Banks         Change SMCD parameters + extra call
*.  9-May-89   D.R.Ward        Protect against particles getting stuck
*.  1-Mar-89   D.R.Ward        More bugs in logic.  Should rewrite some
*. 18-Oct-88   D.R.Ward        Logic in mixed modes still incorrect!
*. 14-Oct-88   D.R.Ward        Add more calls to SMCAL
*. 26-Sep-88   D.R.Ward        Change GOTRUP logic slightly
*.  7-Sep-88   D.R.Ward        Change def'n of "leaving CD"; check stopp
*. 15-Aug-88   D.R.Ward        Fix bug re. debug printing
*.  8-Aug-88   D.R.Ward        Tighten geometrical cut to define CD regi
*.  5-Aug-88   D.R.Ward        Handle improved CD fast geometry
*.  3-Jul-88   D.R.Ward        Another minor bug in logic.
*.  1-Jun-88   D.R.Ward        Fix minor bug in logic
*. 30-May-88   R.J.Barlow      Switches now evaluated in GOIFFR;
*. 30-May-88   R.J.Barlow      Change some calling sequences for SM
*. 19-May-88   D.R.Ward        NSTEPM=750
*. 10-May-88   D.R.Ward        Call GOTRUP for stoppers.
*.  9-May-88   D.R.Ward        Tidy up; modify checks on many points.
*.  2-May-88   D.R.Ward        Major revision to accommodate fast GOPAL
*. 25-Apr-88   D.R.Ward        Strong typing
*. 14-Apr-88   D.R.Ward        Use CHREP for REPORT
*.  3-Feb-88   D.R.Ward        Handle "shower" particles
*.  7-Jan-88   N.Geddes        Modify storing of points in JXYZ banks
*. 30-Nov-87   D.R.Ward        Use of REPORT
*. 20-Jul-87   D.R.Ward        Add call to USSTEP (user routine)
*. 13-Mar-87   D.R.Ward        Changes to implement EB bootstrap code.
*. 21-Jan-87   H.Kreutzmann    CJ changes
*. 21-Jan-87   A.Possoz        Change to PB
*. 12-Jan-87   D.R.Ward        Test on JBOOT
*. 18-Dec-86   D.R.Ward        Changes to allow EE bootstrap code.
*. 12-Dec-86   T.Mashimo       Bug fixes for EB
*.  6-Oct-86   A Possoz        Add DESTEP and TOFG for IDTYPE=1 (TOF)
*. 25-Sep-86   D.R.Ward        Add printing for over-long tracks.
*. 16-Sep-86   S.O'Neale       Clean character variables.
*. 19-Aug-86   C.Y.Chang       Call HBHITS for HBPV.
*. 17-Jul-86   S.O'Neale       Update EB parameterization code.
*. 19-May-86   S.O'Neale       Introduce hit calls for PE.
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*. 10-May-86   S.O'Neale       Introduce GMAIL for printing.
*. 27-Jan-86                   Add  EB parameterization function.
*. 10-Jun-85                   Add TOF code.
*.
*. 17-Jun-85                   Trial code to trap spiralling e+,e-
*.                             in small volumes.
*.
*.
*.      User routine called at the end of each tracking step
*.            INWVOL =1 when track enters into a new volume
*.                   =2 when track leaves the current volume
*.            ISTOP is different from 0 if the track has stopped
*.      In case of a sensitive volume (flag IDTYPE in /GCSETS/ ) the
*.      current point in array VECT (common GCTRAK) is stored in
*.      array POINTS  and the HITS step is performed for all
*.      detectors in the current volume
*.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,RCREP.
+SEQ,GCSETS
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCTRAK
+SEQ,GCLIST
+SEQ,GCVOLU
+SEQ,GCUNIT
+SEQ,GCNUM
+SEQ,GOLOGI
+SEQ,GOFILE
*
      LOGICAL INIT,LOUTER,LINCD,LFDC
      INTEGER   NSTEPT,IS2,JUCOMP,IIC,IBRL,IEE,IICC,IICV,NSTEPM
     +         ,IJCV,IJCC,IISI,IBTU,IHSTOP,IFDC,NLFDC
      REAL RRR,ZZZ,XYZ0(7),XYZ1(7),XYZ2(7),SLENGM,RCDOUT
      EXTERNAL  JUCOMP
      REAL    XSTEP
      INTEGER NSHORT
      DATA NSHORT/0/,XSTEP/0.1/
      DATA NSTEPT/0/
      DATA INIT/.FALSE./
      DATA NLFDC/ 4 /
*
*     ------------------------------------------------------------------
*
*      initialize some flags
*
      IF ( .NOT. INIT ) THEN
         RCDOUT=200.
         IF(LCDSM) RCDOUT=183.4
         SLENGM=2000.
         NSTEPM=100
         IF(LCDFU .OR. LCALFU) NSTEPM=750
         CALL UCTOH('C   ',IIC,4,4)
         CALL UCTOH('CVSV',IICV,4,4)
         CALL UCTOH('SITU',IISI,4,4)
         CALL UCTOH('CJET',IICC,4,4)
         CALL UCTOH('BTU1',IBTU,4,4)
         CALL UCTOH('CV  ',IJCV,4,4)
         CALL UCTOH('CC  ',IJCC,4,4)
         CALL UCTOH('BRL-',IBRL,4,4)
         CALL UCTOH('EE  ',IEE ,4,4)
         CALL UCTOH('STOP',IHSTOP ,4,4)
         CALL UCTOH('FDC-',IFDC ,4,4)
         INIT = .TRUE.
      ENDIF
+SELF,IF=*USSDBG.
*
*--      Allow user to set/reset Switch 2, according to particle type,
*        volume etc
      IF( IDEBUG .NE. 0 )    CALL USSDBG
+SELF.
*--
*--    Force track to stop if too many steps
*--    (Trap intended for electrons spiralling
*--    in air/vacuum gaps)
*--
      IF(SLENG.EQ.0.) THEN
         NSTEPT=1
      ELSE
         NSTEPT=NSTEPT+1
         IF(NSTEPT.GT.NSTEPM) THEN
*
*-- If particle has momentum > 100 MeV then we don't
*-- want to stop it - just reset the counter
*
            IF (VECT(7).GT.0.1) THEN
               WRITE(CHREP,1300) NSTEPM,ITRA,NTMULT
               CALL REPORT('GUSTEP',22,'I')
               WRITE(CHREP,1400)NAMES(NLEVEL),VECT(7),SLENG,STEP,NAPART
               CALL REPORT('GUSTEP',23,'I')
               NSTEPT=0
            ELSE
               WRITE(CHREP,1100) NSTEPM,ITRA,NTMULT
               CALL REPORT('GUSTEP',20,'W')
               WRITE(CHREP,1200)NAMES(NLEVEL),VECT(7),SLENG,STEP,NAPART
               CALL REPORT('GUSTEP',21,'W')
               ISTOP=1
               NSTEPT=0
            ENDIF
         ENDIF
      ENDIF
*--
*--  Consider track as stopping if the length exceeds SLENGM.
*
      IF(SLENG.GT.SLENGM) THEN
         IF(ISTOP.EQ.0)THEN
            WRITE(CHREP ,1000) SLENGM,ITRA,NTMULT
            CALL REPORT('GUSTEP',10,'W')
         ENDIF
         IF(ISTOP.EQ.0) THEN
            WRITE(CHREP ,1200) NAMES(NLEVEL),VECT(7),SLENG,
     +      STEP,NAPART
            CALL REPORT('GUSTEP',11,'W')
         ENDIF
         ISTOP=1
      ENDIF
*
*     Free "stuck" particles?   This occurs because of rounding error
*     problems in GEANT.  If we think this has happened (a succession
*     of very short steps) give the particle a shove to try and free it.
*     CPW 16/12/94: try to stop this happening for particles taking
*     very short steps in SW tungsten skins for physics reasons - 
*     restart count if secondary produced.
*
      IF(STEP.LT.0.01 .AND. SLENG.NE.0 .AND. NGKINE.EQ.0) THEN
         NSHORT=NSHORT+1
      ELSE
         NSHORT=0
      ENDIF
*
      IF(NSHORT.GE.40 .AND. NSHORT.LT.49) THEN
         IF(NSHORT.EQ.40) THEN
            CHREP='Particle  stuck - trying to shake it free'
            CALL REPORT('GUSTEP',9,'I')
         ENDIF
         VECT(1)=VECT(1)+XSTEP*VECT(4)*2.**(NSHORT-40)
         VECT(2)=VECT(2)+XSTEP*VECT(5)*2.**(NSHORT-40)
         VECT(3)=VECT(3)+XSTEP*VECT(6)*2.**(NSHORT-40)
      ENDIF
      IF(NSHORT.EQ.50) THEN
         CHREP='Particle  stuck - failed to unstick it - sorry.'
         CALL REPORT('GUSTEP',89,'W')
      ENDIF
*
*--   If all parts of the detector are in FULL or SMEA mode things are
*--   fairly simple, if not then we have to decide whether we are in the
*--   "central" or "outer" part of the detector.
*
      IF(LALLFU) GO TO 40
*   
      LFDC =       NLEVEL .GE. NLFDC
     +       .AND. NAMES(NLFDC) .EQ. IFDC
*
      IF(LALLSM) GO TO 30
*
*--   If it is a shower particle call SHSTEP to track it.
*
      IF(IPART.EQ.77) THEN
         CALL SHSTEP
         GO TO 50
      ENDIF
*
      LOUTER=.TRUE.
*
*     Check if appropriate geometrical region for conversion to a shower
*     This looks rather messy, but I hope it's reasonably efficient
*     for most common cases (i.e. it leaves the tricky ones till last).
*
      IF(NLEVEL.GE. 2.AND. NAMES(2).NE.IBRL) GO TO 20
      RRR=SQRT(VECT(1)**2+VECT(2)**2)
      ZZZ=ABS(VECT(3))
*     Definitely outside PB => outer
      IF(RRR.GT.243.) GO TO 20
*     Outside CJ and not full PSAM => outer
      IF(.NOT.LPSFU .AND.  RRR.GT.RCDOUT  ) GO TO 20
*     Definitely in CJ/CV region => inner
      IF(RRR.LT.RCDOUT  .AND. ZZZ.LT.147.+0.2679*RRR) GO TO 10
*     Still going?  => outer unless PSAM or FD full, in which case the
*     geometry is tricky.
      IF(.NOT.(LPSFU .OR. LFDFU)) GO TO 20
*     Outside radius of PE => outer
      IF(RRR.GT.170.) GO TO 20
*     Inside radius of EE => inner if FD full
      IF(RRR.LT.45. .AND. LFDFU) GO TO 10
*     Inside radius of PE => outer
      IF(RRR.LT.70.) GO TO 20
*     Fast PE => outer
      IF(.NOT.LPSFU) GO TO 20
      IF(ZZZ.GT.237.) GO TO 20
      IF(NAMES(4).EQ.IEE) GO TO 20
   10 LOUTER=.FALSE.
   20 CONTINUE
*
*
*     This is a mess at the moment.  Must try to tidy it up for GOPAL119
*     It also needs tidying up so it can work in PATR mode.
*
*     In OUTER region...
*
      IF(LOUTER) THEN
         IF(SLENG.EQ.0.) THEN
           LINCD=.FALSE.
           CALL UCOPY(VECT,XYZ0,7)
         ENDIF
*
*     If we've been in CD and CD in SMEA mode need to call SMCD
*
         IF(LCDSM .AND. LINCD .AND. CHARGE.NE.0) THEN
            CALL SMCD(ITRA,IVERT,IPART,XYZ0,XYZ1,XYZ2,CHARGE)
            LINCD=.FALSE.
            IF(.NOT.(LCALSM .OR. LCALFU .OR. LCALFA)) ISTOP=1
         ENDIF
*
*     FULL CAL => go off to GUSTFU to do the work.
*
         IF(LCALFU) THEN
            GO TO 40
         ENDIF
*
*     FAST CAL (shower tracking)
*         If FAST calorimetry selected then we may want to turn this
*         particle into a shower.  SHCREA will decide this.
*         If it doesn't then go on to GUSTFU.
*
         IF(LCALFA) THEN
            CALL SHCREA
            IF(ISTOP.EQ.0) GO TO 40
            IF(LCDSM .AND. LINCD .AND. CHARGE.NE.0) CALL SMCD(ITRA,
     +      IVERT,IPART,XYZ0,XYZ1,XYZ2,CHARGE)
            GO TO 50
         ENDIF
*
*     May have come out of CD somehow, call SMCAL if appropriate.
*
         IF(.NOT.LINCD .AND.(ABS(VECT(3)).GT.210.
     +    .OR. RRR.GT.200.) .AND. LCALSM) THEN
            CALL UCOPY(VECT,XYZ2,7)
            IF(ISTOP.EQ.0) CALL SMCAL(ITRA,IVERT,IPART,XYZ0,XYZ2)
            ISTOP=1
         ENDIF
      ENDIF
*
*     Not OUTER, or in OUTER but outstanding CD work possibly.
*
      IF(.NOT.LOUTER .OR. LINCD) THEN
         IF(LCDSM .OR. LCALSM) THEN
*
*     Store secondaries?
*
            IF(NGKINE.GT.0) THEN
               CALL GOKING
               NGKINE=0
               IF(LCDSM .AND. LINCD .AND. CHARGE.NE.0 .AND. ISTOP.NE.0)
     +            CALL SMCD(ITRA,IVERT,IPART,XYZ0,XYZ1,XYZ2,CHARGE)
            ENDIF
*
*     New particle - store start point and set LINCD
*
            IF(SLENG.EQ.0.) THEN
               LINCD=.FALSE.
               CALL UCOPY(VECT,XYZ0,7)
            ENDIF
*
*    Test whether entering CD for first time
*
            IF(.NOT.LINCD .AND. INWVOL.EQ. 1.AND. ((NLEVEL.GE. 4.AND.
     +        (NAMES(4).EQ.IJCC .OR. NAMES(4).EQ.IJCV)) .OR.
     +         (NLEVEL.GE.4 .AND. NAMES(4).EQ.IISI)) ) THEN
               LINCD=.TRUE.
               CALL UCOPY(VECT,XYZ1,7)
            ENDIF
*
*    Maybe leaving CD in forward region?
*
            IF(.NOT.LINCD .AND. ABS(VECT(3)).GT.210. .AND. LCALSM) THEN
               CALL UCOPY(VECT,XYZ2,7)
               IF(ISTOP.EQ.0) CALL SMCAL(ITRA,IVERT,IPART,XYZ0,XYZ2)
               ISTOP=1
            ENDIF
*
*    Leaving C?  Call SMCD and/or SMCAL as appropriate.
*
            IF(LINCD .AND. ((NLEVEL.LE.2 .OR.
     +      (NAMES(3).NE.IIC .AND. NAMES(3).NE.IBTU)) .OR.
     +         (INWVOL.EQ.2 .AND. NLEVEL.GE.5 .AND.
     +          NAMES(5).EQ.IICC)) ) THEN
               LINCD=.FALSE.
               CALL UCOPY(VECT,XYZ2,7)
               IF(CHARGE.NE.0.) THEN
                  IF(LCDSM) CALL SMCD(ITRA,IVERT,IPART,XYZ0,XYZ1,XYZ2,
     +                                CHARGE)
                  IF(.NOT.(LCALSM .OR. LCALFU .OR. LCALFA)) ISTOP=1
               ENDIF
               IF(LCALSM) THEN
                 IF(ISTOP.EQ.0) CALL SMCAL(ITRA,IVERT,IPART,XYZ0,XYZ2)
                  ISTOP=1
               ENDIF
            ENDIF
         ENDIF
*
*    FULL CD?  Go to GUSTFU for action.
*
         IF(LCDFU) GO TO 40
*
*    FAST CD?  Call appropriate stuff from here when available.
*
         IF(LCDFA) THEN
*       No coding for FAST CD yet
            IF(NGKINE.NE.0) THEN
               CALL GOKING
               NGKINE=0
            ENDIF
            GO TO 50
         ENDIF
      ENDIF
      GO TO 50
*
*--   Call the SM.... routines to handle parametrization mode.
*
   30 IF(NGKINE.GT.0) THEN
         CALL GOKING
         NGKINE=0
      ENDIF
      IF(SLENG.EQ.0.) THEN
*     New particle
         LINCD=.FALSE.
         CALL UCOPY(VECT,XYZ0,7)
      ENDIF
      IF(.NOT.LINCD .AND. INWVOL.EQ.1 .AND. ((NLEVEL.GE. 5.AND.
     + (NAMES(5).EQ.IICC .OR. NAMES(5).EQ.IICV)) .OR.
     + (NLEVEL.GE.4 .AND. NAMES(4).EQ.IISI) ) ) THEN
*     Entering 'C   '
         LINCD=.TRUE.
         CALL UCOPY(VECT,XYZ1,7)
      ENDIF
      IF(.NOT.LINCD .AND. LFDC) THEN
*     Forward
         CALL UCOPY(VECT,XYZ2,7)
         IF(ISTOP.EQ.0 .AND. LFDSM)
     +       CALL SMCAL(ITRA,IVERT,IPART,XYZ0,XYZ2)
         ISTOP=1
      ENDIF
*     Track stopping in CJ
      IF (ISTOP.NE.0.AND.LINCD.AND.CHARGE.NE.0..AND.LCDSM) THEN
         CALL SMCD(ITRA,IVERT,IPART,XYZ0,XYZ1,VECT,CHARGE)
      END IF
*DRW 6/9/88
      IF(LINCD .AND. ((NLEVEL.LE.2 .OR.
     +   (NAMES(3).NE.IIC .AND. NAMES(3).NE.IBTU)) .OR.
     +   (INWVOL.EQ.2 .AND. NLEVEL.GE.5 .AND.
     +    NAMES(5).EQ.IICC)) ) THEN
*     Leaving  'C   '
         LINCD=.FALSE.
         CALL UCOPY(VECT,XYZ2,7)
         IF(CHARGE.NE.0..AND.LCDSM) THEN
            CALL SMCD(ITRA,IVERT,IPART,XYZ0,XYZ1,XYZ2,CHARGE)
         ENDIF
         IF(ISTOP.EQ.0.AND.LCALSM)
     +      CALL SMCAL(ITRA,IVERT,IPART,XYZ0,XYZ2)
         ISTOP=1
      ENDIF
      GO TO 50
*--
*--  Store or stack secondary particles GOKING.
   40 IF(NGKINE.GT.0) THEN
         CALL GOKING
         NGKINE=0
      ENDIF
*
*--  GUSTFU contains most of the code that used to be in GUSTEP
*--         before May 1988.
*
      CALL GUSTFU
*
*--   If a non-stack particle has stopped update the tree.
*
   50 IF(ISTAK.EQ. 0.AND. ISTOP.NE. 0.AND. NGKINE.EQ.0
     +   .AND. IPART.NE.77)
     +   CALL GOTRUP(ITRA,VECT,IHSTOP,0,0,GKIN)
      IF(INWVOL.EQ.3) CALL GOTRUP(ITRA,VECT,IHSTOP,0,0,GKIN)
*
*--
*--  Debugging and plotting options may be selected.
*
      IF(IDEBUG.EQ.0) GO TO 60
*
*--   Stores current point in JXYZ for display  GSXYZ.
*
      IF(
     +(NPLOT.NE.0 .AND. IEVENT.GE.LPLOT(1) .AND. IEVENT.LE.LPLOT(2))
     +  .OR.  ISWIT(2).EQ.1)
     + CALL GSXYZ
*
*--   Print track parameters at current point  GPCXYZ.
*
   60 IF(IDEBUG.EQ.0)GO TO 80
      IS2=MOD(ISWIT(2),10)
      IF(IS2.NE.2)GO TO 70
      CALL GPCXYZ
      GO TO 80
*
*--   Display of the track trajectory  GDCXYZ.
*
   70 IF(IS2.NE.3)GO TO 80
+SELF,IF=GKS,HIGZ.
      IF(JUCOMP('METO',IONAME,NFILE).NE.0) CALL GDCXYZ
+SELF.
*
   80 CALL USSTEP
      IF(INWVOL.EQ.1) CALL GOTSTP
      RETURN
 1000 FORMAT(' Maximum track length',F8.2, ' reached, track no.',I4,
     +' NTMULT',I6)
 1100 FORMAT(' Maximum number of steps ',I6, ' reached, track no.',I4,
     +' NTMULT',I6)
 1200 FORMAT(' in volume ',A4 ,' momentum =',F8.4,' GeV/c; ',
     +'length =',F10.4,' last step',F10.4,2X,5A4)
 1300 FORMAT(' Maximum number of steps ',I6, ' reset, track no.',I4,
     +' NTMULT',I6)
 1400 FORMAT(' in volume ',A4 ,' momentum =',F8.4,' GeV/c; ',
     +'length =',F10.4,' last step',F10.4,2X,5A4)
      END
+DECK,GUSTFU.
      SUBROUTINE GUSTFU
*.
*...GUSTFU    Handles tracking steps in FULL simulation.
*.            (most of the code used to be in GUSTEP).
*.
*. COMMON    :
*. COMMON    :
*. SEQUENCE  : GCFLAG GCKINE GCKING GCLIST GCNUM  GCSETS GCTRAK
*. SEQUENCE  : GCUNIT GCVOLU GOFLAG GOHITS RCREP
*. CALLS     : CDHITS CJSTEP EBHITS EBPAR  EEHITS EEPAR  FDHITS HBHITS
*. CALLS     : HEHITS HPHITS MBHITS MEHITS PBHITS PEHITS REPORT TBHITS
*. CALLS     : UCOPY  UCTOH  UHTOC   BHITS UCOPY  UCTOH  UHTOC  USSTEP
*. CALLS     : TEHITS
*. CALLED    : GUSTEP
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  2-May-88
*. LAST MOD  :  3-Feb-99
*.
*. Modification Log.
*.  3-Feb-99   C.P.Ward      Add FFHITS calls.
*. 28-Sep-94   C.P.Ward      Add TEHITS call.
*.  7-Jun-94   C.P.Ward      Remove bootstrap code.
*. 11-Mar-94   C.P.Ward      ME detectors all in set ME.
*.  8-Dec-93   C.P.Ward      Remove unused variables.
*.  1-Mar-93   J.E.Conboy    Delete FDBOOT call
*. 21-May-91   J.E.Conboy    Store TOFG in POINTS(10,1) for Calo hit, for use
*.                           by FDET FL counter
*. 19-Mar-91   G.Wilson      Store TOF on leaving TB volume
*. 10-Sep-90   J.E.Conboy    insert call to FDGAMA
*. 19-Feb-90   N.K.Watson    Sets MEL and MER
*. 16-Jan-90   D.R.Ward      Call SIHITS
*. 24-Aug-89   D.R.Ward      Implement FD bootstrap option
*. 28-Jun-89   D.R.Ward      Bug fix for reentrant tracks
*.  7-Jun-89   B.Lorazo      New routine CZHITS
*.  9-May-89   D.R.Ward      Bug in setting track numbers for reentrants
*. 26-Sep-88   D.R.Ward      GEANT312 - mods to treatment of reentrant t
*. 12-Sep-88   D.R.Ward      IUSET ==> IHSET (GEANT312)
*.  9-Sep-88   C.P.Ward      Call EEPAR on entry to EE
*. 10-May-88   H.Kreutzmann  Small bug fix.
*.  9-May-88   D.R.Ward      Restore stack particles reentering CD to lo
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,RCREP
+SEQ,GCSETS
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCTRAK
+SEQ,GCLIST
+SEQ,GOHITS
+SEQ,GOFLAG
+SEQ,GCVOLU
+SEQ,GCUNIT
+SEQ,GCNUM
+SEQ,GCBANK
+SEQ,FDBUF.
*
      INTEGER I,IICVPC,IICVSC,IICJET,IICZZD,IVBUF(30),NVBUF, IVNEW,
     +ITNEW,KKCASE,LVER,LVERU,NLNK
C      CHARACTER*4 HERE
      REAL      PMOM(3),BETA0,GAMA0,PENUM
*
*
*--   Declaration of local variables used
*--
*        INIT   : Flagging whether initialization performed
*        IFSLCJ : Flagging whether set CJ selected
*        NAMCJ  : Name of set CJ ( Hollerith )
      LOGICAL     INIT, IFSLCJ
      INTEGER     NAMCJ
      SAVE        INIT, IFSLCJ, NAMCJ
      CHARACTER*4 CUSET
*
*     Declaration of external functions
      INTEGER     IUCOMP
      EXTERNAL    IUCOMP
*     DATA section to assign initial values
      DATA        INIT / .FALSE. /
*
      IF ( .NOT. INIT ) THEN
         CALL UCTOH('CJ  ', NAMCJ, 4, 4)
         CALL UCTOH('CVPC',IICVPC, 4, 4)
         CALL UCTOH('CVSC',IICVSC, 4, 4)
         CALL UCTOH('CJET',IICJET, 4, 4)
         CALL UCTOH('CZZD',IICZZD, 4, 4)
         IF ( IUCOMP(NAMCJ, LSETS(1), NSETS) .GT. 0 ) THEN
            IFSLCJ = .TRUE.
         ELSE
            IFSLCJ = .FALSE.
         ENDIF
         INIT = .TRUE.
      ENDIF
*
*--   Test for stack particle reentering one of the sensitive CD volumes
*
      IF(INWVOL.EQ.1 .AND. ISTAK.NE.0 .AND. CHARGE.NE.0) THEN
         IF(NAMES(NLEVEL).EQ.IICVPC .OR. NAMES(NLEVEL).EQ.IICVSC .OR.
     +   NAMES(NLEVEL).EQ.IICJET .OR. NAMES(NLEVEL).EQ.IICZZD) THEN
*
*--   If so restore as permanent track (code from CJKING)
            DO 10 I = 1, 3
               PMOM(I) = VECT(3+I) * VECT(7)
   10       CONTINUE
*--    Use the user words to store the volume name
*--    in which the vertex occurred, and the mechanism(s).
            IVBUF(1) = NAMES(NLEVEL)
            NVBUF = 1
            DO 20 I = 1, NMEC
               IF ( LMEC(I) .LE.  4) GO TO 20
               NVBUF = NVBUF + 1
               IVBUF(NVBUF) = NAMEC(LMEC(I))
   20       CONTINUE
*--    Store the "vertex".
            CALL GSVERT(VECT(1), ITRA, 0, IVBUF, NVBUF, IVNEW)
*--    Try to set the user words bank to hollerith.
            LVER = LQ(JVERTX-IVNEW)
            LVERU = LQ(LVER-1)
            NLNK = IQ(LVERU-3)
            IQ(LVERU-NLNK-9) = IQ(LVERU-NLNK-9) + 131072
*--    Store the kinematics of the particle.
            CALL GSKINE(PMOM(1), IPART, IVNEW, 0., 0, ITNEW)
            CALL UCTOH('STAK',KKCASE,4,4)
            CALL GOTRUP(ITRA,VECT,KKCASE,IPART,ITNEW,PMOM)
*--    Stop tracking of particle on stack (unless something went wrong)
            IF(IVNEW.EQ. 0.OR. ITNEW.EQ.0) THEN
               CHREP='Error transferring particle from stack'
               CALL REPORT('GUSTFU',1,'W')
            ELSE
               CHREP='Track reentering CD taken off stack'
               CALL REPORT('GUSTFU',2,'S')
               ITRA=ITNEW
               ISTAK=0
*DRW 28/6/89   GO TO 110
            ENDIF
         ENDIF
      ENDIF
*
*--  Stores point in current volume for HITS step
*--    No action if IUHITS is zero
*--    or if the track is neutral 
*--    or if the volume is not a sensitive detector of
*--    a type known to GOPAL.
*
      IF(IUHITS.EQ.0)GO TO 110
*--   Special treatment of CJ tracking steps and hits
      IF ( IFSLCJ ) THEN
         CALL CJSTEP
      ENDIF
         CALL UHTOC(IHSET,4,CUSET,4)
      IF(CHARGE.EQ.0. .AND. CUSET.EQ.'PB  ')THEN
         IF(ISTOP.NE.0.AND.NGKINE.EQ.0)THEN
            NPOINT=1
            CALL UCOPY(VECT,POINTS(1,NPOINT),7)
            POINTS(8,NPOINT)=SLENG
            CALL PBHITS
         ENDIF
         GO TO 110
      ENDIF
      IF(CHARGE.EQ.0) GO TO 110
      IF ( IDTYPE .LE. 0.OR. IDTYPE .GT. 3) GO TO 110
      GO TO ( 40, 60, 90), IDTYPE
*--
*--   Trajectory type detector (1)
*
*               ( IDTYPE = 1 )
*
   40 CONTINUE
* .  A.P.      IF(INWVOL.EQ.1)NPOINT=0
      IF(INWVOL.EQ.1) THEN
         NPOINT=0
         POINTS(9,1)=0.
         POINTS(9,2)=TOFG
      ENDIF
      IF ( CUSET .EQ. 'CJ  ' ) GOTO 50
      POINTS(9,1)=POINTS(9,1)+DESTEP
      NPOINT=NPOINT+1
*--  Consider track as stopping if the no of points exceeds NPLENG.
*--
      IF(NPOINT.GE.NPLENG) THEN
         ISTOP=1
         WRITE(CHREP ,1000) NPLENG,ITRA,NTMULT
         CALL REPORT('GUSTFU',30,'W')
         WRITE(CHREP ,1100) (VECT(I),I=1,3),VECT(7),STEP,NAPART
         CALL REPORT('GUSTFU',30,'W')
      ENDIF
      CALL UCOPY(VECT,POINTS(1,NPOINT),7)
      POINTS(8,NPOINT)=SLENG
      POINTS(10,NPOINT)=TOFG
   50 CONTINUE
      IF(INWVOL.NE.2.AND.ISTOP.LE.0)GO TO 110
      IF(CUSET.EQ.'SI  ') CALL SIHITS
      IF(CUSET.EQ.'CV  ') CALL CDHITS
      IF(CUSET.EQ.'CZ  ') CALL CZHITS
      IF(CUSET.EQ.'ME  ') CALL MEHITS
      IF(CUSET.EQ.'FD  ') CALL FDHITS
      IF(CUSET.EQ.'SW  ') CALL SWHITS
      IF(CUSET.EQ.'PB  ') CALL PBHITS
      IF(CUSET.EQ.'PE  ') CALL PEHITS
      IF(CUSET.EQ.'TB  ') CALL TBHITS
      IF(CUSET.EQ.'TE  ') CALL TEHITS
      IF(CUSET.EQ.'FF  ') CALL FFHITS
      NPOINT=0
      GO TO 110
*
*--   Calorimeter type detector
*--   ( IDTYPE = 2 )
*.   POINTS(1-8,1)  =  X, Y, Z, Px/P, Py/P, Pz/P, P, SLENG   at entry to Vol
*.            9,1)  =  DESTEP summed thro volume
*.           10,1)  =  TOFG at entry
*.   POINTS(  8,2)  =  PENUM ( for EE, EB )
*.            9,2)  =  Beta0
*.----------------
*
   60 CONTINUE
      IF(INWVOL.NE.1)GO TO 70
      CALL UCOPY(VECT,POINTS,7)
      POINTS(8,1)=SLENG
      POINTS(9,1)=0.
      POINTS(9,2)=VECT(7)/GETOT
      POINTS(8,2)=0.0
      POINTS(10,1)  =  TOFG
      NPOINT=1
      BETA0=POINTS(9,2)
      IF(AMASS.NE.0.) GAMA0=GETOT/AMASS
      IF(CUSET.EQ.'EE  ')  CALL EEPAR(PENUM,BETA0,GAMA0)
      GO TO 110
   70 POINTS(9,1)=POINTS(9,1)+DESTEP
*-- Start of code section for SET EE or EB
      IF(CUSET.EQ.'EE  ') THEN
         CALL EEPAR(PENUM,BETA0,GAMA0)
         BETA0=VECT(7)/GETOT
         GAMA0=GETOT/AMASS
         POINTS(8,2)=POINTS(8,2)+PENUM
      ENDIF
      IF(CUSET.EQ.'EB  ') THEN
         CALL EBPAR(PENUM)
         POINTS(8,2)=POINTS(8,2)+PENUM
      ENDIF
*
   80 IF(INWVOL.NE.2.AND.ISTOP.LE.0)GO TO 110
      IF(CUSET.EQ.'EB  ')CALL EBHITS
      IF(CUSET.EQ.'EE  ')CALL EEHITS
      IF(CUSET.EQ.'FD  ')CALL FDHITS
      IF(CUSET.EQ.'SW  ')CALL SWHITS
      IF(CUSET.EQ.'HB  ')CALL HBHITS
      IF(CUSET.EQ.'HE  ')CALL HEHITS
      IF(CUSET.EQ.'HP  ')CALL HPHITS
      IF(CUSET.EQ.'FF  ')CALL FFHITS
      GO TO 110
*
*--
*--  Thin drift chamber (3) e.g. muon barrel chamber.
*    ( IDTYPE = 3 )
*
   90 CONTINUE
      IF(INWVOL.NE.1)GO TO 100
      CALL UCOPY(VECT,POINTS,7)
      POINTS(8,1)=SLENG
      POINTS(9,1)=0.
      NPOINT=1
      GO TO 110
  100 POINTS(9,1)=POINTS(9,1)+DESTEP
      IF(INWVOL.NE.2.AND.ISTOP.LE.0)GO TO 110
      IF(CUSET.EQ.'MB  ') CALL MBHITS
      GO TO 110
  110 CONTINUE
*.
*         Treat gammas in FDET calorimeter ..
      IF( IPART .EQ. 1 .AND. ABS( VECT(3)) .GT. 230. )
     +                                             CALL FDGAMA
*
 1000 FORMAT(' GUSTFU:   MAXIMUM NUMBER OF HITS',I6,
     +' REACHED, TRACK NO.',I4,' NTMULT',I5)
 1100 FORMAT(' (x,y,z)=',3F8.2,' momentum =',F8.4,' GeV/c; last step',
     +F8.4,2X,5A4)
      END
+DECK, GUTREV.
      SUBROUTINE GUTREV
*.
*...GUTREV   User routine to control tracking of one event.
*.
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCDRAW GCFLAG GCLIST GOFLAG
*. CALLS     : DZVERI GDCHIT GDHITS GDOPT  GDPART GDSHOW GDXYZ  GPRINT
*. CALLS     : GRLEAS GTREVE TVNEXT TVSHOW UCTOH  ZPHASE
*. CALLED    : GTRIG
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.01
*. CREATED   : 25-Dec-84
*. LAST MOD  : 12-Jan-90
*.
*. Modification Log.
*. 12-Jan-90   D.R.Ward        Add timing calls
*.  3-Jul-89   D.R.Ward        Check if *FILE card present
*. 26-Apr-89   D.R.Ward        Problem with graphics if no CJ
*.  2-Mar-89   S.O'Neale       Bug fix - if no graphics selected
*.  8-Feb-89   J.Banks         Call SMTREV for all smear mode
*. 14-Feb-89   D.R.Ward        Mods for new CJ HITS format
*. 14-Feb-89   D.R.Ward        Use '*   ' instead of '*'
*. 14-Nov-88   A.Buijs         Mods for GEANT312 (still)
*. 26-Sep-88   D.R.Ward        Remove GOTREV call.
*.  9-Sep-88   D.R.Ward        Call GOTREV (if GEANT312) - this may be o
*.                             a temporary fix.
*.  6-Sep-88   D.R.Ward        use HIGZ graphics
*.  9-May-88   R.J.Hemingway   lose blank frames
*. 25-Apr-88   D.R.Ward        Strong typing
*.  1-Sep-87   D.R.Ward        Default view 'OPAL'
*. 01-Jun-87   B.Lorazo        Drawing of views CDET and VERT added
*. 31-Dec-86   S.O'Neale       Set operation phase for ZEBRA recovery
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ, ROBANK.
+SEQ, GCFLAG.
+SEQ, GCLIST.
+SEQ, GCDRAW.
+SEQ, GOFLAG.
+SEQ, GOLOGI.
+SEQ, GOFILE.
+SEQ, RCREP.
*
      REAL     TIM0,TIM1
      INTEGER   ICTEST(8),J,I,NVTYPE,NVOPT,IJTEST,IUCOMP,JUCOMP
      EXTERNAL IUCOMP,JUCOMP
      CALL UCTOH ('OPALCDETVERTFULLFRONSIDETOP MIXE',ICTEST,4,32)
*
*     ------------------------------------------------------------------
*
      CALL TIMEX(TIM0)
*--   Set operation phase 20 for ZEBRA recovery.
      CALL ZPHASE(20)
*
*--   Skip tracking/hits if hits are read from tape
*
*
*--   If all smear mode use SMTREV to track events
*
      IF (LSMTRK) THEN
        CALL SMTREV
        GOTO 20
      END IF
*
      IF(NGET.EQ.0)GO TO 10
      CALL UCTOH('HITS',IJTEST,4,4)
      IF(IUCOMP(IJTEST,LGET,NGET).NE.0)GO TO 20
*
   10 IF(IUTRAK.EQ.0) GO TO 20
*
      CALL GTREVE
      CALL GOTSTE
*
*--   Release unused space in JHITS
*
+SELF,IF=DBUGMEMO.
      CALL DZVERI(' GOPAL: Verification after GTREVE ',IXSTOR,'CFLSU')
+SELF.
      CALL GRLEAS(JHITS)
+SELF,IF=DBUGMEMO.
      CALL DZVERI(' GOPAL: Verification GRLEAS(JHITS)',IXSTOR,'CFLSU')
+SELF.
*
*              Debug
*
   20 IF (NPLOT .EQ. 0) GOTO 80
+SELF,IF=GKS,HIGZ.
      IF (IEVENT.GE.LPLOT(1).AND.IEVENT.LE.LPLOT(2)) THEN
         IF(JUCOMP('METO',IONAME,NFILE).EQ.0) THEN
            CHREP='PLOT requested but no *FILE ''META'' card'
            CALL REPORT('GUTREV',1,'E')
            GO TO 80
         ENDIF
*--     Loops over the possible VIEWs.
         NVTYPE = 3
         NVOPT =4
         DO 30 I=1,NVTYPE
            IF(IUCOMP(ICTEST(I),LVIEW,20).NE.0) GO TO 40
   30    CONTINUE
         LVIEW(20)=ICTEST(1)
   40    DO 70 I = 1,NVTYPE
            IF (IUCOMP (ICTEST(I) ,LVIEW ,20) .NE. 0) THEN
               DO 60 J = 1,NVOPT
                  IF (J.EQ.2) GO TO 60
                  IF ((I.EQ.1) .AND. (J.EQ.4)) GOTO 60
                  IF (IUCOMP (ICTEST(J+4) ,LVIEW ,20) .NE. 0) THEN
*--             Display the stored view
                     CALL GDSHOW(J + (I-1)*4)
*--             Tracks and hits seen in R-Z projection.
                     CALL GDOPT('THRZ','ON  ')
*--             Display the track trajectory
                     CALL GDXYZ(0)
*--             Display the track number and particle name
                     CALL GDPART(0,11,0.25)
+SELF,IF=GKS,HIGZ.
*--             Display the Central Detector hits as points.
                     CALL GDHITS('SI  ','*   ', 0, -1, 0.01)
                     CALL GDHITS('CV  ','*   ', 0, -1, 0.01)
                     CALL UCTOH('CJ  ',IJTEST,4,4)
                     IF(IUCOMP(IJTEST,LGEOM,NGEOM).NE.0) CALL CJHNOC
                     CALL GDHITS('CJ  ','CJET', 0, -1, 0.01)
                     CALL GDHITS('CZ  ','*   ', 0, -1, 0.01)
                     IF (I .NE. 1) GOTO 50
*--             Display the Time of flight hits
                     CALL GDHITS('TB  ','*   ', 0, 0, 0.10)
*--             Display the Presampler hits
                     CALL GDHITS('PB  ','*   ', 0, 0, 0.10)
                     CALL GDHITS('PE  ','*   ',  0,   0, 0.10)
*--             Display the Forward detector hits
                     CALL GDHITS('FD  ','*   ', 0, 0, 0.10)
                     CALL GDHITS('SW  ','*   ', 0, 0, 0.10)
*--             Display the EM hits (<pe>) as scaled boxes
                     CALL GDCHIT('EB  ','*   ', 0, 841,1.0,7,40.,1000.)
                     CALL GDCHIT('EE  ','*   ', 0, 841,1.0,7,40.,1000.)
*--             Display the Hadron hits (streamers) as triangles
                     CALL GDHITS('HB  ','*   ', 0, 842, 0.10)
                     CALL GDHITS('HE  ','*   ', 0, 842, 0.10)
                     CALL GDHITS('HP  ','*   ', 0, 842, 0.10)
*--             Display the Muon detector hits as stars
                     CALL GDHITS('ME  ','*   ', 0, 844, 0.10)
                     CALL GDHITS('MB  ','*   ', 0, 844, 0.10)
                     CALL ICLRWK(0,0)
   50                CONTINUE
                  ENDIF
   60          CONTINUE
            ENDIF
   70    CONTINUE
      ENDIF
+SELF.
*
   80 IF(IDEBUG.EQ.0)GO TO 90
      IF(ISWIT(2).EQ.1)CALL GPRINT('JXYZ',0)
      IF(ISWIT(3).NE.0)CALL GPHITS('*   ','*   ')
*
   90 CALL TIMEX(TIM1)
      IQ(LMCS+4)=IQ(LMCS+4)+INT(100.*(TIM1-TIM0))
      RETURN
      END
+DECK, GUVIEW, IF=GKS,HIGZ.
      SUBROUTINE GUVIEW (IDS ,IVS ,ICS ,IVIEW)
*.
*...GUVIEW  Sets drawing attributes and draws view (cut, etc...)
*.
*. INPUT     : IDS    Detector name
*. INPUT     : IVS    View name
*. INPUT     : ICS    Complexity name
*. INPUT     : IVIEW  View number
*. OUTPUT    :
*.
*. COMMON    :
*. SEQUENCE  : GOCART
*. CALLS     : GDAXIS GDCLOS GDCOL  GDELET GDHEAD GDGIRL GDOPEN GDRAW
*. CALLS     : GDRAWC GSATT  UCTOH   TOH
*. CALLED    : UGINIT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.01
*. CREATED   : 25-Dec-84
*. LAST MOD  :  7-Jul-94
*.
*. Modification Log.
*.  7-Jul-94   C.P.Ward        GDGIRL --> GDWMN1
*. 18-Jul-91   D.R.Ward        GDMAN --> GDGIRL
*. 24-Sep-90   R.J.Hemingway   Update colours/HB
*. 21-May-90   R.J.Hemingway   Centre pix
*.  7-Apr-90   D.R.Ward        Fix MB problem
*.  3-Jul-89   D.R.Ward        CJ0+ is no more
*. 10-Oct-88   S.Hou           Fix up HE
*.  1-Sep-88   D.R.Ward        Tidy up GSATT calls
*. 16-Aug-88   D.R.Ward        Change GSATT(0 calls for GEANT312
*.  9-May-88   D.R.Ward        Fix up ME attributes.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 16-Dec-87   R. Hospes       Drawing attributes for CL volumes
*. 27-May-87   B. Lorazo       CDET and VERT views defined.
*. 10-Sep-86   S.O'Neale       Use UCTOH to remove compiler warnings.
*.  6-Jul-86   S.O'Neale       Drawing attributes for PE.
*.  5-Jul-86   S.O'Neale       Drawing attributes for EB light guides.
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*     -----------------
*--
*--       IDS, the detector selected, can be :
*--
*--       'OPAL' = opal detector
*--       'HADR' = hadron calorimeter (not implemented)
*--       'CDET' = central detector
*--       'VERT' = vertex detector
*--
*--
*--       IVS, the view selected, can be :
*--
*--       'FRON' = front view (looking along Z axis)
*--       'SIDE' = side view  (looking along X axis - not implemented)
*--       'TOP ' = top view   (looking along Y axis)
*--       'MIXE' = mixed (inclined) view (CDET and VERT only)
*--
*--
*--       ICS, the complexity selected, can be :
*--
*--       'FULL' = full detailed picture, useful to produce
*--                reference drawings
*--
*--       'FAST' = fast picture, with less details than
*--                the former, but useful in interactive sessions
*--
*--
*--       IVIEW, the view bank selected, can be :
*--
*--       0   = draw the view on screen
*--       > 0 = draw the view on view bank IVIEW
*--
+SEQ, GOCART.
+SEQ, GCBANK.
*
      INTEGER   IDSEL(3) ,IVSEL(4),ICSEL( 2)
      INTEGER IUCOMP,JDS,JVS,JCS,ID,IV,IC,IVIEW
      EXTERNAL IUCOMP
      CHARACTER *(*) IDS,IVS,ICS
*  ---------------------------------------------------------------------
*
      CALL UCTOH('OPALCDETVERT' ,IDSEL ,4 ,12)
      CALL UCTOH('FRONSIDETOP MIXE' ,IVSEL ,4 ,16)
      CALL UCTOH('FULLFAST' ,ICSEL ,4 ,8)
      CALL UCTOH(IDS,JDS,4,4)
      CALL UCTOH(IVS,JVS,4,4)
      CALL UCTOH(ICS,JCS,4,4)
*
      ID=IUCOMP(JDS,IDSEL, 3)
      IV=IUCOMP(JVS,IVSEL, 4)
      IC=IUCOMP(JCS,ICSEL, 2)
      IF (ID.EQ.0.OR.IV.EQ.0.OR.IC.EQ.0) GO TO 10
*
      IF (ID.EQ.1) THEN
         IF (IV.EQ.1) THEN
            IF (IC.EQ.1) THEN
*
*    Set attributes to draw OPAL FRONt view with FULL complexit
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('HEPS','SEEN',-1)
               CALL GSATT ('HEPN','SEEN',-1)
               CALL GSATT ('HE  ','SEEN',-1)
               CALL GSATT ('HRO+','SEEN',-1)
               CALL GSATT ('MEL ','SEEN',-1)
               CALL GSATT ('MER ','SEEN',-1)
               CALL GSATT ('ECA-','SEEN',-1)
               CALL GSATT ('CV  ','SEEN',0)
               CALL GSATT ('CVPC','SEEN',1)
               CALL GSATT ('CVSC','SEEN',1)
               CALL GSATT ('CJET','SEEN',1)
               CALL GSATT ('CZC ','SEEN',1)
               CALL GSATT ('COI+','SEEN',1)
               CALL GSATT ('PB  ','SEEN',-2)
               CALL GSATT ('CTP-','SEEN',1)
               CALL GSATT ('TB  ','SEEN',1)
               CALL GSATT ('TPTR','SEEN',1)
               CALL GSATT ('EBPB','SEEN',1)
               CALL GSATT ('EBLG','SEEN',1)
               CALL GSATT ('EBS2','SEEN',1)
*RYH           CALL GSATT ('EBS3','SEEN',1)
               CALL GSATT ('BTU1','SEEN',1)
               CALL GSATT ('BTU2','SEEN',1)
               CALL GSATT ('HBLV','SEEN',1)
               CALL GSATT ('HBLO','SEEN',1)
               CALL GSATT ('HBLT','SEEN',1)
               CALL GSATT ('HBLU','SEEN',1)
               CALL GSATT ('HBSV','SEEN',1)
               CALL GSATT ('HBSO','SEEN',1)
               CALL GSATT ('HBST','SEEN',1)
               CALL GSATT ('HBSU','SEEN',1)
               CALL GSATT ('MBCH','SEEN',1)
               CALL GSATT ('HBA1','SEEN',1)
               CALL GSATT ('HBA2','SEEN',1)
               CALL GSATT ('HBA3','SEEN',1)
               CALL GSATT ('HBA4','SEEN',1)
               CALL GSATT ('HBA5','SEEN',1)
               CALL GSATT ('HBA6','SEEN',1)
               CALL GSATT ('HBA7','SEEN',1)
               CALL GSATT ('HBA8','SEEN',1)
               CALL GSATT ('HBA9','SEEN',1)
               CALL GSATT ('HBB1','SEEN',1)
               CALL GSATT ('HBB2','SEEN',1)
               CALL GSATT ('HBB3','SEEN',1)
               CALL GSATT ('HBB4','SEEN',1)
               CALL GSATT ('HBB5','SEEN',1)
               CALL GSATT ('HBB6','SEEN',1)
               CALL GSATT ('HBB7','SEEN',1)
               CALL GSATT ('HBB8','SEEN',1)
               CALL GSATT ('HBB9','SEEN',1)
               CALL GSATT ('HBC1','SEEN',1)
               CALL GSATT ('HBC2','SEEN',1)
               CALL GSATT ('HBC3','SEEN',1)
               CALL GSATT ('HBC4','SEEN',1)
               CALL GSATT ('HBC5','SEEN',1)
               CALL GSATT ('HBC6','SEEN',1)
               CALL GSATT ('HBC7','SEEN',1)
               CALL GSATT ('HBC8','SEEN',1)
               CALL GSATT ('HBC9','SEEN',1)
               CALL GSATT ('HBD1','SEEN',1)
               CALL GSATT ('HBD2','SEEN',1)
               CALL GSATT ('HBD3','SEEN',1)
               CALL GSATT ('HBD4','SEEN',1)
               CALL GSATT ('HBD5','SEEN',1)
               CALL GSATT ('HBD6','SEEN',1)
               CALL GSATT ('HBD7','SEEN',1)
               CALL GSATT ('HBD8','SEEN',1)
               CALL GSATT ('HBD9','SEEN',1)
               CALL GSATT ('CVPC','COLO',2)
               CALL GSATT ('CVSC','COLO',2)
               CALL GSATT ('CJET','COLO',2)
               CALL GSATT ('CZC ','COLO',2)
               CALL GSATT ('COI+','COLO',2)
               CALL GSATT ('CTP-','COLO',2)
               CALL GSATT ('TB  ','COLO',6)
               CALL GSATT ('TPTR','COLO',6)
               CALL GSATT ('EBPB','COLO',3)
               CALL GSATT ('EBLG','COLO',3)
               CALL GSATT ('EBS2','COLO',3)
               CALL GSATT ('BTU1','COLO',2)
               CALL GSATT ('HBLV','COLO',4)
               CALL GSATT ('HBLO','COLO',4)
               CALL GSATT ('HBLT','COLO',4)
               CALL GSATT ('HBLU','COLO',4)
               CALL GSATT ('HBSV','COLO',4)
               CALL GSATT ('HBSO','COLO',4)
               CALL GSATT ('HBST','COLO',4)
               CALL GSATT ('HBSU','COLO',4)
               CALL GSATT ('HBA1','COLO',4)
               CALL GSATT ('HBA2','COLO',4)
               CALL GSATT ('HBA3','COLO',4)
               CALL GSATT ('HBA4','COLO',4)
               CALL GSATT ('HBA5','COLO',4)
               CALL GSATT ('HBA6','COLO',4)
               CALL GSATT ('HBA7','COLO',4)
               CALL GSATT ('HBA8','COLO',4)
               CALL GSATT ('HBA9','COLO',4)
               CALL GSATT ('HBB1','COLO',4)
               CALL GSATT ('HBB2','COLO',4)
               CALL GSATT ('HBB3','COLO',4)
               CALL GSATT ('HBB4','COLO',4)
               CALL GSATT ('HBB5','COLO',4)
               CALL GSATT ('HBB6','COLO',4)
               CALL GSATT ('HBB7','COLO',4)
               CALL GSATT ('HBB8','COLO',4)
               CALL GSATT ('HBB9','COLO',4)
               CALL GSATT ('HBC1','COLO',4)
               CALL GSATT ('HBC2','COLO',4)
               CALL GSATT ('HBC3','COLO',4)
               CALL GSATT ('HBC4','COLO',4)
               CALL GSATT ('HBC5','COLO',4)
               CALL GSATT ('HBC6','COLO',4)
               CALL GSATT ('HBC7','COLO',4)
               CALL GSATT ('HBC8','COLO',4)
               CALL GSATT ('HBC9','COLO',4)
               CALL GSATT ('HBD1','COLO',4)
               CALL GSATT ('HBD2','COLO',4)
               CALL GSATT ('HBD3','COLO',4)
               CALL GSATT ('HBD4','COLO',4)
               CALL GSATT ('HBD5','COLO',4)
               CALL GSATT ('HBD6','COLO',4)
               CALL GSATT ('HBD7','COLO',4)
               CALL GSATT ('HBD8','COLO',4)
               CALL GSATT ('HBD9','COLO',4)
               CALL GSATT ('MBCH','COLO',170)
               CALL GDELET(IVIEW)
               CALL GDOPEN(IVIEW)
               CALL GDHEAD(001111,'Cross-section$',0.7)
               CALL GDRAWC('OPAL',3,1.001,10.,9.5 ,9.5/CAOPAL(3),
     +            9.5/CAOPAL(3))
               CALL GDCOL(-1)
               CALL GDAXIS(-700.,-650.,0.,100.)
+SELF,IF=GEANT315.
               CALL GDGIRL(19.,2.2)
+SELF,IF=-GEANT315.
               CALL GDWMN1(19.,2.2)
+SELF.
               CALL GDCLOS
*
            ELSE IF (IC.EQ.2) THEN
*
*     Set attributes to draw OPAL FRONt view with FAST option
*
               IF(GVERSN.LT.3.12) THEN
                  CALL GSATT ( 0,'SEEN',0)
               ELSE
                  CALL GSATT('*','SEEN',0)
               ENDIF
               CALL GSATT ('HP  ','SEEN',-2)
               CALL GSATT ('EE  ','SEEN',-2)
               CALL GSATT ('FD  ','SEEN',-2)
               CALL GSATT ('SW  ','SEEN',-2)
               CALL GSATT ('CV  ','SEEN',-2)
               CALL GSATT ('CC  ','SEEN',0)
               CALL GSATT ('CZC ','SEEN',1)
               CALL GSATT ('CTP-','SEEN',1)
               CALL GSATT ('TB  ','SEEN',1)
               CALL GSATT ('EB  ','SEEN',-2)
               CALL GSATT ('BTU1','SEEN',-2)
               CALL GSATT ('HE  ','SEEN',-1)
               CALL GSATT ('HRO+','SEEN',-1)
               CALL GSATT ('HBLA','SEEN',-2)
               CALL GSATT ('HBSA','SEEN',-2)
               CALL GSATT ('HBLB','SEEN',-2)
               CALL GSATT ('HBSB','SEEN',-2)
               CALL GSATT ('MB  ','SEEN',-1)
               CALL GSATT ('MEL ','SEEN',-1)
               CALL GSATT ('MER ','SEEN',-1)
               CALL GDELET(IVIEW)
               CALL GDOPEN(IVIEW)
               CALL GDRAWC('OPAL',3,0.001,10.,10. ,9.5/CAOPAL(3),
     +            9.5/CAOPAL(3))
               CALL GDCLOS
            ENDIF
         ELSE IF (IV.EQ.3) THEN
            IF (IC.EQ.1) THEN
*
*    Set attributes to draw OPAL TOP  view with FULL complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('HEPS','SEEN',1)
               CALL GSATT ('HEPN','SEEN',1)
               CALL GSATT ('HE  ','SEEN',1)
               CALL GSATT ('HRO+','SEEN',1)
               CALL GSATT ('FD  ','SEEN',1)
               CALL GSATT ('SW  ','SEEN',1)
               CALL GSATT ('HPO ','SEEN',1)
               CALL GSATT ('HPLA','SEEN',-1)
               CALL GSATT ('HPIM','SEEN',1)
               CALL GSATT ('HPCM','SEEN',1)
               CALL GSATT ('HPII','SEEN',1)
               CALL GSATT ('EES1','SEEN',1)
               CALL GSATT ('EES2','SEEN',1)
               CALL GSATT ('EEG1','SEEN',1)
               CALL GSATT ('EEG2','SEEN',1)
               CALL GSATT ('EEG3','SEEN',1)
               CALL GSATT ('EEG4','SEEN',1)
               CALL GSATT ('EEG5','SEEN',1)
               CALL GSATT ('EEG6','SEEN',1)
               CALL GSATT ('EEG7','SEEN',1)
               CALL GSATT ('EEG8','SEEN',1)
               CALL GSATT ('FE  ','SEEN',1)
               CALL GSATT ('FES ','SEEN',-2)
               CALL GSATT ('FL  ','SEEN',-2)
               CALL GSATT ('FP  ','SEEN',1)
               CALL GSATT ('FK  ','SEEN',-2)
               CALL GSATT ('CP0+','SEEN',1)
               CALL GSATT ('CP1+','SEEN',1)
               CALL GSATT ('CP2+','SEEN',1)
               CALL GSATT ('CP3+','SEEN',1)
               CALL GSATT ('CP4+','SEEN',1)
               CALL GSATT ('CZC ','SEEN',1)
               CALL GSATT ('CZZD','SEEN',1)
               CALL GSATT ('CJ1+','SEEN',1)
               CALL GSATT ('CJ3+','SEEN',1)
               CALL GSATT ('CJ4+','SEEN',1)
               CALL GSATT ('CJC+','SEEN',1)
               CALL GSATT ('CLB+','SEEN',1)
               CALL GSATT ('CLC+','SEEN',1)
               CALL GSATT ('CLW+','SEEN',1)
               CALL GSATT ('CLH+','SEEN',1)
               CALL GSATT ('CLI+','SEEN',1)
               CALL GSATT ('CLO+','SEEN',1)
               CALL GSATT ('CLP+','SEEN',1)
               CALL GSATT ('CL0+','SEEN',1)
               CALL GSATT ('CLA+','SEEN',1)
               CALL GSATT ('CVE+','SEEN',1)
               CALL GSATT ('CVS+','SEEN',1)
               CALL GSATT ('CVI+','SEEN',1)
               CALL GSATT ('COI+','SEEN',1)
               CALL GSATT ('PB  ','SEEN',-2)
               CALL GSATT ('TB  ','SEEN',1)
               CALL GSATT ('TPTR','SEEN',1)
               CALL GSATT ('EBPB','SEEN',1)
               CALL GSATT ('EBLG','SEEN',1)
               CALL GSATT ('EBS2','SEEN',1)
*RYH           CALL GSATT ('EBS3','SEEN',1)
               CALL GSATT ('BTU1','SEEN',1)
               CALL GSATT ('HBLV','SEEN',1)
               CALL GSATT ('HBLO','SEEN',1)
               CALL GSATT ('HBLT','SEEN',1)
               CALL GSATT ('HBLU','SEEN',1)
               CALL GSATT ('HBSV','SEEN',1)
               CALL GSATT ('HBSO','SEEN',1)
               CALL GSATT ('HBST','SEEN',1)
               CALL GSATT ('HBSU','SEEN',1)
               CALL GSATT ('MBCH','SEEN',1)
               CALL GSATT ('MEQD','SEEN',-2)
               CALL GSATT ('MEPA','SEEN',-2)
               CALL GSATT ('HBA1','SEEN',1)
               CALL GSATT ('HBA2','SEEN',1)
               CALL GSATT ('HBA3','SEEN',1)
               CALL GSATT ('HBA4','SEEN',1)
               CALL GSATT ('HBA5','SEEN',1)
               CALL GSATT ('HBA6','SEEN',1)
               CALL GSATT ('HBA7','SEEN',1)
               CALL GSATT ('HBA8','SEEN',1)
               CALL GSATT ('HBA9','SEEN',1)
               CALL GSATT ('HBB1','SEEN',1)
               CALL GSATT ('HBB2','SEEN',1)
               CALL GSATT ('HBB3','SEEN',1)
               CALL GSATT ('HBB4','SEEN',1)
               CALL GSATT ('HBB5','SEEN',1)
               CALL GSATT ('HBB6','SEEN',1)
               CALL GSATT ('HBB7','SEEN',1)
               CALL GSATT ('HBB8','SEEN',1)
               CALL GSATT ('HBB9','SEEN',1)
               CALL GSATT ('HBC1','SEEN',1)
               CALL GSATT ('HBC2','SEEN',1)
               CALL GSATT ('HBC3','SEEN',1)
               CALL GSATT ('HBC4','SEEN',1)
               CALL GSATT ('HBC5','SEEN',1)
               CALL GSATT ('HBC6','SEEN',1)
               CALL GSATT ('HBC7','SEEN',1)
               CALL GSATT ('HBC8','SEEN',1)
               CALL GSATT ('HBC9','SEEN',1)
               CALL GSATT ('HBD1','SEEN',1)
               CALL GSATT ('HBD2','SEEN',1)
               CALL GSATT ('HBD3','SEEN',1)
               CALL GSATT ('HBD4','SEEN',1)
               CALL GSATT ('HBD5','SEEN',1)
               CALL GSATT ('HBD6','SEEN',1)
               CALL GSATT ('HBD7','SEEN',1)
               CALL GSATT ('HBD8','SEEN',1)
               CALL GSATT ('HBD9','SEEN',1)
               CALL GSATT ('HEPS','COLO',4)
               CALL GSATT ('HEPN','COLO',4)
               CALL GSATT ('HE  ','COLO',4)
               CALL GSATT ('HRO+','COLO',4)
               CALL GSATT ('FD  ','COLO',1)
               CALL GSATT ('SW  ','COLO',1)
               CALL GSATT ('FE  ','COLO',1)
               CALL GSATT ('FES ','COLO',1)
               CALL GSATT ('FL  ','COLO',1)
               CALL GSATT ('FP  ','COLO',1)
               CALL GSATT ('FK  ','COLO',1)
               CALL GSATT ('HPO ','COLO',4)
               CALL GSATT ('HPIM','COLO',4)
               CALL GSATT ('HPCM','COLO',4)
               CALL GSATT ('HPII','COLO',4)
               CALL GSATT ('EES1','COLO',3)
               CALL GSATT ('EES2','COLO',3)
               CALL GSATT ('EEG1','COLO',3)
               CALL GSATT ('EEG2','COLO',3)
               CALL GSATT ('EEG3','COLO',3)
               CALL GSATT ('EEG4','COLO',3)
               CALL GSATT ('EEG5','COLO',3)
               CALL GSATT ('EEG6','COLO',3)
               CALL GSATT ('EEG7','COLO',3)
               CALL GSATT ('EEG8','COLO',3)
               CALL GSATT ('CP0+','COLO',2)
               CALL GSATT ('CP1+','COLO',2)
               CALL GSATT ('CP2+','COLO',2)
               CALL GSATT ('CP3+','COLO',2)
               CALL GSATT ('CP4+','COLO',2)
               CALL GSATT ('CZC ','COLO',2)
               CALL GSATT ('CZZD','COLO',2)
               CALL GSATT ('CJ1+','COLO',2)
               CALL GSATT ('CJ3+','COLO',2)
               CALL GSATT ('CJ4+','COLO',2)
               CALL GSATT ('CJC+','COLO',2)
               CALL GSATT ('CLB+','COLO',2)
               CALL GSATT ('CLC+','COLO',2)
               CALL GSATT ('CLW+','COLO',2)
               CALL GSATT ('CLH+','COLO',2)
               CALL GSATT ('CLI+','COLO',2)
               CALL GSATT ('CLO+','COLO',2)
               CALL GSATT ('CLP+','COLO',2)
               CALL GSATT ('CL0+','COLO',2)
               CALL GSATT ('CLA+','COLO',2)
               CALL GSATT ('CVE+','COLO',2)
               CALL GSATT ('CVS+','COLO',2)
               CALL GSATT ('CVI+','COLO',2)
               CALL GSATT ('COI+','COLO',2)
               CALL GSATT ('TB  ','COLO',6)
               CALL GSATT ('TPTR','COLO',6)
               CALL GSATT ('EBPB','COLO',3)
               CALL GSATT ('EBLG','COLO',3)
               CALL GSATT ('EBS2','COLO',3)
               CALL GSATT ('BTU1','COLO',2)
               CALL GSATT ('HBA1','COLO',4)
               CALL GSATT ('HBA2','COLO',4)
               CALL GSATT ('HBA3','COLO',4)
               CALL GSATT ('HBA4','COLO',4)
               CALL GSATT ('HBA5','COLO',4)
               CALL GSATT ('HBA6','COLO',4)
               CALL GSATT ('HBA7','COLO',4)
               CALL GSATT ('HBA8','COLO',4)
               CALL GSATT ('HBA9','COLO',4)
               CALL GSATT ('HBB1','COLO',4)
               CALL GSATT ('HBB2','COLO',4)
               CALL GSATT ('HBB3','COLO',4)
               CALL GSATT ('HBB4','COLO',4)
               CALL GSATT ('HBB5','COLO',4)
               CALL GSATT ('HBB6','COLO',4)
               CALL GSATT ('HBB7','COLO',4)
               CALL GSATT ('HBB8','COLO',4)
               CALL GSATT ('HBB9','COLO',4)
               CALL GSATT ('HBC1','COLO',4)
               CALL GSATT ('HBC2','COLO',4)
               CALL GSATT ('HBC3','COLO',4)
               CALL GSATT ('HBC4','COLO',4)
               CALL GSATT ('HBC5','COLO',4)
               CALL GSATT ('HBC6','COLO',4)
               CALL GSATT ('HBC7','COLO',4)
               CALL GSATT ('HBC8','COLO',4)
               CALL GSATT ('HBC9','COLO',4)
               CALL GSATT ('HBD1','COLO',4)
               CALL GSATT ('HBD2','COLO',4)
               CALL GSATT ('HBD3','COLO',4)
               CALL GSATT ('HBD4','COLO',4)
               CALL GSATT ('HBD5','COLO',4)
               CALL GSATT ('HBD6','COLO',4)
               CALL GSATT ('HBD7','COLO',4)
               CALL GSATT ('HBD8','COLO',4)
               CALL GSATT ('HBD9','COLO',4)
               CALL GSATT ('HBLV','COLO',4)
               CALL GSATT ('HBLO','COLO',4)
               CALL GSATT ('HBLT','COLO',4)
               CALL GSATT ('HBLU','COLO',4)
               CALL GSATT ('HBSV','COLO',4)
               CALL GSATT ('HBSO','COLO',4)
               CALL GSATT ('HBST','COLO',4)
               CALL GSATT ('HBSU','COLO',4)
               CALL GSATT ('MBCH','COLO',170)
               CALL GSATT ('MEQD','COLO',170)
               CALL GDELET(IVIEW)
               CALL GDOPEN(IVIEW)
               CALL GDHEAD(001111,'Horizontal section$',0.7)
               CALL GDRAWC('OPAL',2,8.45,10.,9.5 ,9.5/CAOPAL(3),
     +            9.5/CAOPAL(3))
               CALL GDCOL(-1)
               CALL GDAXIS(-650.,0.,-700.,100.)
+SELF,IF=GEANT315.
               CALL GDGIRL(19.,2.2)
+SELF,IF=-GEANT315.
               CALL GDWMN1(19.,2.2)
+SELF.
               CALL GDCLOS
            ELSE IF (IC.EQ.2) THEN
*
*             Set attributes to draw OPAL TOP  view with FAST option
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('HP  ','SEEN',-2)
               CALL GSATT ('EE  ','SEEN',-2)
               CALL GSATT ('FD  ','SEEN',-2)
               CALL GSATT ('SW  ','SEEN',-2)
               CALL GSATT ('CV  ','SEEN',-2)
               CALL GSATT ('CCP-','SEEN',0)
               CALL GSATT ('CJET','SEEN',1)
               CALL GSATT ('CL- ','SEEN',-2)
               CALL GSATT ('CLD-','SEEN',-2)
               CALL GSATT ('CZZD','SEEN',1)
               CALL GSATT ('CTP-','SEEN',1)
               CALL GSATT ('TB  ','SEEN',1)
               CALL GSATT ('EB  ','SEEN',-2)
               CALL GSATT ('BTU1','SEEN',-2)
               CALL GSATT ('HE  ','SEEN',-2)
               CALL GSATT ('HB  ','SEEN',-2)
               CALL GSATT ('MB  ','SEEN',-1)
               CALL GSATT ('MEQD','SEEN',-2)
               CALL GSATT ('MEPA','SEEN',-2)
               CALL GDELET(IVIEW)
               CALL GDOPEN(IVIEW)
               CALL GDRAWC('OPAL',2,5.,10.,10. ,9.5/CAOPAL(3),
     +            9.5/CAOPAL(3))
               CALL GDCLOS
            ENDIF
         ENDIF
      ELSE IF (ID .EQ. 2) THEN
         IF (IV .EQ. 1) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw CDET FRONt view with FULL complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CVPC' ,'SEEN' , 1)
               CALL GSATT ('CVSC' ,'SEEN' , 1)
               CALL GSATT ('CCP-' ,'SEEN' , 1)
               CALL GSATT ('CZZD' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('C   ' , 3,0.001, 10. ,10. ,. 045,.045)
               CALL GDCLOS
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw CDET FRONt view with FAST complexity
*
               CALL GSATT ('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' ,-2)
               CALL GSATT ('CZZD' ,'SEEN' ,-2)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('C   ' , 3,0. 001,10. ,10. ,. 045,.045)
               CALL GDCLOS
            ENDIF
         ELSE IF (IV.EQ.2) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw CDET SIDE view with FULL complexity
*
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw CDET SIDE view with FAST complexity
*
            ENDIF
         ELSE IF (IV.EQ.3) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw CDET TOP view with FULL complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CJET' ,'SEEN' , 1)
               CALL GSATT ('CVSC' ,'SEEN' , 1)
               CALL GSATT ('CJ1+' ,'SEEN' , 1)
               CALL GSATT ('CJ3+' ,'SEEN' , 1)
               CALL GSATT ('CJ4+' ,'SEEN' , 1)
               CALL GSATT ('CJC+' ,'SEEN' , 1)
               CALL GSATT ('CJA+' ,'SEEN' , 1)
               CALL GSATT ('CLB+' ,'SEEN' , 1)
               CALL GSATT ('CLC+' ,'SEEN' , 1)
               CALL GSATT ('CLW+' ,'SEEN' , 1)
               CALL GSATT ('CLH+' ,'SEEN' , 1)
               CALL GSATT ('CLI+' ,'SEEN' , 1)
               CALL GSATT ('CLO+' ,'SEEN' , 1)
               CALL GSATT ('CZZD' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('C   ' , 2,0. 001,10. ,10. ,. 045,.045)
               CALL GDCLOS
*
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw CDET TOP view with FAST complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CJET' ,'SEEN' , 1)
               CALL GSATT ('CL- ' ,'SEEN' ,-2)
               CALL GSATT ('CZZD' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('C   ' , 2,0.001, 10. ,10. ,. 045,.045)
               CALL GDCLOS
            ENDIF
         ELSE IF (IV.EQ.4) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw CDET MIXEd view with FULL complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CVRP' ,'SEEN' , 1)
               CALL GSATT ('CVST' ,'SEEN' , 1)
               CALL GSATT ('CLC+' ,'SEEN' , 1)
               CALL GSATT ('CLH+' ,'SEEN' , 1)
               CALL GSATT ('CLO+' ,'SEEN' , 1)
               CALL GSATT ('CZC ' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAW ('C   ' ,30. ,60. ,0. ,10. ,10. ,. 0375,.0375)
               CALL GDCLOS
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw CDET MIXEd view with FAST complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CL- ' ,'SEEN' ,-2)
               CALL GSATT ('CZC ' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAW ('C   ' ,30. ,60. ,0. ,10. ,10. ,. 0375,.0375)
               CALL GDCLOS
            ENDIF
         ENDIF
      ELSE IF (ID .EQ. 3) THEN
         IF (IV .EQ. 1) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw VERT FRONt view with FULL complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CVPC' ,'SEEN' , 1)
               CALL GSATT ('CVSC' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('CV  ' , 3,0. 001,10. ,10. ,. 30,.30)
               CALL GDCLOS
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw VERT FRONt view with FAST complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('CV  ' , 3,0. 001,10. ,10. ,. 30,.30)
               CALL GDCLOS
            ENDIF
         ELSE IF (IV.EQ.2) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw VERT SIDE view with FULL complexity
*
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw VERT SIDE view with FAST complexity
*
            ENDIF
         ELSE IF (IV.EQ.3) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw VERT TOP view with FULL complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CVRP' ,'SEEN' , 1)
               CALL GSATT ('CVST' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('CV  ' , 2,0. 001,10. ,10. ,. 175,.175)
               CALL GDCLOS
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw VERT TOP view with FAST complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAWC ('CV  ' , 2,0. 001,10. ,10. ,. 175,.175)
               CALL GDCLOS
            ENDIF
         ELSE IF (IV.EQ.4) THEN
            IF (IC .EQ. 1) THEN
*
*         Sets attributes to draw VERT MIXEd view with FULL complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GSATT ('CVRP' ,'SEEN' , 1)
               CALL GSATT ('CVST' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAW ('CV  ' ,30. ,60. ,0. ,10. ,10. ,. 200,.200)
               CALL GDCLOS
            ELSE IF (IC .EQ. 2) THEN
*
*         Sets attributes to draw VERT MIXEd view with FAST complexity
*
               CALL GSATT('*','SEEN',0)
               CALL GSATT ('CV  ' ,'SEEN' , 1)
               CALL GDELET (IVIEW)
               CALL GDOPEN (IVIEW)
               CALL GDRAW ('CV  ' ,30. ,60. ,0. ,10. ,10. ,. 200,.200)
               CALL GDCLOS
            ENDIF
         ENDIF
      ENDIF
*
   10 RETURN
      END
+DECK,IDECOD.
      SUBROUTINE IDECOD (IDIIN,IDOUT)
*.
*...IDECOD
*.
*. Routine to "decode" the Particle Data Group Monte Carlo IDs
*.
*. INPUT     : IDIIN   The Particle Data Group ID to be decoded
*. OUTPUT    : IDOUT   The decoded ID (integer array of six elements)
*.
*. CALLS     : none
*. CALLED    : various
*.
*. AUTHOR    :  J.W.Gary
*. CREATED   :  08-May-89
*. LAST MOD  :  08-May-89
*.
*. Modification Log.
*.
*.********************************************************************
+SEQ,DECLARE.
      INTEGER  IDIIN,IDPDG,IDOUT (*)
 
      IDPDG = IABS (IDIIN)
      IDOUT (1) = MOD (IDPDG,10)
      IDOUT (2) = MOD (IDPDG/10,10)
      IDOUT (3) = MOD (IDPDG/100,10)
      IDOUT (4) = MOD (IDPDG/1000,10)
      IDOUT (5) = MOD (IDPDG/10000,10)
      IDOUT (6) = MOD (IDPDG/100000,10)
 
      RETURN
      END
+DECK,JUCOMP.
      INTEGER FUNCTION JUCOMP(CTEST,JLIST,NLIST)
*.
*...JUCOMP  As IUCOMP, but first argument is a character string,
*.  to be compared with JLIST, which is hollerith.
*.
*. INPUT     : CTEST   Character string to be tested
*. INPUT     : JLIST   Array of Holleriths
*. INPUT     : NLIST   Length of JLIST
*. OUTPUT    : JUCOMP  Address of match in JLIST - zero if none.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : UCTOH   CTOH
*. CALLED    : All over the place
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 12-May-87
*. LAST MOD  : 26-Apr-88
*.
*. Modification Log.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 12-May-87   D.R.Ward        First version
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
      CHARACTER *(*) CTEST
      INTEGER ITEST,NLIST,JLIST(*),IUCOMP
      EXTERNAL IUCOMP
      CALL UCTOH(CTEST,ITEST,4,4)
      JUCOMP=IUCOMP(ITEST,JLIST,NLIST)
      RETURN
      END
+DECK,KICOSM.
      SUBROUTINE KICOSM
*.
*...KICOSM   Routine for generation of cosmics
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCKINE GCONST
*. CALLS     : COSANG MZBOOK GFPART  GRNDM
*. CALLED    : GUKINE
*.
*. BANKS L   : KINE
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : P.Watkins
*. VERSION   : 1.00
*. CREATED   : 29-JUL-87
*. LAST MOD  : 08-Dec-93
*.
*. Modification Log.
*. 08-Dec-93   C.P.Ward        Remove unused variables.
*. 22-Feb-89   S.L.Lloyd       Change to PDG particle codes.
*. 17-May-88   D.Schaile       Change INDEX --> JNDEX (for Apollo)
*. 26-Apr-88   D.R.Ward        Strong typing
*. 25-Apr-88   P.M.Watkins     [Pmin,Pmax] default to [2.,200.] GeV/c
*. 22-Apr-88   S.L.Lloyd       Create particle tree bank
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCBANK
+SEQ,GCKINE
+SEQ,GCONST
+SEQ,LINKRA
      CHARACTER*20 CHPART
      REAL      VERTEX(3),PLAB(3),UB(10)
      REAL SURFAC(5),OUTVOL(3),R,COTHEC,PHIC,SITHEC, COSTH,SINTH,
     +THETA,PHI,PMIN,PMAX,PN,Z,Y,PUSER, SINPH,COSPH
      INTEGER ISURF(3),NP,LGENE,LENT,IOTREE,LTREE,KK,II,JNDEX ,J,NWB,
     +ITYPE
      DATA ISURF/2,3,1/
      DATA SURFAC/.3333,.5,.6666,.8332,1./
*    DEFINES PROBABILITIES(CUMULATIVE) FOR HITTING THE SURFACES
*    OF OPAL BOX. ORDER IS TOP ,ENDCAP +z,-z, SIDE +x,-x.
      DATA OUTVOL/700.,700.,700./
*    DEFINES BOX AS SURFACE FOR COSMICS AROUND OPAL IN CMS
*
*-- Create space for 2 tracks in case it interacts later.
*
      NP = 2
*
*-- Creates generated particle banks.
*
      LGENE = LQ(LMC-1)
      LENT = IQ(LGENE+5)
      IOTREE = IQ(LGENE+7)
*
      CALL MZBOOK (IXDIV,LTREE,LGENE,-1,'TREE',0,0,NP*LENT,IOTREE,0)
*
      IQ(LGENE+1) = 1
      IQ(LGENE+2) = 1
*
*     ------------------------------------------------------------------
*
*--   Cosmic  muon generator   ...............
*--       PKINE(1) = not used
*--       PKINE(2) = minimum momentum (GeV/c)
*--       PKINE(3) = maximum momentum (GeV/c)
*--       PKINE(4)-(7) not used
*--
*--   momentum, theta and phi distributions
*--   following the expected distributions in the opal pit.(internal mem
*--   J.Wilson Birmingham)
*..   VERTEX is the array of the coordinates of the cosmic
*..          as it enters the Opal detector volume.Size defined by outvo
*..   NVERT  is returned by GSVERT.
*..   PLAB   contains the momentum components of the cosmic
*..   ITYPE  is the GEANT mass code for the cosmic  (5 or 6)
*..
*
*     RANDOMLY CHOOSE BETWEEN TOP, END AND SIDE OPAL SURFACES
*     TOP SURFACE   ,  END CAPS(+Z OR -Z ) , SIDES  ( +X OR -X )
*     PROBABILITES ARE
*         1/3           1/6  1/6                1/6  1/6
      CALL GRNDM(R,1)
      DO 10 KK= 1,5
         IF(R.LE.SURFAC(KK))GO TO 20
   10 CONTINUE
   20 CONTINUE
*      FROM 5 SURFACES , NOW COMPUTE II=1 TOP, =2 END CAP, =3 SIDE
      IF(KK.EQ.1)II=1
      IF(KK.EQ.2.OR.KK.EQ.3)II=2
      IF(KK.EQ.4.OR.KK.EQ.5)II=3
      JNDEX = ISURF(II)
*      CHOOSE ANGULAR DISTRIBUTION APPROPRIATE TO THIS SURFACE
*      DIFFERENT COTHEC DISTN FOR TOP  AND OTHER SURFACES
      IF(KK.EQ.1)CALL COSANG(1,COTHEC)
      IF(KK.GT.1)CALL COSANG(2,COTHEC)
*      NOW DEAL WITH EACH SURFACE SEPARATELY FOR PHI DISTRIBUTION
*      TOP SURFACE
      IF(KK.EQ.1)THEN
*     SET ONE COORDINATE AT DESIRED SURFACE
         VERTEX(JNDEX) = OUTVOL(JNDEX)
         CALL GRNDM(R,1)
*     FLAT PHI DISTRIBUTION
         PHIC = TWOPI * R
      ENDIF
*     END CAP SURFACE
      IF(KK.GE.2.AND.KK.LT.4)THEN
         VERTEX (JNDEX) = OUTVOL(JNDEX)
         IF(KK.EQ.3) VERTEX(JNDEX) = - VERTEX(JNDEX)
*     SAMPLE FROM CORRECT COSMIC PHI DISTRIBUTION
         CALL COSANG(3,PHIC)
         IF(KK.EQ.3) PHIC = PHIC + PI
      ENDIF
*     SIDE SURFACE
      IF(KK.GE.4.AND.KK.LE.5)THEN
         VERTEX(JNDEX) = OUTVOL(JNDEX)
         IF(KK.EQ.5) VERTEX(JNDEX) = -VERTEX(JNDEX)
         CALL COSANG(4,PHIC)
         IF(KK.EQ.4) PHIC = PHIC + PI
      ENDIF
*
*       NOW NEED TO CHANGE FROM COSMIC COORDINATE SYSTEM TO STANDARD OPA
*       COSMIC SYSTEM MEASURE THETAC FROM OPAL Y AXIS AND PHIC IN
*       THE OPAL X Z PLANE FROM X AXIS.
*       OPAL MEASURES THETA FROM Z AXIS AND PHI IN XY PLANE FROM X AXIS
*       DOWNWARD COSMICS ONLY CONSIDERED
      COTHEC = - COTHEC
      PHIC = -PHIC
      SITHEC = SQRT ( 1. - COTHEC**2 )
      COSTH = SITHEC * SIN(PHIC)
      SINTH = SQRT (1. - COSTH **2)
      THETA= ACOS (COSTH)
      SINPH = COTHEC/ SINTH
      COSPH =(SITHEC * COS(PHIC))/SINTH
      PHI= ATAN2(SINPH,COSPH)
*  II = 1 TOP , =2  END CAP  =3  SIDES
      DO 30 J= 1,3
*   NOW DISTRIBUTE THE COSMIC UNIFORMLY OVER THE INTERSECTED SURFACE
         IF(ISURF(II).EQ.J)GO TO 30
         IF(J.EQ.2) THEN
            CALL GRNDM(R,1)
            VERTEX(J) = R * OUTVOL(J)
         ENDIF
*   FOR END CAPS AND SIDES USE LIMITED AREA TO INCREASE CHANCE OF
*   COSMIC PASSING THROUGH SEVERAL DETECTORS.
*   FOR RATE ESTIMATES THEN FOLLOWING CARD SHOULD ALSO BE JUST
*           RNDM() * OUTVOL(J)
         IF(J.NE.2) THEN
            CALL GRNDM(R,1)
            VERTEX(J) = R * OUTVOL(J)/3. -OUTVOL(J)/6.
         ENDIF
   30 CONTINUE
*    USE REQUESTED MINIMUM MOMENTUM.
*    SAMPLING ASSUMES NO UPPER LIMIT BUT ALLOW MAX MOMENTUM CUT TO
*    AVOID VERY HIGH MOMENTUM IF DESIRED.
      IF(PKINE(2).EQ.BIG) THEN
         PMIN=2.
      ELSE
         PMIN = PKINE(2)
      ENDIF
*    PN  IS  MAGNITUDE OF SLOPE OF LOG RATE VS LOG MOMENTUM IN PIT
      PN =  1.84375
      CALL GRNDM(Z,1)
      Y =(ALOG(1.-Z))/(1.-PN)
      PUSER = PMIN* EXP(Y)
      IF(PKINE(3).EQ.BIG) THEN
         PMAX=200.
      ELSE
         PMAX = PKINE(3)
      ENDIF
      IF (PUSER.GT.PMAX)     PUSER = PMAX
*    FILL PLAB WITH PX PY PZ OF COSMIC
      PLAB(1) = PUSER*SINTH * COS (PHI)
      PLAB(2) = PUSER*SINTH * SIN (PHI)
      PLAB(3) = PUSER*COSTH
*    CHOOSE 50% +/- MIX OF MUONS
      ITYPE   = 5
      CALL GRNDM(R,1)
      IF(R.GT.0.5)ITYPE = 6
*
*-- Find out what the charge and mass are.
*
      CALL GFPART (ITYPE,CHPART,ITRTYP,AMASS,CHARGE,TLIFE,UB,NWB)
*
*-- Fill the particle tree entries.
*
      IF (ITYPE.EQ.5) IQ(LTREE+1) = -13
      IF (ITYPE.EQ.6) IQ(LTREE+1) =  13
      IQ(LTREE+9) = 1
      Q(LTREE+10+1) = PLAB(1)
      Q(LTREE+10+2) = PLAB(2)
      Q(LTREE+10+3) = PLAB(3)
      Q(LTREE+10+4) = SQRT(PLAB(1)**2+PLAB(2)**2+PLAB(3)**2+ AMASS**2)
      Q(LTREE+10+5) = AMASS
      Q(LTREE+10+6) = CHARGE
      Q(LTREE+10+7) = VERTEX(1)
      Q(LTREE+10+8) = VERTEX(2)
      Q(LTREE+10+9) = VERTEX(3)
*
      RETURN
      END
+DECK,KIDISK.
      SUBROUTINE KIDISK
*.
*...KIDISK
*.
*. This routine reads an event from a file in a compressed ascii format
*. and then passes it to Gopal.
*. Events are handled sequentially according to the event number label.
*. The event number label is written as part of the event record headers
*. on the file being read.
*. Each call to this routine reads in one event and increments the event
*. number label by one so as to be ready the next time it is called.
*. The first event which is read from the file (i.e. on the first
*. call to this routine) is the one AFTER that specified on the RUNG
*. ffread card, i.e. ``RUNG  2 250'' will start with run 2, event 251.
*. This will also be the GEANT event number, which appears in the REV bank.
*. The events following the first are read regardless of the event
*. number label, however.
*. Thus the FFREAD cards
*.    RUNG 2 250
*.    TRIG 10
*. will read ten events, starting with the event labeled run 2 event 251;
*. the next nine events on the ascii file will then be read no matter
*. what the event number label on the ascii file might be.
*. If a vertex position is specified in the disk file (the VTX array)
*. then GOLIFE is not called; else it is called.  A vertex position is
*. specified by non-zero values of VTX(1), VTX(2) or VTX(3).
*. This facility is intended for the introduction of beam background
*. such as off momentum electrons, beam gas scatters etc.
*.
*. SEQUENCE  : ROBANK,ROPAR,GCFLAG
*. CALLS     : EVWRIT,GOGINT
*. CALLED    : GUKINE
*.
*. AUTHOR    :  J.W.Gary
*. CREATED   :  18-Mar-89
*. LAST MOD  :  21-Sep-98
*.
*. Modification Log.
*. 21-Sep-98  C.P.Ward      Increase MXTRK from 400 to 1000
*. 18-Feb-98  C.P.Ward      Calculate Ecm for every event.
*. 19-Apr-96  C.P.Ward      Explicitly remove ID=91,92,95 from Ecm calc.
*. 18-Apr-96  C.P.Ward      Fill run/evt in REV bank if no RUNG card
*.  5-Mar-93  D.R.Ward      Disable checking of run/event if no RUNG card
*. 31-Jul-92  D.R.Ward      Really always use 'F' option
*.  8-Jan-92  D.R.Ward      Always use 'F' option
*.  3-Jan-92  D.R.Ward      Permit binary files; internal file definition
*. 15-Apr-90  J.W.Gary      Fix logic for error handling
*.  6-Mar-90  D.R.Ward      Use IDEVT in EVWRIT if multi-cpu
*. 28-Feb-90  D.R.Ward      Use 'F' option if in multi-cpu mode
*. 15-Sep-89  D.R.Ward      VAX fix
*. 24-Jul-89  D.R.Ward      no default file on VAX - just logical name
*. 15-Jun-89  D.R.Ward      get LLOG from *FILE card if present.
*. 15-Jun-89  D.R.Ward      make card file event no. match GEANT
*.  2-Jun-89  D.R.Ward      Change for new header format
*. 19-Apr-89  J.W.Gary      Add calculation for ECM
*.
*.********************************************************************
+SEQ,DECLARE.
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,GOFILE.
+SEQ,GOKIDI.
+SEQ,GCFLAG.
+SEQ,CRO.
      INTEGER  LLOG,ITKDM,MXTRK,J,JUCOMP
      EXTERNAL JUCOMP
      PARAMETER (ITKDM=5,MXTRK=1000)
      INTEGER  NTRAK,IERR,IERRUN,IEREVT,IDUMM,IFIND,IID,IP,IERFST
      SAVE IERRUN,IEREVT,IERFST,ERECM
      INTEGER  IDTRAK (MXTRK),IHSTRY (MXTRK),IDKMPS (6)
      REAL  PTRAK (ITKDM,MXTRK),VTX (3)
      REAL  ERECM
      LOGICAL  DIQRK
      CHARACTER*1 CCOPT
      CHARACTER*11 CFORM
+SELF,IF=APOLLO,VAX,CRAY.
      CHARACTER*10  FILNAM
+SELF,IF=VAX,CRAY.
      DATA  FILNAM / 'KIDISK.DAT' /
+SELF,IF=APOLLO.
      DATA  FILNAM / 'kidisk.dat' /
+SELF.
      DATA  IERRUN / 0 /,IERFST / 0 /
 
      IF (IERFST.EQ.0) THEN
          IERFST = 1
*       first event to read (IDRUN offset by one from RUNG card)
*       ----- ----- -- ----  ----- ------ -- --- ---- ---- ----
          IERRUN = IDRUN
*DRW 15-6-89          IEREVT = IDEVT - 1
          IEREVT = IDEVT
          J=JUCOMP('KINI',IONAME,NFILE)
          CFORM='FORMATTED'
          IF(J.NE.0) THEN
             LLOG=IOUNIT(J)
             CALL UHTOC(IOFCHO(J),1,CCOPT,1)
             IF(CCOPT.EQ.'B') CFORM='UNFORMATTED'
          ELSE
             LLOG=33
             CCOPT=' '
          ENDIF
+SELF,IF=CRAY.
          IF(IOFNAM(J).EQ.'    ') THEN
             OPEN (UNIT=LLOG,FILE=FILNAM,STATUS='OLD',FORM=CFORM)
          ELSE
             OPEN (UNIT=LLOG,FILE=IOFNAM(J),STATUS='OLD',FORM=CFORM)
          ENDIF
+SELF,IF=APOLLO,SUN,SGI,HPUX,IBMRT,DECS,QMVAOS.
          IF(IOFNAM(J).EQ.'    ') THEN
             OPEN (UNIT=LLOG,STATUS='OLD',FORM=CFORM)
          ELSE
             OPEN (UNIT=LLOG,FILE=IOFNAM(J),STATUS='OLD',FORM=CFORM)
          ENDIF
+SELF,IF=IBM.
*SWON          OPEN (UNIT=LLOG,STATUS='OLD',ACCESS='SEQUENTIAL',
*SWON     +          FORM='FORMATTED',ACTION='READ')
+SELF,IF=VAX.
          IF(IOFNAM(J).EQ.'    ') THEN
             OPEN (UNIT=LLOG,STATUS='OLD',READONLY,SHARED,
     +       DEFAULTFILE='KIDISK',FORM=CFORM)
          ELSE
             OPEN (UNIT=LLOG,STATUS='OLD',READONLY,SHARED,
     +       FILE=IOFNAM(J),FORM=CFORM)
          ENDIF
+SELF.
*
*      First event -- Read IDRUN:IDEVT unless no RUNG card supplied
*
          J=JUCOMP('RUNI',IONAME,NFILE)
          IF(NORUNG .AND. (J.EQ.0 .OR. IEVENT.EQ.1)) THEN
             CALL EVWRIT (NTRAK,ITKDM,MXTRK,PTRAK,IDTRAK,IHSTRY,VTX,
     +                IERRUN,IEREVT,IDUMM,LLOG,'R'//CCOPT,IERR)
             IDRUN=IERRUN
             IDEVT=IEREVT         
             IRDRUN=IERRUN
             IRDEVT=IEREVT
             IQ(LREV+IIRUN) = IERRUN
             IQ(LREV+IIEVT) = IEREVT         
          ELSE
             CALL EVWRIT (NTRAK,ITKDM,MXTRK,PTRAK,IDTRAK,IHSTRY,VTX,
     +                IERRUN,IEREVT,IDUMM,LLOG,'F'//CCOPT,IERR)
          ENDIF
      ELSE
          CALL EVWRIT (NTRAK,ITKDM,MXTRK,PTRAK,IDTRAK,IHSTRY,VTX,
     +                IDRUN,IDEVT,IDUMM,LLOG,'F'//CCOPT,IERR)
      END IF
Comment      WRITE (6,FMT='('' KIDISK: IERRUN,IEREVT,NTRAK ='',3I10)')
Comment     +   IERRUN,IEREVT,NTRAK
*  get C.M. energy from first event using stable particles
*  --- ---- ------ ---- ----- ----- ----- ------ ---------
* CPW 18/02/98 get C.M. energy every event
*cpw      IF (IERFST.EQ.1) THEN
*cpw         IERFST = 2
         IF (IERR.NE.0) GO TO 990
         ERECM = 0.
         DO 160 IP=1,NTRAK
            IID = IABS (IDTRAK (IP))
            DIQRK = .FALSE.
            CALL IDECOD (IID,IDKMPS)
            IF (IDKMPS (2).EQ.0.AND.IDKMPS (4).NE.0) DIQRK = .TRUE.
            IF ((IID.LE.8.OR.IID.EQ.21.OR.DIQRK).OR.
     +          (IID.EQ.91.OR.IID.EQ.92.OR.IID.EQ.95.OR.IID.EQ.93)) 
     +           GO TO 160
            CALL KISTBL (NTRAK,IP,IHSTRY,IFIND)
            IF (IFIND.EQ.1) ERECM = ERECM + PTRAK (4,IP)
 160     CONTINUE
*cpw      END IF
*  gopal interface
*  ----- ---------
*  Ebeam in MeV
      IQ (LREV+IIEBEA) = ERECM*500.
      CALL GOGINT (NTRAK,ITKDM,PTRAK,IDTRAK,IHSTRY,VTX)
      IF (VTX (1).EQ.0.AND.VTX (2).EQ.0.AND.VTX (3).EQ.0) THEN
         CALL GOLIFE
      END IF
      IEREVT = IEREVT + 1
 
 990  RETURN
      END
+DECK,KILUND
      SUBROUTINE KILUND
*.
*...KILUND provides an interface to the LUND generator.
*.
*. SEQUENCE  : GCFLAG GCLUND
*. CALLS     : GOLUNI LUEEVT GOLINT
*. CALLED    : GUKINE
*.
*. AUTHOR    : S.L.Lloyd
*. VERSION   : 1.01
*. CREATED   : 19-Apr-88
*. LAST MOD  : 29-Jun-89
*.
*. Modification Log.
*. 29-Jun-89   D.R.Ward        Withdrawn on instructions of PCG
*. 19-Jul-88   D.R.Ward        Replace GLUNDI by GOLUNI
*. 26-Apr-88   D.R.Ward        Strong typing
*.
*.*********************************************************************
*
+SEQ,DECLARE.
+SEQ,GCFLAG.
+SEQ,GCLUND.
+SEQ,RCREP.
*
      CHREP='LUND Generator no longer available'
      CALL REPORT('KILUND',1,'I')
      CHREP='Decision of PCG 29-Jun-89 .... abort run'
      CALL REPORT('KILUND',2,'C')
*
*     IF (IFINIT(3).EQ.0)  CALL GOLUNI
*
*-- Generate an event with the LUND program.
*
*     CALL LUEEVT (IFLUND,ECLUND)
*
*-- Create generated particle bank from LUND common.
*
*     CALL GOLINT
*
      END
+DECK,KIMUON.
      SUBROUTINE KIMUON
*.
*...KIMUON  Generate a MUON at the origin.
*.
*. COMMON    :
*. SEQUENCE  : GCKINE GCONST GCBANK
*. CALLS     : MZBOOK GFPART GRNDM
*. CALLED    : GUKINE
*. BANKS L   : KINE
*.
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 22-Feb-89
*.
*. Modification Log.
*. 22-Feb-89   S.L.Lloyd       Change to PDG particle codes.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 22-Apr-88   S.L.Lloyd       Create particle tree bank
*. 14-Sep-86   S.O'Neale       Insert documentation on program structure
*.             S.O'Neale       Set MUON momentum from KINE data card.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,GCBANK
+SEQ,GCONST
+SEQ,GCKINE
+SEQ,LINKRA
*
      CHARACTER*20 CHPART
      INTEGER NP,LGENE,LENT,IOTREE,ITYPE,LTREE,NWB
      REAL      VERTEX(3),PLAB(3),BUF(2),UB(10),THETA,PHI,PMUON
      REAL    R(3)
      EQUIVALENCE (BUF(1),THETA),(BUF(2),PHI)
      DATA VERTEX/3*0./,PMUON/50./
*
*-- Create space for 2 tracks in case it interacts later.
*
      NP = 2
*
*-- Creates generated particle banks.
*
      LGENE = LQ(LMC-1)
      LENT = IQ(LGENE+5)
      IOTREE = IQ(LGENE+7)
*
      CALL MZBOOK (IXDIV,LTREE,LGENE,-1,'TREE',0,0,NP*LENT,IOTREE,0)
*
      IQ(LGENE+1) = 1
      IQ(LGENE+2) = 1
*
*     ------------------------------------------------------------------
*
*--  The muon momentum is 50.0 GeV unless it is overriden by the first
*--  real parameter on the KINE data card.
*--  e.g. KINE 3 95.0
      IF(PKINE(1).NE.BIG) PMUON=PKINE(1)
*
*--  The charge of the muon is selected randomly with
*--  equal probabilities for positive and negative tracks.
      ITYPE  = 5
      CALL GRNDM(R,3)
      IF ( R(1) .GT. 0.5 ) ITYPE = 6
*
*--  The muon track is orientated by a random selection from
*--  a flat distribution in the polar angle theta (0 - 180)and the
*--  azimuthal angle phi (0 - 360).
      THETA  = PI * R(2)
      PHI    = TWOPI * R(3)
*
      PLAB(1) = PMUON * COS(PHI) * SIN(THETA)
      PLAB(2) = PMUON * SIN(PHI) * SIN(THETA)
      PLAB(3) = PMUON * COS(THETA)
*
*-- Find out what the charge and mass are.
*
      CALL GFPART (ITYPE,CHPART,ITRTYP,AMASS,CHARGE,TLIFE,UB,NWB)
*
*-- Fill the particle tree entries.
*
      IF (ITYPE.EQ.5) IQ(LTREE+1) = -13
      IF (ITYPE.EQ.6) IQ(LTREE+1) =  13
      IQ(LTREE+9) = 1
      Q(LTREE+10+1) = PLAB(1)
      Q(LTREE+10+2) = PLAB(2)
      Q(LTREE+10+3) = PLAB(3)
      Q(LTREE+10+4) = SQRT(PLAB(1)**2+PLAB(2)**2+PLAB(3)**2+ AMASS**2)
      Q(LTREE+10+5) = AMASS
      Q(LTREE+10+6) = CHARGE
      Q(LTREE+10+7) = VERTEX(1)
      Q(LTREE+10+8) = VERTEX(2)
      Q(LTREE+10+9) = VERTEX(3)
*
      RETURN
      END
+DECK,KIPION.
      SUBROUTINE KIPION
*.
*...KIPION  Generate some PIONs at the origin.
*.
*. COMMON    :
*. SEQUENCE  : GCKINE GCONST GCBANK
*. CALLS     : MZBOOK GFPART GRNDM
*. CALLED    : GUKINE
*. BANKS L   : KINE
*.
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 22-Feb-89
*.
*. Modification Log.
*. 22-Feb-89   S.L.Lloyd       Change to PDG particle codes.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 22-Apr-88   S.L.Lloyd       Create particle tree bank
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.             S.O'Neale       Set number of tracks and momenta from
*.                             KINE data cards.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCBANK
+SEQ,GCONST
+SEQ,GCKINE
+SEQ,LINKRA
      CHARACTER*20 CHPART
      INTEGER NTR,NGENER,NP,LGENE,LENT,IOTREE,LTREE,I,NADD,NWB,ITYPE
      REAL      VERTEX(3),PLAB(3),BUF(2),UB(10),THETA,PHI,PMAX
      REAL      PPION,RNDM(4)
      EQUIVALENCE (BUF(1),THETA),(BUF(2),PHI)
      DATA VERTEX/3*0./,NTR/10/,PMAX/10./
*
*--      PKINE(1) = max number of particles to generate (default 10)
*--      PKINE(2) = max momentum to generate (default 10 GeV)
      IF(PKINE(1).NE.BIG) NTR  =PKINE(1)
      IF(PKINE(2).NE.BIG) PMAX =PKINE(2)
*
      CALL GRNDM(RNDM,1)
      NGENER=RNDM(1)*FLOAT(NTR)+1.
*
*-- Create space for twice as many tracks in case they interact later.
*
      NP = 2*NGENER
*
*-- Creates generated particle banks.
*
      LGENE = LQ(LMC-1)
      LENT = IQ(LGENE+5)
      IOTREE = IQ(LGENE+7)
*
      CALL MZBOOK (IXDIV,LTREE,LGENE,-1,'TREE',0,0,NP*LENT,IOTREE,0)
*
      IQ(LGENE+1) = NGENER
      IQ(LGENE+2) = NGENER
*
      DO 10 I = 1,NGENER
         NADD = LTREE + (I-1)*LENT
         CALL GRNDM(RNDM,4)
         PPION=PMAX*RNDM(2)
         THETA = PI * RNDM(3)
         PHI = TWOPI * RNDM(4)
*
         PLAB(1) = PPION * COS(PHI) * SIN(THETA)
         PLAB(2) = PPION * SIN(PHI) * SIN(THETA)
         PLAB(3) = PPION * COS(THETA)
*
         ITYPE = 8
         IF(RNDM(1).GT.0.4)ITYPE=9
         IF(RNDM(1).GT.0.8)ITYPE=7
*
*-- Find out what the charge and mass are.
*
         CALL GFPART (ITYPE,CHPART,ITRTYP,AMASS,CHARGE,TLIFE,UB,NWB)
*
*-- Fill the particle tree entries.
*
         IF (ITYPE.EQ.7) IQ(NADD+1) = 111
         IF (ITYPE.EQ.8) IQ(NADD+1) = 211
         IF (ITYPE.EQ.9) IQ(NADD+1) = -211
         IQ(NADD+9) = 1
         Q(NADD+10+1) = PLAB(1)
         Q(NADD+10+2) = PLAB(2)
         Q(NADD+10+3) = PLAB(3)
         Q(NADD+10+4) = SQRT(PLAB(1)**2+PLAB(2)**2+PLAB(3)**2+ AMASS**2)
         Q(NADD+10+5) = AMASS
         Q(NADD+10+6) = CHARGE
         Q(NADD+10+7) = VERTEX(1)
         Q(NADD+10+8) = VERTEX(2)
         Q(NADD+10+9) = VERTEX(3)
*
   10 CONTINUE
*
      RETURN
      END
+DECK,KISING.
      SUBROUTINE KISING
*.
*...KISING  Single particle generator (replaces G1PART).
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCKINE GCONST RCREP
*. CALLS     : REPORT MZBOOK GRNDM GFPART
*. CALLED    : GUKINE
*.
*. BANKS L   : GENE TREE
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 27-Nov-87
*. LAST MOD  :  2-Jun-89
*.
*. Modification Log.
*.  2-Jun-89   D.R.Ward        Set vertex in BEAM bank
*. 22-Feb-89   S.L.Lloyd       Change to PDG particle codes.
*.  7-Oct-88   D.R.Ward        Bug for antisigmas
*. 26-Apr-88   D.R.Ward        Strong typing
*. 18-Apr-88   S.L.Lloyd       Create particle tree bank
*. 27-Nov-87   D.R.Ward        Introduced (code was in KIUSER before)
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP
+SEQ,GCBANK
+SEQ,GCKINE
+SEQ,GCONST
+SEQ,ROCPAR.
+SEQ,LINKRA.
      CHARACTER*20 CHPART
      REAL      VERTEX(3),PLAB(3),UB(10),PUSER,THETA,PHI,RNDM(3)
      EXTERNAL IUCOMP
      INTEGER ISEL(41),JSEL(41),NSEL,NP,LGENE,LENT,IOTREE,LTREE, ITYPE,
     +ILTYPE,IJK,IUCOMP,NWB,KILROY,LGNCT,LBEAM
      DATA KILROY/0/
*   Conversion table between PDG particle codes and GEANT.
      DATA NSEL/41/
      DATA ISEL/ 22,-11, 11, 12,-12,-13, 13, 14,-14, 16,-16, 211,-211,
     + 321,-321, 310, 130,2212,-2212,2112,-2112,3222,-3222,3112,-3112,
     + 3322,-3322,3312,-3312,3122,-3122,3334,-3334, 15,-15,3212,-3212,
     + 221,-221,111,-111/
      DATA JSEL/ 1, 2, 3, 4, 4, 5, 6, 4, 4, 4, 4, 8, 9, 11, 12, 16, 10,
     +14, 15, 13, 25, 19, 27, 21, 29, 22, 30, 23, 31, 18, 26, 24, 32,
     +34, 33, 20, 28, 17, 17, 7, 7/
*
      DATA VERTEX/3*0./
*
*-- Create space for 2 tracks in case it interacts later.
*
      NP = 2
*
*-- Creates generated particle banks.
*
      LGENE = LQ(LMC-1)
      LENT = IQ(LGENE+5)
      IOTREE = IQ(LGENE+7)
*
      CALL MZBOOK (IXDIV,LTREE,LGENE,-1,'TREE',0,0,NP*LENT,IOTREE,0)
*
      IQ(LGENE+1) = 1
      IQ(LGENE+2) = 1
*
*     ------------------------------------------------------------------
*
*--    Simple single particle event generator ...............
*--       PKINE(1) = GEANT particle code.
*--       PKINE(2) = minimum momentum (GeV/c)
*--       PKINE(3) = maximum momentum (GeV/c)
*--       PKINE(4) = minimum theta (degrees)   <default   0>
*--       PKINE(5) = maximum theta (degrees)   <default 180>
*--       PKINE(6) = minimum phi (degrees)     <default   0>
*--       PKINE(7) = maximum phi (degrees)     <default 360>
*--       PKINE(8) = x of start point (cm)     <default   0>
*--       PKINE(9) = y of start point (cm)     <default   0>
*--       PKINE(10)= z of start point (cm)     <default   0>
*--
*--   momentum, theta and phi uniformly distributed in the ranges define
*--
*..   VERTEX is the array of the coordinates of the generated
*..          event or collection of tracks.
*..   NVERT  is returned by GSVERT.
*..   PLAB   is the array of the momentum components of the tracks
*..          generated at the given vertex. (in the lab system)
*..   ITYPE  is the GEANT mass code for the given particle/track.
*..   NT     is returned by GSTRAK.
*..
      IF(PKINE(8).NE.BIG) VERTEX(1)=PKINE(8)
      IF(PKINE(9).NE.BIG) VERTEX(2)=PKINE(9)
      IF(PKINE(10).NE.BIG) VERTEX(3)=PKINE(10)
*
*     First event - store beam position in BEAM bank
*
      IF(KILROY.EQ.0 .AND. LDAC.GT.0) THEN
         KILROY=1
         LGNCT=LQ(LDAC-LLGNCT)
         IF(LGNCT.GT.0) THEN
            LBEAM=LQ(LGNCT-LLBEAM)
            IF(LBEAM.GT.0) THEN
                  Q(LBEAM+IXBEAM)=VERTEX(1)
                  Q(LBEAM+IYBEAM)=VERTEX(2)
                  Q(LBEAM+IZBEAM)=VERTEX(3)
            ENDIF
         ENDIF
      ENDIF
*
      CALL GRNDM(RNDM,3)
      PUSER  = PKINE(2)+RNDM(1)*(PKINE(3)-PKINE(2))
      IF(PKINE(4).NE.BIG .AND. PKINE(5).NE.BIG) THEN
         THETA = DEGRAD*(PKINE(4)+RNDM(2)*(PKINE(5)-PKINE(4)))
      ELSE
         THETA=PI*RNDM(2)
      ENDIF
      IF(PKINE(6).NE.BIG .AND. PKINE(7).NE.BIG) THEN
         PHI=DEGRAD*(PKINE(6)+RNDM(3)*(PKINE(7)-PKINE(6)))
      ELSE
         PHI = TWOPI * RNDM(3)
      ENDIF
*
      PLAB(1) = PUSER * COS(PHI) * SIN(THETA)
      PLAB(2) = PUSER * SIN(PHI) * SIN(THETA)
      PLAB(3) = PUSER * COS(THETA)
*
      ITYPE   = PKINE(1)
*
*-- Convert from GEANT particle code to PDG.
*
      IJK    = IUCOMP (ITYPE,JSEL,NSEL)
      IF (IJK.EQ.0) THEN
         WRITE (CHREP,1000) ITYPE
         CALL REPORT ('KISING',1,'ERROR')
         ILTYPE = 99
      ELSE
         ILTYPE = ISEL(IJK)
      ENDIF
*
*-- Find out what the charge and mass are.
*
      CALL GFPART (ITYPE,CHPART,ITRTYP,AMASS,CHARGE,TLIFE,UB,NWB)
*
*-- Fill the particle tree entries.
*
      IQ(LTREE+1) = ILTYPE
      IQ(LTREE+9) = 1
      IF (CHARGE.NE.0) IQ(LTREE+10) = 1
      Q(LTREE+10+1) = PLAB(1)
      Q(LTREE+10+2) = PLAB(2)
      Q(LTREE+10+3) = PLAB(3)
      Q(LTREE+10+4) = SQRT(PLAB(1)**2+PLAB(2)**2+PLAB(3)**2+ AMASS**2)
      Q(LTREE+10+5) = AMASS
      Q(LTREE+10+6) = CHARGE
      Q(LTREE+10+7) = VERTEX(1)
      Q(LTREE+10+8) = VERTEX(2)
      Q(LTREE+10+9) = VERTEX(3)
*
*
 1000 FORMAT ('Particle type',I5,' not known')
      END
+DECK,KISTBL.
      SUBROUTINE  KISTBL (NTRAK,IPART,IPOINT,IFIND)
*.
*...KISTBL
*. Routine to determine whether a particle positioned in an event
*. generator event record is stable or not as determined by
*. whether it has any daughters
*.
*. SEQUENCE  : none
*. INPUT     : NTRAK    Number of entries in the event record
*. INPUT     : IPART    Position of the particle in the event record
*. INPUT     : IPOINT   Particle history record for the event
*. OUTPUT    : IFIND    = 1 if the particle is stable
*.                      = 0 if not
*. CALLS     : none
*. CALLED    : By User
*.
*. AUTHOR    :  J.W.Gary
*. CREATED   :  19-Apr-89
*. LAST MOD  :  19-Apr-89
*.
*. Modification Log.
*.
*.********************************************************************
+SEQ,DECLARE.
      INTEGER  IPART,IFIND,INX,NTRAK,IPAR
      INTEGER  IPOINT (*)
 
      IFIND = 1
      INX = IPART
 100  INX = INX + 1
          IF (INX.GT.NTRAK) GO TO 990
          IPAR = IPOINT (INX)
          IF (IPAR.EQ.IPART) THEN
              IFIND = 0
              GO TO 990
          END IF
      GO TO 100
 
 990  RETURN
      END
+DECK,KIUSER.
      SUBROUTINE KIUSER
*.
*...KIUSER  USERS routine for generation of an event
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : KISING
*. CALLED    : GUKINE
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 26-Apr-88
*.
*. Modification Log.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 22-Apr-88   S.L.Lloyd       Change G1PART to KISING.
*. 27-Nov-87   D.R.Ward        Example code moved to G1PART.  For backwa
*.                             compatibility KIUSER just calls G1PART if
*.                             the user doesn't compile his own version.
*.  2-Feb-87   D.R.Ward        Example KIUSER introduced
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*. 19-May-86   S.O'Neale       Skeleton code introduced
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
      CHREP='Dummy KIUSER called'
      CALL REPORT('KUUSER',1,'W')
      RETURN
      END
+DECK,MCPETRAP,IF=MCP.
      SUBROUTINE MCPETRAP(ICODE,RESULT,OPER1,OPER2)
*
* This is switched on to help us when we are in trouble.
* So far I find Maths Library Errors 12 and 15 both come here with
* code 5 but if I try to print a very large number I get IEEE Error.
* 
+CDE,MCPSPY.
      MCPEtraps=MCPEtraps+1
      WRITE(6,6010) ICODE
 6010 FORMAT(' Floating Point Error Trap for External error',I4,/,
     +       ' Trace back will be on standard error ')
      CALL TRACEQC
      IF ( MCPTRAP.GT.1 ) THEN
         WRITE(6,'('' In place of (maybe) MATH LIBRARY ERROR ...'')')
         WRITE(6,'(I4,3E14.6)') ICODE,RESULT,OPER1,OPER2
      END IF
      END
+DECK,NORRAN.
      SUBROUTINE NORRAN(R)
*
*     Mustn't use NORRAN - uses different random number sequence.
*
+SEQ,DECLARE.
+SEQ,RCREP.
      REAL R,DUMMY
      INTEGER IS1,IS2
      CHREP='****** NORRAN called - using GRANOR instead ******'
      CALL REPORT('NORRAN',1,'W')
      CALL GRNDMQ(IS1,IS2,1,'G')
      IF(IS1.EQ.0 .AND. IS2.EQ.0) THEN
         CHREP=' It appears that GRANOR hasn''t been initialized,'
         CALL RMAIL(0,0)
         CHREP=' so I''ll try to do so.'
         CALL RMAIL(0,0)
         CALL GRNDMQ(IS1,IS2,1,' ')
      ENDIF
      CALL GRANOR(R,DUMMY)
      END
+DECK,OPLOAD
      SUBROUTINE OPLOAD(ROUTIN,CALLER,CALLED)
+SEQ,DECLARE.
      EXTERNAL ROUTIN
      CHARACTER*(*) CALLER,CALLED
*     WRITE(6,FMT='('' OPLOAD.  '',A,'' loads '',A)') CALLED,CALLER
      END
+DECK,PDGCHG.
      SUBROUTINE PDGCHG (IDPDG,ICHRG)
*.
*...PDGCHG
*. Routine to determine the charge of a particle, given its ID code
*. in the Particle Data Group format.
*.
*. SEQUENCE  : RCREP
*. INPUT     : IDPDG    The P.D.G. ID of the particle
*. OUTPUT    : ICHRG    3 times the electric charge of the particle
*.                      (ICHRG=-9999 if the IDPDG code is unknown
*.                       to the program).
*. CALLS     : REPORT
*. CALLED    : various
*.
*. AUTHOR    :  J.W.Gary
*. CREATED   :  20-Mar-89
*. LAST MOD  :  29-Mar-96
*.
*. Modification log:
*.
*. 29-Mar-96  C.P.Ward  Min meson code 111-->110 (diff pi0/rho0)
*. 29-Feb-96  C.P.Ward  Add codes 41-79 for SUSY particles
*. 10-May-94  C.P.Ward  Add codes 32-37: extra gauge bosons not covered
*.                      by standard PDG codes, from CERN-TH.6488/92
*.
*.********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER  NTABL
      PARAMETER  (NTABL=79)
      INTEGER  IDPDG,ICHRG ,IID
      INTEGER  IDOUT (5)
      REAL  RTABL (NTABL)
      DATA  RTABL  /
     +  -.333333,.666667,-.333333,.666667,-.333333,.666667,
     +  -.333333,.666667,0.,-3333.,-1.,0.,-1.,0.,-1.,0.,-1.,0.,
     +  -3333.,-3333.,0.,0.,0.,1.,0.,
     +  -3333.,-3333.,-3333.,-3333.,-3333.,-3333.,
     +  0.,0.,1.,0.,0.,1.,
     +  -3333.,-3333.,-3333.,
     +  -.333333,.666667,-.333333,.666667,-.333333,.666667,
     +  -.333333,.666667,-.333333,.666667,-1.,0.,-1.,0.,-1.,0.,
     +  -1.,-1.,-1.,-3333.,-.333333,.666667,-.333333,.666667,
     +  -1.,-.333333,.666667,-1.,-3333.,
     +  0.,0.,0.,0.,0.,1.,1.,-1.,-1.,-3333.
     +   /
      IID = IABS (IDPDG)
      IF (IID.LE.79) THEN
          ICHRG = NINT (3.* RTABL (IID))
          IF (ICHRG.EQ.-9999) GO TO 999
      ELSE IF (IID.GE.110.AND.IID.LE.98888) THEN
*       decompose ID into its quark constituents
*       --------- -- ---- --- ----- ------------
          IDOUT (1) = MOD (IID,10)
          IDOUT (2) = MOD (IID/10,10)
          IDOUT (3) = MOD (IID/100,10)
          IDOUT (4) = MOD (IID/1000,10)
Comment          IDOUT (5) = MOD (IID/10000,10)
*       skip diquarks
*       ---- --------
          IF (IDOUT (2).EQ.0.AND.IDOUT (4).NE.0) GO TO 999
          IF (IDOUT (2).GT.8.OR.IDOUT (3).GT.8.OR.
     +        IDOUT (4).GT.8.OR.IDOUT (2).EQ.0.OR.
     +        IDOUT (3).EQ.0) GO TO 999
*       mesons and baryons handled separately
*       ------ --- ------- ------- ----------
          IF (IDOUT (4).EQ.0) THEN
              ICHRG = NINT (3.*(RTABL (IDOUT (3))-RTABL (IDOUT (2))))
              IF (MOD (IDOUT (3),2).EQ.1) ICHRG = -ICHRG
          ELSE
              ICHRG = NINT (3.* (RTABL (IDOUT (2)) + RTABL (IDOUT (3))
     +              + RTABL (IDOUT (4))))
          END IF
      ELSE
          GO TO 999
      END IF
      IF (IDPDG.LT.0) ICHRG = - ICHRG
      RETURN
 999  ICHRG = -9999
      WRITE (CHREP,FMT='('' ID code'',I10,'' is unknown'')') IDPDG
      CALL REPORT ('PDGCHG',1,'W')
      RETURN
      END
+DECK,PRIJET.
      SUBROUTINE  PRIJET (IL,IDTRAK,IHSTRY,PRMRY)
*.
*...PRIJET
*. Routine to identify whether a parton, string or cluster in
*. an event generator record is primary or secondary.
*. Primary means that the parton has no history or is a descendant
*. of a parton with no history;
*. Secondary means that the parton is a decay product of a hadron.
*.
*. SEQUENCE  : RCREP
*. CALLS     : REPORT
*. CALLED    :
*.
*. INPUT     : IL      Position of the parton to be tested
*. INPUT     : IDTRAK  The IDs of the particles in the event record
*. INPUT     : IHSTRY  The history of the particles in the event record
*. OUTPUT    : PRMRY   = .TRUE. if IL is primary, =.FALSE. otherwise
*.
*. AUTHOR    : J.W.Gary
*. CREATED   : 06-Apr-89
*. LAST MOD  : 08-Dec-93
*.
*. Modification Log.
*. 08-Dec-93  C.P.Ward  Remove unused variables.
*.
*.*********************************************************************
+SEQ,DECLARE.
+SEQ,RCREP.
      INTEGER  MXIT
      PARAMETER  (MXIT=200)
      INTEGER  IDTRAK (*),IHSTRY (*)
      INTEGER  IL,INOW,IDPAR,ITER,IID,IPARNT
      LOGICAL  PRMRY
      INOW = IL
      ITER = 0
 100  ITER = ITER + 1
      IPARNT = IHSTRY (INOW)
      IF (IPARNT.EQ.0) THEN
         PRMRY = .TRUE.
         GO TO 990
      END IF
      IID = IDTRAK (INOW)
      IF (IID.EQ.91.OR.IID.EQ.92) IPARNT = NINT (FLOAT (IPARNT) / 1000.)
      IDPAR = IABS (IDTRAK (IPARNT))
      IF (IDPAR.GT.8.AND.IDPAR.NE.21.AND.
     +    IDPAR.NE.91.AND.IDPAR.NE.92) THEN
         PRMRY = .FALSE.
         GO TO 990
      END IF
      INOW = IPARNT
      IF (ITER.LT.MXIT) GO TO 100
      PRMRY = .FALSE.
      WRITE (CHREP,FMT='('' Max.number of iterations in history'',
     +    ''traceback='',I6,'' exceeded'')') MXIT
      CALL REPORT('PRIJET',1,'W')
 990  RETURN
      END
+DECK,QNEXT.
      SUBROUTINE QNEXT
*.
*...QNEXT    Code from GRUN, modified to deal with ZEBRA error recovery
*.
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCFLAG GCNUM  GCTIME GCUNIT GOSEED
*. CALLS     : GMAIL  GTRIG  GTRIGC GTRIGI TIMEL  TIMEX
*. CALLED    : QNEXT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 31-Dec-86
*. LAST MOD  : 26-Feb-97
*.
*. Modification Log.
*. 26-Feb-97   S.W.O'Neale     Add MCP spy code
*. 12-Jan-95   C.P.Ward        Run file allowed for DECS,QMVAOS
*.  1-Mar-93   J.E.Conboy      Use GTIME to check time remaining
*. 23-Jul-92   D.R.Ward        TIMAL --> TIMEL on IBM
*. 26-Feb-92   D.R.Ward        TIMEL --> TIMAL on IBM
*. 14-Feb-92   D.R.Ward        Mods for GEANT315
*.  3-Jan-92   D.R.Ward        Implement internal file definition
*. 12-Oct-90   D.R.Ward        Increment IEVENT if >1st entry
*.  4-Jan-90   D.R.Ward        Remove r.n. bodge (CRAY problems)
*. 20-Dec-89   D.R.Ward        Use of RUN file for multiprocessing
*.  4-Apr-89   D.R.Ward        Increment r.n. after resetting
*.  2-Aug-88   D.R.Ward        Modify the fix
*.  1-Aug-88   D.R.Ward        Modify the fix
*. 25-Jul-88   D.R.Ward        Fix up random number repeat problem
*. 26-Apr-88   D.R.Ward        Strong typing
*.  8-Jan-88   R.Yaari         Fix timing bug
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
*
+SEQ,GCBANK
+SEQ,GCFLAG
+SEQ,GCNUM
+SEQ,GCUNIT
+SEQ,GCTIME
+SEQ,GOFILE.
+SEQ,GOSTAT.
+SEQ,RCREP.
+SELF,IF=MCP.
+SEQ,MCPSPY.
      INTEGER   CHSPY
      REAL      TimeNow,TimeUsed,TimeEvent,FileNow,FileEvent
      SAVE      TimeNow,TimeUsed,TimeEvent,FileNow,FileEvent
      REAL      SLTIMED    ! Elapsed DATIME in secs (resolution 1 min)
      CHARACTER JobLine*(80),NextLine*(80),LastLine*(80)
      INTEGER   SpySTAT,NumRecs
+SELF.
+SELF,IF=VAX.
      INCLUDE '($FORIOSDEF)'
+SELF,IF=DECS,QMAVOS.
      INCLUDE '/usr/include/foriosdef.f'
+SELF
      INTEGER JUCOMP,J,NTRY,IOSTAT
      EXTERNAL JUCOMP
      REAL DUMMY
      INTEGER IFIRST
      LOGICAL GTIME
      REAL TIMNOW
      REAL RNDM
      EXTERNAL RNDM
      DATA IFIRST/0/
*
*     ------------------------------------------------------------------
*
*             Keep starting time
*
+SELF,IF=IBM.
* Empirical bodge (DRW)
      WRITE(CHREP,'(I10)') IFIRST
+SELF.
      IF(IFIRST.EQ.0) THEN
         IFIRST=1
         IF(GVERSN.LT.3.15) THEN
+SELF,IF=-IBM.
            CALL TIMEX(TIMINT)
+SELF,IF=IBM.
***         CALL TIMAX(TIMINT)
            CALL TIMEX(TIMINT)
+SELF
            IEVENT=IEVENT-1
         ELSE
+SELF,IF=-IBM.
            CALL TIMEL(TIMINT)
+SELF,IF=IBM.
***         CALL TIMAL(TIMINT)
            CALL TIMEL(TIMINT)
+SELF
         ENDIF
      ENDIF
      GO TO 90
*
   10 CONTINUE
*--   Clear event partition
*
      CALL GTRIGC
+SELF,IF=VAX,DECS,QMAVOS.
* Deal with RUN file (for multiple jobs optionally)
      NTRY=0
      J=JUCOMP('RUNI',IONAME,NFILE)
      IF(J.NE.0) THEN
* Old file available?
  81     IF(IOFNAM(J).EQ.'    ') THEN 
            OPEN(IOUNIT(J),STATUS='OLD',ERR=80,IOSTAT=IOSTAT)
         ELSE
            OPEN(IOUNIT(J),STATUS='OLD',ERR=80,IOSTAT=IOSTAT,
     +           FILE=IOFNAM(J))
         ENDIF
  80     IF(IOSTAT.EQ.0) THEN
* Get event number/seeds of last event processed
            READ(IOUNIT(J),'(5I12)')IDRUN,IDEVT,NRNDM(1),NRNDM(2),IEVENT
            IEVENT=IEVENT+1
            IF(IEVENT.GT.NEVENT) THEN
               IEOTRI=1
               IEORUN=1
               GO TO 20
            ENDIF
            CALL GRNDMQ(NRNDM(1),NRNDM(2),1,'S')
            GO TO 82
         ELSEIF(IOSTAT.EQ.FOR$IOS_FILNOTFOU) THEN
* No old file - open a new one.
         IF(IOFNAM(J).EQ.'    ') THEN 
            OPEN(IOUNIT(J),STATUS='NEW',IOSTAT=IOSTAT)
         ELSE
            OPEN(IOUNIT(J),STATUS='NEW',IOSTAT=IOSTAT,FILE=IOFNAM(J))
         ENDIF
            IF(IOSTAT.NE.0) THEN
               CHREP='Cannot open new RUN file - give up'
               CALL REPORT('QNEXT ',11,'F')
               GO TO 20
            ENDIF
            GO TO 82
         ELSEIF(IOSTAT.EQ.FOR$IOS_UNIALROPE .OR.
     +          IOSTAT.EQ.FOR$IOS_OPEFAI)    THEN
* File in use - wait and retry
            NTRY=NTRY+1
            IF(NTRY.GT.5000) THEN
               CHREP='RUN file permanently in use - give up'
               CALL REPORT('QNEXT ',11,'F')
               GO TO 20
            ENDIF
+SELF,IF=VAX.
            CALL WAIT_2SEC
+SELF,IF=DECS,QMVAOS.
            CALL SLEEP(2)
+SELF,IF=VAX,DECS,QMVAOS.
            GO TO 81
         ELSE
* Problem...
            WRITE(CHREP,'('' Mysterious error'',I3,
     +                    '' opening RUN file'')') IOSTAT
            CALL REPORT('QNEXT ',10,'F')
            GO TO 20
         ENDIF
      ENDIF
  82  CONTINUE
+SELF.
*
*--   Initialise event partition
*
      CALL GTRIGI
*
+SELF,IF=MCP.
      IF ( SPYLVL.NE.0 ) THEN
         CALL DATIME(LastDate,LastTime)
         LastRun=IDRUN
         LastEvent=IDEVT+1    ! We should move this code to GUKINE
         SeedOne=NRNDM(1)
         SeedTwo=NRNDM(2)
         CALL TIMEL(TimeLeft)
         FileNow=Filesize     ! In KBytes
         TimeUsed=TimeLjob-TimeLeft
         DayTime=SLTIMED(LastDate,LastTime,StartDate,StartTime)
         WRITE( JobLine,8050) StartDate,StartTime,StartRun,StartEvent,
     +                        TrigJob,TimeLjob,  Hostname,JobName,JobId
         JobLine(80:80)=CHAR(10)
         WRITE(NextLine,8060) LastDate,LastTime,LastRun,LastEvent,
     +                        TrigDone,NINT(TimeUsed),NINT(FileSize),
     +                        NINT(DayTime),   SeedOne,SeedTwo
         NextLine(80:80)=CHAR(10)
 8050 FORMAT(I6,1X,I4,1X,I5,1X,I6,1X,I5,1X,I6,5X,A8,1X,A12,1X,A16)
 8060 FORMAT(I6,1X,I4,1X,I5,1X,I6,1X,I5,1X,I6,
     +          1X,I6,1X,I6,1X,I10,1X,I10)
 
         IF ( SPYLVL.LT.0 ) THEN
            WRITE(9,'('' S '',A)') Jobline
            WRITE(9,'('' S '',A)') Nextline
         ELSE
            CALL CFOPEN(SPYDES,0,20,'r+',0,'mcpspy',SpySTAT)
            CALL CFSEEK(SPYDES,0,20,     1,SpySTAT)      ! Second record
            CALL CFPUT (SPYDES,0,20,  NextLine,SpySTAT)  ! Next Event
            CALL CFSIZE(SPYDES,0,20,  NumRecs ,SpySTAT)  ! Point to EoF
            CALL CFCLOS(SPYDES,0)                        ! Close the file
         END IF
         TrigDone=IEVENT
      END IF
+SELF.
*--   Process one event (trigger)
*
      CALL GTRIG
*
*--   Fix potential problem with repeating random numbers --
*--   Restore seed at start of last GUKINE.
*--   and increment by one...
*        CALL GRNDMQ(JSEED(1),JSEED(2),1,'S')
*        CALL GRNDM(DUMMY,1)
*
  90  IF(IEORUN.NE.0)GO TO 30
+SELF,IF=MCP.
      IF ( SPYLVL.NE.0 .AND. IEVENT.NE.0  ) THEN
         CALL DATIME(LastDate,LastTime)
         LastRun=IDRUN
         LastEvent=IDEVT
         FileEvent=FileSize-FileNow
         FileNow=FileSize
         DayTime=SLTIMED(LastDate,LastTime,StartDate,StartTime)
         CALL TIMEL(TimeNow)
         TimeEvent=TimeLeft-TimeNow
         TimeLeft=TimeNow
         TimeUsed=TimeLjob-Timeleft
         TrigDone=IEVENT
         WRITE( JobLine,8050) StartDate,StartTime,StartRun,StartEvent,
     +                        TrigJob,TimeLjob,  Hostname,JobName,JobId
         JobLine(80:80)=CHAR(10)
         WRITE(NextLine,8060) LastDate,LastTime,LastRun,LastEvent,
     +                        TrigDone,NINT(TimeUsed),NINT(FileSize),
     +                        NINT(DayTime),   SeedOne,SeedTwo
         NextLine(80:80)=CHAR(10)
         WRITE(LastLine,8060) LastDate,LastTime,LastRun,LastEvent,
     +                        TrigDone,NINT(TimeEvent),NINT(FileEvent),
     +                        NINT(DayTime),   SeedOne,SeedTwo
         LastLine(80:80)=CHAR(10)
         IF ( SPYLVL.LT.0 ) THEN
            WRITE(9,'('' E '',A)') Jobline
            WRITE(9,'('' E '',A)') Nextline
            WRITE(9,'('' E '',A)') Lastline
         ELSE
            CALL CFOPEN(SPYDES,0,20,'r+',0,'mcpspy',SpySTAT)
            CALL CFSEEK(SPYDES,0,20,     1,SpySTAT)      ! Second record
            CALL CFPUT (SPYDES,0,20,  NextLine,SpySTAT)  ! Next Event
            IF ( SPYLVL.GT.1 )
     +      CALL CFSIZE(SPYDES,0,20,  NumRecs ,SpySTAT)  ! Point to EoF
            CALL CFPUT (SPYDES,0,20,  LastLine,SpySTAT)  ! Event Done
            CALL CFCLOS(SPYDES,0)                        ! Close file
         END IF
      END IF
+SELF.
      IEVENT = IEVENT + 1
      IF(IEVENT.GT.NEVENT)GO TO 20
*
*             Check time left
*
*jec      IF(ITIME.LE.0)GO TO 10
*jec      IF(MOD(IEVENT,ITIME).NE.0)GO TO 10
*jec            CALL TIMEL(TIMNOW)
*jec            CALL TIMEL(TIMNOW)
*jec      IF(TIMNOW.GT.TIMEND)GO TO 10
      IF( GTIME(IEVENT) )      GOTO  10
*
      WRITE(CHMAIL,1000)TIMEND
      CALL GMAIL(0,2)
      CHREP=CHMAIL
      CALL REPORT('QNEXT ',99,'W')
      IEORUN = 1
   20 IEVENT=IEVENT-1
      IF(JUCOMP('RUNI',IONAME,NFILE).NE.0) IEVENT=NEVTS
*
 1000 FORMAT(5X,'***** THE JOB STOPS NOW BECAUSE THE TIME LEFT IS LESS',
     +' THAN     ',F8.3,' SECONDS *****')
   30 END
+DECK,REVBOK.
      SUBROUTINE REVBOK
*.
*...REVBOK      Book the ROPE top bank REV etc.
*.
*.
*. COMMON    :
*. SEQUENCE  : RCREP  GCUNIT
*. CALLS     : RBKREV
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 14-Apr-88
*. LAST MOD  : 29-Sep-95
*.
*. Modification Log.
*. 29-Sep-95   C.P.Ward      Set train number in REV
*.  7-Jun-94   C.P.Ward      Remove bootstrap code
*. 13-Jan-92   D.R.Ward      Set some bits in MC to flag simulation level
*.  8-Mar-90   D.R.Ward      Set IQIDN(LOD)
*. 30-Nov-89   D.R.Ward      Mods to detector status word
*. 20-Jul-89   S.W.O'Neale   Fix for CRAY
*. 19-Jul-89   S.Weisz       Tidy up HT/HS
*. 17-Jul-89   D.R.Ward      Expt number from GOFLAG
*.  2-Jun-89   D.R.Ward      Convert to new header
*.  9-May-89   D.R.Ward      Set expt number to 1001 for OC
*. 15-Mar-89   D.R.Ward      Initialize IOREV
*. 25-Feb-89   D.R.Ward      Get more stuff from ROPAR and GOPAR
*.  9-Feb-89   S.Weisz       Call RBKREV to lift REV dependants
*. 27-Sep-88   D.R.Ward      Use previously set IOREV
*. 12-Sep-88   D.R.Ward      Extra link for trigger data
*.  8-Aug-88   D.R.Ward      Remove GOHEAD
*. 22-Jul-88   D.R.Ward      Hang REV from JHEAD (allowing reread of KIN
*.  2-Jun-88   D.Schaile     Prevent overwriting of IQ(LREV+1)
*. 17-May-88   D.R.Ward      Lift AD and OD top banks.
*.  2-May-88   A.Buijs       Change the data part of REV.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER IDATE,ITIME
+SEQ,ROBANK.
+SEQ,GOPAR.
+SEQ,ROPAR.
+SEQ,LINKGO.
+SEQ,GCFLAG.
+SEQ,GCKINE.
+SEQ,CRVER.
+SEQ,GCLUND.
+SEQ,GOVERS.
+SEQ,GCLIST.
+SEQ,GOFLAG.
+SEQ,GOLOGI.
+SEQ,CRO.
      INTEGER JHDAQS,JHDETS,JUCOMP
      EXTERNAL JUCOMP
      INTEGER DATEH(2),TIMEH(2),ISEC
      CHARACTER*8 TIMEC
      INTEGER KILROY
      DATA KILROY/0/
*
      IF(KILROY.EQ.0) THEN
         KILROY=1
         CALL MZIOCH(IOREV,2,'5I 9B -I')
         IF(MOD(IGOEXP,1000).EQ.1) THEN
            JHDAQS=89478485
            JHDETS=89478485
         ELSE
            JHDAQS=357913941
            JHDETS=357913941
         ENDIF
*   Set up the DAQ and Detector status bits for this run.
*   DETS tells which geometry included; DAQS which were digitized.
         IF(JUCOMP('SI  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,        29,2)
         IF(JUCOMP('SI  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,        29,2)
         IF(JUCOMP('CV  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLCVRA-1,2)
         IF(JUCOMP('CV  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLCVRA-1,2)
         IF(JUCOMP('CJ  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLCJRA-1,2)
         IF(JUCOMP('CJ  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLCJRA-1,2)
         IF(JUCOMP('CZ  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLCZRA-1,2)
         IF(JUCOMP('CZ  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLCZRA-1,2)
         IF(JUCOMP('BD  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLTBRA-1,2)
         IF(JUCOMP('TB  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLTBRA-1,2)
         IF(JUCOMP('BD  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLPBRA-1,2)
         IF(JUCOMP('PB  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLPBRA-1,2)
         IF(JUCOMP('EB  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLEBRA-1,2)
         IF(JUCOMP('EB  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLEBRA-1,2)
         IF(JUCOMP('PE  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLPERA-1,2)
         IF(JUCOMP('PE  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLPERA-1,2)
         IF(JUCOMP('EE  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLEERA-1,2)
         IF(JUCOMP('EE  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLEERA-1,2)
         IF(JUCOMP('HB  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLHTRA-1,2)
         IF(JUCOMP('HB  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLHTRA-1,2)
         IF(JUCOMP('HE  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLHSRA-1,2)
         IF(JUCOMP('HE  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLHSRA-1,2)
         IF(JUCOMP('HP  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLHPRA-1,2)
         IF(JUCOMP('HP  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLHPRA-1,2)
         IF(JUCOMP('MB  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLMBRA-1,2)
         IF(JUCOMP('MB  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLMBRA-1,2)
         IF(JUCOMP('ME  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLMERA-1,2)
         IF(JUCOMP('ME  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLMERA-1,2)
         IF(JUCOMP('FD  ',LGEOM,NGEOM).NE.0)
     +      CALL SBYT(3,JHDETS,2*LLFDRA-1,2)
         IF(JUCOMP('FD  ',LDIGI,NDIGI).NE.0)
     +      CALL SBYT(3,JHDAQS,2*LLFDRA-1,2)
         IF(LSISM) THEN
            CALL SBYT(3,JHDETS,29,6)
            CALL SBYT(3,JHDAQS,29,6)
         ENDIF
         IF(LCDSM) THEN
            CALL SBYT(63,JHDETS,2*LLCVRA-1,6)
            CALL SBYT(63,JHDAQS,2*LLCVRA-1,6)
         ENDIF
         IF(LCALSM) THEN
            CALL SBYT(4194303,JHDETS,2*LLTBRA-1,22)
            CALL SBYT(4194303,JHDAQS,2*LLTBRA-1,22)
         ENDIF
      ENDIF
*--
*
*-- Set some parameters in CRO
*
      IRDEXP=IGOEXP
      IF(IRDEXP.LT.1000) IRDEXP=IRDEXP+1000
      IREVNT=IEVENT
      IRDRUN=IDRUN
      IRDEVT=IDEVT
      IRDEBU=IDEBUG*ISWIT(5)
*--
*--   Start by lifting the ROPE top bank REV. The format of this bank,
*--   which should be identical to the pilot record, will be '40I-F'.
*--   However, the first integer will be 39, to make it compatible to th
*--   '*I-F' format. The philosophy of this bank is that it does not
*--   change, and therefore spare words are used. The second and third
*--   words are data type and data subtype.
*
      CALL MZBOOK(IXDIV,LREV,JHEAD,-1,'REV ',NLREV,NSREV,NDREV,IOREV,0)
*
*--   and fill some of its data words.
*
      IQ(LREV+IIDAT )=  5
      IQ(LREV+IIEXPT)=  IRDEXP
      IQ(LREV+IIRUN )= IDRUN
      IQ(LREV+IIFILL)= 1
      IQ(LREV+IIEVT )= IDEVT
      IQ(LREV+IIBUN )= 1
      CALL DATIME(IDATE,ITIME)
      CALL DATIMH(DATEH,TIMEH)
+SELF,IF=-CRAY.
      CALL UHTOC(TIMEH,4,TIMEC,8)
+SELF,IF=CRAY.
      CALL UHTOC(TIMEH,8,TIMEC,8)
+SELF.
      READ(TIMEC,FMT='(6X,I2)') ISEC
      IQ(LREV+IIDATE)=IDATE
      IQ(LREV+IITIME)=ITIME*100+ISEC
      IQ(LREV+IITRGS)=JHDAQS
      IQ(LREV+IIDETS)=JHDETS
*   Energy of beams in MeV
      IF(IKINE.EQ.1) IQ(LREV+IIEBEA) = ECLUND*500.
      CALL ROUVER(IQ(LREV+IIPVER))
*--
*--  Lift the header bank for raw data.
*--
      CALL MZBOOK(IXDIV,LDA,LREV,-LLDA,'DA  ',NLDA,NSDA,NDDA,IODA,0)
*
*--  Then the EXternal device bank
*
      CALL MZBOOK(IXDIV,LEX,LREV,-LLEX,'EX  ',NLEX,NSEX,NDEX,IOEX,0)
*
*
*--  lift the Monte Carlo header.
*
      CALL MZBOOK(IXDIV,LMC,LEX,-LLMC,'MC  ',NLMC,NSMC,NDMC,IOMC,0)
      IQ(LMC+5)=IQ(JHEAD+3)
      IQ(LMC+6)=IQ(JHEAD+4)
      IQ(LMC+7)=IGOVER
      IQ(LMC+8)=IGOSVE
      IQ(LMC+9)=IGEVER
      IQ(LMC+10)=LASTMO
      IF(LCDFU) CALL SBIT1(IQ(LMC+17),1)
      IF(LCDFA) CALL SBIT1(IQ(LMC+17),2)
      IF(LCDSM) CALL SBIT1(IQ(LMC+17),3)
      IF(LCALFU) CALL SBIT1(IQ(LMC+17),4)
      IF(LCALFA) CALL SBIT1(IQ(LMC+17),5)
      IF(LCALSM) CALL SBIT1(IQ(LMC+17),7)
      IF(LFDFU) CALL SBIT1(IQ(LMC+17),8)
      IF(LPSFU) CALL SBIT1(IQ(LMC+17),9)
      IF(LSIFU) CALL SBIT1(IQ(LMC+17),10)
      IF(LSIFA) CALL SBIT1(IQ(LMC+17),11)
      IF(LSISM) CALL SBIT1(IQ(LMC+17),12)
      IF(LSMTRK) CALL SBIT1(IQ(LMC+17),13)
      IF(LSMCE) CALL SBIT1(IQ(LMC+17),14)
*
*--  lift the cheat bank header
*
      CALL MZBOOK(IXDIV,LCHEA,LMC,-LLCHEA,'CHEA',NLDA,NSDA,NDDA,IODA,0)
*
*--  Then most of the REV dependants in RBKREV
*
      CALL RBKREV
      IF(LOD.GT.0) IQIDN(LOD)=IVOD
      END
+DECK,RMAIL.
      SUBROUTINE RMAIL(LINBEF,LINAFT)
*.
*...RMAIL    Take output to RMAIL and route it to GMAIL.
*.
*. INPUT     :  LINBEF  lines to skip before
*. INPUT     :  LINAFT  lines to skip before
*.
*. COMMON    :
*. SEQUENCE  : RCREP  GCUNIT
*. CALLS     : GMAIL
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 14-Apr-88
*. LAST MOD  :
*.
*. Modification Log.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER LINBEF,LINAFT
+SEQ,RCLINE.
+SEQ,GCUNIT.
      CHMAIL=CHLINE
      CALL GMAIL(LINBEF,LINAFT)
      END
+DECK,SHCREA.
      SUBROUTINE SHCREA
*.
*...SHCREA   Decide whether to convert the present particle into a showe
*.
*. COMMON    :
*. SEQUENCE  : GCKINE GCKING GCTRAK GCVOLU
*. CALLS     : GOKING GSKINE GSVERT
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  9-Feb-88
*. LAST MOD  : 28-Feb-89
*.
*. Modification Log.
*. 28-Feb-89   D.R.Ward        Trap GEKIN=0
*. 26-Sep-88   D.R.Ward        Mods for GEANT312.
*.  2-May-88   D.R.Ward        Move some code to GUSTEP.
*. 26-Apr-88   D.R.Ward        Strong typing
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCBANK.
+SEQ,GCKINE.
+SEQ,GCTRAK.
+SEQ,GCVOLU.
+SEQ,GCKING.
      INTEGER I,NVNEW,NTNEW,ITROLD
      REAL      UBUF(20),PMOM(3),GAMMA,WEM
+SELF,IF=-IBMRT.
      EXTERNAL GAMMA
+SELF.
      IF(IPART.EQ.77) GO TO 50
   10 CONTINUE
*
*     Check if particle/interaction type suitable.
*
      IF(IPART.EQ.1) THEN
         DO 20 I=1,NMEC
   20    IF(LMEC(I).GE. 6.AND. LMEC(I).LE.8) GO TO 40
         GO TO 50
      ELSEIF(IPART.EQ.2 .OR. IPART.EQ.3) THEN
         GO TO 40
      ELSEIF(IPART.EQ.5 .OR. IPART.EQ.6) THEN
         GO TO 50
      ELSE
         DO 30 I=1,NMEC
            IF(LMEC(I).EQ.5) THEN
               CALL GOKING
               NGKINE=0
               GO TO 50
            ENDIF
   30    IF(LMEC(I).GE. 12.AND. LMEC(I).LE.20) GO TO 40
         GO TO 50
      ENDIF
*     Suitable.
   40 CONTINUE
*
*     Stop this particle and turn it into a shower.
*
      IF(GEKIN.LE.0.) GO TO 50
      CALL GSVERT(VECT(1),ITRA,0,UBUF,0,NVNEW)
*
*     UBUF carries extra information about the shower.
*     UBUF(1) = # radiation lengths traversed.
*     UBUF(2) = # interaction lengths traversed.
*     UBUF(3) = # distance traversed.
*     UBUF(4) = Remaining em energy in shower.
*     UBUF(5) = Remaining hadronic energy in shower.
*     UBUF(6) = Ne Normalization of em component
*     UBUF(7) = Ae Alpha of em component
*     UBUF(8) = Be Beta of em component
*     UBUF(9) = Ne Normalization of em component
*     UBUF(10)= Ae Alpha of hadronic component
*     UBUF(11)= Be Beta of hadronic component
*     UBUF(12...) Widths
*
      PMOM(1)=VECT(4)*VECT(7)
      PMOM(2)=VECT(5)*VECT(7)
      PMOM(3)=VECT(6)*VECT(7)
      UBUF(1)=0.
      UBUF(2)=0.
      UBUF(3)=0.
      IF(IPART.LE.3) THEN
         UBUF(4)=GEKIN
         UBUF(5)=0.
*     UA1 fit to e/m showers; but don't allow a<1
*     <NIM 186 p533>
         UBUF(7)=2.2840+0.7136*ALOG(GEKIN)
         IF(UBUF(7).LT.1.) UBUF(7)=1.
         UBUF(8)=0.5607+0.0093*ALOG(GEKIN)
         UBUF(6)=UBUF(4)*UBUF(8)**UBUF(7)/GAMMA(UBUF(7))
         UBUF(10)=0.
         UBUF(11)=0.
         UBUF(9)=0.
      ELSE
*     NA24 fit to hadronic showers; but don't allow a<1
*     <NIM 219 p87>
         WEM=0.4634
* []  use GEKIN here - should add in 2*Mp for antibaryons?
         UBUF(4)=WEM*GEKIN
         UBUF(5)=(1.-WEM)*GEKIN
         UBUF(7)=0. 946+0. 618*ALOG(GETOT)
         IF(UBUF(7).LT.1.) UBUF(7)=1.
         UBUF(8)=0.290
         UBUF(6)=UBUF(4)*UBUF(8)**UBUF(7)/GAMMA(UBUF(7))
         UBUF(10)=0. 974+0. 068*ALOG(GETOT)
         IF(UBUF(10).LT.1.) UBUF(10)=1.
         UBUF(11)=0.9099-0.0237*ALOG(GETOT)
         UBUF(9)=UBUF(5)*UBUF(11)**UBUF(10)/GAMMA(UBUF(10))
      ENDIF
      CALL GSKINE(PMOM,77,NVNEW,UBUF,20,NTNEW)
      ISTOP=1
      NGKINE=0
*
*     Need to put it on stack also, otherwise it won't be tracked.
*
      ITROLD=ITRA
      ITRA=-NTNEW
      GKIN(1,1)=PMOM(1)
      GKIN(2,1)=PMOM(2)
      GKIN(3,1)=PMOM(3)
      GKIN(5,1)=77.
      IFLGK(1)=0
      CALL GSKING(1)
      ITRA=ITROLD
*
   50 RETURN
      END
+DECK,SHSTEP.
      SUBROUTINE SHSTEP
*.
*...SHSTEP   Deals with the tracking of showers.
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCFLAG GCKINE GCMATE GCTRAK GCUNIT GCVOLU RCREP.
*. CALLS     : GMAIL  REPORT
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  9-Feb-88
*. LAST MOD  : 11-Jul-88
*.
*. Modification Log.
*. 11-Jul-88   S.W.O'Neale   Fix bug in strong typing
*. 26-Apr-88   D.R.Ward        Strong typing
*. 14-Apr-88   D.R.Ward      Use CHREP for REPORT
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCBANK.
+SEQ,GCMATE.
+SEQ,GCTRAK.
+SEQ,GCFLAG.
+SEQ,GCUNIT.
+SEQ,GCKINE.
+SEQ,GCVOLU.
      REAL EMIN,S0,DS,DSTEP,AN,AA,BB,SUME,SS,SUMH,ZZZ,RRR
      INTEGER JK,JKU,MSTEP,JSTEP,J
*
*     EMIN is cutoff energy for showers.  Try 5 MeV for now.
      DATA EMIN/0.005/
      JK=LQ(JKINE-ITRA)
      JKU=LQ(JK-1)
      IF(JKU.EQ.0 .OR. JK.EQ.0) THEN
         WRITE(CHREP ,FMT='('' No user words for shower track'')')
         CALL REPORT('SHSTEP',1,'E')
         ISTOP=1
         GO TO 50
      ENDIF
*
      IF(STEP.EQ.0.) GO TO 50
*
*     Update e/m shower
*
      IF(Q(JKU+4).LT.EMIN) GO TO 20
      S0=Q(JKU+1)
      DS=STEP/RADL
      MSTEP=DS*10.+1.
      DSTEP=DS/FLOAT(MSTEP)
      AN=Q(JKU+6)
      AA=Q(JKU+7)-1.
      BB=Q(JKU+8)
      SUME=0.
      DO 10 JSTEP=1,MSTEP
         SS=S0+(FLOAT(JSTEP)-0.5)*DSTEP
         SUME=SUME+AN*SS**AA*EXP(-BB*SS)*DSTEP
   10 CONTINUE
      Q(JKU+4)=Q(JKU+4)-SUME
      Q(JKU+1)=Q(JKU+1)+DS
   20 CONTINUE
*
*     Update HAD shower
*
      IF(Q(JKU+5).LT.EMIN) GO TO 40
      S0=Q(JKU+2)
      DS=STEP/ABSL
      MSTEP=DS*10.+1.
      DSTEP=DS/FLOAT(MSTEP)
      AN=Q(JKU+9)
      AA=Q(JKU+10)-1.
      BB=Q(JKU+11)
      SUMH=0.
      DO 30 JSTEP=1,MSTEP
         SS=S0+(FLOAT(JSTEP)-0.5)*DSTEP
         SUMH=SUMH+AN*SS**AA*EXP(-BB*SS)*DSTEP
   30 CONTINUE
      Q(JKU+5)=Q(JKU+5)-SUMH
      Q(JKU+2)=Q(JKU+2)+DS
   40 CONTINUE
*
      Q(JKU+3)=Q(JKU+3)+STEP
      IF(Q(JKU+4).LT.EMIN .AND. Q(JKU+5).LT.EMIN) ISTOP=1
*
      IF(IDEBUG.EQ.1 .AND. ISWIT(2).EQ.2) THEN
         WRITE(CHMAIL,1000) (Q(JKU+J),J=1,5)
         CALL GMAIL(0,0)
      ENDIF
*
*     Bodge - problem with showers outside detector - needs investigatio
*
      IF(NLEVEL.EQ.1) THEN
         ZZZ=ABS(VECT(3))
         IF(ZZZ.GT.630.) THEN
            ISTOP=1
            GO TO 50
         ENDIF
         RRR=SQRT(VECT(2)**2+VECT(1)**2)
         IF(RRR.GT.675.) ISTOP=1
      ENDIF
   50 RETURN
 1000 FORMAT(' Shower parameters: distances so far',F6.2,' rad. len.,',
     +F6.2,' abs. len.',F6.2,' cm., Energy left =', F6.3,' e/m,',F6.3,
     +' had.')
      END
+DECK,SLTIMED,IF=MCP.
      REAL FUNCTION SLTIMED(LDATE,LTIME,FDATE,FTIME)
*-- Author :    Steve ONeale   05/06/96
*                                                                      *
*----------------------------------------------------------------------*
*                                                                      *
* Name : SLTIMED                                                       *
*        (module)                                                      *
*                                                                      *
* Description :                                                        *
*        Provides a time difference for data in DATIME format with a   *
*        range of a few days.                                          *
*                                                                      *
* Arguments   :                                                        *
*        [name]  ([in | out | in/out])      [description]              *
*        LDATE     in   Last Date    YYMMDD                            *
*        LTIME     in   Last Time      hhmm                            *
*        FDATE     in   First Date   YYMMDD                            *
*        LTIME     in   First Time     hhmm                            *
*                                                                      *
*----------------------------------------------------------------------*
*                                                                      *
* Author : Steve ONeale                       Date : 05/06/96          *
*                                                                      *
*----------------------------------------------------------------------*
*
+SEQ,DECLARE.
*
      INTEGER  FDATE,FTIME,LDATE,LTIME,FMM,LMM,FHH,LHH
      INTEGER  FYE,FMO,FDA,LYE,LMO,LDA
      INTEGER  DAYMON(12),DAYS
      DATA     DAYMON/  0, 31, 59, 90,120,151,181,212,243,273,304,334/
C                      31  28  31  30  31  30  31  31  30  31  30  31
C     Worry about Leap years in 1999.

      LMM=MOD(LTIME,100)
      LHH=LTIME/100
      LDA=MOD(LDATE,100)
      LMO=MOD(LDATE/100,100)
      LYE=LDATE/10000

      FMM=MOD(FTIME,100)
      FHH=FTIME/100
      FDA=MOD(FDATE,100)
      FMO=MOD(FDATE/100,100)
      FYE=FDATE/10000

      IF (LMO.NE.FMO) THEN
         DAYS=DAYMON(MIN(MAX(LMO,12),1))-DAYMON(MIN(MAX(FMO,12),1))
      ELSE
         DAYS=0
      ENDIF

      SLTIMED=(((LDA-FDA+DAYS)*24+(LHH-FHH))*60+(LMM-FMM))*60
*
      END       
+DECK,UGINIT.
      SUBROUTINE UGINIT
*.
*...UGINIT   Initialise the GOPAL program
*.
*.
*. COMMON    :
*. COMMON    :
*. SEQUENCE  : GCBANK GCFLAG GCKINE GCLIST GCONST GCUNIT
*. SEQUENCE  : GOCART GOFLAG GOFLD  GOUNIT LINKRA
*. CALLS     : DZVERI FFKEY  GBHSTA GDINIT GETNUM GFFGO  GGET   GHEINI
*. CALLS     : GINIT  GMAIL  GOPEN  GOPRIN GOVRSN GPART  GPHYSI GSAVE
*. CALLS     : GUVIEW GZINIT MZBOOK MZLINK OPGEOM UCOPY  UCTOH  USINIT
*. CALLS     : VFILL  VZERO   FILL  VZERO  GOHBOK GOISTA
*. CALLED    : MAIN
*.
*. BANKS L   : DAC    MCCO   TEMP
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.01
*. CREATED   : 25-Dec-84
*. LAST MOD  :  2-Mar-99
*.
*. Modification Log.
*.  2-Mar-99   S.W.O'Neale     LSF and NQS environment variables for Job Id etc.
*. 17-Nov-97   C.P.Ward        Increase space for FFREAD
*. 26-Feb-97   S.W.O'Neale     Add MCP spy code
*. 17-Dec-94   C.P.Ward        Remove CJDDE from external list - obsolete
*. 30-Nov-94   C.P.Ward        Call GFIN with opt 'I'
*. 30-Nov-94   M.Redmond       Add call the GGCLOS if reading INIT structure
*. 14-Nov-94   J.E.Conboy      Set IGYEAR correctly for expt.ge.6
*.  5-Jul-94   D.R.Ward        Allow HIGZ in batch mode?
*. 20-Dec-93   C.P.Ward        Tidy writing of INIT structure.
*. 08-Dec-93   C.P.Ward        Remove unused variables.
*. 19-Feb-93   J.E.Conboy      Calculate IGYEAR in /GOFLAG/
*. 13-Aug-92   D.R.Ward        Use GFIN/GFOUT
*. 25-Feb-92   D.R.Ward        Check if HIGZ already initialized.
*.  3-Jan-92   D.R.Ward        Implement internal file definition
*. 12-Jun-91   J.E.Conboy      Call FDGCSV to restore FDGCON after GET INIT
*. 16-Nov-90   D.R.Ward        Remove bodging of step lengths for GEANT314
*. 29-Aug-90   J.E.Conboy      Call FDTRTH after rope initialised
*.                             Call FDPBSC to fix FDET M/scatter lengths
*. 20-Aug-90   J.E.Conboy      Delete ref to LADC for ROPE311
*.  5-Jun-90   D.R.Ward        Fix GET INIT problem for ME?
*.  3-May-90   D.R.Ward        Fix GET INIT problems?
*.  1-May-90   D.R.Ward        Create directory for GOPAL/GEANT histos
*. 12-Jan-90   D.R.Ward        Book MCS; call DZVERI
*.  5-Jan-90   D.R.Ward        Move EXTERNALs, REBANK init'n from MAIN
*.  4-Jan-90   D.R.Ward        Declare GOFFUS to be the FFREAD user routine
*. 23-Sep-89   D.R.Ward        Suppress REPORT card (in REINIT)
*. 20-Jun-89   D.R.Ward        Initialize GOSLNK
*.  8-Jun-89   H.Kreutzmann    Move CJDEFI call
*.  6-Jun-89   D.R.Ward        Reset r.n. seed across OPGEOM (CJ problem)
*.  5-Jun-89   D.R.Ward        Mods  to graphics initialization
*.  2-Jun-89   D.R.Ward        Lift General Constants bank GNCT
*. 17-May-89   D.R.Ward        Don't call CJDEFI if CJ GEOM not selected
*.  1-Mar-89   S.W.O'Neale     Test on PLOT card before initializing gra
*. 26-Feb-89   D.R.Ward        Don't call CJDEFI in SMEAr mode
*. 24-Feb-89   S.Weisz         Mods for REPORT in ROPE306
*.  9-Feb-89   D.R.Ward        Move USINIT call before GOROPS
*. 24-Jan-89   H.Kreutzmann    Mods for CJ RZ usage
*.  3-Jan-89   D.R.Ward        More space for FFREAD; up to 8 characters
*.  3-Jan-89   H.Kreutzmann    Call CJDEFI
*. 13-Oct-88   D.R.Ward        Mods to GSAVE/GGET (GEANT312)
*. 11-Oct-88   D.R.Ward        Update MULS tables (GEANT312)
*.  6-Sep-88   D.R.Ward        Initialize Graphics package (including HI
*.  1-Aug-88   D.R.Ward        Test for eof from GGET
*. 30-May-88   D.R.Ward        Call GOIFFR after GOROPI
*. 24-May-88   D.R.Ward        Booking of MCCO, DATC moved to GOROPI
*.  4-May-88   D.R.Ward        Change logic for calling GSAVE.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 19-Apr-88   D.R.Ward        Call GOROPS
*. 14-Apr-88   D.R.Ward        Create ROPE divisions
*. 13-Apr-88   D.R.Ward        Declare /RCLINK/
*. 25-Mar-88   D.R.Ward        Only call GSAVE if necessary
*.  2-Feb-88   D.R.Ward        Set up "shower" particle
*. 27-Jan-88   D.R.Ward        Test on IEORUN
*. 19-Jan-88   D.R.Ward        Reorganize - move some of the work to
*.                               GOFFI, GOIIO, GOIGR
*. 27-Nov-87   D.R.Ward        Initialize statistics
*. 21-Oct-87   R.J.Hemingway   Mods to circumvent compiler problems in O
*. 20-Jul-87   D.R.Ward        Make OPAL the default VIEW if none specif
*. 15-Jul-87   D.R.Ward        Lift constants banks for ROPE
*.  7-Jul-87   D.R.Ward        FLDFAC set to -1 by default => full map
*. 28-May-87   B.Lorazo        Steering of CDET and VERT views added.
*.                             OPAL, CDET and VERT have now to be
*.                             declared in the VIEW FFREAD card together
*.                             with the options FRON, TOP ,SIDE and MIXE
*.                             OPAL views are stored in views 1-4, CDET
*.                             in views 5-7 and VERT in views 8-12
*.                             according to the herebefore option order.
*. 12-May-87   D.R.Ward        Allow CV CJ CZ CP to be specified on GEOM
*. 16-Apr-87   D.R.Ward        Add UNIT data card
*. 23-Feb-87   D.R.Ward        Add FAST data card for fast geometry def'
*. 28-Jan-87   D.R.Ward        Declare links for raw data structure
*.  9-Jan-87   D.R.Ward        Add FIEL card
*. 18-Dec-86   D.R.Ward        Add BOOT card option.
*. 30-Nov-86   D.R.Ward        Add PE HP and FD to GEOM options
*.  2-Sep-86   S.O'Neale       Remove character constants from data.
*. 21-Aug-86   S.O'Neale       CERNVAX option to do I/O during
*.                             initialisation of GOPAL.
*. 25-May-86   A.Possoz        Correct zeroing of IUFLAG (no effect).
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.  7-May-86   S.O'Neale       Introduce 'ALL ' option for SETS and
*.             and DIGI cards.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,ROBANK
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCUNIT
+SEQ,GCLIST
+SEQ,GOFLAG
+SEQ,GOFLD
+SEQ,GOLOGI
+SEQ,LINKGO
+SEQ,ROCPAR.
+SEQ,ROSPAR.
+SEQ,GOUNIT
+SEQ,RCREP.
+SEQ,GCMULO.
+SEQ,GOFILE.
+SEQ,ROSLNK.
+SEQ,EECLNK.
+SEQ,MBLINK.
+SEQ,MELINK,MELPAR.
+SEQ,GOHTOP.
+SEQ,TTCAL.
+SEQ,MCPSPY,IF=MCP.
      INTEGER LSPACE,IREPOR
+SELF,LSPACE.
      PARAMETER (LSPACE= 40000)
+SELF.
      COMMON /HIFLAG/ GFLAG,GLFLAG,ZFLAG,PFLAG,MFLAG,TFLAG
     +,ASFLAG,GRFLAG,AXFLAG
      LOGICAL GFLAG,GLFLAG,ZFLAG,PFLAG,MFLAG,TFLAG
     +,ASFLAG,GRFLAG,AXFLAG
      COMMON/REBANK/IREPOR(LSPACE)
      REAL    FFSPAC
      COMMON/CFREAD/FFSPAC(15000)
      COMMON/DUMMY0/DUMMY
      INTEGER ISEED(2),ISAVE(2)
      LOGICAL GGFLAG
      INTEGER IER,IDENT,JUCOMP
      INTEGER LGNCT,LBEAM,LMAGF,JJJ,LLIFE
      REAL    TIM0,TIM1,DUMMY
      EXTERNAL JUCOMP,GOFFUS,RFUSER
      EXTERNAL MELINT
      LOGICAL  MELINT
+SELF,IF=MCP.
      COMMON /SLATE/ ISLATE(40)
      INTEGER        ISLATE
      CHARACTER*(14)  Env
      CHARACTER*(4)   BatchSystem  ! Int LSF NQS MCP
      CHARACTER*(80)  JobLine
      INTEGER         SpySTAT,CHSPY
+SELF.
+SELF,IF=VAX.
*     Declare those GOPAL routines called from GEANT EXTERNAL -
*     allows one to keep GOPAL as an OLB on a VAX.
      EXTERNAL        GRUN,GUDIGI,GUHADR,GUKINE,GUOUT,GUPHAD, GUSTEP,
     +          GUTREV,QNEXT,GUFLD,GUNEAR,KIUSER
*     And RMAIL, lest we pick up the ROPE version instead!
      EXTERNAL RMAIL,ZTELUS
+SELF.
*
      DATA ISEED/12345,54321/
*
*     ------------------------------------------------------------------
*
      CALL TIMEX(TIM0)
      IREPOR(1)=LSPACE-100
      CALL GINIT
*
*--   Reinitialize FFREAD with more space/ 8 character names
*
      CALL FFINIT(15000)
      CALL FFSET('SIZE',12)
      CALL FFUSET(GOFFUS)
*
*--  set up the version number
*
      CALL GOVRSN
*
*--   Initialise  GEANT/ZEBRA/ROPE data structures
*
      CALL GZINIT
*
*--   Declare links to raw data banks
*
      CALL MZLINK(IXSTOR,'/ROLINK/',LTEMP,LCHEA,LTEMP)
      CALL MZLINK(IXSTOR,'/RCLINK/',LREV,LZZ,LREV)
      CALL MZLINK(IXSTOR,'/ROSLNK/',LRSMS,LRSP2,LRSMS)
*
*--   Initialize ROPE divisions etc.
*
      CALL GOROPI
      IF(IQ(LDAC-2).LT.LLGNCT)
     +    CALL MZPUSH(IXSTOR,LDAC,LLGNCT-IQ(LDAC-2),0,' ')
      CALL MZBOOK(IXCONS,LGNCT,LDAC,-LLGNCT,'GNCT',
     +            NLGNCT,NSGNCT,NDGNCT,IOGNCT,0)
      CALL MZBOOK(IXCONS,LMAGF,LGNCT,-LLMAGF,'MAGF',
     +            NLMAGF,NSMAGF,NDMAGF,IOMAGF,0)
      CALL MZBOOK(IXCONS,LBEAM,LGNCT,-LLBEAM,'BEAM',
     +            NLBEAM,NSBEAM,NDBEAM,IOBEAM,0)
      CALL MZBOOK(IXCONS,LLIFE,LGNCT,-LLLIFE,'LIFE',
     +            NLLIFE,NSLIFE,NDLIFE,IOLIFE,0)
      CALL MZBOOK (IROSTA,LMCS,LEXS,-LLMCS,'MCS ',1,1,120,2,0)
*
*--   Set up GOPAL data cards, read them, and take appropriate action.
*
      CALL GOIFFR
      IF(IEORUN.NE.0) GO TO 30
      IF(MOD(IGOEXP,1000) .LT. 6) THEN
        IGYEAR  =  1989 + MOD( IGOEXP,1000)
      ELSE
        IGYEAR  =  1988 + MOD( IGOEXP,1000)
      ENDIF
      WRITE(CHREP,6001) IGYEAR
 6001 FORMAT(I4,' OPAL configuration selected ')
      CALL REPORT( 'UGINIT', 4, 'I' )
*
+SELF,IF=DBUGMEMO.
      CALL DZVERI(' GOPAL: Verification after GZINIT ',IXSTOR,'CFLSU')
+SELF.
+SELF,IF=MCP.
      Hostname='HostName'
      CALL GETENVF('HOST',Env)
      IF ( ISLATE(1).EQ.0 ) CALL GETENVF('HOSTNAME',Env)
      IF ( ISLATE(1).NE.0 ) Hostname=Env

      BatchSystem='Int '
      JobName='No_JobName'
      JobId  ='No_JobId'
      CALL GETENVF('QSUB_REQID',Env)
      IF ( ISLATE(1).NE.0 ) THEN
         BatchSystem='NQS '
         JobId=Env
         CALL GETENVF('QSUB_REQNAME',JobName)
      ELSE
         CALL GETENVF('LSB_JOBID',Env)
         IF ( ISLATE(1).NE.0 ) THEN
            BatchSystem='LSF '
            JobId=Env
            CALL GETENVF('LSB_JOBNAME',JobName)
         ELSE
            CALL GETENVF('MCP_JOBID',Env)
            IF ( ISLATE(1).NE.0 ) THEN
               BatchSystem='MCP '
               JobId=Env
               CALL GETENVF('MCP_JOBNAME',JobName)
            END IF
         END IF
      END IF

      CHREP='Batch: '//BatchSystem//'   Name:'//JobName
     +    //' Id: '//JobId//'  On: '//Hostname
      CALL REPORT('UGINIT',66,'I')   ! Information Report

      CALL DATIME(StartDate,StartTime)
      CALL TIMEL(TimeLjob)
      StartRun=IDRUN
      StartEvent=IDEVT
      TrigJob=NEVENT              ! From TRIG FFREAD card /GCFLAG/
      TrigDone=0
      FileLimit=800 000.0         ! Not implemented
      FileSize=     500.0         ! Guess in Kb (INIT records)
      IF ( SPYLVL.NE.0 ) THEN
 8050 FORMAT(I6,1X,I4,1X,I5,1X,I6,1X,I5,1X,I6,5X,A8,1X,A12,1X,A16)
         WRITE( JobLine,8050) StartDate,StartTime,StartRun,StartEvent,
     +                        TrigJob,TimeLjob,  Hostname,JobName,JobId
         JobLine(80:80)=CHAR(10)   ! NewLine
         CALL CFOPEN(SPYDES,0,20,'w',0,'mcpspy',SpySTAT)
         IF ( SpySTAT.EQ.0 ) THEN
            CHREP=' MC Production monitor writing to mcpspy' 
            CALL REPORT('UGINIT',95,'I')       ! Information Report
         ELSE
            CHREP=' MCP monitor failed to open mcpspy '
            CALL REPORT('UGINIT',93,'E')       ! Error Report
            CHREP=' MC Production monitor writing to LUN 9 ' 
            CALL REPORT('UGINIT',94,'I')       ! Information Report
            SPYLVL=-SPYLVL                     ! Flag cfio failure
         END IF
         IF ( SPYLVL.LT.0 ) THEN
            WRITE(9,'('' I '',A)') JobLine
         ELSE
            CALL CFPUT (SPYDES,0,20,   JobLine,SpySTAT)  ! Job Processing
            CALL CFPUT (SPYDES,0,20,   JobLine,SpySTAT)  ! (Allow seek 1)
            CALL CFCLOS(SPYDES,0)                        ! Close the file
         END IF
      END IF
      IF (MCPTRAP.GT.0) THEN
         ON EXTERNAL ERROR CALL MCPETRAP    ! thats it for now
         CHREP=' Trap for HP External Errors Invoked'
         CALL REPORT('UGINIT',97,'I')       ! Information Report
         MCPETraps=0
      END IF
+SELF.
*
*--   Initialise HIGZ and the Drawing Package
*
+SELF,IF=GKS,HIGZ.
        IF(NPLOT.GT.0 .AND. NVIEW.GT.0 .AND. LPLOT(2).GE.1)  THEN
            JJJ=JUCOMP('METO',IONAME,NFILE)
            GGFLAG=GFLAG
            IF(.NOT. GGFLAG) CALL IGINIT(0)
            IF(LPLOT(3).LE.0 .OR. LPLOT(3).GT.65535) LPLOT(3)=0
***            CALL UHTOC(IOFCHO(JJJ),4,CHOPT,4)
            IF(JJJ.NE.0) THEN
*  Output to metafile
+SELF,IF=APOLLO,SUN,SGI,HPUX,IBMRT,IF=GKS,HIGZ.
            IF(IOFNAM(JJJ).EQ.'    ') THEN 
               OPEN(IOUNIT(JJJ),STATUS='NEW')
            ELSE
               OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ))
            ENDIF
+SELF,IF=VAX,DECS,QMVAOS,IF=GKS,HIGZ.
            IF(IOFNAM(JJJ).EQ.'    ') THEN 
               IF(LPLOT(3).EQ.101) THEN
                  OPEN(IOUNIT(JJJ),STATUS='NEW',
     +                 CARRIAGECONTROL='NONE')
               ELSEIF((LPLOT(3).GE.12201 .AND. LPLOT(3).LE.12204)
     +                 .OR. LPLOT(3).EQ.0 ) THEN
                  OPEN(IOUNIT(JJJ),STATUS='NEW',
     +                 CARRIAGECONTROL='LIST')
               ELSE
                  OPEN(IOUNIT(JJJ),STATUS='NEW')
               ENDIF
            ELSE
               IF(LPLOT(3).EQ.101) THEN
                  OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +                 CARRIAGECONTROL='NONE')
               ELSEIF((LPLOT(3).GE.12201 .AND. LPLOT(3).LE.12204)
     +                 .OR. LPLOT(3).EQ.0 ) THEN
                  OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ),
     +                 CARRIAGECONTROL='LIST')
               ELSE
                  OPEN(IOUNIT(JJJ),STATUS='NEW',FILE=IOFNAM(JJJ))
               ENDIF
            ENDIF
+SELF,IF=GKS.
               IF(.NOT. GGFLAG) CALL IGSSE(LOUT,101)
               IF(LPLOT(3).EQ.101 .OR.
     +           (LPLOT(3).GE.12001.AND.LPLOT(3).LE.12204)) THEN
                  CALL IGMETA(-IOUNIT(JJJ)-100,LPLOT(3))
               ELSE
                  CALL IGMETA(-IOUNIT(JJJ),LPLOT(3))
               ENDIF
               CHREP='Metafile opened'
               CALL REPORT('UGINIT',20,'I')
            ELSE
*  Output to screen - workstation id = LPLOT(3)
                IF(.NOT. GGFLAG) CALL IGSSE(LOUT,LPLOT(3))
            ENDIF
            CALL GDINIT
        ENDIF
+SELF,IF=HIGZ.
               IF(.NOT. GGFLAG) CALL IGSSE(LOUT,0)
               CALL IGMETA(-IOUNIT(JJJ),LPLOT(3))
               CHREP='Metafile opened'
               CALL REPORT('UGINIT',20,'I')
            ELSE
*  Output to screen - workstation id = LPLOT(3)
                IF(.NOT. GGFLAG) CALL IGSSE(LOUT,LPLOT(3))
            ENDIF
            CALL GDINIT
        ENDIF
+SELF,IF=DBUGMEMO,IF=GKS,HIGZ.
      CALL DZVERI(' GOPAL: Verification after GDINIT ',IXSTOR,'CFLSU')
+SELF.
*
*--   Initialize I/O units if required
*
      CALL GOIIO
*
*--   Read Initialisation data structures
*
*drw  CALL GGET(LGGET,CCGET,-NGET,IDENT,IER)
      IER=0
      IDENT=-1
      IF(NGET.GT.0) THEN
         CALL GFIN(LGGET,CCGET,NGET,0,'I',IER)
         IF(IER.GE.0) IDENT=0
      ENDIF
*drw      IF(IER.GT.2) THEN
      IF(IER.LT.0) THEN
         CHREP='Unexpected end of GET INIT input - stop the run'
         CALL REPORT('UGINIT',1,'F')
         IEORUN=1
         GO TO 30
      ENDIF
      IF(IDENT.EQ.0) THEN
*--   Init banks found - set up some links and then skip some steps.
         FLDFAC=SIGN(ABS(FLDFAC),FLDSGN)
         LRCO=LQ(JRUNG-1)
         LEXC=LQ(LRCO-LLEXC)
         LMCC=LQ(LEXC-2)
         LDAC=LQ(LRCO-LLDAC)
         LCDC=LQ(LRCO-LLCDC)
         LECC=LQ(LRCO-LLECC)
         LHCC=LQ(LRCO-LLHCC)
         LFOC=LQ(LRCO-LLFOC)
         LMUC=LQ(LRCO-LLMUC)
         LODC=LQ(LRCO-LLODC)
*
         IENCV(1)=-1
*
         CALL EESLNK
         LEECT=LQ(LDAC-LLEECT)
*
         CALL MBLDEF
         LMBCT=LQ(LDAC-LLMBCT)
         CALL MBCFIL
*
         IF(MELINT()) CALL MZLINT(IXSTOR,'/MELINK/',LAREA,LMETP,LAREA)
         LMECT=LQ(LDAC-LLMECT)
         LMESF=LQ(LMECT-LLMESF)
         LMEGM=LQ(LMECT-LLMEGM)
*              Reset parameters in FDGCON
         CALL FDGCSV( 'GET ')
*              and set up some HB/E stuff
         CALL HBGINT
         CALL HEGINT
*
         CALL GGCLOS
*
         CHREP='INIT structure GOT'
         CALL REPORT('UGINIT',1,'I')
         GO TO 10
      ENDIF
*
*--   Initialise  particles table and geometry
*
      CALL GPART
*     Define "shower particle"
      CALL GSPART(77,'Shower$',6,0.,0.,1.E15,0,0)
*
*     Safest to save and restore r.n. seed here.  Otherwise if xxGEOM
*     routines use random numbers the run will be unreproducible.
*
      CALL GRNDMQ(ISAVE(1),ISAVE(2),1,'G')
      CALL GRNDMQ(ISEED(1),ISEED(2),1,'S')
      CALL OPGEOM
      CALL GRNDMQ(ISAVE(1),ISAVE(2),1,'S')
      CHREP='OPGEOM called     '
      CALL REPORT('UGINIT',2,'I')
      IF(IEORUN.NE.0) GO TO 30
 
*
+SELF,IF=DBUGMEMO.
      CALL DZVERI(' GOPAL: VERIFICATION AFTER OPGEOM ',IXSTOR,'CFLSU')
+SELF.
*--   initialises physics tables (energy loss,cross-sections,..)
*
   10 CONTINUE
      CALL GPHYSI
*
         CHREP='Physics processes initialized'
         CALL REPORT('UGINIT',3,'I')
 
*
*--   Initialise GHEISHA (if selected)
+SELF,IF=GHEISHA.
      CALL GHEINI
         CHREP='GHEISHA initialized'
         CALL REPORT('UGINIT',4,'I')
+SELF.
*
*--   Book GEANT histogram or volume statistics
*
      IF(GOTOP.NE.' //PAWC') THEN
         CALL HCDIR(GOTOP,' ')
         CALL HMDIR('GEANT',' ')
      ENDIF
      CALL HCDIR('//PAWC',' ')
      CALL HMDIR('GEANT','S')
      IF(NHSTA.GT.0)CALL GBHSTA
*
*--   Initialize GOPAL statistics
*
      IF(GOTOP.NE.' //PAWC') THEN
         CALL HCDIR(GOTOP,' ')
         CALL HMDIR('GOPAL',' ')
      ENDIF
      CALL HCDIR('//PAWC',' ')
      CALL HMDIR('GOPAL','S')
      CALL GOISTA
      CALL GOHBOK
      CALL HCDIR('//PAWC',' ')
*
*--   create view banks
*
+SELF,IF=GKS,HIGZ.
      CALL GOIGR
+SELF.
*
   20 CALL GOPRIN
*
*--   Check the jet chamber run specifications.
*
      IF(JUCOMP('CJ  ',LGEOM,NGEOM).NE.0) CALL CJDEFI
*
*     Reinitialize FFREAD - allowing 8 characters this time.
*
      CALL FFINIT(5000)
      CALL FFSET('SIZE',8)
      CALL FFUSET(RFUSER)
*
*     Define one (dummy) KEY to prevent rude error message from FFGO
*
      CALL FFKEY('QWERTYUI',DUMMY,1,'REAL')
*
      CALL USINIT
*
*--   Now initialize ROPE processors.
*
      CALL GOROPS
*
      CALL FDTRTH
*
*--   Save INIT data structures; then remove INIT from array to
*--   prevent multiple writing.
*
      IF(NSAVE.GE.1) THEN
        CALL GFOUT(LGSAVE,'INIT',1,0,' ',IER)
        NSAVE = NSAVE - 1
      ENDIF
*
+SELF,IF=DBUGMEMO.
      CALL DZVERI(' GOPAL: Verification after USINIT ',IXSTOR,'CFLSU')
+SELF.
   30 CALL TIMEX(TIM1)
      IQ(LMCS+2)=100.*(TIM1-TIM0)
      IF(JUCOMP('INIT',JZVERI,10).NE.0 .OR.
     +   JUCOMP('CONS',JZVERI,10).NE.0)
     +   CALL DZVERI('End of UGINIT',IXCONS,'CLSU')
      RETURN
      END
+DECK,UGLAST.
      SUBROUTINE UGLAST
*.
*...UGLAST  GOPAL termination routine to print histograms and statistics
*.
*.
*. COMMON    :
*. SEQUENCE  : GCLIST
*. CALLS     : GCLOSE GLAST  TVEND  USLAST  GOPSTA
*. CALLED    : MAIN
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.09
*. CREATED   : 25-Dec-84
*. LAST MOD  : 12-Jan-95
*.
*. Modification Log.
*. 12-Jan-95   C.P.Ward        Use GOOOUT on DECS, QMAVOS
*.  8-Dec-93   C.P.Ward        Remove unused variables.
*.  9-Aug-93   D.R.Ward        Change OPT 'T' to 'NT' in HROUT.
*.  2-Jan-90   D.R.Ward        Use GOOOUT on VAX
*.  8-Jun-89   H.Kreutzmann    Mods for OC201
*.  5-Jun-89   D.R.Ward        Write histo's to RZ file if required
*. 24-Jan-89   H.Kreutzmann    Mods to handle CJ RZ files
*.  4-Nov-88   D.R.Ward        Problem with unmatched ENDIF
*.  6-Sep-88   D.R.Ward        Use IGEND
*. 20-Jul-88   D.R.Ward        Add RCEREP (forgotten)
*. 11-Jul-88   S.W.O'Neale     Error handling for IBM
*.  6-May-88   D.R.Ward        Call HISTDO
*. 26-Apr-88   D.R.Ward        Strong typing
*. 21-Apr-88   S.L.Lloyd       Call GOTRPR
*. 30-Nov-87   D.R.Ward        Call RCPREP
*. 27-Nov-87   D.R.Ward        Call GOPSTA
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.  9-May-86   S.O'Neale       CALL TVEND for GKS,PIGS use selection.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,CRO.
+SEQ,ROBANK.
+SEQ,GCLIST
+SEQ,ROPAR.
+SEQ,GOFILE.
+SEQ,GOLOGI.
+SEQ,GCFLAG.
+SEQ,RCREP.
+SEQ,RCEREP,IF=IBM.
      INTEGER INEW
      INTEGER JUCOMP,JJJ
      EXTERNAL JUCOMP
*
*     ------------------------------------------------------------------
*
+SELF,IF=CJCARZBL.
      CALL CACJCL
+SELF.
*
*     Close GEANT              
*
      CALL GLAST
*
*     Close GKS display file
*
      IF(NPLOT.GT.0.OR.NVIEW.GT.0) THEN
+SELF,IF=GKS,HIGZ.
         CALL IGEND
+SELF.
      ENDIF
*
*     Print various statistics
*
   10 CALL GOPST2
      CALL GOPSTA
      CALL GOTRPR
*
*     Close down ROPE processors.
*
      CALL GOROPF
      IF(LCDSM .OR. LCALSM) CALL SMLAST
*
*     User's last chance to do anything
*
      CALL USLAST
*
*     Write RST structure as End-of-run (to DATA and PROD but not DST).
*
      JJJ=JUCOMP('DATO',IONAME,NFILE)
      IF(JJJ.NE.0) THEN
         CALL VZERO(IUHEAD,NDREV)
         IUHEAD(IIDAT )=2005
         IUHEAD(IIRUN )=IDRUN
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOOOUT('DATO',INEW)
+SELF.
         CALL FZOUT(IOUNIT(JJJ),IROSTA,LRST,1,' ',IOHEAD,NDREV,IUHEAD)
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOCOUT('DATO')
+SELF.
      ENDIF
      JJJ=JUCOMP('PROO',IONAME,NFILE)
      IF(JJJ.NE.0) THEN
         CALL VZERO(IUHEAD,NDREV)
         IUHEAD(IIDAT )=2005
         IUHEAD(IIRUN )=IDRUN
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOOOUT('PROO',INEW)
+SELF.
         CALL FZOUT(IOUNIT(JJJ),IROSTA,LRST,1,' ',IOHEAD,NDREV,IUHEAD)
+SELF,IF=VAX,DECS,QMVAOS.
         CALL GOCOUT('PROO')
+SELF.
      ENDIF
*
*     Print and/or save histograms
*
      CALL HLDIR('//PAWC','T')
      CALL HPDIR('//PAWC/GEANT','T')
      CALL HPDIR('//PAWC/GOPAL','T')
      JJJ=JUCOMP('HISO',IONAME,NFILE)
      IF(JJJ.EQ.0) JJJ=JUCOMP('HISU',IONAME,NFILE)
      IF(JJJ.NE.0) THEN
         CALL HCDIR('//PAWC',' ')
         CALL HCDIR('//HISTO',' ')
         CALL HROUT(0,JJJ,'NT')
         CALL HREND('HISTO')
         CHREP='Histograms saved to RZ file'
         CALL REPORT('UGLAST',2,'I')
      ENDIF
      CALL HCDIR('//PAWC',' ')
*
*
+SELF,IF=IBM.
      IF(NERTOT.GT.0) THEN
         WRITE(CHREP,5000) NERTOT
         CALL REPORT('IBMERR',3,'WARNING')
      ENDIF
 5000 FORMAT('IBM Run time errors (',I6,') occured in this run.')
+SELF.
      CALL REPREP('*')
*
*             Close I/O buffers
*
      CALL FZENDI(0,'T')
      IF(JUCOMP('RUNI',IONAME,NFILE).EQ.0) THEN
+SELF,IF=VAX,DECS,QMVAOS.
         IF(JUCOMP('DATO',IONAME,NFILE).NE.0) CALL GOOOUT('DATO',INEW)
         IF(JUCOMP('PROO',IONAME,NFILE).NE.0) CALL GOOOUT('PROO',INEW)
         IF(JUCOMP('DSTO',IONAME,NFILE).NE.0) CALL GOOOUT('DSTO',INEW)
         IF(JUCOMP('DDSO',IONAME,NFILE).NE.0) CALL GOOOUT('DDSO',INEW)
+SELF.
         CALL FZENDO(0,'T')
      ENDIF
      RETURN
      END
+DECK,USFFGO.
      SUBROUTINE USFFUS(KEYW)
*.
*...USFFUS   USERs initialization routine to handle user defined * cards
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    : GOFFUS
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  1-Mar-93
*. LAST MOD  :  1-Mar-93
*.
*. Modification Log.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      INTEGER KEYW
      RETURN
      END
+DECK,USIFFR.
      SUBROUTINE USIFFR
*.
*...USIFFR   USERs initialization routine.  Called before GFFGO, and
*.           therefore intended mainly to allow the user to define
*.           private data cards.  (S)he can then take appropriate action
*.           in USINIT.
*.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    : GOIFFR
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  9-Feb-88
*. LAST MOD  : 26-Apr-88
*.
*. Modification Log.
*. 26-Apr-88   D.R.Ward        Strong typing
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      RETURN
      END
+DECK,USINIT.
      SUBROUTINE USINIT
*.
*...USINIT   USERs routine for start of run processing.  Called after
*.           the standard GOPAL/GEANT initialization.
*.
*.
*. COMMON    :
*. SEQUENCE  : GCLIST
*. CALLS     : GLOOK  HBOOK1 HDELET
*. CALLED    : UGINIT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 26-Apr-88
*.
*. Modification Log.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 18-Dec-86   S.O'Neale       Avoid HBOOK bug with auto binsizes.
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCBANK,IF=DBUGMEMO.
+SEQ,GCLIST
+SEQ,GCUNIT
      INTEGER ID
*--   The algorithm (in use in HBOOK version 3) to perform the automatic
*--   limits calculation results in the overwriting of the storage or
*--   pointers of other histograms. This effect was reported in 1984 as
*--   a possible GEANT bug and has now been traced to the HAUTO routine
*--   in HBOOK. (S.O'Neale, Dec 1986).
*--   Anybody using GEANT/GOPAL to study complete events
*--   and who uses the SIZE histogram can avoid the problem by defining
*--   the upper limit to the histogram at this point.
      IF(NHSTA.GT.0) THEN
         CALL GLOOK('SIZE',LHSTA,NHSTA,ID)
         IF(ID.NE.0) THEN
            CALL HDELET(-ID)
            CALL HBOOK1(-ID,'Space Used in IXDIV per Event.$',
     1      100, 0.0 , 500000., 0.)
*                      ------
         ENDIF
      ENDIF
      END
+DECK,USLAST.
      SUBROUTINE USLAST
*.
*...USLAST   USERs routine for end of run processing
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     : HISTDO
*. CALLED    : UGLAST
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  :  6-May-88
*.
*. Modification Log.
*.  6-May-88   D.R.Ward        Drop HISTDO call
*. 26-Apr-88   D.R.Ward        Strong typing
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      RETURN
      END
+DECK,USOUT.
      SUBROUTINE USOUT
*.
*...USOUT   USERs routine for end of event processing.
*.
*. COMMON    :
*. SEQUENCE  : GCBANK GCUNIT
*. CALLS     :
*. CALLED    : GUOUT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 25-Dec-84
*. LAST MOD  : 26-Apr-88
*.
*. Modification Log.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 19-May-86   S.O'Neale       Insert documentation on program structure
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,GCBANK,IF=DBUGMEMO
+SEQ,GCUNIT
      INTEGER IERROR
+SELF,IF=DBUGMEMO.
      IERROR=0
*     CALL ZDEBUG(Q,LOUT,IERROR,'USOUT ')
+SELF.
      RETURN
      END
+DECK,USSDBG,IF=*USSDBG.
      SUBROUTINE USSDBG 
      END
+DECK,USSLCT.
      SUBROUTINE USSLCT(CTYPE,WANTED)
*.
*...USSLCT    USERs routine called before output of event
*.
*. INPUT     : CTYPE  - type of o/p 'DATA' 'PROD' or 'DST '
*. OUTPUT    : WANTED - logical flag - set .FALSE. to drop event
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    : GUOUT
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   :  6-Nov-89
*. LAST MOD  :
*.
*. Modification Log.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      LOGICAL       WANTED
      CHARACTER*(*) CTYPE
      WANTED=.TRUE.
      RETURN
      END
+DECK,USSTEP.
      SUBROUTINE USSTEP
*.
*...USSTEP  USERs routine called each tracking step.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :
*. CALLED    : GUSTEP
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 20-Jul-87
*. LAST MOD  : 26-Apr-88
*.
*. Modification Log.
*. 26-Apr-88   D.R.Ward        Strong typing
*. 20-Jul-87   D.R.Ward        Introduced into GOPAL
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      RETURN
      END
+DECK,ZEND.
      SUBROUTINE ZEND
*.
*...ZEND   Receives control after a ZEBRA crash.
*.         Tries to perform normal GOPAL closedown.
*.         Needed otherwise one gets the ROPE version of ZEND
*.         which isn't what we want.
*.
*.
*. COMMON    :
*. SEQUENCE  :
*. CALLS     :  UGLAST
*. CALLED    :  <ZEBRA>
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : D.R.Ward
*. VERSION   : 1.00
*. CREATED   : 17-May-88
*. LAST MOD  :
*.
*. Modification Log.
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
      CALL UGLAST
      END
+DECK,ZTELUS.
      SUBROUTINE ZTELUS
*.
*...ZTELUS User routine called on ZEBRA error
*.
*.
*. COMMON    : ZTELLC
*. SEQUENCE  :
*. CALLS     :
*. CALLED    :
*.
*. BANKS L   :
*. BANKS U   :
*. BANKS M   :
*. BANKS D   :
*.
*. REPORT CONDITIONS
*.
*. AUTHOR    : S.O'Neale
*. VERSION   : 1.00
*. CREATED   : 31-Dec-86
*. LAST MOD  :  4-Jul-91
*.
*. Modification Log.
*.  4-Jul-91   S.W.O'Neale     Set MODE=3
*.  4-Dec-89   D.R.Ward        Set IFBOOK
*.  5-Apr-89   D.R.Ward        Handle REPORT FATAL/CRASH conditions.
*.  6-Sep-88   D.R.Ward        Do not use REPORT
*. 26-Apr-88   D.R.Ward        Strong typing
*. 14-Apr-88   D.R.Ward      Use CHREP for REPORT
*. 30-Nov-87   D.R.Ward        Use of REPORT
*.
*.**********************************************************************
*.
+SEQ,DECLARE.
+SEQ,RCREP.
+SEQ,GCUNIT.
+SEQ,ROBANK.
+SEQ,GCFLAG.
+SEQ,RCNTRL.
      CHARACTER*2 CREV(10),CCD(9)
      INTEGER ID,MODE
      INTEGER NNB,NND,NNL,NNW,I,J
      COMMON /ZTELLC/ ID,MODE
      COMMON /ZSTATE/QVERSN,NQPHAS,IQDBUG,NQDCUT,NQWCUT,NQERR
     +,              NQLOGD,NQLOGM,NQLOCK,NQDEVZ,NQAUGM(6)
      INTEGER        QVERSN,NQPHAS,IQDBUG,NQDCUT,NQWCUT,NQERR
      INTEGER        NQLOGD,NQLOGM,NQLOCK,NQDEVZ,NQAUGM
      DATA CREV/'EX','UT','DA','CD','EC','HC','MU','FO','DD','OD'/
      DATA CCD /'CV','CJ','CZ','CT','DX','CF','CX','SI','CS'/
      WRITE (CHMAIL,FMT= '('' GOPAL ZTELUS ID '',I5,'' MODE '',I3)') ID,
     +MODE
      CALL GMAIL(0,0)
      CHREP=CHMAIL
      IF(ID.EQ.99 .AND. MODE.EQ.1) THEN
        CHMAIL=' This probably means you have run out of memory'
        CALL GMAIL(0,0)
        CHREP=' ***** Run out of memory ***** '
        IEOTRI=1
        CALL ROSIZE(LRCO,'    ',NNB,NND,NNL,NNW)
        WRITE(CHMAIL,
     +    '('' Size of RCO structure ='',I10,'' words'')') NNW
        CALL GMAIL(0,0)
        CALL ROSIZE(LREV,'    ',NNB,NND,NNL,NNW)
        WRITE(CHMAIL,
     +    '('' Size of REV structure ='',I8,'' words'')') NNW
        CALL GMAIL(0,0)
        DO 10 I=1,10
          IF(LQ(LREV-I).LE.0) GO TO 10
          CALL ROSIZE(LQ(LREV-I),'    ',NNB,NND,NNL,NNW)
          WRITE(CHMAIL,
     +      '(12X,A2,'' structure ='',I8,'' words'')')CREV(I),NNW
          CALL GMAIL(0,0)
          IF(I.EQ.4 .AND. LCD.NE.0) THEN
            DO 20 J=1,9
              IF(LQ(LCD-J).LE.0) GO TO 20
              CALL ROSIZE(LQ(LCD-J),'    ',NNB,NND,NNL,NNW)
              WRITE(CHMAIL,
     +          '(14X,A2,'' structure ='',I8,'' words'')')CCD(J),NNW
              CALL GMAIL(0,0)
  20        CONTINUE
          ENDIF
  10    CONTINUE
      ENDIF
*
*     FATAL - abort event
*
      IF(ID.EQ.101 .AND. NQPHAS.GE.1) THEN
          IEOTRI=1
          IF(MODE.EQ.0) MODE=1
      ENDIF
*
*     CRASH - abort run
*
      IF(ID.EQ.102 .AND. NQPHAS.GE.1) THEN
         IEOTRI=1
         IEORUN=1
***         IF(MODE.EQ.0) MODE=1
         MODE=3
      ENDIF
      IFBOOK=0
      CALL REPORT('ZTELUS',ID,'E')
      END
+PATCH,NOGENLIB.   MATHLIB routines required by GOPAL.
+DECK,DSTLAN,IF=-F4.
      FUNCTION DSTLAN(X)
C
      DIMENSION P1(0:4),P2(0:3),P3(0:3),P4(0:3),P5(0:3),P6(0:3)
      DIMENSION Q1(0:4),Q2(0:3),Q3(0:3),Q4(0:3),Q5(0:3),Q6(0:3)
      DIMENSION A1(1:3),A2(1:3)
C
      DATA (P1(I),I=0,4),(Q1(J),J=0,4)
     1/ 0.25140 91491E+0,-0.62505 80444E-1, 0.14583 81230E-1,
     2 -0.21088 17737E-2, 0.74112 47290E-3,
     3  1.0             ,-0.55711 75625E-2, 0.62253 10236E-1,
     4 -0.31373 78427E-2, 0.19314 96439E-2/
C
      DATA (P2(I),I=0,3),(Q2(J),J=0,3)
     1/ 0.28683 28584E+0, 0.35643 63231E+0, 0.15235 18695E+0,
     2  0.22513 04883E-1,
     3  1.0             , 0.61911 36137E+0, 0.17207 21448E+0,
     4  0.22785 94771E-1/
C
      DATA (P3(I),I=0,3),(Q3(J),J=0,3)
     1/ 0.28683 29066E+0, 0.30038 28436E+0, 0.99509 51941E-1,
     2  0.87338 27185E-2,
     3  1.0             , 0.42371 90502E+0, 0.10956 31512E+0,
     4  0.86938 51567E-2/
C
      DATA (P4(I),I=0,3),(Q4(J),J=0,3)
     1/ 0.10003 51630E+1, 0.45035 92498E+1, 0.10858 83880E+2,
     2  0.75360 52269E+1,
     3  1.0             , 0.55399 69678E+1, 0.19335 81111E+2,
     4  0.27213 21508E+2/
C
      DATA (P5(I),I=0,3),(Q5(J),J=0,3)
     1/ 0.10000 06517E+1, 0.49094 14111E+2, 0.85055 44753E+2,
     2  0.15321 53455E+3,
     3  1.0             , 0.50099 28881E+2, 0.13998 19104E+3,
     4  0.42000 02909E+3/
C
      DATA (P6(I),I=0,3),(Q6(J),J=0,3)
     1/ 0.10000 00983E+1, 0.13298 68456E+3, 0.91621 49244E+3,
     2 -0.96050 54274E+3,
     3  1.0             , 0.13398 87843E+3, 0.10559 90413E+4,
     4  0.55322 24619E+3/
C
      DATA (A1(I),I=1,3)
     1/-0.45833 33333E+0, 0.66753 47222E+0,-0.16417 41416E+1/
C
      DATA (A2(I),I=1,3)
     1/ 1.0             ,-0.42278 43351E+0,-0.20434 03138E+1/
C
      V=X
      IF(V .LT. -5.5) THEN
       U=EXP(V+1.0)
       DSTLAN=0.3989422803*EXP(-1.0/U)*SQRT(U)*
     1        (1.0+(A1(1)+(A1(2)+A1(3)*U)*U)*U)
      ELSE IF(V .LT. -1.0) THEN
       U=EXP(-V-1.0)
       DSTLAN=(EXP(-U)/SQRT(U))*
     1        (P1(0)+(P1(1)+(P1(2)+(P1(3)+P1(4)*V)*V)*V)*V)/
     2        (Q1(0)+(Q1(1)+(Q1(2)+(Q1(3)+Q1(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 1.0) THEN
       DSTLAN=(P2(0)+(P2(1)+(P2(2)+P2(3)*V)*V)*V)/
     1        (Q2(0)+(Q2(1)+(Q2(2)+Q2(3)*V)*V)*V)
      ELSE IF(V .LT. 4.0) THEN
       DSTLAN=(P3(0)+(P3(1)+(P3(2)+P3(3)*V)*V)*V)/
     1        (Q3(0)+(Q3(1)+(Q3(2)+Q3(3)*V)*V)*V)
      ELSE IF(V .LT. 12.0) THEN
       U=1.0/V
       DSTLAN=(P4(0)+(P4(1)+(P4(2)+P4(3)*U)*U)*U)/
     1        (Q4(0)+(Q4(1)+(Q4(2)+Q4(3)*U)*U)*U)
      ELSE IF(V .LT. 50.0) THEN
       U=1.0/V
       DSTLAN=(P5(0)+(P5(1)+(P5(2)+P5(3)*U)*U)*U)/
     1        (Q5(0)+(Q5(1)+(Q5(2)+Q5(3)*U)*U)*U)
      ELSE IF(V .LT. 300.0) THEN
       U=1.0/V
       DSTLAN=(P6(0)+(P6(1)+(P6(2)+P6(3)*U)*U)*U)/
     1        (Q6(0)+(Q6(1)+(Q6(2)+Q6(3)*U)*U)*U)
      ELSE
       U=1.0/(V-V*LOG(V)/(V+1.0))
       DSTLAN=1.0-(A2(1)+(A2(2)+A2(3)*U)*U)*U
      END IF
      RETURN
      END
+DECK,FUNPRE.
      SUBROUTINE FUNPRE (FUNC,XFCUM,X2LOW,X2HIGH)
C         F. JAMES,    MAY, 1976
C         MODIFIED OCT, 1980 TO ADD PRINTOUT OF INTEGRAL
C         MODIFIED DEC., 1980 TO DELETE LEADING AND TRAILING
C            RANGES OF X WHERE FUNCTION IS ZERO.
C         MODIFIED JUNE,1982 TO FIX POSSIBLE INFINITE LOOP.
C
C         PREPARES THE USER FUNCTION "FUNC" FOR FUNRAN
C         BY FINDING THE PERCENTILES
C         (IN EFFECT, INVERTING THE CUMULATIVE DISTRIBUTION)
      EXTERNAL FUNC
      COMMON/FUNINT/TFTOT
      DIMENSION XFCUM(100)
      DATA NBINS / 99/
      DATA NZ / 10/
      DATA MAXZ / 20/
      DATA NITMAX / 6 /
      DATA IFUNC/0/
      IFUNC = IFUNC + 1
C         FIND MACHINE ACCURACY
      COMP1 = 1.0
      DO 200 I= 1, 100
      COMP1 = COMP1*0.5
      COMP2 = 1.0 - COMP1
      IF(COMP2 .EQ. 1.0) GOTO 210
  200 CONTINUE
      COMP1 = 1.0E-10
  210 PRECIS = COMP1
C         FIND RANGE WHERE FUNCTION IS NON-ZERO.
      CALL FUNZER(FUNC,X2LOW,X2HIGH,XLOW,XHIGH)
      XRANGE = XHIGH-XLOW
      IF(XRANGE .LE. 0.) GOTO 900
      RTEPS = MAX(0.0001,PRECIS*10.)
      TFTOT = GAUSS(FUNC,XLOW,XHIGH,RTEPS)
C         PRINT OUT VALUE OF NORMALIZATION INTEGRAL
      WRITE(6,1003) IFUNC,XLOW,XHIGH,TFTOT
      RTEPS = 0.001
      IF(TFTOT .LE. 0.) GOTO 900
      TPCTIL = TFTOT/NBINS
      TZ = TPCTIL/NZ
      TZMAX = TZ * 2.
       XFCUM(1) = XLOW
      XFCUM(NBINS+1) = XHIGH
      X = XLOW
      F = FUNC(X)
      IF(F .LT. 0.) GOTO 900
      NBINM1 = NBINS - 1
C         LOOP OVER BINS (HUNDREDTH PERCENTILES)
      DO 600 IBIN = 1, NBINM1
      TCUM = 0.
      X1 = X
      F1 = F
      DXMAX = (XHIGH -X) / NZ
      FMIN = TZ/DXMAX
      FMINZ = FMIN
C         LOOP OVER TRAPEZOIDS WITHIN A SUPPOSED PERCENTILE
      DO 500 IZ= 1, MAXZ
      XINCR = TZ/MAX(F1,FMIN,FMINZ)
  350 X = X1 + XINCR
      F = FUNC(X)
      IF(F .LT. 0.) GOTO 900
      TINCR = (X-X1) * 0.5 * (F+F1)
      IF(TINCR .LT. TZMAX) GOTO 370
      XINCR = XINCR * 0.5
      GOTO 350
  370 CONTINUE
      TCUM = TCUM + TINCR
      IF(TCUM .GE. TPCTIL*0.99) GOTO 520
      FMINZ = TZ*F/ (TPCTIL-TCUM)
      F1 = F
      X1 = X
  500 CONTINUE
      WRITE(6,2000)
 2000 FORMAT('0      FAILURE TO FIND TRAPEZOID   HELP')
C         END OF TRAPEZOID LOOP
C         ADJUST TRAPEZOID INTEGRAL BY GAUSS WITH NEWTON CORRECTION
  520 CONTINUE
      X1 = XFCUM(IBIN)
      XBEST = X
      DTBEST = TPCTIL
      TPART = TPCTIL
C         ALLOW FOR MAXIMUM NITMAX MORE ITERATIONS ON GAUSS
      DO 550 IHOME= 1, NITMAX
      XINCR = (TPCTIL-TPART) / MAX(F,FMIN)
  535 X = XBEST + XINCR
      X2 = X
      TPART2 = GAUSS(FUNC,X1,X2,RTEPS)
      DTPAR2 = TPART2-TPCTIL
      DTABS = ABS(DTPAR2)
      IF(ABS(XINCR) .LT. PRECIS) GOTO 545
      IF(DTABS .LT. DTBEST) GOTO 545
      XINCR = XINCR * 0.5
      GOTO 535
  545 DTBEST = DTABS
      XBEST = X
      IF(DTABS .LT. RTEPS*TPCTIL) GOTO 580
      TPART = TPART2
      F = FUNC(X)
  550 CONTINUE
      IHOME = NITMAX
C
  580 CONTINUE
      XFCUM(IBIN+1) = X
      F = FUNC(X)
      IF(F .LT. 0.) GOTO 900
  600 CONTINUE
C         END OF LOOP OVER BINS
      X1 = XFCUM(NBINS)
      X2 = XHIGH
      TPART = GAUSS(FUNC,X1,X2,RTEPS)
      ABERR = ABS(TPART-TPCTIL)/TFTOT
      WRITE(6,1001) IFUNC,ABERR
      IF(ABERR .GT. RTEPS)  WRITE(6,1002)
      RETURN
  900 WRITE(6,1000) X,F,XLOW,XHIGH
      RETURN
 1000 FORMAT('0FUNPRE FINDS NEGATIVE FUNCTION VALUE OR RANGE OF X'/
     + ,' X=',E15.6,', F=',E15.6,20X,'XLOW=',E15.6,' XHIGH=',E15.6/)
 1001 FORMAT(' SUBROUTINE FUNPRE HAS PREPARED USER FUNCTION NUMBER',I4,
     + ' FOR FUNRAN'/' MAXIMUM RELATIVE ERROR IN CUMULATIVE',
     + 'DISTRIBUTION WILL BE',E15.5)
 1002 FORMAT('+',80X,'WARNING,THIS MAY BE TOO BIG'//)
 1003 FORMAT('0SUBROUTINE FUNPRE FINDS THE INTEGRAL OF USER FUNCTION',
     +  I2,' FROM ',E12.5,' TO ',E12.5,' IS ',E14.6)
      END
+DECK,FUNRAN.
      SUBROUTINE FUNRAN(ARRAY,XRAN)
C         GENERATION OF RANDOM NUMBERS IN ANY GIVEN DISTRIBUTION, BY
C         4-POINT INTERPOLATION IN THE INVERSE CUMULATIVE DISTR.
C         WHICH WAS PREVIOUSLY GENERATED BY FUNPRE
      COMMON/FUNINT/X
      DIMENSION ARRAY(100)
      DIMENSION RBUF(20)
      DATA IBUF/20/
      DATA GAP,GAPINV/.0101010101,99./
C
*DRW 29-Oct-90
*drw  IF (IBUF .LT. 20)  GO TO 10
*drw  CALL GRNDM(RBUF,020)
*drw  IBUF = 0
*  10 IBUF = IBUF + 1
*drw  X = RBUF(IBUF)
      CALL GRNDM(X,1)
*DRW 29-Oct-90
      J = INT(  X    *GAPINV) + 1
      J = MAX0(J,2)
      J = MIN0(J,98)
      P = (   X -GAP*FLOAT(J-1)) * GAPINV
      A = (P+1.0) * ARRAY(J+2) - (P-2.0)*ARRAY(J-1)
      B = (P-1.0) * ARRAY(J) - P * ARRAY(J+1)
      XRAN = A*P *(P-1.0) *0.16666667  + B * (P+1.0) * (P-2.0) * 0.5
      RETURN
      END
+DECK,FUNZER.
      SUBROUTINE FUNZER(FUNC,X2LOW,X2HIGH,XLOW,XHIGH)
C         FIND RANGE WHERE FUNC IS NON-ZERO.
C         WRITTEN 1980, F. JAMES
C         MODIFIED, NOV. 1985, TO FIX BUG AND GENERALIZE
C         TO FIND SIMPLY-CONNECTED NON-ZERO REGION (XLOW,XHIGH)
C         ANYWHERE WITHIN THE GIVEN REGION (X2LOW,H2HIGH).
C            WHERE 'ANYWHERE' MEANS EITHER AT THE LOWER OR UPPER
C            EDGE OF THE GIVEN REGION, OR, IF IN THE MIDDLE,
C            COVERING AT LEAST 1% OF THE GIVEN REGION.
C         OTHERWISE IT IS NOT GUARANTEED TO FIND THE NON-ZERO REGION.
C         IF FUNCTION EVERYWHERE ZERO, FUNZER SETS XLOW=XHIGH=0.
      EXTERNAL FUNC
      XLOW = X2LOW
      XHIGH = X2HIGH
C         FIND OUT IF FUNCTION IS ZERO AT ONE END OR BOTH
      XMID = XLOW
      IF (FUNC(XLOW) .GT. 0.) GO TO 120
      XMID = XHIGH
      IF (FUNC(XHIGH) .GT. 0.)  GO TO 50
C         FUNCTION IS ZERO AT BOTH ENDS,
C         LOOK FOR PLACE WHERE IT IS NON-ZERO.
      DO 30 LOGN= 1, 7
      NSLICE = 2**LOGN
      DO 20 I= 1, NSLICE, 2
      XMID = XLOW + I * (XHIGH-XLOW) / NSLICE
      IF (FUNC(XMID) .GT. 0.)  GO TO 50
   20 CONTINUE
   30 CONTINUE
C         FALLING THROUGH LOOP MEANS CANNOT FIND NON-ZERO VALUE
      WRITE(6,554)
      WRITE(6,555) XLOW, XHIGH
      XLOW = 0.
      XHIGH = 0.
      GO TO 220
C
   50 CONTINUE
C         DELETE 'LEADING' ZERO RANGE
      XH = XMID
      XL = XLOW
      DO 70 K= 1, 20
      XNEW = 0.5*(XH+XL)
      IF (FUNC(XNEW) .EQ. 0.) GO TO 68
      XH = XNEW
      GO TO 70
   68 XL = XNEW
   70 CONTINUE
      XLOW = XL
      WRITE(6,555) X2LOW,XLOW
  120 CONTINUE
      IF (FUNC(XHIGH) .GT. 0.) GO TO 220
C         DELETE 'TRAILING' RANGE OF ZEROES
      XL = XMID
      XH = XHIGH
      DO 170 K= 1, 20
      XNEW = 0.5*(XH+XL)
      IF (FUNC(XNEW) .EQ. 0.) GO TO 168
      XL = XNEW
      GO TO 170
  168 XH = XNEW
  170 CONTINUE
      XHIGH = XH
      WRITE(6,555) XHIGH, X2HIGH
C
  220 CONTINUE
      RETURN
  554 FORMAT('0CANNOT FIND NON-ZERO FUNCTION VALUE')
  555 FORMAT(' FUNCTION IS ZERO FROM X=',E12.5,' TO ',E12.5)
      END
+DECK,HISRAN.
      SUBROUTINE HISRAN(Y,N,XLO,XWID,XRAN)
*         SUBROUTINE TO GENERATE RANDOM NUMBERS
*         ACCORDING TO AN EMPIRICAL DISTRIBUTION
*         SUPPLIED BY THE USER IN THE FORM OF A HISTOGRAM
*         F. JAMES,    MAY, 1976
      DIMENSION Y(2)
      DATA IERR,NTRY,NXHRAN,NXHPRE/0,3HRAN,3HRAN,3HPRE/
      IF(Y(N).EQ.1.0) GOTO 40
      PRINT 1000, Y(N)
      NTRY=NXHRAN
      GOTO 10
*         INITIALIZE HISTOGRAM TO FORM CUMULATIVE DISTRIBUTION
      ENTRY HISPRE(Y,N)
      NTRY=NXHPRE
   10 CONTINUE
      YTOT = 0.
      DO 20 I= 1, N
         IF(Y(I).LT.0.) GOTO 70
         YTOT = YTOT + Y(I)
   20 Y(I) = YTOT
      IF(YTOT.LE.0.) GOTO 70
      YINV = 1.0/YTOT
      DO 30 I= 1, N
   30 Y(I) = Y(I) * YINV
      Y(N) = 1.0
      IF(NTRY.EQ.NXHPRE) RETURN
*         NOW GENERATE RANDOM NUMBER BETWEEN 0 AND ONE
   40 CONTINUE
*DRW  YR = RNDM(-1)
      CALL GRNDM(YR,1)
*DRW
*         AND TRANSFORM IT INTO THE CORRESPONDING X-VALUE
      L = LOCATF(Y,N,YR)
      IF(L.EQ.0) GOTO 50
      IF(L.GT.0) GOTO 60
*         USUALLY COME HERE.
      L = IABS(L)
      XRAN = XLO + XWID * (FLOAT(L) +((YR-Y(L))/(Y(L+1)-Y(L))))
      RETURN
*         POINT FALLS IN FIRST BIN.  SPECIAL CASE
   50 XRAN = XLO + XWID * (YR/Y(1))
      RETURN
*         GUARD AGAINST SPECIAL CASE OF FALLING ON EMPTY BIN
   60 XRAN = XLO + FLOAT(L) * XWID
      RETURN
   70 CONTINUE
      IERR = IERR + 1
      IF(IERR.LT.6) PRINT 1100,NTRY
      PRINT 1200, (Y(K),K=1,N)
      XRAN = 0.
      RETURN
 1000 FORMAT (
     +56H0SUBROUTINE HISRAN FINDS Y(N) NOT EQUAL TO 1.0     Y(N)=,E15.6/
     +105H ASSUMES USER HAS SUPPLIED HISTOGRAM RATHER THAN CUMULATIVE DI
     +STRIBUTION AND HAS FORGOTTEN TO CALL HISPRE/)
 1100 FORMAT(28H0ERROR IN INPUT DATA FOR HIS,A3,
     +28H    VALUES NOT ALL POSITIVE /)
 1200 FORMAT (1X,10F13.7)
      END
+DECK,POISSN.
      SUBROUTINE POISSN (AMU,N,IERROR)
*
*    POISSON GENERATOR
*    CODED FROM LOS ALAMOS REPORT      LA-5061-MS
*    PROB(N)=EXP(-AMU)*AMU**N/FACT(N)
*        WHERE FACT(N) STANDS FOR FACTORIAL OF N
*    ON RETURN IERROR.EQ.0 NORMALLY
*              IERROR.EQ.1 IF AMU.LE.0.
*
      DATA AMUOL/-12345.67/
*    AMAX IS THE VALUE ABOVE WHICH THE NORMAL DISTRIBUTION MUST BE USED
      DATA AMAX/100./
      IERROR= 0
      IF(AMU.GT.AMAX) GO TO 40
      IF(AMU.EQ.AMUOL) GO TO 20
      IF(AMU.GT.0.) GO TO 10
*    MEAN SHOULD BE POSITIVE
      IERROR=1
      N = 0
      RETURN
*    SAVE EXPONENTIAL FOR FURTHER IDENTICAL REQUESTS
   10 AMUOL=AMU
      EXPMA=EXP(-AMU)
   20 PIR=1.
      N=-1
   30 N=N+1
*DRW
      CALL GRNDM(RAN,1)
      PIR=PIR*RAN
*DRW  PIR=PIR*RNDM(N)
      IF(PIR.GT.EXPMA) GO TO 30
      RETURN
*   NORMAL APPROXIMATION FOR AMU.GT.AMAX
   40 CALL GRANOR(RAN,B)
      N=RAN*SQRT(AMU)+AMU+.5
      RETURN
*   ENTRY FOR USER TO SET AMAX, SWITCHOVER POINT TO NORMAL APPROXIMATION
      ENTRY POISET(AMU)
      PRINT 1000,AMU
      AMAX=AMU
      RETURN
 1000 FORMAT(77H POISSON RANDOM NUMBER GENERATOR TO SWITCH TO NORMAL APP
     +ROXIMATION ABOVE AMU= ,F12.2)
      END
+DECK,RANLANR,IF=-F4.
      FUNCTION RANLAN(X)
C
      DIMENSION F(-1:1002)
C
      DATA (F(I),I= -1,100)
     A/     7*0.,                                        -2.244733,
     B -2.204365,-2.168163,-2.135219,-2.104898,-2.076740,-2.050397,
     C -2.025605,-2.002150,-1.979866,-1.958612,-1.938275,-1.918760,
     D -1.899984,-1.881879,-1.864385,-1.847451,-1.831030,-1.815083,
     E -1.799574,-1.784473,-1.769751,-1.755383,-1.741346,-1.727620,
     F -1.714187,-1.701029,-1.688130,-1.675477,-1.663057,-1.650858,
     G -1.638868,-1.627078,-1.615477,-1.604058,-1.592811,-1.581729,
     H -1.570806,-1.560034,-1.549407,-1.538919,-1.528565,-1.518339,
     I -1.508237,-1.498254,-1.488386,-1.478628,-1.468976,-1.459428,
     J -1.449979,-1.440626,-1.431365,-1.422195,-1.413111,-1.404112,
     K -1.395194,-1.386356,-1.377594,-1.368906,-1.360291,-1.351746,
     L -1.343269,-1.334859,-1.326512,-1.318229,-1.310006,-1.301843,
     M -1.293737,-1.285688,-1.277693,-1.269752,-1.261863,-1.254024,
     N -1.246235,-1.238494,-1.230800,-1.223153,-1.215550,-1.207990,
     O -1.200474,-1.192999,-1.185566,-1.178172,-1.170817,-1.163500,
     P -1.156220,-1.148977,-1.141770,-1.134598,-1.127459,-1.120354,
     Q -1.113282,-1.106242,-1.099233,-1.092255/
C
      DATA (F(I),I=101,200)
     A/-1.085306,-1.078388,-1.071498,-1.064636,-1.057802,-1.050996,
     B -1.044215,-1.037461,-1.030733,-1.024029,-1.017350,-1.010695,
     C -1.004064, -.997456, -.990871, -.984308, -.977767, -.971247,
     D  -.964749, -.958271, -.951813, -.945375, -.938957, -.932558,
     E  -.926178, -.919816, -.913472, -.907146, -.900838, -.894547,
     F  -.888272, -.882014, -.875773, -.869547, -.863337, -.857142,
     G  -.850963, -.844798, -.838648, -.832512, -.826390, -.820282,
     H  -.814187, -.808106, -.802038, -.795982, -.789940, -.783909,
     I  -.777891, -.771884, -.765889, -.759906, -.753934, -.747973,
     J  -.742023, -.736084, -.730155, -.724237, -.718328, -.712429,
     K  -.706541, -.700661, -.694791, -.688931, -.683079, -.677236,
     L  -.671402, -.665576, -.659759, -.653950, -.648149, -.642356,
     M  -.636570, -.630793, -.625022, -.619259, -.613503, -.607754,
     N  -.602012, -.596276, -.590548, -.584825, -.579109, -.573399,
     O  -.567695, -.561997, -.556305, -.550618, -.544937, -.539262,
     P  -.533592, -.527926, -.522266, -.516611, -.510961, -.505315,
     Q  -.499674, -.494037, -.488405, -.482777/
C
      DATA (F(I),I=201,300)
     A/ -.477153, -.471533, -.465917, -.460305, -.454697, -.449092,
     B  -.443491, -.437893, -.432299, -.426707, -.421119, -.415534,
     C  -.409951, -.404372, -.398795, -.393221, -.387649, -.382080,
     D  -.376513, -.370949, -.365387, -.359826, -.354268, -.348712,
     E  -.343157, -.337604, -.332053, -.326503, -.320955, -.315408,
     F  -.309863, -.304318, -.298775, -.293233, -.287692, -.282152,
     G  -.276613, -.271074, -.265536, -.259999, -.254462, -.248926,
     H  -.243389, -.237854, -.232318, -.226783, -.221247, -.215712,
     I  -.210176, -.204641, -.199105, -.193568, -.188032, -.182495,
     J  -.176957, -.171419, -.165880, -.160341, -.154800, -.149259,
     K  -.143717, -.138173, -.132629, -.127083, -.121537, -.115989,
     L  -.110439, -.104889, -.099336, -.093782, -.088227, -.082670,
     M  -.077111, -.071550, -.065987, -.060423, -.054856, -.049288,
     N  -.043717, -.038144, -.032569, -.026991, -.021411, -.015828,
     O  -.010243, -.004656,  .000934,  .006527,  .012123,  .017722,
     P   .023323,  .028928,  .034535,  .040146,  .045759,  .051376,
     Q   .056997,  .062620,  .068247,  .073877/
C
      DATA (F(I),I=301,400)
     A/  .079511,  .085149,  .090790,  .096435,  .102083,  .107736,
     B   .113392,  .119052,  .124716,  .130385,  .136057,  .141734,
     C   .147414,  .153100,  .158789,  .164483,  .170181,  .175884,
     D   .181592,  .187304,  .193021,  .198743,  .204469,  .210201,
     E   .215937,  .221678,  .227425,  .233177,  .238933,  .244696,
     F   .250463,  .256236,  .262014,  .267798,  .273587,  .279382,
     G   .285183,  .290989,  .296801,  .302619,  .308443,  .314273,
     H   .320109,  .325951,  .331799,  .337654,  .343515,  .349382,
     I   .355255,  .361135,  .367022,  .372915,  .378815,  .384721,
     J   .390634,  .396554,  .402481,  .408415,  .414356,  .420304,
     K   .426260,  .432222,  .438192,  .444169,  .450153,  .456145,
     L   .462144,  .468151,  .474166,  .480188,  .486218,  .492256,
     M   .498302,  .504356,  .510418,  .516488,  .522566,  .528653,
     N   .534747,  .540850,  .546962,  .553082,  .559210,  .565347,
     O   .571493,  .577648,  .583811,  .589983,  .596164,  .602355,
     P   .608554,  .614762,  .620980,  .627207,  .633444,  .639689,
     Q   .645945,  .652210,  .658484,  .664768/
C
      DATA (F(I),I=401,500)
     A/  .671062,  .677366,  .683680,  .690004,  .696338,  .702682,
     B   .709036,  .715400,  .721775,  .728160,  .734556,  .740963,
     C   .747379,  .753807,  .760246,  .766695,  .773155,  .779627,
     D   .786109,  .792603,  .799107,  .805624,  .812151,  .818690,
     E   .825241,  .831803,  .838377,  .844962,  .851560,  .858170,
     F   .864791,  .871425,  .878071,  .884729,  .891399,  .898082,
     G   .904778,  .911486,  .918206,  .924940,  .931686,  .938446,
     H   .945218,  .952003,  .958802,  .965614,  .972439,  .979278,
     I   .986130,  .992996,  .999875, 1.006769, 1.013676, 1.020597,
     J  1.027533, 1.034482, 1.041446, 1.048424, 1.055417, 1.062424,
     K  1.069446, 1.076482, 1.083534, 1.090600, 1.097681, 1.104778,
     L  1.111889, 1.119016, 1.126159, 1.133316, 1.140490, 1.147679,
     M  1.154884, 1.162105, 1.169342, 1.176595, 1.183864, 1.191149,
     N  1.198451, 1.205770, 1.213105, 1.220457, 1.227826, 1.235211,
     O  1.242614, 1.250034, 1.257471, 1.264926, 1.272398, 1.279888,
     P  1.287395, 1.294921, 1.302464, 1.310026, 1.317605, 1.325203,
     Q  1.332819, 1.340454, 1.348108, 1.355780/
C
      DATA (F(I),I=501,600)
     A/ 1.363472, 1.371182, 1.378912, 1.386660, 1.394429, 1.402216,
     B  1.410024, 1.417851, 1.425698, 1.433565, 1.441453, 1.449360,
     C  1.457288, 1.465237, 1.473206, 1.481196, 1.489208, 1.497240,
     D  1.505293, 1.513368, 1.521465, 1.529583, 1.537723, 1.545885,
     E  1.554068, 1.562275, 1.570503, 1.578754, 1.587028, 1.595325,
     F  1.603644, 1.611987, 1.620353, 1.628743, 1.637156, 1.645593,
     G  1.654053, 1.662538, 1.671047, 1.679581, 1.688139, 1.696721,
     H  1.705329, 1.713961, 1.722619, 1.731303, 1.740011, 1.748746,
     I  1.757506, 1.766293, 1.775106, 1.783945, 1.792810, 1.801703,
     J  1.810623, 1.819569, 1.828543, 1.837545, 1.846574, 1.855631,
     K  1.864717, 1.873830, 1.882972, 1.892143, 1.901343, 1.910572,
     L  1.919830, 1.929117, 1.938434, 1.947781, 1.957158, 1.966566,
     M  1.976004, 1.985473, 1.994972, 2.004503, 2.014065, 2.023659,
     N  2.033285, 2.042943, 2.052633, 2.062355, 2.072110, 2.081899,
     O  2.091720, 2.101575, 2.111464, 2.121386, 2.131343, 2.141334,
     P  2.151360, 2.161421, 2.171517, 2.181648, 2.191815, 2.202018,
     Q  2.212257, 2.222533, 2.232845, 2.243195/
C
      DATA (F(I),I=601,700)
     A/ 2.253582, 2.264006, 2.274468, 2.284968, 2.295507, 2.306084,
     B  2.316701, 2.327356, 2.338051, 2.348786, 2.359562, 2.370377,
     C  2.381234, 2.392131, 2.403070, 2.414051, 2.425073, 2.436138,
     D  2.447246, 2.458397, 2.469591, 2.480828, 2.492110, 2.503436,
     E  2.514807, 2.526222, 2.537684, 2.549190, 2.560743, 2.572343,
     F  2.583989, 2.595682, 2.607423, 2.619212, 2.631050, 2.642936,
     G  2.654871, 2.666855, 2.678890, 2.690975, 2.703110, 2.715297,
     H  2.727535, 2.739825, 2.752168, 2.764563, 2.777012, 2.789514,
     I  2.802070, 2.814681, 2.827347, 2.840069, 2.852846, 2.865680,
     J  2.878570, 2.891518, 2.904524, 2.917588, 2.930712, 2.943894,
     K  2.957136, 2.970439, 2.983802, 2.997227, 3.010714, 3.024263,
     L  3.037875, 3.051551, 3.065290, 3.079095, 3.092965, 3.106900,
     M  3.120902, 3.134971, 3.149107, 3.163312, 3.177585, 3.191928,
     N  3.206340, 3.220824, 3.235378, 3.250005, 3.264704, 3.279477,
     O  3.294323, 3.309244, 3.324240, 3.339312, 3.354461, 3.369687,
     P  3.384992, 3.400375, 3.415838, 3.431381, 3.447005, 3.462711,
     Q  3.478500, 3.494372, 3.510328, 3.526370/
C
      DATA (F(I),I=701,800)
     A/ 3.542497, 3.558711, 3.575012, 3.591402, 3.607881, 3.624450,
     B  3.641111, 3.657863, 3.674708, 3.691646, 3.708680, 3.725809,
     C  3.743034, 3.760357, 3.777779, 3.795300, 3.812921, 3.830645,
     D  3.848470, 3.866400, 3.884434, 3.902574, 3.920821, 3.939176,
     E  3.957640, 3.976215, 3.994901, 4.013699, 4.032612, 4.051639,
     F  4.070783, 4.090045, 4.109425, 4.128925, 4.148547, 4.168292,
     G  4.188160, 4.208154, 4.228275, 4.248524, 4.268903, 4.289413,
     H  4.310056, 4.330832, 4.351745, 4.372794, 4.393982, 4.415310,
     I  4.436781, 4.458395, 4.480154, 4.502060, 4.524114, 4.546319,
     J  4.568676, 4.591187, 4.613854, 4.636678, 4.659662, 4.682807,
     K  4.706116, 4.729590, 4.753231, 4.777041, 4.801024, 4.825179,
     L  4.849511, 4.874020, 4.898710, 4.923582, 4.948639, 4.973883,
     M  4.999316, 5.024942, 5.050761, 5.076778, 5.102993, 5.129411,
     N  5.156034, 5.182864, 5.209903, 5.237156, 5.264625, 5.292312,
     O  5.320220, 5.348354, 5.376714, 5.405306, 5.434131, 5.463193,
     P  5.492496, 5.522042, 5.551836, 5.581880, 5.612178, 5.642734,
     Q  5.673552, 5.704634, 5.735986, 5.767610/
C
      DATA (F(I),I=801,900)
     A/ 5.799512, 5.831694, 5.864161, 5.896918, 5.929968, 5.963316,
     B  5.996967, 6.030925, 6.065194, 6.099780, 6.134687, 6.169921,
     C  6.205486, 6.241387, 6.277630, 6.314220, 6.351163, 6.388465,
     D  6.426130, 6.464166, 6.502578, 6.541371, 6.580553, 6.620130,
     E  6.660109, 6.700495, 6.741297, 6.782520, 6.824173, 6.866262,
     F  6.908795, 6.951780, 6.995225, 7.039137, 7.083525, 7.128398,
     G  7.173764, 7.219632, 7.266011, 7.312910, 7.360339, 7.408308,
     H  7.456827, 7.505905, 7.555554, 7.605785, 7.656608, 7.708035,
     I  7.760077, 7.812747, 7.866057, 7.920019, 7.974647, 8.029953,
     J  8.085952, 8.142657, 8.200083, 8.258245, 8.317158, 8.376837,
     K  8.437300, 8.498562, 8.560641, 8.623554, 8.687319, 8.751955,
     L  8.817481, 8.883916, 8.951282, 9.019600, 9.088889, 9.159174,
     M  9.230477, 9.302822, 9.376233, 9.450735, 9.526355, 9.603118,
     N  9.681054, 9.760191, 9.840558, 9.922186,10.005107,10.089353,
     O 10.174959,10.261958,10.350389,10.440287,10.531693,10.624646,
     P 10.719188,10.815362,10.913214,11.012789,11.114137,11.217307,
     Q 11.322352,11.429325,11.538283,11.649285/
C
      DATA (F(I),I=901,1002)
     A/11.762390,11.877664,11.995170,12.114979,12.237161,12.361791,
     B 12.488946,12.618708,12.751161,12.886394,13.024498,13.165570,
     C 13.309711,13.457026,13.607625,13.761625,13.919145,14.080314,
     D 14.245263,14.414134,14.587072,14.764233,14.945778,15.131877,
     E 15.322712,15.518470,15.719353,15.925570,16.137345,16.354912,
     F 16.578520,16.808433,17.044929,17.288305,17.538873,17.796967,
     G 18.062943,18.337176,18.620068,18.912049,19.213574,19.525133,
     H 19.847249,20.180480,20.525429,20.882738,21.253102,21.637266,
     I 22.036036,22.450278,22.880933,23.329017,23.795634,24.281981,
     J 24.789364,25.319207,25.873062,26.452634,27.059789,27.696581,
     K 28.365274,29.068370,29.808638,30.589157,31.413354,32.285060,
     L 33.208568,34.188705,35.230920,36.341388,37.527131,38.796172,
     M 40.157721,41.622399,43.202525,44.912465,46.769077,48.792279,
     N 51.005773,53.437996,56.123356,59.103894,              20*0./
C
      U=1000.0*X
      I=U
      U=U-I
      RANLAN=F(I)+U*(F(I+1)-F(I))
      IF(I .GE. 70 .AND. I .LE. 800) RETURN
      RANLAN=RANLAN-0.25*U*(1.0-U)*(F(I+2)-F(I+1)-F(I)+F(I-1))
      IF(I .GE.  7 .AND. I .LE. 980) RETURN
      IF(I. LT. 7) THEN
       V=LOG(X)
       U=1.0/V
       RANLAN=((0.99858950+(3.45213058E1+1.70854528E1*U)*U)/
     1         (1.0       +(3.41760202E1+4.01244582  *U)*U))*
     2         (-LOG(-0.91893853-V)-1.0)
      ELSE
       U=1.0-X
       V=U**2
       IF(X .LE. 0.999) THEN
        RANLAN=(1.00060006+2.63991156E2*U+4.37320068E3*V)/
     1        ((1.0       +2.57368075E2*U+3.41448018E3*V)*U)
       ELSE
        RANLAN=(1.00001538+6.07514119E3*U+7.34266409E5*V)/
     1        ((1.0       +6.06511919E3*U+6.94021044E5*V)*U)
       END IF
      END IF
      RETURN
      END
+PATCH,OPALLEGO.
+DECK,INFO,IF=NEVER.
C LE101   2.01/01   960412  17:00  OPALLEGO PAMFILE
C HISTORY DETAILS
C
C 12 Apr 1996
C N.K.Watson    Added a FINEPHI option, to allow a fine scan of 1024 bins
C               in phi (work done sometime in 1993), added SW to list of
C               calorimeters (treated as an ecal in forward region).
C               Decks modified: USLAST, USINIT, GUSTEP.
C               Updated kumacs.
C
C 16 Oct 1990
C Code imported from Nigel Watson (last used on CERNVM circa July 1989).
C Modified for GOPAL123 and GEANT313 by Richard Hemingway and tested
C          with both NORMAL and FINECTH options.
C
C Patchy Select option. Choose ONLY one of the following:
C         NORMAL gets you original 40 cos(theta) * 40 phi bins.
C         FINECTH gets a fine scan in cos(theta) 1024 bins.
C         FINEPHI gets a fine scan in phi        1024 bins.
C         DISTRIB gets a distribution of material in specified direction.
C
+DECK,KIUSER.
      SUBROUTINE KIUSER
*.
*...KIUSER  Single particle generator.
*.
*. COMMON    : GCKINE GCONST GCFLAG
*. CALLS     : GSKINE GSVERT GRNDM
*. CALLED    : GUKINE
*. BANKS L   : VERT,TRAK
*.
*. AUTHOR    : P.Hinde.
*. VERSION   : 2.00
*. CREATED   : 26-Aug-87
*. LAST MOD  : 13-Apr-88
*.
*. Modification log.
*. 25-May-89   John Allison    Change to PDG particle codes.
*. 13-Apr-88   John Allison    Add possibility
*.                             of partial and multiple cycles.
*.
*.-----------------------------------------------------------------
 
*--  Takes theta and phi in degrees and generates in bin(s) equally spaced
*--  in cos(theta) and phi.
*--
*--  IKINE,PKINE specified by FFREAD card KINE :-
*--              IKINE    - 4 to call this routine
*--              PKINE(1) - momentum (GeV/c)          (default 10 GeV/c)
*--                       - or 2 limits of mometum (see PKINE(9))
*--                       - given as PMIN+10000*PMAX
*--              PKINE(2) - particle type             (default 5, mu+)
*--                       - < 0, random selection of |N| and |N+1|
*--                       - (e.g. if N=-5 it generates mu+, mu-)
*--                       - where N is value given
*--              PKINE(3) - number of bins in theta   (default 1)
*--              PKINE(4) - starting theta (degrees)  (default 0.)
*--              PKINE(5) - finishing theta (degrees) (default 180.)
*--              PKINE(6) - number of bins in phi     (default 1)
*--              PKINE(7) - starting phi (degrees)    (default 0.)
*--              PKINE(8) - finishing phi (degrees)   (default 360.)
*--              PKINE(9) - S+10000*T
*--                       - where T is the momentum distribution type:
*--                       -   0) single momentum given by PKINE(1)[DEF]
*--                       -   1) flat momentum distribution between
*--                       -      2 values given in PKINE(1)
*--                       - and S is:
*--                       -   0 for random generation within bin [DEF]
*--                       -   1 for generation at centre of bin.
*--              PKINE(10)- NT+90000*NP where NT and NP are
*--                       - the starting bin numbers in theta and phi
*--                       - default to first bins. (0)
*--  E.g., to generate 10 GeV/c pi+ uniformly over 4 pi:
*--        KINE 4 10. 8.
*--      (Don't forget the decimal points, since, as far as FFREAD is
*--       concerned, the parameters are real.)
*--
+SEQ,DECLARE. 
+SEQ,ROBANK.
+SEQ,ROPAR.
+SEQ,GCKINE
+SEQ,GCONST
+SEQ,GCFLAG
+SEQ,GCUNIT.
      CHARACTER*20 CHPART
      LOGICAL     FIRST
      REAL        VERTEX (3), PLAB (3), BUF (2)
      EQUIVALENCE (BUF (1), THETA), (BUF (2), PHI)
      INTEGER     ITYPE, IGP, ILTYPE,  NTHCH, NPHICH, ICHOI, IPDIS
      REAL        PMAX, PMIN, P, CTHMIN, CTHMAX, PHIMIN, PHIMAX
*     Bin counters.
      INTEGER     INCT,          INCP
*     Conversion table between LUND particle codes and GEANT.
      INTEGER ISEL(41), JSEL(41), NSEL
*     Other variables.
      INTEGER NTR, NPP, LTREE, IOTREE, LENT, LGENE, IJK, IUCOMP, NWB
      REAL CHPHI, CHTH, CTHETA, PHI, RNDM, SINT, THETA ,UB(10)
*     Data statements.
      DATA        FIRST /.TRUE./
      DATA        VERTEX /3*0./, NTR    /1/
      DATA        PMAX/10./,     ITYPE  /5/,
     +            NTHCH  /1/,    NPHICH /1/,
     +            CTHMIN /-1./,  CTHMAX /1./
     +            PHIMIN /0./,   PHIMAX /360./,
     +            ICHOI  /0/,    IPDIS  /0/
      DATA        INCT   /0/,    INCP   /0/
*   Conversion table between PDG particle codes and GEANT.
      DATA NSEL/41/
      DATA ISEL/ 22,-11, 11, 12,-12,-13, 13, 14,-14, 16,-16, 211,-211,
     + 321,-321, 310, 130,2212,-2212,2112,-2112,3222,-3222,3112,-3112,
     + 3322,-3322,3312,-3312,3122,-3122,3334,-3334, 15,-15,3212,-3212,
     + 221,-221,111,-111/
      DATA JSEL/ 1, 2, 3, 4, 4, 5, 6, 4, 4, 4, 4, 8, 9, 11, 12, 16, 10,
     +14, 15, 13, 25, 19, 27, 21, 29, 22, 30, 23, 31, 18, 26, 24, 32,
     +34, 33, 20, 28, 17, 17, 7, 7/
      IF (FIRST) THEN
        FIRST = .FALSE.
        IF (PKINE(1) .NE. BIG) THEN
         IF(PKINE(1) .LT. 10000.) THEN
          PMAX   = PKINE (1)
         ELSE
          PMIN   = MOD (PKINE (1) , 10000.)
          PMAX   = (PKINE (1) - PMIN) / 10000.
         END IF
        END IF
        IF (PKINE(2) .NE. BIG) ITYPE  = INT (PKINE (2))
        IF (PKINE(3) .NE. BIG) NTHCH  = INT (PKINE (3))
        IF (PKINE(4) .NE. BIG) CTHMIN = COS (PKINE (5) * DEGRAD)
        IF (PKINE(5) .NE. BIG) CTHMAX = COS (PKINE (4) * DEGRAD)
        IF (PKINE(6) .NE. BIG) NPHICH = INT (PKINE (6))
        IF (PKINE(7) .NE. BIG) PHIMIN = PKINE (7) * DEGRAD
        IF (PKINE(8) .NE. BIG) PHIMAX = PKINE (8) * DEGRAD
        IF (PKINE(9) .NE. BIG) THEN
          IPDIS  = INT (PKINE (9) / 10000.)
          ICHOI  = INT (MOD (PKINE (9) , 10000.))
        END IF
        IF (PKINE(10).NE. BIG) THEN
          INCP  = INT (PKINE (10) / 10000.)
          INCT  = INT (MOD (PKINE (10) , 10000.))
        END IF
*-- Create space for 2 tracks in case it interacts later.
        NPP = 2
*       Calculate width of bins in cos(theta) and phi
        CHPHI= (PHIMAX - PHIMIN)  / FLOAT(NPHICH)
        CHTH = (CTHMAX - CTHMIN)  / FLOAT(NTHCH)
      END IF
*-- Creates generated particle banks.
        LGENE = LQ(LMC-1)
        LENT = IQ(LGENE+5)
        IOTREE = IQ(LGENE+7)
        CALL MZBOOK (IXDIV,LTREE,LGENE,-1,'TREE',0,0,NPP*LENT,IOTREE,0)
        IQ(LGENE+1) = 1
        IQ(LGENE+2) = 1
*     Calculate in centre of bin or randomly in the bin
      IF (ICHOI .EQ. 1) THEN
        CTHETA = CTHMIN + INCT * CHTH  + CHTH/2.
        PHI    = PHIMIN + INCP * CHPHI + CHPHI/2.
      ELSE
        CALL GRNDM(RNDM,1)
        CTHETA = CTHMIN + ( INCT + RNDM ) * CHTH
        CALL GRNDM(RNDM,1)
        PHI    = PHIMIN + ( INCP + RNDM ) * CHPHI
      END IF
*     Increment INCP and INCT cyclically.
      INCP = INCP + 1
      IF (INCP .EQ. NPHICH) THEN
        INCP = 0
        INCT = INCT + 1
      END IF
      IF (INCT .EQ. NTHCH) THEN
        INCT = 0
      END IF
*     calculate a momentum for the particle
      IF (IPDIS .EQ. 0) THEN
       P = PMAX
      ELSE
       CALL GRNDM(RNDM,1)
       P = (PMAX - PMIN) * RNDM + PMIN
      END IF
      SINT     = SQRT (1. - CTHETA * CTHETA)
      PLAB (1) = P * COS(PHI) * SINT
      PLAB (2) = P * SIN(PHI) * SINT
      PLAB (3) = P * CTHETA
*     Determine particle type to save
      IF (ITYPE .LT. 0) THEN
       CALL GRNDM(RNDM,1)
       IF (RNDM .LT. 0.5) THEN
        IGP = ABS (ITYPE)
       ELSE
        IGP = ABS (ITYPE) + 1
       END IF
      ELSE
       IGP = ITYPE
      END IF
*     Save track kinematics
*-- Convert from GEANT particle code to LUND.
*
      IJK    = IUCOMP (IGP,JSEL,NSEL)
      IF (IJK.EQ.0) THEN
         WRITE (CHMAIL,1000) IGP
         CALL GMAIL(0,0)
         ILTYPE = 99
      ELSE
         ILTYPE = ISEL(IJK)
      ENDIF
*
*-- Find out what the charge and mass are.
*
      CALL GFPART (IGP,CHPART,ITRTYP,AMASS,CHARGE,TLIFE,UB,NWB)
*
*-- Fill the particle tree entries.
*
      IQ(LTREE+1) = ILTYPE
      IQ(LTREE+9) = 1
      IF (CHARGE.NE.0) IQ(LTREE+10) = 1
      Q(LTREE+10+1) = PLAB(1)
      Q(LTREE+10+2) = PLAB(2)
      Q(LTREE+10+3) = PLAB(3)
      Q(LTREE+10+4) = SQRT(PLAB(1)**2+PLAB(2)**2+PLAB(3)**2+ AMASS**2)
      Q(LTREE+10+5) = AMASS
      Q(LTREE+10+6) = CHARGE
      Q(LTREE+10+7) = VERTEX(1)
      Q(LTREE+10+8) = VERTEX(2)
      Q(LTREE+10+9) = VERTEX(3)
*     write out bin numbers if 3rd debug parameter is 3
      IF (ITEST .NE. 0) THEN
       WRITE(CHMAIL,'('' BIN NUMBERS : '',I5,1X,I5)') INCT,INCP
       CALL GMAIL(0,0)
      END IF
      RETURN
 1000 FORMAT ('Particle type',I5,' not known')
      END
+DECK,USINIT.
      SUBROUTINE USINIT
+SELF,IF=NORMAL.
      NT=40
      NP=40
      CALL HBOOK2 (100,
     +             'Number of entries for RADIATION lengths',
     +             NT , 0.0, 1.0, NP, 0.0, 90., 0.)
      CALL HBPRO  (100, 0.)
      CALL HBANDY (100,  0., .68, 0.)
      CALL HBANDY (100, .68, .72, 0.)
      CALL HBANDY (100, .72, .84, 0.)
      CALL HBANDY (100, .84,  1., 0.)
      CALL HCOPY  (100, 101,
     +             'Total number of RADIATION lengths')
      CALL HCOPY  (100, 102,
     +             'No. of RAD. lengths BEFORE EM. Cal.')
      CALL HCOPY  (100, 103,
     +             'No. of RAD. lengths to END of EM. Cal.')
      CALL HBOOK2 (200,
     +             'No. of entries for ABSORPTION lengths',
     +             NT , 0.0, 1.0, NP, 0.0, 90., 0.)
      CALL HBPRO  (200, 0.)
      CALL HBANDX (200,  0., 74., 0.)
      CALL HBANDX (200, 74., 90., 0.)
      CALL HBANDY (200,  0., .74, 0.)
      CALL HBANDY (200, .74, .82, 0.)
      CALL HBANDY (200, .82, .88, 0.)
      CALL HBANDY (200, .88, .98, 0.)
      CALL HCOPY  (200, 201,
     +             'Total no. of ABS. lengths')
      CALL HCOPY  (200, 202,
     +             'No. of ABS. lengths BEFORE EM. Cal.')
      CALL HCOPY  (200, 203,
     +             'No. of ABS. lengths to END of EM. Cal.')
      CALL HCOPY  (200, 204,
     +             'No. of ABS. lengths BEFORE Had Cal. pad')
      CALL HCOPY  (200, 205,
     +             'No. of ABS. lengths to LAST Had. Cal. pad')
+SELF,IF=FINECTH.
      CALL HBOOK1 (100,
     +             'Number of entries for RADIATION lengths',
     +             1024, 0.0, 1.0, 0.)
      CALL HCOPY  (100, 101,
     +             'Total number of RADIATION lengths')
      CALL HCOPY  (100, 102,
     +             'No. of RAD. lengths BEFORE EM. Cal.')
      CALL HCOPY  (100, 103,
     +             'No. of RAD. lengths to END of EM. Cal.')
      CALL HBOOK1 (200,
     +             'No. of entries for ABSORPTION lengths',
     +             1024, 0.0, 1.0, 0.)
      CALL HCOPY  (200, 201,
     +             'Total no. of ABS. lengths')
      CALL HCOPY  (200, 202,
     +             'No. of ABS. lengths BEFORE EM. Cal.')
      CALL HCOPY  (200, 203,
     +             'No. of ABS. lengths to END of EM. Cal.')
      CALL HCOPY  (200, 204,
     +             'No. of ABS. lengths BEFORE Had Cal. pad')
      CALL HCOPY  (200, 205,
     +             'No. of ABS. lengths to LAST Had. Cal. pad')
+SELF,IF=FINEPHI.
      CALL HBOOK1 (100,
     +             'Number of entries for RADIATION lengths',
     +             1024, 0.0, 360., 0.)
      CALL HCOPY  (100, 101,
     +             'Total number of RADIATION lengths')
      CALL HCOPY  (100, 102,
     +             'No. of RAD. lengths BEFORE EM. Cal.')
      CALL HCOPY  (100, 103,
     +             'No. of RAD. lengths to END of EM. Cal.')
      CALL HBOOK1 (200,
     +             'No. of entries for ABSORPTION lengths',
     +             1024, 0.0, 360., 0.)
      CALL HCOPY  (200, 201,
     +             'Total no. of ABS. lengths')
      CALL HCOPY  (200, 202,
     +             'No. of ABS. lengths BEFORE EM. Cal.')
      CALL HCOPY  (200, 203,
     +             'No. of ABS. lengths to END of EM. Cal.')
      CALL HCOPY  (200, 204,
     +             'No. of ABS. lengths BEFORE Had Cal. pad')
      CALL HCOPY  (200, 205,
     +             'No. of ABS. lengths to LAST Had. Cal. pad')
+SELF,IF=DISTRIB.
      CALL HBOOK1 (1, 'Distribution of RADIATION lengths',
     +             320, 0., 320., 0.)
      CALL HBOOK1 (2, 'Distribution of ABSORPTION lengths',
     +             500, 0., 500., 0.)
+SELF.
C
      RETURN
      END
+DECK,USLAST.
      SUBROUTINE USLAST
+SELF,IF=DISTRIB.
      PARAMETER (NXRMAX = 1000)
      COMMON/XR/XRADSM(NXRMAX),XABSSM(NXRMAX)
+SELF.
      INTEGER LHROUT, ICYCLE
      CHARACTER*8 CHDIR
      DIMENSION ID0(8), ID1(8)
      DATA ID0 /3 * 100, 5 * 200/
      DATA ID1 /101, 102, 103,
     *          201, 202, 203, 204, 205/
      DATA NID /8/
+SELF,IF=NORMAL.
      DO 10, I = 1, NID
        CALL HOPERA (ID1(I), '/', ID0(I), ID1(I), 1., 1.)
 10   CONTINUE
      CALL HSCALE (0, 0.)
      CHDIR = 'NORMAL'
+SELF,IF=FINECTH
      DO 20, I = 1, NID
        CALL HOPERA (ID1(I), '/', ID0(I), ID1(I), 1., 1.)
 20   CONTINUE
      CALL HSCALE (0, 0.)
      CHDIR = 'FINECTH'
+SELF,IF=FINEPHI
      DO 20, I = 1, NID
        CALL HOPERA (ID1(I), '/', ID0(I), ID1(I), 1., 1.)
 20   CONTINUE
      CALL HSCALE (0, 0.)
      CHDIR = 'FINECTH'
+SELF,IF=DISTRIB.
      CHDIR = 'DISTRIB'
      CALL HPAK(1,XRADSM(1))
      CALL HPAK(2,XABSSM(1))
+SELF.
*drw      CALL HRPUT(0,'OPALLEGO RZ','T')
      CALL HINDEX
      RETURN
      END
+DECK,GUSTEP.
      SUBROUTINE GUSTEP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each tracking step     *
C.    *       INWVOL =1 when track enters into a new volume            *
C.    *              =2 when track leaves the current volume           *
C.    *       ISTOP is different from 0 if the track has stopped       *
C.    *       In case of a sensible volume (flag IDTYPE in /GCSETS/ )  *
C.    *       the current point is in array VECT (common GCTRAK)       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,DECLARE.
+SEQ,GCBANK
+SEQ,GCSETS
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCTRAK
+SEQ,GCMATE
+SEQ,GCVOLU
+SEQ,GCLIST
+SEQ,GCONST
CSEQ,GCHADR
+SELF,IF=DISTRIB.
      PARAMETER (NXRMAX = 1000)
      COMMON/XR/XRADSM(NXRMAX),XABSSM(NXRMAX)
+SELF.
C
      CHARACTER*4  IEB,IEE,IHB,IHE,IHP,IFD,ISW
      CHARACTER*4  CUSET
      REAL      SRAD,SABS,TSTEPJ,ASTEPJ,DASTEP
C
      INTEGER      LKUSER,LKINE,LMATE,LPROB,LMIXT,LMI1
      REAL         AEFF,TKVAR1,TKVAR2,XRAD,SIG,ABSLEN,XABS,GHSIGM
      REAL         RADL1,ABSL1,X1,X
      EXTERNAL     GHSIGM
      EXTERNAL     UHTOC,GPCXYZ,GDCXYZ
C
      DIMENSION SRAD(3), SABS(5)
      LOGICAL INECAL, INHCAL
C
      DATA SRAD /3 * 0./, SABS /5 * 0./
+SELF,IF=DISTRIB.
      DATA TSTEPJ /0./
      DATA ASTEPJ /0./
      DATA DASTEP /1./
      DATA IMOLD /0/
      DATA XTOT /0./
+SELF.
C SRAD(I), SABS(I) are radiation lengths and absorption lengths for
C      I = 1     total
C      I = 2     before em calorimeter
C      I = 3     after   "     "
C      I = 4     before 1st had cal pad
C      I = 5     before last had cal pad
      DATA IEB /'EB  '/, IEE /'EE  '/
      DATA IHB /'HB  '/, IHE /'HE  '/, IHP /'HP  '/
      DATA IFD /'F   '/
      DATA ISW /'SW  '/
C.
C.    ------------------------------------------------------------------
C.
C            Get track variables.
C
*      LKINE = LQ(JKINE - 1)
*      LKUSER= LQ(LKINE - 1)
*      TKVAR1 = Q(LKUSER + 1)  (Not stored in the new version of KIUSER.)
*      TKVAR2 = Q(LKUSER + 2)
      TKVAR1 = VECT (6)
      TKVAR2 = RADDEG * ATAN2 (VECT (5), VECT (4))
      IF (TKVAR2 .LT. 0.) TKVAR2 = TKVAR2 + 360.
C
C            Calculate no. of radiation lengths this step.
C
      IF ( RADL .GT. 1.E-6) THEN
        XRAD = STEP / RADL
      ELSE
        XRAD = 0.
      ENDIF
C
C            Calculate no. of absorption lengths this step.
C              (for a 5 GeV/c proton)
C
      LMATE = LQ(JMATE-NMAT)
      LPROB = LQ(LMATE- 4)
      LMIXT = LQ(LMATE- 5)
C
      IF (LMIXT .GT. 0) THEN
        LMI1 = LQ(LMIXT- 1)
        AEFF =  Q(LMI1 + 1)
      ELSE
        AEFF = A
      ENDIF
      SIG = GHSIGM (5., 14, AEFF)
      IF (SIG .GT. 1.E-6) THEN
        ABSLEN =  Q(LPROB + 8) / SIG
        XABS = STEP / ABSLEN
      ELSE
        ABSLEN = 1.E10
        XABS = 0.
      ENDIF
C
C           Accumulate.
C
      SRAD (1) = SRAD (1) + XRAD
      SABS (1) = SABS (1) + XABS
+SELF,IF=DISTRIB.
*  New code to accumulate the radiation length for each bin.
*  G.W.W.   15/4/88.
* Extended by John Allison to absorption lenghts, 8/8/88.
      TSTART = TSTEPJ
      TEND   = TSTEPJ + STEP
      ISTART = 1 + INT(TSTEPJ)
      IEND = 1 + INT(TSTEPJ+STEP)
      DO 30 I=ISTART,IEND
         IF(ISTART.EQ.IEND)THEN
            XRADSM(I) = XRADSM(I) + XRAD
            XABSSM(I) = XABSSM(I) + XABS
         ELSEIF(I.EQ.ISTART)THEN
            XRADSM(I) = XRADSM(I) + (FLOAT(ISTART)-TSTART)/RADL
            XABSSM(I) = XABSSM(I) + (FLOAT(ISTART)-TSTART)/ABSLEN
         ELSEIF(I.EQ.IEND)THEN
            XRADSM(I) = XRADSM(I) + (TEND - FLOAT(IEND-1))/RADL
            XABSSM(I) = XABSSM(I) + (TEND - FLOAT(IEND-1))/ABSLEN
         ELSE
            XRADSM(I) = XRADSM(I) + 1.0/RADL
            XABSSM(I) = XABSSM(I) + 1.0/ABSLEN
         ENDIF
 30   CONTINUE
      IF(IDEBUG.EQ.1)
     +WRITE(6,132)TSTART,TEND,XRADSM(ISTART),XRADSM(IEND),
     +                        XABSSM(ISTART),XABSSM(IEND)
 
 132  FORMAT(6X,'TS,TE,XRADSM(TS),XRADSM(TE)',4(2X,F10.5)/
     +       6X,'      XABSSM(TS),XABSSM(TE)',24X,2(2X,F10.5))
*     The following code steps through each bin along the
*     track and histograms 1/X0 for the first material
*     encountered in the bin.
*     Clearly this is not exactly correct if a bin contains more
*     than one material. Best solution is to decrease the step size
*     DASTEP.
      TSTEPJ = TSTEPJ + STEP
* The following now redundent - superceded by above.
*   (But leave commented for now.)
  10   CONTINUE
       IF (TSTEPJ .GT. ASTEPJ) THEN
         RADL1 = XRAD/STEP
         ABSL1 = XABS/STEP
         X1 = ASTEPJ
         DO 20, X = X1, TSTEPJ, DASTEP
         CALL HFILL (1, X, 0., RADL1)
         CALL HFILL (2, X, 0., ABSL1)
         WRITE (6, '('' ASTEPJ,X,1/RADL,1/ABSL'', 4G15.5)' )
     *    ASTEPJ, X, RADL1, ABSL1
         ASTEPJ = ASTEPJ + DASTEP
  20     CONTINUE
       END IF
+SELF.
C
C           Special conditions for other parameters.
C
      CALL UHTOC(IHSET,4,CUSET,4)
      INECAL = (CUSET .EQ. IEB) .OR. (CUSET .EQ. IEE) .OR.
     *  (CUSET .EQ. IFD) .OR. (CUSET .EQ. ISW)
      IF (INECAL .AND. IDTYPE .NE. 0) THEN
        IF (INWVOL .EQ. 1 .AND. SRAD (2) .LE. 0.) THEN
          SRAD (2) = SRAD (1)
          SABS (2) = SABS (1)
        ELSE IF (INWVOL .EQ. 2) THEN
          SRAD (3) = SRAD (1)
          SABS (3) = SABS (1)
        ENDIF
      ENDIF
C
      INHCAL = (CUSET .EQ. IHB) .OR. (CUSET .EQ. IHE) .OR.
     *  (CUSET .EQ. IHP)
      IF (INHCAL .AND. IDTYPE .NE. 0) THEN
        IF (INWVOL .EQ. 1 .AND. SABS (4) .LE. 0.) THEN
          SABS (4) = SABS (1)
        ELSEIF (INWVOL .EQ. 2) THEN
          SABS (5) = SABS (1)
        ENDIF
      ENDIF
C
      IF (ISTOP .EQ. 0) GO TO 90
+SELF,IF=FINECTH,NORMAL.
      CALL HFILL (100, TKVAR1, TKVAR2, 1.)
      CALL HFILL (101, TKVAR1, TKVAR2, SRAD (1) )
      CALL HFILL (102, TKVAR1, TKVAR2, SRAD (2) )
      CALL HFILL (103, TKVAR1, TKVAR2, SRAD (3) )
      CALL HFILL (200, TKVAR1, TKVAR2, 1.)
      CALL HFILL (201, TKVAR1, TKVAR2, SABS (1) )
      CALL HFILL (202, TKVAR1, TKVAR2, SABS (2) )
      CALL HFILL (203, TKVAR1, TKVAR2, SABS (3) )
      CALL HFILL (204, TKVAR1, TKVAR2, SABS (4) )
      CALL HFILL (205, TKVAR1, TKVAR2, SABS (5) )
+SELF,IF=FINEPHI. < We swap around for 1d phi histograms. >
      CALL HFILL (100, TKVAR2, TKVAR1, 1.)
      CALL HFILL (101, TKVAR2, TKVAR1, SRAD (1) )
      CALL HFILL (102, TKVAR2, TKVAR1, SRAD (2) )
      CALL HFILL (103, TKVAR2, TKVAR1, SRAD (3) )
      CALL HFILL (200, TKVAR2, TKVAR1, 1.)
      CALL HFILL (201, TKVAR2, TKVAR1, SABS (1) )
      CALL HFILL (202, TKVAR2, TKVAR1, SABS (2) )
      CALL HFILL (203, TKVAR2, TKVAR1, SABS (3) )
      CALL HFILL (204, TKVAR2, TKVAR1, SABS (4) )
      CALL HFILL (205, TKVAR2, TKVAR1, SABS (5) )
+SELF.
      CALL VZERO (SRAD, 3)
      CALL VZERO (SABS, 5)
C             Something to debug ?
C
  90  IF(IDEBUG.EQ.1) THEN
        IF(ISWIT(2).EQ.2)CALL GPCXYZ
        IF(ISWIT(7).EQ.1)THEN
          WRITE (6, 1004) TKVAR1, TKVAR2,
     +                    SLENG, RADL, ABSLEN ,SRAD, SABS
 1004     FORMAT (1X,2F6.2,
     +            ' LEN,RAD,ABS',3F9.3,' SRAD',3F6.2,' SABS',5F6.2)
        END IF
C               Stores current point in JXYZ for display
C
C
C             Online display of the track trajectory
C
        IF(ISWIT(2).EQ.3) CALL GDCXYZ
      END IF
C
  99  RETURN
      END
+PATCH,GOPRIMER.  LaTeX introductory documentation.

 No longer included in the PAMfile.  
 
 Look on the WRITEUP (OPALDOC 253) disk on CERNVM
 for the file named GOvvv.TEX where vvv is the version number

+PATCH,GOBANK.    DZDOC documentation of the banks output by GOPAL.
+DECK,CHEA.
*B..CHEA Cheat words header bank for GOPAL
*B.AUTH  D.R.Ward
*B.VERS  1.33
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    23
*B.NL    23
*B.NS    23
*B.NX    None
*B.UP    MC   -4
*B.OR    MC   -4
*B.LINK
*B.1 CVMC  Vertex detector cheat words
*B.2 CJCH  Jet Chamber cheat words
*B.3 CZCH  Zed Chamber cheat words
*B.4 TBMC  Time of Flight cheat words
*B.5 PBMC  Presampler Barrel cheat words
*B.6 EBMC  Lead glass Barrel cheat words
*B.7 PECH  Presampler Endcap cheat words
*B.8 EEMC  Lead glass Endcap cheat words
*B.9 HBMC  Hadron barrel cheat words
*B.10 HEMC  Hadron endcap cheat words
*B.11 HPCH  Hadron poletip cheat words
*B.12 MBMC  Muon barrel cheat words
*B.13 MECH  Muon endcap cheat words
*B.14 FDMC  Forward detector cheat words
*B.15 TRMC  Trigger cheat words
*B.16 TTMC  Track trigger cheat words
*B.17 SCMC  Slow controls cheat words
*B.18 FIMC  Filter cheat words
*B.19 ????  Unused?
*B.20 SIMC  Silicon microvertex cheat words
*B.21 ????  Unused?
*B.22 SWMC  Silicon tungsten detector cheat words
*B.23 TEMC  Time of flight endcap cheat words
*B/LINK
*B.DATA
*B.1 CVMC  Vertex detector cheat words flag (to be defined)
*B.2 CJMC  Jet Chamber cheat words flag (to be defined)
*B.3 CZMC  Zed Chamber cheat words flag (to be defined)
*B.4 TBMC  Time of Flight cheat words flag (to be defined)
*B.5 PBMC  Presampler Barrel cheat words flag (to be defined)
*B.6 EBMC  Lead glass Barrel cheat words flag (to be defined)
*B.7 PECH  Presampler Endcap cheat words flag (to be defined)
*B.8 EEMC  Lead glass Endcap cheat words flag (to be defined)
*B.9 HBMC  Hadron barrel cheat words flag (to be defined)
*B.10 HEMC  Hadron endcap cheat words flag (to be defined)
*B.11 HPMC  Hadron poletip cheat words flag (to be defined)
*B.12 MBMC  Muon barrel cheat words flag (to be defined)
*B.13 MEMC  Muon endcap cheat words flag (to be defined)
*B.14 FDMC  Forward detector cheat words flag (to be defined)
*B.15 TRMC  Trigger cheat words flag (to be defined)
*B.16 TTMC  Track trigger cheat words flag (to be defined)
*B.17 SCMC  Slow controls cheat words flag (to be defined)
*B.18 FIMC  Filter cheat words flag (to be defined)
*B.19 ????  Unused?
*B.20 SIMC  Silicon microvertex cheat words flag (to be defined)
*B.21 ????  Unused?
*B.22 SWMC  Silicon tungsten cheat words flag (to be defined)
*B.23 TEMC  Time of flight endcap cheat words flag (to be defined)
*B/DATA
*B/
+DECK, CJC1. ---------------------------------------------------------
*B..CJC1      Flag words for "good" digits (bit pattern).
*B.           The bank contains a bit patterns describing the
*B.           history of each digit.
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       1
*B.DATA
*B.REP NDIGS
*B.1  IFLDIG Flag word.
*B/REP
*B/DATA
*B/
+DECK, CJC2. ---------------------------------------------------------
*B..CJC2      Track numbers ( integer ).
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       2
*B.DATA
*B.REP NDIGS
*B.1  ITRA   Geant track number.
*B/REP
*B/DATA
*B/
+DECK, CJC3. ---------------------------------------------------------
*B..CJC3      Track segment numbers ( integer ).
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       3
*B.DATA
*B.REP NDIGS
*B.1  ITS    Jet chamber track segment number.
*B/REP
*B/DATA
*B/
+DECK, CJC4. ---------------------------------------------------------
*B..CJC4  Drift distance ( sign corresponding to L-R ) ( real ).
*B.       This bank is created for cheat words detail level >= 2 only.
*B.ND       *
*B.NL      0
*B.NS      0
*B.UP  CJSH       4
*B.DATA
*B.REP NDIGS
*B.1  DDRIFT Unsmeared drift distance.
*B/REP
*B/DATA
*B/
+DECK, CJC5. ---------------------------------------------------------
*B..CJC5  Px/P in drift cell (Real, DRS).
*B.       This bank is created for cheat words detail level >= 2 only.
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       5
*B.DATA
*B.REP NDIGS
*B.1  PXBYP X- direction in drift cell.
*B/REP
*B/DATA
*B/
+DECK, CJC6. ---------------------------------------------------------
*B..CJC6  Py/P in drift cell (Real, DRS).
*B.       This bank is created for cheat words detail level >= 2 only.
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       6
*B.DATA
*B.REP NDIGS
*B.1  PYBYP Y- direction in drift cell.
*B/REP
*B/DATA
*B/
+DECK, CJC7. ---------------------------------------------------------
*B..CJC7  Momentum in drift cell (Real).
*B.       This bank is created for cheat words detail level >= 2 only.
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       7
*B.DATA
*B.REP NDIGS
*B.1  PMOM  Momentum in drift cell.
*B/REP
*B/DATA
*B/
+DECK, CJC8. ---------------------------------------------------------
*B..CJC8  X of correct hit ( real, MRS ).
*B.       This bank is created for cheat words detail level >= 2 only.
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       8
*B.DATA
*B.REP NDIGS
*B.1  X     Unsmeared X- coordinate.
*B/REP
*B/DATA
*B/
+DECK, CJC9. ---------------------------------------------------------
*B..CJC9  Y of correct hit ( real, MRS ).
*B.       This bank is created for cheat words detail level >= 2 only.
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       9
*B.DATA
*B.REP NDIGS
*B.1  Y     Unsmeared Y- coordinate.
*B/REP
*B/DATA
*B/
+DECK, CJCA. ---------------------------------------------------------
*B..CJCA  Z of correct hit ( real, MRS ).
*B.       This bank is created for cheat words detail level >= 2 only.
*B.ND      NDIGS
*B.NL      0
*B.NS      0
*B.UP  CJSH       10
*B.DATA
*B.REP NDIGS
*B.1  Z     Unsmeared Z- coordinate.
*B/REP
*B/DATA
*B/
+DECK, CJCE. ---------------------------------------------------------
*B..CJCE Digits cheat words event header bank.
*B.ND       2
*B.NL      24
*B.NS      24
*B.UP  CJCH       3
*B.LINK
*B.REP 24
*B.1  CJSH   CJ sector cheat words.
*B/REP
*B/LINK
*B.DATA
*B.1  ICHVRS   Cheat words version number.
*B.2  ICHLEV   Cheat words detail level.
*B/DATA
*B/
+DECK, CJCH. ---------------------------------------------------------
*B..CJCH cheat words event header bank.
*B.ND       8
*B.NL       8
*B.NS       8
*B.UP  CHEA       2
*B.LINK
*B.3  CJCE Digits cheat words event header.
*B.8  CJTC Tracks cheat words bank.
*B/LINK
*B.DATA
*B.REP   8
*B.1  #  Undefined
*B/REP
*B/DATA
*B/
+DECK, CJC.
*B..CJC  CJ constants top bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    5      Format : all integer.
*B.NL    5
*B.NS    5
*B.UP CDC - 2
*B.OR CDC - 2
*B.LINK
*B.1  CJGP Jet chamber geometry parameters top bank.
*B.2  CJPD Jet chamber detector parameters top bank.
*B.3  CJCP Jet chamber calibration parameters top bank.
*B.4  CJHP Jet chamber hit analysis parameters top bank.
*B.5  CJTP Jet chamber track/segments finding parameters top bank.
*B/LINK
*B.DATA
*B.1 # undefined
*B.2 # undefined
*B.3 # undefined
*B.4 # undefined
*B.5 # undefined
*B/DATA
*B/
+DECK, CJDD. ---------------------------------------------------------
*B..CJDD CJ - data cards parameters bank.
*B.      Most parameters for the parametrisations of detector effects
*B.      in the jet chamber are stored here.
*B.AU    G.Tysarczyk
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    variable
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    CJDK
*B.OR    CJDK
*B.DATA
*B.REP NT
*B.REP N_I   Values of data card parameters
*B.1  ..
*B/REP
*B/REP
*B/DATA
*B/
+DECK, CJDK. ---------------------------------------------------------
*B..CJDK CJ - data cards bank.
*B.AU    G.Tysarczyk
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    2 * NT + 1 = number of data cards * 2 + 1
*B.NL    1
*B.NS    1
*B.NX    None
*B.UP    CJPD
*B.OR    CJPD
*B.LINK
*B.1  CJDD   Data cards parameters bank
*B/LINK
*B.DATA
*B.1  NT     Number of data cards
*B.REP NT
*B.1  N_I    Number of parameters for data card number I
*B/REP
*B.REP NT
*B.1  J_I    Reference link to the bank CJDD for the first value of
*B.          data card 1 . Starts at word number NT + 2
*B/REP
*B/DATA
*B/
+DECK, CJGP. ---------------------------------------------------------
*B..CJGP Jet chamber geometry parameters top bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    2      Format : all integer.
*B.NL    2
*B.NS    2
*B.UP CJC  - 1
*B.OR CJC  - 1
*B.LINK
*B.1  CJVD Jet chamber volume description top bank.
*B.2  CJRM Jet chamber rotation matrix top bank.
*B/LINK
*B.DATA
*B.1 # undefined
*B.2 # undefined
*B/DATA
*B/
+DECK, CJLO. ---------------------------------------------------------
*B..CJLO        Top level bank of list of CJ LOST points.
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      10
*B.NL      14
*B.NS      14
*B.UP  CJSH      11
*B.LINK
*B.1  CJL1      Wire/ drift cell number ( integer ).
*B.2  CJL2      Drift time ( integer ).
*B.3  CJL3      Z ( integer ).
*B.4  CJL4      Charge on wire ( integer )
*B.5  CJL5      Flag words for lost digits.
*B.6  CJL6      Track numbers ( integer ).
*B.7  CJL7      Track segment numbers ( integer ).
*B.8  CJL8      Drift distance ( sign corresponding to L-R ) ( real ).
*B.9  CJL9      X- component of momentum in cell ( real ).
*B.10 CJLA      Y- component of momentum in cell ( real ).
*B.11 CJLB      Z- component of momentum in cell ( real ).
*B.12 CJLC      X of correct hit ( real ).
*B.13 CJLD      Y of correct hit ( real ).
*B.14 CJLE      Z of correct hit ( real ).
*B/LINK
*B.DATA
*B.1  NDLOST   Number of hits discarded during the digitization.
*B.REP   9
*B.1  #  Undefined
*B/REP
*B/DATA
*B/
+DECK, CJL1. ---------------------------------------------------------
*B..CJL1  Drift cell number (Integer).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     1
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 ICELL  Drift cell number
*B/REP
*B/DATA
*B/
+DECK, CJL2. ---------------------------------------------------------
*B..CJL2  Drift time (Integer).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     2
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 ITIME  Drift time.
*B/REP
*B/DATA
*B/
+DECK, CJL3. ---------------------------------------------------------
*B..CJL3  Smeared Zed- coordinate (Integer).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     3
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 IZED   Zed (integer, millimeters)
*B/REP
*B/DATA
*B/
+DECK, CJL4. ---------------------------------------------------------
*B..CJL4  Charge (Integer).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     4
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 ICHARG Charge deposit in drift cell.
*B/REP
*B/DATA
*B/
+DECK, CJL5. ---------------------------------------------------------
*B..CJL5  Flag words (= CJC1 ).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     5
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 IFLAG  Flag word
*B/REP
*B/DATA
*B/
+DECK, CJL6. ---------------------------------------------------------
*B..CJL6  Track numbers (= CJC2).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     6
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 ITRA   Geant track number of digit.
*B/REP
*B/DATA
*B/
+DECK, CJL7. ---------------------------------------------------------
*B..CJL7  Track segment numbers (= CJC3).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     7
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 ITS    Jet chamber track segment number.
*B/REP
*B/DATA
*B/
+DECK, CJL8. ---------------------------------------------------------
*B..CJL8  Unsmeared drift distance (= CJC4).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     8
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 DDRIFT Drift distance.
*B/REP
*B/DATA
*B/
+DECK, CJL9. ---------------------------------------------------------
*B..CJL9  Px/P in drift cell (DRS) (= CJC5).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO     9
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 PXBYP  Px/P (DRS)
*B/REP
*B/DATA
*B/
+DECK, CJLA. ---------------------------------------------------------
*B..CJLA  Py/P in drift cell (DRS) (= CJC6).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO    10
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 PYBYP  Py/P (DRS)
*B/REP
*B/DATA
*B/
+DECK, CJLB. ---------------------------------------------------------
*B..CJLB  Momentum of track in drift cell (= CJC7).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO    11
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 P      Momentum in the drift cell.
*B/REP
*B/DATA
*B/
+DECK, CJLC. ---------------------------------------------------------
*B..CJLC  Unsmeared X in drift cell (MRS) (= CJC8).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO    12
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 X      X coordinate.
*B/REP
*B/DATA
*B/
+DECK, CJLD. ---------------------------------------------------------
*B..CJLD  Unsmeared Y in drift cell (MRS) (= CJC9).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO    13
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 Y      Y coordinate.
*B/REP
*B/DATA
*B/
+DECK, CJLE. ---------------------------------------------------------
*B..CJLE  Unsmeared Z in drift cell (MRS) (= CJCA).
*B.       This bank is created for cheat words detail level >= 3 only.
*B.ND      NDLOST
*B.NL      0
*B.NS      0
*B.UP  CJLO    14
*B.LINK
*B/LINK
*B.DATA
*B.REP   NDLOST
*B.1 Z      Z coordinate.
*B/REP
*B/DATA
*B/
+DECK, CJPD. ---------------------------------------------------------
*B..CJPD Jet chamber detector parameters bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.02
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    205   Mixed Format: (1I 1I 26H 26I 1I -F)
*B.NL    1
*B.NS    1
*B.UP CJC  - 2
*B.OR CJC  - 2
*B.LINK
*B.1  CJDK
*B/LINK
*B.DATA
*B.1   JMLAST Address of last word used for management.
*B.2   NALSEC Number of GEANT detector aliases (24).
*B.3   NAMSET Name of the GEANT set "Jet Chamber".
*B.4   NAMDET Name of the GEANT detector "Jet Chamber".
*B.REP NALSEC
*B.1   NAMSEC Name of a GEANT detector alias for the Jet Chamber.
*B/REP
*B.29  IDSET  Numerical identifier of the set "Jet Chamber".
*B.30  IDDET  Numerical identifier of the detector "Jet Chamber".
*B.REP NALSEC
*B.1   IDASEC Numerical identifier of a detector alias.
*B/REP
*B.55  NDETPA Number of detector parameters.
*B.56  NSECT  Number of jet chamber sectors.
*B.57  NWIRES Number of drift cells in one sector.
*B.58  RWZERO Position of wire Zero in cm.
*B.59  DWIRES Distance between sense wires in cm.
*B.60  XWZERO X- position of wire Zero lorentz inclined DRS in cm.
*B.61  DCELLX Thickness of drift cells.
*B.62  W0HLEN Half length of wire Zero in cm.
*B.63  TAINC  Tangent of inclination angle of the end cones.
*B.64  STMMAX Nominal value of mechanical staggering in cm.
*B.65  STEMAX Nominal value of electrostatic sagging in cm.
*B.66  STGMAX Nominal value of gravitational sagging in cm.
*B.67  BFIELD Nominal value of magnetic field strength.
*B.68  ALOR   Nominal value of Lorentz angle in degrees.
*B.69  SINLOR Sine of Lorentz angle.
*B.70  COSLOR Cosine of Lorentz angle.
*B.71  APHI   Nominal half opening angle of a sector in R- PHI
*B.           in degrees.
*B.72  VDRIFT Nominal value of drift velocity.
*B.73  TSCALE Scale used to store the drift time ( will be removed with
*B.           the next version).
*B.74  CELRAD "Radius" of a drift cell in Lorentz inclined DRS in cm.
*B.75  TICRAD "Radius" of a drift cell in Lorentz inclined DRS in nsec.
*B.76  AINC   Nominal inclination angle of the cones in degrees.
*B.77  RADINC Nominal inclination angle of the cones in radians.
*B.78  PHIHOP Nominal half opening angle of a sector in R- Phi
*B.           in radians.
*B.79  RADLOR Nominal Lorentz angle in radians.
*B.80  TANHOP Tangent of PHIHOP.
*B.81  CTGHOP Cotangent of PHIHOP.
*B.82  SINHOP Sine of PHIHOP.
*B.83  COSHOP Cosine of PHIHOP.
*B.84  #      Undefined.
*B.85  DCATHW Distance between cathode wires.
*B.86  WHLCAT Half length of cathode wire Zero.
*B.87  RW0CAT Radial position of cathode wire Zero.
*B.88  #      Undefined.
*B.89  #      Undefined.
*B.90  TSCALE Scale for the storing of the digit drift time.
*B.91  ZSCALE Scale for the storing of the digit drift Z- coordinate.
*B.92  ZOFSET Offset for the storing of the digit drift Z- coordinate.
*B.93  QSCALE Scale for the storing of the digit charge.
*B.94  #      Undefined.
*B.95  #      Undefined.
*B.REP 24 Rotation matrices to detector reference frame.
*B.1   SINSEC Nominal sine of orientation of anode plane w.r.t. MRS.
*B.2   COSSEC Nominal cosine of orientation of anode plane w.r.t. MRS.
*B.3   SINSEC Nominal sine of Lorentz inclined DRS w.r.t. MRS.
*B.4   COSSEC Nominal cosine of Lorentz inclined DRS w.r.t. MRS.
*B/REP
*B.REP 14
*B.1   #      Undefined.
*B/REP
*B/DATA
*B/
+DECK, CJRM. ---------------------------------------------------------
*B..CJRM Jet chamber rotation matrix top bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    1      Format : all integer.
*B.NL    5
*B.NS    5
*B.UP CJGP - 2
*B.OR CJGP - 2
*B.LINK
*B.REP NROTMA ( NROTMA = number of matrices).
*B.1  CJRO Jet chamber rotation matrix bank.
*B/REP
*B/LINK
*B.DATA
*B.1 NROTMA Number of rotation matrices.
*B/DATA
*B/
+DECK, CJRO. ---------------------------------------------------------
*B..CJRO Jet chamber rotation matrix bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    8  Format : 2I -F.
*B.NL    0
*B.NS    0
*B.UP CJRM - IDROTM ( IDROTM = internal rotation matrix identifier).
*B.OR CJRM - IDROTM ( IDROTM = internal rotation matrix identifier).
*B.LINK
*B/LINK
*B.DATA
*B.1 IDROTM Internal rotation matrix identifier.
*B.2 IGROTM GEANT rotation matrix identifier.
*B.REP 6
*B.1 ANGLES Angles used to define the matrix ( degrees ).
*B/REP
*B/DATA
*B/
+DECK, CJSH. ---------------------------------------------------------
*B..CJSH  Sector header bank for digits cheat words.
*B.ND      10
*B.NL      14
*B.NS      14
*B.UP  CJCE
*B.LINK
*B.1  CJC1      Flag words.
*B.2  CJC2      Track numbers ( integer ).
*B.3  CJC3      Track segment numbers ( integer ).
*B.4  CJC4      Drift distance ( sign corresponding to L-R ) ( real ).
*B.5  CJC5      Px/P in cell ( real ).
*B.6  CJC6      Py/P in cell ( real ).
*B.7  CJC7      P    in cell ( real ).
*B.8  CJC8      X of correct hit ( real ).
*B.9  CJC9      Y of correct hit ( real ).
*B.10 CJCA      Z of correct hit ( real ).
*B.11 CJLO      "Lost points" header bank.
*B/LINK
*B.DATA
*B.1  NDIGS    Number of digits.
*B.REP   9
*B.1  #  Undefined
*B/REP
*B/DATA
*B/
+DECK, CJTC. ---------------------------------------------------------
*B..CJTC Tracks cheat words bank.
*B.      This bank is created and filled only if the faked track
*B.      reconstruction is switched on.
*B.ND NUMTRA Number of "reconstructed" tracks.
*B.NL       0
*B.NS       0
*B.UP  CJCH  8
*B.LINK
*B/LINK
*B.DATA
*B.REP   NUMTRA
*B.1  ITRA Geant track number of the track.
*B/REP
*B/DATA
*B/
+DECK, CJVD. ---------------------------------------------------------
*B..CJVD Jet chamber volume description top bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    1      Format : all integer.
*B.NL    8
*B.NS    8
*B.UP CJGP - 1
*B.OR CJGP - 1
*B.LINK
*B.REP NVOLU ( NVOLU = Number of volumes ).
*B.1  CJVO Jet chamber volume parameters bank.
*B/REP
*B/LINK
*B.DATA
*B.1 NVOLU Number of volumes
*B/DATA
*B/
+DECK, CJVO. ---------------------------------------------------------
*B..CJVO Jet chamber volume parameters bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    variable  Format : 3H 4I -F.
*B.NL    NCVOLU ( NCVOLU = number of copies) .
*B.NS    NCVOLU ( NCVOLU = number of copies) .
*B.UP CJVD - IDVOL ( IDVOL = internal volume identifier ).
*B.OR CJVD - IDVOL ( IDVOL = internal volume identifier ).
*B.LINK
*B.REP NCVOLU
*B.1  CJVP Jet chamber volume position bank.
*B/REP
*B/LINK
*B.DATA
*B.1 NAVOLU Name of volume.
*B.2 MOVOLU Name of mother volume.
*B.3 TYVOLU GEANT shape type of volume.
*B.4 MEVOLU Tracking medium number of volume.
*B.5 IGVOLU GEANT volume identifier of volume.
*B.6 NCVOLU Number of copies placed in the mother volume.
*B.7 NPVOLU Number parameters used for volume description.
*B.REP NPVOLU
*B.1 PAVOLU Volume parameters.
*B/REP
*B/DATA
*B/
+DECK, CJVP. ---------------------------------------------------------
*B..CJVP Jet chamber volume position bank.
*B.AUTH  H. Kreutzmann
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IROCON
*B.ND    5    Format : 2I 3F.
*B.NL    0
*B.NS    0
*B.UP CJVO - IDVOLP ( IDVOLP = internal volume position identifier.)
*B.OR CJVO - IDVOLP ( IDVOLP = internal volume position identifier.)
*B.LINK
*B/LINK
*B.DATA
*B.1 IDVOLP Internal position identifier.
*B.2 IRVOLU Internal rotation matrix number.
*B.REP 3
*B.1 PSVOLU Coordinate of volume position.
*B/REP
*B/DATA
*B/
+DECK,CVMC.
*B..CVMC Vertex detector top cheat bank.
*B.NL *
*B.NS *
*B.ND 1
*B.UP CHEA
*B.OR CHEA -1
*B.
*B.LINK
*B.REP NSECT
*B.1 CVM1 on the Ith link is the Ith sector cheat bank.
*B/REP NSECT
*B/LINK
*B.DATA
*B.1 NSECT  is the number of sectors.
*B/
+DECK,CVM1.
*B..CVM1 CV sector cheat bank.
*B.NL 0
*B.NS 0
*B.ND *
*B.UP CVMC
*B.OR CVMC -ISECT
*B.DATA
*B.1 NWIRE  is the number of wires.
*B.2 NTOT   is the total number of hits in the sector.
*B.3 NDATPH is the number of data words per hit.
*B.REP NWIRE
*B.1 NHIT   is the number of hits on wire I.
*B/REP NWIRE
*B.REP NWIRE
*B.1 N1     is the position in this data of the first word of the
*B.         first hit on wire I.
*B/REP NWIRE
*B.REP NHIT
*B.1 ITREE  is the tree number of the track which caused the hit.
*B.2 IX     is the true x position of the hit in microns.
*B.3 IY     is the true y position of the hit in microns.
*B.4 IZ     is the true z position of the hit in microns.
*B/REP NHIT
*B/
+DECK, CZCH.
*B..CZCH CZ Top Cheat words bank
*B.AU B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    1
*B.NL    NGRP
*B.NS    NGRP
*B.UP    CHEA -LCZCH
*B.IO    1I
*B.LINK
*B.REP NGRP
*B.1 CZHG Group cheat words bank
*B/REP
*B/LINK
*B.DATA
*B.1 NGRP Number of groups
*B/DATA
*B/
+DECK, CZHG.
*B..CZHG Group Cheat words bank
*B.AU    B. LORAZO
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    3
*B.NL    19
*B.NS    19
*B.UP    CZCH -IGRP
*B.IO    3I
*B.LINK
*B.1 CZHX -LCZHX X coordinate  (LRS)
*B.2 CZHY -LCZHY Y coordinate  (LRS)
*B.3 CZHZ -LCZHZ Z coordinate  (LRS)
*B.13 CZHW -LCZHW Wire no.
*B.18 CZHT -LCZHT Signed GEANT Track #.
*B/LINK
*B.DATA
*B.1 * Group no.
*B.2 * IPC for current group (10*IPAN +ICELL)
*B.3 * NHCZ Number of hits for current group
*B/DATA
*B/
+DECK, CZHX.
*B..CZHX X coordinate LRS Cheat words bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    NHGRP Number of hits
*B.NL    0
*B.NS    0
*B.UP    CZHG -LCZHX
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * X coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZHY.
*B..CZHY Y coordinate LRS Cheat words bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    NHGRP Number of hits
*B.NL    0
*B.NS    0
*B.UP    CZHG -LCZHY
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * Y coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZHZ.
*B..CZHZ Z coordinate LRS Cheat words bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    NHGRP Number of hits
*B.NL    0
*B.NS    0
*B.UP    CZHG -LCZHZ
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * Z coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZHW.
*B..CZHW Wire index Cheat words bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    NHGRP  Number of hits
*B.NL    0
*B.NS    0
*B.UP    CZHG -LCZHW
*B.IO    -I
*B.DATA
*B.REP NHGRP
*B.1 * Hit wire index
*B/REP
*B/DATA
*B/
+DECK, CZHT.
*B..CZHT Signed GEANT track number.
*B.AU    B. LORAZO
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    NHGRP  Number of hits
*B.NL    0
*B.NS    0
*B.UP    CZHG -LCZHT
*B.IO    -I
*B.DATA
*B.REP NDIGS
*B.1 * Signed GEANT Track #.
*B/REP
*B/
+DECK, CZWK.
*B..CZWK Top working bank
*B.AU B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    5
*B.NL    5
*B.NS    5
*B.UP    none
*B.LINK
*B.2 CZWD Calibrated Digit bank
*B.3 CZWM GOPAL dynamic Multiplexing bank
*B/LINK
*B.DATA
*B.REP 5
*B.1 ????
*B/REP
*B/DATA
*B/
+DECK, CZWM.
*B..CZWM GOPAL Dynamic Multiplexing working bank
*B.AU B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.UP    CZWK -LCZWM
*B.IO    -I
*B.DATA
*B.1 NCLST  Number of clusters
*B.REP NCLST
*B.1 IGRP  group index of multiplexed cell 1 in current cluster
*B.2 IGRP  group index of multiplexed cell 2 in current cluster
*B.3 IGRP  group index of multiplexed cell 3 in current cluster
*B.4 IGRP  group index of multiplexed cell 4 in current cluster
*B/REP
*B/DATA
*B/
+DECK, CZWD.
*B..CZWD Digit working bank
*B.AU B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    *
*B.NS    *
*B.UP    CZWK -LCZWD
*B.IO    -I
*B.LINK
*B.REP NGRP
*B.1 CZWG Group working bank
*B/REP
*B/LINK
*B.DATA
*B.1 NGRP Number of groups
*B.REP NGRP
*B.1 IPC for current group (10*IPAN +ICELL)
*B/REP
*B.REP NGRP
*B.1 NHCZ Number of digits for current group
*B/REP
*B/DATA
*B/
+DECK, CZWG.
*B..CZWG Group working bank
*B.AU    B. LORAZO
*B.VE    1.02
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    13
*B.NL    19
*B.NS    19
*B.UP    CZWD -IGRP
*B.IO    13I
*B.LINK
*B.1 CZWX -LCZWX X coordinate  (LRS)
*B.2 CZWY -LCZWY Y coordinate  (LRS)
*B.3 CZWZ -LCZWZ Z coordinate  (LRS0
*B.4 CZWR -LCZWR Right Z coordinate  (LRS)
*B.5 CZWL -LCZWL Left  Z coordinate  (LRS)
*B.6 CZWU -LCZWU Y coordinate error
*B.7 CZWV -LCZWV Z coordinate error
*B.10 CZWS -LCZWS Drift distance
*B.13 CZWW -LCZWW Wire no.
*B.15 CZWQ -LCZWQ Quality flag
*B.18 CZWT -LCZWT Pointer to Original Hit
*B.19 CZWO -LCZWO Multiplexed partner
*B/LINK
*B.DATA
*B.1 * Number of digits for the current group
*B.REP NCZWIR
*B.1 * Wire start address
*B/REP
*B.REP NCZWIR
*B.1 * Number of digits per wire
*B/REP
*B/DATA
*B/
+DECK, CZWX.
*B..CZWX X coordinate LRS working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWX
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * X coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZWY.
*B..CZWY Y coordinate LRS
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWY
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * Y coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZWZ.
*B..CZWZ Z coordinate LRS working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWZ
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * Z coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZWR
*B..CZWR RIGHT Z coordinate LRS working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWR
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * RIGHT Z coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZWL
*B..CZWL LEFT Z coordinate LRS working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWL
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * LEFT Z coordinate (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZWU
*B..CZWU Y coordinate error LRS working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWU
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * Y coordinate error (LRS)
*B/REP
*B/DATA
*B/
+DECK, CZWV
*B..CZWV Z coordinate error working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWV
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * Z coordinate error
*B/REP
*B/DATA
*B/
+DECK, CZWS.
*B..CZWS Drift distance working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP  Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWS
*B.IO    -F
*B.DATA
*B.REP NHGRP
*B.1 * Drift distance
*B/REP
*B/DATA
*B/
+DECK, CZWW.
*B..CZWW Wire index working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP  Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWW
*B.IO    -I
*B.DATA
*B.REP NHGRP
*B.1 * Hit wire index
*B/REP
*B/DATA
*B/
+DECK, CZWQ.
*B..CZWQ Quality flag working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP  Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWQ
*B.IO    -I
*B.DATA
*B.REP NHGRP
*B.1 * Quality flag
*B/REP
*B/DATA
*B/
+DECK, CZWT.
*B..CZWT Original Hit Pointer working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP  Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWT
*B.IO    -I
*B.DATA
*B.REP NDIGS
*B.1 * Pointer to the original hit (1000*IGRP +IHGRP)
*B/REP
*B/
+DECK, CZWO.
*B..CZWO Multiplexed partner working bank
*B.AU    B. LORAZO
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    NHGRP  Number of digits
*B.NL    0
*B.NS    0
*B.UP    CZWG -LCZWO
*B.IO    -I
*B.DATA
*B.REP NHGRP
*B.1 * 1000*IGRPT +IHGRPT
*B/REP
*B/DATA
*B/
+DECK,EBMC.
*B..EBMC EB Monte Carlo cheat words.
*B.AUTH  T.Mashimo
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    CHEA
*B.OR    CHEA
*B.DATA
*B.REP ND/3
*B.1 TRACK  Track number (floating point)
*B.2 BLOCK  Block number (range 1-9440)
*B.3 ENERGY Energy from this track in this block (GeV)
*B/REP
*B/
+DECK,EEMC.
*B..EEMC EE Monte Carlo cheat words.
*B.AU    C.P.Ward
*B.VE    1.00
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    CHEA -8
*B.OR    CHEA -8
*B.DATA
*B.REP ND/3
*B.1  TRK    Track number (floating point)
*B.2  BLK    Block number (floating point 10000.*IZ+100.*IY+IX)
*B.3  ENER   Energy from this track in this block
*B/REP
*B/DATA
*B/
+DECK,GENE.
*B..GENE Generator Bank
*B.AU    S.L.Lloyd
*B.ST    IXSTOR
*B.DV    IXDIV
*B.NL 3
*B.NS 3
*B.ND 8
*B.UP MC -1
*B.OR MC -1
*B.LINK
*B.1 TREE  Tree of generated particles
*B.2 JETS  Generated partons
*B.3 XTRA  Additional generator parameters
*B/LINK
*B.DATA
*B.1 NGEN   Total number of generated particles
*B.2 NPRIM  Number of primary particles
*B.3 NJET   Number of primary partons
*B.4 NSJET  Number of secondary partons
*B.5 LENT   Length of a TREE entry (=22)
*B.6 LENJ   Length of a JETS entry (=8)
*B.7 IOTREE IO pointer for TREE bank
*B.8 IOTREE IO pointer for JETS bank
*B/DATA
*B/
+DECK,HTSB.
*B..HTSB Temporary Strip Header bank
*B.AU    A.Buijs
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    NSTRIP
*B.NL    NSTRIP
*B.NS    NSTRIP
*B.NX    None
*B.UP    None
*B.OR    None
*B.LINK
*B.REP NSTRIP
*B.1  HTSD   Temporary Strip Data Bank
*B/REP
*B/LINK
*B.DATA
*B.REP NSTRIP
*B.1  NHIT   Number of hits for this strip
*B/REP
*B/DATA
*B/
*
****************************************************************************
*
+DECK,HTSD.
*B..HTSD Temporary Strip data bank
*B.AU    A.Buijs
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    8*NHIT
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    HTSB
*B.OR    HTSB
*B.DATA
*B.REP NHIT
*B.1  JIFLAG   Flag (0 original hit, 1 neighbouring hit, 10 cross talk.)
*B.2  JIMCTR   Monte Carlo track that caused this hit
*B.3  JXLOC    local X coordinate (perp. to strip)                 [cm]
*B.4  JYLOC    local Y coordinate (along strip)                    [cm]
*B.5  JANGLE   Track angle in local x-z frame
*B.6  JYPROJ   Projected track length along strip                  [cm]
*B.7  JXCELL   Local track coordinate in cell wrt wire (-.5 to .5) [cm]
*B.8  JQIND    Induced charge                                      [pC]
*B/REP
*B/DATA
*B/
*
****************************************************************************
*
+DECK,HTTB.
*B..HTTB Temporary Tower Header bank
*B.AU    A.Buijs
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    21
*B.NL    21
*B.NS    21
*B.NX    None
*B.UP    None
*B.OR    None
*B.LINK
*B.REP 21
*B.1  HTTD   Temporary Tower Data Bank
*B/REP
*B/LINK
*B.DATA
*B.REP 21
*B.1  IMASK  Mask of active pads (bit n = layer n, 1=active)
*B/REP
*B/DATA
*B/
*
****************************************************************************
*
+DECK,HTTD.
*B..HTTD Temporary Tower data bank
*B.AU    A.Buijs
*B.VE    1.01
*B.ST    IXSTOR
*B.DV    IRODIV
*B.ND    9
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    HTTB
*B.OR    HTTB
*B.DATA
*B.1  JIQL1    Charge induced on layer 1.
*B.2  JIQL2    Charge induced on layer 2.
*B.3  JIQL3    Charge induced on layer 3.
*B.4  JIQL4    Charge induced on layer 4.
*B.5  JIQL5    Charge induced on layer 5.
*B.6  JIQL6    Charge induced on layer 6.
*B.7  JIQL7    Charge induced on layer 7.
*B.8  JIQL8    Charge induced on layer 8.
*B.9  JIQL9    Charge induced on layer 9.
*B/DATA
*B/
 
+DECK,HPCH.
*B..HPCH   Hadron Poletip Cheat Data Bank
*B.AUTH    HOCHMAN
*B.VERSION 1.01/1
*B.NL 2
*B.NS 2
*B.ND 0
*B.UP      CHEA
*B.OR      CHEA
*B.LINK
*B.1 HPGT  CHEAT DATA FOR TOWERS
*B.2 HPGS  CHEAT DATA FOR STRIPS
*B/LINK
*B/        End of bank descriptor
+DECK,HPGS.
*B..HPGS   Hadron Pole Tip Cheat Data for Strips
*B.NL *
*B.NS *
*B.ND *
*B.UP      HPCH
*B.OR      HPCH
*B.LINK
*B.1 HPKS  TRACK 5 VECTOR ASSOCIATED TO STRIP
*B/LINK
*B.DATA
*B.REP Number of strips
*B.1   JSTRIP,(JSTRIP = 32768*ICAP+2048*ISEG+128*ILAY+ISTR)
*B/REP
*B/DATA
+DECK,HPGT.
*B..HPGT   Hadron Pole Tip Cheat Data for Towers
*B.NL *
*B.NS *
*B.ND *
*B.UP      HPCH
*B.OR      HPCH
*B.LINK
*B.1 HPKT  TRACK 5 VECTOR ASSOCIATED TO TOWER
*B/LINK
*B.DATA
*B.REP Number of towers
*B.1   JTOWER,(JTOWER = 32768*ICAP+256*ISEG+IPAD)
*B/REP
*B/DATA
+DECK,HPKS.
*B..HPKS   Hadron Pole Tip Track Data
*B.NL 0
*B.NS 0
*B.ND *
*B.UP      HPGS
*B.OR      HPKS
*B.DATA
*B.REP Number of tracks associated to strip
*B.1   Track number in kinematic bank
*B.2   Px
*B.3   Py
*B.4   Pz
*B.5   E
*B.6   M
*B/REP
*B/DATA
+DECK,HPKT.
*B..HPKT   Hadron Pole Tip Track Data
*B.NL 0
*B.NS 0
*B.ND *
*B.UP      HPGT
*B.OR      HPKT
*B.DATA
*B.REP Number of tracks associated to tower
*B.1   Track number in kinematic bank
*B.2   Px
*B.3   Py
*B.4   Pz
*B.5   E
*B.6   M
*B/REP
*B/DATA
+DECK,HPLS.
*B..HPLS   Hadron Pole Tip Raw Strip Data Bank (Endcap = 1)
*B.NL 0
*B.NS 0
*B.ND *
*B.UP      HPRA
*B.OR      HPRA
*B.DATA
*B.REP Number of strips  (endcap = 1)
*B.1   65536*JSTRIP+MSTRIP,(JSTRIP = 32768*ICAP+2048*ISEG+128*ILAY+ISTR)
*B/REP
*B/DATA
*B/        Tower Information (endcap = 1)
+DECK,HPLT.
*B..HPLT   Hadron Pole Tip Raw Tower Data Bank (Endcap = 1)
*B.NL 0
*B.NS 0
*B.ND *
*B.UP      HPRA
*B.OR      HPRA
*B.DATA
*B.REP Number of towers  (endcap = 1)
*B.1   65536*JTOWER+IPULSE,(JTOWER = 32768*ICAP+256*ISEG+IPAD)
*B/REP
*B/DATA
*B/        Tower Information (endcap = 1)
+DECK,HPRA.
*B..HPRA   Hadron Poletip Raw Data Bank
*B.AUTH    HOCHMAN
*B.VERSION 1.01/1
*B.NL 4
*B.NS 4
*B.ND 64
*B.UP      DA
*B.OR      DA
*B.IO      I
*B.LINK
*B.1 HPRT  Raw data from towers (endcap = 2)
*B.2 HPRS  Raw data from strips (endcap = 2)
*B.3 HPLT  Raw data from towers (endcap = 1)
*B.4 HPLS  Raw data from strips (endcap = 1)
*B/LINK
*B.DATA
*B.REP Number of towers  (endcap = 0)  168 towers 6 words
*B.1   Bitmask set if dead right tower.
*B/REP
*B.REP Number of towers  (endcap = 0)  168 towers 6 words
*B.1   Bitmask set if hot right tower.
*B/REP
*B.REP Number of towers  (endcap = 1)  168 towers 6 words
*B.1   Bitmask set if dead left tower.
*B/REP
*B.REP Number of towers  (endcap = 1)  168 towers 6 words
*B.1   Bitmask set if hot left tower.
*B/REP
*B.REP Number of strip modules (endcap 0). (32 strips/module) 5 words.
*B.1   Bitmask set if hot right strip.
*B/REP
*B.REP Number of strip modules (endcap 1). (32 strips/module) 5 words.
*B.1   Bitmask set if hot left strip.
*B/REP
*B.1   Deadtime of right endcap.  (0.1 msec)
*B.1   Deadtime of left endcap.   (0.1 msec)
*B.1   Energy in right endcap.    (10 mev)
*B.1   Energy in left endcap.     (10 mev)
*B.REP Number of towers  (endcap = 0)  168 towers 6 words
*B.1   Bitmask set if HV 1 on.
*B/REP
*B.REP Number of towers  (endcap = 0)  168 towers 6 words
*B.1   Bitmask set if HV 2 on.
*B/REP
*B.REP Number of towers  (endcap = 1)  168 towers 6 words
*B.1   Bitmask set if HV 1 on.
*B/REP
*B.REP Number of towers  (endcap = 1)  168 towers 6 words
*B.1   Bitmask set if HV 2 on.
*B/REP
*B/DATA
*B/        End of bank descriptor
+DECK,HPRS.
*B..HPRS   Hadron Pole Tip Raw Strip Data Bank (Endcap = 2)
*B.NL 0
*B.NS 0
*B.ND *
*B.UP      HPRA
*B.OR      HPRA
*B.DATA
*B.REP Number of strips  (endcap = 2)
*B.1   65536*JSTRIP+MSTRIP,(JSTRIP = 32768*ICAP+2048*ISEG+128*ILAY+ISTR)
*B/REP
*B/DATA
*B/        Tower Information (endcap = 2)
+DECK,HPRT.
*B..HPRT   Hadron Pole Tip Raw Data Tower Bank (Endcap = 2)
*B.NL 0
*B.NS 0
*B.ND *
*B.UP      HPRA
*B.OR      HPRA
*B.DATA
*B.REP Number of towers  (endcap = 2)
*B.1   65536*JTOWER+IPULSE,(JTOWER = 32768*ICAP+256*ISEG+IPAD)
*B/REP
*B/DATA
*B/        Tower Information (endcap = 2)
+DECK,JETS.
*B..JETS Generated partons
*B.AU    S.L.Lloyd
*B.ST    IXSTOR
*B.DV    IXDIV
*B.NL 0
*B.NS 0
*B.ND *
*B.UP GENE -2
*B.OR GENE -2
*B.DATA
*B.REP NJET
*B.1  I Flavour
*B.2  I Number of parent particle in tree
*B.3  I Number of decay particle in tree
*B.4  R Px
*B.5  R Py
*B.6  R Pz
*B.7  R Energy
*B.8  R Mass
*B/REP NJET
*B/DATA
*B/
+DECK,KINE
*B..KINE    GEANT track bank
*B.ND        *
*B.NS        0
*B.UP    KINH         1
*B.DATA
*B.1   PX      Px (GeV/c)
*B.2   PY      Py (GeV/c)
*B.3   PX      Pz (GeV/c)
*B.4   ENERGY  E  (GeV)
*B.5   IPART   GEANT particle code
*B.6   IVORIG  Vertex number at which created
*B.7   MVERTX  Number of vertices created by this particle
*B.REP MVERTX
*B.1   IVERTX  Vertex number created by this particle
*B/REP
*B/DATA
*B/
+DECK,KINH
*B..KINH     GEANT track header bank
*B.ND        1
*B.NS        *
*B.UP   MC          3
*B.LINK
*B.REP  NTRACK
*B.1   KINE   GEANT track bank
*B/REP
*B/LINK
*B.DATA
*B.1    NTRACK Total number of tracks
*B/DATA
*B/
+DECK,MBMC
*B..MBMC    MB cheat words
*B.ND       *
*B.NS       0
*B.UP  CHEA -12
*B.DATA
*B.1       MMCHLN    Number of cheat words per hit (REAL).
*B.2       MMCHNH    Total number of hits (REAL)
*B.REP MMCHNH
*B.1       MMCHXX    X co-ordinate of hit
*B.2       MMCHYY    Y co-ordinate of hit
*B.3       MMCHZZ    Z co-ordinate of hit
*B.4       MMCHPX    X component of momenta at (X,Y,Z)
*B.5       MMCHPY    Y component of momenta at (X,Y,Z)
*B.6       MMCHPZ    Z component of momenta at (X,Y,Z)
*B.7       MMCHLN    Length of track in sensitive volume
*B.8       MMCHTY    Geant particle code (REAL)
*B.9       MMCHTK    GEANT track number  (REAL)
*B.10      MMCHVX    Vertex number       (REAL)
*B/REP
*B/DATA
*B/
+DECK,MC.
*B..MC   Monte Carlo header
*B.AUTH  D.R.Ward
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    20
*B.NL    6
*B.NS    6
*B.NX    None
*B.UP    EX  -2
*B.OR    EX  -2
*B.LINK
*B.1 GENE  Link to Generated tracks banks (TREE and JETS)
*B.2 VERH  GEANT VERTX banks - (obsolete)
*B.3 KINH  GEANT KINE banks - (obsolete)
*B.4 CHEA  Link to 'cheat words' header
*B.5 ODEM  OD EM cheat words (lifted by OD)
*B.6 ODHM  OD HM cheat words (lifted by OD)
*B/LINK
*B.DATA
*B.1 IKINE  Event type (= IKINE data word of GOPAL)
*B.2 NVERTX Number of vertices
*B.3 NTRACK Number of tracks
*B.4 IFCHEA Flag for cheat words
*B.5 NRNDM(1) Random number seed (first part)
*B.6 NRNDM(2) Random number seed (second part)
*B.7 IGOVER GOPAL version number
*B.8 IGOSVE GOPAL sub-version number
*B.9 IGEVER GEANT version number
*B.10 LASTMO date (yymmdd) of last dated GOPAL corrections
*B.11 ??????
*B.12 ??????
*B.13 KTRIG1 Trigger word (G. Quast)
*B.14 KTRIG2 Trigger word (G. Quast)
*B.15 KTRIG3 Trigger word (G. Quast)
*B.16 KTRIG4 Trigger word (G. Quast)
*B.17 IGOLEV GOPAL simulation level (FULL/SMEAR etc.)
*B.17  BITVAL00  CD FULL
*B.17  BITVAL01  CD FAST
*B.17  BITVAL02  CD SMEA
*B.17  BITVAL03  CAL FULL
*B.17  BITVAL04  CAL FAST
*B.17  BITVAL05  CAL BOOT
*B.17  BITVAL06  CAL SMEA
*B.17  BITVAL07  FD FULL
*B.17  BITVAL08  PS FULL
*B.17  BITVAL09  SI FULL
*B.17  BITVAL10  SI FAST
*B.17  BITVAL11  SI SMEA
*B.17  BITVAL12  SM fast tracking
*B.17  BITVAL13  SM extrapolation
*B/DATA
*B/
+DECK,MCC .
*B..MCC  Monte Carlo-specific constants
*B.AUTH  D.R.Ward
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IXCONS
*B.ND    4
*B.NL    4
*B.NS    4
*B.NX    None
*B.UP    EXC -2
*B.OR    EXC -2
*B.LINK
*B.1 ????  Spare
*B.2 MCDO  Used for *SKIP and *SELECT cards
*B.3 ????  Spare
*B.4 ????  Spare
*B/LINK
*B.DATA
*B.1 ????
*B.2 ????
*B.3 ????
*B.4 ????
*B/
+DECK,MCDO.
*B..MCDO Stores contents of *SKIP and *SELECT cards
*B.AUTH  D.R.Ward
*B.VERS  1.00
*B.ST    IXSTOR
*B.DV    IXCONS
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    None
*B.UP    MCC -2
*B.OR    MCC -2
*B.LINK
*B/LINK
*B.DATA
*B.1       ITYP  1=>SKIP  2=> SELECT
*B.2       NLIST Number of event numbers in the list
*B.3       IEV1  First event number
*B.2+NLIST IEVN  NLIST'th event number
*B/
+DECK,MECH
*B..MECH    ME cheat words
*B.ND       *
*B.NS       0
*B.UP  CHEA -13
*B.DATA
*B.1       MMCHLN    Number of cheat words per hit (REAL).
*B.2       MMCHNH    Total number of hits (REAL)
*B.REP MMCHNH
*B.1       MMCHXX    X co-ordinate of hit
*B.2       MMCHYY    Y co-ordinate of hit
*B.3       MMCHZZ    Z co-ordinate of hit
*B.4       MMCHPX    X component of momenta at (X,Y,Z)
*B.5       MMCHPY    Y component of momenta at (X,Y,Z)
*B.6       MMCHPZ    Z component of momenta at (X,Y,Z)
*B.7       MMCHLN    Length of track in sensitive volume
*B.8       MMCHTY    Geant particle code (REAL)
*B.9       MMCHTK    GEANT track number  (REAL)
*B.10      MMCHVX    Vertex number       (REAL)
*B/REP
*B/DATA
*B/
+DECK,MECN
*B..MECN    ME various offline constants
*B.ND     10
*B.NS      0
*B.UP  MECT      4
*B.DATA
*B.REP   10
*B.1          Not yet used
*B/REP
*B/DATA
*B/
+DECK,MECT
*B..MECT    ME calibration constants header bank
*B.ND      0
*B.NL      5
*B.NS      5
*B.UP  DAC       13
*B.LINK
*B.1 MESF
*B.2 MESI
*B.3 MEGM
*B.4 MECN
*B.5 MEDR
*B/LINK
*B/
+DECK,MEDR
*B..MEDR    ME dead region data
*B.ND     2000
*B.NS      0
*B.UP  MECT      5
*B.DATA
*B.1   NRGDED   Number of dead regions
*B.REP NRGDED   Packed data words for each region
*B.1   IDEDWD   Packed data word (see documentation in ME....)
*B/REP
*B/DATA
*B/
+DECK,MEGM
*B..MEGM    ME various geometrical consants
*B.ND      8
*B.NS      0
*B.UP  MECT      3
*B.DATA
*B.1 SWID     strip width of perpendicular strips
*B.2 SWIPL    strip width of parallel strips
*B.3 CMEME    z-coord of centre of Muon Endcaps
*B.4 CMEMD    z-coord of module relative to flatbed centre
*B.5 SMAGAP   gap between the units for parallel strips
*B.6          Not yet used
*B.7          Not yet used
*B.8          Not yet used
*B/DATA
*B/
+DECK,MERA
*B..MERA    ME raw data
*B.ND      *
*B.NS      0
*B.UP  DA        13
*B.DATA
*B.1  NTRIG    Number of trigger words (=34 at present)
*B.REP NTRIG   Trigger words (Not stored in GOPAL)
*B.1           Trigger word
*B/REP
*B.36  NEXTRA  Number of extra words allowed
*B.37  NACTIV  Number of active plane-quadrants
*B.REP NACTIV  Data for each plane-quadrant
*B.1   NSTR    Number of active strips in this plane-quadrant
*B.REP NSTR    Packed data words for each strip
*B.1   MEDATA  Packed data word (see documentation in MEDIGI)
*B/REP
*B/REP
*B/DATA
*B/
+DECK,MESF
*B..MESF    ME rolling frame survey data
*B.ND      216
*B.NS      0
*B.UP  MECT      1
*B.DATA
*B.REP   4
*B.REP   6
*B.REP   3
*B.1  FRAMES   x-coord of survey dowell peg (IDWL1,IQD.KPL)
*B.2  FRAMES   y-coord
*B.3  FRAMES   z-coord
*B/REP
*B/REP
*B/REP
*B/DATA
*B/
+DECK,MESI
*B..MESI    ME internal survey data for each flatbed
*B.ND      2448
*B.NS      0
*B.UP  MECT      2
*B.DATA
*B.REP   4
*B.REP   6
*B.REP   2
*B.REP   17
*B.1  FRAMES   x-coord of survey dowell peg (IDWL2,IEND,IQD.KPL)
*B.2  FRAMES   y-coord
*B.3  FRAMES   z-coord
*B/REP
*B/REP
*B/REP
*B/REP
*B/DATA
*B/
+DECK,PBMC
*B..PBMC PB cheat word banks
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    0
*B.NL    16
*B.NS    16
*B.NX    0
*B.UP CHEA -5
*B.OR CHEA -5
*B.LINK
*B.REP NSECT number of sectors (16)
*B.1 PBMS MC cheat words for each PB sector ISECT (ISECT=1,16)
*B/REP
*B/
+DECK,PBMI
*B..PBMI track bank from hits in PB
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PBMS -1
*B.OR PBMS -1
*B.DATA
*B.REP NHITCL number of hits clusters in PB
*B.1 ITRACK track number that produced the hits cluster
*B/REP
*B/
+DECK,PBMJ
*B..PBMJ particle code bank from hits in PB
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PBMS -2
*B.OR PBMS -2
*B.DATA
*B.REP NHITCL number of hits clusters in PB
*B.1 IPART particle code that produced the hits cluster
*B/REP
*B/
+DECK,PBMH
*B..PBMH number of hits from hits in PB
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PBMS -7
*B.OR PBMS -7
*B.DATA
*B.REP NHITCL number of hits clusters in PB
*B.1 INBHIT number of hits in the hits cluster
*B/REP
*B/
+DECK,PBMM
*B..PBMM average momentum bank from hits in PB
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PBMS -3
*B.OR PBMS -3
*B.DATA
*B.REP NHITCL number of hits clusters in PB
*B.1 IPMOM average momentum of particles that produced the hits cluster
*B/REP
*B/
+DECK,PBMP
*B..PBMP phi bank from hits in PB
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PBMS -6
*B.OR PBMS -6
*B.DATA
*B.REP NHITCL number of hits clusters in PB
*B.1 IPHI  average phi of the hits cluster
*B/REP
*B/
+DECK,PBMS
*B..PBMS PB cheat word for each sector
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    1
*B.NL    7
*B.NS    7
*B.NX    0
*B.UP PBMC -ISECT (ISECT=sector number)
*B.OR PBMC -ISECT (ISECT=sector number)
*B.LINK
*B.1  PBMI track number bank
*B.2  PBMJ particule code bank
*B.3  PBMM momentum bank
*B.4  PBMV vertex bank
*B.5  PBMT theta bank
*B.6  PBMP phi bank
*B.7  PBMH number of hits bank
*B/LINK
*B.DATA
*B.1  NHITCL number of hits clusters in this sector
*B/DATA
*B/
+DECK,PBMT
*B..PBMT theta bank from hits in PB
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PBMS -5
*B.OR PBMS -5
*B.DATA
*B.REP NHITCL number of hits clusters in PB
/B.1 ITHETA average theta of the hits cluster
*B/REP
*B/
+DECK,PBMV
*B..PBMV vertex number bank from hits in PB
*B.AUTH  A. Possoz
*B.VERS  1.1
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PBMS -4
*B.OR PBMS -4
*B.DATA
*B.REP NHITCL number of hits clusters in PB
*B.1 IVERTX vertex number of the track that produced the hits cluster
*B/REP
*B/
+DECK,PBRA
*B..PBRA PB raw data after preprocessor
*B.AUTH  A. Possoz
*B.VERS 2.0
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    1
*B.NS    1
*B.NX    0
*B.IO    *B
*B.UP DA   -5
*B.OR DA   -5
*B.LINK
*B.1 PBUP PB unpacked raw data
*B/LINK
*B.DATA
*B.1 NTWOBT  Number of 16 bit words in raw data structure
*B.1         (+4 for real data)
*B.REP NCLSTR
*B.2 ADDU      Address of the first strip and cluster length
*B.2           Bits 0-8 Length of cluster (LEN)
*B.2           Bits 16-24 First strip number
*B.2 BITVAL25  V strip
*B.2           Bits 26-29 Sector-1
*B.2 BITVAL31  Address Flag
*B.2           In case of Monte Carlo, word order is switched
*B.REP LEN     (packed, 16 bit words)
*B.3 IAMP      Strip Pulse Height (ADC Counts) (Lower 16 bits)
*B.3 BITVAL15  Low gain measurement
*B/REP
*B/REP
*B.REP NCLW
*B.1 ADDU      Address of the first wire (0-95) and cluster length
*B.1           Bits 0-8 two times number of wires in cluster (2*LEN)
*B.1           Bits 16-24 First strip number
*B.1 BITVAL25  First wire in cluster is wire on outer layer
*B.1 BITVAL26  Wire Cluster
*B.1           Bits 26-29 Sector-1
*B.1 BITVAL31  Address Flag
*B.1           In case of Monte Carlo, word order is switched
*B.REP LEN (may not coincide with longword boundaries)
*B.2 IAMP      Bits 0-13 Sum of right and left wire pulse heights
*B.2             in ADC Counts (with nominal pedestal)
*B.2 BITVAL15  Low gain measurement
*B.2           Bits 16-29 Difference of left and right pulse heights
*B.2            (left-right) in ADC Counts
*B.2 BITVAL31 Difference is negative - subtract 65536 from bits 16-29
*B.2          In case of Monte Carlo, word order is switched
*B/REP
*B/REP
*B.REP 16 (packed, 4 bit words)
*B.1 IVOLT  Chamber voltage flag where voltage = 3300V + IVOLT*100V
*B.1 C0     Chamber is not functioning
*B/REP
*B.1 IGAIN  Global gain (16 bits)
*B.1 IGRMS  Global gain RMS * 10 (16 bits)
*B/
+DECK,PERA
*B..PERA PE raw data
*B.AUTH  D.Hochman, D.Lellouch
*B.VERS 1.0
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    5
*B.NL    1
*B.NS    1
*B.NX    0
*B.UP DA   -7
*B.OR DA   -7
*B.LINK
*B.1  PEAP    PE address and pulse height.
*B.DATA
*B.1  HVSTAT    High voltage status bit mask. (Update per/event)
*B.2  ELSTAT    Electronic status bit mask.   (Update per/event)
*B.3  RDSTAT    Readout status bit mask.      (Update per run)
*B.4  spare
*B.5  spare
*B/DATA
*B/
+DECK,PEAP
*B..PEAP PE address and pulse height
*B.AUTH  D.Hochman, D.Lellouch
*B.VERS 1.0
*B.ST    IXSTOR
*B.DV    IXDIV
*B.ND    *
*B.NL    0
*B.NS    0
*B.NX    0
*B.UP PERA -1
*B.OR PERA -1
*B.LINK
*B.DATA
*B.REP ND
*B.1  IRAWAD    Raw data, two 16 bit words packed...
*B.     Module descriptor and pulse height       IRAWAD IRAWPH
*B.
*B. IRAWAD IRAWPH are packed into 32 bit words so
*B.
*B.     word = 65536*IRAWAD + IRAWPH
*B.
*B.     IRAWAD = 32768*ICAP + 256*ISEC + IMDL
*B.
*B.          ICAP = Endcap       (0-1)
*B.          ISEC = Sector       (0-15)
*B.          IMDL = Small Pad    (1-10)
*B.               = Small Strip  (11-32)
*B.               = Big Wire     (33-142)
*B.               = Big Pad      (145-160)
*B.               = Big Strip    (161-192)
*B/REP
*B/DATA
*B/
+DECK,TBMB
*B..TBMB     TB hit bar
*B.ND       *
*B.NS       0
*B.UP  TBMC       9
*B.DATA
*B.REP NTBMC
*B.1   IBAR
*B/REP
*B/DATA
*B/
+DECK,TBMC
*B..TBMC    TB cheat words header
*B.ND       1
*B.NS      11
*B.UP  CHEA       4
*B.LINK
*B.1  TBMI    TB hit track numbers
*B.2  TBMJ    TB hit particle codes
*B.3  TBMM    TB hit momentum
*B.4  TBMV    TB hit vertex no
*B.5  TBMT    TB hit theta
*B.6  TBMP    TB hit phi
*B.7  TBMH
*B.8  TBMF    TB hit TOF
*B.9  TBMB    TB hit bar
*B.10  TBME   TB hit Dlen
*B.11  TBMS   TB hit Slen
*B/LINK
*B.DATA
*B.1  NTBMC Number of hits in the following banks.
*B/DATA
*B/
+DECK,TBME
*B..TBME     TB hit Dlen
*B.ND       *
*B.NS       0
*B.UP  TBMC      10
*B.DATA
*B.REP NTBMC
*B.1   DLEN
*B/REP
*B/DATA
*B/
+DECK,TBMF
*B..TBMF     TB hit TOF
*B.ND       *
*B.NS       0
*B.UP  TBMC       8
*B.DATA
*B.REP NTBMC
*B.1   TOF      TOF
*B/REP
*B/DATA
*B/
+DECK,TBMH
*B..TBMH    TB hit ?
*B.ND       *
*B.NS       0
*B.UP  TBMC       7
*B.DATA
*B.REP NTBMC
*B.1   NS     ?
*B/REP
*B/DATA
*B/
+DECK,TBMI
*B..TBMI      TB hit track numbers
*B.ND       *
*B.NS       0
*B.UP  TBMC       1
*B.DATA
*B.REP NTBMC
*B.1   ITRA   Track number
*B/REP
*B/DATA
*B/
+DECK,TBMJ
*B..TBMJ     TB hit particle codes
*B.ND       *
*B.NS       0
*B.UP  TBMC       2
*B.DATA
*B.REP NTBMC
*B.1   IPART  Particle code (GEANT)
*B/REP
*B/DATA
*B/
+DECK,TBMM
*B..TBMM     TB hit momentum
*B.ND       *
*B.NS       0
*B.UP  TBMC       3
*B.DATA
*B.REP NTBMC
*B.1   PMOM   Momentum
*B/REP
*B/DATA
*B/
+DECK,TBMP
*B..TBMP     TB hit phi
*B.ND       *
*B.NS       0
*B.UP  TBMC       6
*B.DATA
*B.REP NTBMC
*B.1   PHI    phi
*B/REP
*B/DATA
*B/
+DECK,TBMS
*B..TBMS     TB hit SLen
*B.ND       *
*B.NS       0
*B.UP  TBMC      11
*B.DATA
*B.REP NTBMC
*B.1   SLEN
*B/REP
*B/DATA
*B/
+DECK,TBMT
*B..TBMT    TB hit theta
*B.ND       *
*B.NS       0
*B.UP  TBMC       5
*B.DATA
*B.REP NTBMC
*B.1   THETA  Theta
*B/REP
*B/DATA
*B/
+DECK,TBMV
*B..TBMV    TB hit vertex
*B.ND       *
*B.NS       0
*B.UP  TBMC       4
*B.DATA
*B.REP NTBMC
*B.1   IVERT  vertex number
*B/REP
*B/DATA
*B/
+DECK,TREE.Available in sequence GOPAR
*B..TREE Tree of generated particles.
*B.AU    S.L.Lloyd
*B.ST    IXSTOR
*B.DV    IRODIV
*B.NL    0
*B.NS    0
*B.ND    *
*B.NX    None
*B.UP    GENE -1
*B.OR    GENE -1
*B.DATA
*B.REP NGEN
*B.1   ITRTY    Particle Data Group particle code
*B.2   ITRPAR   Number of parent in tree
*B.3   ITRFSEC  Number of first secondary in tree
*B.4   ITRNSEC  Number of secondaries
*B.5   ITRNDST  Track number in DST structure
*B.6   ITRNJET  Jet number
*B.7   ITRKINE  Number of KINE bank for this particle
*B.8   ????     Spare
*B.9   ITRSTAR  Start flag
*B.9   C0000000 Initial state photon
*B.9   C0000001 Primary particle
*B.9   C0000002 Decay product in generator
*B.9   C0000003 Transfered from GEANT stack
*B.9   C0000004 Unknown
*B.9   C0000005 Decay product in GEANT
*B.9   C0000006 Pair production
*B.9   C0000007 Compton
*B.9   C0000008 Photoelectric
*B.9   C0000009 Bremsstrahlung
*B.9   C0000010 Delta ray
*B.9   C0000011 Positron annihilation
*B.9   C0000012 Hadronic interaction
*B.10  ITREND   End flag
*B.10  C0000001 Neutral and still alive
*B.10  C0000002 Charged and still alive
*B.10  C-000001 Decayed in generator
*B.10  C-000005 Decay product in GEANT
*B.10  C-000006 Pair production
*B.10  C-000007 Compton
*B.10  C-000008 Photoelectric
*B.10  C-000009 Bremsstrahlung
*B.10  C-000010 Delta ray
*B.10  C-000011 Positron annihilation
*B.10  C-000012 Hadronic interaction
*B.11  TRPX     Px
*B.12  TRPY     Py
*B.13  TRPZ     Pz
*B.14  TRE      Energy
*B.15  TRM      Mass
*B.16  TRCH     Charge
*B.17  TRSX     Start x
*B.18  TRSY     Start y
*B.19  TRSZ     Start z
*B.20  TREX     End x
*B.21  TREY     End y
*B.22  TREZ     End z
*B/REP NGEN
*B/DATA
*B/
+DECK,VERT.
*B..VERT    GEANT VERTEX bank
*B.ND        *
*B.NS        1
*B.UP   VERH        1
*B.LINK
*B.1  VERU    User words.
*B/LINK
*B.DATA
*B.1    XVERT  x (cm)
*B.2    YVERT  y (cm)
*B.3    ZVERT  z (cm)
*B.4    TIME   time of flight
*B.5    NTBEAM track number of incoming particle
*B.6    NTTARG track number of target
*B.7    MTRACK Number of tracks generated
*B.REP  MTRACK
*B.1    ITRACK track number of daughter
*B/REP
*B/DATA
*B/
+DECK,VERH.
*B..VERH      GEANT VERTEX header bank
*B.ND        1
*B.NS        *
*B.UP   MC          2
*B.LINK
*B.REP NVERT
*B.1   VERT
*B/REP
*B/LINK
*B.DATA
*B.1 NVERT  Number of vertices
*B/DATA
*B/
+DECK,VERU.
*B..VERU      GEANT vertex user words (secondary vertices).
*B.ND        *
*B.NS        0
*B.UP   VERT     1
*B.DATA
*B.1  VOLU  volume name in which vertex was created (Hollerith)
*B.REP NMEC
*B.1  NAMEC Mechanism(s) at this vertex (Hollerith)
*B/REP
*B/DATA
*B/
+DECK,XTRA.
*B..XTRA Extra generator information
*B.AU    S.L.Lloyd
*B.ST    IXSTOR
*B.DV    IXDIV
*B.NL 0
*B.NS 0
*B.ND *
*B.UP GENE -3
*B.OR GENE -3
*B.DATA
*B.1  R Fragmentation z for b quark      (-1 if absent)
*B.2  R Fragmentation z for anti-b quark (-1 if absent)
*B.3  R Transverse mass for b quark      (-1 if absent)
*B.4  R Transverse mass for anti-b quark (-1 if absent)
*B.5  R Fragmentation z for c quark      (-1 if absent)
*B.6  R Fragmentation z for anti-c quark (-1 if absent)
*B.7  R Transverse mass for c quark      (-1 if absent)
*B.8  R Transverse mass for anti-c quark (-1 if absent)
*B.9  R Negative tau helicity            ( 0 if absent)
*B.10 R Positive tau helicity            ( 0 if absent)
*B/DATA
*B/
+PATCH,INSTALL
+DECK,VAXGEN.    Generate .OLB file on VAX/VMS
$! GO139GEN.COM  Generate GOPAL     OBJ/OLB files.
$! Version for batch use, with graphics.
$!
$ YPATCHY
- GOPAL139 TTP TTY .GO
%EXE.
%USE,VAX.
%USE,TYPE.
%USE,HIGZ.
%USE,GHEISHA.
%USE,NOGENLIB,T=E.        
%USE,GCDES,GOCDES,GSCDES,ROCDES.
%USE,TRCDES,SICDES,CVCDES,CTCDES,CXCDES,CECDES,EECDES,EMCDES,MBCDES.
%USE,HBCDES,MMCDES,FDCDES,ODCDES,CZCDES,TBCDES,HPCDES,MECDES,JCCDES.
%USE,SWCDES,PBCDES.
%USE,OBASE,OGEOM,OHITS,ODIGI,OSMEAR,GUFLDFUL,OTRIG,OCJ.
%EXE,OBASE,OGEOM,OHITS,ODIGI,OSMEAR,GUFLDFUL,OTRIG,OCJ.
%ADD,GCDES,BLANKDEK,401.
      REAL ZZFU,ZZFV
      INTEGER MYISEL
%KEEP,LASTMOD. << GOPAL139/01
      LASTMO = 971117
%PAM,11,R=GCDES ,T=ATTACH,T=CARDS. GEANTCAR!
%PAM,12,R=ROCDES,T=ATTACH,T=CARDS. ROPECAE!
%PAM,12,R=TRCDES,T=ATTACH,T=CARDS. TRCAR!
%PAM,12,R=SICDES,T=ATTACH,T=CARDS. SICAR!
%PAM,12,R=CVCDES,T=ATTACH,T=CARDS. CVCAR!
%PAM,12,R=JCCDES,T=ATTACH,T=CARDS. JCCAR!
%PAM,12,R=CTCDES,T=ATTACH,T=CARDS. CTCAR!
%PAM,12,R=CXCDES,T=ATTACH,T=CARDS. CXCAR!
%PAM,12,R=CZCDES,T=ATTACH,T=CARDS. CZCAR!
%PAM,12,R=CECDES,T=ATTACH,T=CARDS. CECAR!
%PAM,12,R=PBCDES,T=ATTACH,T=CARDS. PBCAR!
%PAM,12,R=EECDES,T=ATTACH,T=CARDS. EECAR!
%PAM,12,R=EMCDES,T=ATTACH,T=CARDS. EMCAR!
%PAM,12,R=HBCDES,T=ATTACH,T=CARDS. HBCAR!
%PAM,12,R=HPCDES,T=ATTACH,T=CARDS. HPCAR!
%PAM,12,R=MBCDES,T=ATTACH,T=CARDS. MBCAR!
%PAM,12,R=MECDES,T=ATTACH,T=CARDS. MECAR!
%PAM,12,R=MMCDES,T=ATTACH,T=CARDS. MMCAR!
%PAM,12,R=FDCDES,T=ATTACH,T=CARDS. FDCAR!
%PAM,12,R=TBCDES,T=ATTACH,T=CARDS. TBCAR!
%PAM,12,R=ODCDES,T=ATTACH,T=CARDS. ODCAR!
%PAM,12,R=SWCDES,T=ATTACH,T=CARDS. SWCAR!
%PAM,13,         T=ATTACH,T=CARDS. GOPALCAR!
%PAM,13,         T=ATTACH,T=CARDS. GOPAGCAR!
%PAM,13,         T=ATTACH,T=CARDS. GOPAHCAR!
%PAM,13,         T=ATTACH,T=CARDS. GOPADCAR!
%PAM,13,         T=ATTACH,T=CARDS. GOPATCAR!
%PAM,13,         T=ATTACH,T=CARDS. GOPAJCAR!
%PAM,13,         T=ATTACH,T=CARDS. GOPASCAR!
%QUIT.
$ FOR GOPAL/NOLIST/WARNING/STANDARD=ALL
$ LIB/CREATE GOPALLIB GOPAL
+DECK,OSFGEN.    Generate library on AXP/OSF
#                   
# @$-o /opal/com/gopal139gen.log
# @$-eo
# @$-x 
# @$   
#                   
cd  /opal/com
rm -f temp.cra 
cat >temp.cra <<EOF
%USE,QMVAOS,DECS.                                                               
%USE,TYPE.                                                                      
%USE,HIGZ.                                                                      
%USE,GHEISHA.                                                                   
%USE,NOGENLIB,T=E.        (otherwise POISSN calls RNDM)                         
%USE,GCDES,GOCDES,GSCDES,ROCDES.                                                
%USE,TRCDES,SICDES,CVCDES,CTCDES,CXCDES,CECDES,EECDES,EMCDES,MBCDES.            
%USE,HBCDES,MMCDES,FDCDES,ODCDES,CZCDES,TBCDES,HPCDES,MECDES,JCCDES.            
%USE,SWCDES,PBCDES.                                                             
%USE,OBASE,OGEOM,OHITS,ODIGI,OSMEAR,GUFLDFUL,OTRIG,OCJ.                         
%EXE,OBASE,OGEOM,OHITS,ODIGI,OSMEAR,GUFLDFUL,OTRIG,OCJ.                         
%ADD,GCDES,BLANKDEK,401.                                                        
      REAL ZZFU,ZZFV                                                            
      INTEGER MYISEL                                                            
%KEEP,LASTMOD. << GOPAL139/01                                                   
      LASTMO = 971117                                                          
%PAM,11,R=GCDES ,T=C,ATTACH,T=CARDS. /user2/opal/geant/geant321.car             
%PAM,12,R=ROCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope414/rope414.car            
%PAM,12,R=TRCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/tr212.car              
%PAM,12,R=SICDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/si210.car              
%PAM,12,R=CVCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/cv335.car              
%PAM,12,R=JCCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/jc315.car              
%PAM,12,R=CTCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/ct315.car              
%PAM,12,R=CXCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/cx224.car              
%PAM,12,R=CZCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/cz327.car              
%PAM,12,R=CECDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/ce319.car              
%PAM,12,R=PBCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/pb322.car              
%PAM,12,R=EECDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/ee231.car              
%PAM,12,R=EMCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/em317.car              
%PAM,12,R=HBCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/hb318.car              
%PAM,12,R=HPCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/hp225.car              
%PAM,12,R=MBCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/mb222.car              
%PAM,12,R=MECDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/me422.car              
%PAM,12,R=MMCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/mm213.car              
%PAM,12,R=FDCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/fd428.car              
%PAM,12,R=TBCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/tb422.car              
%PAM,12,R=ODCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/od414.car              
%PAM,12,R=SWCDES,T=C,ATTACH,T=CARDS. /user2/opal/rope407/sw110.car              
%PAM,13,         T=C,ATTACH,T=CARDS. /user2/opal/geant/gopal139.car             
%PAM,13,         T=C,ATTACH,T=CARDS. /user2/opal/geant/gopag139.car             
%PAM,13,         T=C,ATTACH,T=CARDS. /user2/opal/geant/gopah139.car             
%PAM,13,         T=C,ATTACH,T=CARDS. /user2/opal/geant/gopad139.car             
%PAM,13,         T=C,ATTACH,T=CARDS. /user2/opal/geant/gopat139.car             
%PAM,13,         T=C,ATTACH,T=CARDS. /user2/opal/geant/gopaj139.car             
%PAM,13,         T=C,ATTACH,T=CARDS. /user2/opal/geant/gopas139.car             
%QUIT.                                                                          
EOF
/cern/cernlib/94a/bin/ypatchy - gopal133 temp tty .go
ls -l
mkdir qwerty
mv gopal139.f qwerty/gopal139.f
cd    qwerty
fsplit gopal139.f
rm -f gopal139.f
f77 *.f -c -w -assume backslash 
ar cq gopal139.a *.o
ranlib gopal139.a
chmod o+r gopal139.a
chmod g+r gopal139.a
mv gopal139.a /opal/lib/gopal139.a
rm -f *
cd  /opal/com
rmdir qwerty
+PATCH,EXAMPLES
+DECK,RUNVAX.    Example job to run GOPAL on VAX/VMS
$!
$!   CREATE GOPAL.EXE
$!
$ SET VERIFY=NOIM
$ SET DEF [CPW1.GOPAL]
$NEWCODE
$
$ YPATCHY
- GOPAL TTY TTY .GO
%EXE,CRA*.
%OPT,M.
%USE,P=GCDES.
%USE,GOCDES,VAX.
%USE,ROCDES.
%USE,P=BATCH,T=E.
%LIS,P=BATCH,D=MAIN.
%KEEP,KSPACE.
      PARAMETER (KSPACE=300000)
%KEEP,JSPACE.
      PARAMETER (JSPACE=2200000)
%USE,TYPE.     
%USE,GHEISHA.
%USE,RNDM.
%USE,MYCODE,T=E.
%PAM,11,R=GCDES,T=A,C.  GEANTCAR! 
%PAM,12,R=ROCDES,T=A,C. ROPECAR! 
%PAM,13,T=A,C.          GOPALCAR!
%USE,ODCDES.
%PAM,11,T=A,C,R=ODCDES.  ODCAR!
%PATCH,MYCODE.
%DECK,RLU.
      FUNCTION RLU(I)
      REAL RLU,R
      INTEGER I
      CALL GRNDM(R,1)
      RLU=R
      END
%QUIT.
$
$ FOR/nolist/standard GOPAL
$
$ LIN/NOMAP/EXE=WORK:GORO139.EXE -
GOPAL,-                              ! Main program
O$GEN:JETSET74,-
SYS$INPUT/OPT        
GOPALLIB/L,GEANTLIB/L,ROPELIB/L
DXLIB/L           
DDLIB/L,OPLIB/L
LLLIB/L,FILIB/L
CELIB/L
CSLIB/L,CTLIB/L,CVLIB/L,CZLIB/L,SILIB/L,CXLIB/L   
JCLIB/L,CJLIB/L,OPLIB/L,JCLIB/L        
EMLIB/L,EELIB/L,EBLIB/L,PBLIB/L,PELIB/L,TBLIB/L  
MMLIB/L,MBLIB/L,MELIB/L
HBLIB/L,HPLIB/L
SWLIB/L,FDLIB/L,LMLIB/L
ODLIB/L
OCLIB/L,OULIB/L,TRLIB/L,PXLIB/L    
ROPELIB/L,DUMMYLIB/L
CERN$LIBRARY:MATHLIB/L,PACKLIB/L,KERNLIB/L
SYS$LIBRARY:VAXCRTL/L
ISD_MAX=500 
$PU work:*.*
$PU GOPAL.*
$
$
$R WORK:GORO139
C   ===================== START GOPAL DATA CARDS ===================   
LIST
SI    'FULL'
CD    'FULL'       
CAL   'FULL'
CHEA  'ALL '                       
*FILE 'KINE' 'IN  ' 33 5='B' 7='DISK$OPAL:[OPAL.CPW1.MC]JT5555.KIDISK'
*FILE 'DDST' 'OUT ' 23 7='WORK$CBHPAA:JT5555_K.FZDDST'
C    *FILE 'RUN ' 'IN  ' 55 7='DISK$OPAL:[OPAL.CPW1.MC]JT5555.RUN'
EXPT  4
SWIT  0 0 0 0 0
DEBU  1 1 1
KINE 7 
TRIG 5
RUNG 5555 1
RNDM  322191718  1368764924  
END
C   ===================== START ROPE DATA CARDS ===================   
LIST  
MONITOR
RERUN 'ALL '
END
+DECK,RUNOSF.    Example job to run GOPAL on AXP/OSF
# @$-o /usera/cpw1/gopal/goro139.log
# @$-eo
# @$-x
# @$
#
limit
cd /usera/cpw1/gopal
rm -f temp.cra
cat >temp.cra <<EOF
%EXE,CRA*.
%USE,QMALOS,DECS.
%OPT,M.
%USE,P=GCDES.
%USE,GOCDES.
%USE,ROCDES.
%USE,P=BATCH,T=E.
%KEEP,KSPACE.
      PARAMETER (KSPACE=100000)
%KEEP,JSPACE.
      PARAMETER (JSPACE=1999999)
%USE,TYPE.      
%USE,DUMMY,T=E.
%USE,GHEISHA. 
%USE,ODCDES.
%PAM,11,T=A,C,R=ODCDES.   /user2/opal/rope414/od414.car
%PAM,11,R=GCDES,T=A,C.   /user2/opal/geant/geant321.car
%PAM,12,R=ROCDES,T=A,C.  /user2/opal/rope414/rope414.car
%PAM,13,T=A,C.   /user2/opal/geant/gopal139.car
%PATCH,DUMMY.
%DECK,RLU.
      FUNCTION RLU(I)
      REAL RLU,R
      INTEGER I
      CALL GRNDM(R,1)
      RLU=R
      END
%QUIT
EOF
/cern/cernlib/94a/bin/ypatchy - gopal139 temp tty .go
echo Try to compile and link...
rm /opal/bin/goro139.exe
f77 -o /opal/bin/goro139.exe -O3 -assume backslash gopal139.f \
/opal/lib/gopal139.a \
/opal/lib/geant321.a \
/opal/lib/rope414.a \
/opal/lib/dx112.a \
/opal/lib/dd210.a \
/opal/lib/op305.a \
/opal/lib/ll209.a \
/opal/lib/fi602.a \
/opal/lib/ce319.a \
/opal/lib/cs211.a \
/opal/lib/ct315.a \
/opal/lib/cv335.a \
/opal/lib/cz327.a \
/opal/lib/si210.a \
/opal/lib/cx224.a \
/opal/lib/jc315.a \
/opal/lib/cj733.a \
/opal/lib/op305.a \
/opal/lib/jc315.a \
/opal/lib/em317.a \
/opal/lib/ee231.a \
/opal/lib/eb220.a \
/opal/lib/pb322.a \
/opal/lib/pe317.a \
/opal/lib/tb422.a \
/opal/lib/mm213.a \
/opal/lib/mb222.a \
/opal/lib/me422.a \
/opal/lib/hb318.a \
/opal/lib/hp225.a \
/opal/lib/sw110.a \
/opal/lib/fd428.a \
/opal/lib/lm428.a \
/opal/lib/od414.a \
/opal/lib/ou220.a \
/opal/lib/tr212.a \
/opal/lib/px111.a \
/opal/lib/rope414.a \
/opal/lib/dummy414.a \
/cern/cernlib/97a/lib/libmathlib.a \
/cern/cernlib/97a/lib/libpacklib.a \
/cern/cernlib/97a/lib/libkernlib.a 
echo OK, goro139.exe has been created
chmod +x /opal/bin/goro139.exe
# @$-o /usera/cpw1/gopal/goro139.log
# @$-eo
# @$-x
# @$
#
limit
cd /usera/cpw1/gopal
time /opal/bin/goro139.exe <<EOD
*FILE 'KINE' 'IN  ' 33 7='/user2/opal/drw1/jt1299.kidisk'                  
C   *FILE 'HIST' 'OUT ' 55 7='jt1299.rzhist'                  
C   *FILE 'DDST' 'OUT ' 21 8100 'OXL ' 7='jt1299.fxddst'   
CD   'FULL'
CAL  'FULL'
CHEA 'ALL '
EXPT 5
SWIT  0 0 0 0 0
DEBU  0 0 1
KINE 7 6. 10. 10. 5. 175. 0. 360.     
RUNG 1299 1 
TRIG  100
RNDM  1805523733 1140933655
END
C   ===================== Start ROPE data cards ===================   
LIST  
MONITOR
RERUN 'ALL '
END
STOP
EOD
+PATCH,EXAMPLE.
+DECK,OPALLEGO.
#!/bin/ksh
# @$-o opallego_normal_exp8.log
# @$-r opallego                   # Assigne a name to the request.
# @$-q lbqS                       # default of central pipe queue (Fast).
# @$-eo                           # merge the error and std out
# @$-nr                           # Do not restart if the system crashed
#
echo ' ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'
# This variable is not defined by default on SnOPAL.
export dstrope="rope dc px ou tr oc od cx su ll"
#
echo 'host  : '  `hostname`
echo 'shell : '  $SHELL
echo 'home  : '  $HOME
echo 'path  : '  $PATH

#
# Various.
export workdir=$HOME/lego
# Create temporary directory with a unique name for each job.
until [[ ! -a $workdir/$sd ]] do
  export sd=`/bin/date | awk '/ / {print $4}' | awk -F: '/:/ {print $2$3}'`
done
#
mkdir $workdir/$sd
cd $workdir/$sd
#
cat >opallego.cra <<\PATCHYEOF
%+OPT,MAP.
%+USE,HPUX,UNIX.
%+USE,TYPE.
%+USE,P=BATCH,D=GODUM,T=E.   << Dummy graphics routines. >>
%+USE,NOROPE.                      Do NOT run ROPE in this job.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%            Patchy switches for OPALLEGO. Choose ONE of them.
%%
%+USE,NORMAL.    gives you original 40 cos(theta) * 40 phi bins.
%% +USE,FINECTH.   gives a fine scan in cos(theta) 1024 bins.
%% +USE,FINEPHI.   gives a fine scan in phi        1024 bins.
%% +USE,DISTRIB.   gives a distribution of material in specified direction.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%+USE,GOCDES,ROCDES,GCDES.
%+USE,GHEISHA.
%+USE,P=BATCH,T=E.         GOPAL main program.
%+USE,P=OPALLEGO,T=E.      Activate the OPALLEGO code from gopal.car
%+KEEP,JSPACE.
%      PARAMETER (JSPACE = 2 500 000)
%+KEEP,KSPACE.
%      PARAMETER (KSPACE= 200 000)
%+PAM,LUN=11,T=A,T=C.     geant
%+PAM,LUN=11,T=A,T=C.     rope
%+PAM,LUN=13,T=A,T=C.     /u/ws/watson/lego/gopal135
%+QUIT.
PATCHYEOF

# Run ypatchy.
echo 'Starting ytofort:' `date`
ytofort opallego

# Now compile.
echo 'Starting ftobin:' `date`
ftobin opallego

# multi-pass linker.
echo 'Starting link:' `date`
link -3 opallego $dstrope fd op jc dd pe gopal ou geant dummy

# Finally, start to run.
opallego.run <<\FFREADEOF
LIST
C Specify 'ALL ' geometry, and choose the vintage of OPAL using the
C using EXP ffread card
EXPT 8
C
*FILE 'HIST' 'OUT ' 19 0 '    ' '    ' 'opalexp8_normal.rz'
GEOM 'ALL '
SETS 'EB  ' 'EE  ' 'HB  ' 'HE  ' 'HP  ' 'FD  ' 'SW  '
HITS 1
HADR 0
MULS 0
DRAY 0
MUNU 0
C
C ---------------------------------------------------------------------
C       Following card for NORMAL option.
KINE 4 50. 4. 40. 0. 90. 40. 0. 90.
TRIG 16000
C
C       Following card for FINECTH option.
C KINE 4 50. 4. 1024. 0. 90. 1. 1. 1.
C TRIG 81920
C
C       Following card for FINEPHI option.
C KINE 4 50. 4.    1. 65. 67.    1024. 0. 360.
C TRIG 81920
C
C       Following card for DISTRIB option.
C KINE 4 50. 4. 1. 89. 89. 1. 1. 1.
C TRIG 1
C
C Detailed description of KINE ffread card in this job (from gopal135.car)
C
C - The KINE  data card has the following meaning in this job;
C - Takes theta and phi in degrees and generates in bin(s) equally spaced
C - in cos(theta) and phi.
C -
C -  IKINE,PKINE specified by FFREAD card KINE :-
C -              IKINE    - 4 to call this routine
C -              PKINE(1) - momentum (GeV/c)          (default 10 GeV/c)
C -                       - or 2 limits of mometum (see PKINE(9))
C -                       - given as PMIN+10000*PMAX
C -              PKINE(2) - particle type             (default 5, mu+)
C -                       - < 0, random selection of |N| and |N+1|
C -                       - (e.g. if N=-5 it generates mu+, mu-)
C -                       - where N is value given
C -              PKINE(3) - number of bins in theta   (default 1)
C -              PKINE(4) - starting theta (degrees)  (default 0.)
C -              PKINE(5) - finishing theta (degrees) (default 180.)
C -              PKINE(6) - number of bins in phi     (default 1)
C -              PKINE(7) - starting phi (degrees)    (default 0.)
C -              PKINE(8) - finishing phi (degrees)   (default 360.)
C -              PKINE(9) - S+10000*T
C -                       - where T is the momentum distribution type:
C -                       -   0) single momentum given by PKINE(1)[DEF]
C -                       -   1) flat momentum distribution between
C -                       -      2 values given in PKINE(1)
C -                       - and S is:
C -                       -   0 for random generation within bin [DEF]
C -                       -   1 for generation at centre of bin.
C -              PKINE(10)- NT+90000*NP where NT and NP are
C -                       - the starting bin numbers in theta and phi
C -                       - default to first bins. (0)
C -  E.g., to generate 10 GeV/c pi+ uniformly over 4 pi:
C -        KINE 4 10. 8.
C -      (Don't forget the decimal points, since, as far as FFREAD is
C -       concerned, the parameters are real.)
STOP
FFREADEOF
echo 'Job finished:' `date`
+DECK,LEGOKUMAC.
MACRO OPALLEGO
*
*-- NKW 960415
*- Macro to plot 'normal' histograms.
*
osetup ; opt zfl1; set *FON -20; set ygti 0.7 ; opt grid
view/zone 1 2
title 'Material in OPAL with GOPAL134 and GEANT321'
*
close 1
h/file 1 opalexp8_normal.rz
*
*- Do things for the Ecal 1st.
*
do i=101,103
  h/pl //lun1/[i].prox
  atit 'Cos(theta)' 'Radiation lengths'
  h/pl //lun1/[i].proy
  atit 'Phi /degrees' 'Radiation lengths'
  wait
enddo
*
*- Now do the Hcal
*
do j=201,205
  h/pl //lun1/[j].prox
  atit 'Cos(theta)' 'Absorption lengths'
  h/pl //lun1/[j].proy
  atit 'Phi /degrees' 'Absorption lengths'
  wait
enddo
*
RETURN
