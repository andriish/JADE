+TITLE.
C GEANT   3.21/03  17/10/94  16.00.29  CERN PROGRAM LIBRARY GEANT  = W5013
+PATCH,$VERSION.
+DECK,V3_21.
*CMZ :  3.21/03 17/10/94  16.00.29  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/03   17/10/94 16.00.29
*
*
*::>          VERSION  3.21/02   25/07/94 15.24.16
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 16.32.43
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* GEANT 3.21 has a new tracking logic to speed up the search over the
*            volumes positioned inside a given node (Virtual Divisions).
*            The new tracking is initialized by GGCLOS in a completely
*            transparent way and in a negligible amount of time.
*            The GUNEAR and GSORD techniques are automatically disabled
*            and no change in the user code is needed. Anyway, it is
*            still possible to get the old Geant tracking recompiling
*            GEANT and GEANG with the patchy flag OLD.
*            To implement the new logic, the following routines have
*            written or deeply modified: GTNEXT, GGCLOS, GTMEDI, GNEXT,
*            GMEDIA, GINVOL, GVDCAR, GVDRAD, GVDPHI, GVDLIM, GSCVOL.
*                                                               S.Giani.
*
* GEANT 3.21 has a new logic for MANY volumes: the tracking is not
*            based anymore on a step-search, but relies on a algorithm
*            similar to the one used for ONLY volumes (giving then
*            basically the same speed obtained for ONLY). The new logic
*            of MANY allows boolean operations between volumes, clipping
*            of protuding objects, divisions along arbitrary axis,
*            overlaps of 1-D structures to build 2-D or 3-D structures
*            (like honeycombs, spaghetti, etc.). To implement the new
*            logic, the following routines have been written or modified:
*            GTNEXT, GTMEDI, GNEXT, GMEDIA, GTELEC, GTCKOV, GTHADR,
*            GTHION, GTMUON.
*                                                             S.Giani.
*
* GEANT 3.21 contains modifications to GTELEC, GTGAMA, GDRAY in order
*            to exploit the e.m. low energy effects introduced in 3.16
*            without any overhead in performance compared with 3.15.
*            A bug in the delta ray productions is now fixed.
*                                                        Thanks to L.Urban.
*
* GEANT 3.21 provides a ray-tracing as a new visualization tool. The
*            ray-tracing is based on the new Geant tracking and allows
*            the visualization of the boolean operations results.
*            The following routines have been written or modified:
*            GDRACK, GDSTEP, GDNINO, GDOPT, GDRAYT, GDRAW, GDINIT,
*            GTRIG, GTRIGI, GDKINE, GDLUMI, GLIGHT, GFIND, GXDRAW,
*            CDF.
*                                                             S.Giani.
*
* A new GGPERP has been written to cope with almost all the shapes.
*            It is now of general utility both for the Cerenkovs
*            and for the ray-tracing.
*                                               Thanks to R.Jones.
*
* A new set of routines to compute distances to surfaces has been
*            introduced (GVSAFE, GVGRAD, GVPSQR, GVSIGN, GVLONG).
*                                               Thanks to V.Perev.
*
* Important fix in GPHYSI: user words for media were overwriting
*            ILABS, ISYNC and ISTRA.
*                                    Thanks to S.Giani, S.Ravndal.
*
* GXOBJ has been improved to handle DETs as objects of a SET directory
*            in the HITS class.
*                                    Thanks to S.Giani, A.Dellacqua.
*
* GTNINO has been corrected in order to print the mechanism NEXT when
*            crossing boundaries.
*                                    Thanks to S.Giani, M.Maire.
*
* GFMFIN and GFMDIS are the new names for the 316 routines FMUFIN and
*        FMDIST to avoid clashes with the program library. GFMFIN has
*        also been corrected for a 316 bug affecting neutrons.
*                             Thanks to C.Zeitniz,K.Lassila,S.Ravndal.
*
* GINTRP and GINPCO have been corrected to handle sharp edges with no
*        risk of float exception.
*                                Thanks to L.Gibbons.
*
* GGPERP has been corrected in reading the TRAP parameters and a systematic
*        consistency of single precision or double precision variables in
*        the MAX,MIN,MOD operands is provided.
*                                             Thanks to S.Ravndal.
*
* FEREVV and FERHAV are now new from FLUKA.
*                                             Thanks to A.Ferrari.
*
* FEREVV has been adapted to the Geant random numbers generators.
*                                             Thanks to S.Ravndal.
*
* In GRNDMQ the option `SH' is provided to write the seeds ISEED1 and
*         ISEED2 to the event header bank.
*                                             Thanks to S.Ravndal.
*
* In GMORIN,FLINIT and GHEINI the interface messages are removed.
*                                             Thanks to S.Ravndal.
*
* In GGDPAR now PAR(3) is correctly initialized to 1.for slices of
*         a PGON.
*
*
* The seq GCNUM has been added to the deck ERTRGO in Geane.
*
*
*
* G321X and G321M are the new names for the KUIP output of the CDF.
*                                             Thanks to S.Giani.
*
* GMORIN has been modified in order to read correctly xsneut.dat
*          for MSDOS and WINNT as well.
*                                         Thanks to V.Fine.
*
* GEAMON has been modified in order to print Real and CPU Time longer
*          than 999 sec.
*                                         Thanks to R.Brun.
*
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                      Correction cradle 0.01                        *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       29/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* GZINIT and GSCKOV have been corrected (compared with 3.16) in order
*        to initialize correctly the link area for the Zebra pointers
*        of the banks relative to straggling, Cerenkovs, Asho, etc.
*        Four pointers were not seen by Mzlint and, moreover, the link
*        area (containing pointers for straggling, etc.) was initialized
*        only if using Cerenkovs.
*                                   Thanks to M.Verzocchi and R.Brun.
*
* FERHAV in Geanf was provoking a float exception due to a negative sqrt.
*        The problem was fixed thanks to a comparison with the original
*        Fluka code.
*                                   Thanks to B.Slater and S.Giani.
*
* PREPRE has been deoptimized on HP.
*                                   Thanks to A.Kulik.
*
* In GSKINE a pointer was not saved (in the previous versions as well).
*                                   Thanks to A.Dellacqua.
*
* In GTNEXT and GNEXT precision problems are handled more effectively.
*                                   Thanks to P.Ward, C.Markou and S.Giani.
*
* In GTNEXT the blocking of the volume from which particles are exiting
*        has been corrected.
*                                   Thanks to P.Ward.
*
* Problems in the interactive materials, mixtures and media definition
*        have been solved. (Routines GXCONT,GXGEOM). Idem for the 3D
*        Dspec (routine GXDRAW).
*
* In order to handle correctly calls to Gfcoor in phi (for x=0 or y=0)
*        GTMEDI, GMEDIA and GINVOL have been modified.
*                                    Thanks to P.Ward.
*
* In the ray-tracing, GDNINO has been corrected for precision problems.
*                                    Thanks to S.Giani.
*
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                      Correction cradle 0.02                        *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       25/7/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* In GTNEXT precision problems in phi have been solved.
*                                    Thanks to A.Rosowsky and A.Givernaud.
*
* In GDRAY a missing protection for delta ray production was added.
*                                    Thanks to L.Urban.
*
* In GINVOL the variable ingt is corrrectly reset. It was not reset in
*       all the previous versions of GEANT as well.
*                                    Thanks to R.Jones.
*
* GTCKOV, GTHADR, GTHION, GLISUR have been corrected and extended compared
*       with the first implementation in 3.16 for Cerenkov tracking.
*                                    Thanks to R.Jones.
*
* GSKPHO has been fixed for Cerenkov physics compared with the previous
*       version of GEANT (3.16).
*                                    Thanks to S.Bottai.
*
* GFTMAT had a wrong pointer to plot the muon-nucleus cross sections since
*       version 3.16. Now it is fixed.
*                                    Thanks to C.Wiebusch and S.Ravndal.
*
* GFINDS has been restored to the 3.15 functionality.
*                                    Thanks to A.Dellacqua and S.Tonse.
*
* GFANG has been fixed for a special pathological case.
*                                    Thanks to C.Zosi.
*
* GSROTM  has been fixed for a special pathological case.
*                                    Thanks to A.Vlassov.
*
* GDRAYT does not increment ievent anymore.
*                                    Thanks to P.Jacobs.
*
* GLVOLU has been fixed to recompute the pointers of the geometrical tree
*       even if the names and numbers were identical.
*                                    Thanks to R.Jones, T.Noble, S.Ravndal.
*
* GVDRAD has been fixed to compute the scope of tubs.
*                                    Thanks to K.Albiol and S.Giani.
*
* GDSPEC has been fixed to print degrees for the 3-rd parameter of sphe.
*                                    Thanks to S.Ravndal.
*
* GVDPHI has been fixed for a special pathological case (only for volumes
*       with planar surfaces).
*                                    Thanks to M.Kaspar and S.Giani.
*
* GXCONT is changed to handle correctly the variables ievent and nevent.
*                                    Thanks to P.Jacobs.
*
* SVGAM7 in Gheisha has now a protection against the log(0).
*                                    Thanks to D.Heck.
*
* FEREVV and FERHAV have been updated.
*                                    Thanks to A.Ferrari.
*
* In FLUFIN the correct mechanism is given to lmec in case of energy
*       below cut-off.
*                                    Thanks to B.Slater and S.Ravndal.
*
* In NUDISV the array anpowr is saved.
*                                    Thanks to S.Ravndal.
*
* In GMXSEC imed is used instead of nmed.
*                                   Thanks to K.L.Perini.
*
*
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                  Correction version 0.03 = 94b release             *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       25/7/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* In GDCGVW traslation problems have been fixed (graphics).
*                                    Thanks to J.Stepanek, S.Giani.
*
* In GLTRAC nlevel is now initialized to 0 and GTNEXT has been improved
*    further for handling precision problems.
*                                    Thanks to A.Dellacqua.
*
* GDRELX and GTELEC have been corrected for energy deposition problems.
*                                    Thanks to L.Urban.
*
* GSDVT2 has been corrected for divisions in phi.
*                                    Thanks to V.Popov.
*
* GPVOLU and GFMOTH are now able to handle cases where copy number = 1
*    is not defined.
*                                    Thanks to S.Giani, S.Nowak.
*
* GTREVE has been changed in order to avoid the loading of the graphics
*    package if not desired.
*                                    Thanks to S.Giani, I.Bird.
*
* GUPHAD, GUHADR and FLINIT give warnings and conditions for the use of FLUKA.
*                                    Thanks to A.Ferrari.
*
* GVDPHI and GVDCAR have been further improved to compute the scope of pgon.
*                                    Thanks to P.Kent.
*
* GTELEC now computes cross sections for SYNC only if there is mag. field.
*                                    Thanks to M.Maire.
*
* GPCXYZ printing format can now handle bigger dimensions.
*                                    Thanks to S.Ravndal.
*
* GDRMAT and GPRMAT headers are now consistent with GFTMAT. In GPLMAT `STEP'
*    and `RANGE' do not belong anymore to `ALL' as physical processes.
*                                    Thanks to M.Maire, S.Ravndal.
*
* GPHYSI is now setting dray=0 if loss=0. Labs, Sync and Stra can be switched
*    interactively. Decay and Sync are now also defined in vacuum.
*                                    Thanks to M.Maire, S.Ravndal.
*
* In GRNDMQ the ' ' and the 'G' options work now as described in the doc.
*                                    Thanks to S.ONeale, S.Ravndal.
*
* GPART calls GSDK anyhow to give flexibility at run time (for the interactive
*    version). The values relatives to the particles are now updated to
*    Phys.Rev. D50 1173 1994.
*                                    Thanks to S.Ravndal, F.H.Heinsius.
*
* In GDEXCA (Cadint) a bug from 316 is now fixed.
*                                    Thanks to J.Vuoskosky.
*
* GBREME and GSYNC (see the new doc for the meaning of sync=0,1,2,3) have
*    been improved and the two relative mechanism can happen at the same time.
*                                    Thanks to M.Maire.
*
+DECK,V3_16.
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/00   07/12/93 14.33.29
*
+DECK,V3_15.
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.15/09   920408 13.02
*
*
*          ************************************************************
*          *                                                          *
*          *                                                          *
*          *                G E A N T   Version  3.15                 *
*          *                                                          *
*          *            O F F I C I A L     R E L E A S E             *
*          *                                                          *
*          *              CERN, Geneva, April 7, 1992                 *
*          *                                                          *
*          *                                                          *
*          *                                                          *
*          ************************************************************
*
*
*::>          VERSION  3.15/08   920401  8.41
*
*
*::>          VERSION  3.15/07   920331  9.42
*
*
*::>          VERSION  3.15/06   920331  8.01
*
*
*::>          VERSION  3.15/05   920329 15.41
*
*
*::>          VERSION  3.15/04   920329 13.45
*
*
*::>          VERSION  3.15/03   920327 18.49
*
*
*::>          VERSION  3.15/02   920316 12.53
*
*
*::>          VERSION  3.15/01   920316 10.18
*
*             Prerelease stamping of 3.15
*
+DECK,V3_14.
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.14/16   901107 15.23
*
*      See PATCH,HISTORY for the description of version 3.14
*
 
+DECK,V3_13.
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.13/05   890628 15.01
*
*      See PATCH,HISTORY for the description of version 3.14
*
+PATCH,HISTORY
+DECK,BLANKDEK.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*
*           ************************************************
*           *                                              *
*           *         G E A N T  version  3.16             *
*           *                                              *
*           *          Official  R E L E A S E             *
*           *       ==============================         *
*           *                                              *
*           ************************************************
*
+DECK,V_313.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.13/05   890628 15.01
*
*        Changes in GTELEC,GTHADR and GTMUON for overstopping tracks.
*        STEP and SLENG correction optimized
*        In COMMON/GCDRAW/ variable IGVIEW changed to IDVIEW
*        Routine GTRMUL recoded
*        DOUBLE precision in GINTCO and protection added.
*        Changes in GNOPG6.
*        Changes in GINME (for spheres,tubes and cones DPP.LE.0)
*        GDINIT called by GXINT
*        Particle data table updated in GPART
*        Tests on boundary conditions for IEKBIN modified in GTGAMA
*        A new user callable routine GBIRK introduced in GPHYS.
*         GBIRK may be called from GUSTEP to compute the Birk
*         correction factors for anorganic scintillators.
*
*::>          VERSION  3.13/04   890623 12.34
*
*        New version of GLANDZ and GPOISS by L.Urban
*        GRNDM calling sequence changed
*        Sequence numbers (1-->215) can be initialized
*         with data card RNDM
*                Ex:
*            RNDM  9876  1234534   initializes sequence 1
*            RNDM 45  initilizes sequence 45 with the starting
*                     seed of sequence 45
*        New routine GRANOR (copy of RANNOR for GRNDM)
*
*::>          VERSION  3.13/03   890425 12.09
*
*        Update of inline documentation DOCGBASE,DOCGKINE,DOCGTRAK
*        Deck GGCLOS modified and moved from GGEOM to GBASE
*        New deck GHCLOS (called by GGCLOS) in GBASE
*        Deck GEVKEV moved from GTRAK to GCONS
*        New decks GFNDIG,GFNHIT,GRHITS in GHITS
*        Minor bug corrected in GTELEC
*        Control of debug and removal of SNXT=BIG  in GTNEXT
*        Call to GUSTEP removed from GUVIEW
*
*::>          VERSION  3.13/02   890311 10.45
*
*        Bug corrected in GPAIRM (COMMON/GCMATE/ overwritten
*        Bug corrected in outines GDRELM and GDRELP
*           (error in AVO changed to AVOGAD)
*        Minor corrections in physics routines
*        SAVE statements added
*        Protection in GHANGL
*        Default changed to GHEISHA instead of TATINA
*          in routines GUPHAD and GUHADR
*        Bug corrected in GHTATI (NAMEC(12) instead of NAMEC(10)
*
+DECK,V_314.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
C
C
C           ************************************************
C           *                                              *
C           *         G E A N T  version  3.14.16          *
C           *                                              *
C           *           Official  R e l e a s e            *
C           *       ==============================         *
C           *                                              *
C           ************************************************
C
C
C
*    The version 3.14 of GEANT is being released. Apart from a few
*    features, reported below, the new version is compatible with the
*    previous version 3.13. Substantial developments have taken place,
*    in particular in the physics and tracking areas.
*
*    In addition to the GEANT team
*     (R.Brun:CERN/CN-AS,  F.Bruyant:CERN/ECP-PI and M.Maire:LAPP),
*    many people have contributed to the new version, especially
*     - a large number of users of the previous version who reported
*       their experience, found bugs and suggested several improvements,
*     - the guinea-pigs of 3.14 who gave us essential comments during
*       our attempt to automatize computation of the tracking parameters.
*                 ** A.Givernaud (UA1), F.Nessi, V.Vercesi(UA2/LHC)
*                 ** The LHC proto collaborations
*     - H.Fesefelt(Aachen) has provided a new version of the GHEISHA
*       package with help from N.Van Eijndhoven (CERN/CN-AS)
*     - H.J Trost from ANL has reported problems in the muon-nuclear
*       interactions routines and provided the relevant corrections.
*     - P.Pedroni (Pavia) has implemented a new interface called
*       by GHEISHA for low-energy hadronic processes (See NUCRIN below).
*     - the contributors to the geometry package:
*            for the introduction of new shapes
*                ELTU by A.Solano (ZEUS)
*                HYPE by M.Corden (ALEPH and SSC)
*                CTUB by A.McPherson (CEBAF)
*            for systematic investigation of problems with the old shapes
*                R.Nierhaus (CERN/CN-AS)
*     - S.Egli (H1) has proposed an automatic optimisation for the
*       geometry at initialisation time.
*     - G.Lynch from Berkeley has investigated the multiple-scattering
*       various strategies and proposed a new algorithm.
*     - A.Rotondi and P.Montagna have proposed a new technique for the
*       fast generation of Vavilov distribution.
*       K.S.Koelbig (CERN/CN-AS) has implemented a new routine GVAVIV
*       based on their work.
*     - J.Salt (CERN/CN-AS) has implemented the graphics interface to the
*       CG package from Serpukhov with the help of E.Chernaev.
*     - The IBM team (C.Guerin, M.Roelisberger) have investigated how
*       to speed-up the program. Their work has been coordinated
*       by F.Carminati (CERN/CN-AS).
*
*     GEANT3.14 documentation
*     =======================
*      The printing of a new manual describing the new version is
*      scheduled for the end of this year. The CERN Program Library
*      will not distribute anymore the old document (version 3.11).
*
*
*     Important notice to GEANT users
*     ===============================
*
*      Following the reorganisation of the CERN research divisions
*      in July 90, R.Brun is now in charge of the Application Software
*      group (AS) in the CN division and F.Bruyant is in charge of the
*      Production support and computers Infrastructure group (PI) in the
*      ECP division. They will nevertheless continue, with M.Maire, to be
*      actively involved in the development of GEANT. Federico Carminati
*      is the coordinator of a simulation software unit in the CN-AS group.
*      Users are strongly recommended to address their questions,etc
*      directly to him (email: FCA@CERNVM.CERN.CH on BITNET). In particular,
*      feedback from users making comparisons with real data will be most
*      appreciated.
*
*      The simulation team is preparing the ground for the next version
*      of GEANT. In view of the proposed new accelerators, the following
*      items are considered with high priority:
*        - Parametrization techniques. A survey of the various methods
*          used in current experiments has been done and the implementation
*          of a new algorithm based on the GSCAN geometry + GFLASH (H1)
*          is in progress.
*        - Improvements in the geometry package. General shape definition,
*          surface based algorithms.
*        - Detector data structure and data base. Interface with CAD systems.
*        - Parallelism (at event level and below).
*
*
*......................................................................
*
* *** Compatibility with version 3.13
*     ===============================
*     - If COMMON blocks GCMULO or/and GCJLOC were included in the
*       user code, the new GEANT sequences GCMULO and GCJLOC must be
*       inserted and the code recompiled.
*     - Initialisation data structures saved with the previous versions
*       cannot be read by the new version, because the binning for
*       the cross-sections and energy loss tables has been changed.
*     - The GCPHYS variables SOLOSS,STLOSS,SOMULS,STMULS are no more
*       defined (see comments below)
*     - The GCTRAK variable IDECAD is replaced by IGAUTO
*
*
* *** MAIN CHANGES IN THE TRACKING PROCEDURES
*     =======================================
*
*    The tracking control routines GTGAMA,GTELEC,GTHADR,GTNEUT,GTMUON
*    have been largely rewritten to reflect the changes to the energy-loss
*    and multiple scattering processes.
*
*
* *** The ENERGY RANGE of the cross section and energy loss tables can
*     be fixed by the user with the new data card :
*             'ERANG'   EKMIN  EKMAX    NKBIN
*     which defines nkbin bins from Ekmin to Ekmax in a logarithmic scale.
*     The default is, as before, 90 bins from 10 Kev to 10 Tev but in
*     logarithmic scale. NKBIN must be 50<NKBIN<200.
*
*     WARNING 1 : as a consequence the common GCMULO has been changed.
*     User applications referencing GCMULO must be recompiled.
*
*     WARNING 2 : as a consequence the ZEBRA data structure JMATE
*     contains now cross-sections and energy loss tables based on the new
*     energy range. Structures saved by previous versions of GEANT cannot
*     be used by the new version.
*
*     WARNING 3 : changing the 'ERANG' data card arguments requires to
*     recreate the initialisation data structures.
*
*     WARNING 4 : for Hadrons, GEANT tabulates the energy-loss tables
*     for a proton-kinetic energy equivalent. As a consequence, the value
*     given for EKMAX must be at least 7 times the maximum kinetic energy
*     of particles to be tracked (ratio proton/pion mass).
*     For LHC/SSC simulations, we recommend ERANG 1.E-5 1.E+5 100
*     The recommended value for NKBIN is 10*LOG10(EKMAX/EKBIN).
*
*
* *** The MEAN STOPPING RANGE of a charged particle (STOPMX) is computed and
*     tabulated as a function of the kinetic energy (routine GRANGI).
*     There are tables for electrons, muons, protons. The others particles are
*     scaled from the proton table.
*     As for the other tabulated quantities, the Stopping Range can be displayed
*     with the routines GPLMAT and/or GPRMAT (keyword 'RANG').
*
*     During the tracking, the MEAN ENERGY LOSS over a given step (DEMEAN) is
*     computed from the difference of the stopping range before and after the
*     transport of the particle.
*
*
* *** ENERGY LOSS STRAGGLING : when ILOSS=2 (default) the Landau/Vavilov
*     fluctuations are applied to the mean energy loss over the step.
*     The VAVILOV distribution has been improved so that the fluctuations are
*     less dependent on the step size.
*
*     ILOSS=1 is now equivalent to ILOSS=3 i.e. restricted fluctuations are
*     applied together with delta-ray production (see routine GLANDZ).
*     The user who wish to inhibit the energy fluctuations must set ILOSS=4
*     The latter option has been kept for debug purpose only.
*
*
* *** MULTIPLE SCATTERING.  The calculation of the step size (SMULS) is new :
*     Bethe criterion taken into account, limitation of step size at low
*     energy (see routine GMULOF).
*
*     New routine GMULTS : depending on the step size the Moliere distribution,
*     or its gaussian approximation, is used.
*
*     The routines GMOLI, GMOLIE (ex Gmol), GMOLS have been slightly modified.
*
*     In the routine GMGAUS (ex Gmuls), we use a new sigma (G. Lynch LBL-28165).
*     The lateral displacement has been deleted. As a consequence the tracking
*     parameter DMAXMS is not used anymore for the control of the step size.
*     DMAXMS.LE.0 forces no multiple scattering at all in the medium.
*
*     New routine GMCOUL : for very small steps single Coulomb scatters are
*     generated instead of Moliere distribution.
*
*     By default (IMULS=1) GEANT will select automatically the algorithm to use
*     (GMCOUL, GMOLIE or GMGAUS).
*
*
* *** NEW ROUTINE GMULOF. The step for energy loss (SLOSS), the step for
*     multiple scattering (SMULS), and the step  for the curvature in a magnetic
*     field (SFIELD) can be precomputed and tabulated, at least for electrons
*     and muons. The routine GMULOF, called from GPHYSI, tabulates:
*                  SMULOF = MIN ( SMULS , SLOSS , SFIELD )
*     which is the effective step due to the "continuous processes".
*     SMULOF can be displayed with the routines GPLMAT/GPRMAT, keyword 'STEP'.
*
*
* *** Multiple scattering and energy loss computations are systematically
*     applied at each step during tracking. Therefore the GCPHYS variables
*     SOLOSS, STLOSS, SOMULS, STMULS are OBSOLETE. However, for backward
*     compatibility with 3.13, STLOSS is set equal to STEP.
*
*
* *** TRACKING PARAMETERS STMIN and DEEMAX.
*
*     The meaning of STMIN is the following : at low energy (below 1 Mev) the
*     multiple scattering condition can induce a very small step SMULOF.
*     On the other hand the Stopping Range is also small. Therefore, if the
*     Stopping Range is smaller than STMIN, the constraint SMULOF is ignored.
*     The exact condition is :
*               IF (SMULOF.LE.STMIN)   SMULOF = MIN ( STOPMX, STMIN )
*     STMIN is no more than an accelerator factor for the stopping particles.
*
*     The DEEMAX parameter remains the main tracking parameter. It governs the
*     precision of the tracking by limitating SMULOF.
*
*
* *** AUTOMATIC COMPUTATION of STMIN and DEEMAX.
*
*     By default Geant3.14 overwrites STMIN and DEEMAX. The STMIN default value
*     correspond to a stopping range of 200 Kev above CUTELE.
*     The default for DEEMAX follows the following algorithm:
*       - For non-sensitive volumes (ISVOL=0) DEEMAX is set to 0.25 for
*         materials with a radiation length x0<2cm
*         and DEEMAX=0.25-0.2/sqrt(x0) for other materials.
*       - For sensitive volumes (ISVOL.NE.0) DEEMAX=0.2/sqrt(x0)
*     These values have been tuned empirically on a variety of setups.
*
*     A new data card 'AUTO' has been implemented :
*     Setting 'AUTO' 1 is equivalent to NO data card, i.e. automatic computation
*     Setting 'AUTO' 0 : NO automatic computation, EXCEPT if STMIN and/or DEEMAX
*     has been given a negative value by the user.
*
*     WARNING : The default values above have been found reasonable for any kind
*     of medium. The unexperienced user is invited to start with automatic
*     computation. Please check the actual parameters by calling GPRINT ('TMED'
*     after the call to GPHYSI.
*
*     We STRONGLY recommend to always run in AUTO mode (default). The AUTO
*     mode makes GEANT a predictive tool if all parameters are automatically
*     computed by the system as opposed to tuning data and Monte Carlo
*     via the tracking parameters.
*
* *** GPHYSI
*     The routine GPHYSI has been improved to include additional protections
*     and to take into account the changes due to the new energy-range tables.
*     It must be noted that is mandatory to always call GPHYSI at the end
*     of the initialisation phase even when initialisation data structures
*     are read from a file.
*
* *** GPIONS
*     This new routine (a complement to GPART) defines a subset of the most
*     common "stable" elements in the nature.
*     GPIONS can be called at the initialisation stage after GPART. It creates
*     particles with GEANT identifiers 61 to 112.
*     GPIONS has been written for the heavy ions experiments in view of an
*     interface with the program FRITIOF which is being developed by
*     P.Gorodetzky (Strasbourg).
*
* *** GDEBUG
*     This new user callable routine from GUSTEP will take the following actions
*     if the flag IDEBUG=1:
*
*     IF(IDEBUG.NE.0) THEN
*       IF((ISWIT(2).EQ.1).OR.(ISWIT(3).EQ.1)) CALL GSXYZ ! store point in JXYZ
*       IF (ISWIT(2).EQ.2) CALL GPCXYZ ! step by step printed debug
*       IF (ISWIT(1).EQ.2) CALL GPGKIN ! list of particles generated during step
*       IF (ISWIT(2).EQ.3) THEN
*          IF(ISWIT(4).EQ.3.AND.CHARGE.EQ.0.)RETURN
*          CALL GDCXYZ    ! interactive drawing of trajectories
*        ENDIF
*     ENDIF
*
* *** New user callable routine GBIRK to take into account BIRK's factors.
*     ====================================================================
*    This new routine is callable from the GUSTEP routine. EDEP=DESTEP
*    if no Birk factors have been given via GSTPAR.
*      SUBROUTINE GBIRK(EDEP)
*
*     *** apply BIRK's saturation law to energy deposition ***
*     *** only organic scintillators implemented in this version MODEL=1
*
*     Note : the material is assumed ideal, which means that impurities
*            and aging effects are not taken into account
*
*     algorithm : edep = destep / (1. + RKB*dedx + C*(dedx)**2)
*
*     the values of RKB and C can be entered via :
*
*     call gstpar(imate,'BIRK1',value) to set the model (value= 1. or 2.)
*     call gstpar(imate,'BIRK2',value) to set RKB
*     call gstpar(imate,'BIRK3',value) to set C
*
*     the basic units of the coefficient are g/(Mev*cm**2)
*     because the de/dx is obtained in Mev/cm
*
*     exp. values from NIM 80 (1970) 239-244 :
*
*     RKB = 0.013  g/mev*cm**2  and  C = 9.6e-6  g**2/(Mev**2)(cm**4)
*
*
*
*
* *** GEANH news
*
*
*     a serious bug in GMUNUI has been reported by
*     Hans-Jochen Trost from ANL:
*       : convert millibarns to cm**2 by a factor 10**-27
*         and obtain therefore NA * 1 millibarn/cm**2 a
*         factor 10 smaller than in the code. Hans has verified
*         that the original code gives to high an energy loss
*         due to muon-nuclear interactions on iron by a fac-
*         tor of about 5-10, comparing to W.Lohmann et al.,
*         CERN 85-03 whose predictions have recently been
*         verified by CCFR data up to 1.2 TeV.
*     Hans has also introduced protections in GMUNU.
*
*    A new version of the GHEISHA package has been introduced by
*     H.Fesefelt (contact him for details).
*
*     The TATINA package is considered obsolete. Default routines
*     GUPHAD/GUHADR call GHEISHA. We are planning to remove the code
*     of TATINA in the coming versions of GEANT.
*
*
* *** NUCRIN: A new model for hadronic showers at low energies
*     ========================================================
*
*
*    NUCRIN (see ref.1) simulates hadron-nucleus ( A > 3) inelastic
*    interactions from a few MeV/c up to about 4.5 GeV/c laboratory
*    momentum of the incoming particle.
*    NUCRIN is automatically called by the GHEISHA routine GHEISH
*    when the flag IHADR=3 (set by data card HADR).
*    It is assumed that these reactions  are the superimposition of three
*    basic processes:
*
*    (a) inelastic collision of the projectile hadron (allowed particles are :
*        p,pbar,n,nbar,pi0,pi+,pi-,k+,k-,k0,k0bar,lamda0,lamda0bar,sigma+,
*        sigma-,sigma0) with a target nucleon in the nucleus.
*        This interaction is simulated,taking into account of the nucleon
*        Fermi momentum,  using HADRIN (see ref.2) program.
*        The corresponding physical model is based on the experimental evidence
*        that, in the selected momentum range,the inelastic cross section shows
*        the typical threshold and resonance behaviour of meson production:
*        the primary hadron-nucleon system is excited to an isobaric state
*        which then decays into hadrons or other resonances.
*
*        If the interacting nucleus is hydrogen,HADRIN can also be used
*        in a separate way to simulate hadron-proton reaction.
*
*    (b) induced intranuclear cascade with resulting proton and neutron
*        emission;
*
*    (c) nuclear evaporation and deexcitation from residual nucleus. At the
*        output the total energy available for these processes is given as
*        "excitation energy".
*
*    The mean excitation and cascade energies and the average multiplicities
*    of cascade particles are parametrized, according to experimental
*    distributions.
*    In each event their value are sampled from gaussian distribution:
*    if they fall in the permitted kinematical region, energy and types of
*    cascade nucleons are calculated and the remaining energy is assigned to
*    the incoming particle.
*    For hadron-nucleon interactions all relevant kinematic variables are
*    Lorentz-trasformed into the target nucleon rest system. If interaction
*    kinetic energy is greater than the total available collision energy
*    a new Fermi momentun is sampled, otherwise an event is generated with
*    HADRIN,in which decays modes of 107 particle and resonances into about
*    450 different channels are tabulated and outgoing particle directions
*    and momenta are chosen to reproduced experimental momentum transfer
*    distributions.
*    Final state particles kinematical variables are transformed back into
*    laboratory system; reaction and sampled event energies are again compared:
*    if their difference is negative, energy is not conserved and generation
*    has to be started once more with a new Fermi momentum sampling or if it
*    is,on the contrary positive, particle momenta and energies are corrected
*    to reach conservation.
*    The sampled events conserve the energy, the momentum, the electric and
*    baryonic charge  and the strangeness.
*    NUCRIN and HADRIN are initialised, by default, before event generation,
*    with a call to subroutines HADDEN and CHANWX which estabilish internal
*    weight tables and decay channels.
*
*    -----------------------------------------------------------------------
*    (1) K. Hanssgen, J. Ranft , Comp. Phys. Comm. 39, 53 (1986)
*    (2) K. Hanssgen, J. Ranft , Comp. Phys. Comm. 39, 37 (1986)
*
*
* *** GEOMETRY PACKAGE: New shapes and many improvements
*     ==================================================
*
*    Automatic optimisation of the geometry structure:
*    A new data card OPTI has been introduced (S.Egli H1).
*      OPTI -1 : disable optimisation
*      OPTI  0 : only volumes GSORDered are optimised (as in 3.13)
*      OPTI  1 : volumes GSORDered are optimised along the axis
*                specified. All the other volumes are automatically
*                optimised along the best axis (1 to 7).
*      OPTI  2 : All volumes are optimised along the best axis.
*                Volumes for which GSORD was called are also optimised.
*      The default value for OPTI is 0.
*      In case OPTI >0, the result of the optimisation is printed.
*      The automatic optimisation is done at initialisation time by
*      a new routine GGORDQ called by GGCLOS.
*
*
*    Most of the geometry routines have been revisited and consolidated.
*    The following new shapes are available.
*
*      'ELTU'    is a cylinder with an elliptical section.
*                It has three parameters: the ellipse semi-axis in X,
*                the ellipse semi-axis in Y and the half length in Z.
*                Given the equation of the conical curve:
*                     X**2/A**2 + Y**2/B**2 = 1,
*                describing the volume,then:       PAR(1) = A
*                                                  PAR(2) = B
*                                                  PAR(3) = DZ
*                ELTU is not divisible.
*
*      'HYPE'    is a hyperbolic tube, ie the inner and outer surfaces
*                are hyperboloids, as would be formed by a system of
*                cylindrical wires which were then rotated
*                tangentially about their centres.  The 4 parameters
*                are the inner and outer radii, the half length in z,
*                and the "stereo angle" theta in degrees, such that
*                the hyperbolic surfaces are given by
*                r**2 = (z*tan(theta))**2 + (r at z=0)**2
*
*      'CTUB'   (for cut tube) is a TUBS whose end planes are not
*               perpendicular to the z axis. It has 11 parameters :
*               the 5 of the TUBS shape plus the components of the normal
*               to the end plane at the lower z (LXL,LYL,LZL) and
*               those at the higher z (LXH,LYH,LZH).
*               DZ means the half length in z for x = y = 0
*
*
*     Bugs have been fixed in the routines GNPCON, GNPGON and GNOPGO.
*
*     The new version of GNOTRP requires an extended parameter array.
*     In addition to the 11 specified parameters (of which 4 are
*     modified in subroutine GSVOLU or GSPOSP), the coefficients of
*     the implicit normalized plane equation for the 6 surfaces
*     of the hexahedron are stored.
*
*     IMPORTANT NOTE concerning the TRAP shape
*     ========================================
*     The Geant documentation describes the Geant shape TRAP as follows:
*
*          TRAP is a general trapezoid, i.e. one for which the
*          faces perpendicular to z are trapezia and their
*          centres are not at the same x, y. It has 11
*          parameters: Dz the half length in z, Th & Phi the
*          polar angles from the centre of the face at z=-Dz
*          to that at z=+Dz, H1 the half length in y  at
*          z=-Dz, LB1 the half length in x at z=-Dz and y=low
*          edge, LH1 the half length in x at z=-Dz and y=
*          high edge, Th1 the angle w.r.t. the y axis from
*          the centre of the low y  edge to the centre of the
*          high y edge, and H2, LB2, LH2, Th2 the
*          corresponding quantities to the 1s but at z=+Dz.
*
*     This seems to describe a general hexahedron with 3 constraints:
*     2 constraints follow from the fact that two faces are "trapezia".
*     (twice 2 edges parallel).
*     The 3rd constaint is that two faces are parallel, namely the "trapezia"
*     faces are both perpendicular to the Z-axis.
*     We will assume that shape TRAP is a hexahedron with 3
*     constraints and direct our attention to the degrees of freedom
*     of such a shape.
*     The shape has 8 vertices and therefore 24 coordinates.
*     If we first consider a volume with 8 vertices and 6 surfaces,
*     but do not make the assumption that the surfaces are plane,
*     we see that this shape has 18 degrees of freedom.
*     We loose 3 coordinates because of the translational invariance
*     of the shape and 3 coordinates because of its rotational
*     invariance.
*     If we now assume that the shape is a hexahedron, that is
*     bounded by plane surfaces, we have 6 constraints, one for each
*     surface, and our hexahedron has 12 degrees of freedom.
*     Considering the 3 constraints mentioned in the beginning,
*     we conclude that our shape trapezohedron has 9 degrees of freedom.
*     It is however described by 11 parameters.
*     Therefore we must either drop our assumption that shape TRAP is
*     a hexahedron, that is bounded by parallel surfaces, or we must
*     request that the user specifies the 11 parameters with certain
*     constraints.
*
*     To check that the user respected the constraints, we check the
*     coplanarity of the faces during the specification phase of shape TRAP.
*     We know the vertex coordinates, and we have the indices to the
*     vertices for each face.
*     Assuming that a face is tetrahedron, we compute its volume.
*     We divide by the surface of the base triangle, and get a measure
*     for the coplanarity of the face, which is actually a distance.
*     A warning message is printed in case of no-coplanar faces.
*
*    GSORD problem
*    =============
*    A bug has been found in GTNEXT (and alike) which is induced by a bug of
*    logic in GSORD/GGORD. User calls to GSORD, with ordering axis 4 (Rxy)
*    or 5 (Rxyz), may cause problems when the ordered contents are such that
*    one can jump from a given content to another one without crossing a
*    content which, along the given axis, occupies a position in between the
*    start and the end contents : e.g. coaxial TUBES with different Z-lengths
*    should not in general be ordered by GSORD along the axis IAX=4 (Rxy).
*    However, part of the information provided by such calls can still be
*    used, in the static context of GTMEDI for instance. Therefore, the
*    following convention has been introduced: If the user is sure that the
*    contents are positioned in such a way that the anomaly mentioned above
*    cannot occur, the call to GSORD can be modified by using IAX=14 (instead
*    of 4), or 15 (instead of 5), in which case the ordering techniques will
*    also be used in the dynamic context of GTNEXT. In case of doubt, the
*    user has better to keep the old code, with IAX=4 or 5.
*
* *** DRAWING PACKAGE: Interface to the CG package
*     ============================================
*
*    An interface to the CG (Combinatorial Geometry) package written
*    at Serpukhov by E.Cernaev et al is now available. The new package
*    is automatically called if the option 'HIDE' is selected. eg.
*
*         CALL GDOPT('HIDE','ON')  in a Fortran program
*         DOPT HIDE ON/OFF  in the interactive version
*
*    This new facility includes a hidden line and surface algorithm
*    which permits nice 3-D views of a detector.
*    In the frequent case of hermetic 4 PI detectors, a facility
*    to remove a box (The Cutting BOX) is also implemented. The Cutting BOX
*    specifies a region of the detector which must be Cut to see inside.
*    A new interactive command CBOX is available to specify the box limits.
*
*    The CG system is part of the GEANG file (See Patches CGCDES,CGPACK)
*    To activate the CG package, +USE,CG,*GEANG.
*
*
* *** The SCAN geometry
*     =================
*   A new Patch,GSCAN has been introduced on a provisional basis in the GEANG
*   file. See discussion about SCAN below.
*
* *** GUPARA: Parametrization interface
*     =================================
*   A new FFREAD data cards PCUT can be used to set parametrization cuts.
*   The first argument of the PCUT card is a integer flag which turns or
*   on off the parametrization mechanism. If the parametrization is turned on
*   and a particle falls below one of the 5 cuts specified by the PCUT card
*   (similar in kind to the cuts specified by the card CUTS), then the
*   routine GUPARA is called and tracking of the particle is abandoned. This
*   mechanism is provided for applying parametrization schemes which
*   replace a particle by a parametrized shower when it falls below
*   a certain threshold.
*
*.............................................................................
*
*
* *** GXINT: Interactive version
*     ==========================
*
*      New menu FORTRAN: CALL,FILE,CLOSE,FORTRAN
*      New menu HISTOGRAM: FILE,LIST,PLOT,DELETE,LEGO,HRIN,HROUT,PUT,GET
*                          ZONE,SET,OPTION,NULL
*      New menu PICTURE: FILE,LIST,DELETE,SCRATCH,PLOT,RENAME,IZOUT,IZIN,IGSET
*      New menu SCAN: PHI,THETA,SLIST,VERTEX,SFACTORS,LSCAN,HSCAN
*      New menu PHYSICS: ANNI,BREM,COMP,DCAY,DRAY,HADR,LOSS,MULS,MUNU,PAIR,
*                        PFIS,PHOT,RAYL,CUTS,PHYSI
*
*      The menus FORTRAN,HISTOGRAM and PICTURE are subsets of the similar
*      menus in the PAW system.
*
*      The menu PHYSICS gives the possibility to modify the run conditions.
*      In case physics conditions are changed (LOSS,DRAY,MULS,CUTS) it is
*      mandatory to call the command PHYSI (which calls GPHYSI) to recompute
*      the cross-section and/or energy loss tables.
*
*      The menu FORTRAN is similar to the FORTRAN menu of PAW. It contains
*      in addition a new very important command FORTRAN which gives the
*      possibility to describe the geometry (UGEOM) in a Fortran routine
*      that can be edited interactively with the local editor and also
*      executed interactively under the control of the Fortran interpreter
*      COMIS.
*
* ***  GEANT >FORTRAN  FNAME
*
*      The routines in the file FNAME will be compiled by COMIS.
*      If routines with names: UGEOM,GUKINE,GUOUT,UGLAST are found,
*      then they will be automatically called by GXINT instead of
*      the routines with the same names compiled with the standard
*      Fortran compiler and linked with the application.
*      The user callable routines from the GEANT library as well as
*      routines from PACKLIB (HBOOK,HPLOT,HIGZ,ZEBRA) may be called
*      from these user routines. All GEANT common blocks may be
*      referenced.
*      In case where the routine UGEOM is called several times,
*      it is important to DROP all the initialisation data structures
*      JVOLUM,JMATE,JTMED,etc already in memory by using the routine GIDROP.
*
*       Example of an interactive session where the routine UGEOM is modified:
*
*         GEANT > Edit ugeom.for
*         GEANT > Fortran ugeom.for
*         GEANT > Call GIDROP
*         GEANT > Call UGEOM
*         GEANT > Dtree
*         GEANT > Edit ugeom.for
*         GEANT > Fortran ugeom.for
*         GEANT > Call GIDROP
*         GEANT > Call UGEOM
*         GEANT > Dtree
*
*      If FNAME='-', calls to user routines is reset and standard
*      routines called instead.
*
* *** Interface to CG
*    The command DOPT has a new option HIDE (DOPT HIDE ON/OFF)
*    Type DOPT without parameters to get the list of all currently
*    available options.
*    When this option is ON, the subsequent graphics commands DCUT/DRAW
*    will invoke the CG system for hidden line/surface removal.
*    This algorithm requires a lot of memory and time. It is recommended
*    to set the visibility attributes (SATT SEEN 0) for many of the
*    volumes in case the command aborts for lake of memory or time.
*    This option can also be used with the view banks mechanism (DOPEN)
*
*    New command CBOX to specify the boundaries of the cutting box.
*
* *** PLMAT
*
*   The existing command PLMAT offers the new possibility to plot
*    various physics parameters (cross-sections, energy-loss tables,etc)
*   in graphics format (via HPLOT) if MECAN=ALLG
*   The Keywords 'STEP' or 'RANG' may also be specified to produce
*   an alphanumeric output of the step-size and energy-range tables.
*
*        PLMAT  IMATE IPART MECAN [ IDM ]
*
*       IMATE      I 'Material number'
*       IPART      I 'Particle number'
*       MECAN      C 'Mechanism'
*       IDM        I 'ID mode option' D=0
*
*
* *** New menu SCAN. The SCAN geometry
*     ================================
*
*    This new menu contains various commands for an interactive interface
*    to the SCAN geometry
*    The SCAN geometry algorithm has been designed as a tool to improve
*    the tracking speed. This new facility still requires substantial
*    developments in view of the new parametrisation algorithms which
*    are developed in collaboration between the CN/AS group and the
*    LEP/HERA/LHC/SSC and other interested groups.
*    The SCAN facility is being introduced in the version 3.14 on a trial
*    basis to familiarise potential users with the concept.
*    The SCAN geometry data structure JSCAN is automatically generated
*    either by calling the GSCAN routine in the PATCH,GSCAN of GEANG
*    or interactively by using the commands in the new menu SCAN.
*    Starting from the normal geometry data structure created by GSVOLU,
*    GSPOS,GSDVN,etc, the detector may be divided into a simpler geometry
*    structure (theta,phi) or (eta,phi).
*    Geantinos are tracked starting from a VERTEX position through
*    the NPHI,NTETA divisions. For each division, the SCAN procedure
*    will insert into the JSCAN data structure the following information
*    for every main detector component specified in the SLIST command
*    in the spherical R direction:
*      Total number of radiation lengths up to entry in each R
*      Total number of absorption lenghts
*      Detector identifier
*    When the interactive command TRIGGER is entered, the number of
*    Geantinos specified as parameter will be tracked. In case the
*    data structure JSCAN is not empty, the program will automatically
*    start with the first PHI,TETA division not yet filled. As the
*    number of Geantinos to be tracked can be very large (depending
*    on the granularity) this gives the possibility to fill the JSCAN
*    data structures in several passes.
*
*
*     New menu SCAN: PHI,TETA,SLIST,VERTEX,SFACTORS,LSCAN,HSCAN
*
* ==>   /SCAN/PHI  NPHI [ PHIMIN PHIMAX ]
*
*        NPHI       I 'Number of PHI divisions' D=90
*        PHIMIN     R 'Minimum PHI in degrees' D=0
*        PHIMAX     R 'Maximum PHI in degrees' D=360
*
*        To specify number of divisions along PHI.
*
*
* ==>   /SCAN/TETA  NTETA TETMIN TETMAX [ DIVTYP ]
*
*        NTETA      I 'Number of TETA divisions' D=90
*        TETMIN     R 'Minimum value of TETA' D=0
*        TETMAX     R 'Maximum value of TETA' D=180
*        DIVTYP     I 'Type of TETA division' D=1 R=1:2
*
*        To specify number of divisions along TETA.
*        If DIVTYP=1 divisions in degrees following the THETA angle.
*        If DIVTYP=2 divisions in pseudo-rapidity ETA.
*
*
* ==>   /SCAN/SLIST  LIST
*
*        LIST       C 'List of master volumes'
*
*        Only boundary crossings of volumes given in LIST
*        will be seen in the SCAN geometry.
*
*
* ==>   /SCAN/VERTEX  VX VY VZ
*
*        VX         R 'Scan vertex origin' D=0
*        VY         R 'Scan vertex origin' D=0
*        VZ         R 'Scan vertex origin' D=0
*
*        All Geantinos tracked will start from position VX,VY,VZ.
*
*
* ==>   /SCAN/SFACTORS  FACTX0 FACTL FACTR
*
*        FACTX0     R 'Scale factor for SX0' D=100
*        FACTL      R 'Scale factor for SL' D=1000
*        FACTR      R 'Scale factor for R' D=100
*
*        Set scale factors for SX0,SL and R. The given scale factors must be
*        such that:
*
*          SX0*FACTX0 < 2**15-1 (32767)
*          SL*FACTL   < 2**10-1 (1023)
*          SR*FACTR   < 2**17-1 (131071)
*
*
* ==>   /SCAN/LSCAN  ID [ VOLUME CHOPT ]
*
*        ID         I 'Lego plot identifier' D=2000
*        VOLUME     C 'Volume name' D='XXXX'
*        CHOPT      C 'List of options' D='OPX' R=' ,O,P,I,X,L'
*
*        Generates and plot a table of physics quantities such as
*        the total number of radiation lengths or interaction lengths
*        in function of the SCAN parameters TETA,PHI.
*
*          CHOPT='O' table is generated at Exit  of VOLUME.
*          CHOPT='I' table is generated at Entry of VOLUME.
*          CHOPT='X' radiation lengths
*          CHOPT='L' Interaction lengths
*          CHOPT='P' Plot the table
*
*        If VOLUME='XXXX' Mother volume is used.
*
*
* ==>   /SCAN/HSCAN  IDPHI [ VOLUME CHOPT ]
*
*        IDPHI      I 'Histogram/phi identifier' D=1000
*        VOLUME     C 'Volume name' D='XXXX'
*        CHOPT      C 'List of options' D='OPX' R=' ,O,P,I,X,L'
*
*        Generates and plot an histogram of physics quantities such as
*        the total number of radiation lengths or interaction lengths
*        in function of the SCAN parameter TETA for a given value of PHI.
*
*          CHOPT='O' histogram is generated at Exit  of VOLUME.
*          CHOPT='I' histogram is generated at Entry of VOLUME.
*          CHOPT='X' radiation lengths
*          CHOPT='L' Interaction lengths
*          CHOPT='P' Plot the histogram
*
*        If VOLUME='XXXX' Mother volume is used.
*        The histogram identifier IDPHI is used to also identify which
*        PHI division to plot. IPHI=MOD(IDPHI,1000).
*        If IPHI=0, then all PHI divisions are generated (not plotted)
*        with histogram identifiers IDPHI+PHI division number.
*
*
*
*
*
*
* ***   New commands FILE,REND,MDIR,CDIR,IN,OUT in the RZ menu.
*       =======================================================
*
*
* ==>   RZ/FILE  LUN FNAME [ CHOPT ]
*
*        LUN        I 'Logical unit number'
*        FNAME      C 'File name'
*        CHOPT      C 'Options' D=' ' R=' ,U,N,I,O'
*
*        Open a GEANT/RZ file. Call GRFILE (See below).
*
*         CHOPT=' ' readonly mode
*         CHOPT='U' update mode
*         CHOPT='N' create new file
*         CHOPT='I' Read all structures from existing file
*         CHOPT='O' Write all structures on file
*
*
* ==>   RZ/OUT  OBJECT [ IDVERS ]
*
*        OBJECT     C 'Structure name'
*        IDVERS     I 'Version number' D=1
*
*        Write data structure identified by OBJECT,IDVERS to RZ file.
*        Call GROUT (See below)
*
*          MATE write JMATE structure
*          TMED write JTMED structure
*          VOLU write JVOLUM structure
*          ROTM write JROTM structure
*          SETS write JSET  structure
*          PART write JPART structure
*          SCAN write JSCAN structure
*          *    write all structures
*
* ==>   RZ/IN  OBJECT [ IDVERS ]
*
*        OBJECT     C 'Structure name'
*        IDVERS     I 'Version number' D=1
*
*        Read data structure identified by OBJECT,IDVERS into memory.
*        Call GRIN (See below)
*
*          MATE read JMATE structure
*          TMED read JTMED structure
*          VOLU read JVOLUM structure
*          ROTM read JROTM structure
*          SETS read JSET  structure
*          PART read JPART structure
*          SCAN read JSCAN structure
*          *    read all structures
*
*
*
*
* *** New routines for direct access I/O in the GIOPA package
*     =======================================================
*
* ==>    SUBROUTINE GRFILE(LUN,CHFILE,CHOPT)
*.
*.           Routine to open a GEANT/RZ data base.
*.
*.           LUN logical unit number associated to the file
*.
*.           CHFILE RZ file name
*.
*.           CHOPT is a character string which may be
*.              'N' To create a new file
*.              'U' to open an existing file for update
*.              ' ' to open an existing file for read only
*.              'Q' The initial allocation (default 1000 records)
*.                  is given in IQUEST(10)
*.              'I' Read all data structures from file to memory
*.              'O' Write all data structures from memory to file
*.
*.           Note:
*.             If options 'I' or 'O' all data structures are read or
*.                written from/to file and the file is closed.
*.             See routine GRMDIR to create subdirectories
*.             See routines GROUT,GRIN to write,read objects
*.
*.
*.
*. ==>    SUBROUTINE GROUT(CHOBJ,IDVERS,CHOPT)
*.
*.           Routine to write GEANT object(s) in the RZ file
*.             at the Current Working Directory (See RZCDIR)
*.           Input is taken from the data structures in memory
*.               (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)
*.
*.           CHOBJ  The type of object to be written:
*.                  MATE write JMATE structure
*.                  TMED write JTMED structure
*.                  VOLU write JVOLUM structure
*.                  ROTM write JROTM structure
*.                  SETS write JSET  structure
*.                  PART write JPART structure
*.                  SCAN write LSCAN structure
*.                  INIT write all initialisation structures
*.
*.           IDVERS is a positive integer which specifies the version
*.               number of the object(s).
*.
*.           CHOPT List of options (none for the time being)
*.
*.        Note that if the cross-sections and energy loss tables
*.           are available in the data structure JMATE, then they are
*.           saved on the data base.
*.
*.
*.        The data structures saved by this routine can be retrieved
*.        with the routine GRIN.
*.
*.        Before calling this routine a RZ data base must have been
*.        created using GRFILE.
*.        The data base must be closed with RZEND.
*.          Ex: if LUN=1 CALL RZEND('LUN1')
*.
*.        The RZ data base can be transported between different
*.        machines in using the ZEBRA RZ utility RZTOFZ.
*.
*.        The interactive version of GEANT provides facilities
*.        to interactively update, create and display objects.
*.
*.          Example.
*.
*.          CALL GRFILE(1,'Geometry.dat','N')
*.          CALL GROUT('VOLU',1,' ')
*.          CALL GROUT('MATE',1,' ')
*.          CALL GROUT('TMED',1,' ')
*.          CALL GROUT('ROTM',1,' ')
*.          CALL GROUT('PART',1,' ')
*.          CALL GROUT('SCAN',1,' ')
*.          CALL GROUT('SETS',1,' ')
*.
*.          The same result can be achieved by:
*.          CALL GRFILE(1,'Geometry.dat','NO')
*.
*.
*.
*. ==>    SUBROUTINE GRIN(CHOBJ,IDVERS,CHOPT)
*.
*.           Routine to read GEANT object(s) fromin the RZ file
*.             at the Current Working Directory (See RZCDIR)
*.           The data structures from disk are read in memory
*.               (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)
*.
*.           CHOBJ  The type of object to be read:
*.                  MATE read JMATE structure
*.                  TMED read JTMED structure
*.                  VOLU read JVOLUM structure
*.                  ROTM read JROTM structure
*.                  SETS read JSET  structure
*.                  PART read JPART structure
*.                  SCAN read LSCAN structure
*.                  INIT read all initialisation structures
*.
*.           IDVERS is a positive integer which specifies the version
*.               number of the object(s).
*.
*.           CHOPT List of options (none for the time being)
*.
*.
*.        The RZ data base has been created via GRFILE/GROUT
*.
*.
*.          Example.
*.
*.          CALL GRFILE(1,'Geometry.dat',' ')
*.          CALL GRIN ('VOLU',1,' ')
*.          CALL GRIN ('MATE',1,' ')
*.          CALL GRIN ('TMED',1,' ')
*.          CALL GRIN ('ROTM',1,' ')
*.          CALL GRIN ('PART',1,' ')
*.          CALL GRIN ('SCAN',1,' ')
*.          CALL GRIN ('SETS',1,' ')
*.
*.          The same result can be achieved by:
*.          CALL GRFILE(1,'Geometry.dat','I')
*.
*.
*.
* ==>     SUBROUTINE GRMDIR(CHDIR,CHOPT)
*.
*.
*.           Routine to create a subdirectory
*.
*.           CHDIR Subdirectory name
*.
*.           CHOPT is a character string which may be
*.              ' ' To create a subdirectory
*.              'S' To create a subdirectory and set the new
*.                  Current Directory to this directory.
*.
*.
 
+DECK,V_315
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*
*        Maintenance and support for the GEANT MonteCarlo system
*        are performed by the Simulation Section of the CERN
*        Computing and Networks division. For any problem please
*        contact:
*
*                        Federico Carminati
*                        CERN-CN
*                        1211 Geneva 23
*                        Tel:        +41 22 767.4959
*                        Telefax:    +41 22 767.7155
*                        E-mail:
*                        BITnet/EARN: FCA@CERNVM
*                        DECnet     : VXCERN::FCA (Node 22.190)
*                        Internet   : fca@cernvm.cern.ch
*
*        An electronic GEANT discussion list has been set up on CERNVM.
*        To be included in the mailing list it is enough to send the
*        following message:
*
*       TELL LISTSERV AT CERNVM SUBSCRIBE LGEANT Firstname Lastname Inst
*
*        People who do not dispose of a TELL (or equivalent) bitnet
*        command should send a mail to LISTSERV@CERNVM containing the
*        only line:
*
*                   SUBSCRIBE LGEANT Firstname Lastname Inst
*
*================================= History
*
*===> 20/NOV/1990
*
*        Current plans set the release of GEANT 3.15 around the third
*        quarter of 1991.
*
*===> 27/NOV/1990
*
*        Correction in GTRACK to set correctly the value of PREC
*        to match machine precision. Thanks to Stephan Egli and
*        M.Maire.
*        Introduced in the 314 correction cradle.
*
*===> 28/NOV/1990
*
*        Correction in GNTUBE to avoid square root of a negative
*        number. Thanks to M.Maire
*        Introduced in the 314 correction cradle.
*
*        Eliminate TOFG=0 from GINIT, already done in GTRIGI
*        Thanks to F.Carminati
*        Introduced in the 314 correction cradle.
*
*===> 29/NOV/1990
*
*        UNIX and BSLASH flags correctly set inside *GEANT.
*        Thanks to A.Nathaniel
*        GPMATE now prints also the components in case of
*        mixtures. If NUMB is <0 then materials from 1 to
*        -NUMB are printed. Thanks to Stephan Egli.
*
*        Corrections in GRGET (obsolete), GGET, GRIN to reset
*        correctly the number in GCNUM. Thanks to Stephan Egli
*        Introduced in the 314 correction cradle.
*
*===> 30/NOV/1990
*
*        New version of GNOELT and GNELTU, thanks to Yoshihisa Iga
*        and R.Nierhaus
*        Introduced in the 314 correction cradle.
*
*        Correction in GTRAK, all mechanisms turned off in the
*        vacuum. Thanks to S.Egli
*        Introduced in the 314 correction cradle.
*
*
*===> 03/DEC/1990
*
*        New routine GXPICK for the interactive version (Command
*        DRAWING/PICK) to pick a point in a detector and return
*        volume/material characteristics. Thanks to S.Egli.
*
*===> 04/DEC/1990
*
*        MAXNOD from 2000 to 8000 in GDTR0. Suggestion by S.Egli.
*        Introduced in the 314 correction cradle.
*
*        Bug corrected in GGCLOS, do not touch ISEARC in case
*        of user search (ISEARC.GT.0). Thanks to D.Ward.
*        Introduced in the 314 correction cradle.
*
*===> 05/DEC/1990
*
*        Correction in TWOB, get correctly Tmin and Tmax and
*        their distribution. Thanks to Marko Mikuz.
*        Introduced in the 314 correction cradle.
*
*===> 06/DEC/1990
*
*        Correction in TWOCLU and GENXPT to improve energy
*        conservation. Thanks to S.Egli.
*        Introduced in the 314 correction cradle.
*
*===> 11/DEC/1990
*
*        Generic function LOG introduced in GHFRAK. Generic
*        functions MAX and MIN introduced in several routines
*        in GGEOM (HYPE) and CGPACK. Generic SIN, COS, ATAN and
*        SQRT introduced in CGPACK. Thanks to Federico Carminati.
*        Introduced in the 314 correction cradle.
*
*===> 13/DEC/1990
*
*        GTAU routine to be obsoleted.
*
*        Supporting link for the LSCAN data structure mispelled
*        in several places. Corrected now. Thanks to Isabel Josa.
*        Introduced in the 314 correction cradle.
*
*        Unused variable IPOT eliminated from GHFFER.
*
*        Changes in the interactive part for ATC GKS which does
*        not use FORTRAN unit for metafiles. (routines GXINT and
*        GXGCON). Thanks to W.Koellner
*
*===> 14/DEC/1990
*
*        REAL*8 changed to DOUBLE PRECISION in CGPACK.
*        Life of the D+/- mesons was 100 times too short.
*        Thanks to Cheng He Sheng.
*        Introduced in the 314 correction cradle.
*
*===> 19/DEC/1990
*
*        Modification in GDRAW and GDSPEC to correct a bug.
*        Modifications in GLVOLU not to print a warning message
*        caused by drawing.
*        Introduced in the 314 correction cradle.
*
*===> 20/DEC/1990
*
*        Correction in GRAYLI affecting Rayleigh effect in
*        mixtures.
*        Introduced in the 314 correction cradle.
*
*        Recode of GRAYLI and GHESIG to be safer with respect
*        to compiler optimization.
*        Thanks to Rafi Yaari.
*
*===> 8/JAN/1991
*
*        Corrections in GRGET, GGET, GRIN to set correctly
*        NPART, NTMED, NMATE, NVOLUM. Thanks to Lee Roberts.
*        Introduced in the 314 correction cradle.
*
*        New meaning for ISVOL. If <0 the material is not a
*        a detector but the tracking parameters are the same
*        as in the case ISVOL>0 (sensitive medium).
*        Thanks to Michel Maire.
*        Introduced in the 314 correction cradle.
*
*===> 9/JAN/1991
*
*        TMAXFD not recomputed with IGAUTO=1 if the value given
*        by the user >= 0. Default value reset to 20. instead of
*        60. degrees. Thanks to W.Mueller and M.Maire
*        Introduced in the 314 correction cradle.
*
*===> 10/JAN/1991
*
*        Corrections in GPFIS, GPFISI and GPHYSI for the fotofission
*        and fotoabsorbtion (Giant resonance) of photons on Uranium
*        and plutonium. Thanks to Harm Fesefeld.
*        Introduced in the 314 correction cradle.
*
*        Correction in GPHYSI in case ILOSS=2 and more than one
*        tracking medium with the same material number then a
*        spurious error message was printed. Thanks to Kevin Sparks
*        Introduced in the 314 correction cradle.
*
*        Corrections in GENXPT, TWOCLU, TWOB, CINEMA and EXNU.
*        Thanks to Harm Fesefeldt.
*        Introduced in the 314 correction cradle.
*
*===> 11/JAN/1991
*
*        Correction in GPPART in case of user words. Thanks to Walter
*        Mueller.
*        Introduced in the 314 correction cradle.
*
*        Correction in GSTMED to protect for EPSIL <=0. Thanks to
*        Michel Lefebvre.
*        Introduced in the 314 correction cradle.
*
*===> 14/JAN/1991
*
*        Correction in GRGET to read the banks in the correct
*        division. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*
*        Improvement of GRIN, GROUT. New global keywords KINE and
*        TRIG can now be used. Thanks to Federico Carminati
*        Introduced in the 314 correction cradle.
*
*===> 17/JAN/1991
*
*        Correction in GSVOLU, GSDVN, GSDVN2, GSDVT, GSDVT2 not to
*        use uninitialized LINATT, set by GDINIT. This should take
*        care of the problem of empty drawings. Thanks to Simone Giani.
*        Introduced in the 314 correction cradle.
*
*        Correction in GPKINE to print correctly user words and vertex
*        information. Thanks to Kevin Sparks.
*        Introduced in the 314 correction cradle.
*
*        Correction in GPVERT to print correctly user words and vertex
*        information. Thanks to Soren G. Frederiksen.
*        Introduced in the 314 correction cradle.
*
*===> 18/JAN/1991
*
*        Max. GCKING stack size parametrized. The actual value of the
*        stack is not changed (100), but can be redefined in the
*        sequence GCKMAX. Important for LHC studies.
*        Thanks to Harm Fesefeldt.
*
*        Correction in GPRINT to call correctly GPDIGI and GPSETS.
*        Thanks to Michel Maire.
*        Introduced in the 314 correction cradle.
*
*===> 22/JAN/1991
*
*        New facilities of DZDOC introduced in the interactive menu.
*        Patchy flag (DZDOC) to assure backward compatibility.
*        Thanks to O.Schaile
*
*===> 31/JAN/1991
*
*        New facility using the JUMPT package to call user routines.
*        Patchy flag (USRJMP) to assure bacward compatibility.
*        Thanks to F.Carminati
*
*===> 05/FEB/1991
*
*        Correction in GINIT to print the level of the correction
*        cradle applied. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*
*        Correction Cradle 3.14/06 stamped and released.
*
*===> 06/FEB/1991
*
*        Introduction of the AIX370 flag in GEANX and GEANT.
*        Thanks to Roger Howard.
*
*===> 13/FEB/1991
*
*        Protection in GTRACK, GFTRAC and GLTRAC, do not update
*        pointers to cross section banks in the vacuum.
*        Thanks to C.Fuglesang, S.Banerjee, M.Maire.
*        Introduced in the 314 correction cradle.
*
*???>    Backward incompatibility
*
*        GFDETH returns NAMESH as a character*4 array and
*        GFDETD returns NAMESD as a character*4 array.
*        Thanks to M.Maire.
*
*
*===> 14/FEB/1991
*
*        Mods in GPMATE, GPPART, GPTMED, GSDK, GSMATE, GSMIXT, GSPART,
*        GSTMED, GSROTM, GPROTM
*        to warn against replacement of existing objects. Thanks to
*        Steve O'Neale.
*        Introduced in the 314 correction cradle.
*
*        Force load of user routines in GINIT.
*        Introduced in the 314 correction cradle.
*
*===> 15/FEB/1991
*
*        GSDVN to notify correctly when mother volume does not exists.
*        Thanks to Victor Perevoztchikov.
*        Introduced in the 314 correction cradle.
*
*===> 20/FEB/1991
*
*        Correction in GHEINI for the exponent range to be compatible
*        with IEEE machines. Original limits were for IBM/370.
*        Routine LIMDAT eliminated. Thanks to Hans-Jochen Trost.
*        Introduced in the 314 correction cradle.
*
*???>    Backward incompatibility
*
*        Parameter NAMATE returned from GFMATE now a CHARACTER*20
*        variable. Thanks to Michel Maire.
*
*        Monitoring introduced, flag MONITOR. Thanks to F.Carminati.
*        Mods in GXINT, GINIT, GLAST. Routine GEAMON introduced.
*        Introduced in the 314 correction cradle.
*
*===> 22/FEB/1991
*
*        GWORK in GINIT was (DUMMY) called without arguments.
*        GUDTIM was (dummy) called as a routine and it is a
*        function. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*
*        GUVIEW to specify 3rd argument as a character. Thanks to
*        Federico Carminati.
*        Introduced in the 314 correction cradle.
*
*        Call NUCRIN with the right number of arguments (the last
*        was not used anyway). Thanks to Federico Carminati.
*        Introduced in the 314 correction cradle.
*
*===> 04/MAR/1991
*
*        Correction in GMUSIG to avoid division by zero. Thanks to
*        M.Verzocchi.
*        Introduced in the 314 correction cradle.
*
*
*===> 20/MAR/1991
*
*        Corrections in GPRELM, muon e+e- soft radiation. Correction in
*        GDRELM for the ionization energy loss for muons. Thanks to
*        A.Nathaniel. Introduced in the 314 correction cradle.
*
*===> 21/MAR/1991
*
*        Correction in GPHYSI to initialise the JMULOF bank even in
*        the case of vacuum. Electron tracking in vacuum was not taking
*        into account the TMAXFD parameter. Correction in GRANGI to set
*        the range to BIG in case of 0 energy loss tabulated in JLOSS.
*        Correction in GPHYSI to switch off all the mechanisms in the
*        vacuum but decay. The corresponding code in GTRACK has been
*        removed. The previous corrections for IUPD in GLTRAC, GFTRAC
*        and GTRACK have been removed as well. Thanks to D.Ward, R.Brun,
*        F.Carminati
*        Introduced in the 314 correction cradle.
*
*        Corrections in GRANGI and in GTHADR to cure small steps in
*        tracking. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*
*===> 25/MAR/1991
*
*???>    Backward incompatibility
*
*        GFPART returns NAPART as a CHARACTER*20 array. Thanks to R.Rui
*        Introduced in the 314 correction cradle.
*
*===> 26/MAR/1991
*
*        GFTMAT will return the correct values for the vacuum, except
*        for hadrons. Thanks to P.Gumplinger.
*        Introduced in the 314 correction cradle.
*
*        Correction in GPCXYZ when the number of mechanisms is greater
*        than 6. Thanks to Y.Iga.
*        Introduced in the 314 correction cradle.
*
*
*===> 27/MAR/1991
*
*        GDXYZ corrected to use HIGZ generic line types. Thanks to
*        M.Maire.
*        Introduced in the 314 correction cradle.
*
*        Correction in the CDF for RZ/IN and RZ/OUT. Thanks to
*        F.Carminati.
*        Introduced in the 314 correction cradle.
*
*===> 04/APR/1991
*
*        For reasons of speed GKS-type lines are used now in
*        GDCXYZ, GDXYZ. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*
*===> 18/APR/1991
*
*        Correction of the logic for TMAXFD. Now is:
*
*            AUTO 1: 0<TMAXFD<20  --> accepted
*                      TMAXFD>20  --> set to 20
*                      TMAXFD<=0  --> set to 20
*
*            AUTO 0:   TMAXFD>0   --> accepted
*                      TMAXFD<=0  --> set to 20
*
*        Thanks to Gerry Lynch.
*        Introduced in the 314 correction cradle.
*
*        Correction in GMULOF. STMIN=BIG for the vacuum. Thanks
*        to F.Carminati.
*        Introduced in the 314 correction cradle.
*
*        Correction in GRFILE, GRIN called with IDVERS=0 and not
*        999. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*
*===> 22/APR/1991
*
*        Corrections in GPRELA, GMULOF, GPHYSI and GTNEXT. Now
*        STMIN is set to 0. for vacuum independly of the AUTO
*        flag. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*
*        Format correction in GSDVN. Thanks to Federico Carminati.
*        Introduced in the 314 correction cradle.
*
*===> 23/APR/1991
*
*        Correction in GINIT to initialize LIN via IQTTIN if
*        different from 0. Thanks to F.Carminati
*        Introduced in the 314 correction cradle.
*
*===> 24/APR/1991
*
*        New routines GPLMAT, GPRMAT, GPGKIN from Michel Maire.
*
*===> 25/APR/1991
*
*        geant.metafile is not opened any more by default.
*        The METAFILE command now accepts the metafile name
*        for packages like ATC-GKS which do not use FORTRAN.
*        Thanks to W.Koellner.
*
*===> 01/MAY/1991
*
*        Problem corrected in GHEISH for neutron cascade. A neutron
*        undergoing an hadronic reaction could generate two recoil
*        protons. Thanks to Henk den Bok.
*        Introduced in the 314 correction cradle.
*
*        Correction in GNEXT/GTNEXT. STMIN not used anymore for
*        MANY volumes. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*
*===> 02/MAY/1991
*
*        Call to NVETIM routine removed from GHEISHA. Thanks to
*        F.Carminati.
*
*===> 07/MAY/1991
*
*        RNDM interactive command added to set the random number
*        generator seeds. Thanks to F.Carminati.
*
*===> 08/MAY/1991
*
*        New routine GDTRAK introduced to draw a track and delete
*        it from the JXYZ buffer optionally. Thanks to R.Brun,
*        F.Carminati.
*
*        Important correction in GTGAMA, GTNEUT to avoid problems
*        due to machine precision. When a push is made to cross a
*        volume boundary the condition that the change in coordinate
*        be not negligible is imposed. Thanks to F.Carminati, R.Brun.
*        Introduced in the 314 correction cradle.
*
*===> 09/MAY/1991
*
*        Correction in GMGAUS due to G.Lynch. The sigma of the multiple
*        scattering in the gaussian approssimation was too small.
*        Introduced in the 314 correction cradle.
*
*===> 14/MAY/1991
*
*        Corrections in GTELEC, GTHADR and GTMUON to introduce the
*        same boundary correction than in GTNEUT, GTGAMA. Thanks to
*        P.Gumplinger.
*        Introduced in the 314 correction cradle.
*
*        New menu in GXINT to handle FZ files. Thanks to F.Carminati
*
*===> 17/MAY/1991
*
*        Correction in GHFHDN to reset to 0. TOFD. Thanks to
*        R.Rui.
*        Introduced in the 314 correction cradle.
*
*===> 31/MAY/1991
*
*        Correction in GTRACK to allow PREC to decrease and avoid
*        problems when changing particle and position but not medium.
*        Thanks to R.Spiwoks.
*        Introduced in the 314 correction cradle.
*
*===>  4/JUN/1991
*
*        New version of the hidden line removal, thanks to S.Giani.
*        New menu CVOL introduced to cut volumes and new SHIFT
*        command to shift volumes for drawing.
*
*        Correction in GHEISH. The ENP parameters are reset to 0.
*        at the beginning of every event. Thanks to Henk den Bok.
*        Introduced in the 314 correction cradle.
*
*===>  5/JUN/1991
*
*        Correction introduced in GPHYSI. JTM recalculated after
*        bank push. Thanks to K.Sparks.
*        Introduced in the 314 correction cradle.
*
*===> 11/JUN/1991
*
*        Correction introduced in GTELEC, GTMUON, GTHADR. When the
*        energy loss is below machine precision, it is recalculated
*        via the De/Dx table. Thanks to H.Fesefeld and Ralf Spiwoks.
*        Introduced in the 314 correction cradle.
*
*        Booking of the bank IMAT-4 delayed till GPHYSI. Will save some
*        words in case of materials which are not inserted in a tracking
*        medium. Thanks to F.Carminati.
*
*???>    Backward incompatibility
*
*        The argument DMAXMS in the calling sequence of GSTMED, unused
*        in 314, will be called STEMAX and will assume the meaning of
*        maximum step allowed for a particle in the given material.
*        This will only affect people running with AUTO 0. In case of
*        automatic computation of the tracking media parameters, this
*        number will be set to BIG (=1.E10).
*        Thanks to F.Carminati, M.Maire.
*
*===> 12/JUN/1991
*
*        Corrections in GMUNU to allow the usage of a variable number of
*        energy bins. Corrections in PHASP and GMUSIG for very high
*        energies. Thanks to Hans-Jochen Trost.
*        Introduced in the 314 correction cradle.
*
*        Correction in GFLTHE to avoid division by 0. Thanks to
*        Roy Bossingham.
*        Introduced in the 314 correction cradle.
*
*===> 13/JUN/1991
*
*        Correction in GINPGO and GINPCO to check correctly the PHI
*        limits. Thanks to R.Bossingham.
*        Introduced in the 314 correction cradle.
*
*===> 19/JUN/1991
*
*        Correction in GMUNU to calculate correctly the angle of the
*        incoming muon. Thanks to H-J.Trost.
*        Introduced in the 314 correction cradle.
*
*===> 20/JUN/1991
*
*        Corrections in GLANDZ for high energy to avoid numerical
*        problems. Thanks to H-J.Trost.
*        Introduced in the 314 correction cradle.
*
*===> 26/JUN/1991
*
*        All the routines and the commons of the HADRIN/NUCRIN
*        package have been renamed. All routines begin now with
*        GHF and all commons with GCF. This to avoid interactions
*        with the interface with FLUKA. Thanks to F.Carminati
*
*===> 28/JUN/1991
*
*        New algorithm for pushing a view bank. Now push of the
*        max between MORGS and the 25% of the size of the view
*        bank. Thanks to S.Giani.
*
*===> 17/JUL/1991
*
*        Common HIATT of HIGZ removed from GXCONT and workstation type
*        retrieved in GXDZ from Workstation ID. Thanks to O.Couet.
*
*        Modification in GMUSIG to protect against possible division
*        by zero. Thanks to M.Sarris.
*
*        Correction in GDSHOW to recalculate COSPSI and SINPSI. Thanks
*        to M.Verzocchi.
*        Introduced in the 314 correction cradle.
*
*===> 18/JUL/1991
*
*        Correction in GINVOL. When tracking in magnetic
*        field they could return the wrong volume. Thanks to D.Greiner.
*        Introduced in the 314 correction cradle.
*
*===> 24/JUL/1991
*
*        Corrections in GRIN to allow tracking after reading a data
*        structure. Thanks to R.Brun.
*        Introduced in the 314 correction cradle.
*
*        Modifications in GXINT to allow running with the MOTIF
*        user interface. Thanks to R.Brun.
*
*===> 31/JUL/1991
*
*        INT=0 suppressed in GHEISH after nuclear fission.
*        Thanks to Kati Lassila.
*
*===> 01/AUG/1991
*
*        Protection introduced in GMUSIG. Thanks to Jochen Trost.
*        Introduced in the 314 correction cradle.
*
*===> 02/AUG/1991
*
*        Correction in GHSTOP to fix the calculation of the time of
*        flight for stopping particles. Thanks to L.Roberts.
*        Introduced in the 314 correction cradle.
*
*        Correction in GNPGON not to calculate safety for the inner
*        radius when this is 0. Thanks to Andrei Nomerotsky.
*        Introduced in the 314 correction cradle.
*
*        Correction in GNOTRP to return the correct SNXT. Thanks to
*        V.Innocente.
*        Introduced in the 314 correction cradle.
*
*        Correction in GHSTOP not to discard hadrons at rest, they
*        may decay. Thanks to H.Fesefeld.
*        Introduced in the 314 correction cradle.
*
*        Modifications in GHSTOP and GHEISH to handle user defined
*        particles. Thanks to P.Gumplinger.
*        Introduced in the 314 correction cradle.
*
*===> 12/AUG/1991
*
*        Call to GUINTI added in GINTRI to define user commands. Thanks
*        to V.Vercesi.
*        Introduced in the 314 correction cradle.
*
*===> 21/AUG/1991
*
*        Modification in GTMED to print a warning when FIELDM .EQ. 0
*        and IFIELD .NE. 0. Thanks to Federico Carminati
*
*        Modification in GTHADR to set CFLD = BIG in case FIELDM=0.
*        Thanks to V.Vercesi.
*        Introduced in the 314 correction cradle.
*
*===> 27/AUG/1991
*
*        Call to C dummy routine to initialise X11 introduced in
*        GXINT for IBM/VM. Thanks to M.Marquina.
*
*===> 19/SEP/1991
*
*        Rayleigh effect now the default. IRAYL is set to 1 by default
*        in GINIT. Thanks to M.Maire
*
*        Changes in the multiple scattering routines. GMOLI1 and GMOLI2
*        suppressed and GMOLIO used instead. Corresponding changes in
*        GMULTS and GMULOF. The code of GMOLS has been put in line inside
*        GMOLIE and GMOLS is obsolete. GPOISS and GMCOUL modified for
*        performance reasons.
*        Gaussian scattering is now generated according to the Rossi
*        gaussian formula and there is no logarithmic term in the
*        sigma of the gaussian. This gives a distribution where the
*        tails are underestimated, but which is consistent over many
*        steps.
*        Moliere and single Coulomb scattering are chosen according to
*        the value of Omega in the Moliere formula.
*        The new meaning of IMULS is the following:
*
*              IMULS = 0       No multiple scattering
*              IMULS = 1,2     Moliere or single Coulomb scattering
*              IMULS = 3       Gaussian scattering with Rossi formula
*
*        Thanks to G.Lynch.
*
*===> 14/OCT/1991
*
*         New algorithm for calculation of energy loss. The stopping
*         range is now calculated with a parabolical interpolation
*         instead than with a linear one. This gives a dE/dx curve
*         which is a piecewise linear function and not a step function.
*         Thanks to F.Carminati.
*
*         Modification of GNOPG1 taking care of the case of a particle
*         which is very near to the surface and it may appear inside due
*         to machine precision. This could cause the volume to be skipped.
*         Thanks to R.Nierhaus.
*
*         Routine GNPGON rewritten for the calculation of SNXT. The
*         previous routine was returning wrong results. Thanks to
*         R.Nierhaus.
*
*===> 28/OCT/1991
*
*         Modifications in the routines GFLPHI and GFCOOR. The ordering
*         for TUBS in phi was wrong. Volumes could become invisible.
*         Thanks to F.Carminati.
*
*         New routine GFVERT introduced. Retrieves the parameters of a
*         vertex. Thanks to F.Carminati.
*
*===> 29/OCT/1991
*
*         Modification in NUCREC to zero the whole of the PV array
*         to prevent the use of uninitiated variables. Thanks to
*         F.Ranjard. Introduced in the 3.14 correction cradel.
*
*===>  1/NOV/1991
*
*         Useless code commented out in GTRAIN. Thanks to F.Carminati.
*
*         GNCONE gone to double precision. Thanks to J.Toth.
*
*===>  5/NOV/1991
*
*         Variable USERW undefined in the RESULT common now set to
*         UPWGHT from GCTRAK common. Thanks to F.Ranjard.
*
*         Type declarations for GCSTAK completed. Thanks to M.Battle.
*
*===>  5/DEC/1991
*
*         New calculation of the range table. Simpson integration rule
*         used. Modifications in GRANGI, GCOEFF.
*
*===> 10/DEC/1991
*
*         Protection introduced against the reading of a pre-315 data
*         structure. The value of STEMAX is set to BIG in this case.
*         Modification in GPHYSI.
*
*         Better handling of version numbers in I/O operations.
*         Modifications in GPHYSI and GRIN.
*
*===> 08/JAN/1992
*
*         Correction in GLANDZ to avoid gaussian distribution for
*         very thin layers. The version of GEANT 3.13 has been
*         used for this. Thanks to F.Carminati and M.Maire.
*
*         Corrections in GTNEXT, GINVOL and GTMEDI to protect against
*         wrong values of INGOTO when using MANY volumes. Thanks to
*         R.Brun.
*
*===> 15/JAN/1992
*
*???>    Backward incompatibility
*
*         The random numbers seeds are stored at the end of every event
*         in the JRUNG bank at locations 19 and 20. If the JRUNG data
*         structure is read in and the data card RNDM or the interactive
*         command RNDM has not been issued (NRNDM(1), NRNDM(2) <> 0),
*         and if the words 19/20 are not 0, then the random number
*         generator is restarted with these seeds. Thanks to F.Carminati
*
*         The RNDM command now reads the values of the seeds into
*         NRNDM(1) and NRNDM(2) in common GCFLAG. The values 0 0
*         can be used for the random seeds. These values will not
*         alter the current status of the random number generator,
*         but zeroing the variables  NRNDM(1) and NRNDM(2) will
*         allow them to be reinitialised with the values stored
*         in a data structure read from disk. Thanks to F.Carminati
*
*         Routine GREND now needs an integer as input. This is to be
*         consistent with GRFILE.
*
*===> 27/JAN/1992
*
*         The following changes made to the names of FLUKA routines
*         to avoid clashes with ISAJET. Thanks to L.Roberts.
*
*        Type          Original name            New name
*        Routine       DECAY                    FKDECA
*        Routine       FLAVOR                   FKFLAV
*        Routine       SIGINT                   FKSIGI
*
*===> 31/JAN/1992
*
*        Corrections in GMEDIA in case of many volumes to avoid
*        program crash. Thanks to R.Jones.
*
*        Change of logics in GRUN. Now if NEVENT is <= 0, no event
*        is processed. Thanks to B.Lockman.
*
*        Common GCFLAX put in the GCFLAG sequence with the BATCH and
*        NOLOG variable from GXINT. Thanks to B.Cole.
*
*        Problem corrected in GDECAY. The mass of the particle was
*        altered. If the next particle was the same, the mass was
*        not reset to its correct value. Thanks to S.Tonse.
*
*        TIMINT is now really the time left after initiatlization
*        as is specified in the documentation and not the time
*        USED for initialization as it was till now.
*        Thanks to V.Ivanov.
*
*        Corrections in GNPGON. Improvement of code safety under
*        optimization in GNOGO1, GNPGON, GNPCON. Thanks to Y.Iga.
*
*===>  4/FEB/1992
*
*        Corrections in GMULOF and GTHADR. SFIELD takes precedence
*        on STMIN in case IFIELD=1 to make sure that the Runge-Kutta
*        approssimation still works. Thanks to R.Hawkings.
*
*===> 10/FEB/1992
*
*         Correction in GDRAY to improve the precision in the calculation
*         of the angle. Thanks to F.Carminati & P.Lubrano.
*
*         Change in GFKINE. The variable TOFG is not updated any more.
*         Thanks to F.Carminati
*
*         New GMEDIA, GTMEDI, GINVOL to take care of the problems with
*         MANY volumes. Thanks to R.Jones.
*
*===> 14/FEB/1992
*
*         Bug corrected in GNPGON when the particle was exactly on the
*         wall of the last Z section. Thanks to V.Palichik.
*
*===> 17/FEB/1992
*
*         Updated routines GLUND, GLUNDI and new sequences LUDAT1, LUDAT3,
*         LUJETS. The data cards MSTE, KTYP, PMAS, PWID, IDB have been
*         removed because either obsolete or not aplicable. The new code
*         runs with JETSET 7.3 upward. Thanks to F.Carminati, T.Sjostrand.
*
*         Update of GLUDKY to work with 7.3. Thanks to F.Carminati.
*
*===> 23/FEB/1992
*
*         New subroutine GFIN to handle sequential input. Routine GGET
*         has been maintained for backward compatibility.
*         Thanks to F.Carminati.
*
*===> 01/MAR/1992
*
*         New Runge-Kutta integration routine for the tracking in
*         magnetic field. If the result of the stepping is not accurate,
*         the step is divided in 2 parts and the integration repeated
*         and so on. Thanks to V.Perevotchikov.
*
*===> 05/MAR/1992
*
*         Correction in GLTRAC. When the particle fetched has an entry
*         in JKINE the correct vertex number is calculated. Thanks to
*         Y.Foka.
*
*===> 06/MAR/1992
*
*         Correction in GTELEC. The calculated range may be slightly
*         larger than the maximum allowed range due to precision
*         problems and this was leading to very small negative steps.
*         Thanks to R.Brun.
*
*===> 08/MAR/1992
*
*         New GRKUTA, GHELIX, GHELX3 from V.Perevotchikov.
*
*===> 16/MAR/1992
*
*          ENERGY renamed to FKENER in FLUKA. Thanks to F.Carminati
*
*===> 17/MAR/1992
*
*          VERTEX->FKVERT, ZEROIN->FKZERO, ERROR->FKERRO in FLUKA.
*          Thanks to F.Carminati
*
*          Corrections in PBANH. Thanks to M.Sasaki.
*
*===> 19/MAR/1992
*
*          Corrections in GFIN, GFOUT and GRIN, version 0 is now allowed
*          for a data structure in I/O. Thanks to B.Cole.
*
*          Modification in GBREME to improve precision for small angles.
*          Thanks to F.Carminati.
*
*          Inlining of rotation routines in GFTRAC, GINVOL, GTMEDI,
*          GTNEXT, GMEPOS, GMEDIA. Thanks to D.Kryn, F.Carminati.
*
*          New routines GDLENS, GDPLST and GDPRTR in the drawing package.
*          New version of GDTREE. Thanks to S.Giani.
*
*          Streamlining of GDTOM, GINROT, GITRAN, GMTOD, GRMTD, GRMUL,
*          GROT, GTRMUL and GTRNSF. Thanks to F.Carminati.
*
*===> 23/MAR/1992
*
*???>    Backward incompatibility
*           Tracking medium name in GFTMED changed in CHARACTER variable.
*           Thanks to V.Perevotchikov.
*
*           IMPULS renamed to FKIMPU
*           DRES   renamed to FKDRES
*           ERUP   renamed to FKERUP in FLUKA. Thanks to F.Carminati.
*
*===> 24/MAR/1992
*
*       COSI entry point renamed to FKCOSI
*       POLI             renamed to FKPOLI in FLUKA. Thanks to F.Carminati
*
*       Changes in GCOMP to increase the precision of the rotation
*       of the scattered photons and electrons in the reference
*       frame of the incoming particle. Thanks to F.Carminati
*
*       New version of the routines GNOPG1 and GNPGO1. Speed up of
*       a factor two or more achieved. Thanks to F.Carminati,
*       M.Roethlisberger.
*
*===> 29/MAR/1992
*
*       Improvement of the routines GMEDIA, GTMEDI and GINVOL. A better
*       use is made of the variable INGOTO. Thanks to R.Jones, F.Carminati.
*
*===> 01/APR/1992
*
*       Modification in GTRACK. If a particle tries for more than 5 times
*       consecutively to exit a volume, the precision used for tracking is
*       multiplied by 5 and so on every fifth attempt. Thanks to
*       F.Carminati.
*
*       Modification in FLUFIN to normalise in double precision the
*       direction cosines given to FLUKA. Thanks to A.Ferrari
*
*       Modification in GLANDZ to avoid peaks in energy loss for very
*       light materials. Thanks to F.Carminati
*
*       New routine GETVER to crack the title sequence and to return
*       the correct version number. Thanks to F.Carminati and M.Maire.
*
+DECK,V_316
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*     Correction cradle for version 3.15 of the GEANT Programme
*     and history of the evolution of 3.16.
*
*               Important !!!
*               =============
*
*     Only corrections flagged by "Introduced in the 3.15 correction
*     cradle" are applied to 3.15. All the other comments refer
*     to modifications which will appear in the 3.16 version of
*     the program.
*
********************************************************************
*
*===> 06/12/93
*
*           Release of the 3.11 correction cradle.
*
*===> 02/12/93
*
*           Correction in GBRELE and GRANGI. Thanks to F.Carminati.
*           Introduced in the 3.15 correction cradle.
*
*===> 29/11/93
*
*           Release of the 3.10/00 correction cradle.
*
*===> 21/10/93
*
*          Correction in FKDECA and HADEVV to permit the correct
*          treatment of charmed particles decay. Thanks to
*          A.Ferrari. Introduced in the 3.15 correction cradle.
*
*          Correction in FKDRES to avoid a loop. Thanks to
*          B.Slater and A.Ferrari. Introduced in the 3.15 correction
*          cradle.
*
*===> 20/10/93
*
*          Correction in GDRAW to update current pointer to IN
*          bank. Correction in GGPPAR to compute the internal
*          parameters of a TRAP with negative parameters. Thanks
*          to S.Banerjee. Introduced in the 3.15 correction cradle.
*
*===> 19/10/93
*
*           Correction in GTNEUT, GTHADR, to allow hadronic decay
*           in the vacuum. Thanks to R.Jones. Introduced in the
*           3.15 correction cradle.
*
*===> 01/10/93
*
*           Correction in GNSLWD to avoid numerical problem. Thanks
*           to A.Parri. Introduced in the 3.15 correction cradle.
*
*===> 15/09/93
*
*           Release of the 3.09/00 correction cradle.
*
*===> 13/09/93
*
*           Correction in GNOCTU, thanks to M.Nessi. Introduced in
*           the 3.15 correction cradle.
*
*===> 03/09/93
*
*           Correction in EVENTV to protect square root of a negative
*           number. Thanks to B.Slater and A.Ferrari. Introduced in
*           the 3.15 correction cradle.
*
*===> 11/08/93
*
*           New tratment for thin layer, mainly gas, of dE/dx
*           introduced. Thanks to V.Grishin, S.Kotelnikov,
*           K.Lassila-Perini and P.Nevski.
*
*           All bit manipulation functions replaced by Military
*           Standard functions. Thanks to F.Carminati.
*
*===> 19/07/93
*
*           Correction in FLUFIN in order to avoid 0 mechanism
*           number when IHADR=2. Thanks to P.Bloch. Introduced
*           in the 3.15 correction cradle.
*
*           Correction in GSROTM, NROTM updated when the bank is
*           pushed. Thanks to M.Maire. Introduced in the 3.15
*           correction cradle.
*
*           Correction in ERTRGO. Thanks to E.Nagy. Introduced
*           in the 3.15 correction cradle.
*
*===> 07/06/93
*
*           Release of version 3.08 of the correction cradle.
*
*           New version of the FLUKA interface introduced. New
*           model for energy straggling introduced (Ermilova&
*           Checkin) and synchrotron radiation. Thanks to K.
*           Lassila-Perini, A.Ferrari&P.Sala et al. and I.
*           Gavrilenko. Please see the documentation for more
*           information.
*
*           New routine GFANG introduced. It finds the angles
*           Theta and Phi which are used to rotate a vector in
*           the master system of the other. Thanks to F.Carminati
*
*           New rotine GVROT introduced. It will rotate in full
*           double precision a vector in the reference system of
*           another one. Thanks to F.Carminati
*
*           Corrections in GRIN/GFIN to calculate correctly the
*           number of rotation matrixes. Thanks to M.Maire.
*           Introduced in the 3.15 correction cradle.
*
*           Correction in FLUFIN to pass antiprotons to FLUKA when
*           they are 'stopping'. Thanks to A.Ferrari. Introduced in
*           the 3.15 correction cradle.
*
*
*===> 27/05/93
*
*           Corrections in FLUFIN to pass stopping antiprotons,
*           antineutrons and pions to FLUKA for annihilation. The
*           other hadrons are either decayed or (neutral particles)
*           passed to GHEISHA/GHSTOP.
*
*===> 04/05/93
*
*           Correction in FDNOPT to properly initialise an
*           array. Thanks to K.Lassila-Perini. Introduced in
*           the 3.15 correction cradle.
*
*===> 21/04/93
*
*           New routine from Laszlo Urban for the tracking of
*           ions, GTHION. Ions now have to be given particle
*           type 8. Thanks to L.Urban.
*
*===> 18/04/93
*
*           Addition in GPPERP, the sphere has been added. Thanks
*           to R.Jones.
*
*           Old Hadrin/Nucrin interface deleted. HADR 3 flag has
*           no meaning any more. Warning message introduced in
*           GPHYSI, when IHADR=3 then reset it to 1 and use GHEISHA.
*           Thanks to F.Carminati.
*
*           Tatina code eliminated from GEANT. Thanks to F.Carminati.
*
*           Small changes in GSCHIT to avoid integer/floating
*           conversions and to speed-up the code. Thanks to
*           F.Carminati.
*
*===> 07/04/93
*
*           Correction in the GPOISS routine to avoid overflows.
*           Thanks to S.Qian. Introduced in the 3.15 correction
*           cradle.
*
*===> 06/04/93
*
*           Correction in GNSPHR to avoid floating point overflow.
*           Thanks to S.Ljungfelt. Introduced in the 3.15 correction
*           cradle.
*
*===> 22/03/93
*
*           Correction in GEAMON to extend the field for CPU
*           time. Thanks to R.Brun. Introduced in the 3.15
*           correction cradle.
*
*===> 14/03/93
*
*           Release of version 3.07 of the correction cradle.
*
*           Corrections in GZINIT, GPHYSI and GDSHOW. The
*           working space is now allocated via calls to
*           GWORK. GWORK has been modified and it only
*           increases the working space, it never reduces it.
*           Thanks to M.Corden. Introduced in the 3.15
*           correction cradle.
*
*===> 10/03/93
*
*           Correction in GFIN/GFOUT to avoid spurious error
*           message. Thanks to M.Maire.
*
*===> 03/03/93
*
*           Correction in GLTRAC to improve the precision of
*           the calculation of the kinetic energy. Thanks to
*           C.Zeitnitz. Introduced in the 3.15 correction
*           cradle.
*
*           Correction in GTRACK to avoid output overflow in
*           format statement. Thanks to M.Corden. Introduced
*           in the 3.15 correction cradle.
*
*           Correction in GDXYZ to obtain the correct line color
*           for a track. Thanks to M.Corden. Introduced in the
*           3.15 correction cradle.
*
*===> 02/03/93
*
*           New treatment of the photoelectric effect introduced.
*           Thanks to J.Chwastowski. Please see documentation for
*           more information.
*
*===> 01/03/93
*
*           Changes in GKGEOM to avoid warnings with the new
*           version of KUIP. Thanks to A.Nathaniel. Introduced
*           in the 3.15 correction cradle.
*
*           Changes in GSDVN2 to support division of spheres
*           in PHI with initial offset. Thanks to F.Carminati.
*
*           Changes in GMEDIV and GNSPHR to correct precision
*           problems. Thanks to F.Carminati.
*
*           Introduction of the Cerenkov effect. Thanks to
*           R.Jones. Please see documentation for more
*           details.
*
*===> 12/02/93
*
*           Changes in GSDVN to support division in PHI (axis
*           N. 3) of the sphere. Thanks to F.Carminati.
*
*           Changes in GDRAWS to partially support the drawing
*           of parts of sphere. Thanks to F.Carminati.
*
*===> 09/02/93
*
*           Release of version 3.06 of the correction cradle.
*
*===> 28/01/93
*
*           Correction in GXINT for compatibility with the KUIP
*           installed with version 93a of the CERN Program Library.
*           Thanks to R.Jones. Introduced in the 3.15 correction
*           cradle.
*
*===> 27/01/93
*
*           Correction in GMUNU. Only GHEISHA used to handle the
*           interaction irrespective of the value of IHADR. Thanks
*           to K.Lassila-Perini and G.Battistoni. Introduced in the
*           3.15 correction cradle.
*
*           Corrections in GGPPAR to handle a tube with negative
*           parameters positioned into a tubes in the general case.
*           Thanks to F.Carminati.
*
*===> 19/01/93
*
*           Correction in FLUFIN to make sure that just neutrons
*           are passed to GHEISHA. Thanks to K.Lassila. Introduced
*           in the 3.15 correction cradle.
*
*===> 21/12/92
*
*           Option Q(uiet) introduced in GRIN/GROUT. Thanks to
*           M.Maire.
*
*           New version of GRKUTA protected against 0 fields and
*           improved for precision. Introduced in the 3.15 correction
*           cradle. Thanks to W.Manner.
*
*===> 15/12/92
*
*           IQ(JRUNG+29) set to the event sequence number of the
*           last generated event in GTRIGC. Thanks to M.Maire.
*
*===> 11/12/92
*
*           Call to LUPART replaced with LU1ENT in GLUDKY. LUPART
*           was an obsolete routine deleted from JETSET 7.3
*           library. Thanks to R.Gomes.
*
*===> 23/11/92
*
*           Release of the version 3.05/00 of the correction
*           cradle.
*
*           Corrections in GRANGI to account for the use of the
*           ERAN card. Thanks to P.Gumplinger. Introduced in the
*           3.15 correction cradle.
*
*===> 18/11/92
*
*           Correction in GDRAWS for very thin CTUBes. Thanks to
*           M.Guidal. Introduced in the 3.15 correction cradle.
*
*           New version of GRKUTA introduced. It will limit the
*           number of iterations and cut steps to prevent looping.
*           Thanks to V.Perevotchikov. Introduced in the 3.15
*           correction cradle.
*
*===> 11/11/92
*
*           Correction in GGDSPE to allow repeated division of
*           tubes along R. Thanks to M.Maire. Introduced in the
*           3.15 correction cradle.
*
*===> 11/11/92
*
*           Correction in GNPCON when the particle is slightly
*           outside of the last plane in Z. It could happen for
*           precision problems. Thank to C.Georgiopoulos.
*           Introduced in the 3.15 correction cradle.
*
*           Quiet option introduced in GFIN and GFOUT to suppress
*           printing. Thanks to A.Eisner.
*
*           Correction in the header of GFIN, GFOUT. Thanks to
*           A.Eisner.
*
*           Correction to GSNEXT. It now checks the values of the
*           input list. Repeated values or values which are not
*           within the allowed limits are ignored and a warning
*           message is printed. Thanks to F.Luehring.
*
*===> 04/11/92
*
*           Modification in GSVOLU. A warning is printed if the same
*           volume name is repeated twice. Thanks to V.Perevoztchikov.
*
*===> 23/10/92
*
*           Print statement in GSKING replaced by a WRITE(CHMAIL
*           Thanks to F.Carminati.
*
*===> 19/10/92
*
*           Correction in GDRAY to increase the precision of
*           the angle calculation. Thanks to F.Malek.
*           Introduced in the 3.15 correction cradle.
*
*===> 19/10/92
*
*           Release of version 3.04 of the correction cradle.
*
*           Corrections in FEREVV and HADEVV. Thanks to A.Ferrari.
*           Introduced in the 3.15 correction cradle.
*
*===> 16/10/92
*
*           Release of version 3.03 of the correction cradle.
*
*===> 13/10/92
*
*           Correction in GFIN and GFOUT to handle correctly
*           ZEBRA error conditions. Thanks to H.Uijterwaal.
*           Introduced in the 3.15 correction cradle.
*
*           Correction in GDECAY to improve precision of rotation
*           of secondaries. Thanks to F.Carminati. Introduced in
*           the 3.15 correction cradle.
*
*           Correction in FEREVV to avoid square root of negative
*           number. Thanks to A.Ferrari. Introduced in the 3.15
*           correction cradle.
*
*           Correction in GDRAW to avoid error when traversing the
*           tree. Thanks to F.Carminati. Included in the 3.15
*           correction cradle.
*
*===> 09/10/92
*
*           Correction in GXPICT, added definition of a character
*           variable. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*
*===> 08/10/92
*
*           Corrections in ERPRDOC, EUFILV and ERTEST to change
*           Hollerith in characters for GEANE. Thanks to V.Innocente.
*           Introduced in the 3.15 correction cradle.
*
*===> 24/09/92
*
*           Correction in NUCREL to avoid square root of negative
*           numbers. Thanks to A.Ferrari. Introduced in the 3.15
*           correction cradle.
*
*===> 23/09/92
*
*           Correction in GMEDIA. INFR not set going up the tree to
*           avoid problem with user calls of GMEDIA during tracking.
*           Thanks to S.Banerjee. Introduced in the 3.15 correction
*           cradle.
*
*===> 21/09/92
*
*           Correction in GRANGI to avoid interpolation of DE/DX
*           beyond 10GeV. Thanks to V.Innocente. Introduced in the
*           3.15 correction cradle.
*
*===> 16/09/92
*
*           Correction in GBRELA. Auxiliary integration point for
*           muon dedx table was wrong. Thanks to V.Innocente.
*           Introduced in the 3.15 correction cradle.
*
*===> 15/09/92
*
*           Release of version 3.02 of the correction cradle.
*
*           Correction in GMEDIA, GTMEDI: JVIN not properly
*           initialised. Thanks to F.Carminati. Introduced in
*           the 3.15 correction cradle.
*
*           Release of version 3.01 of the correction cradle.
*
*           Correction to GSDVN for a mistype. Thanks to H.Plothow.
*           Introduced in the 3.15 correction cradle.
*
*           Small mod to GSNGTR for the CRAY. Function DSIGN changed
*           to SIGN. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*
*           Release of version 3.00 of the correction cradle.
*
*           Correction in GDECAY. When IDCAY=2 the routine does not
*           produce secondaries. Thanks to R.Jones. Introduced in
*           the 3.15 correction cradle.
*
*           Corrections in GFIN, GFOUT. Thanks to B.Cole. Introduced
*           in the 3.15 correction cradle.
*
*===> 14/09/92
*
*           Correction in GMEDIV, GMEDIA, GINVOL, GTMEDI to
*           improve precision and prevent blocking of volumes.
*           Thanks to F.Carminati, R.Jones. Introduced in the
*           3.15 correction cradle.
*
*===> 03/09/92
*
*           GDLADY and GDMISS routines introduced. Thanks to
*           H.Plothow.
*
*           Correction in GXDRAW for the coordinates of the
*           drawing of the GIRL. Thanks to F.Carminati.
*           Introduced in the 3.15 correction cradle.
*
*           Correction in GPHSIG, typing mistake in a formula.
*           Thanks to M.Fanti. Introduced in the 3.15 correction
*           cradle.
*
*===> 02/09/92
*
*           Corrections in GSDVN, GGPPAR, GGDPAR, GMEDIV, GCENT,
*           GSDVN2, GSDVT, GSDVT2 to allow the division of a TRAP
*           along y. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*
*           Corrections in GNPGO1 for precision problems. Thanks
*           to K.Lassila. Introduced in the 3.15 correction
*           cradle.
*
*           Corrections in GGDPAR, GSDVN for the z division of a
*           Polygone. Thanks to F.Carminati. Introduced in the
*           3.15 correction cradle.
*
*===> 01/09/92
*
*           Correction in GSDVT for the division of a parallepiped.
*           Thanks to Y.Fisiak. Introduced in the 3.15 correction
*           cradle.
*
*           Correction in GRKUTA. Helix is used if angle of
*           curvature is too large. In this case step is anyway
*           smaller than STMIN which is under user control.
*           Thanks to H.Plothow and V.Perevotchikov. Introduced
*           in the 3.15 correction cradle.
*
*===> 26/08/92
*
*           Correction in GKRZ and CDF for the command RZ/FILE.
*           Record lenght fixed at 1024 in GRFILE cannot be
*           Changed by the user. Thanks to H.Plothow. Introduced
*           in the 3.15 correction cradle.
*
*           Corrections in GTMEDI, GMEDIA and GINVOL for the case
*           of 'MANY' volumes. Uncleared blocking words found in
*           the tree. Thanks to H.Plothow. Introduced in the 3.15
*           correction cradle.
*
*===> 25/08/92
*
*           Correction in GNSPHR. The PHI limits were used
*           incorrectly in calculating the distance to the
*           sphere. This was slowing down calculation but still
*           giving correct results. Thanks to J.Stepanek.
*           Introduced in the 3.15 correction cradle.
*
*===> 21/08/92
*
*           Correction in GGORDQ. Incorrect counting of volumes
*           in case of phi ordering and phi division spanning
*           across 0 degrees. Thanks to L.Roberts and F.Carminati.
*           Introduced in the 3.15 correction cradle.
*
*===> 18/08/92
*
*           Version 2.00 of the correction cradle released
*
*
*           Correction in GDRELP and GDRELM. The shell corrections
*           where underestimated due to a wrong factor introduced
*           translating the original formula from ev to Gev. Thanks
*           to A.Ferrari and K.Lassila-Perini. Introduced in the
*           3.15 correction cradle.
*
*===> 17/08/92
*
*           Correction in GCENT in case of general trapezoid sliced
*           in z in a local development structure.
*           Thanks to S.Chekhtman. Introduced in the 3.15 correction
*           cradle.
*
*           Correction in GHEISH. Time of flight correctly initialised
*           for particles with number > 48. Thanks to A.Eisner.
*           Introduced in the 3.15 correction cradle.
*
*===> 14/08/92
*
*           Correction in GGPPAR for boxes with negative parameters
*           in traps. The current code supports correctly boxes with
*           one, two or three negative parameters positioned in a trap
*           not necessarily in the centre. The trap must not be twisted
*           and the ALP1 and ALP2 angles (PAR(7) and PAR(11)) must be
*           equal. This facility must be used with care because the
*           algorithm first maximises Z, then Y and then X. The result
*           may be not quite what is expected in all cases, and the
*           user is invited to check carefully the result. Thanks to
*           H.Plothow. Introduced in the 3.15 correction cradle.
*
*===> 12/08/92
*
*           Correction in GINVOL, GTMEDI and GMEDIA to handle correctly
*           the GSNEAR case when LIST(1)=1 and LIST(2)=0, that is when
*           all the volume are separated inside a mother. Optimisation
*           of the routine in case a large number of objects are
*           positioned at the same level and GUNEAR is used. Thanks to
*           R.Jones, M.Lefebvre and M.Pieri. Introduced in the 3.15
*           correction cradle.
*
*===> 07/08/92
*
*           Correction in GTNEXT. When the currents step brings
*           the particle on the surface of the next volume, signal
*           IGNEXT=1 to GTxxxx to 'push' into the next volume.
*           This is a genuine bug and some volumes may be lost
*           due to this. Thanks to M.Maire. Introduced in the 3.15
*           correction cradle.
*
*===> 02/08/92
*
*           Corrections to the precision in GNOPG1, GNCONE, GNOCON.
*           Thanks to R.Jones. Introduced in the 3.15 correction
*           cradle.
*
*===> 31/07/92
*
*           Correction in the printout of GTRACK when max number
*           of steps is reached. Event number and random numbers are
*           printed out as well. Thanks to M.Maire. Introduced in the
*           3.15 correction cradle.
*
*===> 29/07/92
*
*           Correction in PIMABS for HPUX only. If variable NT is
*           saved then the routine compiles correctly, otherwise
*           not. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*
*           Correction in NIZL. All local variable are saved now.
*           Thanks to F.Carminati. Introduced in the 3.15 correction
*           cradle.
*
*===> 29/07/92
*
*           Correction in CDF and in GKDRAW. Minimum angle for the
*           drawing is 0 and not 1. Thanks to H.Plothow. Introduced
*           in the 3.15 correction cradle.
*
*           Minor update of GXFZ, a character length has been set
*           to 4 to keep KUIP happy. Thanks to F.Carminati. Introduced
*           in the 3.15 correction cradle.
*
*===> 28/07/92
*
*           Corrections in GXFZ. Now the array LUNITS is properly
*           updated when a file is closed.
*
*           Correction in GBRSGE, GBRSGM. Save statement introduced.
*           Thanks to L.Roberts. Introduced in the 3.15 correction
*           cradle.
*
*           Correction in GINVOL for many volumes. Thanks to S.Giani
*           and R.Jones. Introduced in the 3.15 correction cradle.
*
*           Correction in GMCOUL to prevent a division by 0. Thanks
*           to M.Maire. Introduced in the 3.15 correction cradle.
*
*===> 03/06/92
*
*           Correction in GSNGTR. Double precision variables removed
*           in case of 64 bits machines. Thanks to E.Boehm. Introduced
*           in the 3.15 correction cradle.
*
*           Correction in the SROTM command. The lower limit for
*           PHI3 is really 0. and not 1. Thanks to E.Boehm. Introduced
*           in the 3.15 correction cradle.
*
*===> 01/06/92
*
*           New version of GRKUTA. In fact this is the 3.14 version
*           with the multiple steps algorithm of 3.15 introduced.
*           If the bending angle in one step is too big, then the
*           integration is done in several steps rather than in
*           one. The IMPLICIT REAL*8 in the cradle is to avoid
*           problems with the CRAY in the absence of PATCHY delayed
*           control cards. Thanks to V.Perevotchikov. Introduced in
*           the 3.15 correction cradle.
*
*===> 25/05/92
*
*           Sequence GCONSP changed for 32 bits machines. All
*           constants are suffixed with D0 to avoid truncations.
*           Thanks to F.Carminati. Introduced in the 3.15 correction
*           cradle.
*
*===> 25/05/92
*
*           Version 1.00 of the correction cradle released
*
*===> 21/05/92
*
*          Correction in GHFNUC: TNNUC variable was undefined.
*          Thanks to B.Lund-Jensen.
*          Introduced in the 3.15 correction cradle.
*
*===> 08/05/92
*
*          Correction in TWOCLU to avoid infinite looping in some
*          pathological cases. Thanks to L.Roberts.
*          Introduced in the 3.15 correction cradle.
*
*===> 06/05/92
*
*          Correction in GNPGO1. Constants changed to double
*          precision to avoid problems on the IBM. Thanks to
*          D.Ward.
*          Introduced in the 3.15 correction cradle.
*
*===> 28/04/92
*
*          Correction in GXINT to obtain the correct time in
*          the monitoring routine when running interactively
*          on IBM/VM. Thanks to F.Carminati.
*          Introduced in the 3.15 correction cradle.
*
*===> 16/04/92
*
*          Correction in GMULTS. A particle going exactly along
*          the negative direction of the Z axis could be rotated
*          of 180 degrees after multiple scattering. Thanks to
*          P.Gabriel.
*          Introduced in the 3.15 correction cradle.
*
*===> 15/04/92
*
*          Correction in GXDRAW. The arguments of DHEAD were
*          fetched with the wrong order. Thanks to F.Videbaek.
*          Introduced in the 3.15 correction cradle.
*
*          Correction in GPHYSI. Variable NUMOLD is now reset to
*          zero. This may affect people running interactively and
*          using the command PHYSI. Thanks to F.Videbaek.
*          Introduced in the 3.15 correction cradle.
*
+PATCH,*GEANT
+DECK,BLANKDEK.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
+USE,GCDES.
+USE,GBASE.
+USE,GCONS.
+USE,GHITS.
+USE,GIOPA.
+USE,GKINE.
+USE,GPHYS.
+USE,GTRAK.
+USE,GSTRAG.
+USE,GUSER.
+USE, SINGLE,  IF=CDC, CRAY.
+USE, F2C,     IF=MSDOS,WINNT,LINUX.
+USE, UNIX,    IF=SUN, SGI, DECS, CONVEX, IBMRT, AIX370.
+USE, UNIX,    IF=HPUX, APOLLO, IPSC, NEXT.
+USE, IBMALL,  IF=IBM, IBMMVS, AIX370.
+USE, DOUBLE,  IF=APOLLO, IBMALL, VAX.
+USE, DOUBLE,  IF=UNIX, IF=-SINGLE.
+USE, BSLASH,  IF=SUN, SGI, DECS, IBMRT, IPSC, F2C, QMALPH.
+USE, USRJMP,  IF=UNIX.
+USE, HIGZ,CG,MONITOR,FLUKA,IF=BLDLIB.
+DECK, INCSEQ, IF=INCLUDE
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
+KEEP,INCBEG,IF=IBM
      INCLUDE '
+KEEP,INCEND,IF=IBM
     +'
+PATCH,*GEAINC,IF=MINCL.
+DECK,blankdek.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
+USE,GCDES
+USE,GTINCL.     Include files for GEANT car file
+USE,GGINCL.     Include files for GEANG car file CG package
+USE,GFINCL.     Include files for GEANF car file
+USE,GHINCL.     Include files for GEANH car file
+USE,ERINCL      Include files for GEANE car file
+PATCH,GCDES.
+DECK,BLANKDEK,IF=-INCLUDE.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
+KEEP,GTLINK
      INTEGER       JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
C
+KEEP,GCLINK
+SEQ, GTLINK, IF=TYPE.
      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
C
+KEEP,GTBANK
      INTEGER IQ,LQ,NZEBRA,IXSTOR,IXDIV,IXCONS,LMAIN,LR1,JCG
      INTEGER KWBANK,KWWORK,IWS
      REAL GVERSN,ZVERSN,FENDQ,WS,Q
C
+KEEP,GCBANK
+SEQ,GTBANK,IF=TYPE.
      PARAMETER (KWBANK=69000,KWWORK=5200)
      COMMON/GCBANK/NZEBRA,GVERSN,ZVERSN,IXSTOR,IXDIV,IXCONS,FENDQ(16)
     +             ,LMAIN,LR1,WS(KWBANK)
      DIMENSION IQ(2),Q(2),LQ(8000),IWS(2)
      EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN),(IWS(1),WS(1))
      EQUIVALENCE (JCG,JGSTAT)
+SEQ,GCLINK
+KEEP,GTCURS
      INTEGER INTFLA
      REAL    SIZD2,FACHV,HALF,SAVPLX,SAVPLY,YPLT,XPLT
*
+KEEP,GCCURS
+SEQ,GTCURS,IF=TYPE
      COMMON/GCCURS/INTFLA,SIZD2,FACHV,HALF,SAVPLX,SAVPLY,YPLT,XPLT
*
+KEEP,GTCUTS
      REAL          CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM
     +             ,DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS
C
+KEEP,GCCUTS
      COMMON/GCCUTS/CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM
     +             ,DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS(5)
C
+SEQ,GTCUTS,IF=TYPE.
+KEEP,GTURSB
      INTEGER NUMNDS,IADDI,NUMND2,NNPAR,IISELT
*
+KEEP,GCURSB
      COMMON/GCURSB/NUMNDS,IADDI,NUMND2,NNPAR,IISELT
      COMMON/GCURSC/MOMO
      CHARACTER*4 MOMO
*
+SEQ,GTURSB,IF=TYPE
+KEEP,GTFLAG.
      INTEGER       IDEBUG,IDEMIN,IDEMAX,ITEST,IDRUN,IDEVT,IEORUN
     +        ,IEOTRI,IEVENT,ISWIT,IFINIT,NEVENT,NRNDM
C
+KEEP,GCFLAG
      COMMON/GCFLAG/IDEBUG,IDEMIN,IDEMAX,ITEST,IDRUN,IDEVT,IEORUN
     +        ,IEOTRI,IEVENT,ISWIT(10),IFINIT(20),NEVENT,NRNDM(2)
      COMMON/GCFLAX/BATCH, NOLOG
      LOGICAL BATCH, NOLOG
C
+SEQ,GTFLAG,IF=TYPE.
+KEEP,GCNMEC
      PARAMETER(NMECA=45,IBLOWN=23)
      CHARACTER*4 CHNMEC(NMECA)
*
* *** Two blank spaces for FISF and CAPF which do not exist
*
* *** The low-neutron cross-sections have to be at the end for the
* *** logics of the routine to work, and they have to start at
* *** IBLOWN
      DATA CHNMEC /
     +     'HADF',  'INEF',  'ELAF',  'NULL',  'NULL',
     +     'HADG',  'INEG',  'ELAG',  'FISG',  'CAPG',
     +     'LOSS',  'PHOT',  'ANNI',  'COMP',  'BREM',
     +     'PAIR',  'DRAY',  'PFIS',  'RAYL',  'MUNU',
     +     'RANG',  'STEP',  'LOWN',  'NABS',  'NELA',
     +     'NINE',  'NINC',  'N,2N',  'N,3N',  'N,NA',
     +     'N2NA',  'N,NP',  'NFIS',  'N,GA',  'N,PR',
     +     'N,DE',  'N,TR',  'N3HE',  'N,AL',  'N,2A',
     +     'N,3A',  'N,2P',  'N,PA',  'NT2A',  'ND2A'/
*
+KEEP,GTOPTI
      INTEGER IOPTIM
+KEEP,GCOPTI
      COMMON/GCOPTI/ IOPTIM
C
+SEQ, GTOPTI, IF=TYPE
+KEEP,GCJLOC
      COMMON/GCJLOC/NJLOC(2),JTM,JMA,JLOSS,JPROB,JMIXT,JPHOT,JANNI
     +                  ,JCOMP,JBREM,JPAIR,JDRAY,JPFIS,JMUNU,JRAYL
     +                  ,JMULOF,JCOEF,JRANG
C
      INTEGER       NJLOC   ,JTM,JMA,JLOSS,JPROB,JMIXT,JPHOT,JANNI
     +                  ,JCOMP,JBREM,JPAIR,JDRAY,JPFIS,JMUNU,JRAYL
     +                  ,JMULOF,JCOEF,JRANG
C
      COMMON/GCJLCK/NJLCK(2),JTCKOV,JABSCO,JEFFIC,JINDEX,JCURIN
     +                      ,JPOLAR,JTSTRA,JTSTCO,JTSTEN,JTASHO
C
      EQUIVALENCE (JLASTV,JTSTEN)
C
      INTEGER       NJLCK,JTCKOV,JABSCO,JEFFIC,JINDEX,JCURIN
     +                   ,JPOLAR,JLASTV,JTSTRA,JTSTCO,JTSTEN
     +                   ,JTASHO
C
+KEEP,GTKINE.
      INTEGER       IKINE,ITRA,ISTAK,IVERT,IPART,ITRTYP,NAPART,IPAOLD
      REAL          PKINE,AMASS,CHARGE,TLIFE,VERT,PVERT
C
+KEEP,GCKINE
      COMMON/GCKINE/IKINE,PKINE(10),ITRA,ISTAK,IVERT,IPART,ITRTYP
     +      ,NAPART(5),AMASS,CHARGE,TLIFE,VERT(3),PVERT(4),IPAOLD
C
+SEQ,GTKINE,IF=TYPE.
+KEEP,GCKMAX
      INTEGER MXGKIN
      PARAMETER (MXGKIN=100)
+KEEP,GCKING
+SEQ, GCKMAX
      COMMON/GCKING/KCASE,NGKINE,GKIN(5,MXGKIN),
     +                           TOFD(MXGKIN),IFLGK(MXGKIN)
      INTEGER       KCASE,NGKINE ,IFLGK,MXPHOT,NGPHOT
      REAL          GKIN,TOFD,XPHOT
C
      PARAMETER (MXPHOT=800)
      COMMON/GCKIN2/NGPHOT,XPHOT(11,MXPHOT)
C
      COMMON/GCKIN3/GPOS(3,MXGKIN)
      REAL          GPOS
C
+KEEP,GTLIST.
      INTEGER       NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT
     + ,NSTAT,LHSTA,LGET ,LSAVE,LSETS,LPRIN,LGEOM,LVIEW,LPLOT,LSTAT
C
+KEEP,GCLIST
      COMMON/GCLIST/NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT
     +       ,NSTAT,LHSTA(20),LGET (20),LSAVE(20),LSETS(20),LPRIN(20)
     +             ,LGEOM(20),LVIEW(20),LPLOT(20),LSTAT(20)
C
+SEQ,GTLIST,IF=TYPE.
+KEEP,GCMATE
      COMMON/GCMATE/NMAT,NAMATE(5),A,Z,DENS,RADL,ABSL
C
      INTEGER NMAT,NAMATE
      REAL A,Z,DENS,RADL,ABSL
C
+KEEP,GCMULO
      COMMON/GCMULO/SINMUL(101),COSMUL(101),SQRMUL(101),OMCMOL,CHCMOL
     +  ,EKMIN,EKMAX,NEKBIN,NEK1,EKINV,GEKA,GEKB,EKBIN(200),ELOW(200)
C
      REAL SINMUL,COSMUL,SQRMUL,OMCMOL,CHCMOL,EKMIN,EKMAX,ELOW,EKINV
      REAL GEKA,GEKB,EKBIN
      INTEGER NEKBIN,NEK1
C
+KEEP,GCMZFO
      COMMON/GCMZFO/IOMATE,IOPART,IOTMED,IOSEJD,IOSJDD,IOSJDH,IOSTAK
     +             ,IOMZFO(13)
C
      INTEGER       IOMATE,IOPART,IOTMED,IOSEJD,IOSJDD,IOSJDH,IOSTAK
     +             ,IOMZFO
C
+KEEP,GTNUM.
      INTEGER      NMATE ,NVOLUM,NROTM,NTMED,NTMULT,NTRACK,NPART
     +            ,NSTMAX,NVERTX,NHEAD,NBIT ,NALIVE,NTMSTO
C
+KEEP,GCNUM
      COMMON/GCNUM/NMATE ,NVOLUM,NROTM,NTMED,NTMULT,NTRACK,NPART
     +            ,NSTMAX,NVERTX,NHEAD,NBIT
      COMMON /GCNUMX/ NALIVE,NTMSTO
C
+SEQ,GTNUM,IF=TYPE.
+KEEP,GTCONS
      REAL          PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      REAL          EMMU,PMASS,AVO
C
+KEEP,GCONSP,IF=SINGLE
      REAL PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      REAL EMMU,PMASS,AVO
*
      PARAMETER (PI=3.14159265358979324)
      PARAMETER (TWOPI=6.28318530717958648)
      PARAMETER (PIBY2=1.57079632679489662)
      PARAMETER (DEGRAD=0.0174532925199432958)
      PARAMETER (RADDEG=57.2957795130823209)
      PARAMETER (CLIGHT=29979245800.)
      PARAMETER (BIG=10000000000.)
      PARAMETER (EMASS=0.00051099906)
      PARAMETER (EMMU=0.105658389)
      PARAMETER (PMASS=0.93827231)
      PARAMETER (AVO=0.60221367)
*
+KEEP,GCONSP,IF=-SINGLE
      DOUBLE PRECISION PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      DOUBLE PRECISION EMMU,PMASS,AVO
*
      PARAMETER (PI=3.14159265358979324D0)
      PARAMETER (TWOPI=6.28318530717958648D0)
      PARAMETER (PIBY2=1.57079632679489662D0)
      PARAMETER (DEGRAD=0.0174532925199432958D0)
      PARAMETER (RADDEG=57.2957795130823209D0)
      PARAMETER (CLIGHT=29979245800.D0)
      PARAMETER (BIG=10000000000.D0)
      PARAMETER (EMASS=0.0005109990615D0)
      PARAMETER (EMMU=0.105658387D0)
      PARAMETER (PMASS=0.9382723128D0)
      PARAMETER (AVO=0.60221367D0)
*
+KEEP,GCONST.
+SEQ, GTCONS, IF=TYPE.
      COMMON/GCONST/PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      COMMON/GCONSX/EMMU,PMASS,AVO
C
+KEEP,GTPHYS.
      INTEGER IPAIR,ICOMP,IPHOT,IPFIS,IDRAY,IANNI,IBREM,IHADR,IMUNU
     +       ,IDCAY,ILOSS,IMULS,IRAYL,ILABS,ISYNC,ISTRA
      REAL    SPAIR,SLPAIR,ZINTPA,STEPPA,SCOMP,SLCOMP,ZINTCO,STEPCO
     +       ,SPHOT,SLPHOT,ZINTPH,STEPPH,SPFIS,SLPFIS,ZINTPF,STEPPF
     +       ,SDRAY,SLDRAY,ZINTDR,STEPDR,SANNI,SLANNI,ZINTAN,STEPAN
     +       ,SBREM,SLBREM,ZINTBR,STEPBR,SHADR,SLHADR,ZINTHA,STEPHA
     +       ,SMUNU,SLMUNU,ZINTMU,STEPMU,SDCAY,SLIFE ,SUMLIF,DPHYS1
     +       ,SLOSS,SOLOSS,STLOSS,DPHYS2,SMULS,SOMULS,STMULS,DPHYS3
     +       ,SRAYL,SLRAYL,ZINTRA,STEPRA,SLABS,SLLABS,ZINTLA,STEPLA
C
+KEEP,GCPHYS
      COMMON/GCPHYS/IPAIR,SPAIR,SLPAIR,ZINTPA,STEPPA
     +             ,ICOMP,SCOMP,SLCOMP,ZINTCO,STEPCO
     +             ,IPHOT,SPHOT,SLPHOT,ZINTPH,STEPPH
     +             ,IPFIS,SPFIS,SLPFIS,ZINTPF,STEPPF
     +             ,IDRAY,SDRAY,SLDRAY,ZINTDR,STEPDR
     +             ,IANNI,SANNI,SLANNI,ZINTAN,STEPAN
     +             ,IBREM,SBREM,SLBREM,ZINTBR,STEPBR
     +             ,IHADR,SHADR,SLHADR,ZINTHA,STEPHA
     +             ,IMUNU,SMUNU,SLMUNU,ZINTMU,STEPMU
     +             ,IDCAY,SDCAY,SLIFE ,SUMLIF,DPHYS1
     +             ,ILOSS,SLOSS,SOLOSS,STLOSS,DPHYS2
     +             ,IMULS,SMULS,SOMULS,STMULS,DPHYS3
     +             ,IRAYL,SRAYL,SLRAYL,ZINTRA,STEPRA
      COMMON/GCPHLT/ILABS,SLABS,SLLABS,ZINTLA,STEPLA
     +             ,ISYNC
     +             ,ISTRA
*
+SEQ,GTPHYS,IF=TYPE.
+KEEP,GTPARM.
      INTEGER IPARAM,MPSTAK,NSPARA,NPGENE
      REAL    PCUTGA,PCUTEL,PCUTNE,PCUTHA,PCUTMU
+KEEP,GCPARM.
      COMMON/GCPARM/IPARAM,PCUTGA,PCUTEL,PCUTNE,PCUTHA,PCUTMU
     +             ,NSPARA,MPSTAK,NPGENE
      REAL PACUTS(5)
      EQUIVALENCE (PACUTS(1),PCUTGA)
+SEQ,GTPARM,IF=TYPE.
C
+KEEP,GCPOLY
      COMMON/GCPOLY/IZSEC,IPSEC
      INTEGER IZSEC,IPSEC
C
+KEEP,GCPUSH
      COMMON/GCPUSH/NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ
      INTEGER       NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ
C
+KEEP,GCRZ
      COMMON/GCRZ1/NRECRZ,NRGET,NRSAVE,LRGET(20),LRSAVE(20)
      INTEGER      NRECRZ,NRGET,NRSAVE,LRGET    ,LRSAVE
      COMMON/GCRZ2/RZTAGS
      CHARACTER*8 RZTAGS(4)
C
+KEEP,GTSETS.
      INTEGER       IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV
C
+KEEP,GCSETS.
      COMMON/GCSETS/IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV(20)
C
+SEQ,GTSETS,IF=TYPE.
+KEEP,GTSTAK.
      INTEGER  NJTMAX,NJTMIN,NTSTKP,NTSTKS,NDBOOK,NDPUSH,NJFREE,NJGARB,
     +         NJINVO,LINSAV,LMXSAV,NWSTAK,NWINT,NWREAL,NWTRAC
      INTEGER ISTORD
+KEEP,GCSHNO.
      PARAMETER ( NSBOX=1,  NSTRD1=2, NSTRD2=3, NSTRAP=4, NSTUBE=5,
     +  NSTUBS=6, NSCONE=7, NSCONS=8, NSSPHE=9, NSPARA=10,NSPGON=11,
     +  NSPCON=12,NSELTU=13,NSHYPE=14,NSGTRA=28, NSCTUB=29 )
+KEEP,GCSTAK.
+SEQ,GTSTAK,IF=TYPE.
      PARAMETER (NWSTAK=12,NWINT=11,NWREAL=12,NWTRAC=NWINT+NWREAL+5)
      COMMON /GCSTAK/ NJTMAX, NJTMIN, NTSTKP, NTSTKS, NDBOOK, NDPUSH,
     +                NJFREE, NJGARB, NJINVO, LINSAV(15), LMXSAV(15)
      EQUIVALENCE (ISTORD,NJTMIN)
C
+KEEP,GCSTRA.
      PARAMETER (ILTAB=200)
      COMMON /GCSTRA / EMAX,EM(200),SFINT,EPSR(ILTAB),EPSI(ILTAB),
     +  FINT(ILTAB),EMIN,EPPS,BETA2,GAMMA2,WP2,S2,MEEV,EMM(200),
     +  GAMLOG(21),NP,NTAB,IE,NFACT,NICOLL
*
      INTEGER NP,NTAB,IE,NFACT
      REAL    EMAX,EM,SFINT,EPSR,EPSI,FINT,EMIN,EPPS,EMM,GAMLOG
     +        ,BETA2,GAMMA2,WP2,S2,MEEV
*
+KEEP,GTASHO
      REAL         ZMED,AMED,DMED,E0MED,ZSMED,ESMED,ALFA,
     *             STEP,PLIN,PLOG,BE2,PLASM,TRNSMA,
     *             BOSC,AOSC,EOSC,ZOSC,EMEAN,CMGO,EMGO,EMGOMI
      INTEGER      NSMED,IOSC,NOSC,NMGO,NMGOMA
C
+KEEP,GCASHO
      COMMON/GCASHO/ZMED,AMED,DMED,E0MED,ZSMED(50),ESMED(50),ALFA,
     *             STEP,PLIN,PLOG,BE2,PLASM,TRNSMA,
     *             BOSC(50),AOSC(50),EOSC(50),ZOSC(50),EMEAN,
     *             CMGO(2000),EMGO,EMGOMI,
     *             NSMED,IOSC(50),NOSC,NMGO,NMGOMA
C
+SEQ,GTASHO,IF=TYPE.
+KEEP,GCTIME
      COMMON/GCTIME/TIMINT,TIMEND,ITIME,IGDATE,IGTIME
      INTEGER ITIME,IGDATE,IGTIME
      REAL TIMINT,TIMEND
C
+KEEP,GTHIL2.
      INTEGER LARETT,JTICK,JMYLL,JFIMOT,JFISCA,JFINAM,
     +        JAASS1,JAASS2,JAASS3,JAASS4,
     +        JTICKS,JMYLLS,JMYMOT
+KEEP,GCHIL2.
+SEQ, GTHIL2, IF=TYPE
      COMMON/GCHIL2/LARETT(2),JTICK,JMYLL,JFIMOT,JFISCA,JFINAM,
     +              JAASS1,JAASS2,
     +              JAASS3,JAASS4,JTICKS,JMYLLS,JMYMOT
*
+KEEP,GTTMED.
      INTEGER       NUMED,NATMED,ISVOL,IFIELD,IUPD,ISTPAR,NUMOLD
      REAL          FIELDM,TMAXFD,STEMAX,DEEMAX,EPSIL,STMIN,CFIELD,PREC
      INTEGER       JMIN,NPCKOV,IMCKOV,ITCKOV
      REAL          THRIND,PMIN,DP,DNDL
C
+KEEP,GCTMED
      COMMON/GCTMED/NUMED,NATMED(5),ISVOL,IFIELD,FIELDM,TMAXFD,STEMAX
     +      ,DEEMAX,EPSIL,STMIN,CFIELD,PREC,IUPD,ISTPAR,NUMOLD
      COMMON/GCTLIT/THRIND,PMIN,DP,DNDL,JMIN,ITCKOV,IMCKOV,NPCKOV
C
+SEQ,GTTMED,IF=TYPE.
+KEEP,GTTRAK.
      INTEGER NMEC,LMEC,NAMEC,NSTEP ,MAXNST,IGNEXT,INWVOL,ISTOP,MAXMEC
     + ,IGAUTO,IEKBIN,ILOSL, IMULL,INGOTO,NLDOWN,NLEVIN,NLVSAV,ISTORY
     + ,MAXME1,NAMEC1
      REAL  VECT,GETOT,GEKIN,VOUT,DESTEP,DESTEL,SAFETY,SLENG ,STEP
     + ,SNEXT,SFIELD,TOFG  ,GEKRAT,UPWGHT
      REAL POLAR
+KEEP,GCTRAK
+SEQ,GTTRAK,IF=TYPE.
      PARAMETER (MAXMEC=30)
      COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7),NMEC,LMEC(MAXMEC)
     + ,NAMEC(MAXMEC),NSTEP ,MAXNST,DESTEP,DESTEL,SAFETY,SLENG
     + ,STEP  ,SNEXT ,SFIELD,TOFG  ,GEKRAT,UPWGHT,IGNEXT,INWVOL
     + ,ISTOP ,IGAUTO,IEKBIN, ILOSL, IMULL,INGOTO,NLDOWN,NLEVIN
     + ,NLVSAV,ISTORY
      PARAMETER (MAXME1=30)
      COMMON/GCTPOL/POLAR(3), NAMEC1(MAXME1)
C
+KEEP,GCUNIT
      COMMON/GCUNIT/LIN,LOUT,NUNITS,LUNITS(5)
      INTEGER LIN,LOUT,NUNITS,LUNITS
      COMMON/GCMAIL/CHMAIL
      CHARACTER*132 CHMAIL
C
+KEEP,GTVOLU.
      INTEGER NLEVEL,NAMES,NUMBER,LVOLUM,LINDEX,INFROM,NLEVMX,
     +        NLDEV,LINMX
      REAL GTRAN,GRMAT,GONLY,GLX
+KEEP,GCVOLU
      COMMON/GCVOLU/NLEVEL,NAMES(15),NUMBER(15),
     +LVOLUM(15),LINDEX(15),INFROM,NLEVMX,NLDEV(15),LINMX(15),
     +GTRAN(3,15),GRMAT(10,15),GONLY(15),GLX(3)
C
+SEQ,GTVOLU,IF=TYPE.
+KEEP,GTVOL1.
      INTEGER NAMES1,NUMBR1,LVOLU1
+KEEP,GCVOL1
      COMMON/GCVOL1/NLEVL1,NAMES1(15),NUMBR1(15),LVOLU1(15)
C
+SEQ,GTVOL1,IF=TYPE.
+KEEP,GCVOL2
      COMMON/GCVOL2/NLEVE2,NAMES2(15),NUMB2(15),
     +LVOL2(15),LIND2(15),INFRO2,NLDEV2(15),LINMX2(15),
     +GTRAN2(3,15),GRMAT2(10,15),GONLY2(15),GLX2(15)
      INTEGER NLEVE2,NAMES2,NUMB2,LVOL2,LIND2,INFRO2,NLDEV2,LINMX2
      REAL GTRAN2,GRMAT2,GONLY2,GLX2
C
+KEEP,GTDRAW.
      INTEGER NUMNOD,MAXNOD,NUMND1,LEVVER,LEVHOR,MAXV,IPICK,
     + MLEVV,MLEVH,NWCUT,JNAM,JMOT,JXON,JBRO,JDUP,JSCA,JDVM,JPSM,
     + JNAM1,JMOT1,JXON1,JBRO1,JDUP1,JSCA1,JULEV,JVLEV,
     + LOOKTB,IDRNUM,NGVIEW,ICUTFL,ICUT,NSURF,ISURF,LINATT,LINATP,
     + ITXATT,ITHRZ,IPRJ,ITR3D,IPKHIT,IOBJ,LINBUF,
     + MAXGU,MORGU,MAXGS,MORGS,MAXTU,MORTU,MAXTS,MORTS,
     + IGU,IGS,ITU,ITS,NKVIEW,IDVIEW,
     + NOPEN,IGMR,IPIONS,ITRKOP,IHIDEN
      REAL GRMAT0,GTRAN0,GSIN,GCOS,SINPSI,COSPSI,GTHETA,GPHI,GPSI,
     + GU0,GV0,GSCU,GSCV,CTHETA,CPHI,DCUT,GZUA,GZVA,GZUB,GZVB,GZUC,
     + GZVC,PLTRNX,PLTRNY,DPERS,DDUMMY
+KEEP,GCDRAW
      COMMON/GCDRAW/NUMNOD,MAXNOD,NUMND1,LEVVER,LEVHOR,MAXV,IPICK,
     + MLEVV,MLEVH,NWCUT,JNAM,JMOT,JXON,JBRO,JDUP,JSCA,JDVM,JPSM,
     + JNAM1,JMOT1,JXON1,JBRO1,JDUP1,JSCA1,JULEV,JVLEV,
     + LOOKTB(16),
     + GRMAT0(10),GTRAN0(3),IDRNUM,GSIN(41),GCOS(41),SINPSI,COSPSI,
     + GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV,NGVIEW,
     + ICUTFL,ICUT,CTHETA,CPHI,DCUT,NSURF,ISURF,
     + GZUA,GZVA,GZUB,GZVB,GZUC,GZVC,PLTRNX,PLTRNY,
     + LINATT,LINATP,ITXATT,ITHRZ,IPRJ,DPERS,ITR3D,IPKHIT,IOBJ,LINBUF,
     + MAXGU,MORGU,MAXGS,MORGS,MAXTU,MORTU,MAXTS,MORTS,
     + IGU,IGS,ITU,ITS,NKVIEW,IDVIEW,
     + NOPEN,IGMR,IPIONS,ITRKOP,IHIDEN,
     + ZZFU,ZZFV,MYISEL,
     + DDUMMY(15)
C
+SEQ,GTDRAW,IF=TYPE.
+KEEP,GSECTI
      COMMON/GSECTI/ AIEL(20),AIIN(20),AIFI(20),AICA(20),ALAM,K0FLAG
      INTEGER K0FLAG
      REAL AIEL,AIIN,AIFI,AICA,ALAM
C
+KEEP,GCGOBJ
      PARAMETER (NTRCG=1)
      PARAMETER (NWB=207,NWREV=100,NWS=1500)
      PARAMETER (C2TOC1=7.7, C3TOC1=2.,TVLIM=1296.)
      COMMON /GCGOBJ/IST,IFCG,ILCG,NTCUR,NFILT,NTNEX,KCGST
     +             ,NCGVOL,IVFUN,IVCLOS,IFACST,NCLAS1,NCLAS2,NCLAS3
      COMMON /CGBLIM/IHOLE,CGXMIN,CGXMAX,CGYMIN,CGYMAX,CGZMIN,CGZMAX
C
+KEEP,GTSCAN
      INTEGER MSLIST,NPHI,IPHIMI,IPHIMA,IPHI1,IPHIL,NTETA,MODTET,NSLMAX,
     +        MAXMDT,NSLIST,ISLIST,IPHI,ITETA,ISCUR
      REAL    PHIMIN,PHIMAX,TETMIN,TETMAX,VSCAN,FACTX0,FACTL,
     +        FACTR,SX0,SABS,TETMID,TETMAD
     +       ,SX0S,SX0T,SABSS,SABST,FACTSF
     +       ,DLTPHI,DLTETA,DPHIM1,DTETM1
     +       ,FCX0M1,FCLLM1,FCRRM1
+KEEP,GCSCAN
+SEQ,GTSCAN, IF=TYPE
      PARAMETER (MSLIST=32,MAXMDT=3)
      COMMON/GCSCAN/SCANFL,NPHI,PHIMIN,PHIMAX,NTETA,TETMIN,TETMAX,
     +              MODTET,IPHIMI,IPHIMA,IPHI1,IPHIL,NSLMAX,
     +              NSLIST,ISLIST(MSLIST),VSCAN(3),FACTX0,FACTL,
     +              FACTR,IPHI,ITETA,ISCUR,SX0,SABS,TETMID(MAXMDT),
     +              TETMAD(MAXMDT)
     +             ,SX0S,SX0T,SABSS,SABST,FACTSF
     +             ,DLTPHI,DLTETA,DPHIM1,DTETM1
     +             ,FCX0M1,FCLLM1,FCRRM1
      LOGICAL SCANFL
      COMMON/GCSCAC/SFIN,SFOUT
      CHARACTER*80 SFIN,SFOUT
*
+KEEP,GTSCAL.
      INTEGER MXSLNK, ISLINK, LSLAST, LSCAN, LSTEMP, LSPARA, LSERAY
*
+KEEP,GCSCAL.
+SEQ,GTSCAL, IF=TYPE
      PARAMETER(MXSLNK=100)
      COMMON/GCSCAL/ ISLINK(MXSLNK)
      EQUIVALENCE (LSLAST,ISLINK(MXSLNK))
      EQUIVALENCE (LSCAN ,ISLINK(1)),(LSTEMP,ISLINK(2))
      EQUIVALENCE (LSPARA,ISLINK(3)),(LSERAY,ISLINK(4))
*
+KEEP,GTPARA.
      INTEGER    BITPHI, BITTET, BITPOT
      LOGICAL    SYMPHI, SYMTEU, SYMTED
+KEEP,GCPARA.
+SEQ,GTPARA.
      PARAMETER (LSTACK = 5000)
C     BITPOT is for Phi.Or.Tet
C
C ---------------------------------------------------------
      COMMON    /GCPARA/
     +                   EPSIX0 (LSTACK)       ,
     +                   IDRPHI (LSTACK     )  , IDRTET (LSTACK     ),
     +                   IDROUT (LSTACK     )  , JPLOST (LSTACK     ),
     +                   IPHTMP (LSTACK     )  ,
     +                   BITPHI (LSTACK     )  , BITTET (LSTACK     ),
     +                   BITPOT (LSTACK     )  , JJLOST, JJFILL,
     +                                           JENTRY, JEMPTY,
     +                                           EPSMAX,
     +                   JJTEMP, JJWORK        , JJSTK1,
     +                   J1TEMP,                 J1STK1,
     +                   IFOUNP, IFOUNT        , IFNPOT,
     +                                           SYMPHI,
     +                   SYMTEU, SYMTED
C
+KEEP,GTJUMP
      INTEGER       JUDCAY, JUDIGI, JUDTIM, JUFLD , JUHADR, JUIGET,
     +              JUINME, JUINTI, JUKINE, JUNEAR, JUOUT , JUPHAD,
     +              JUSKIP, JUSTEP, JUSWIM, JUTRAK, JUTREV, JUVIEW,
     +              JUPARA
      INTEGER       JMPADR, MAXJMP
*
+KEEP,GCJUMP
+SEQ ,GTJUMP, IF=TYPE
      PARAMETER    (MAXJMP=30)
      COMMON/GCJUMP/JUDCAY, JUDIGI, JUDTIM, JUFLD , JUHADR, JUIGET,
     +              JUINME, JUINTI, JUKINE, JUNEAR, JUOUT , JUPHAD,
     +              JUSKIP, JUSTEP, JUSWIM, JUTRAK, JUTREV, JUVIEW,
     +              JUPARA
      DIMENSION     JMPADR(MAXJMP)
      EQUIVALENCE  (JMPADR(1), JUDCAY)
*
+KEEP,GCOMIS
      COMMON/GCOMIS/JUINIT,JUGEOM,JUKINE,JUSTEP,JUOUT,JULAST
      DIMENSION JPCOMS(6)
      EQUIVALENCE (JPCOMS,JUINIT)
*
+KEEP,GCXLUN
      COMMON/GCXLUN/LUNIT(128)
*
+KEEP,GTMUTR
*
      INTEGER NCVOLS,NSHIFT,KSHIFT,ICUBE,NAIN,JJJ,NIET,IVOOLD,
     +        IWPOIN,IHPOIN,IVECVO,IOLDSU,ICGP,IPORNT
      REAL    GXMIN,GXMAX,GYMIN,GYMAX,GZMIN,GZMAX,GXXXX,GYYYY,GZZZZ
      REAL    CLIPMI,CLIPMA,ABCD,BMIN,BMAX,CGB,CGB1,GBOOM
      REAL    PORGX,PORGY,PORGZ,POX,POY,POZ,PORMIR,PORMAR
+KEEP,GCMUTR
+SEQ, GTMUTR, IF=TYPE
*
      PARAMETER (MULTRA=50)
      CHARACTER*4 GNASH, GNNVV, GNVNV
      COMMON/GCMUTR/NCVOLS,KSHIFT,NSHIFT,ICUBE,NAIN,JJJ,
     +              NIET,IOLDSU,IVOOLD,IWPOIN,IHPOIN,IVECVO(100),
     +              PORGX,PORGY,PORGZ,POX(15),POY(15),POZ(15),GBOOM,
     +              PORMIR(18),PORMAR(18),IPORNT,
     +              ICGP,CLIPMI(6),CLIPMA(6),
     +              ABCD(4),BMIN(6),BMAX(6),CGB(16000),CGB1(16000),
     +              GXMIN(MULTRA),GXMAX(MULTRA),GYMIN(MULTRA),
     +              GYMAX(MULTRA),GZMIN(MULTRA),GZMAX(MULTRA),
     +              GXXXX(MULTRA),GYYYY(MULTRA),GZZZZ(MULTRA)
*
      COMMON/GCMUTC/   GNASH(MULTRA),GNNVV(MULTRA),GNVNV(MULTRA)
*
+KEEP,GTHILN.
      INTEGER LARECG,JCGOBJ,JCGCOL,JCOUNT,JCLIPS,IMPOIN,IMCOUN,
     +        JSIX,JSIY,JSIZ,JPXC,JPYC,JPZC,ICLIP1,ICLIP2
+KEEP,GCHILN.
+SEQ, GTHILN, IF=TYPE
      COMMON/GCHILN/LARECG(2), JCGOBJ, JCGCOL, JCOUNT, JCLIPS,
     +              IMPOIN, IMCOUN, JSIX, JSIY, JSIZ,
     +              JPXC, JPYC, JPZC, ICLIP1, ICLIP2
*
+KEEP,GTSPEE
*
      REAL S1,S2,S3,SS1,SS2,SS3,SRAGMX,SRAGMN,
     +     RAINT1,RAINT2,RMIN1,RMIN2,RMAX1,RMAX2
      INTEGER ISCOP,NTIM,NTFLAG,IOLDCU,ITSTCU,ISUBLI,IPORLI
      INTEGER LPASS,JPORJJ,LEP,JSC
*
+KEEP,GCSPEE.
+SEQ, GTSPEE, IF=TYPE
      COMMON/GCSPEE/S1,S2,S3,SS1,SS2,SS3,LEP,IPORLI,ISUBLI,
     +              SRAGMX,SRAGMN,RAINT1,RAINT2,RMIN1,RMIN2,
     +              RMAX1,RMAX2,JPORJJ,ITSTCU,IOLDCU,ISCOP,
     +              NTIM,NTFLAG,LPASS,JSC
*
+KEEP, LUJETS
      COMMON/LUJETS/N,K(4000,5),P(4000,5),V(4000,5)
      INTEGER N,K
      REAL P,V
      SAVE /LUJETS/
*
+KEEP, LUDAT1
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      INTEGER MSTU,MSTJ
      REAL    PARU,PARJ
      SAVE /LUDAT1/
*
+KEEP, LUDAT3
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)
      INTEGER MDCY,MDME,KFDP
      REAL    BRAT
      SAVE /LUDAT3/
*
+KEEP,GCLUND
      COMMON/GCLUND/IFLUND,ECLUND
      INTEGER IFLUND
      REAL ECLUND
C
+KEEP,PAWCT
      INTEGER NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKUIP,IFENCE,LLMAIN,IQQ,LQQ
      REAL WWS,QQ
+KEEP,PAWC
+SEQ,PAWCT,IF=TYPE.
      COMMON /PAWC/ NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKUIP,IFENCE(5),
     +              LLMAIN, WWS(9989)
      DIMENSION IQQ(2),QQ(2),LQQ(8000)
      EQUIVALENCE (QQ(1),IQQ(1),LQQ(9)),(LQQ(1),LLMAIN)
C
+KEEP,GCPMXZ.
      INTEGER MAXELZ
      PARAMETER (MAXELZ=100)
C
+KEEP,GC10EV.
      REAL G10EV,TENEV
      PARAMETER (G10EV=1.0E-8)
      PARAMETER (TENEV=1.E-2)
C
+KEEP,GCSHPT.
C  Shells are numbered from 1 to 24.
C  Shells used:
C               K,L1,L2,L3,M1,M2,M3,M4,M5
C               N1,N2,N3,N4,N5,N6,N7,
C               O1,O2,O3,O4,O5,P1,P2,P3
C   VARIABLES:
C     NSHLST - value of Z for which the shells starts to be present
C     N1ST   - pointer to K shell of a given Z (in ESHELL array)
C     NSHLLS - Number of used shells for a given Z
C     ESHELL - Shells potentials in eV !!!
      INTEGER LENGTH,MAXSHL
      PARAMETER (LENGTH=  1409)
      PARAMETER (MAXSHL=24)
      INTEGER NSHLST,N1ST,NSHLLS
      REAL ESHELL
      DIMENSION NSHLST(MAXSHL),N1ST(MAXELZ),NSHLLS(MAXELZ)
      DIMENSION ESHELL(LENGTH)
      COMMON /GCSHPT/NSHLST,N1ST,NSHLLS,ESHELL
C
+KEEP,GCPHPR.
C  Probability of radiative decay mode.
      REAL GFLUPR
      COMMON /GCPHPR/ GFLUPR(4,MAXELZ)
C
+KEEP,GCPHNR.
C  INRFIN - nonradiative decay mode
      INTEGER IGNRFN
      COMMON /GCPHNR/ IGNRFN(8,MAXELZ)
C
+KEEP,GCPHRD.
C  GRATE - radiative modes' rates
      INTEGER KSHLS,L1SHLS,L2SHLS,L3SHLS,ISHLS,ISHLUS,ISHLTR
      REAL GPHRAT
      PARAMETER (KSHLS=6)
      PARAMETER (L1SHLS=8)
      PARAMETER (L2SHLS=7)
      PARAMETER (L3SHLS=8)
      PARAMETER (ISHLS=29)
      COMMON / GCPHRD / GPHRAT(ISHLS,MAXELZ),ISHLUS(24,4),ISHLTR(ISHLS)
C
+KEEP,GCPHXS.
      INTEGER MAXPOW,MAXINT
      PARAMETER (MAXPOW=4)
      PARAMETER (MAXINT=13)
      CHARACTER*6 CRNGUP
      COMMON /GCPXRN/ CRNGUP(MAXINT,MAXELZ)
      REAL COFS,GPOMIN
      COMMON /GCPXCF/ COFS(MAXPOW,MAXINT,MAXELZ),GPOMIN(MAXELZ)
C
+KEEP, GFKDIS
      COMMON/ GFKDIS/ ZINE, ZELA, ZTOT, INT
     +               ,SINE, SELA, FSIG, IFMAT, IGF
C
C
+KEEP,GTHVIR.
      INTEGER JVIRT,JVDIV,JCONT2,JCONT
+KEEP,GCHVIR
      COMMON/GCHVIR/JVIRT,JVDIV,JCONT2,JCONT
C
+SEQ,GTHVIR,IF=TYPE.
C
+KEEP,GTVDMA.
      INTEGER NVMANY,MANYLE,MANYNA,MANYNU,
     +        NFMANY,MYCOUN,IMYSE
      REAL RAYTRA,VECCOS
+KEEP,GCVDMA
      COMMON/GCVDMA/NVMANY,MANYLE(20),MANYNA(20,15),
     +MANYNU(20,15),NFMANY,MYCOUN,IMYSE,RAYTRA,VECCOS(3)
C
+SEQ,GTVDMA,IF=TYPE.
C
+KEEP,GTFDIM.
      INTEGER NPROC,NMPTOT
      REAL TSEQTO,TOTMBY,TSEQ,TLAT,TNET,X1MIN,X1MAX,
     +     Y1MIN,Y1MAX,Z1MIN,Z1MAX,XCUT,YCUT,ZCUT
+KEEP,GCFDIM
      COMMON/GCFDIM/NPROC,NMPTOT,TSEQTO,TOTMBY,TSEQ,
     +TLAT,TNET,X1MIN,X1MAX,Y1MIN,Y1MAX,Z1MIN,Z1MAX,
     +XCUT,YCUT,ZCUT
C
+SEQ,GTFDIM,IF=TYPE.
C
+KEEP,GTRAYT.
      INTEGER INTEN,IOMBRA,IXYFLA,NOFLAG
      REAL XLPOS,YLPOS,ZLPOS,XLDIR,YLDIR,ZLDIR,APFLAH,
     +     CCXX,CCYY,CCZZ,BOFLAG,APFLAG,
     +     XCOSXS,YCOSYS,ZCOSZS,VDX,VDY,VDZ,SSLENG,
     +     XPINTS,YPINTS,ZPINTS,FPINTX,FPINTY,FPINTZ,
     +     AROTS,ZROTS,RRR
+KEEP,GCRAYT
      COMMON/GCRAYT/INTEN,IOMBRA,IXYFLA,NOFLAG,
     +XLPOS,YLPOS,ZLPOS,XLDIR,YLDIR,ZLDIR,APFLAH,
     +CCXX(4),CCYY(4),CCZZ(4),BOFLAG,APFLAG,
     +XCOSXS,YCOSYS,ZCOSZS,VDX,VDY,VDZ,SSLENG,
     +XPINTS,YPINTS,ZPINTS,FPINTX,FPINTY,FPINTZ,
     +AROTS(4,4),ZROTS(4,4),RRR(4)
C
+SEQ,GTRAYT,IF=TYPE.
C
+KEEP,GTPIXE.
      INTEGER LIMPRE,IFLAPE,ICOLOR,IXXX,IYYY,
     +        ISSEEN,ISCOLO,ISLSTY,ISLWID,ISFILL,
     +        IMAP,JON,NMAP
      REAL UUU,VVV,ZUV,ZNMAP1
+KEEP,GCPIXE
      COMMON/GCPIXE/LIMPRE,IFLAPE,ICOLOR,IXXX,IYYY,
     +ISSEEN,ISCOLO,ISLSTY,ISLWID,ISFILL,
     +IMAP,JON,NMAP,UUU,VVV,ZUV,ZNMAP1
C
+SEQ,GTPIXE,IF=TYPE.
 
+DECK,INCDEK,IF=INCLUDE.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
+KEEP,GCLINK
*
+SEQ,INCBEG
     +   gclink
+SEQ,INCEND
+KEEP,GCBANK
*
+SEQ,INCBEG
     +   gcbank
+SEQ,INCEND
+KEEP,GCCURS
*
+SEQ,INCBEG
     +   gccurs
+SEQ,INCEND
+KEEP,GCCUTS
*
+SEQ,INCBEG
     +   gccuts
+SEQ,INCEND
+KEEP,GCURSB
*
+SEQ,INCBEG
     +   gcursb
+SEQ,INCEND
+KEEP,GCFLAG
*
+SEQ,INCBEG
     +   gcflag
+SEQ,INCEND
+KEEP,GCOPTI
*
+SEQ,INCBEG
     +   gcopti
+SEQ,INCEND
+KEEP,GCJLOC
*
+SEQ,INCBEG
     +   gcjloc
+SEQ,INCEND
+KEEP,GCKINE
*
+SEQ,INCBEG
     +   gckine
+SEQ,INCEND
+KEEP,GCKMAX
*
+SEQ,INCBEG
     +   gckmax
+SEQ,INCEND
+KEEP,GCKING
*
+SEQ,INCBEG
     +   gcking
+SEQ,INCEND
+KEEP,GCLIST
*
+SEQ,INCBEG
     +   gclist
+SEQ,INCEND
+KEEP,GCMATE
*
+SEQ,INCBEG
     +   gcmate
+SEQ,INCEND
+KEEP,GCMULO
*
+SEQ,INCBEG
     +   gcmulo
+SEQ,INCEND
+KEEP,GCMZFO
*
+SEQ,INCBEG
     +   gcmzfo
+SEQ,INCEND
+KEEP,GCNUM
*
+SEQ,INCBEG
     +   gcnum
+SEQ,INCEND
+KEEP,GCONSP
*
+SEQ,INCBEG
     +   gconsp
+SEQ,INCEND
+KEEP,GCONST
*
+SEQ,INCBEG
     +   gconst
+SEQ,INCEND
+KEEP,GCPHYS
*
+SEQ,INCBEG
     +   gcphys
+SEQ,INCEND
+KEEP,GCPARM
*
+SEQ,INCBEG
     +   gcparm
+SEQ,INCEND
+KEEP,GCPOLY
*
+SEQ,INCBEG
     +   gcpoly
+SEQ,INCEND
+KEEP,GCPUSH
*
+SEQ,INCBEG
     +   gcpush
+SEQ,INCEND
+KEEP,GCRZ
*
+SEQ,INCBEG
     +   gcrz
+SEQ,INCEND
+KEEP,GCSETS
*
+SEQ,INCBEG
     +   gcsets
+SEQ,INCEND
+KEEP,GCSHNO
*
+SEQ,INCBEG
     +   gcshno
+SEQ,INCEND
+KEEP,GCSTAK
*
+SEQ,INCBEG
     +   gcstak
+SEQ,INCEND
+KEEP,GCTIME
*
+SEQ,INCBEG
     +   gctime
+SEQ,INCEND
+KEEP,GCHIL2
*
+SEQ,INCBEG
     +   gchil2
+SEQ,INCEND
+KEEP,GCTMED
*
+SEQ,INCBEG
     +   gctmed
+SEQ,INCEND
+KEEP,GCTRAK
*
+SEQ,INCBEG
     +   gctrak
+SEQ,INCEND
+KEEP,GCUNIT
*
+SEQ,INCBEG
     +   gcunit
+SEQ,INCEND
+KEEP,GCVOLU
*
+SEQ,INCBEG
     +   gcvolu
+SEQ,INCEND
+KEEP,GCVOL1
*
+SEQ,INCBEG
     +   gcvol1
+SEQ,INCEND
+KEEP,GCVOL2
*
+SEQ,INCBEG
     +   gcvol2
+SEQ,INCEND
+KEEP,GCDRAW
*
+SEQ,INCBEG
     +   gcdraw
+SEQ,INCEND
+KEEP,GSECTI
*
+SEQ,INCBEG
     +   gsecti
+SEQ,INCEND
+KEEP,GCGOBJ
*
+SEQ,INCBEG
     +   gcgobj
+SEQ,INCEND
+KEEP,GCSCAN
*
+SEQ,INCBEG
     +   gcscan
+SEQ,INCEND
+KEEP,GCSCAL
*
+SEQ,INCBEG
     +   gcscal
+SEQ,INCEND
+KEEP,GCPARA
*
+SEQ,INCBEG
     +   gcpara
+SEQ,INCEND
+KEEP,GCJUMP
*
+SEQ,INCBEG
     +   gcjump
+SEQ,INCEND
+KEEP,GCOMIS
*
+SEQ,INCBEG
     +   gcomis
+SEQ,INCEND
+KEEP,GCXLUN
*
+SEQ,INCBEG
     +   gcxlun
+SEQ,INCEND
+KEEP,GCMUTR
*
+SEQ,INCBEG
     +   gcmutr
+SEQ,INCEND
+KEEP,GCHILN
*
+SEQ,INCBEG
     +   gchiln
+SEQ,INCEND
+KEEP,GCSPEE
*
+SEQ,INCBEG
     +   gcspee
+SEQ,INCEND
+KEEP, LUJETS
*
+SEQ,INCBEG
     +    lujets
+SEQ,INCEND
+KEEP, LUDAT1
*
+SEQ,INCBEG
     +    ludat1
+SEQ,INCEND
+KEEP, LUDAT3
*
+SEQ,INCBEG
     +    ludat3
+SEQ,INCEND
+KEEP,GCLUND
*
+SEQ,INCBEG
     +   gclund
+SEQ,INCEND
+KEEP,PAWC
*
+SEQ,INCBEG
     +   pawc
+SEQ,INCEND
+KEEP,GCPMXZ
*
+SEQ,INCBEG
     +   gcpmxz
+SEQ,INCEND
+KEEP,GC10EV
*
+SEQ,INCBEG
     +   gc10ev
+SEQ,INCEND
+KEEP,GCSHPT
*
+SEQ,INCBEG
     +   gcshpt
+SEQ,INCEND
+KEEP,GCPHPR
*
+SEQ,INCBEG
     +   gcphpr
+SEQ,INCEND
+KEEP,GCPHNR
*
+SEQ,INCBEG
     +   gcphnr
+SEQ,INCEND
+KEEP,GCPHRD
*
+SEQ,INCBEG
     +   gcphrd
+SEQ,INCEND
+KEEP,GCPHXS
*
+SEQ,INCBEG
     +   gcphxs
+SEQ,INCEND
+KEEP,GCPOTM
*
+SEQ,INCBEG
     +   gcpotm
+SEQ,INCEND
+PATCH,GTINCL,IF=MINCL
+DECK,GCBANK
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCBANK
+DECK,GCCURS
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCCURS
+DECK,GCCUTS
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCCUTS
+DECK,GCDRAW
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCDRAW
+DECK,GCFLAG
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCFLAG
+DECK,GCGOBJ
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCGOBJ
+DECK,GCHIL2.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCHIL2.
+DECK,GCHILN.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCHILN.
+DECK,GCJLOC
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCJLOC
+DECK,GCJUMP
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCJUMP
+DECK,GCKINE
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCKINE
+DECK,GCKING
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCKING
+DECK,GCKMAX
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCKMAX
+DECK,GCLINK
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCLINK
+DECK,GCLIST
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCLIST
+DECK,GCLUND
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCLUND
+DECK,GCMATE
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCMATE
+DECK,GCMULO
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCMULO
+DECK,GCMUTR
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCMUTR
+DECK,GCMZFO
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCMZFO
+DECK,GCNUM
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCNUM
+DECK,GCOMIS
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCOMIS
+DECK,GCONSP
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCONSP
+DECK,GCONST.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCONST.
+DECK,GCOPTI
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCOPTI
+DECK,GCPARA.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPARA.
+DECK,GCPARM.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPARM.
+DECK,GCPHNR.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPHNR.
+DECK,GCPHPR.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPHPR.
+DECK,GCPHRD.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPHRD.
+DECK,GCPHXS.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPHXS.
+DECK,GCPHYS
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPHYS
+DECK,GCPMXZ.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPMXZ.
+DECK,GCPOLY
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPOLY
+DECK,GCPOTM.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPOTM.
+DECK,GCPUSH
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCPUSH
+DECK,GCRZ
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCRZ
+DECK,GCSCAL.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCSCAL.
+DECK,GCSCAN
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCSCAN
+DECK,GCSETS.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCSETS.
+DECK,GCSHNO.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCSHNO.
+DECK,GCSHPT.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCSHPT.
+DECK,GCSPEE.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCSPEE.
+DECK,GCSTAK.
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCSTAK.
+DECK,GCTIME
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCTIME
+DECK,GCTMED
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCTMED
+DECK,GCTRAK
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCTRAK
+DECK,GCUNIT
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCUNIT
+DECK,GCURSB
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCURSB
+DECK,GCVOL1
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCVOL1
+DECK,GCVOL2
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCVOL2
+DECK,GCVOLU
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCVOLU
+DECK,GCXLUN
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GCXLUN
+DECK,GSECTI
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,GSECTI
+DECK, LUDAT1
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ, LUDAT1
+DECK, LUDAT3
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ, LUDAT3
+DECK, LUJETS
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ, LUJETS
+DECK,PAWC
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
*-- Author :
*
+SEQ,PAWC
*-- Author :
+PATCH,GBASE
+DECK,DOCGBASE,IF=DOC
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                                                                      *
*                         Introduction to GEANT3                       *
*                         ----------------------                       *
*                                                                      *
*                                                                      *
*    GEANT3 APPLICATIONS                                               *
*                                                                      *
*  The principal applications of GEANT3 are:                           *
*                                                                      *
*  - The  tracking of  particles  through an  experimental setup  for  *
*    acceptance studies or simulation of detector response, and        *
*  - the graphical  representation of the  setup and of  the particle  *
*    trajectories.                                                     *
*                                                                      *
*  It is of course desirable and  very instructive to combine the two  *
*  interactively since the observation of  what happens to a particle  *
*  during the tracking may underline  the weaknesses of the setup and  *
*  makes  the debugging  easier. In view  of these  applications, the  *
*  GEANT3 system allows:                                               *
*                                                                      *
*  - to  describe an  experimental setup  in a  rather efficient  and  *
*    simple  way.   The  setup  is  represented  by  a  structure  of  *
*    geometrical VOLUMEs.  Each volume is  given a 'MEDIUM' number by  *
*    the user.   Different volumes  may have  the same  medium number  *
*    [GEOM].   A  medium is  defined  by  a  set of  parameters,  the  *
*    so-called TRACKING MEDIUM parameters, which include reference to  *
*    the MATERIAL filling the volume [CONS].                           *
*  - to  generate   simulated  events   from  standard   Monte  Carlo  *
*    generators [KINE].                                                *
*  - to  control  the  transport  of particles  through  the  various  *
*    regions of the setup, taking into account the geometrical volume  *
*    boundaries and  all physical  effects due to  the nature  of the  *
*    particles themselves, to their  interactions with the matter and  *
*    to the magnetic field [TRAK, PHYS].                               *
*  - to  record the  elements of  the particle  trajectories and  the  *
*    response from the sensitive detectors [HITS],                     *
*  - to visualize either interactively  or in batch the detectors and  *
*    the particle trajectories [DRAW, XINT].                           *
*                                                                      *
*   Part of the  subroutines available in GEANT3  are integrated into  *
*  program segments which perform these tasks.                         *
*   The  program  segments may  contain  'dummy'  and 'default'  user  *
*  subroutines  called  whenever  application dependent  actions  are  *
*  expected.                                                           *
*   Other  subroutines   provide  tools  either  to   perform  simple  *
*  functions (control  print, debug, I/O,  etc.) or to  implement the  *
*  operations required  for most of the  applications (description of  *
*  the geometrical setup, handling of detector responses,etc.).        *
*   It is the responsibility of  the user to assemble the appropriate  *
*  program segments and tools into an executable program, to code the  *
*  relevant  user subroutines,  to  provide the  data describing  the  *
*  experimental environment and to  submit the appropriate data cards  *
*  which control the  execution of the program.  The  section BASE of  *
*  the User's Guide gives the information necessary to understand how  *
*  to do this job.                                                     *
*                                                                      *
*  Note: as a  general convention the  names of the dummy  or default  *
*        user subroutines have GU or UG  as first two letters and are  *
*        printed in bold characters.                                   *
*                                                                      *
*  EVENT SIMULATION FRAMEWORK                                          *
*                                                                      *
*  The framework for  event simulation is described  in the following  *
*  paragraphs to  familiarize the  reader with  the areas  where user  *
*  interventions are expected.                                         *
*   At  the same  time, the  GEANT3 data  structures are  introduced.  *
*  This last point  is important as the coding to  be provided by the  *
*  user  often consists  of  filling data  structures, or  extracting  *
*  information from  them, or  saving them on  output, making  use of  *
*  standard routines available in the system.                          *
*   A main  program has to  be provided by  the user [BASE  100].  It  *
*  allocates the dynamic memory for ZEBRA and HBOOK and gives control  *
*  to the three phases of the run:                                     *
*                                                                      *
*  - Initialisation                                                    *
*  - Event processing                                                  *
*  - Termination.                                                      *
*                                                                      *
*  INITIALISATION                                                      *
*                                                                      *
*  The initialisation  phase is under  the control of the  user [BASE  *
*  100].  It consists of the  following steps, most of them performed  *
*  via calls to standard GEANT3 subroutines:                           *
*                                                                      *
*  - GINIT,  to  initialize the  GEANT3  common  blocks with  default  *
*    values which the user should be aware of [BASE 030, 110].         *
*  - GFFGO to read  'free format' data cards which  can override some  *
*    of the  values defined in  GINIT the default options  [BASE 040,  *
*    110].                                                             *
*  - GZINIT to initialize the dynamic  core divisions, the link areas  *
*    and the data structure JRUNG [BASE 110].                          *
*  - GDINIT  to initialize the drawing package [DRAW].                 *
*  - GPART  and auxiliaries,  to  generate the  data structure  JPART  *
*    describing the standard particle properties [CONS].               *
*  - GMATE  and auxiliaries,  to  generate the  data structure  JMATE  *
*    describing  the  characteristics  of   the  most  commonly  used  *
*    MATERIALs [CONS].                                                 *
*  - <USER> to define the geometry of the different components of the  *
*    experimental  setup [GEOM]  and the  tracking medium  parameters  *
*    [CONS,TRAK], and  to generate the corresponding  data structures  *
*    JROTM, JVOLUM and JTMED.                                          *
*  - <USER> to specify which elements of the geometrical setup should  *
*    be considered as 'sensitive detectors', giving a 'response' when  *
*    hit by a particle [HITS].                                         *
*  - GGCLOS to close the Geometry package (mandatory).                 *
*  - GBHSTA to  book standard  GEANT3 histograms  as required  by the  *
*    user with the data card HSTA [BASE 040, 110].                     *
*  - GPHYSI to  compute energy loss  and cross section tables  and to  *
*    store them in the data structure JMATE [CONS,PHYS].               *
*                                                                      *
*  EVENT PROCESSING                                                    *
*                                                                      *
*  The processing phase is triggered by  a call to the subroutine GRUN *
*  which,  for each  event to  be  processed,  gives  control to  the  *
*  subroutines:                                                        *
*                                                                      *
*  - GTRIGI, to  initialize the  event processing  and to  create the  *
*    Header bank JHEAD.                                                *
*  - GTRIG to process the event.                                       *
*  - GTRIGC to clean up the event division                             *
*                                                                      *
*  and checks that enough time is left for the next event [BASE 200].  *
*  The main  steps of GTRIG  consist of  calls to the  following user  *
*  routines:                                                           *
*                                                                      *
*  - GUKINE generates the data structures JVERTX and JKINE describing  *
*    the kinematics  of the current  event on input [KINE],  or reads  *
*    them [IOPA].                                                      *
*  - GUTREV (calls GTREVE) controls the  tracking for the whole event  *
*    [TRAK].  Each particle  is tracked in turn and  when a sensitive  *
*    detector is  hit, the user  may store any useful  information in  *
*    the  data  structure JHITS  [HITS].   Before  tracking the  next  *
*    particle, any  secondary products generated by  the current one,  *
*    and stored  by the user  in the temporary data  structure JSTAK,  *
*    are processed in the same way.                                    *
*    Simultaneously,   the  data   structure  JXYZ,   containing  the  *
*    coordinates  of space  points  along the  tracks  for the  whole  *
*    event, can be filled by the user [TRAK].                          *
*  - GUDIGI  simulates the  detector responses  for the  whole event,  *
*    making use  of the information  previously recorded in  the data  *
*    structure JHITS,  and stores the  results in the  data structure  *
*    JDIGI [HITS].                                                     *
*  - GUOUT outputs the relevant data structures for the current event  *
*    [IOPA].                                                           *
*                                                                      *
*  Other user routines called during  the tracking phase triggered by  *
*  GTREVE should be mentioned for completeness:                        *
*                                                                      *
*  - The hadronic processes activated by  default for the tracking of  *
*    hadrons in  GEANT3 are  described by  the program  GHEISHA (file  *
*    GEANH).  In  the subroutines GUPHAD  and GUHADR [TRAK]  the user  *
*    may select, instead of GHEISHA,  the program FLUKA (file GEANF).  *
*  - After each  tracking step of  a given  track in a  given medium,  *
*    control is given to the subroutine GUSTEP.  From the information  *
*    available  in  common  blocks  the  user is  able  to  take  the  *
*    appropriate  action, such  as  storing a  hit or transferring  a  *
*    secondary product  either in  the stack JSTAK  or in  the events  *
*    structure JVERTX/JKINE.                                           *
*  - The subroutine GUSWIM is called  by various tracking routines to  *
*    select the appropriate  code for transport of  the particle over  *
*    the given tracking  step.  A default version is  provided in the  *
*    library for  this routine which in  normal cases need not  to be  *
*    provided by the user.                                             *
*  - The magnetic field,  unless constant with no  X- or Y-component,  *
*    has to be returned by the user subroutine GUFLD.                  *
*                                                                      *
*  TERMINATION                                                         *
*                                                                      *
*   The  termination phase  is under  the control  of the  user [BASE  *
*  300].  For trivial applications it may simply consist of a call to  *
*  the subroutine  GLAST which  computes and prints  some statistical  *
*  information (time per event, use of dynamic memory, etc.).          *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*                                                                      *
*                  Simplified Program Flow Chart                       *
*                  -----------------------------                       *
*                                                                      *
*  MAIN(user)                                                          *
*  |                                                                   *
*  |-GZEBRA  initialisation   of   ZEBRA  system, dynamic core         *
*  |         allocation                                                *
*  |-UGINIT  (user)                                                    *
*  ||                                                                  *
*  ||- GINIT    initialisation of GEANT3 variables                     *
*  ||- GFFGO    interpretation of data cards                           *
*  ||- GZINIT   initialisation  of ZEBRA  core  divisions and  link    *
*  ||           areas                                                  *
*  ||- GPART    creation of the 'particle' data structure JPART        *
*  ||- GMATE    creation of the 'material' data structure JMATE        *
*  ||- <USER>   description  of the geometrical setup,   of the        *
*  ||           sensitive detectors and creation of data structures    *
*  ||           JVOLUM, JTMED, JROTM, JSETS                            *
*  ||- GGCLOS   close Geometry package                                 *
*  ||- GPHYSI   preparation of cross-sections and energy loss tables   *
*  |            for all used materials                                 *
*  |                                                                   *
*  |-GRUN (loop over events)                                           *
*  ||                                                                  *
*  ||- GTRIGI   initialisation for event processing                    *
*  ||- GTRIG    event processing                                       *
*  ||  |                                                               *
*  ||  |- GUKINE (user)  generation (or input)  of  event initial      *
*  ||  |                 kinematics                                    *
*  ||  |- GUTREV (user)                                                *
*  ||  |   |- GTREVE   (simplified flow for sequential tracking)       *
*  ||  |      |- GSSTAK   store primary tracks in stack                *
*  ||  |      |- Loop over tracks                                      *
*  ||  |        |- GLTRAC   prepare commons for tracking               *
*  ||  |            |- GMEDIA  find current volume /tracking medium    *
*  ||  |        |- GUTRAK (user)                                       *
*  ||  |          |- GTRACK                                            *
*  ||  |            |- GTGAMA/GTELEC/...  tracking   of  particle      *
*  ||  |                                  according to type            *
*  ||  |                 |-   compute physical step size               *
*  ||  |                 |- GTNEXT compute geometrical step size       *
*  ||  |                 |-   propagate (GUSWIM..)                     *
*  ||  |                 |-   test change of volume (GINVOL)           *
*  ||  |            |- GUSTEP (user) recording of hits in data         *
*  ||  |                      structure JHITS and of space points      *
*  ||  |                      in structure JXYZ                        *
*  ||  |- GUDIGI computation  of  digitisations  and recording  in     *
*  ||  |         structure JDIGI                                       *
*  ||  |- GUOUT  output of current event                               *
*  ||                                                                  *
*  ||- GTRIGC   clearing of memory for next event                      *
*  |                                                                   *
*  |-UGLAST (user)                                                     *
*  ||                                                                  *
*  ||- GLAST    standard GEANT3 termination.                           *
*  |                                                                   *
*  |                                                                   *
*  STOP                                                                *
*                                                                      *
*                                                                      *
************************************************************************
************************************************************************
*                                                                      *
*                    Overview of COMMON Blocks                         *
*                    -------------------------                         *
*                                                                      *
*                                                                      *
*  INTRODUCTION                                                        *
*                                                                      *
*  The communication between program segments of the GEANT3 system is  *
*  ensured by data structures and by 'long range' variables in common  *
*  blocks.  In addition,within the  program segments, the subroutines  *
*  communicate with each other  via  explicit arguments  and via  the  *
*  common block variables.                                             *
*   The data structures are described in separate sections. Here, the  *
*  main features of the common  blocks used in GEANT3 are summarized,  *
*  with special mention of the  variables initialized in GINIT and of  *
*  the possibility to override them via data cards [BASE040].          *
*   The  labelled   common  blocks  are  accessible   via  Patchy/CMZ  *
*  sequences identified by the name  of the COMMON.  They are defined  *
*  in the Patch GCDES.                                                 *
*                                                                      *
*  Note: Unless  otherwise specified  the  long  range variables  are  *
*        initialized  in GINIT.   When not  zero, default  values are  *
*        quoted between brackets.  If the value may be modified via a  *
*        standard data  card the  card  keyword is also given between  *
*        brackets.                                                     *
*                                                                      *
*  DYNAMIC CORE                                                        *
*                                                                      *
*  The  GEANT3 data  structures  are stored  in  the common  /GCBANK/  *
*  accessible via the following Patchy sequence.                       *
*                                                                      *
*+KEEP,GCBANK                                                          *
*     PARAMETER (KWBANK=69000,KWWORK=5200)                             *
*     COMMON/GCBANK/NZEBRA,GVERSN,ZVERSN,IXSTOR,IXDIV,IXCONS,FENDQ(16) *
*    +             ,LMAIN,LR1,WS(KWBANK)                               *
*     DIMENSION IQ(2),Q(2),LQ(8000),IWS(2)                             *
*     EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN),(IWS(1),WS(1))      *
*     EQUIVALENCE (JCG,JGSTAT)                                         *
*     COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART    *
*    +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX   *
*    +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT                         *
*                                                                      *
*  The /GCLINK/ variables are pointers to the GEANT3 data structures.  *
*  They belong  to a permanent  area declared in GZINIT.   The common  *
*  /GCLINK/ alone may be accessed through the sequence GCLINK.         *
*                                                                      *
*  OTHER LABELLED COMMON BLOCKS                                        *
*                                                                      *
*        COMMON/GCCUTS/CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM) *
*       +             ,DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS(5)            *
*  C                                                                   *
*  CUTGAM   Kinetic energy cut for gammas              (0.001, CUTS)   *
*  CUTELE   Kinetic energy cut for electrons           (0.001, CUTS)   *
*  CUTHAD   Kinetic energy cut for hadrons             (0.01, CUTS)    *
*  CUTNEU   Kinetic energy cut for neutral hadrons     (0.01, CUTS)    *
*  CUTMUO   Kinetic energy cut for muons               (0.01, CUTS)    *
*  BCUTE    Kinetic energy cut for electron Brems.     (CUTGAM, CUTS)  *
*  BCUTM    Kinetic energy cut for muon Brems.         (CUTGAM, CUTS)  *
*  DCUTE    Kinetic energy cut for electron delta-rays (CUTELE, CUTS)  *
*  DCUTM    Kinetic energy cut for muon delta-rays     (CUTELE, CUTS)  *
*  PPCUTM   Kinetic energy cut for e+e- pair production by muons       *
*                                                      (.01, CUTS)     *
*  TOFMAX   Tracking cut on time of flight integrated from  primary    *
*           interaction time                           (1.E+10, CUTS)  *
*  GCUTS    For user applications                      (CUTS)          *
*                                                                      *
*  Note: The cuts BCUTE, BCUTM and DCUTE, DCUTM are given, in GPHYSI,  *
*        the  respective  default  values CUTGAM  and  CUTELE.   Only  *
*        experienced users should make use of the facility offered by  *
*        the data card CUTS to  change BCUTE, DCUTE, BCUTM and DCUTM.  *
*                                                                      *
*     COMMON /GCDRAW/ .....                                            *
*                     see GEANG Pam file                               *
*                                                                      *
*        COMMON/GCFLAG/IDEBUG,IDEMIN,IDEMAX,ITEST,IDRUN,IDEVT,IEORUN   *
*       +        ,IEOTRI,IEVENT,ISWIT(10),IFINIT(20),NEVENT,NRNDM(2)   *
*        COMMON/GCFLAX/BATCH, NOLOG                                    *
*        LOGICAL BATCH, NOLOG                                          *
*  C                                                                   *
*  IDEBUG   Flag set equal to 1 to activate debug if IEVENT (below)    *
*  IDEMIN            is greater or equal to IDEMIN                     *
*  IDEMAX            and less or equal to IDEMAX             (DEBU)    *
*  ITEST    Flag to request printing of IEVENT, IDEVT and NRNDM        *
*           (below) every ITEST events                       (DEBU)    *
*  IDRUN    Current user run number                        (1, RUN)    *
*  IDEVT    Current user event number                         (RUN)    *
*  IEORUN   Flag to terminate current run if non zero                  *
*  IEOTRI   Flag to abort current event if non zero                    *
*  IEVENT   Current event sequence number                       (1)    *
*  ISWIT    Flags reserved for user in relation to debug     (SWIT)    *
*  IFINIT   System flags to check initialisation of GEANT routines     *
*  NEVENT   Number of events to be processed        (10000000,TRIG)    *
*  NRNDM    Initial value of random number seeds NRNDM(1),             *
*           NRNDM(2). If NRNDM(2) is 0, the independent sequence       *
*           NRNDM(1) is used. If NRNDM(1) is 0, the default sequence   *
*           is used. (9876, 54321, RNDM)                               *
*  BATCH    Flag set to .TRUE. if the program is running in            *
*           batch.                                                     *
*  NOLOG    Flag set to .TRUE. if the no logon file has been           *
*           requested.                                                 *
*                                                                      *
*        COMMON/GCJLOC/NJLOC(2),JTM,JMA,JLOSS,JPROB,JMIXT,JPHOT,JANNI  *
*       +                  ,JCOMP,JBREM,JPAIR,JDRAY,JPFIS,JMUNU,JRAYL  *
*       +                  ,JMULOF,JCOEF,JRANG                         *
*  C                                                                   *
*   For relocation of local pointers. Self-explanatory [CONS 199].     *
*                                                                      *
*        COMMON/GCKINE/IKINE,PKINE(10),ITRA,ISTAK,IVERT,IPART,ITRTYP   *
*       +      ,NAPART(5),AMASS,CHARGE,TLIFE,VERT(3),PVERT(4),IPAOLD   *
*  C                                                                   *
*  IKINE    User flag(0, KINE)                                         *
*  PKINE    User array(1E10, KINE)                                     *
*  ITRA     Current track number                                       *
*  ISTAK    Current stack-track number                                 *
*  IVERT    Current vertex number                                      *
*  IPART    Current particle number                                    *
*  ITRTYP   Tracking type of current particle                          *
*  NAPART   Name of current particle                                   *
*  AMASS    Mass of current particle                                   *
*  CHARGE   Charge of current particle                                 *
*  TLIFE    Life-time of current particle                              *
*  VERT     Coordinates of origin vertex for current track             *
*  PVERT    Track kinematics at origin vertex (PVERT(4) no longer      *
*           used)                                                      *
*  IPAOLD   Particle number of the previous track.                     *
*                                                                      *
*        INTEGER MXGKIN                                                *
*        PARAMETER (MXGKIN=100)                                        *
*        COMMON/GCKING/KCASE,NGKINE,GKIN(5,MXGKIN),                    *
*       +                           TOFD(MXGKIN),IFLGK(MXGKIN)         *
*  KCASE     Mechanism having generated the secondary particles        *
*  NGKINE    Number of generated secondaries                           *
*  GKIN(1,I) Px      of I-th secondary                                 *
*  GKIN(2,I) Py               " "                                      *
*  GKIN(3,I) Pz               " "                                      *
*  GKIN(4,I) E                " "                                      *
*  GKIN(5,I) Particle number  " "                                      *
*  TOFD(I)   Time delay introduced by the interaction.                 *
*                                                                      *
*     COMMON/GCLIST/NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT    *
*    +       ,NSTAT,LHSTA(20),LGET (20),LSAVE(20),LSETS(20),LPRIN(20)  *
*    +             ,LGEOM(20),LVIEW(20),LPLOT(20),LSTAT(20)            *
*C                                                                     *
*  NHSTA    Number of histograms declared on data card HSTA            *
*  NGET     Number of data structures declared on data card GET        *
*  NSAVE    Number of data structures declared on data card SAVE       *
*  NSETS    Number of items described on data card SETS                *
*  NPRIN    Number of items described on data card PRIN                *
*  NGEOM    Number of items described on data card GEOM                *
*  NVIEW    Number of items described on data card VIEW                *
*  NPLOT    Number of items described on data card PLOT                *
*  NSTAT    Number of items described on data card STAT                *
*  LHSTA,...,LSTAT Corresponding user lists of items (HSTA,...,STAT)   *
*                                                                      *
*   See examples of utilisation of  the user lists in GEANT3 examples  *
*  in  GEANX file.   LSTAT(1) is  reserved by  the system  for volume  *
*  statistics.                                                         *
*                                                                      *
*        COMMON/GCMATE/NMAT,NAMATE(5),A,Z,DENS,RADL,ABSL               *
*  C                                                                   *
*  NMAT      Current material number                                   *
*  NAMATE    Name of current material                                  *
*  A         Atomic weight of current material                         *
*  Z         Atomic number of current material                         *
*  DENS      Density of current material                               *
*  RADL      Radiation length of current material                      *
*  ABSL      Absorption length of current material                     *
*                                                                      *
*     COMMON/GCMULO/SINMUL(101),COSMUL(101),SQRMUL(101),OMCMOL,CHCMOL  *
*    +  ,EKMIN,EKMAX,NEKBIN,NEK1,EKINV,GEKA,GEKB,EKBIN(200),ELOW(200)  *
*                                                                      *
*   Pre-computed  quantities  for   multiple  scattering  and  energy  *
*  binning [CONS 199]                                                  *
*  SINMUL   Not used                                                   *
*  COSMUL   Not used                                                   *
*  SQRMUL   Not used                                                   *
*  OMCMOL   Constant Omega for Moliere scattering                      *
*  CHCMOL   Constant for Moliere scattering                            *
*  EKMIN    Lower edge for the energy range           (1E-5, ERAN)     *
*  EKMAX    Upper edge for the energy range           (1E+4, ERAN)     *
*  NEKBIN   Number of energy bins to be used          (90, ERAN)       *
*  NEK1     Number of energy bins to be used + 1                       *
*  EKINV    \                                                          *
*  GEKA      >Constants for the energy binning                         *
*  GEKB     /                                                          *
*  EKBIN    Lower edges of energy bins                                 *
*  ELOW     Lower edges of logarithm of energy bins                    *
*                                                                      *
*        COMMON/GCNUM/NMATE ,NVOLUM,NROTM,NTMED,NTMULT,NTRACK,NPART    *
*       +            ,NSTMAX,NVERTX,NHEAD,NBIT                         *
*        COMMON /GCNUMX/ NALIVE,NTMSTO                                 *
*  C                                                                   *
*  NMATE    Number of Materials                                        *
*  NVOLUM   Number of Volumes                                          *
*  NROTM    Number of Rotation matrices                                *
*  NTMED    Number of Tracking media                                   *
*  NTMULT   Number of  tracks processed  in current  event (including  *
*           secondaries), reset to 0 for each event                    *
*  NTRACK   Number of tracks in JKINE banks for current event          *
*  NPART    Number of Particle banks                                   *
*  NSTMAX   Maximum  number of  tracks  in  stack JSTAK  for  current  *
*           event, reset to 0 for each event                           *
*  NVERTX   Number of Vertices in JVERTX banks for current event       *
*  NHEAD    Number of data words in the JHEAD bank       (10)          *
*  NBIT     Number of bits per word (initialized in GINIT via FFINIT   *
*  NALIVE   Internal counter used for parallel tracking                *
*  NTMSTO   Internal counter used for parallel tracking                *
*                                                                      *
**KEEP,GCONSP                                                          *
*      DOUBLE PRECISION PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS  *
*      DOUBLE PRECISION EMMU,PMASS,AVO                                 *
*C                                                                     *
*      PARAMETER (PI=3.14159265358979324)                              *
*      PARAMETER (TWOPI=6.28318530717958648)                           *
*      PARAMETER (PIBY2=1.57079632679489662)                           *
*      PARAMETER (DEGRAD=0.0174532925199432958)                        *
*      PARAMETER (RADDEG=57.2957795130823209)                          *
*      PARAMETER (CLIGHT=29979245800.)                                 *
*      PARAMETER (BIG=10000000000.)                                    *
*      PARAMETER (EMASS=0.0005109990615)                               *
*      PARAMETER (EMMU=0.105658387)                                    *
*      PARAMETER (PMASS=0.9382723128)                                  *
*      PARAMETER (AVO=0.60221367)                                      *
*                                                                      *
*  PI       Number PI                                                  *
*  TWOPI    (2.*PI)                                                    *
*  PIBY2    (PI/2.)                                                    *
*  DEGRAD   Degree to radian conversion factor  (PI/180.)              *
*  RADDEG   Radian to degree conversion factor  (180./PI)              *
*  CLIGHT   Light velocity                                             *
*  BIG      Arbitrary large number                                     *
*  EMASS    Electron mass                                              *
*  EMMU     Muon mass                                                  *
*  PMASS    Proton mass                                                *
*  AVO      Avogadro Number * 1E-24                                    *
*                                                                      *
*  Control of Geometry optimisation                                    *
*     COMMON/GCOPTI/IOPTIM                                             *
*  IOPTIM  -1 = No optimisation at all. GSORD calls disabled           *
*           0 = No optimisation. Only user calls to GSORD kept         *
*           1 = All non-ordered volumes are ordered along the best axis*
*           2 = All volumes are ordered along the best axis            *
*                                                                      *
*   Control of physics processes.                                      *
*        COMMON/GCPHYS/IPAIR,SPAIR,SLPAIR,ZINTPA,STEPPA                *
*       +             ,ICOMP,SCOMP,SLCOMP,ZINTCO,STEPCO                *
*       +             ,IPHOT,SPHOT,SLPHOT,ZINTPH,STEPPH                *
*       +             ,IPFIS,SPFIS,SLPFIS,ZINTPF,STEPPF                *
*       +             ,IDRAY,SDRAY,SLDRAY,ZINTDR,STEPDR                *
*       +             ,IANNI,SANNI,SLANNI,ZINTAN,STEPAN                *
*       +             ,IBREM,SBREM,SLBREM,ZINTBR,STEPBR                *
*       +             ,IHADR,SHADR,SLHADR,ZINTHA,STEPHA                *
*       +             ,IMUNU,SMUNU,SLMUNU,ZINTMU,STEPMU                *
*       +             ,IDCAY,SDCAY,SLIFE ,SUMLIF,DPHYS1                *
*       +             ,ILOSS,SLOSS,SOLOSS,STLOSS,DPHYS2                *
*       +             ,IMULS,SMULS,SOMULS,STMULS,DPHYS3                *
*       +             ,IRAYL,SRAYL,SLRAYL,ZINTRA,STEPRA                *
*  *                                                                   *
*  IPAIR    Controls pair production process               (1,PAIR)    *
*           0 = no pair production                                     *
*           1 = pair production with generation of secondaries         *
*           2 = same without generation of secondaries                 *
*  ICOMP    Controls Compton scattering process            (1,COMP)    *
*           0 = no Compton scattering                                  *
*           1 = Compton scattering with generation of secondaries      *
*           2 = same without generation of secondaries                 *
*  IPHOT    Controls photo-electric effect process         (1,PHOT)    *
*           0 = no photo-electric effect                               *
*           1 = photo-electric effect with generation of secondaries   *
*           2 = same without generation of secondaries                 *
*  IPFIS    Controls photofission process                  (0,PFIS)    *
*           0 = no photofission                                        *
*           1 = photofission with generation of secondaries            *
*           2 = same without generation of secondaries                 *
*  IDRAY    Controls delta rays process                    (1,DRAY)    *
*           0 = no delta rays effect                                   *
*           1 = delta rays with generation of secondaries              *
*           2 = same without generation of secondaries                 *
*  IANNI    Controls positron annihilation process         (1,ANNI)    *
*           0 = no positron annihilation effect                        *
*           1 = positron annihilation with generation of secondaries   *
*           2 = same without generation of secondaries                 *
*  IBREM    Controls Bremsstrahlung process                (1,BREM)    *
*           0 = no Bremsstrahlung effect                               *
*           1 = Bremsstrahlung with generation of secondaries          *
*           2 = same without generation of secondaries                 *
*  IHADR    Controls hadron interactions process           (1,HADR)    *
*           0 = no hadron interactions effect                          *
*           1 = hadron interactions with generation of secondaries     *
*           2 = same without generation of secondaries                 *
*  IMUNU    Controls muon nuclear interaction process       (0,MUNU)   *
*           0 = no muon nuclear interaction effect                     *
*           1 = muon nuclear interaction with generation of secondaries*
*           2 = same without generation of secondaries                 *
*  IDCAY    Controls decay process                          (1,DCAY)   *
*           0 = no decay effect                                        *
*           1 = decay with generation of secondaries                   *
*           2 = same without generation of secondaries                 *
*  ILOSS    Controls energy loss process                    (2,LOSS)   *
*           0 = no energy loss effect                                  *
*           1 = delta ray and reduced Landau fluctuations              *
*           2 = full Landau fluctuations and no delta rays             *
*           3 = same as 1                                              *
*           4 = average Energy loss and no fluctuations                *
*  IMULS    Controls multiple scattering                   (1,MULS)    *
*           1 = Moliere or Coulomb scattering                          *
*           2 = Moliere or Coulomb scattering                          *
*           3 = Gaussian scattering                                    *
*  IRAYL    0 = No Rayleigh scattering                                 *
*           1 = Rayleigh scattering                                    *
*                                                                      *
*        COMMON/GCPOLY/IZSEC,IPSEC                                     *
*  C                                                                   *
*  Internal flags for polygon and polycone shapes. See GEANG file.     *
*                                                                      *
*        COMMON/GCPUSH/NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ       *
*  C                                                                   *
*  NCVERT   Initial size of mother bank JVERTX              (5)        *
*  NCKINE   Initial size of mother bank JKINE              (50)        *
*  NCJXYZ   Initial size of mother bank JXYZ               (50)        *
*  NPVERT   Increment for size of mother bank JVERTX        (5)        *
*  NPKINE   Increment for size of mother bank JKINE        (10)        *
*  NPJXYZ   Increment for size of mother bank JXYZ         (10)        *
*                                                                      *
*        COMMON/GCSETS/IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV(20)   *
*  C                                                                   *
*  IHSET    Set identifier                                             *
*  IHDET    Detector identifier                                        *
*  ISET     Position of set in bank JSET                               *
*  IDET     Position of detector in bank JS=IB(JSET-IDET)              *
*  IDTYPE   User defined detector type                                 *
*  NVNAME   Number of elements in NUMBV                                *
*  NUMBV    List of volume numbers to identify the detector            *
*                                                                      *
*      PARAMETER (NWSTAK=12,NWINT=11,NWREAL=12,NWTRAC=NWINT+NWREAL+5)  *
*      COMMON /GCSTAK/ NJTMAX, NJTMIN, NTSTKP, NTSTKS, NDBOOK, NDPUSH, *
*     +                NJFREE, NJGARB, NJINVO, LINSAV(15), LMXSAV(15)  *
*C                                                                     *
*  NTKSTP   Primary allocation for stack JSTAK                         *
*  NTKSTS   Secondary allocation for stack JSTAK                       *
*  NDBOOK   local variable for control of stack size                   *
*  NDPUSH   local variable for control of stack size                   *
*  (other variables used in parallel tracking only)                    *
*                                                                      *
*        COMMON/GCTIME/TIMINT,TIMEND,ITIME,IGDATE,IGTIME               *
*        INTEGER ITIME,IGDATE,IGTIME                                   *
*        REAL TIMINT,TIMEND                                            *
*  C                                                                   *
*  TIMINT   Total time left after initialization  (System, TIME)       *
*  TIMEND   Time required for program termination phase (1., TIME)     *
*  ITIME    Test on time left done every ITIME events (1, ITIME)       *
*  IGDATE   Date of the day  YYMMDD  integer (e.g. 920407)             *
*  IGTIME   Time of the day  HHMM    integer (e.g. 1425)               *
*                                                                      *
*      COMMON/GCTMED/NUMED,NATMED(5),ISVOL,IFIELD,FIELDM,TMAXFD,STEMAX *
*     +      ,DEEMAX,EPSIL,STMIN,CFIELD,PREC,IUPD,ISTPAR,NUMOLD        *
*  NUMED    Current tracking medium number                             *
*  NATMED   Name of current tracking medium                            *
*  ISVOL    Sensitive volume flag (if non zero)                        *
*  IFIELD   Field map type (0 if no field)                             *
*  FIELDM   Maximum field                                              *
*  TMAXFD   Maximum field turning angle in one step                    *
*  STEMAX   Maximum step allowed                                       *
*  DEEMAX   Maximum energy loss gradient in one step                   *
*  EPSIL    Boundary crossing accuracy                                 *
*  STMIN    Minimum step size by energy loss, multiple scattering      *
*           or field                                                   *
*  CFIELD   Constant for field step evaluation                         *
*  PREC     Initial step for boundary crossing (0.1*EPSIL)             *
*  IUDP     0 If medium change, (1 otherwise)                          *
*  ISTPAR   0 If standard tracking parameters                          *
*  NUMOLD   Numed of the last medium.                                  *
*                                                                      *
*        PARAMETER (MAXMEC=30)                                         *
*        COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7),NMEC,LMEC(MAXMEC)   *
*       + ,NAMEC(MAXMEC),NSTEP ,MAXNST,DESTEP,DESTEL,SAFETY,SLENG      *
*       + ,STEP  ,SNEXT ,SFIELD,TOFG  ,GEKRAT,UPWGHT,IGNEXT,INWVOL     *
*       + ,ISTOP ,IGAUTO,IEKBIN, ILOSL, IMULL,INGOTO,NLDOWN,NLEVIN     *
*       + ,NLVSAV,ISTORY                                               *
*  VECT     Current track parameters (X,Y,Z,Px/P,Py/P,Pz/P,P)          *
*  GETOT    Current track total energy                                 *
*  GEKIN    Current track kinetic energy                               *
*  VOUT     Local use                                                  *
*  NMEC     Number of mechanisms for current step                      *
*  LMEC     List of mechanism indices for current step                 *
*  NAMEC    Mechanism names (See below)                                *
*  NSTEP    Number of steps so far                                     *
*  MAXNST   Maximum number of steps allowed (default = 10000)          *
*  DESTEP   Total energy lost in current step                          *
*  DESTEL   Continuous energy loss in current step                     *
*  SAFETY   Overestimated distance to closest medium boundary          *
*  SLENG    Track length at current point                              *
*  STEP     Size of current tracking step                              *
*  SNEXT    Straight distance to next current medium boundary          *
*  SFIELD   Field turning angle step size evaluation                   *
*  TOFG     Time of flight                                             *
*  GEKRAT   Interpolation factor in table ELOW                         *
*  UPWGHT   User particle weight                                       *
*  IGNEXT   Flag set to 1 when SNEXT has been recomputed               *
*  INWVOL   Flag set to 1 when entering a new volume,                  *
*                       2 when leaving a volume and                    *
*                       3 when leaving the experimental setup.         *
*                       0 otherwise 0                                  *
*  ISTOP    Flag set to 1 when track looses its identity               *
*                       2 when energy below cut                        *
*  IGAUTO   Automatic computation of DEEMAX,STMIN,TMAXFD,STEMAX        *
*  IEKBIN   Current kinetic energy bin in table ELOW                   *
*  ILOSL    Local value of ILOSS for current tracking medium           *
*  IMULL    Local value of IMULS for current tracking medium           *
*  INGOTO   Content number of limiting content when computing SNEXT    *
*  NLDOWN   Lowest level reached down the tree (parallel tracking only)*
*  NLEVIN   Number of levels currently filled and valid in /GCVOLU/    *
*  NLVSAV   Current level (parallel tracking only)                     *
*  ISTORY   User flag for current track history (reset to 0 in GLTRAC) *
*  --------                                                            *
*  NAMEC    List  of possible  mechanisms  for  step size  limitation  *
*           filled in GINIT :                                          *
*     DATA MEC/'NEXT','MULS','LOSS','FIEL','DCAY','PAIR','COMP','PHOT' *
*    +        ,'BREM','DRAY','ANNI','HADR','ECOH','EVAP','FISS','ABSO' *
*    +        ,'ANNH','CAPT','EINC','INHE','MUNU','TOFM','PFIS','SCUT' *
*    +        ,'RAYL','PARA','PRED','LOOP','NULL','STOP'/              *
*  *                                                                   *
*                                                                      *
*        COMMON/GCUNIT/LIN,LOUT,NUNITS,LUNITS(5)                       *
*        INTEGER LIN,LOUT,NUNITS,LUNITS                                *
*        COMMON/GCMAIL/CHMAIL                                          *
*        CHARACTER*132 CHMAIL                                          *
*  C                                                                   *
*  LIN      Input unit to read data cards                              *
*  LOUT     Line printer output unit                                   *
*  NUNITS   Number of additional units                                 *
*  LUNITS   List of additional units.                                  *
*  CHMAIL   Internal string used for error messages                    *
*   LIN and  LOUT are defined in  GINIT through calls to  the routine  *
*  FFGET from  the standard  FFREAD package.   NUNITS and  LUNITS are  *
*  reserved for user applications.                                     *
*                                                                      *
*     COMMON /GCVOLU/   ......                                         *
*                     see GEANG Pam file                               *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*                      Summary of Data Cards                           *
*                      ---------------------                           *
*                                                                      *
*                                                                      *
*  INTRODUCTION                                                        *
*                                                                      *
*  GEANT3 uses the standard FFREAD package to read 'free format' data  *
*  cards in  the routine GFFGO.   The cards currently  interpreted by  *
*  GFFGO can be classified into four categories:                       *
*                                                                      *
*  - General control of the run.                                       *
*  - Control of the physics processes.                                 *
*  - Debug and I/O operations.                                         *
*  - User applications.                                                *
*                                                                      *
*  The data  cards are  listed below by  category with  the following  *
*  information:                                                        *
*                                                                      *
*  - KEY, card  keyword, any  number of  characters truncated  to the  *
*    first 4                                                           *
*  - N, maximum expected number of variables NVAR,                     *
*  - T,  TYPE of these variables (I=INTEGER,  R=REAL or M=MIXED)       *
*                                                                      *
*  for each variable in turn:                                          *
*                                                                      *
*      - VAR.., FORTRAN name                                           *
*      - Short description (more detail in BASE 030)                   *
*      - COMMON where it is stored, and                                *
*      - Default value from GINIT.                                     *
*                                                                      *
*  When a  card is decoded,  the values  entered by the  user without  *
*  explicit assignment are  assigned to the variables  in order.  The  *
*  number of values can  be less than NVAR.  In case  of a MIXED type  *
*  the values entered have to be in agreement with the default of the  *
*  corresponding FORTRAN variable names.                               *
*                                                                      *
*  Example of data card:     RUN   5   201                             *
*                                                                      *
*  to  preset  the  current  run  and  event  number  to  5  and  201  *
*  respectively.                                                       *
*   In batch jobs  there is no need for any  special termination card  *
*  and none of the cards mentioned below is mandatory.                 *
*                                                                      *
*  USER DEFINED DATA CARDS                                             *
*                                                                      *
*  Before  calling  GFFGO the  user  may  define private  data  cards  *
*  through calls to FFKEY as follows:                                  *
*      CALL FFKEY('KEY',VAR(1),NVAR,'TYPE')                            *
*   They will be interpreted by GFFGO in the same way as the standard  *
*  cards.                                                              *
*                                                                      *
*  SUMMARY OF THE MOST IMPORTANT GEANT3 DATA CARDS                     *
*                                                                      *
*  KEY   N  T  VAR..  Short description                COMMON  GINIT   *
*  General control of the run:                                         *
*  HSTA 20  M LHSTA   Names of required histograms     GCLIST    0     *
*  PATR  4  I NJTMAX  Max number of tracks in parallel GCSTAK    0     *
*                     tracking stack                                   *
*             NJTMIN  Number of tracks above which        "      0     *
*                     parallel tracking can be                         *
*                     reactivated when frozen earlier                  *
*             NTSTKP  Primary allocation for stack JSTAK  "    500     *
*             NTSTKS  Secondary  ... (when parallel       "    100     *
*                     tracking used)                                   *
*  RNDM  2  I NRNDM   Initial random number seeds                      *
*             NRNDM(1)                                 GCFLAG  9876    *
*             NRNDM(2)                                 GCFLAG 54321    *
*  RNDM  2  I NRNDM   Initial random number seeds      GCFLAG    0     *
*  RUNG  2  I IDRUN   User run number                  GCFLAG    1     *
*             IDEVT   User event number                GCFLAG    1     *
*  TIME  3  M TIMINT  Time left after initialisation   GCTIME System   *
*             TIMEND  Time required for termination    GCTIME   1.     *
*             ITIME   Test every ITIME events          GCTIME   1      *
*  TRIG  1  I NEVENT  Number of events to process      GCFLAG  1E7     *
*  Geometry optimization:                                              *
*  OPTI  1  I IOPTIM  Optimization level               GCOPTI   1      *
*  SCAN process control:                                               *
*  SCAN  8  M         SCAN granularity and mode                        *
*           SCANFL    Scan processing flag (Logical)   GCSCAN  FALSE   *
*           NPHI      Number of divisions in PHI       GCSCAN   90     *
*           PHIMIN    Minimum value of PHI             GCSCAN   0.     *
*           PHIMAX    Maximum value of PHI             GCSCAN 360.     *
*           NTETA     Number of divisions in TETA      GCSCAN  90      *
*           TETMIN    Minimum value of TETA            GCSCAN  0.      *
*           TETMAX    Maximum value of TETA            GCSCAN 180.     *
*           MODTET    Type of TETA division            GCSCAN   1      *
*  SCAL 32  M SLIST   List of scanned volumes          GCSCAN  'XXXX'  *
*  SCAP  6  R         SCAN parameters                                  *
*           VX      SCAN vertex X coordinate           GCSCAN  0.0     *
*           VY      SCAN vertex Y coordinate           GCSCAN  0.0     *
*           VZ      SCAN vertex Z coordinate           GCSCAN  0.0     *
*           FACTX0  Scale factor for SX0               GCSCAN  100.    *
*           FACTL   Scale factor for SL                GCSCAN  1000.   *
*           FACTR   Scale factor for R                 GCSCAN  100.    *
*  Control of physics processes:                                       *
*  AUTO  1  I IGAUTO  Automatic computation of STMIN   GCTRAK   1      *
*                     STEMAX,DEEMAX,TMAXFD                             *
*                     0 = Tracking media parameters                    *
*                         taken from the argument list                 *
*                         of GSTMED                                    *
*                     1 = Tracking media parameters                    *
*                         calculated by GEANT                          *
*  ANNI  1  I IANNI   Annihilation flag                GCPHYS   1      *
*  BREM  1  I IBREM   Bremsstrahlung flag              GCPHYS   1      *
*  COMP  1  I ICOMP   Compton scattering flag          GCPHYS   1      *
*  CUTS 15  R         Kinetic energy cuts :                            *
*           CUTGAM    " "   for gammas                 GCCUTS   0.001  *
*           CUTELE    " "   for electrons              GCCUTS   0.001  *
*           CUTHAD    " "   for charged hadrons        GCCUTS   0.01   *
*           CUTNEU    " "   for neutral hadrons        GCCUTS   0.01   *
*           CUTMUO    " "   for muons                  GCCUTS   0.01   *
*           BCUTE     " "   for electron brems.        GCCUTS   CUTGAM *
*           BCUTM     " "   for muon Brems.            GCCUTS   CUTGAM *
*           DCUTE     " "   for electron delta-rays    GCCUTS   CUTELE *
*           DCUTM     " "   for muon delta-rays        CCUTS    CUTELE *
*           PPCUTM    " "   for e+e- pairs by muons    CCUTS    10 MeV *
*           TOFMAX  Time of flight cut                 GCCUTS   1.E+10 *
*           GCUTS   5 user words                       GCCUTS   0.     *
*  DCAY  1  I IDCAY   Decay flag                       GCPHYS   1      *
*  DRAY  1  I IDRAY   delta-rays flag                  GCPHYS   1      *
*  ERAN  3  M Cross section tables                                     *
*           R EKMIN   Minimum energy for the tables    GCMULO  1E-5    *
*           R EKMAX   Maximum energy for the tables    GCMULO  1E+4    *
*           I NEKBIN  Number of bins in the table      GCMULO   90     *
*  HADR  1  I IHADR   Hadronic process flag            GCPHYS   1      *
*  LOSS  1  I ILOSS   Energy loss flag                 CGPHYS   2      *
*  MULS  1  I IMULS   Multiple scattering flag         GCPHYS   1      *
*  MUNU  1  I IMUNU   Muon nuclear interactions flag   GCPHYS   0      *
*  PAIR  1  I IPAIR   Pair production flag             GCPHYS   1      *
*  PFIS  1  I IPFIS   Photofission flag                GCPHYS   0      *
*  PHOT  1  I IPHOT   Photo-electric effect flag       GCPHYS   1      *
*  RAYL  1  I IRAYL   Rayleigh scattering flag         GCPHYS   0      *
*                                                                      *
*  Debug and I/O operations:                                           *
*  DEBU 3  M IDEMIN  First event to debug              GCFLAG   0      *
*            IDEMAX  Last event to debug               GCFLAG   0      *
*            ITEST   Print control frequency           GCFLAG   0      *
*  GET  20 M LGET    Names of data structure to get    GCLIST   ' '    *
*  PRIN 20 M LPRIN   User keywords to print data       GCLIST   ' '    *
*                   structures                                         *
*  SAVE 20 M LSAVE   Names of data struct. to save     GCLIST   ' '    *
*  SWIT 10 I ISWIT   User flags for debug or else      GCFLAG   0      *
*                   User applications:                                 *
*  KINE 11 M IKINE   User flag                         GCKINE   0      *
*            PKINE   10 user words                     GCKINE 1.E+10   *
*  SETS 20 M LSETS   User words for detector sets      GCLIST   ' '    *
*  STAT 20 M LSTAT   1 system + 19 user words          GCLIST   ' '    *
*  PLOT 20 M LPLOT   User words to control plots       GCLIST   ' '    *
*  GEOM 20 M LGEOM   User words to control geometry    GCLIST   ' '    *
*  VIEW 20 M LVIEW   User words to control View banks  GCLIST ' '      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*               The Reference Systems and dimensional Units            *
*               -------------------------------------------            *
*                                                                      *
*                                                                      *
*  THE MASTER REFERENCE SYSTEM  (MARS)                                 *
*                                                                      *
*   The Master Reference  System (MARS) is determined by  the way the  *
*  user  represents  the kinematical  quantities.   If  the axes  are  *
*  labelled (X,Y,Z), then the point P(A,B,C) is represented by         *
*                                                                      *
*           Y |                                                        *
*             |         * P(A,B,C)                                     *
*             |                    * X                  A on axis X    *
*             |                  *                      B on axis Y    *
*             |                *                        C on axis Z    *
*             |              *                                         *
*             |            *                                           *
*             |          *                                             *
*             |        *                                               *
*             |      *                                                 *
*             |                                                        *
*             |                                                        *
*             ............................>                            *
*                                         Z                            *
*    The tracking is performed in  the MAster Reference System.  This  *
*  implies that  the arguments  of the  user magnetic  field routine,  *
*  space point  coordinates and field  components, are given  in this  *
*  system.                                                             *
*                                                                      *
*  THE LOCAL REFERENCE SYSTEMS (MRS AND DRS)                           *
*                                                                      *
*   As explained in GEOM 001, the experimental set-up is described by  *
*  the  definition  of  an   'initial  MOTHER'  volume  inside  which  *
*  'DAUGHTER' volumes are positioned.   Other daughter volumes can be  *
*  positioned  inside  these volumes  which  are  promoted as  mother  *
*  volumes and so on, as russian dolls.                                *
*   This  requires the  definition  of local  reference systems,  the  *
*  Mother  Reference  Systems  (MRS,  Origin  O.)  and  the  Daughter  *
*  Reference Systems (DRS, Origin O.).                                 *
*   The  local  reference  system  of  the  'initial  mother'  volume  *
*  coincides with the MAster Reference System.                         *
*   The full description of a given  detector is usually given in the  *
*  local reference system of the associated volume.                    *
*   The transformation of a point from  the MRS (V.) to the DRS (V.),  *
*  at any level, requires the knowledge  of a rotation matrix R and a  *
*  translation vector T defined through the relation :                 *
*              ( V. ) = [ R ] ( V. - T )                               *
*   The components of  T are the projections of the  vector O.O. onto  *
*  the MRS axes.                                                       *
*   The rotation matrices  are computed from the  spherical angles of  *
*  each of  the axes of  the daughter  reference system (I,  II, III)  *
*  with respect to the mother reference system (1,2,3).                *
*   The spherical angles  THETA and PHI of a direction  D are defined  *
*  as follows :                                                        *
*                                                                      *
*  THETA     is the angle formed by the axis 3 and D (range : 0 to 180 *
*            degrees)                                                  *
*  PHI       is the angle formed by the axis 1 and the projection of D *
*            onto the plane defined by the axes 1 and 2 (range : 0 to  *
*            360 degrees)                                              *
*  Examples are given in GEOM 200.                                     *
*   The various rotation matrices required for a given set-up must be  *
*  defined  during  the initialisation  stage,  usually  in the  user  *
*  routine UGEOM.                                                      *
*   A serial number is assigned to each matrix [GEOM 200].             *
*   The translation parameters and the  serial number of the rotation  *
*  matrix are specified  by the user when the  volumes are positioned  *
*  inside the set-up [GEOM 110].                                       *
*                                                                      *
*  THE DIMENSIONAL UNITS                                               *
*                                                                      *
*  Unless  otherwise   specified,  the   following  units   are  used  *
*  throughout the program :                                            *
*                                                                      *
*      -  CENTIMETER, SECOND, KILOGAUSS, GEV, GEV/C, DEGREE            *
*                                                                      *
************************************************************************
*                                                                      *
*        Examples of MAIN Program and User Initialisation              *
*        ------------------------------------------------              *
*                                                                      *
*      PROGRAM MAIN                                                    *
*  C                                                                   *
*      PARAMETER (NG=100000,NH=10000)                                  *
*      COMMON/PAWC/H(NH)                                               *
*      COMMON/GCBANK/Q(NG)                                             *
*  C                                                                   *
*  C       Allocate memory for ZEBRA and HBOOK                         *
*      CALL GZEBRA(NG)                                                 *
*      CALL HLIMIT(-NH)                                                *
*  C                                                                   *
*  C       Initialize Graphics package                                 *
*      CALL IGINIT(0)                                                  *
*  C       Open metafile and define workstation type                   *
*  C         (computer dependent)                                      *
*                  ....                                                *
*  C                                                                   *
*  C       Initialisation phase                                        *
*      CALL UGINIT                                                     *
*  C                                                                   *
*  C       Processing phase                                            *
*      CALL GRUN                                                       *
*  C                                                                   *
*  C       Termination phase                                           *
*      CALL UGLAST                                                     *
*  C                                                                   *
*      END                                                             *
*      SUBROUTINE UGINIT                                               *
*  C                                                                   *
*  +SEQ,GCLIST                                                         *
*  C                                                                   *
*  C       Initialize GEANT variables                                  *
*      CALL GINIT                                                      *
*  C                                                                   *
*  C       Read data cards                                             *
*      CALL GFFGO                                                      *
*  C                                                                   *
*  C       Initialize data structures                                  *
*      CALL GZINIT                                                     *
*  C                                                                   *
*  C       Initialize drawing package                                  *
*      CALL GDINIT                                                     *
*  C                                                                   *
*  C       Open I/O buffers                                            *
*      IF(NGET .GT.0)CALL GOPEN(1,'I',0,IER)                           *
*      IF(NSAVE.GT.0)CALL GOPEN(2,'O',0,IER)                           *
*  C                                                                   *
*  C       Fetch permanent data structures (if any)                    *
*      CALL GFIN(1,'INIT',1,IDENT,' ',IER)                             *
*      IF(IER.LT.0) THEN                                               *
*  C                                                                   *
*  C       Define standard Particle and Material data                  *
*         CALL GPART                                                   *
*         CALL GMATE                                                   *
*  C                                                                   *
*  C       Define the geometrical set-up                               *
*         CALL 'user code'                                             *
*         CALL GGCLOS                                                  *
*  C                                                                   *
*  C       Compute cross-section and energy loss tables                *
*         CALL GPHYSI                                                  *
*       ENDIF                                                          *
*  C                                                                   *
*  C       Initialize standard histograms                              *
*       CALL GBHSTA                                                    *
*  C                                                                   *
*       END                                                            *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*               The System Initialisation routines                     *
*               ----------------------------------                     *
*                                                                      *
*  Presets COMMON  block variables to default  values.  Preprocessing  *
*  of  various  COMMON  block  variables.  See  'Overview  of  COMMON  *
*  blocks' [BASE  030].  Reads a  set of  data cards with  the FFREAD  *
*  package.  See 'Summary  of data cards' [BASE 040]  GFFGO should be  *
*  called  after  GINIT.   Allocates   the  dynamic  core  divisions.  *
*  Initialize the link areas and the data structure JRUNG [BASE 299].  *
*  Initialize  exotic bank  formats.  GZINIT  should be  called after  *
*  GFFGO.  To be called before the  user geometry routine if the user  *
*  wants  to  open  VIEW   banks  there.   Initializes  any  standard  *
*  histogram required by the user with the data record HSTA.           *
*   The following histogram keywords may be used :                     *
*  TIME     Time per event                                             *
*  SIZE     Size of division LXDIV per event                           *
*  MULT     Total number of tracks per event                           *
*  NTRA     Number of 'long life' tracks per event                     *
*  STAK     Maximum stack size per event                               *
*                                                                      *
*   GBHSTA should be called after GFFGO.                               *
*                                                                      *
*             Steering routines for Event Processing                   *
*             --------------------------------------                   *
*                                                                      *
*   The following flow chart is  only valid for the 'batch' execution  *
*  mode.   For  interactive  applications, see  section  XINT.   Main  *
*  routine to control a run of events                                  *
*                     .........                                        *
*                 ...>|  TIMEX|                                        *
*                 |   .........                                        *
*                 |      Get    time   left    (TIMINT)    after       *
*   initialisation                                                     *
*                 |                                                    *
*                 .............................                        *
*                 |    ...........            |                        *
*                 ... >| GTRIGI  |            |                        *
*                 |    ...........            |                        *
*                 |    ...........            |                        *
*   ........ .    |.. >| GTRIG   |       ......... .                   *
*   |        |    |    ......... .       |loop on  |                   *
*   | GRUN   |... |    |                 |         |                   *
*   ........ .    |    ......... .       | events  |                   *
*                 |.. >| GTRIGC  |       ......... .                   *
*                 |    ......... .            .                        *
*                 |    ...................    |                        *
*                 ... >| check time left |    |                        *
*                 |    ...................    |                        *
*                 .............................                        *
*                                                                      *
*   Resets to 0  the flag IEOTRI in /GCFLAG/ and  the counters NTRACK  *
*  and NVERTX in /GCNUM/.  Sets the  debug flag IDEBUG in /GCFLAG/ to  *
*  the value required for the current event.                           *
*   Creates the Header bank for current event.                         *
*   Prints  the sequence  number,  the event  number  and the  number  *
*  random  generators, under  control of  the flag  ITEST (data  card  *
*  DEBU).                                                              *
*   Steering routine to process one event (trigger)                    *
*                                                                      *
*                      ..........................                      *
*                      | Generates kinematics,  |                      *
*                 ... >| or read event GUKINE   |                      *
*                 |    ..........................                      *
*                 |    ................                                *
*                 |    | Tracking/hits|                                *
*   ........ .    |.. >| GUTREV       |                                *
*   | GTRIG  |.. >|    .............. .                                *
*   ........ .    |    .............. .                                *
*                 |.. >|                                               *
*   Digitisations |                                                    *
*                 |    | GUDIGI       |                                *
*                 |    ................                                *
*                 |    ................                                *
*                 |    | Output event |                                *
*                 ... >| GUOUT        |                                *
*                      ................                                *
*   The partition initialized  in GTRIGI is cleared.   The space used  *
*  by the current event may be used by the next one.                   *
*                                                                      *
*                    The banks JRUNG and JHEAD                         *
*                    -------------------------                         *
*                                                                      *
*  Run bank JRUNG:  1 user link, 30 data words                         *
*  LQ(JRUNG-1)   user link                                             *
*   IQ(JRUNG+1) IDRUN     Run number                                   *
*    ""  +2/10)           Reserved for user applications               *
*          +11) creation date for 'INIT' data structures               *
*          +12) creation time for 'INIT' data structures               *
*          +13) creation data for 'KINE'                               *
*          +14) creation time for 'KINE'                               *
*          +15) creation data for 'HITS'                               *
*          +16) creation time for 'HITS'                               *
*          +17) creation data for 'DIGI'                               *
*          +18) creation time for 'DIGI'                               *
*          +19) Random number seed 1                                   *
*          +20) Random number seed 2                                   *
*          +21) GEANT version number when 'INIT' created               *
*          +22) ZEBRA version number when 'INIT' created               *
*          +23) GEANT version number when 'KINE' created               *
*          +24) ZEBRA version number when 'KINE' created               *
*          +25) GEANT version number when 'HITS' created               *
*          +26) ZEBRA version number when 'HITS' created               *
*          +27) GEANT version number when 'DIGI' created               *
*          +28) ZEBRA version number when 'DIGI' created               *
*  Header bank JHEAD: 1 user link, NHEAD(=10) data words               *
*   IQ(JHEAD+1) IDRUN     Run number                                   *
*       ""  +2) IDEVT     Event number                                 *
*       ""  +3) NRNDM(1)  Random number seed 1 at beginning of event   *
*       ""  +4) NRNDM(2)          "     "                              *
*     "" +5/10)           Reserved for user applications               *
*                                                                      *
************************************************************************
*                                                                      *
*                                                                      *
*        Example of User Termination and related routines              *
*        ------------------------------------------------              *
*                                                                      *
*     SUBROUTINE UGLAST                                                *
*  C                                                                   *
*  +SEQ,GCLIST                                                         *
*  C                                                                   *
*  C      Call standard GEANT termination routine                      *
*     CALL GLAST                                                       *
*  C                                                                   *
*  C      Close HIGZ files                                             *
*     CALL IGEND                                                       *
*  C                                                                   *
*  C      Close I/O buffers                                            *
*     IF(NGET.EQ.0.AND.NSAVE.EQ.0) GO TO 5                             *
*     CALL GCLOSE(0,IER)                                               *
*  C                                                                   *
*  C      Print histograms                                             *
*   5 CALL HISTDO                                                      *
*  C                                                                   *
*     END                                                              *
*                                                                      *
*                                                                      *
************************************************************************
+DECK,GBHSTA
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GBHSTA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Books histograms statistics                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUOUT                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCLIST
C.
C.    ------------------------------------------------------------------
C.
      IF(NHSTA.GT.0)THEN
         CALL GLOOK('TIME',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Time per event$',100,0.,0.,0.)
*
         CALL GLOOK('SIZE',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Space used in IXDIV per event$',
     +   100,0.,0.,0.)
*
         CALL GLOOK('MULT',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Total number of tracks per event$'
     +   ,100,0.,0.,0.)
*
         CALL GLOOK('NTRA',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Long life tracks per event$',100,
     +   0.,0.,0.)
*
         CALL GLOOK('STAK',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Maximum stack size per event$',
     +   100,0.,0.,0.)
*
      ENDIF
      END
+DECK,GEAMON,IF=MONITOR.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GEAMON(ICASE,CHINFO)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine for GEANT monitoring                             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUOUT                                *
C.    *       Author    R.Brun, F.Carminati ********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCUNIT
C.
C.    ------------------------------------------------------------------
C.
      COMMON/CWK/IWK
      CHARACTER*5  ENTRY, EXIT, BATINT
      LOGICAL FIRST, INTRAC
      CHARACTER*(*) CHINFO
      SAVE IWK1,IM1,TIM1,FIRST,ENTRY,EXIT,BATINT
      DATA ENTRY  /'GINIT'/
      DATA EXIT   /'GLAST'/
      DATA BATINT /'BATCH'/
      DATA FIRST  /.TRUE./
*
*________________________________________________________
*
      IF(ICASE.LE.1)THEN
         IF(FIRST) THEN
            CALL TIMEL(TIM1)
            IWK1=IWK
            CALL DATIME(IDAT1,ITIM1)
            IH1=ITIM1/100
            IM1=ITIM1-100*IH1+IH1*60
            IF(INTRAC()) BATINT='INTER'
            FIRST=.FALSE.
         ENDIF
      ENDIF
      IF(ICASE.EQ.0) THEN
         ENTRY='GXINT'
         EXIT ='GXINT'
      ELSE
         IF(ICASE.EQ.1) THEN
            WRITE(CHMAIL,10000)IWK1,CHINFO,ENTRY,BATINT
         ELSEIF(ICASE.EQ.2) THEN
            IF(ENTRY.EQ.'GXINT'.AND.CHINFO.EQ.'GLAST') THEN
               EXIT='GLAST'
               GOTO 999
            ENDIF
            CALL TIMEL(TIM2)
            CPTIME=TIM1-TIM2
            CALL DATIME(IDAT2,ITIM2)
            IH2=ITIM2/100
            IM2=ITIM2-100*IH2+IH2*60
            IMD=IM2-IM1
            IF(IMD.LT.0) IMD=IMD+24*60
            IRTIME=MIN(9999,MAX(IMD,1))
            CPTIME=MIN(99999.,CPTIME)
            IF(IRTIME.GT.999)THEN
               WRITE(CHMAIL,10101)IWK1,IRTIME,CPTIME,EXIT
            ELSE
               WRITE(CHMAIL,10100)IWK1,IRTIME,CPTIME,EXIT
            ENDIF
         ENDIF
*
         CALL UMLOG('GEANTMON',CHMAIL(1:LNBLNK(CHMAIL)))
*
      ENDIF
*
10000 FORMAT('LOG321 WTYP=',I6,1X,A,2(1X,A5))
10100 FORMAT('LOGOUT WTYP=',I6,' RT=',I3,' min CP=',F9.3,' sec ',A5)
10101 FORMAT('LOGOUT WTYP=',I6,' RT', I4,' min CP=',F9.3,' sec ',A5)
*
  999 CONTINUE
      END
+DECK,GETNUM
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GETNUM(LIST,N)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to count the number of non blank elements        *
C.    *      in the array LIST before the first blank one              *
C.    *                                                                *
C.    *    ==>Called by : GFFGO                                        *
C.    *    ==>Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION LIST(*)
      SAVE IFIRST,IDFLT
      DATA IFIRST/0/
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH('    ',IDFLT,4,4)
      ENDIF
C
      N = 0
      DO 10 I=1,20
         IF(LIST(I).EQ.IDFLT) GO TO 99
         N=N+1
  10  CONTINUE
C
  99  RETURN
      END
+DECK,GETVER.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GETVER(CHVER,HVERS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Routine to get the current version number from a pam       *
C.    *     file. This routine is cracking the title given in          *
C.    *     HOLLERITH format, because CMZ and old versions of PATCHY   *
C.    *     do not support the character title sequence QFTITLCH       *
C.    *                                                                *
C.    *    ==>Called by : GINIT                                        *
C.    *       Author    F.Carminati *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*60 CHTIT
      CHARACTER*6 CHFOR
      CHARACTER*8 CHVER
*
      CHVER = ' '
      HVERS = 0.
*
      WRITE(CHTIT,'(
+SEQ,QFTITLE,N=60.
     +)')
      DO 10 JSLASH=1,60
         IF(CHTIT(JSLASH:JSLASH).EQ.'/') THEN
            JSL=JSLASH
            GOTO 20
         ENDIF
   10 CONTINUE
      GOTO 999
*
   20 CONTINUE
      DO 30 JBLA=JSL,1,-1
         IF(CHTIT(JBLA-1:JBLA-1).EQ.' ') THEN
            JBEG=JBLA
            GOTO 40
         ENDIF
   30 CONTINUE
      GOTO 999
*
   40 CONTINUE
      DO 50 JBLA=JSL,60
         IF(CHTIT(JBLA+1:JBLA+1).EQ.' ') THEN
            JEND=JBLA
            GOTO 60
         ENDIF
   50 CONTINUE
      GOTO 999
*
   60 WRITE(CHFOR,'(''(F'',I1,''.2)'')') JSL-JBEG
      READ(CHTIT(JBEG:JSL-1),CHFOR) HMAIN
      READ(CHTIT(JSL+1:JEND),'(I2)')   ISUBV
      HVERS=HMAIN+ISUBV*.001
      NCHA=JEND-JBEG+1
      CHVER=' '
      IF(NCHA.EQ.8) THEN
         CHVER=CHTIT(JBEG:JEND)
      ELSE
         CHVER=' '//CHTIT(JBEG:JEND)
      ENDIF
*
  999 CONTINUE
      END
+DECK,GFFGO
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GFFGO
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to define and read GEANT/FFREAD data cards       *
C.    *      If user data cards have been defined via FFKEY            *
C.    *      they will be read as well                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCPHYS
+SEQ,GCCUTS
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCLIST
+SEQ,GCPARM
+SEQ,GCSTAK
+SEQ,GCTIME
+SEQ,GCTRAK
+SEQ,GCMULO
+SEQ,GCSCAN
+SEQ,GCUNIT
+SEQ,GCOPTI
+SEQ,GCTMED
+SEQ,GCRZ
C.
C.    ------------------------------------------------------------------
C.
      CALL FFKEY ('ANNI',IANNI , 1,'INTEGER')
      CALL FFKEY ('BREM',IBREM , 1,'INTEGER')
      CALL FFKEY ('COMP',ICOMP , 1,'INTEGER')
      CALL FFKEY ('CUTS',CUTGAM,16,'REAL')
      CALL FFKEY ('DEBU',IDEMIN, 3,'INTEGER')
      CALL FFKEY ('DCAY',IDCAY , 1,'INTEGER')
      CALL FFKEY ('DRAY',IDRAY , 1,'INTEGER')
      CALL FFKEY ('LABS',ILABS , 1,'INTEGER')
      CALL FFKEY ('GEOM',LGEOM ,20,'MIXED')
      CALL FFKEY ('GET ',LGET  ,20,'MIXED')
      CALL FFKEY ('HADR',IHADR , 1,'INTEGER')
      CALL FFKEY ('HSTA',LHSTA ,20,'MIXED')
      CALL FFKEY ('KINE',IKINE ,11,'MIXED')
      CALL FFKEY ('LOSS',ILOSS , 1,'INTEGER')
      CALL FFKEY ('MULS',IMULS , 1,'INTEGER')
      CALL FFKEY ('MUNU',IMUNU , 1,'INTEGER')
      CALL FFKEY ('PAIR',IPAIR , 1,'INTEGER')
*     CALL FFKEY ('PATR',NJTMAX, 4,'INTEGER')
      CALL FFKEY ('SORD',ISTORD, 1,'INTEGER')
      CALL FFKEY ('PFIS',IPFIS , 1,'INTEGER')
      CALL FFKEY ('PHOT',IPHOT , 1,'INTEGER')
      CALL FFKEY ('PLOT',LPLOT ,20,'MIXED')
      CALL FFKEY ('PRIN',LPRIN ,20,'MIXED')
      CALL FFKEY ('RAYL',IRAYL , 1,'INTEGER')
      CALL FFKEY ('RGET',LRGET ,20,'MIXED')
      CALL FFKEY ('RSAV',LRSAVE,20,'MIXED')
      CALL FFKEY ('RNDM',NRNDM , 2,'INTEGER')
      CALL FFKEY ('RUNG',IDRUN , 2,'INTEGER')
      CALL FFKEY ('SAVE',LSAVE ,20,'MIXED')
      CALL FFKEY ('SETS',LSETS ,20,'MIXED')
      CALL FFKEY ('STAT',LSTAT ,20,'MIXED')
      CALL FFKEY ('SWIT',ISWIT ,10,'INTEGER')
      CALL FFKEY ('TIME',TIMINT, 3,'MIXED')
      CALL FFKEY ('TRIG',NEVENT, 1,'INTEGER')
      CALL FFKEY ('VIEW',LVIEW ,20,'MIXED')
      CALL FFKEY ('ERAN',EKMIN , 3,'MIXED')
      CALL FFKEY ('AUTO',IGAUTO, 1,'INTEGER')
      CALL FFKEY ('OPTI',IOPTIM, 1,'INTEGER')
      CALL FFKEY ('CKOV',ITCKOV, 1,'INTEGER')
      CALL FFKEY ('SYNC',ISYNC,  1,'INTEGER')
      CALL FFKEY ('STRA',ISTRA,  1,'INTEGER')
*--------------- SCAN/Parametrize cards
      CALL FFKEY ('SCAN',SCANFL, 8,'MIXED')
      CALL FFKEY ('SCAL',ISLIST,MSLIST,'MIXED')
      CALL FFKEY ('SCAP',VSCAN , 6,'REAL')
      CALL FFKEY ('PCUT',IPARAM,  6,'MIXED')
      CALL FFKEY ('PNUM',MPSTAK,  2,'MIXED')
C
C             Now read data cards
C
      CALL FFGO
C
C             Get some parameters from the data cards
C
      CALL GETNUM (LHSTA ,NHSTA)
      CALL GETNUM (LGET  ,NGET)
      CALL GETNUM (LSAVE ,NSAVE)
      CALL GETNUM (LRGET ,NRGET)
      CALL GETNUM (LRSAVE,NRSAVE)
      CALL GETNUM (LSETS ,NSETS)
      CALL GETNUM (LPRIN ,NPRIN)
      CALL GETNUM (LGEOM ,NGEOM)
      CALL GETNUM (LVIEW ,NVIEW)
      CALL GETNUM (LPLOT ,NPLOT)
      CALL GETNUM (LSTAT ,NSTAT)
      CALL GETNUM (ISLIST,NSLIST)
*
      IF(ILABS.NE.0) THEN
         IF(ITCKOV.NE.0) ILABS=1
      ENDIF
*
      IF(MODTET.LT.1.OR.MODTET.GT.MAXMDT) THEN
         WRITE(LOUT,10000) MODTET
10000    FORMAT(' MODTET = ',I2,' out of range - 1 assumed')
         MODTET=1
      ENDIF
      TETMIN = TETMID(MODTET)
      TETMAX = TETMAD(MODTET)
      IF(IDEVT.GT.0)IDEVT=IDEVT-1
C
C             Set IDEBUG flag for initialisation phase
C
      IF(IDEMIN.LT.0.AND.IDEMAX.GE.0)THEN
         IDEMIN=-IDEMIN
         IDEBUG=1
      ENDIF
C
C             Initialise the random number generator
C
      IF(NRNDM(2).NE.0)THEN
         CALL GRNDMQ(NRNDM(1),NRNDM(2),1,'S')
      ELSEIF(NRNDM(1).GT.0)THEN
         ISEQ=NRNDM(1)
         CALL GRNDMQ(NRNDM(1),NRNDM(2),ISEQ,'Q')
         CALL GRNDMQ(NRNDM(1),NRNDM(2),ISEQ,'S')
      ENDIF
C
  999 CONTINUE
      END
+DECK,GFHEAD.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GFHEAD (NWHEAD,IHEAD,NWBUF,UBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Retrieves the parameter of the Header bank               *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCFLAG.
*
      DIMENSION IHEAD(1),UBUF(1)
*
      IF (JHEAD.NE.0) THEN
         NWHEAD = IQ(JHEAD-1)
         DO 10 I=1,NWHEAD
            IHEAD(I) = IQ(JHEAD+I)
   10    CONTINUE
*
         NWBUF = 0
         IF (LQ(JHEAD-1).NE.0) THEN
            JHU = LQ(JHEAD-1)
            NWBUF = IQ(JHU-1)
            DO 20 I=1,NWBUF
               UBUF(I) = Q(JHU+I)
   20       CONTINUE
         ENDIF
*
      ELSE
         NWHEAD = 0
         WRITE(CHMAIL,1000) IEVENT
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GFHEAD: No Header bank in memory for ievent:',I7)
*
      END
+DECK,GFHSTA
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GFHSTA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Fills histograms statistics                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUOUT                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCLIST
      COMMON/QUEST/IQUEST(100)
C.
C.    ------------------------------------------------------------------
C.
      IF(NHSTA.GT.0) THEN
         CALL GLOOK('TIME',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL TIMED(TEVENT)
            CALL HFILL(-ID,TEVENT,0.,1.)
         ENDIF
*
         CALL GLOOK('SIZE',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            NL=NZLEFT(IXDIV,' ')
            CALL HFILL(-ID,IQUEST(11)+0.5,0.,1.)
         ENDIF
*
         CALL GLOOK('MULT',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL HFILL(-ID,NTMULT+0.5,0.,1.)
         ENDIF
*
         CALL GLOOK('NTRA',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL HFILL(-ID,NTRACK+0.5,0.,1.)
         ENDIF
*
         CALL GLOOK('STAK',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL HFILL(-ID,NSTMAX+0.5,0.,1.)
         ENDIF
*
      ENDIF
      END
+DECK,GFRUNG.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GFRUNG (NWRUNG,IRUNG,NWBUF,UBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Retrieves the parameter of the RUNG   bank               *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
*
      DIMENSION IRUNG(1),UBUF(1)
*
      IF (JRUNG.NE.0) THEN
         NWRUNG = IQ(JRUNG-1)
         DO 10 I=1,NWRUNG
            IRUNG(I) = IQ(JRUNG+I)
   10    CONTINUE
*
         NWBUF = 0
         IF (LQ(JRUNG-1).NE.0) THEN
            JRU = LQ(JRUNG-1)
            NWBUF = IQ(JRU-1)
            DO 20 I=1,NWBUF
               UBUF(I) = Q(JRU+I)
   20       CONTINUE
         ENDIF
*
      ELSE
         NWRUNG = 0
         WRITE(CHMAIL,1000)
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GFRUNG: No RUNG bank existing in memory ')
*
      END
+DECK,GGCLOS,IF=-OLD.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GGCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Closes off the geometry setting.                            *
C.    *    Initializes the search list for the contents of each        *
C.    *    volume following the order they have been positioned, and   *
C.    *    inserting the content '0' when a call to GSNEXT (-1) has    *
C.    *    been required by the user.                                  *
C.    *    Performs the development of the JVOLUM structure for all    *
C.    *    volumes with variable parameters, by calling GGDVLP.        *
C.    *    Interprets the user calls to GSORD, through GGORD.          *
C.    *    Computes and stores in a bank (next to JVOLUM mother bank)  *
C.    *    the number of levels in the geometrical tree and the        *
C.    *    maximum number of contents per level, by calling GGNLEV.    *
C.    *    Sets status bit for CONCAVE volumes, through GGCAVE.        *
C.    *    Completes the JSET structure with the list of volume names  *
C.    *    which identify uniquely a given physical detector, the      *
C.    *    list of bit numbers to pack the corresponding volume copy   *
C.    *    numbers, and the generic path(s) in the JVOLUM tree,        *
C.    *    through the routine GHCLOS.                                 *
C.    *                                                                *
C.    *    Called by : <USER>                                          *
C.    *    Authors   : R.Brun, F.Bruyant, S.Giani  *********           *
C.    *                                                                *
C.    *    Modified by S.Giani for automatic initialization of the new *
C.    *    tracking based on virtual divisions (1993).                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCLIST.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCOPTI.
+SEQ, GCHVIR.
      CHARACTER*4 NAME
      LOGICAL BTEST
C.
C.    ------------------------------------------------------------------
      dimension dx(3),tmpmax(7),ndivto(7),qualit(7),ivoaxi(7)
      data jfirst/0/
      save jfirst
      COMMON /QUEST/ IQUEST(100)
      COMMON/GCDINA/jphi2,jclow,jchig,jbuff
*
* *** Stop the run in case of serious anomaly during initialization
*
      IF (IEORUN.NE.0) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         STOP
      ENDIF
*
      IF (NVOLUM.LE.0) THEN
         WRITE (CHMAIL, 1002) NVOLUM
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      NPUSH = NVOLUM -IQ(JVOLUM-2)
      CALL MZPUSH (IXCONS, JVOLUM, NPUSH, NPUSH,'I')
*
* *** Loop over volumes, create default JNear banks as relevant,
*      and release unused bank space
*
      IDO = 0
      DO 80 IVO = 1,NVOLUM
         JVO = LQ(JVOLUM-IVO)
*
* *** Check if Tracking medium has been defined
*
         NMED=Q(JVO+4)
         IF(NMED.LE.0.OR.NMED.GT.IQ(JTMED-2))THEN
            WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
            CALL GMAIL (0, 0)
         ELSE
            IF(LQ(JTMED-NMED).EQ.0)THEN
               WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
               CALL GMAIL (0, 0)
            ENDIF
         ENDIF
         IF (BTEST(IQ(JVO),0)) GO TO 80
         IDO = 1
         IQ(JVO) = IBSET(IQ(JVO),0)
         NINL  = IQ(JVO-2)
         NIN   = Q(JVO+3)
         NUSED = IABS(NIN)
         IF (NIN.GT.0) THEN
*           reserve enough additional space for sorted volumes
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
              NUSED=NUSED+1
            ELSE
              NUSED=NUSED+2
            ENDIF
         ENDIF
*
         NPUSH = NUSED -NINL
         DO 90 IN=NINL,NUSED+1,-1
            JIN = LQ(JVO-IN)
            IF(JIN.GT.0) THEN
               CALL MZDROP(IXCONS,JIN,'L')
            ENDIF
  90     CONTINUE
         CALL MZPUSH (IXCONS, JVO, NPUSH, 0, 'I')
         IF (NIN.LE.0) GO TO 80
*
         IF(BTEST(IQ(JVO),3)) THEN
            IZERO=1
         ELSE
            IZERO=0
         ENDIF
         NEL = NIN +IZERO
         JN = LQ(JVO-NIN-1)
         IF(JN.EQ.0) THEN
            CALL MZBOOK (IXCONS,JN,JVO,-NIN-1,'VONE',0,0,NEL+1,2,0)
         ENDIF
         IQ(JN-5) = IVO
         IQ(JN+1) = NEL
         JN = JN +1
         DO 29 I = 1,NIN
            IQ(JN+IZERO+I) = I
   29    CONTINUE
         IF (IZERO.NE.0) IQ(JN+1) = 0
*
   80 CONTINUE
*
      IF (IDO.NE.0) THEN
*
* ***    Perform development of JVOLUM structure where necessary
*
         CALL GGDVLP
*
* ***    Fill GSORD ordering banks if required
*
* Modified by S.Egli to allow GGORDQ to find the optimum sorting for
* all volumes
*
         IF(IOPTIM.GE.1)THEN
            WRITE(6,'(A)')' GGCLOS: Start automatic volume ordering:'
         ENDIF
         DO 91 IVO = 1,NVOLUM
            JVO = LQ(JVOLUM-IVO)
            NIN = Q(JVO+3)
            ISEARC=Q(JVO+1)
            IF(ISEARC.GT.0) GO TO 91
*           check if sorting not possible or not wanted
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
               Q(JVO+1)=0.
               IF(NIN.GT.500.AND.IOPTIM.GE.1)THEN
                 CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
                 WRITE (CHMAIL,1004) NAME,NIN
                 CALL  GMAIL (0, 0)
               ENDIF
            ELSEIF(IOPTIM.EQ.0)THEN
               IF(ISEARC.LT.0)CALL GGORD (IVO)
            ELSEIF(IOPTIM.EQ.1)THEN
               IF(ISEARC.EQ.0) THEN
                  CALL GGORDQ(IVO)
               ELSE
                  CALL GGORD (IVO)
               END IF
            ELSE
               CALL GGORDQ(IVO)
            ENDIF
   91    CONTINUE
*
* ***    Set status bit for concave volumes
*
         CALL GGCAVE
*
* ***    Compute maximum number of levels and of contents per level
*
         CALL GGNLEV
*
      ENDIF
*
********************************************************************************
*
      if(jfirst.eq.0)then
        jfirst=1
        call mzlink(ixcons,'/GCHVIR/',jvirt,jvdiv,jcont)
        call mzlink(ixstor,'/GCDINA/',jphi2,jbuff,jphi2)
      endif
      jflag=0
      nwjvdi=0
      jphi2=0
      jclow=0
      jchig=0
      jbuff=0
      if(jvirt.ne.0)call mzdrop(ixcons,jvirt,' ')
      nwjvir=5*nvolum+20
      call mzneed(ixcons,nwjvir,'G')
      if(iquest(11).le.0)then
          print *,'No space for jvirt bank'
      else
          call mzbook(ixcons,jvirt,jvirt,1,'VIRT',nvolum,nvolum,
     +              4*nvolum+20,0,0)
      endif
      dx(1)=0.
      dx(2)=0.
      dx(3)=0.
      ndivst=0
      ndioff=0
      ninmax=0
      do 101 ivo=1,nvolum
        jvo=lq(jvolum-ivo)
        call uhtoc(iq(jvolum+ivo),4,NAME,4)
*         print *,'VOLUME ',NAME
*         print *,' '
        nin=q(jvo+3)
        isearc=q(jvo+1)
*        if(nin.eq.0)then
*          print *,'No daughters.'
*        elseif(nin.lt.0)then
*          print *,'Divided volume.'
*        elseif(nin.le.1)then
*          print *,'Only 1 daughter.'
*        endif
 1      continue
        if(nin.gt.1)then
         if(jflag.eq.0)then
          if(iswit(9).eq.12345)then
            print *,'VOLUME ',NAME
            print *,' '
          endif
         endif
         if(jflag.eq.1)then
           q(jvirt+4*(ivo-1)+1)=itmpq
           iaxlo=itmpq
           iaxhi=itmpq
         else
           iaxlo=1
           iaxhi=7
         endif
          if(nin.gt.ninmax)then
           if(jphi2.ne.0)call mzdrop(ixstor,jphi2,' ')
           if(jclow.ne.0)call mzdrop(ixstor,jclow,' ')
           if(jchig.ne.0)call mzdrop(ixstor,jchig,' ')
           call mzbook(ixstor,jphi2,jphi2,2,'PHI2',0,0,
     +                 nin+20,2,-1)
           call mzbook(ixstor,jclow,jclow,2,'CLOW',0,0,
     +                 nin+20,3,-1)
           call mzbook(ixstor,jchig,jchig,2,'CHIG',0,0,
     +                 nin+20,3,-1)
           if(jflag.eq.1)then
             if(jbuff.ne.0)call mzdrop(ixstor,jbuff,' ')
             call mzbook(ixstor,jbuff,jbuff,2,'BUFF',0,0,
     +                   nin+20,2,-1)
           endif
          endif
         do 110 iaxis=iaxlo,iaxhi
          myphif=0
*          print *,'Quality search for axis ',iaxis
          ish=q(jvo+2)
          if(iaxis.le.3)then
            call gvdcar(iaxis,ish,0,q(jvo+7),clmoth,chmoth,ierr)
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          elseif(iaxis.le.5)then
            call gvdrad(iaxis,ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
             if(iaxis.eq.5)ierr=1
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          elseif(iaxis.eq.6)then
            call gvdphi(ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            elseif((chmoth-clmoth).gt.360..or.chmoth.gt.360)then
              print *,'(chmoth-clmoth).gt.360.or.chmoth.gt.360'
            elseif((chmoth-clmoth).eq.360.)then
              myphif=1
            endif
          elseif(iaxis.eq.7)then
            call gvdthe(ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
            ierr=1
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          endif
          if(jflag.eq.1)then
            q(jvirt+4*(ivo-1)+3)=clmoth
            q(jvirt+4*(ivo-1)+4)=chmoth
          endif
          thimot=abs(chmoth-clmoth)
          thimin=100000.
          do 102 in=1,nin
            iq(jphi2+in)=0
            jin=lq(jvo-in)
            call gvdlim(jvo,in,iaxis,clow,chigh,ierr)
            if(ierr.eq.1.or.(chigh.le.clow))then
*              if(ierr.eq.0)print *,'Error in gvdlim: corrected',iaxis
              clow=clmoth
              chigh=chmoth
            elseif(myphif.eq.1)then
              clowm=clow
              chighm=chigh
              sg=sign(1.0,clow)
              clow=mod(abs(clow),360.0)
              if(chigh.ne.360.0)then
               if(sg.le.0.0)clow=360.-clow
               sg=sign(1.0,chigh)
               chigh=mod(abs(chigh),360.0)
               if(sg.le.0.0)chigh=360.-chigh
              endif
              if(chigh.lt.clow)then
                iq(jphi2+in)=1
              endif
            elseif(iaxis.eq.6.and.myphif.eq.0)then
             if((chigh-chmoth).gt..01.or.(clmoth-clow).gt..01)then
               if(clmoth.lt.0..and.clow.gt.0.)then
                clow=clow-360.
                chigh=chigh-360.
                if((chigh-chmoth).gt..01)then
                  chigh=chmoth
                  if(chigh.le.clow)clow=clmoth
                elseif((clmoth-clow).gt..01)then
                  clow=clmoth
                  if(clow.ge.chigh)chigh=chmoth
                endif
               elseif(chigh.lt.0..and.chmoth.gt.0.)then
                clow=clow+360.
                chigh=chigh+360.
                if((chigh-chmoth).gt..01)then
                  chigh=chmoth
                  if(chigh.le.clow)clow=clmoth
                elseif((clmoth-clow).gt..01)then
                  clow=clmoth
                  if(clow.ge.chigh)chigh=chmoth
                endif
               endif
             endif
            endif
            if((chigh-chmoth).gt..01)then
*** ONLY FOR DEBUG
*              print *,'iaxis =',iaxis,'protuding daughter',in
**              print *,'myphif =',myphif,'myphi2 =',iq(jphi2+in)
*              print *,'Dhigh=',chigh-chmoth
*              print *,'Dlow=',clmoth-clow
***
              chigh=chmoth
              if(chigh.le.clow)clow=clmoth
            elseif((clmoth-clow).gt..01)then
*** ONLY FOR DEBUG
*              print *,'iaxis =',iaxis,'protuding daughter',in
**              print *,'myphif =',myphif,'myphi2 =',iq(jphi2+in)
*              print *,'Dhigh=',chigh-chmoth
*              print *,'Dlow=',clmoth-clow
***
              clow=clmoth
              if(clow.ge.chigh)chigh=chmoth
            endif
            q(jclow+in)=clow
            q(jchig+in)=chigh
            if(iq(jphi2+in).eq.0)then
             tmpthi=abs(chigh-clow)
            else
             tmpthi=abs(chighm-clowm)
            endif
            if(thimin.gt.tmpthi)thimin=tmpthi
 102      continue
          if((thimin-thimot).gt.1)then
*            print *,'thimin.gt.thimot',thimin-thimot,'iax=',iaxis
            qualit(iaxis)=10000
            goto 110
          endif
          if(thimin.lt.0.04)thimin=0.04
          tmpndi=2.*thimot/thimin
          nditmp=tmpndi+1
*****          print *,nditmp,' divisions asked for ',nin,' daughters.'
*****           if(nditmp.lt.nin)then
*****             nditmp=nin
*****             print *,'Number of divisions corrected to be = ',nin
*****           endif
*****          if(nditmp.gt.1000.)print *,'1000 divisions are enough.'
          ndivto(iaxis)=min(nditmp,1000)
          if(jflag.eq.1)then
            q(jvirt+4*(ivo-1)+2)=ndivto(iaxis)
           jvdiv=lq(jvirt-ivo)
           if(jvdiv.ne.0)call mzdrop(ixcons,jvdiv,' ')
           nwvili=ndivto(iaxis)+ivoaxi(itmpq)+11
           nwjvdi=nwjvdi+nwvili
           call mzneed(ixcons,nwvili,'G')
           if(iquest(11).le.0)then
            print *,'No space for jvdiv bank',ivo
           else
            call mzbook(ixcons,jvdiv,jvirt,-ivo,'VLIST',0,0,
     +                  nwvili,2,0)
           endif
          endif
          thisli=thimot/ndivto(iaxis)
          clslic=clmoth
          chslic=clmoth+thisli
          avelis=0.
          aveave=0.
          avesta=0.
          ii=0
          tmpmax(iaxis)=0.
          import=0
          if(jflag.eq.1)ioff=ndivto(iaxis)
          do 103 i=1,ndivto(iaxis)
            j=1
            do 104 in=1,nin
             if(iq(jphi2+in).eq.0)then
              if(q(jchig+in).ge.clslic.and.
     +           q(jclow+in).le.chslic)then
                j=j+1
                if(jflag.eq.1)then
                  iq(jbuff+j)=in
                endif
              endif
             else
              if(q(jchig+in).ge.clslic.or.
     +           q(jclow+in).le.chslic)then
                j=j+1
                if(jflag.eq.1)then
                  iq(jbuff+j)=in
                endif
              endif
             endif
 104        continue
            inbuf1=j-1
            if(jflag.eq.1)then
             if(i.gt.1.and.iq(jbuff+1).eq.(j-1))then
               if(j-1.eq.0)then
                 import=1
               elseif(j-1.eq.1)then
                 if(iq(jbuff+2).eq.iq(jvdiv+ioff-nposti+2))then
                   import=1
                 else
                   import=0
                 endif
               else
                import=1
                do 234 ijk=2,nposti-2
                 do 432 kji=2,nposti-2
                  if(iq(jbuff+ijk).eq.iq(jvdiv+ioff-nposti+kji))then
                    goto 234
                  endif
 432             continue
                 import=0
                 goto 235
 234            continue
 235            continue
               endif
               if(import.eq.1)then
                 iq(jvdiv+ioff-nposti+nposti)=i
                 iq(jvdiv+i)=ioff-nposti
                 goto 145
               endif
             else
               import=0
             endif
             iq(jbuff+1)=j-1
             nposti=j+2
             iq(jbuff+j+1)=i
             iq(jbuff+j+2)=i
             iq(jvdiv+i)=ioff
             do 144 m=1,nposti
               iq(jvdiv+ioff+m)=iq(jbuff+m)
 144         continue
             ioff=ioff+nposti
            else
             aveinc=j+2
             avesta=avesta+aveinc
            endif
 145        continue
            if(inbuf1.gt.tmpmax(iaxis))then
             tmpmax(iaxis)=inbuf1
            endif
            if(inbuf1.ne.0.)ii=ii+1
            avelis=avelis+inbuf1
            clslic=chslic
            chslic=clslic+thisli
 103      continue
          if(jflag.eq.1)then
             ndioff=ndioff+ioff
             if(iswit(9).eq.12345)then
              print *,'words booked =',nwvili,'; words used =',ioff
              print *,' '
          endif
*** ONLY FOR DEBUG
**             mymyof=0
**             do 2 mm=1,ndivto(iaxis)
**               myoff=iq(jvdiv+mm)
**              if(myoff.ne.mymyof)then
**               if(iq(jvdiv+myoff+1).eq.0)then
**                 print *,'Lower div =',iq(jvdiv+myoff+2)
**                 print *,'Upper div =',iq(jvdiv+myoff+3)
**               elseif(iq(jvdiv+myoff+1).eq.1)then
**                 print *,'Lower div =',iq(jvdiv+myoff+3)
**                 print *,'Upper div =',iq(jvdiv+myoff+4)
**               endif
**             endif
**               mymyof=iq(jvdiv+mm)
** 2           continue
***
          endif
          if(ii.eq.0)then
            print *,iaxis,'=iax: not filled divisions: error!'
            print *,' '
            aveave=10000
            avelis=10000
            goto 105
          endif
          if(jflag.eq.0)then
            ivoaxi(iaxis)=avesta
          endif
          aveave=avelis/ndivto(iaxis)
          avelis=avelis/ii
 105      continue
          qualit(iaxis)=avelis
*** ONLY FOR DEBUG
**      print *,'Max n. of objects per div = ',tmpmax(iaxis)
**      print *,'Aver. n. of obj. per not-empty div = ',avelis
**      print *,'Average n. of objects per div = ',aveave
**            print *,' '
***
 110     continue
        if(jflag.eq.0)then
         tmpq=10000
         tmpm=10000
         itmpq=0
         itmpm=0
         do 111 iaxis=1,7
          if(qualit(iaxis).lt.tmpq)then
           tmpq=qualit(iaxis)
           itmpq=iaxis
          endif
          if(tmpmax(iaxis).lt.tmpm)then
           tmpqm=tmpmax(iaxis)
           itmpm=iaxis
          endif
 111     continue
         if(iswit(9).eq.12345)then
          print *,'nin=',nin,' iax=',itmpq,' ndiv=',ndivto(itmpq)
          print *,'Max n. of objects per div = ',tmpmax(itmpq)
          print *,'Average n. of objects per div = ',tmpq
         endif
*** ONLY FOR DEBUG
**         if(isearc.lt.0)then
**           jsb=lq(lq(jvo-nin-1))
**           iaxor=q(jsb+1)
**           ndivor=q(jsb+2)-1
**           jsco=lq(jvo-nin-2)
**           tmpqor=0.
**           tmpmor=0.
**           do 133 idivor=1,ndivor
**             if(iq(jsco+idivor).gt.tmpmor)tmpmor=iq(jsco+idivor)
**             tmpqor=tmpqor+iq(jsco+idivor)
** 133       continue
**           tmpqor=tmpqor/ndivor
**           print *,'Gsord: iax=',iaxor,' ndiv=',ndivor
**           print *,'Gsord: Max n. of obj. per div = ',tmpmor
**           print *,'Gsord: Aver. n. of obj. per div = ',tmpqor
**         endif
***
         ndivst=ndivst+(ndivto(itmpq)+ndivto(itmpq)*(3.+tmpq)+10.)
         jflag=1
         goto 1
        else
          jflag=0
*** ONLY FOR DEBUG
**          print *,'nin=',nin,' iax=',q(jvirt+4*(ivo-1)+1),' ndiv=',
**     +q(jvirt+4*(ivo-1)+2)
**          ittmp=0
**          iind=q(jvirt+4*(ivo-1)+2)
**          do 155 n=1,iind
**           jvdiv=lq(jvirt-ivo)
**           iofset=iq(jvdiv+n)
**           nnobj=iq(jvdiv+iofset+1)
**           if(nnobj.gt.ittmp)ittmp=nnobj
** 155      continue
**          print *,'Max n. of objects per div = ',ittmp
**          print *,' '
**          print *,' '
***
        endif
        endif
        if(nin.gt.ninmax)ninmax=nin
 101  continue
       nwtota=ndivst+nvolum*5+10.
       if(iswit(9).eq.12345)then
        print *,'Computed number of words foreseen = ',nwtota
       endif
       nwreal=nwjvir+nwjvdi
       if(iswit(9).eq.12345)then
        print *,'Computed number of words booked = ',nwreal
       endif
       nwneed=nwjvir+ndioff
       if(iswit(9).eq.12345)then
        print *,'Computed number of words needed = ',nwneed
       endif
       if(jphi2.ne.0)call mzdrop(ixstor,jphi2,' ')
       if(jclow.ne.0)call mzdrop(ixstor,jclow,' ')
       if(jchig.ne.0)call mzdrop(ixstor,jchig,' ')
       if(jbuff.ne.0)call mzdrop(ixstor,jbuff,' ')
*
********************************************************************************
*
* *** Scan the volume structure to retrieve the path through
*      the physical tree for all sensitive detectors
*
       CALL GHCLOS
*
* *** Books STAT banks if data card STAT is submitted
*
      IF (NSTAT.GT.0)  CALL GBSTAT
*
      CALL MZGARB (IXCONS, 0)
*
 1001 FORMAT (' Severe diagnostic in initialization phase. STOP')
 1002 FORMAT (' GGCLOS : NVOLUM =',I5,' *****')
 1003 FORMAT (' Illegal tracking medium number in volume : ',A4)
 1004 FORMAT (' GGORDQ : Volume ',A4,' has more than 500 (',
     +        I3,') daughters ; volume sorting not possible !')
*                                                             END GGCLOS
  999 CONTINUE
      END
 
+DECK, GHCLOS.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GHCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        SUBR. GHCLOS                                            *
C.    *                                                                *
C.    *   For every sensitive detector, calls GGDETV in order to       *
C.    *   complete the JD bank with the list of volume names which     *
C.    *   permit to identify uniquely a given physical detector, the   *
C.    *   list of bit numbers to pack the corresponding volume copy    *
C.    *   numbers,  and the generic path(s) through the JVOLUM tree.   *
C.    *                                                                *
C.    *   Called by : GGCLOS, <USER>                                   *
C.    *   Author    : F.Bruyant                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
*
      IF (JSET.NE.0) THEN
*
* ***   Scan the volume structure to retrieve the path through
*       the physical tree for all sensitive detectors
*
        NSET = IQ(JSET-1)
        DO 20 ISET=1,NSET
          JS = LQ(JSET-ISET)
          NDET = IQ(JS-1)
          DO 10 IDET=1,NDET
            CALL GGDETV (ISET, IDET)
   10     CONTINUE
   20   CONTINUE
      ENDIF
*                                                             END GHCLOS
      END
+DECK,GINIT
*CMZ :  3.21/03 12/10/94  18.45.33  by  S.Giani
*-- Author :
      SUBROUTINE GINIT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       GEANT initialisation routine                             *
C.    *                                                                *
C.    *         IFINIT(1)=1 free                                       *
C.    *               (2)=1 if GZINIT   "  "                           *
C.    *               (3)=1 if GLUND or GLUNDI have been called        *
C.    *               (4)=1 if GHEINI or GPGHEI have been called       *
C.    *               (5)=1 if GHCASC has been called                  *
C.    *               (6)=1 if GLUDKY has been called                  *
C.    *               (7)=1 if GTAU  "   "                             *
C.    *               (8)=1 if GPRELA                                  *
C.    *               (9)=1 if GPCXYZ                                  *
C.    *              (10)=1 if GDRAW                                   *
C.    *              (11)=1 if INIT_GMR                                *
C.    *              (12)=1 if GET_GEANT_STRUCTURE                     *
C.    *              (13)=1 if GPIONS                                  *
C.    *              (14)=1 if GDINIT                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCLIST
+SEQ,GCSETS
+SEQ,GCONSP
+SEQ,GCPUSH
+SEQ,GCTIME
+SEQ,GCPHYS
+SEQ,GCPARM
+SEQ,GCCUTS
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCMULO
+SEQ,GCSCAN
+SEQ,GCOPTI
+SEQ,GCNUM
+SEQ,GCSTAK
+SEQ,GCTRAK
+SEQ,GCUNIT
+SEQ,GCVOLU
+SEQ,GCTMED
+SEQ,GCRZ
+SEQ,GCJUMP, IF=USRJMP
*
*     COMMON/GCONST/PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
*     COMMON/GCONSX/EMMU,PMASS,AVO
      COMMON/GCONST/CONS1(8)
      COMMON/GCONSX/CONS2(3)
+SELF, IF=USRJMP
      EXTERNAL      GUDCAY, GUDIGI, GUDTIM, GUFLD , GUHADR, GUIGET,
     +              GUINME, GUINTI, GUKINE, GUNEAR, GUOUT , GUPHAD,
     +              GUSKIP, GUSTEP, GUSWIM, GUTRAK, GUTREV, GUVIEW,
     +              GUPARA
+SELF
C
C             ZEBRA system common blocks
C
      COMMON /ZHEADP/IQHEAD(20),IQDATE,IQTIME,IQPAGE,NQPAGE(4)
      COMMON /ZMACH/ NQBITW,NQBITC,NQCHAW,NQLNOR,NQLMAX,NQLPTH,NQRMAX
     +,              IQLPCT,IQNIL
      COMMON /ZSTATE/QVERSN,NQPHAS,IQDBUG,NQDCUT,NQWCUT,NQERR
     +,              NQLOGD,NQLOGM,NQLOCK,NQDEVZ,NQAUGM(6)
      COMMON /ZUNIT/ IQREAD,IQPRNT,IQPR2,IQLOG,IQPNCH,IQTTIN,IQTYPE
C
      CHARACTER*4 MEC(MAXMEC),MEC1(MAXME1),DFLT(2)
      CHARACTER*8 CHVERS
+SELF, IF=MONITOR
      CHARACTER*32 CHINFO
+SELF
      PARAMETER (LEFTM1=MAXME1-9)
      SAVE LOAD
      DATA LOAD/0/
      DATA  DFLT /'    ','XXXX'/
      DATA MEC/'NEXT','MULS','LOSS','FIEL','DCAY','PAIR','COMP','PHOT'
     +        ,'BREM','DRAY','ANNI','HADR','ECOH','EVAP','FISS','ABSO'
     +        ,'ANNH','CAPT','EINC','INHE','MUNU','TOFM','PFIS','SCUT'
     +        ,'RAYL','PARA','PRED','LOOP','NULL','STOP'/
      DATA MEC1/'LABS','LREF','SMAX','SCOR','CKOV','REFL','REFR',
     +          'SYNC','STRA',LEFTM1*'    '/
C.
C.    ------------------------------------------------------------------
C.
C
+SEQ,DATEQQ
+SEQ,TIMEQQ
      CALL GETVER(CHVERS,GVERSN)
      ZVERSN = QVERSN
      IGDATE = IQDATE
      IGTIME = IQTIME
      LIN    = IQREAD
      IF(IQTTIN.NE.0) LIN=IQTTIN
      LOUT   = IQPRNT
C
      WRITE (CHMAIL,10100)GVERSN
      CALL GMAIL(0,0)
*
*** 94b release is coincident with cradle 0.03
      GVERSC = 0.03
+SEQ, GVERSC, T=PASS.
      IF (GVERSC.NE.0.0) THEN
         WRITE (CHMAIL,10200) GVERSC
         CALL GMAIL(0,0)
      ENDIF
+SELF, IF=MONITOR
*
      WRITE(CHINFO,10000) GVERSN, GVERSC
10000 FORMAT(' Version/Cradle: ',F7.4,'/',F7.4)
      CALL GEAMON(1,CHINFO)
+SELF.
      WRITE(CHMAIL,10300)IDATQQ,ITIMQQ
      CALL GMAIL(0,1)
C
+SELF, IF=USRJMP
      JUDCAY = JUMPAD(GUDCAY)
      JUDIGI = JUMPAD(GUDIGI)
* GUDTIM is a function
      JUFLD  = JUMPAD(GUFLD)
      JUHADR = JUMPAD(GUHADR)
      JUIGET = JUMPAD(GUIGET)
      JUINME = JUMPAD(GUINME)
      JUINTI = JUMPAD(GUINTI)
      JUKINE = JUMPAD(GUKINE)
      JUNEAR = JUMPAD(GUNEAR)
      JUOUT  = JUMPAD(GUOUT)
      JUPHAD = JUMPAD(GUPHAD)
      JUSKIP = JUMPAD(GUSKIP)
      JUSTEP = JUMPAD(GUSTEP)
      JUSWIM = JUMPAD(GUSWIM)
      JUTRAK = JUMPAD(GUTRAK)
      JUTREV = JUMPAD(GUTREV)
      JUVIEW = JUMPAD(GUVIEW)
      JUPARA = JUMPAD(GUPARA)
+SELF
C
      CALL FFINIT(0)
      NBIT   = NQBITW
      CALL UCTOH(DFLT,IDFLT,4,4)
      CONS1( 1) = PI
      CONS1( 2) = TWOPI
      CONS1( 3) = PIBY2
      CONS1( 4) = DEGRAD
      CONS1( 5) = RADDEG
      CONS1( 6) = CLIGHT
      CONS1( 7) = BIG
      CONS1( 8) = EMASS
      CONS2( 1) = EMMU
      CONS2( 2) = PMASS
      CONS2( 3) = AVO
      DO 10 J=1,MXGKIN
         TOFD(J)  = 0.
         IFLGK(J) = 0
   10 CONTINUE
C
      IGAUTO= 1
      IPAIR = 1
      ICOMP = 1
      IPHOT = 1
      IRAYL = 0
      IBREM = 1
      IHADR = 1
      IANNI = 1
      IDRAY = 1
      IMUNU = 1
      IPFIS = 0
      IDCAY = 1
      ILOSS = 2
      IMULS = 1
      ILABS = -1
      ITCKOV = 0
      ISYNC = 0
      ISTRA = 0
C
      CUTGAM = 0.001
      CUTELE = 0.001
      CUTHAD = 0.01
      CUTNEU = 0.01
      CUTMUO = 0.01
      TOFMAX = BIG
      DO 20 J=1,5
         GCUTS(J) = 0.
   20 CONTINUE
C
C               The following cuts can be changed by data card CUTS
C               If they are now changed, then the routine GPHYSI
C               will change them respectively to
C               BCUTE=CUTGAM,BCUTM=CUTGAM, DCUTE=CUTELE, DCUTM=CUTELE
C               and PPCUTM=4.*EMASS
C
      DCUTE = BIG
      DCUTM = BIG
      BCUTE = BIG
      BCUTM = BIG
      PPCUTM= BIG
      ISTPAR= 1
      IOPTIM= 0
C
      NCVERT =  5
      NCKINE =  50
      NCJXYZ = 100
      NPVERT = 5
      NPKINE = 10
      NPJXYZ = 200
C
      IKINE = 0
      DO 30 J=1,10
         PKINE(J) = BIG
   30 CONTINUE
      CALL VZERO (IHSET,26)
      CALL VZERO (NHSTA,9)
      CALL VFILL (LHSTA, 180, IDFLT)
      CALL VFILL (LRGET,  40, IDFLT)
      CALL VZERO (NUNITS,6)
      CALL VZERO (IDEBUG,42)
      CALL VZERO (NMATE,9)
      CALL VZERO (NLEVEL,306)
      NALIVE = 0
      NTMSTO = 0
      NJTMAX = 0
      NJTMIN = 0
      NTSTKP = 500
      NTSTKS = 100
*
*-------- Scan parameters defaults
      SCANFL = .FALSE.
      NPHI   = 90
      PHIMIN = 0.
      PHIMAX = 360.
      IPHI1  = 1
      IPHIL  = NPHI
      NTETA  = 90
      TETMID(1) = -10.
      TETMID(2) = 0.
      TETMID(3) = -1.
      TETMAD(1) =  10.
      TETMAD(2) = 180.
      TETMAD(3) = 1.
      MODTET = 1
      CALL VFILL (ISLIST,MSLIST,IDFLT)
      CALL UCTOH(DFLT(2),ISLIST(1),4,4)
      NSLIST = 1
      VSCAN(1) = 0.
      VSCAN(2) = 0.
      VSCAN(3) = 0.
      FACTX0 = 100.
      FACTL  = 10.
      FACTSF = 100.
      FACTR  = 100.
*---      Parametrization cut=0 means no parametrization
      IPARAM  = 0
      DO 40 J=1,5
         PACUTS(J) = 0.
   40 CONTINUE
*---      Size for the primary parametrization stak
      MPSTAK = 1000
*---      Number of particles generated for every shower
      NPGENE = 20
*-------- Scan parameters defaults
C
      RZTAGS(1)='STRUCTUR'
      RZTAGS(2)='TRIG-NR '
      RZTAGS(3)='RUNG-NRT '
      RZTAGS(4)='USER-ID '
      NRGET  = 0
      NRSAVE = 0
      NRECRZ = 1000
C
      IPAOLD =-1
      NUMOLD = 0
C
      IEVENT = 0
      IDRUN  = 1
      NHEAD  = 10
      NTMED  = 100
      NMATE  = 100
      NROTM  = 100
      NPART  = 100
      NEVENT = 10000000
C
      TIMINT = 0.
      TIMEND = 1.
      ITIME  = 1
C
      CALL UCTOH(MEC,NAMEC,4,MAXMEC*4)
      CALL UCTOH(MEC1,NAMEC1,4,MAXME1*4)
      MAXNST=10000
C
C             Constants for energy loss and physics processes
C
      UPWGHT=1.
      NEKBIN=90
      NEK1=NEKBIN+1
      EKMIN=1.E-5
      EKMAX=1.E+4
C
C             Initialize Random number generator
C
      NRNDM(1) = 0
      NRNDM(2) = 0
      CALL GRNDMQ(0,0,1,' ')
C
C             Constants for multiple scattering (GMUL)
C
      DXM=TWOPI/100.
      XM=-0.5*DXM
      SQ=-0.0099999
      DO 50 I=1,101
         SQ=SQ+0.01
         IF(I.LT.101)SQRMUL(I)=SQRT(-2.*LOG(SQ))
         XM=XM+DXM
         SINMUL(I)=SIN(XM)
   50 COSMUL(I)=COS(XM)
      SQRMUL(101)=0.01
C
C               This piece of code to force loading of default
C               routines from the GEANG file on some machines
C               like VAX.
C
      IF(LOAD.NE.0)THEN
         CALL GWORK (IP1)
+SELF, IF=-USRJMP
         CALL GUDCAY
         CALL GUDIGI
         P1 = GUDTIM( P2, P3,IP4, P4)
         CALL GUFLD ( P1, P2)
         CALL GUHADR
         CALL GUIGET(IP1,IP2,IP3)
         CALL GUINME( P1, P2, P3,IP4)
         CALL GUINTI
         CALL GUKINE
         CALL GUNEAR(IP1,IP2, P3,IP4)
         CALL GUOUT
         CALL GUPHAD
         CALL GUSKIP(IP1)
         CALL GUSTEP
         CALL GUSWIM( P1, P2, P3, P4)
         CALL GUTRAK
         CALL GUTREV
         CALL GUVIEW(IP1,IP2,IP3,IP4)
         CALL GUPARA
+SELF
      ENDIF
C
10100 FORMAT('1*****  GEANT Version',F7.4,
     +' Released on Tuesday 15 March 1994 *****')
*    +' Pre-release version *****')
10200 FORMAT('0*****  Correction Cradle Version ',F7.4)
10300 FORMAT(' *****  Library compiled on ',I6,' at ',I4,' *****')
      END
+DECK,GLAST
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GLAST
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       TERMINATION ROUTINE                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGLAST                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCFLAG
+SEQ,GCUNIT
+SEQ,GCTIME
C.
C.    ------------------------------------------------------------------
C.
      WRITE (CHMAIL,1000) IEVENT
      CALL GMAIL(0,0)
C
      CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'G')
C
      WRITE (CHMAIL,3000) NRNDM
      CALL GMAIL(0,0)
C
C             COMPUTE ONE EVENT PROCESSING TIME
C
      IF(IEVENT.GT.0)THEN
         CALL TIMEL(TIMLFT)
         XMEAN  = (TIMINT - TIMLFT)/IEVENT
         WRITE(CHMAIL,4000)XMEAN
         CALL GMAIL(0,2)
      ENDIF
C
C             Print ZEBRA statistics
C
      CALL MZEND
C
C             Print statistics
C
      IF(JGSTAT.NE.0)CALL GPSTAT
+SELF, IF=MONITOR
C
C             Call monitoring routine
C
      CALL GEAMON(2,'GLAST')
+SELF.
C
 1000 FORMAT('1',9X,'**** NUMBER OF EVENTS PROCESSED =',I10)
 3000 FORMAT(10X,'**** RANDOM NUMBER GENERATOR AFTER'
     +,' LAST COMPLETE EVENT ',2I12)
 4000 FORMAT(10X,'**** TIME TO PROCESS ONE EVENT IS =',F10.4,
     +      ' SECONDS')
      END
+DECK,GLOOK
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GLOOK(NAME,IVECT,N,ILOOK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Search position ILOOK of element NAME in array IVECT     *
C.    *       of length N                                              *
C.    *                                                                *
C.    *    ==>Called by : many GEANT and GEANG routines                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION IVECT(1)
      CHARACTER*(*) NAME
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH(NAME,NAMEH,4,4)
      ILOOK=IUCOMP(NAMEH,IVECT,N)
C
      END
+DECK,GMAIL
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GMAIL(LINBEF,LINAFT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Send a mail on the output device (usually unit LOUT)     *
C.    *       The mail is in character array CHMAIL of /GCMAIL/        *
C.    *       Max length is 132 chars and trailing blanks are stripped *
C.    *       LINBEF lines are skipped before mail and LINAFT after    *
C.    *                                                                *
C.    *    ==>Called by : many routines                                *
C.    *       Authors : R.Brun, P.Zanarini   *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCUNIT
C.
C.    ------------------------------------------------------------------
C.
      DO 10 I=1,LINBEF
        WRITE (LOUT,1000)
   10 CONTINUE
      DO 20 NCH=132,1,-1
        IF (CHMAIL(NCH:NCH).NE.' ') GO TO 30
   20 CONTINUE
      NCH=1
   30 CONTINUE
      WRITE (LOUT,2000) CHMAIL(1:NCH)
      DO 40 I=1,LINAFT
        WRITE (LOUT,1000)
   40 CONTINUE
 1000 FORMAT (1X)
 2000 FORMAT (A)
      END
+DECK,GPHEAD.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPHEAD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints Header bank JHEAD                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    M.Maire                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCFLAG.
*
      IF (JHEAD.NE.0) THEN
         NHEAD = IQ(JHEAD-1)
         WRITE (CHMAIL,1000) (IQ(JHEAD+I),I=1,4)
         CALL GMAIL(0,0)
         WRITE (CHMAIL,1001) (IQ(JHEAD+I),I=5,NHEAD)
         CALL GMAIL(0,0)
         IF (LQ(JHEAD-1).NE.0) THEN
             WRITE(CHMAIL,2000)
             CALL GMAIL(0,0)
             JHU = LQ(JHEAD-1)
             NDT = IQ(JHU-1)
             NW  = MIN(NDT,9)
             WRITE(CHMAIL,3000) (Q(JHU+I),I=1,NW)
   15        CALL GMAIL(0,0)
             IF ((NDT-NW).GT.0) THEN
                NS = NW+1
                NW = MIN(NDT,NW+9)
                WRITE(CHMAIL,3000) (Q(JHU+I),I=NS,NW)
                GO TO 15
             ENDIF
         ENDIF
      ELSE
         WRITE(CHMAIL,4000) IEVENT
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GPHEAD: IDRUN=',I4,' IDEVT=',I7,
     &       ' Random Seeds = ',I10,2X,I10)
 1001 FORMAT(20X,10I10)
 2000 FORMAT(14X,'User words')
 3000 FORMAT( 1X,9(2X,E12.5))
 4000 FORMAT(' **** GPHEAD: No Header bank in memory for ievent:',I7)
*
      END
+DECK,GPRINT
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPRINT(CHNAME,NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print data structures                         *
C.    *                                                                *
C.    *       CHNAME   name of a data structure                        *
C.    *       NUMB     data structure number                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT  ,<GXINT> GINC4               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*4 KNAMES(11),NAME
      DIMENSION NHAMES(11)
      CHARACTER*(*) CHNAME
      SAVE IFIRST,KNAMES,NHAMES
      DATA IFIRST/0/
      DATA KNAMES/'DIGI','JXYZ','HITS','KINE','MATE','VOLU'
     +           ,'ROTM','SETS','TMED','PART','VERT'/
C.
C.    ------------------------------------------------------------------
C.
      NAME=CHNAME
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KNAMES,NHAMES,4,44)
      ENDIF
C
      CALL GLOOK(NAME,NHAMES,11,JUMP)
C
      IF(JUMP.EQ. 1) CALL GPDIGI ('*','*')
      IF(JUMP.EQ. 2) CALL GPJXYZ (NUMB)
      IF(JUMP.EQ. 3) CALL GPHITS ('*','*')
      IF(JUMP.EQ. 4) CALL GPKINE (NUMB)
      IF(JUMP.EQ. 5) CALL GPMATE (NUMB)
      IF(JUMP.EQ. 6) CALL GPVOLU (NUMB)
      IF(JUMP.EQ. 7) CALL GPROTM (NUMB)
      IF(JUMP.EQ. 8) CALL GPSETS ('*','*')
      IF(JUMP.EQ. 9) CALL GPTMED (NUMB)
      IF(JUMP.EQ.10) CALL GPPART (NUMB)
      IF(JUMP.EQ.11) CALL GPVERT (NUMB)
C
      END
+DECK,GPRUNG.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPRUNG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints Rung bank JRUNG                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    M.Maire                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
*
      IF (JRUNG.NE.0) THEN
         NRUNG = IQ(JRUNG-1)
         WRITE (CHMAIL,1000) (IQ(JRUNG+I),I=1,10)
         CALL GMAIL(0,0)
         WRITE (CHMAIL,1001) (IQ(JRUNG+I),I=11,20)
         CALL GMAIL(0,0)
         WRITE (CHMAIL,1002) ( Q(JRUNG+I),I=21,30)
         CALL GMAIL(0,0)
         IF (LQ(JRUNG-1).NE.0) THEN
             WRITE(CHMAIL,2000)
             CALL GMAIL(0,0)
             JRU = LQ(JRUNG-1)
             NDT = IQ(JRU-1)
             NW  = MIN(NDT,9)
             WRITE(CHMAIL,3000) (Q(JRU+I),I=1,NW)
   15        CALL GMAIL(0,0)
             IF ((NDT-NW).GT.0) THEN
                NS = NW+1
                NW = MIN(NDT,NW+9)
                WRITE(CHMAIL,3000) (Q(JRU+I),I=NS,NW)
                GO TO 15
             ENDIF
         ENDIF
      ELSE
         WRITE(CHMAIL,4000)
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GPRUNG: IDRUN=',I4,2X,9I7)
 1001 FORMAT(20X,10I10)
 1002 FORMAT(20X,10F10.4)
 2000 FORMAT(14X,'User words')
 3000 FORMAT( 1X,9(2X,E12.5))
 4000 FORMAT(' **** GPRUNG: No Rung bank existing in memory ')
*
      END
+DECK,GRUN
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GRUN
*.
*.    ******************************************************************
*.    *                                                                *
*.    *       Steering routine to process all the events               *
*.    *                                                                *
*.    *    ==>Called by : <USER>, main program                         *
*.    *       Author    R.Brun  *********                              *
*.    *                                                                *
*.    ******************************************************************
*.
+SEQ,GCBANK
+SEQ,GCFLAG
+SEQ,GCUNIT
+SEQ,GCTIME
      SAVE IFIRST
      DATA IFIRST/0/
*.
*.    ------------------------------------------------------------------
*.
*             Keep starting time
*
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL TIMEL(TIMINT)
      ENDIF
*
   10 IF(IEVENT.LT.NEVENT) THEN
         IEVENT=IEVENT+1
*
*             Initialises event partition
*
         CALL GTRIGI
*
*             Process one event (trigger)
*
         CALL GTRIG
*
*             Clear event partition
*
         CALL GTRIGC
*
         IF(IEORUN.EQ.0) THEN
*
*             Check time left
*
            IF(ITIME.LE.0)GO TO 10
            IF(MOD(IEVENT,ITIME).NE.0)GO TO 10
            CALL TIMEL(TIMNOW)
            IF(TIMNOW.GT.TIMEND)GO TO 10
            WRITE(CHMAIL,10000)TIMEND
            CALL GMAIL(0,2)
            IEORUN = 1
         ENDIF
      ENDIF
*
10000 FORMAT(5X,'***** THE JOB STOPS NOW BECAUSE THE TIME LEFT IS LESS',
     +' THAN     ',F8.3,' SECONDS *****')
      END
+DECK,GSHEAD.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSHEAD (NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in HEADER user bank.          *
C     *       IADR is the stating location in the bank                 *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCFLAG.
*
      DIMENSION UBUF(1)
*
      IF (JHEAD.GT.0) THEN
*
         NDATA = IADR + NWBUF
         IF (LQ(JHEAD-1).EQ.0) THEN
            CALL MZBOOK (IXDIV,JHU,JHEAD,-1,'HEDU',0,0,NDATA,3,0)
         ELSE
            JHU = LQ(JHEAD-1)
            NFREE = IQ(JHU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXDIV,JHU,0,-NFREE,'I')
         ENDIF
*
         DO  10 I=1,NWBUF
            Q(JHU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
      ELSE
*
         IADR = 0
         WRITE(CHMAIL,1000) IEVENT
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSHEAD: No Header bank in memory for ievent:',I7)
*
      END
+DECK,gsrung.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSRUNG (NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in RUNG user bank.            *
C     *       IADR is the stating location in the bank                 *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
*
      DIMENSION UBUF(1)
*
      IF (JRUNG.GT.0) THEN
*
         NDATA = IADR + NWBUF
         IF (LQ(JRUNG-1).EQ.0) THEN
            CALL MZBOOK (IXCONS,JRU,JRUNG,-1,'RUNU',0,0,NDATA,3,0)
         ELSE
            JRU = LQ(JRUNG-1)
            NFREE = IQ(JRU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXCONS,JRU,0,-NFREE,'I')
         ENDIF
*
         DO 10 I=1,NWBUF
            Q(JRU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
*
      ELSE
         IADR = 0
         WRITE(CHMAIL,1000)
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSRUNG: No RUNG bank existing in memory ')
*
      END
+DECK,GTRIG
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GTRIG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Steering routine to process one event                    *
C.    *    ==>Called by : GRUN   ,<GXINT> GINC4                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCVDMA.
+SEQ,GCFLAG
+SEQ,GCJUMP, IF=USRJMP
C.
C.    ------------------------------------------------------------------
C.
C.            Kinematics
C.
      IF(RAYTRA.NE.1.)THEN
+SELF, IF=-USRJMP
       CALL GUKINE
+SELF, IF=USRJMP
       CALL JUMPT0(JUKINE)
+SELF
      ELSE
       CALL GDKINE
      ENDIF
      IF (IEOTRI.NE.0)  GO TO  99
C.
C.            Tracking
C.
+SELF, IF=-USRJMP
      CALL GUTREV
+SELF, IF=USRJMP
      CALL JUMPT0(JUTREV)
+SELF
      IF (RAYTRA.EQ.1.) GO TO  99
      IF (IEOTRI.NE.0)  GO TO  99
C.
C.            Digitisation
C.
+SELF, IF=-USRJMP
      CALL GUDIGI
+SELF, IF=USRJMP
      CALL JUMPT0(JUDIGI)
+SELF
      IF (IEOTRI.NE.0)  GO TO  99
C.
C.            User end of event control routine
C.
+SELF, IF=-USRJMP
      CALL GUOUT
+SELF, IF=USRJMP
      CALL JUMPT0(JUOUT)
+SELF
C
  99  RETURN
      END
+DECK,GTRIGC
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GTRIGC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Clear event partition                                    *
C.    *                                                                *
C.    *    ==>Called by : GRUN   ,<GXINT> GINC4                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCSTAK.
+SEQ,GCFLAG.
C.
C.    ------------------------------------------------------------------
C.
*
      IF (NJTMAX.LT.0) NJTMAX = -NJTMAX
*
      CALL GRNDMQ(IQ(JRUNG+19),IQ(JRUNG+20),0,'G')
      IQ(JRUNG+29) = IEVENT
*
      IF (JSTAK.NE.0) THEN
         IQ(JSTAK+1) = 0
         IQ(JSTAK+3) = 0
      ENDIF
*
      CALL MZWIPE (IXDIV)
*                                                             END GTRIGC
      END
 
+DECK,GTRIGI
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GTRIGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Initialises event partition                              *
C.    *    ==>Called by : GRUN ,<GXINT> GINC4                          *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCVDMA.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCFLAG
+SEQ,GCUNIT
+SEQ,GCTRAK
C.
C.    ------------------------------------------------------------------
C.
      IEOTRI=0
      NTRACK=0
      NVERTX=0
      IDEBUG=0
      TOFG  =0.
C
C               Print event number and random number generator
C
      IF(RAYTRA.NE.1.)CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'G')
C
C               Create event header bank
C
      CALL MZBOOK(IXDIV,JHEAD,JHEAD,1,'HEAD', 1, 1,NHEAD,2,0)
      IDEVT=IDEVT+1
      IQ(JHEAD+1)=IDRUN
      IQ(JHEAD+2)=IDEVT
      IQ(JHEAD+3)=NRNDM(1)
      IQ(JHEAD+4)=NRNDM(2)
C
      IF(ITEST.GT.0)THEN
         IF(MOD(IEVENT,ITEST).EQ.0)THEN
           IF(RAYTRA.NE.1.)THEN
            WRITE (CHMAIL,1000) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
            CALL GMAIL(0,0)
           ENDIF
         ENDIF
      ENDIF
C
      IF(IEVENT.GE.IDEMIN.AND.IEVENT.LE.IDEMAX)IDEBUG=1
C
 1000 FORMAT(' **** GTRIGI: IEVENT=',I7,' IDEVT=',I7,
     +' Random Seeds = ',I10,2X,I10)
  99  RETURN
      END
+DECK,GWORK
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GWORK(NWORK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Handle working space.                                      *
C.    *                                                                *
C.    *     If NWORK>0 make sure that at least NWORK words of working  *
C.    *     space are available in the GCBANK common. If current       *
C.    *     working space is >= NWORK, do nothing.                     *
C.    *                                                                *
C.    *     If NWORK=0 return in NWORK the current size of the         *
C.    *     working space.                                             *
C.    *                                                                *
C.    *     If NWORK<0 reset the working space to be NWORK words       *
C.    *     irrespective of its value.                                 *
C.    *                                                                *
C.    *    ==>Called by :USER,GZINIT,GPHYSI,GDRAWC,GDRAWX,GDSHOW,GKXYZ *
C.    *                                                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT,IF=DEBUG
      COMMON / QUEST / IQUEST(100)
C.
C.    ------------------------------------------------------------------
C.
      IF(NWORK.GE.0) THEN
         CALL MZINQS(IXSTOR)
         NOWORK = IQUEST(5)-IQUEST(3)-1
+SELF,IF=DEBUG
         WRITE(CHMAIL,
     +   '('' *** GWORK: Size of the working space = '',I10)') NOWORK
         CALL GMAIL(0,0)
+SELF.
         IF(NWORK.EQ.0) THEN
            NWORK=NOWORK
         ELSE
            IF(NWORK.GT.NOWORK) THEN
               CALL MZWORK(IXSTOR,WS,WS(NWORK),0)
            ENDIF
         ENDIF
      ELSE
         CALL MZWORK(IXSTOR,WS,WS(-NWORK),0)
      ENDIF
      END
+DECK,GZEBRA
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GZEBRA(NZEB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to initialise ZEBRA store (//)                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
C.
C.    ------------------------------------------------------------------
C.
      NZEBRA=NZEB
      CALL MZEBRA(-1)
      CALL MZSTOR(IXSTOR,'/GCBANK/',' ',FENDQ,LQ,LR1,WS,LQ(KWWORK+100)
     +            ,LQ(NZEBRA-30))
      CALL MZLOGL(IXSTOR,0)
C
      RETURN
      END
+DECK,GZINIT
*CMZ :  3.21/02 29/03/94  17.18.27  by  S.Giani
*-- Author :
      SUBROUTINE GZINIT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to initialise GEANT/ZEBRA data structures        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCFLAG
+SEQ,GCJLOC
+SEQ,GCTIME
+SEQ,GCMZFO
+SEQ,GCSCAL
      COMMON/GCLOCA/NLOCAL(2),LOCAL(20)
C.
C.    ------------------------------------------------------------------
C.
      IF(IFINIT(2).NE.0)RETURN
      IFINIT(2)=1
C
C                 Create one long range division (reverse)
C                 to store all constants
C                 The event structures are created in division 2
C                 of the store
C
      MINCON=2000
      MAXCON=8*NZEBRA/10
      CALL MZDIV(IXSTOR,IXCONS,'Constants',MINCON,MAXCON,'LRC')
      IXDIV=IXSTOR+2
C
C                 IXDIV and IXCONS are two self contained divisions.
C                 To gain time we specify that to ZEBRA
C
      CALL MZXREF(IXCONS,IXDIV,'C')
      CALL MZXREF(IXDIV,IXCONS,'C')
C
C                 Define a default work space of KWWORK words
C
      CALL GWORK(KWWORK)
C
C                 Create a permanent link area for master pointers
C
      CALL MZLINK(IXSTOR,'/GCLINK/',JDIGI,JSKLT,JDIGI)
C
C                 Create a permanent link area for param. pointers
C
      CALL MZLINK(IXSTOR,'/GCSLNK/',LSCAN,LSLAST,LSCAN)
C
C                 Create temporary link areas
C
      CALL MZLINT(IXSTOR,'/GCLOCA/',NLOCAL,LOCAL(1),LOCAL(20))
      CALL MZLINT(IXSTOR,'/GCJLOC/',NJLOC ,JTM,JRANG)
      CALL MZLINT(IXSTOR,'/GCJLCK/',NJLCK ,JTCKOV,JTASHO)
C
C             Define IO descriptors of GEANT banks
C
      CALL MZFORM('MATE','5H -F'      ,IOMATE)
      CALL MZFORM('PART','5H -F'      ,IOPART)
      CALL MZFORM('TMED','5H -F'      ,IOTMED)
      CALL MZFORM('SEJD','10I / 1H 1I',IOSEJD)
      CALL MZFORM('SJDD','/ 1H 1I'    ,IOSJDD)
      CALL MZFORM('SJDH','/ 1H 1I 2F' ,IOSJDH)
      CALL MZFORM ('STAK', '3I / 3I 9F',IOSTAK)
      CALL MZFORM('RUNG','20I 8F 2I'   ,IORUNG)
C
C             Create RUN header bank
C
      CALL MZBOOK(IXCONS,JRUNG,JRUNG,1,'RUNG',1,1,30,IORUNG,0)
      IQ(JRUNG-5)=1
      IQ(JRUNG+1)=IDRUN
C
C             Fill header with default date,time,Geant and Zebra
C             version numbers for the 4 main GEANT data structures
C             INIT,KINE,HITS,DIGI
C
       DO 10 I=1,4
         IQ(JRUNG+2*I+ 9)=IGDATE
         IQ(JRUNG+2*I+10)=IGTIME
          Q(JRUNG+2*I+19)=GVERSN
          Q(JRUNG+2*I+20)=ZVERSN
  10  CONTINUE
C
  99  RETURN
      END
 
+DECK,GGCLO2,IF=OLD.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GGCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Closes off the geometry setting.                            *
C.    *    Initializes the search list for the contents of each        *
C.    *    volume following the order they have been positioned, and   *
C.    *    inserting the content '0' when a call to GSNEXT (-1) has    *
C.    *    been required by the user.                                  *
C.    *    Performs the development of the JVOLUM structure for all    *
C.    *    volumes with variable parameters, by calling GGDVLP.        *
C.    *    Interprets the user calls to GSORD, through GGORD.          *
C.    *    Computes and stores in a bank (next to JVOLUM mother bank)  *
C.    *    the number of levels in the geometrical tree and the        *
C.    *    maximum number of contents per level, by calling GGNLEV.    *
C.    *    Sets status bit for CONCAVE volumes, through GGCAVE.        *
C.    *    Completes the JSET structure with the list of volume names  *
C.    *    which identify uniquely a given physical detector, the      *
C.    *    list of bit numbers to pack the corresponding volume copy   *
C.    *    numbers, and the generic path(s) in the JVOLUM tree,        *
C.    *    through the routine GHCLOS.                                 *
C.    *                                                                *
C.    *    Called by : <USER>                                          *
C.    *    Authors   : R.Brun, F.Bruyant  *********                    *
C.    *                                                                *
C.    *    Modified by S.Egli at 15.9.90: automatic sorting of volumes *
C     *    done by calling GGORDQ for each volume                      *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCLIST.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCOPTI.
      CHARACTER*4 NAME
      LOGICAL BTEST
C.
C.    ------------------------------------------------------------------
C.
*
* *** Stop the run in case of serious anomaly during initialization
*
      IF (IEORUN.NE.0) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         STOP
      ENDIF
*
      IF (NVOLUM.LE.0) THEN
         WRITE (CHMAIL, 1002) NVOLUM
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      NPUSH = NVOLUM -IQ(JVOLUM-2)
      CALL MZPUSH (IXCONS, JVOLUM, NPUSH, NPUSH,'I')
*
* *** Loop over volumes, create default JNear banks as relevant,
*      and release unused bank space
*
      IDO = 0
      DO 80 IVO = 1,NVOLUM
         JVO = LQ(JVOLUM-IVO)
*
* *** Check if Tracking medium has been defined
*
         NMED=Q(JVO+4)
         IF(NMED.LE.0.OR.NMED.GT.IQ(JTMED-2))THEN
            WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
            CALL GMAIL (0, 0)
         ELSE
            IF(LQ(JTMED-NMED).EQ.0)THEN
               WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
               CALL GMAIL (0, 0)
            ENDIF
         ENDIF
         IF (BTEST(IQ(JVO),0)) GO TO 80
         IDO = 1
         IQ(JVO) = IBSET(IQ(JVO),0)
         NINL  = IQ(JVO-2)
         NIN   = Q(JVO+3)
         NUSED = IABS(NIN)
         IF (NIN.GT.0) THEN
*           reserve enough additional space for sorted volumes
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
              NUSED=NUSED+1
            ELSE
              NUSED=NUSED+2
            ENDIF
         ENDIF
*
         NPUSH = NUSED -NINL
         DO 90 IN=NINL,NUSED+1,-1
            JIN = LQ(JVO-IN)
            IF(JIN.GT.0) THEN
               CALL MZDROP(IXCONS,JIN,'L')
            ENDIF
  90     CONTINUE
         CALL MZPUSH (IXCONS, JVO, NPUSH, 0, 'I')
         IF (NIN.LE.0) GO TO 80
*
         IF(BTEST(IQ(JVO),3)) THEN
            IZERO=1
         ELSE
            IZERO=0
         ENDIF
         NEL = NIN +IZERO
         JN = LQ(JVO-NIN-1)
         IF(JN.EQ.0) THEN
            CALL MZBOOK (IXCONS,JN,JVO,-NIN-1,'VONE',0,0,NEL+1,2,0)
         ENDIF
         IQ(JN-5) = IVO
         IQ(JN+1) = NEL
         JN = JN +1
         DO 29 I = 1,NIN
            IQ(JN+IZERO+I) = I
   29    CONTINUE
         IF (IZERO.NE.0) IQ(JN+1) = 0
*
   80 CONTINUE
*
      IF (IDO.NE.0) THEN
*
* ***    Perform development of JVOLUM structure where necessary
*
         CALL GGDVLP
*
* ***    Fill GSORD ordering banks if required
*
* Modified by S.Egli to allow GGORDQ to find the optimum sorting for
* all volumes
*
         IF(IOPTIM.GE.1)THEN
            WRITE(6,'(A)')' GGCLOS: Start automatic volume ordering:'
         ENDIF
         DO 91 IVO = 1,NVOLUM
            JVO = LQ(JVOLUM-IVO)
            NIN = Q(JVO+3)
            ISEARC=Q(JVO+1)
            IF(ISEARC.GT.0) GO TO 91
*           check if sorting not possible or not wanted
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
               Q(JVO+1)=0.
               IF(NIN.GT.500.AND.IOPTIM.GE.1)THEN
                 CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
                 WRITE (CHMAIL,1004) NAME,NIN
                 CALL  GMAIL (0, 0)
               ENDIF
            ELSEIF(IOPTIM.EQ.0)THEN
               IF(ISEARC.LT.0)CALL GGORD (IVO)
            ELSEIF(IOPTIM.EQ.1)THEN
               IF(ISEARC.EQ.0) THEN
                  CALL GGORDQ(IVO)
               ELSE
                  CALL GGORD (IVO)
               END IF
            ELSE
               CALL GGORDQ(IVO)
            ENDIF
   91    CONTINUE
*
* ***    Set status bit for concave volumes
*
         CALL GGCAVE
*
* ***    Compute maximum number of levels and of contents per level
*
         CALL GGNLEV
*
      ENDIF
*
* *** Scan the volume structure to retrieve the path through
*      the physical tree for all sensitive detectors
*
       CALL GHCLOS
*
* *** Books STAT banks if data card STAT is submitted
*
      IF (NSTAT.GT.0)  CALL GBSTAT
*
      CALL MZGARB (IXCONS, 0)
*
 1001 FORMAT (' Severe diagnostic in initialization phase. STOP')
 1002 FORMAT (' GGCLOS : NVOLUM =',I5,' *****')
 1003 FORMAT (' Illegal tracking medium number in volume : ',A4)
 1004 FORMAT (' GGORDQ : Volume ',A4,' has more than 500 (',
     +        I3,') daughters ; volume sorting not possible !')
*                                                             END GGCLOS
  999 CONTINUE
      END
 
+PATCH,GCONS
+DECK,DOCGCONS,IF=DOC
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
************************************************************************
*                                                                      *
*                   Introduction to the section CONS                   *
*                   --------------------------------                   *
*                                                                      *
*   THE SECTION CONS                                                   *
*                                                                      *
*  The  experimental   setup  is  represented  by   a  structure  of   *
* geometrical volumes.  Each volume is  given a medium number by the   *
* user.  Different volumes may have the same medium number [GEOM].     *
*  A  medium is  defined  by  a set  of  parameters, the  so>-called   *
* 'tracking  medium'  parameters,  which include  reference  to  the   *
* material filling the volume.                                         *
*  The tracking  of particles  through an experimental  setup [TRAK]   *
* requires access to the data which describe                           *
*       - the geometrical setup,                                       *
*       - the characteristics of the materials used,                   *
*       - the tracking medium parameters, and                          *
*       - the particle properties.                                     *
*  The section CONS contains all routines related to the storage and   *
* retrieval of information for the materials, the tracking media and   *
* the particles.                                                       *
*                                                                      *
*   MATERIALS                                                          *
*                                                                      *
*  The material  constants are  stored in  the data  structure JMATE   *
* through  the routine  GMATE which  defines the  standard table  of   *
* materials.   They can  be  accessed with  the  routine GFMATE  and   *
* printed with the routine GPMATE.                                     *
*  GMATE calls  the routine GSMATE  for each material in  turn.  The   *
* user may directly use GSMATE instead  of, or in addition to, or to   *
* partly override, GMATE.                                              *
*  MIXTUREs of  basic materials, or COMPOUNDs,  molecules with atoms   *
* from  different basic  materials, may  also be  defined and  their   *
* characteristics  can be  stored  in the  structure JMATE,  through   *
* calls  to the  routine  GSMIXT.  Mixtures  of  compounds are  also   *
* accepted.                                                            *
*  In addition,  some quantities computed during  the initialisation   *
* of the physics processes are stored  in the structure JMATE , such   *
* as energy loss and cross>-section tables [PHYS].                     *
*                                                                      *
* TRACKING MEDIUM PARAMETERS                                           *
*                                                                      *
*  For  each medium  in  turn, the  tracking  medium parameters  are   *
* stored in  the data  structure JTMED  through the  routine GSTMED.   *
* Details about these  parameters are given in [TRAK].   They can be   *
* accessed  with the  routine GFTMED  and printed  with the  routine   *
* GPTMED.                                                              *
*  The correct setting  of the tracking media  parameters is crucial   *
* for the  correctness of the  results of the simulation.   In GEANT   *
* some  of  these parameters  are  calculated  automatically by  the   *
* program by default.  This can be  disabled by the data record AUTO   *
* 0, but only experienced users should use this option.                *
*  The tracking cuts,  the physics cuts and the  flags which control   *
* the physics processes, defined in  GINIT and possibly modified via   *
* the relevant data  cards, are also stored in  the structure JTMED.   *
* Any of  these additional  parameters can  be modified  through the   *
* routine GSTPAR.                                                      *
*                                                                      *
* PARTICLES                                                            *
*                                                                      *
*  The particle  constants are  stored in  the data  structure JPART   *
* through  the routine  GPART which  defines the  standard table  of   *
* particles and, if relevant, the  branching ratios and decay modes.   *
*  The standard particle constants can  be accessed with the routine   *
* GFPART and printed with the routine GPPART.                          *
*  GPART calls the routine GSPART (and GSDK for the decays) for each   *
* particle  in turn.   The user  may call  directly GSPART  and GSDK   *
* instead of, or in addition to, or to partly override, GPART.         *
*                                                                      *
************************************************************************
+DECK,GEVKEV
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GEVKEV(EGEV,ENERU,KUNIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Convert energy from GeV to more appropriate units        *
C.    *                                                                *
C.    *    ==>Called by : GPLMAT,GPRMAT,GPHYSI,GPCXYZ                  *
C.    *       Author     M.Maire    *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*4 KUNIT
*
      IF(EGEV.LT.0.0000009999) THEN
         ENERU = EGEV*1.E+9
         KUNIT = '  eV'
      ELSEIF(EGEV.LT.0.0009999) THEN
         ENERU = EGEV*1.E+6
         KUNIT = ' keV'
      ELSEIF(EGEV.LT.0.9999) THEN
         ENERU = EGEV*1.E+3
         KUNIT = ' MeV'
      ELSEIF(EGEV.LT.999.9) THEN
         ENERU = EGEV
         KUNIT = ' GeV'
      ELSE
         ENERU = EGEV*1.E-3
         KUNIT = ' TeV'
      ENDIF
*
      END
+DECK,GFCOUL
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      FUNCTION GFCOUL(Z)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Compute Coulomb correction for pair production and Brem       *
C.    *  REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78              *
C.    *                        FORMULA 2.7.17                          *
C.    *                                                                *
C.    *    ==>Called by : GSMIXT                                       *
C.    *       Author    M.Maire *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (ALPHA = 7.29927E-03)
C
      AZ2   = (ALPHA*Z)**2
      AZ4   =   AZ2 * AZ2
      FP    = ( 0.0083*AZ4 + 0.20206 + 1./(1.+AZ2) ) * AZ2
      FM    = ( 0.0020*AZ4 + 0.0369  ) * AZ4
      GFCOUL = FP - FM
      END
+DECK,GFMATE
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GFMATE(IMAT,NAMATE,A,Z,DENS,RADL,ABSL,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Return parameters for material IMAT                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GTRACK                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
      CHARACTER NAMATE*(*)
      DIMENSION UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      A=-1.
      IF (JMATE.LE.0)GO TO 99
      IF (IMAT.LE.0)GO TO 99
      IF (IMAT.GT.NMATE)GO TO 99
C
      JMA = LQ(JMATE- IMAT)
      IF (JMA.LE.0)GO TO 99
      CALL UHTOC(IQ(JMA+1),4,NAMATE,MIN(20,LEN(NAMATE)))
      A = Q(JMA + 6)
      Z = Q(JMA + 7)
      DENS = Q(JMA + 8)
      RADL = Q(JMA + 9)
      ABSL = Q(JMA + 10)
      NWBUF = IQ(JMA-1) - 11
      IF(NWBUF.GT.0) CALL UCOPY(Q(JMA+12),UBUF,NWBUF)
C
  99  RETURN
      END
+DECK,GFPART
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GFPART(IPART,NAPART,ITRTYP,AMASS,CHARGE,TLIFE
     +          ,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Return parameters for particle of type IPART             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GTREVE                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
      CHARACTER*20 NAPART
      DIMENSION UBUF(10)
C.
C.    ------------------------------------------------------------------
C.
      ITRTYP=0
      IF (JPART.LE.0)GO TO 99
      IF (IPART.LE.0)GO TO 99
      IF (IPART.GT.NPART)GO TO 99
      JPA = LQ(JPART- IPART)
      IF (JPA.LE.0)GO TO 99
C
      CALL UHTOC(IQ(JPA+1),4,NAPART,20)
      ITRTYP = Q(JPA + 6)
      AMASS = Q(JPA + 7)
      CHARGE = Q(JPA + 8)
      TLIFE = Q(JPA + 9)
      NWBUF = IQ(JPA-1) - 9
      IF(NWBUF.LE.0) GO TO 99
      DO 20 I=1,NWBUF
  20  UBUF(I)=Q(JPA+9+I)
C
  99  RETURN
      END
+DECK,GFTMAT
*CMZ :  3.21/02 30/05/94  14.52.42  by  S.Ravndal
*-- Author :
      SUBROUTINE GFTMAT(IMATE,IPART,CHMECA,KDIM,TKIN,VALUE,PCUT,IXST)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FETCH and INTERPOLATE the DE/DX and Cross sections       *
C.    *       tabulated in JMATE banks coresponding to  :              *
C.    *       material IMATE, particle IPART, mecanism name CHMECA,    *
C.    *       kinetic energies TKIN                                    *
C.    *                                                                *
C.    *      The CHMECAnism name can be :                              *
C.    *      'HADF'   'INEF'   'ELAF'   'FISF'   'CAPF'                *
C.    *      'HADG'   'INEG'   'ELAG'   'FISG'   'CAPG'                *
C.    *      'LOSS'   'PHOT'   'ANNI'   'COMP'   'BREM'                *
C.    *      'PAIR'   'DRAY'   'PFIS'   'RAYL'   'HADG'                *
C.    *      'MUNU'   'RANG'   'STEP'                                  *
C.    *                                                                *
C.    *       For Hadronic particles it also computes the              *
C.    *       hadronic cross section from FLUKA ( '***F' ) or          *
C.    *       GHEISHA ( '***G' ) programs:                             *
C.    *       HADF or HADG -- total                                    *
C.    *       INEF or INEG -- inelastic                                *
C.    *       ELAF or ELAG -- elastic                                  *
C.    *       FISF or FISG -- fission (0.0 for FLUKA)                  *
C.    *       CAPF or CAPG -- neutron capture (0.0 for FLUKA)          *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IMATE   Geant material number                                 *
C.    *  IPART   Geant particle number                                 *
C.    *  CHMECA   mechanism name of the bank to be fetched             *
C.    *  KDIM   dimension of the arrays TKIN , VALUE                   *
C.    *  TKIN   array of kinetic energy of incident particle (in Gev)  *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    *  VALUE  array of energy loss (in Mev/cm) ,                     *
C.    *               or stopping range (cm) ,or continuous step (cm)  *
C.    *               or macroscopic cross section (in 1/cm)           *
C.    *  PCUT(5)  array of the physical cuts in material IMATE  (Gev)  *
C.    *  IXST   flag = 1 if the array VALUE is filled ,  =0 otherwise  *
C.    *                                                                *
C.    *    ==>Called by : <USER>  GPLMAT  GRPMAT                       *
C.    *       Authors    R.Brun, M.Maire    *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCNUM.
+SEQ,GCONST.
+SEQ,GCUNIT.
+SEQ,GCMULO.
+SEQ,GSECTI.
+SEQ,GCFLAG.
+SEQ,GCTRAK.
+SEQ,GCMATE.
+SEQ,GCTMED.
+SEQ,GFKDIS.
+SEQ,GCKING.
*
      LOGICAL CERKOV
      CHARACTER*4  CHMECA
      DIMENSION TKIN(KDIM), VALUE(KDIM), PCUT(5)
+SEQ,GCNMEC
*
*     ------------------------------------------------------------------
*
      IXST = 0
      IF(KDIM.LE.0) GO TO 999
      IMECA = 0
      DO 10  KMECA=1,NMECA
         IF(CHMECA.EQ.CHNMEC(KMECA)) THEN
            IMECA = KMECA
         ENDIF
   10 CONTINUE
      IF(IMECA.EQ.0) THEN
         WRITE(CHMAIL,'('' *** GFTMAT: Mechanism '',A,                 '
     +   //'    ''not implemented'')') CHMECA
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      DO 20  IDIM=1, KDIM
         VALUE(IDIM)=0.
   20 CONTINUE
      DO 30  ICUT=1,5
         PCUT(ICUT)=0.
   30 CONTINUE
*
      IF(JMATE.LE.0) GO TO 999
      IF(IMATE.LE.0) GO TO 999
      IF(IMATE.GT.NMATE) GO TO 110
      JMA = LQ(JMATE-IMATE)
      IF(JMA.LE.0) GO TO 110
      A      =  Q(JMA+6)
      Z      =  Q(JMA+7)
      IF(Z.LT.1.) GO TO 999
      DENS   =  Q(JMA+8)
      RADL   =  Q(JMA+9)
      NLM    =  Q(JMA+11)
      JPROB  = LQ(JMA-4)
      AZRO   =  Q(JPROB+8)
      AHEFF  =  A
      IF(NLM .GT.1) THEN
         JMIXT = LQ(JMA-5)
         JMI1  = LQ(JMIXT-1)
         AHEFF =  Q(JMI1+1)
      ENDIF
*
      IF(JTMED.LE.0) GO TO 999
      IF(NTMED.LE.0) GO TO 999
      JBANK = JTMED
      DO 40 ITM = 1,NTMED
         JTM = LQ(JTMED-ITM)
         IF(JTM.LE.0) GO TO 40
         JTMN =  0
         IMAT =  Q(JTM+6)
         IF(IMAT.EQ.IMATE) THEN
            JTMN = LQ(JTM)
            IF(JTMN.NE.0) JBANK = JTMN
            GO TO 50
         ENDIF
   40 CONTINUE
   50 CALL UCOPY( Q(JBANK+6),PCUT(1),5)
      CUTHAD = Q(JBANK+ 4)
      ILOSS  = Q(JBANK+21)
      IMULS  = Q(JBANK+22)
      IFIELD = Q(JTM +  8)
      FIELDM = Q(JTM +  9)
      TMAXFD = Q(JTM + 10)
      STEMAX = Q(JTM + 11)
      DEEMAX = Q(JTM + 12)
      STMIN  = Q(JTM + 14)
*
      IF(JPART.LE.0) GO TO 999
      IF(IPART.LE.0) GO TO 999
      IF(IPART.GT.NPART) GO TO 110
      JPA = LQ(JPART-IPART)
      IF(JPA.LE.0) GO TO 110
      ITYPE  =  Q(JPA+6)
      AMASS  =  Q(JPA+7)
      CHARGE =  Q(JPA+8)
*
* *** Find the correct pointer
*
      JBANK  = 0
      ISHIF  = 0
      RMASS  = 1.
*
* *** Photons
*
      IF (ITYPE.EQ.1) THEN
         IF (CHMECA.EQ.'PHOT') JBANK = LQ(JMA- 6)
         IF (CHMECA.EQ.'COMP') JBANK = LQ(JMA- 8)
         IF (CHMECA.EQ.'PAIR') JBANK = LQ(JMA-10)
         IF (CHMECA.EQ.'PFIS') JBANK = LQ(JMA-12)
         IF (CHMECA.EQ.'RAYL') JBANK = LQ(JMA-13)
*
* *** Electrons / positons
*
      ELSE IF (ITYPE.EQ.2) THEN
         IF (CHMECA.EQ.'LOSS') THEN
            JBANK = LQ(JMA- 1)
            IF (CHARGE.GT.0.) ISHIF = NEK1
         ELSE IF (CHMECA.EQ.'RANG') THEN
            JBANK = LQ(JMA- 15)
            IF (CHARGE.GT.0.) ISHIF = NEK1
         ELSE IF (CHMECA.EQ.'STEP') THEN
            JBANK = LQ(JTM- 1)
         ELSE IF ((CHMECA.EQ.'ANNI').AND.(CHARGE.GT.0.)) THEN
            JBANK = LQ(JMA- 7)
         ELSE IF (CHMECA.EQ.'BREM') THEN
            JBANK = LQ(JMA- 9)
         ELSE IF (CHMECA.EQ.'DRAY') THEN
            JBANK = LQ(JMA-11)
            IF (CHARGE.GT.0.) ISHIF = NEK1
         ENDIF
*
* *** Neutral hadrons (***F for FLUKA cross sections
*                      ***G for GHEISHA cross sections
*                      LOWN and N*** for MICAP cross sections)
*
      ELSE IF (ITYPE.EQ.3) THEN
         IF((CHMECA.EQ.'HADF').OR.(CHMECA.EQ.'INEF')
     +   .OR.(CHMECA.EQ.'ELAF') .OR.(CHMECA.EQ.'FISF')
     +   .OR.(CHMECA.EQ.'CAPF')) THEN
            JBANK = -3
            IF (IFINIT(5) .EQ. 0) CALL FLINIT
         ELSE IF((CHMECA.EQ.'HADG').OR.(CHMECA.EQ.'INEG')
     +   .OR.(CHMECA.EQ. 'ELAG').OR.(CHMECA.EQ.'FISG')
     +   .OR.(CHMECA.EQ.'CAPG')) THEN
            JBANK = -4
            CALL GHEINI
         ELSE IF(IMECA.GE.IBLOWN.AND.IPART.EQ.13) THEN
            IF (IFINIT(7) .EQ. 0) CALL GMORIN
            JBANK = -5
         ENDIF
         K0OLD = K0FLAG
*
* *** Charged hadrons (***F for FLUKA cross sections
*                      ***G for GHEISHA cross sections)
* *** Heavy ions
*
      ELSE IF (ITYPE.EQ.4.OR.ITYPE.EQ.8) THEN
         RMASS = PMASS/AMASS
         IF (CHMECA.EQ.'LOSS') THEN
            JBANK = LQ(JMA- 3)
         ELSE IF (CHMECA.EQ.'RANG') THEN
            JBANK = LQ(JMA- 16) + NEK1
         ELSE IF (CHMECA.EQ.'STEP') THEN
            JBANK = -1
            JRANG = LQ(JMA -16) + NEK1
            CUTPRO = CUTHAD*RMASS
            CUTPRO = MAX(ELOW(1), MIN( CUTPRO, ELOW(NEK1)*0.99))
            IKCUT  = GEKA*LOG10(CUTPRO) + GEKB
            GKC = (CUTPRO - ELOW(IKCUT))/(ELOW(IKCUT+1) - ELOW(IKCUT))
            STOPC = (1.-GKC)*Q(JRANG+IKCUT) + GKC*Q(JRANG+IKCUT+1)
         ELSE IF (CHMECA.EQ.'DRAY') THEN
            JBANK = -2
            JPROB = LQ(JMA-4)
            AZRO  =  Q(JPROB+17)
            DCUTM =  PCUT(4)
         ELSE IF(((CHMECA.EQ.'HADF').OR.(CHMECA.EQ.'INEF')
     +   .OR.(CHMECA.EQ. 'ELAF').OR.(CHMECA.EQ.'FISF')
     +   .OR.(CHMECA.EQ.'CAPF')).AND.ITYPE.NE.8) THEN
            JBANK = -3
            IF (IFINIT(5) .EQ. 0) CALL FLINIT
         ELSE IF(((CHMECA.EQ.'HADG').OR.(CHMECA.EQ.'INEG')
     +   .OR.(CHMECA.EQ. 'ELAG').OR.(CHMECA.EQ.'FISG')
     +   .OR.(CHMECA.EQ.'CAPG')).AND.ITYPE.NE.8) THEN
            JBANK = -4
            CALL GHEINI
         ENDIF
         K0OLD = K0FLAG
*
* *** Muons
*
      ELSE IF (ITYPE.EQ.5) THEN
         IF (CHMECA.EQ.'LOSS') THEN
            JBANK = LQ(JMA- 2)
         ELSE IF (CHMECA.EQ.'RANG') THEN
            JBANK = LQ(JMA- 16)
         ELSE IF (CHMECA.EQ.'STEP') THEN
            JBANK = LQ(JTM- 2)
         ELSE IF (CHMECA.EQ.'MUNU') THEN
            JBANK = LQ(JMA- 14)
         ELSE IF (CHMECA.EQ.'BREM') THEN
            JBANK = LQ(JMA- 9)
            ISHIF = 2*NEK1
         ELSE IF (CHMECA.EQ.'PAIR') THEN
            JBANK = LQ(JMA- 10)
            ISHIF = NEK1
         ELSE IF (CHMECA.EQ.'DRAY') THEN
            JBANK = LQ(JMA-11)
            ISHIF = 2*NEK1
         ENDIF
*
* *** Geantinos
*
      ELSEIF (ITYPE.EQ.6) THEN
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
         JBANK = 0
*
* *** Cerenkov
*
      ELSEIF (ITYPE.EQ.7) THEN
         IF (CHMECA.EQ.'LABS') THEN
*
* *** Not implemented yet!
            JBANK=0
         ENDIF
*
      ENDIF
      CERKOV=.FALSE.
      IF(CHARGE.NE.0.AND.ITCKOV.NE.0) THEN
         IF(IQ(JTM-2).GE.3) THEN
            IF(LQ(JTM-3).NE.0.AND.LQ(LQ(JTM-3)-3).NE.0) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag and calculate the
* ***  relevant pointers.
*
               CERKOV = .TRUE.
               JTCKOV = LQ(JTM-3)
               JABSCO = LQ(JTCKOV-1)
               JEFFIC = LQ(JTCKOV-2)
               JINDEX = LQ(JTCKOV-3)
               JCURIN = LQ(JTCKOV-4)
               NPCKOV = Q(JTCKOV+1)
            ENDIF
         ENDIF
      ENDIF
 
      IF(JBANK.EQ.0) GO TO 999
      IXST = 1
*
*
      JBANK = JBANK + ISHIF
      DO 100 IKB = 1,KDIM
*        Find bin number in table JMATE
         EKP = TKIN(IKB)*RMASS
         EKP = MAX(ELOW(1), MIN( EKP, ELOW(NEK1)*0.99))
         IKP=GEKA*LOG10(EKP)+GEKB +0.001
         GKRA=(EKP-ELOW(IKP))/(ELOW(IKP+1)-ELOW(IKP))
*
         IF(JBANK.GT.0) THEN
*           Retieve value from bank JMATE
            VALUE(IKB) =  (1.-GKRA)*Q(JBANK+IKP) + GKRA*Q(JBANK+IKP+1)
            IF ((CHMECA.EQ.'PHOT').AND.(EKP.GE.0.05 )) VALUE(IKB) =
     +      BIG
            IF ((CHMECA.EQ.'MUNU').AND.(EKP.LT.0.05 )) VALUE(IKB) =
     +      BIG
            IF ( CHMECA.EQ.'LOSS') THEN
               VALUE(IKB) = VALUE(IKB)*CHARGE**2*1.E+3
            ELSE IF (CHMECA.EQ.'RANG') THEN
               VALUE(IKB) = VALUE(IKB)/(RMASS*CHARGE*CHARGE)
            ELSE IF (CHMECA.NE.'STEP') THEN
               IF (VALUE(IKB).GT.0.) THEN
                  VALUE(IKB) = 1./VALUE(IKB)
               ELSE
                  VALUE(IKB) = 1./BIG
               ENDIF
            ENDIF
*
         ELSEIF (JBANK.EQ.-1) THEN
*           Compute step due to muls + loss + field
            GEKIN=TKIN(IKB)
            GETOT=GEKIN+AMASS
            PMOM =SQRT(GEKIN*(GETOT+AMASS))
            SFIELD = BIG
            SMULS  = BIG
            SLOSS  = BIG
            STOPMX = BIG
            IF (IFIELD*FIELDM.NE.0.)
     +         SFIELD = 3333.*DEGRAD*TMAXFD*PMOM/ABS(FIELDM*CHARGE)
            IF (IMULS.GT.0.)
     +         SMULS = MIN (2232.*RADL*((PMOM**2)/(GETOT*CHARGE))**2 ,
     +                      10.*RADL )
            IF (ILOSS*DEEMAX.GT.0.) THEN
               STOPP  = (1.-GKRA)*Q(JRANG+IKP) + GKRA*Q(JRANG+IKP+1)
               STOPMX = (STOPP - STOPC)/(RMASS*CHARGE*CHARGE)
               IF (STOPMX.LT.0.) STOPMX = 0.
               EKF = MAX ( ELOW(1) , (1.-DEEMAX)*EKP )
               IKF = GEKA*LOG10(EKF) + GEKB
               GKF = (EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
               SLOSP= STOPP - (1.-GKF)*Q(JRANG+IKF) - GKF*Q(JRANG+IKF+1)
               SLOSS = SLOSP/(RMASS*CHARGE*CHARGE)
            ENDIF
            IF(CERKOV) THEN
               VECT(7)=SQRT(TKIN(IKB)*(TKIN(IKB)+2*AMASS))
               CALL GNCKOV
               STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
            ELSE
               STCKOV=BIG
            ENDIF
*
            IF (STOPMX.LE.STMIN) THEN
               VALUE(IKB) = STOPMX
            ELSE
               VALUE(IKB) = MAX(STMIN,MIN(STCKOV,SLOSS,SFIELD,SMULS,
     +         STEMAX))
            ENDIF
*
         ELSEIF (JBANK.EQ.-2) THEN
*           Compute delta ray cross section for hadrons
            GEKIN=TKIN(IKB)
            GETOT=GEKIN+AMASS
            GAMASS=GETOT+AMASS
            BET2=GEKIN*GAMASS/(GETOT*GETOT)
            TMAX=EMASS*GEKIN*GAMASS/(0.5*AMASS*AMASS+EMASS*GETOT)
            IF(TMAX.GT.DCUTM)THEN
               Y=DCUTM/TMAX
               SIG=(1.-Y+BET2*Y*LOG(Y))/DCUTM
               IF(AMASS.GT.0.9)SIG=SIG+0.5*(TMAX-DCUTM)/(GETOT*GETOT)
               VALUE(IKB)=SIG*AZRO*CHARGE*CHARGE*EMASS/BET2
            ELSE
               VALUE(IKB)=1./BIG
            ENDIF
*
*           compute hadronic cross section from FLUKA code
*
         ELSEIF (JBANK.EQ.-3) THEN
            GEKIN=TKIN(IKB)
            PMOM = SQRT(GEKIN*(GEKIN+2*AMASS))
            NMAT = IMATE
            VECT(7) = PMOM
            CALL FLDIST
            IF (CHMECA.EQ.'HADF') VALUE(IKB)= FSIG
            IF (CHMECA.EQ.'INEF') VALUE(IKB)= SINE
            IF (CHMECA.EQ.'ELAF') VALUE(IKB)= SELA
            IF (CHMECA.EQ.'FISF') VALUE(IKB)= 0.0
            IF (CHMECA.EQ.'CAPF') VALUE(IKB)= 0.0
*
*           compute hadronic cross section from GHEISHA code
*
         ELSEIF (JBANK.EQ.-4) THEN
            GEKIN=TKIN(IKB)
            PMOM = SQRT(GEKIN*(GEKIN+2*AMASS))
            K0FLAG = 1
*           (compounds)
            IF(NLM.GT.1) THEN
               HHHH=0.
               IF (JTMN.GT.0) HHHH=Q(JTMN+26)
               VALUE(IKB)=GHESIG(PMOM,GEKIN,A,Q(JMIXT+1), Q(JMIXT+NLM+
     +         1),Q(JMIXT+2*NLM+1),NLM,DENS,HHHH,IPART)
               IF (CHMECA .EQ. 'INEG') THEN
                  VALUE(IKB) = 0.
                  DO 60 K=1,NLM
                     VALUE(IKB) = AIIN(K) + VALUE(IKB)
   60             CONTINUE
               ELSE IF (CHMECA .EQ. 'ELAG') THEN
                  VALUE(IKB) = 0.
                  DO 70 K=1,NLM
                     VALUE(IKB) = AIEL(K) + VALUE(IKB)
   70             CONTINUE
               ELSE IF (CHMECA .EQ. 'FISG') THEN
                  VALUE(IKB) = 0.
                  DO 80 K=1,NLM
                     VALUE(IKB) = AIFI(K) + VALUE(IKB)
   80             CONTINUE
               ELSE IF (CHMECA .EQ. 'CAPG') THEN
                  VALUE(IKB) = 0.
                  DO 90 K=1,NLM
                     VALUE(IKB) = AICA(K) + VALUE(IKB)
   90             CONTINUE
               ENDIF
            ELSE
*           (simple elements)
               VALUE(IKB)=GHESIG(PMOM,GEKIN,A,A,Z,1.,1,DENS,0.,IPART)
               IF (CHMECA .EQ. 'INEG') VALUE(IKB) = AIIN(1)
               IF (CHMECA .EQ. 'ELAG') VALUE(IKB) = AIEL(1)
               IF (CHMECA .EQ. 'FISG') VALUE(IKB) = AIFI(1)
               IF (CHMECA .EQ. 'CAPG') VALUE(IKB) = AICA(1)
            END IF
            K0FLAG = K0OLD
*
*           compute the cross-section for low-energy neutrons
*           from MICAP code
*
         ELSEIF (JBANK.EQ.-5) THEN
            GEKIN=TKIN(IKB)
            IF (GEKIN.LE..02) THEN
               IF (CHMECA .EQ. 'LOWN') THEN
                  VALUE(IKB) = SIGMOR(GEKIN*1.E+9,IMATE)
               ELSE
                  NMAT = IMATE
                  CALL GMXSEC (IMECA,VALUE(IKB))
               ENDIF
            ELSE
               VALUE(IKB) = 0.
            ENDIF
*
         ENDIF
  100 CONTINUE
*
      GO TO 999
  110 WRITE(CHMAIL,10100) IMATE ,IPART
      CALL GMAIL(0,0)
*
10000 FORMAT(' ***** GFTMAT: No processes active for geantinos')
10100 FORMAT(' ***** GFTMAT error : material',I4,
     +       '  or particle',I4,' not defined'   )
  999 CONTINUE
      END
+DECK,GFTMED
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GFTMED(NUMED,NATMED,NMAT,ISVOL,IFIELD,FIELDM,
     +           TMAXFD,STEMAX,DEEMAX,EPSIL,STMIN,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Return parameters for tracking medium NUMED              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GTRACK                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
      CHARACTER*20 NATMED
      DIMENSION UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      NMAT=0
      IF (JTMED.LE.0)GO TO 99
      IF (NUMED.LE.0)GO TO 99
      IF (NUMED.GT.NTMED)GO TO 99
      JTM = LQ(JTMED- NUMED)
      IF (JTM.LE.0)GO TO 99
C
      CALL UHTOC(IQ(JTM+1),4,NATMED,20)
      NMAT = Q(JTM + 6)
      ISVOL = Q(JTM + 7)
      IFIELD = Q(JTM + 8)
      FIELDM = Q(JTM + 9)
      TMAXFD = Q(JTM + 10)
      STEMAX = Q(JTM + 11)
      DEEMAX = Q(JTM + 12)
      EPSIL = Q(JTM + 13)
      STMIN = Q(JTM + 14)
      NWBUF = IQ(JTM-1) - 14
      IF(NWBUF.LE.0) GO TO 99
      DO 20 I=1,NWBUF
  20  UBUF(I)=Q(JTM+14+I)
C
  99  RETURN
      END
+DECK,GMATE
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GMATE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Define standard GEANT materials                               *
C.    *                                                                *
C.    *  All data EXCEPT for nuclear absorption lengths taken from :   *
C.    *                        M. Aguilar-Benitez et al,               *
C.    *                        Rev. of Particle Properties,            *
C.    *                        Rev. Mod. Phys. 56(1984)                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION UBUF(1)
      DATA UBUF/0./
C
      CALL GSMATE( 1,'HYDROGEN$ ',  1.01, 1.,0.0708,865.,790.,UBUF,0)
      CALL GSMATE( 2,'DEUTERIUM$',  2.01, 1.,0.162 ,757.,342.,UBUF,0)
      CALL GSMATE( 3,'HELIUM$   ',  4.  , 2.,0.125 ,755.,478.,UBUF,0)
      CALL GSMATE( 4,'LITHIUM$  ',  6.94, 3.,0.534 ,155.,120.6,UBUF,0)
      CALL GSMATE( 5,'BERILLIUM$',  9.01, 4.,1.848 ,35.3,36.7,UBUF,0)
      CALL GSMATE( 6,'CARBON$   ', 12.01, 6.,2.265 ,18.8,49.9,UBUF,0)
      CALL GSMATE( 7,'NITROGEN$ ', 14.01, 7.,0.808 ,44.5,99.4,UBUF,0)
      CALL GSMATE( 8,'NEON$     ', 20.18,10.,1.207 , 24.,74.9,UBUF,0)
      CALL GSMATE( 9,'ALUMINIUM$', 26.98,13.,2.7   , 8.9,37.2,UBUF,0)
      CALL GSMATE(10,'IRON$     ', 55.85,26.,7.87  ,1.76,17.1,UBUF,0)
      CALL GSMATE(11,'COPPER$   ', 63.54,29.,8.96  ,1.43,14.8,UBUF,0)
      CALL GSMATE(12,'TUNGSTEN$ ',183.85,74.,19.3  ,0.35,10.3,UBUF,0)
      CALL GSMATE(13,'LEAD$     ',207.19,82.,11.35 ,0.56,18.5,UBUF,0)
      CALL GSMATE(14,'URANIUM$  ',238.03,92.,18.95 ,0.32,12. ,UBUF,0)
      CALL GSMATE(15,'AIR$      ',14.61,7.3,0.001205,30423.24,67500.
     +                           ,UBUF,0)
      CALL GSMATE(16,'VACUUM$ ',1.E-16,1.E-16,1.E-16,1.E+16,1.E+16
     +                           ,UBUF,0)
C
      END
+DECK,GPART
*CMZ :  3.21/03 14/09/94  14.33.42  by  S.Ravndal
*-- Author :
      SUBROUTINE GPART
C.
C.    *******************************************************************
C.    *                                                                 *
C.    *  Define standard GEANT particles plus selected decay modes      *
C.    *  and branching ratios.                                          *
C.    *                                                                 *
C.    *  All data taken from : M. AGUILAR-BENITEZ et al,                *
C.    *                        Review of Particle Properties,           *
C.    *                        Rev. Mod. Phys. 56(1984).                *
C.    *                                                                 *
C.    *  Updated to:           Phys.Rev. D50,1173(1994)                 *
C.    *                        S. Ravndal                               *
C.    *                                                                 *
C.    *                                                                 *
C.    *  In the case of W and Z, the lifetimes are calculated from      *
C.    *  quoted upper limits on widths.                                 *
C.    *                                                                 *
C.    *  NPAR           Number of parent particles defined for decay.   *
C.    *  IPAR           List of parent partilces allowed to decay.      *
C.    *                 Currently set up for pi0,pi+,pi-,K0long,K+,K-,  *
C.    *                 K0short,eta,lambda,sigma+,sigma0,sigma-,xi0,    *
C.    *                 xi-,omega-,antilambda,antisigma -,antisigma 0,  *
C.    *                 antisigma +,antixi 0,antixi +,antiomega +       *
C.    *                 decays.                                         *
C.    *  MODE(I,J)      I'th decay mode of J'th particle defined in     *
C.    *                 IPAR.                                           *
C.    *  BRATIO(I,J)    Branching ratio for I'th decay mode of J'th     *
C.    *                 particle in IPAR.                               *
C.    *                                                                 *
C.    *    ==>Called by : <USER>, UGINIT                                *
C.    *       Author    G.Patrick  *********                            *
C.    *                                                                 *
C.    *******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCONSP
C
      DIMENSION BRATIO(6,24),BRTIO1(6,20),BRTIO2(6,4)
      DIMENSION IPAR(24)
      DIMENSION MODE(6,24),MODE1(6,20),MODE2(6,4)
      DIMENSION UBUF(1)
C
      EQUIVALENCE(BRTIO1(1,1),BRATIO(1,1)),(BRTIO2(1,1),BRATIO(1,21))
      EQUIVALENCE(MODE1(1,1),MODE(1,1)),(MODE2(1,1),MODE(1,21))
C
      DATA IPAR/ 7, 8, 9,10,11,12,16,17,18,19,20,21,22,23,24,26,27,
     *          28,29,30,31,32,5,6/
      DATA BRTIO1/ 98.802, 1.198, 0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *             21.60, 19.35, 19.35, 13.50, 13.50, 12.38,
     *             63.51, 21.17,  5.59,  4.82,  3.18,  1.73,
     *             63.51, 21.17,  5.59,  4.82,  3.18,  1.73,
     *             68.61, 31.39,  0.,    0.,    0.,    0.,
     *             38.80, 31.90, 23.6,   4.88,  0.5,   0.071,
     *             63.90, 35.80,  0.,    0.,    0.,    0.,
     *             51.57, 48.30,  0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *             67.80, 23.60,  8.60,  0.,    0.,    0.,
     *             63.90, 35.80,  0.,    0.,    0.,    0.,
     *             51.57, 48.30,  0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0./
      DATA BRTIO2/100.00,  0.,    0.,    0.,    0.,    0.,
     *             67.80, 23.60,  8.60,  0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0./
      DATA MODE1/  101,30201,    0,    0,    0,    0,
     *             405,    0,    0,    0,    0,    0,
     *             406,    0,    0,    0,    0,    0,
     *             70707,40308,40209,40608,40509,70908,
     *             405,  708,90808,70402,70405,70708,
     *             406,  709,80909,70403,70406,70709,
     *             908,  707,    0,    0,    0,    0,
     *             101,70707,70908,10908,10302,10107,
     *             914,  713,    0,    0,    0,    0,
     *             714,  813,    0,    0,    0,    0,
     *             118,    0,    0,    0,    0,    0,
     *             913,    0,    0,    0,    0,    0,
     *             718,    0,    0,    0,    0,    0,
     *             918,    0,    0,    0,    0,    0,
     *            1218,  922,  723,    0,    0,    0,
     *             815,  725,    0,    0,    0,    0,
     *             715,  925,    0,    0,    0,    0,
     *             126,    0,    0,    0,    0,    0,
     *             825,    0,    0,    0,    0,    0,
     *             726,    0,    0,    0,    0,    0/
      DATA MODE2/  826,    0,    0,    0,    0,    0,
     *            1126,  830,  731,    0,    0,    0,
     *           40402,    0,    0,    0,    0,    0,
     *           40403,    0,    0,    0,    0,    0/
      DATA NPAR/24/
      DATA UBUF/0./
C.
C.    -------------------------------------------------------------------
C.
      REMASS=EMASS
      REMMU =EMMU
      RPMASS=PMASS
      CALL GSPART( 1,'GAMMA$      ',1,0.      , 0.,1.E+15,UBUF,0)
      CALL GSPART( 2,'POSITRON$   ',2,REMASS  , 1.,1.E+15,UBUF,0)
      CALL GSPART( 3,'ELECTRON$   ',2,REMASS  ,-1.,1.E+15,UBUF,0)
      CALL GSPART( 4,'NEUTRINO$   ',3,0.      , 0.,1.E+15,UBUF,0)
      CALL GSPART( 5,'MUON +$     ',5,REMMU   , 1.,2.19703E-06,UBUF,0)
      CALL GSPART( 6,'MUON -$     ',5,REMMU   ,-1.,2.19703E-06,UBUF,0)
      CALL GSPART( 7,'PION 0$     ',3,0.1349764,0.,0.84E-16,UBUF,0)
      CALL GSPART( 8,'PION +$     ',4,0.1395700, 1.,2.603E-08,UBUF,0)
      CALL GSPART( 9,'PION -$     ',4,0.1395700,-1.,2.603E-08,UBUF,0)
      CALL GSPART(10,'KAON 0 LONG$',3,0.497672, 0.,5.17E-08,UBUF,0)
      CALL GSPART(11,'KAON +$     ',4,0.493677, 1.,1.237E-08,UBUF,0)
      CALL GSPART(12,'KAON -$     ',4,0.493677,-1.,1.237E-08,UBUF,0)
      CALL GSPART(13,'NEUTRON$    ',3,0.93956563, 0.,8.870E+02,UBUF,0)
      CALL GSPART(14,'PROTON$     ',4,RPMASS  , 1.,1.000000E+15,UBUF,0)
      CALL GSPART(15,'ANTIPROTON$ ',4,RPMASS  ,-1.,1.000000E+15,UBUF,0)
      CALL GSPART(16,'KAON 0 SHORT$',3,0.497672, 0.,8.926E-11,UBUF,0)
      CALL GSPART(17,'ETA$        ',3,0.54745 , 0.,5.485E-19,UBUF,0)
      CALL GSPART(18,'LAMBDA$     ',3,1.115684, 0.,2.632E-10,UBUF,0)
      CALL GSPART(19,'SIGMA +$    ',4,1.18937 , 1.,0.799E-10,UBUF,0)
      CALL GSPART(20,'SIGMA 0$    ',3,1.19255 , 0.,7.4E-20,UBUF,0)
      CALL GSPART(21,'SIGMA -$    ',4,1.197436,-1.,1.479E-10,UBUF,0)
      CALL GSPART(22,'XI 0$       ',3,1.3149  , 0.,2.9E-10,UBUF,0)
      CALL GSPART(23,'XI -$       ',4,1.32132 ,-1.,1.639E-10,UBUF,0)
      CALL GSPART(24,'OMEGA -$    ',4,1.67245 ,-1.,0.822E-10,UBUF,0)
      CALL GSPART(25,'ANTINEUTRON$',3,0.93956563, 0.,8.870E+02,UBUF,0)
      CALL GSPART(26,'ANTILAMBDA$ ',3,1.115684, 0.,2.632E-10,UBUF,0)
      CALL GSPART(27,'ANTISIGMA -$',4,1.18937 ,-1.,0.799E-10,UBUF,0)
      CALL GSPART(28,'ANTISIGMA 0$',3,1.19255 , 0.,7.4E-20,UBUF,0)
      CALL GSPART(29,'ANTISIGMA +$',4,1.197436, 1.,1.479E-10,UBUF,0)
      CALL GSPART(30,'ANTIXI 0$   ',3,1.3149  , 0.,2.9E-10,UBUF,0)
      CALL GSPART(31,'ANTIXI +$   ',4,1.32132 , 1.,1.639E-10,UBUF,0)
      CALL GSPART(32,'ANTIOMEGA +$',4,1.67245 , 1.,0.822E-10,UBUF,0)
*     CALL GSPART(33,'TAU +$      ',4,1.7771  , 1.,3.040000E-13,UBUF,0)
*     CALL GSPART(34,'TAU -$      ',4,1.7771  ,-1.,3.040000E-13,UBUF,0)
*     CALL GSPART(35,'D +$        ',4,1.8694  , 1.,1.062000E-12,UBUF,0)
*     CALL GSPART(36,'D -$        ',4,1.8694  ,-1.,1.062000E-12,UBUF,0)
*     CALL GSPART(37,'D 0$        ',3,1.8646  , 0.,4.280000E-13,UBUF,0)
*     CALL GSPART(38,'ANTI D 0$   ',3,1.8646  , 0.,4.280000E-13,UBUF,0)
*     CALL GSPART(39,'DS+$        ',4,1.9685  , 1.,4.360000E-13,UBUF,0)
*     CALL GSPART(40,'DS-$        ',4,1.9685  ,-1.,4.360000E-13,UBUF,0)
*     CALL GSPART(41,'LAMBDA C +$ ',4,2.2851  , 1.,1.790000E-13,UBUF,0)
*     CALL GSPART(42,'W +$        ',4,80.220  , 1.,3.160000E-25,UBUF,0)
*     CALL GSPART(43,'W -$        ',4,80.220  ,-1.,2.640000E-25,UBUF,0)
*     CALL GSPART(44,'Z 0$        ',3,91.187  , 0.,7.740000E-26,UBUF,0)
      CALL GSPART(45,'DEUTERON$   ',8,1.875613,+1.,1.000000E+15,UBUF,0)
      CALL GSPART(46,'TRITON$     ',8,2.80925 ,+1.,1.000000E+15,UBUF,0)
      CALL GSPART(47,'ALPHA$      ',8,3.727417,+2.,1.000000E+15,UBUF,0)
      CALL GSPART(48,'GEANTINO$   ',6,0.      , 0.,1.000000E+15,UBUF,0)
      CALL GSPART(49,'HE3$        ',8,2.80923 ,+2.,1.000000E+15,UBUF,0)
      CALL GSPART(50,'Cerenkov$   ',7,0.      , 0.,1.000000E+15,UBUF,0)
C
C     Define decay modes.
C
      DO 10 I=1,NPAR
      CALL GSDK(IPAR(I),BRATIO(1,I),MODE(1,I))
   10 CONTINUE
C
  99  RETURN
      END
+DECK,GPIONS.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPIONS
C.
C.    *******************************************************************
C.    *                                                                 *
C.    *  Define a subset of the 'stable' most common elements           *
C.    *    in the Nature                                                *
C.    *                                                                 *
C.    *    ==>Called by : <USER>, UGINIT                                *
C.    *       Author    B.Grosdidier (Strasbourg) *****                 *
C.    *                                                                 *
C.    *******************************************************************
C.
      DIMENSION UBUF(1)
      DATA UBUF/0./
*
*     The Geant particle identification begin to IPART = 61
      CALL GSPART( 61,'LI6  ',8,   5.60305,  3., 1000., UBUF,0)
      CALL GSPART( 62,'LI7  ',8,   6.53536,  3., 1000., UBUF,0)
      CALL GSPART( 63,'BE7  ',8,   6.53622,  4., 1000., UBUF,0)
      CALL GSPART( 64,'BE9  ',8,   8.39479,  4., 1000., UBUF,0)
      CALL GSPART( 65,'B10  ',8,   9.32699,  5., 1000., UBUF,0)
      CALL GSPART( 66,'B11  ',8,  10.25510,  5., 1000., UBUF,0)
      CALL GSPART( 67,'C12  ',8,  11.17793,  6., 1000., UBUF,0)
      CALL GSPART( 68,'N14  ',8,  13.04378,  7., 1000., UBUF,0)
      CALL GSPART( 69,'O16  ',8,  14.89917,  8., 1000., UBUF,0)
      CALL GSPART( 70,'F19  ',8,  17.69690,  9., 1000., UBUF,0)
      CALL GSPART( 71,'NE20 ',8,  18.62284, 10., 1000., UBUF,0)
      CALL GSPART( 72,'NA23 ',8,  21.41483, 11., 1000., UBUF,0)
      CALL GSPART( 73,'MG24 ',8,  22.34193, 12., 1000., UBUF,0)
      CALL GSPART( 74,'AL27 ',8,  25.13314, 13., 1000., UBUF,0)
      CALL GSPART( 75,'SI28 ',8,  26.06034, 14., 1000., UBUF,0)
      CALL GSPART( 76,'P31  ',8,  28.85188, 15., 1000., UBUF,0)
      CALL GSPART( 77,'S32  ',8,  29.78180, 16., 1000., UBUF,0)
      CALL GSPART( 78,'CL35 ',8,  32.57328, 17., 1000., UBUF,0)
      CALL GSPART( 79,'AR36 ',8,  33.50356, 18., 1000., UBUF,0)
      CALL GSPART( 80,'K39  ',8,  36.29447, 19., 1000., UBUF,0)
      CALL GSPART( 81,'CA40 ',8,  37.22492, 20., 1000., UBUF,0)
      CALL GSPART( 82,'SC45 ',8,  41.87617, 21., 1000., UBUF,0)
      CALL GSPART( 83,'TI48 ',8,  44.66324, 22., 1000., UBUF,0)
      CALL GSPART( 84,'V51  ',8,  47.45401, 23., 1000., UBUF,0)
      CALL GSPART( 85,'CR52 ',8,  48.38228, 24., 1000., UBUF,0)
      CALL GSPART( 86,'MN55 ',8,  51.17447, 25., 1000., UBUF,0)
      CALL GSPART( 87,'FE56 ',8,  52.10307, 26., 1000., UBUF,0)
      CALL GSPART( 88,'CO59 ',8,  54.89593, 27., 1000., UBUF,0)
      CALL GSPART( 89,'NI58 ',8,  53.96644, 28., 1000., UBUF,0)
      CALL GSPART( 90,'CU63 ',8,  58.61856, 29., 1000., UBUF,0)
      CALL GSPART( 91,'ZN64 ',8,  59.54963, 30., 1000., UBUF,0)
      CALL GSPART( 92,'GE74 ',8,  68.85715, 32., 1000., UBUF,0)
      CALL GSPART( 93,'SE80 ',8,  74.44178, 34., 1000., UBUF,0)
      CALL GSPART( 94,'KR84 ',8,  78.16309, 36., 1000., UBUF,0)
      CALL GSPART( 95,'SR88 ',8,  81.88358, 38., 1000., UBUF,0)
      CALL GSPART( 96,'ZR90 ',8,  83.74571, 40., 1000., UBUF,0)
      CALL GSPART( 97,'MO98 ',8,  91.19832, 42., 1000., UBUF,0)
      CALL GSPART( 98,'PD106',8,  98.64997, 46., 1000., UBUF,0)
      CALL GSPART( 99,'CD114',8, 106.10997, 48., 1000., UBUF,0)
      CALL GSPART(100,'SN120',8, 111.68821, 50., 1000., UBUF,0)
      CALL GSPART(101,'XE132',8, 122.86796, 54., 1000., UBUF,0)
      CALL GSPART(102,'BA138',8, 128.45793, 56., 1000., UBUF,0)
      CALL GSPART(103,'CE140',8, 130.32111, 58., 1000., UBUF,0)
      CALL GSPART(104,'SM152',8, 141.51236, 62., 1000., UBUF,0)
      CALL GSPART(105,'DY164',8, 152.69909, 66., 1000., UBUF,0)
      CALL GSPART(106,'YB174',8, 162.02245, 70., 1000., UBUF,0)
      CALL GSPART(107,'W184 ',8, 171.34924, 74., 1000., UBUF,0)
      CALL GSPART(108,'PT194',8, 180.67513, 78., 1000., UBUF,0)
      CALL GSPART(109,'AU197',8, 183.47324, 79., 1000., UBUF,0)
      CALL GSPART(110,'HG202',8, 188.13451, 80., 1000., UBUF,0)
      CALL GSPART(111,'PB208',8, 193.72907, 82., 1000., UBUF,0)
      CALL GSPART(112,'U238 ',8, 221.74295, 92., 1000., UBUF,0)
*
      END
+DECK,GPLMAT.
*CMZ :  3.21/03 10/10/94  14.26.28  by  S.Ravndal
*-- Author :
      SUBROUTINE GPLMAT(IMATES,IPART,MECAN,KDIN,TKIN,IDM)
C.
C     ******************************************************************
C.    *                                                                *
C.    *       INTERPOLATE and PLOT  the DE/DX and Cross sections       *
C.    *       tabulated in JMATE banks corresponding to :              *
C.    *       material IMATE, particle IPART, mecanism name HMECAN,    *
C.    *       kinetic energies TKIN                                    *
C.    *                                                                *
C.    *      The MECANism name can be :                                *
C.    *      'HADF'   'INEF'   'ELAF'   'FISF'   'CAPF'                *
C.    *      'HADG'   'INEG'   'ELAG'   'FISG'   'CAPG'                *
C.    *      'LOSS'   'PHOT'   'ANNI'   'COMP'   'BREM'                *
C.    *      'PAIR'   'DRAY'   'PFIS'   'RAYL'   'HADG'                *
C.    *      'MUNU'   'RANG'   'STEP'                                  *
C.    *                                                                *
C.    *       For Hadronic particles it also computes the              *
C.    *       hadronic cross section from FLUKA ( '***F' ) or          *
C.    *       GHEISHA ( '***G' ) programs:                             *
C.    *       HADF or HADG -- total                                    *
C.    *       INEF or INEG -- inelastic                                *
C.    *       ELAF or ELAG -- elastic                                  *
C.    *       FISF or FISG -- fission (0.0 for FLUKA)                  *
C.    *       CAPF or CAPG -- neutron capture (0.0 for FLUKA)          *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IMATE   Geant material number                                 *
C.    *  IPART   Geant particle number                                 *
C.    *  MECAN  mechanism name of the bank to be fetched               *
C.    *  KDIM   dimension of the arrays TKIN , VALUE                   *
C.    *  TKIN   array of kinetic energy of incident particle (in Gev)  *
C.    *  IDM    convention for histogramming mode :                    *
C.    *         IDM.gt.0  fill , print , keep histogram(s)             *
C.    *         IDM.eq.0  fill , print , delete histogram(s)           *
C.    *         IDM.lt.0  fill , noprint , keep histogram(s)           *
C.    *           The histogram IDentificator will be :                *
C.    *             10000*imate + 100*ipart + imeca                    *
C.    *          where IMECA is the link number in stucture JMATE      *
C.    *          (see Geant3 writeup CONS 199)                         *
C.    *           for 'HADG'  imeca = 17                               *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    R.Brun, M.Maire    *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCNUM.
+SEQ,GCONSP.
+SEQ,GCUNIT.
+SEQ,GCPHYS.
      PARAMETER (MMX= 201,NCOL= 5)
      CHARACTER*(*) MECAN
      CHARACTER*4 MECA , KU(NCOL)
      CHARACTER   NAPART*16 , NAMATE*16 , CHTITL*68
      DIMENSION   TKIN(KDIN),VALUE(MMX),SIGT(MMX),PCUT(5)
      DIMENSION   KI(NCOL),EK(NCOL)
      LOGICAL     LXBARN
*
+SEQ,GCNMEC
*
*     ------------------------------------------------------------------
*
      IF (KDIN.LE.0)  GO TO 999
      KDIM = MIN(KDIN,MMX)
      IF(IMATES.LT.0) THEN
         LXBARN=.TRUE.
      ELSEIF(IMATES.GT.0) THEN
         LXBARN=.FALSE.
      ELSE
         GOTO 999
      ENDIF
      IMATE=ABS(IMATES)
*
      IF (JMATE.LE.0) GO TO 999
      IF (IMATE.GT.NMATE) GO TO 80
      JMA = LQ(JMATE-IMATE)
      IF  (JMA.LE.0) GO TO 80
      CALL UHTOC(IQ(JMA+1),4,NAMATE,16)
      IF(LXBARN) THEN
         CMIBAR=Q(JMA+6)/(AVO*Q(JMA+8))
      ELSE
         CMIBAR=1.
      ENDIF
*
      IF (JPART.LE.0) GO TO 999
      IF (IPART.LE.0) GO TO 999
      IF (IPART.GT.NPART) GO TO 80
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0) GO TO 80
      CALL UHTOC(IQ(JPA+1),4,NAPART,16)
*
* *** Print  bin meaning
      IF (IDM.GE.0) THEN
         CHMAIL='1'
         CALL GMAIL(0,0)
         CHMAIL=' '
         CHMAIL(31:)='Kinetic energy bin meaning'
         CALL GMAIL(0,0)
         CHMAIL(31:)='--------------------------'
         CALL GMAIL(0,1)
         NROW = (KDIM-1)/NCOL + 1
         DO 20  IR=1,NROW
            DO 10  IC=1,NCOL
               IKB = IR + (IC-1)*NROW
               IF (IKB.GT.KDIM) IKB=KDIM
               KI(IC) = IKB
               CALL GEVKEV(TKIN(IKB),EK(IC),KU(IC))
   10       CONTINUE
            WRITE(CHMAIL,10200) (KI(IC),EK(IC),KU(IC),IC=1,NCOL)
            CALL GMAIL(0,0)
   20    CONTINUE
      ENDIF
*
      BIGINV= 1000./BIG
      DO 30  JMX = 1, MMX
         SIGT(JMX) = 0.
   30 CONTINUE
      IF(MECAN.EQ.'ALL') THEN
         N1 = 1
         N2 = NMECA
      ELSE
         N1 = 0
         DO 40  IMECA=1,NMECA
            IF(MECAN.EQ.CHNMEC(IMECA)) THEN
               N1 = IMECA
            ENDIF
   40    CONTINUE
         IF(N1.EQ.0) THEN
            WRITE(CHMAIL,'('' *** GPLMAT: Mechanism '',A,
     +      '' not implemented'')') MECAN
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         N2 = N1
      ENDIF
      DO 60  IMEC = N1,N2
C
         IF (MECAN.EQ.'ALL') THEN
             IF (CHNMEC(IMEC).EQ.'RANG') GO TO 60
             IF (CHNMEC(IMEC).EQ.'STEP') GO TO 60
         END IF
C
         IF(CHNMEC(IMEC).NE.'NULL') THEN
            MECA = CHNMEC(IMEC)
            CALL GFTMAT(IMATE,IPART,MECA,KDIM,TKIN,VALUE,PCUT,IXST)
            IF(IXST.EQ.0) GO TO 60
*
* ***    Book histogram
            ISIG = 0
            IF (MECA.EQ.'LOSS') THEN
               CHTITL = NAPART//' in '//NAMATE//'   dE/dx (MeV/cm)'
            ELSEIF (MECA.EQ.'RANG') THEN
               CHTITL = NAPART//' in '//NAMATE//'   Stopping range (cm)'
            ELSEIF (MECA.EQ.'STEP') THEN
               CHTITL = NAPART//' in '//NAMATE//'   continuous step '
     +         //'(cm)'
            ELSE
               CHTITL = NAPART//' in '//NAMATE//'   '//MECA// ' cross '
     +         //'section'
               IF(LXBARN) THEN
                  CHTITL(LNBLNK(CHTITL)+1:) = ' (barn)'
               ELSE
                  CHTITL(LNBLNK(CHTITL)+1:) = ' (1/cm)'
               ENDIF
               ISIG = 1
            ENDIF
*
            ID = 10000*IMATE + 100*IPART + IMEC
            CALL HBOOKB(ID,CHTITL,KDIM-1,TKIN,0.)
*
* ***    Fill histogram
*
            VALMI = MAX (BIGINV,VMAX(VALUE,KDIM)*1.E-8)
            DO 50  IKB = 1,KDIM
               IF (MECA.NE.'LOSS'.OR.MECA.NE.'RANG'.OR.MECA.NE.'STEP')
     +             VALUE(IKB)=VALUE(IKB)*CMIBAR
               IF (VALUE(IKB).GE.VALMI) THEN
                  CALL HFILL(ID,TKIN(IKB),0.,VALUE(IKB))
               ENDIF
               IF (ISIG.EQ.1) THEN
                  IF(MECA(1:3).NE.'INE'.AND.MECA(1:3).NE.'ELA'.AND.
     +            MECA(1:3).NE.'FIS'.AND.MECA(1:3).NE.'CAP'.AND.
     +            MECA(1:3).NE.'HAD'.AND.IMEC.LT.IBLOWN) THEN
                     SIGT(IKB) = SIGT(IKB) + VALUE(IKB)
                  ELSE IF (MECA(1:3).EQ.'HAD') THEN
                     IF ((MECA.EQ.'HADG'.AND.IHADR.LE.2).OR. (MECA.EQ.
     +               'HADF'.AND.IHADR.EQ.4)) THEN
                        SIGT(IKB) = SIGT(IKB) + VALUE(IKB)
                     ENDIF
                  ENDIF
               ENDIF
   50       CONTINUE
            CALL HIDOPT(ID,'LOGY')
            IF(IDM.GE.0) CALL HPHIST(ID,' ',0)
            IF(IDM.EQ.0) CALL HDELET(ID)
         ENDIF
   60 CONTINUE
*
* *** plot total cross section and mean free path
      IF (MECAN.EQ.'ALL') THEN
         CHTITL= NAPART//' in '//NAMATE//'   total cross section'
         IF(LXBARN) THEN
            CHTITL(LNBLNK(CHTITL)+1:) = ' (barn)'
         ELSE
            CHTITL(LNBLNK(CHTITL)+1:) = ' (1/cm)'
         ENDIF
         ID = 10000*IMATE + 100*IPART + NMECA+1
         CALL HBOOKB(ID,CHTITL,KDIM-1,TKIN,0.)
*
         CHTITL= NAPART//' in '//NAMATE//'   total mean free path (cm)'
         II = ID + 1
         CALL HBOOKB(II,CHTITL,KDIM-1,TKIN,0.)
*
         VALMI = MAX (BIGINV,VMAX( SIGT,KDIM)*1.E-8)
         DO 70  IKB = 1,KDIM
            IF (SIGT(IKB).GE.VALMI) THEN
               CALL HFILL(ID,TKIN(IKB),0.,       SIGT(IKB))
               CALL HFILL(II,TKIN(IKB),0.,CMIBAR/SIGT(IKB))
            ENDIF
   70    CONTINUE
         CALL HIDOPT(ID,'LOGY')
         IF(IDM.GE.0) CALL HPHIST(ID,' ',0)
         IF(IDM.EQ.0) CALL HDELET(ID)
*
         CALL HIDOPT(II,'LOGY')
         IF(IDM.GE.0) CALL HPHIST(II,' ',0)
         IF(IDM.EQ.0) CALL HDELET(II)
      ENDIF
*
      GO TO 999
*
   80 WRITE(CHMAIL,10000) IMATE ,IPART
      CALL GMAIL(0,0)
10000 FORMAT(' ***** GPLMAT error : material',I4,
     +       '  or particle',I4,' not defined'   )
10100 FORMAT(6X,'BCUTE =',F6.2,A4,3X,'BCUTM =',F6.2,A4,3X,
     +             'DCUTE =',F6.2,A4,3X,'DCUTM =',F6.2,A4,3X,
     +            'PPCUTM =',F6.2,A4 )
10200 FORMAT(1X,5('   bin ',I3,' =',F7.2,A4))
  999 CONTINUE
      END
+DECK,GPMATE
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPMATE (NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print material data structures JMATE          *
C.    *       NUMB     Material number                                 *
C.    *                                                                *
C.    *      Changed by S.Egli at 8.5.90: also show mixture contents   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCNUM
      CHARACTER CHMIXT*17
C.
C.    ------------------------------------------------------------------
C.
      IF (JMATE.LE.0) GO TO 999
      IF (NUMB .EQ.0) THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NMATE
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
      IF(NUMB.GE.0) THEN
         WRITE (CHMAIL,10100)
         CALL GMAIL(0,1)
      ENDIF
C
      DO 20 I=N1,N2
         JMA = LQ(JMATE-I)
         IF (JMA.LE.0) GO TO 20
C
         NMIXT=Q(JMA+11)
         CHMIXT=' '
         IF(NMIXT.GT.1) CHMIXT='   A      Z     W'
         WRITE (CHMAIL,10200) I,(Q(JMA + J),J = 1,10),NMIXT,CHMIXT
         CALL GMAIL(0,0)
         IF(NMIXT.GT.1)THEN
            JMX=LQ(JMA-5)
            DO 10 J=1,NMIXT
               WRITE(CHMAIL,10300)Q(JMX+J),Q(JMX+NMIXT+J),
     +         Q(JMX+2*NMIXT+J)
               CALL GMAIL(0,0)
   10       CONTINUE
         ENDIF
   20 CONTINUE
C
10000 FORMAT ('0',51('='),5X,'MATERIALS',6X,50('='))
10100 FORMAT ('0','MATERIAL',27X,'A',9X,'Z',5X,'DENSITY'
     +,2X,'RADIAT L',2X,'ABSORP L',' NMIXT')
10200 FORMAT (' ',I8,1X,5A4,3F10.3,2E10.3,I4,2X,A17)
10300 FORMAT (' ',85X,2F7.2,F7.3)
  999 CONTINUE
      END
+DECK,GPMATX.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPMATX (NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print material data structures JMATE          *
C.    *       NUMB     Material number                                 *
C.    *                                                                *
C.    *      Changed by S.Egli at 8.5.90: also show mixture contents   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  S.Giani *****                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCNUM
      CHARACTER CHMIXT*17
      CHARACTER NAME*20
      CHARACTER*32 CHLINE,CHSTRI(50)
C.
C.    ------------------------------------------------------------------
C.
      IF (JMATE.LE.0) GO TO 999
      IF (NUMB .EQ.0) THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NMATE
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
*      IF(NUMB.GE.0) THEN
*         WRITE (CHMAIL,10100)
*         CALL GMAIL(0,1)
*      ENDIF
C
      DO 20 I=N1,N2
         JMA = LQ(JMATE-I)
         IF (JMA.LE.0) GO TO 20
C
         NMIXT=Q(JMA+11)
         CHMIXT=' '
*         IF(NMIXT.GT.1) CHMIXT='   A      Z     W'
*         WRITE (CHMAIL,10200) I,(Q(JMA + J),J = 1,10),NMIXT,CHMIXT
*         CALL GMAIL(0,0)
 
         CHLINE='Material Number='
         ILEN=LENOCC(CHLINE)+1
         CALL IZITOC(I,CHLINE(ILEN:))
         CHSTRI(1)=CHLINE
         CALL UHTOC(IQ(JMA+1),4,NAME,20)
         CHLINE='Name='
         ILEN=LENOCC(CHLINE)+1
         CHLINE(ILEN:)=NAME
         CHSTRI(2)=CHLINE
         CHLINE='A='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+6),CHLINE(ILEN:))
         CHSTRI(3)=CHLINE
         CHLINE='Z='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+7),CHLINE(ILEN:))
         CHSTRI(4)=CHLINE
         CHLINE='Dens='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+8),CHLINE(ILEN:))
         CHSTRI(5)=CHLINE
         CHLINE='RadLeng='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JMA+9),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10300)Q(JMA+9)
         CHSTRI(6)=CHLINE
         CHLINE='AbsLeng='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JMA+10),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10300)Q(JMA+10)
         CHSTRI(7)=CHLINE
         CHLINE='Nmixt='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+11),CHLINE(ILEN:))
         CHSTRI(8)=CHLINE
 
         JJJ=8
         IF(NMIXT.GT.1)THEN
            JMX=LQ(JMA-5)
            DO 10 JJ=1,NMIXT
               CHLINE='A('
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(JJ,CHLINE(ILEN:))
               ILEN=LENOCC(CHLINE)+1
               CHLINE(ILEN:)=')='
               ILEN=LENOCC(CHLINE)+1
               CALL IZRTOC(Q(JMX+JJ),CHLINE(ILEN:))
               JJJ=JJJ+1
               CHSTRI(JJJ)=CHLINE
               CHLINE='Z('
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(JJ,CHLINE(ILEN:))
               ILEN=LENOCC(CHLINE)+1
               CHLINE(ILEN:)=')='
               ILEN=LENOCC(CHLINE)+1
               CALL IZRTOC(Q(JMX+NMIXT+JJ),CHLINE(ILEN:))
               JJJ=JJJ+1
               CHSTRI(JJJ)=CHLINE
               CHLINE='W('
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(JJ,CHLINE(ILEN:))
               ILEN=LENOCC(CHLINE)+1
               CHLINE(ILEN:)=')='
               ILEN=LENOCC(CHLINE)+1
               CALL IZRTOC(Q(JMX+2*NMIXT+JJ),CHLINE(ILEN:))
               JJJ=JJJ+1
               CHSTRI(JJJ)=CHLINE
   10       CONTINUE
*            DO 10 J=1,NMIXT
*               WRITE(CHMAIL,10300)Q(JMX+J),Q(JMX+NMIXT+J),
*     +         Q(JMX+2*NMIXT+J)
*               CALL GMAIL(0,0)
*   10       CONTINUE
         ENDIF
         CALL IGMESS(JJJ,CHSTRI,'PRINT','P')
   20 CONTINUE
C
10000 FORMAT ('0',51('='),5X,'MATERIALS',6X,50('='))
10100 FORMAT ('0','MATERIAL',27X,'A',9X,'Z',5X,'DENSITY'
     +,2X,'RADIAT L',2X,'ABSORP L',' NMIXT')
10200 FORMAT (' ',I8,1X,5A4,3F10.3,2E10.3,I4,2X,A17)
10300 FORMAT (E12.5)
10400 FORMAT (' ',85X,2F7.2,F7.3)
  999 CONTINUE
      END
+DECK,GPPART
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPPART (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print particle definition JPART               *
C.    *       NUMB     Particle number                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JPART.LE.0)  GO TO 99
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,1000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = IQ(JPART-2)
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
C
      IF(NUMB.GE.0) THEN
         WRITE (CHMAIL,1001)
         CALL GMAIL(0,1)
      ENDIF
C
      DO 10 I=N1,N2
         JP = LQ(JPART-I)
         IF (JP.NE.0)THEN
            IOPT = Q(JP+6)
            NL = IQ(JP-1)
            CALL UCOPY(IQ(JP+1),ITITLE,5)
            NW=MIN(NL,13)
            WRITE (CHMAIL,1002) I,ITITLE,IOPT,
     +                          (Q(JP + J),J = 7,NW)
    5       CALL GMAIL(0,0)
            IF(NL-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NL,NW+5)
               WRITE(CHMAIL,1003) (Q(JP + J),J = NS,NW)
               GO TO 5
            END IF
         ENDIF
   10 CONTINUE
C
 1000 FORMAT ('0',51('='),3X,'Particle Types',3X,50('='))
 1001 FORMAT ('0','Part',25X,'Options',8X,'Mass',4X,'Charge'
     +,'    Life time                  User words')
 1002 FORMAT (' ',I4,1X,5A4,I8,6X,E11.4,F7.0,3X,5(E12.5,2X))
 1003 FORMAT (61X,5(E12.5,2X))
  99  RETURN
      END
+DECK,GPPARX.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPPARX (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print particle definition JPART               *
C.    *       NUMB     Particle number                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  S.Giani *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      CHARACTER*32 CHLINE,CHSTRI(50)
      CHARACTER*20 NAME
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JPART.LE.0) GO TO 999
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = IQ(JPART-2)
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
C
*      IF(NUMB.GE.0) THEN
*         WRITE (CHMAIL,1001)
*         CALL GMAIL(0,1)
*      ENDIF
C
      DO 20 I=N1,N2
         JP = LQ(JPART-I)
         IF (JP.NE.0)THEN
            IOPT = Q(JP+6)
            NL = IQ(JP-1)
            CALL UCOPY(IQ(JP+1),ITITLE,5)
*            NW=MIN(NL,13)
*            NW=NL
            CHLINE='Particle Number='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(I,CHLINE(ILEN:))
            CHSTRI(1)=CHLINE
            CALL UHTOC(IQ(JP+1),4,NAME,20)
            CHLINE='Name='
            ILEN=LENOCC(CHLINE)+1
            CHLINE(ILEN:)=NAME
            CHSTRI(2)=CHLINE
            CHLINE='Iopt='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IOPT,CHLINE(ILEN:))
            CHSTRI(3)=CHLINE
            CHLINE='Mass='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JP+7),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10200)Q(JP+7)
            CHSTRI(4)=CHLINE
            CHLINE='Charge='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JP+8),CHLINE(ILEN:))
            CHSTRI(5)=CHLINE
            CHLINE='LifeTim='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JP+9),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10300)Q(JP+9)
            CHSTRI(6)=CHLINE
            DO 10 JJ=7,NL
               CHLINE='User='
               ILEN=LENOCC(CHLINE)+1
*       CALL IZRTOC(Q(JP+JJ),CHLINE(ILEN:))
               WRITE(CHLINE(ILEN:),10300)Q(JP+JJ)
               CHSTRI(JJ)=CHLINE
   10       CONTINUE
            CALL IGMESS(NL,CHSTRI,'PRINT','P')
*            WRITE (CHMAIL,1002) I,ITITLE,IOPT,
*     +                          (Q(JP + J),J = 7,NW)
*    5       CALL GMAIL(0,0)
*            IF(NL-NW.GT.0) THEN
*               NS=NW+1
*               NW=MIN(NL,NW+5)
*               WRITE(CHMAIL,1003) (Q(JP + J),J = NS,NW)
*               GO TO 5
*            END IF
         ENDIF
   20 CONTINUE
C
10000 FORMAT ('0',51('='),3X,'Particle Types',3X,50('='))
10100 FORMAT ('0','Part',25X,'Options',8X,'Mass',4X,'Charge'
     +,'    Life time                  User words')
* 1002 FORMAT (' ',I4,1X,5A4,I8,6X,E11.4,F7.0,3X,5(E12.5,2X))
10200 FORMAT (E11.4)
10300 FORMAT (E12.5)
  999 CONTINUE
      END
+DECK,GPRMAT.
*CMZ :  3.21/03 10/10/94  14.28.58  by  S.Ravndal
*-- Author :
      SUBROUTINE GPRMAT(IMATE,IPART,MECAN,KDIN,TKIN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       INTERPOLATE and PRINT the DE/DX ,stopping range and      *
C.    *       Cross sections tabulated in JMATE banks corresponding to *
C.    *       material IMATE, particle IPART, mecanism name MECAN ,    *
C.    *       kinetic energies TKIN.                                   *
C.    *                                                                *
C.    *      The MECAnism name can be :                                *
C.    *      'HADF'   'INEF'   'ELAF'   'FISF'   'CAPF'                *
C.    *      'HADG'   'INEG'   'ELAG'   'FISG'   'CAPG'                *
C.    *      'LOSS'   'PHOT'   'ANNI'   'COMP'   'BREM'                *
C.    *      'PAIR'   'DRAY'   'PFIS'   'RAYL'   'HADG'                *
C.    *      'MUNU'   'RANG'   'STEP'                                  *
C.    *                                                                *
C.    *       For Hadronic particles it also computes the              *
C.    *       hadronic cross section from FLUKA ( '***F' ) or          *
C.    *       GHEISHA ( '***G' ) programs:                             *
C.    *       HADF or HADG -- total                                    *
C.    *       INEF or INEG -- inelastic                                *
C.    *       ELAF or ELAG -- elastic                                  *
C.    *       FISF or FISG -- fission (0.0 for FLUKA)                  *
C.    *       CAPF or CAPG -- neutron capture (0.0 for FLUKA)          *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IMATE   Geant material number                                 *
C.    *  IPART   Geant particle number                                 *
C.    *  MECAN   mechanism name of the bank to be fetched              *
C.    *  KDIM   dimension of the arrays TKIN , VALUE                   *
C.    *  TKIN   array of kinetic energy of incident particle (in Gev)  *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    R.Brun, M.Maire    *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCNUM.
+SEQ,GCUNIT.
      PARAMETER (MMX=100)
      CHARACTER*(*) MECAN
      CHARACTER*4  MECA
      CHARACTER*4  KU1 , KU2 , KU3 , KU(5)
      DIMENSION   TKIN(KDIN),VALUE(MMX),SIGT(MMX),PCUT(5),CU(5)
*
+SEQ,GCNMEC.
*
*     ------------------------------------------------------------------
*
      KDIM = MIN(KDIN,MMX)
      IF (KDIM.LE.0) GO TO 999
*
      IF (JMATE.LE.0) GO TO 999
      IF (IMATE.LE.0) GO TO 999
      IF (IMATE.GT.NMATE) GO TO 90
      JMA = LQ(JMATE-IMATE)
      IF (JMA.LE.0) GO TO 90
*
      IF (JPART.LE.0) GO TO 999
      IF (IPART.LE.0) GO TO 999
      IF (IPART.GT.NPART) GO TO 90
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0) GO TO 90
*
      DO 10 JSIG=1,MMX
         SIGT(JSIG)=0.
   10 CONTINUE
      IF(MECAN.EQ.'ALL') THEN
         N1 = 1
         N2 = NMECA
      ELSE
         N1 = 0
         DO 20  IMECA=1,NMECA
            IF(MECAN.EQ.CHNMEC(IMECA)) THEN
               N1 = IMECA
            ENDIF
   20    CONTINUE
         IF(N1.EQ.0) THEN
            WRITE(CHMAIL,'('' *** GPRMAT: Mechanism '',A,
     +      '' not implemented'')') MECAN
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         N2 = N1
      ENDIF
      DO 60  IMEC = N1,N2
         IF(CHNMEC(IMEC).NE.'NULL') THEN
            MECA = CHNMEC(IMEC)
            CALL GFTMAT(IMATE,IPART,MECA,KDIM,TKIN,VALUE,PCUT,IXST)
            IF(IXST.EQ.0) GO TO 60
            CHMAIL='1'
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10100)(IQ(JMA+I),I=1,5),MECA,(IQ(JPA+J),J=1,5)
            CALL GMAIL(0,0)
            CHMAIL(31:)='-----------------------------------------'
            CALL GMAIL(0,1)
            CHMAIL=' '
            DO 30  K=1,5
   30       CALL GEVKEV(PCUT(K),CU(K),KU(K))
            WRITE(CHMAIL,10200) (CU(K),KU(K),K=1,5)
            CALL GMAIL(0,1)
*
            IF (MECA.EQ.'LOSS'.OR.MECA.EQ.'RANG'.OR.MECA.EQ.'STEP')
     +      THEN
               IF (MECA.EQ.'LOSS') WRITE(CHMAIL,10300)
               IF (MECA.EQ.'RANG') WRITE(CHMAIL,10400)
               IF (MECA.EQ.'STEP') WRITE(CHMAIL,10500)
               CALL GMAIL(0,1)
               NROW = (KDIM-1)/3 + 1
               DO 40  IKB=1,NROW
                  IK = IKB
                  DE1 = VALUE(IK)
                  CALL GEVKEV(TKIN(IK),EK1,KU1)
*
                  IK = IKB + NROW
                  IF (IK.GT.KDIM) IK=KDIM
                  DE2 = VALUE(IK)
                  CALL GEVKEV(TKIN(IK),EK2,KU2)
*
                  IK = IKB + 2*NROW
                  IF (IK.GT.KDIM) IK=KDIM
                  DE3 = VALUE(IK)
                  CALL GEVKEV(TKIN(IK),EK3,KU3)
*
                  WRITE(CHMAIL,10600) EK1,KU1,DE1,EK2,KU2,DE2,EK3,KU3,
     +            DE3
                  CALL GMAIL(0,0)
   40          CONTINUE
            ELSE
               WRITE(CHMAIL,10700)
               CALL GMAIL(0,1)
               NROW = (KDIM-1)/2 + 1
               DO 50  IKB=1,NROW
                  IK = IKB
                  SIG1 = VALUE(IK)
                  AL1 = 1./SIG1
                  SIGT(IK) = SIGT(IK) + SIG1
                  CALL GEVKEV(TKIN(IK),EK1,KU1)
*
                  IK = IKB + NROW
                  IF (IK.GT.KDIM) IK=KDIM
                  SIG2 = VALUE(IK)
                  AL2 = 1./SIG2
                  SIGT(IK) = SIGT(IK) + SIG2
                  CALL GEVKEV(TKIN(IK),EK2,KU2)
*
                  WRITE(CHMAIL,10900) EK1,KU1,SIG1,AL1,EK2,KU2,SIG2,AL2
                  CALL GMAIL(0,0)
   50          CONTINUE
            ENDIF
         ENDIF
   60 CONTINUE
*
* *** print total cross section
      IF (MECAN.EQ.'ALL') THEN
         MECA = 'SIGT'
         CHMAIL='1'
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)(IQ(JMA+I),I=1,5),MECA,(IQ(JPA+J),J=1,5)
         CALL GMAIL(0,0)
         CHMAIL(31:)='-----------------------------------------'
         CALL GMAIL(0,1)
         CHMAIL=' '
         DO 70  K=1,5
   70    CALL GEVKEV(PCUT(K),CU(K),KU(K))
         WRITE(CHMAIL,10200) (CU(K),KU(K),K=1,5)
         CALL GMAIL(0,1)
         WRITE(CHMAIL,10800)
         CALL GMAIL(0,1)
         NROW = (KDIM-1)/2 + 1
         DO 80  IKB=1,NROW
            IK = IKB
            SIG1 = SIGT(IK)
            AL1  = 1./SIG1
            CALL GEVKEV(TKIN(IK),EK1,KU1)
*
            IK = IKB + NROW
            IF (IK.GT.KDIM) IK=KDIM
            SIG2 = SIGT(IK)
            AL2  = 1./SIG2
            CALL GEVKEV(TKIN(IK),EK2,KU2)
*
            WRITE(CHMAIL,10900) EK1,KU1,SIG1,AL1,EK2,KU2,SIG2,AL2
            CALL GMAIL(0,0)
   80    CONTINUE
      ENDIF
*
      GO TO 999
*
   90 WRITE(CHMAIL,10000) IMATE ,IPART
      CALL GMAIL(0,0)
*
10000 FORMAT(' ***** GPRMAT error : material',I4,
     +       '  or particle',I4,' not defined'   )
10100 FORMAT(30X,5A4,A4, ' for  ',5A4)
10200 FORMAT(  6X,'BCUTE =',F6.2,A4,3X,'BCUTM =',F6.2,A4,3X,
     +             'DCUTE =',F6.2,A4,3X,'DCUTM =',F6.2,A4,3X,
     +            'PPCUTM =',F6.2,A4 )
10300 FORMAT(  6X,'kinetic energy   DE/DX(mev/cm)',
     +         6X,'kinetic energy   DE/DX(mev/cm)',
     +         6X,'kinetic energy   DE/DX(mev/cm)')
10400 FORMAT(  6X,'kinetic energy   Stop range cm',
     +         6X,'kinetic energy   Stop ramge cm',
     +         6X,'kinetic energy   Stop range cm')
10500 FORMAT(  6X,'kinetic energy   Mulof step cm',
     +         6X,'kinetic energy   Mulof step cm',
     +         6X,'kinetic energy   Mulof step cm')
10600 FORMAT( 3(F16.2,A4,E15.4))
10700 FORMAT(  6X,'kinetic energy   Sigma (1/cm)    Lambda (cm)',
     +         6X,'kinetic energy   Sigma (1/cm)    Lambda (cm)')
10800 FORMAT(  6X,'kinetic energy   Sigto (1/cm)    Lambda (cm)',
     +         6X,'kinetic energy   Sigto (1/cm)    Lambda (cm)')
10900 FORMAT( 2(F16.2,A4,2(E15.4)))
  999 CONTINUE
      END
+DECK,GPTMED
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPTMED (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print tracking media data structure JTMED     *
C.    *       NUMB     medium number                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCNUM
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JTMED.LE.0)  GO TO 99
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,1000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NTMED
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
      IF(NUMB.GE.0) THEN
         WRITE (CHMAIL,1001)
         CALL GMAIL(0,1)
      ENDIF
C
      DO 10 I=N1,N2
         JTM = LQ(JTMED-I)
         IF (JTM.NE.0)THEN
            IMAT = Q(JTM+6)
            ISVOL = Q(JTM+7)
            IFIELD = Q(JTM+8)
            CALL UCOPY(IQ(JTM+1),ITITLE,5)
            WRITE(CHMAIL,1002)I,ITITLE,IMAT,ISVOL,IFIELD,
     +                        (Q(JTM+J),J=9,14)
            CALL GMAIL(0,0)
         ENDIF
   10 CONTINUE
C
 1000 FORMAT ('0',51('='),3X,'TRACKING MEDIA',3X,50('='))
 1001 FORMAT ('0','TMED',26X,'MATERIAL ','ISVOL',' IFIELD  FIELDM'
     +, '  TMAXFD','  STEMAX','    DEEMAX','   EPSIL','   STMIN')
 1002 FORMAT (' ',I6,1X,5A4,I8,I8,I6,4X,F6.2,2X,F6.2,G10.3,3F8.3)
  99  RETURN
      END
+DECK,GPTMEX.
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GPTMEX (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print tracking media data structure JTMED     *
C.    *       NUMB     medium number                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun S.Giani  *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCNUM
      CHARACTER*32 CHLINE,CHSTRI(50)
      CHARACTER*20 NAME
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JTMED.LE.0) GO TO 999
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NTMED
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
*      IF(NUMB.GE.0) THEN
*         WRITE (CHMAIL,1001)
*         CALL GMAIL(0,1)
*      ENDIF
C
      DO 10 I=N1,N2
         JTM = LQ(JTMED-I)
         IF (JTM.NE.0)THEN
            IMAT = Q(JTM+6)
            ISVOL = Q(JTM+7)
            IFIELD = Q(JTM+8)
            CALL UCOPY(IQ(JTM+1),ITITLE,5)
            CHLINE='T. Med. Number='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(I,CHLINE(ILEN:))
            CHSTRI(1)=CHLINE
            CALL UHTOC(IQ(JTM+1),4,NAME,20)
            CHLINE='Name='
            ILEN=LENOCC(CHLINE)+1
            CHLINE(ILEN:)=NAME
            CHSTRI(2)=CHLINE
            CHLINE='Material='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IMAT,CHLINE(ILEN:))
            CHSTRI(3)=CHLINE
            CHLINE='Isvol='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(ISVOL,CHLINE(ILEN:))
            CHSTRI(4)=CHLINE
            CHLINE='Ifield='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IFIELD,CHLINE(ILEN:))
            CHSTRI(5)=CHLINE
            CHLINE='Fieldm='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+9),CHLINE(ILEN:))
            CHSTRI(6)=CHLINE
            CHLINE='Tmaxfd='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+10),CHLINE(ILEN:))
            CHSTRI(7)=CHLINE
            CHLINE='Stepmax='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JTM+11),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10200)Q(JTM+11)
            CHSTRI(8)=CHLINE
            CHLINE='Deemax='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+12),CHLINE(ILEN:))
            CHSTRI(9)=CHLINE
            CHLINE='Epsil='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JTM+13),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10200)Q(JTM+13)
            CHSTRI(10)=CHLINE
            CHLINE='Stmin='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+14),CHLINE(ILEN:))
            CHSTRI(11)=CHLINE
            CALL IGMESS(11,CHSTRI,'PRINT','P')
 
*            WRITE(CHMAIL,1002)I,ITITLE,IMAT,ISVOL,IFIELD,
*     +                        (Q(JTM+J),J=9,14)
*            CALL GMAIL(0,0)
         ENDIF
   10 CONTINUE
C
10000 FORMAT ('0',51('='),3X,'TRACKING MEDIA',3X,50('='))
10100 FORMAT ('0','TMED',26X,'MATERIAL ','ISVOL',' IFIELD  FIELDM'
     +, '  TMAXFD','  STEMAX','    DEEMAX','   EPSIL','   STMIN')
10200 FORMAT (E12.5)
  999 CONTINUE
      END
+DECK,GSCKOV
*CMZ :  3.21/02 21/03/94  17.01.28  by  Rene Brun
*-- Author :
      SUBROUTINE GSCKOV(ITMED, NPCKOV, PPCKOV, ABSCO, EFFIC, RINDEX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Stores the tables for UV photon tracking in medium ITMED    *
C.    *    Please note that it is the user's responsability to         *
C.    *    provide all the coefficients:                               *
C.    *                                                                *
C.    *                                                                *
C.    *       ITMED       Tracking medium number                       *
C.    *       NPCKOV      Number of bins of each table                 *
C.    *       PPCKOV      Value of photon momentum (in GeV)            *
C.    *       ABSCO       Absorbtion coefficents                       *
C.    *                   dielectric: absorbtion length in cm          *
C.    *                   metals    : absorbtion fraction (0<=x<=1)    *
C.    *       EFFIC       Detection efficiency for UV photons          *
C.    *       RINDEX      Refraction index (if=0 metal)                *
C.    *                                                                *
C.    *       Called by : <USER>                                       *
C.    *                                                                *
C.    *       Authors: F.Carminati, R.Jones  ************              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCMZFO
+SEQ,GCUNIT
+SEQ,GCJLOC
      DIMENSION PPCKOV(*), ABSCO(*), EFFIC(*), RINDEX(*)
C.
C.    ------------------------------------------------------------------
C.
      JTM = 0
      IF(ITMED.GT.0) THEN
         IF(JTMED.GT.0) THEN
            IF(IQ(JTMED-2).GE.ITMED) THEN
               JTM = LQ(JTMED-ITMED)
            ENDIF
         ENDIF
      ENDIF
      IF(JTM.LE.0) THEN
         WRITE(CHMAIL,10000)
10000   FORMAT(' **** GSCKOV Tracking medium ',I10,' not defined')
         CALL GMAIL(0,0)
         GO TO 999
      ENDIF
      IF(IQ(JTM-2).LT.3) THEN
         CALL MZPUSH(IXSTOR,JTM,3-IQ(JTM-2),0,' ')
      ENDIF
      CALL MZBOOK(IXCONS,JTCKOV,JTM,-3,'CKOV',4,4,NPCKOV+1,3,-1)
      CALL MZBOOK(IXCONS,JABSCO,JTCKOV,-1,'ABSC',0,0,NPCKOV,3,-1)
      CALL MZBOOK(IXCONS,JEFFIC,JTCKOV,-2,'EFFI',0,0,NPCKOV,3,-1)
      IF(RINDEX(1).GE.1.) THEN
         CALL MZBOOK(IXCONS,JINDEX,JTCKOV,-3,'RIND',0,0,NPCKOV,3,-1)
         CALL MZBOOK(IXCONS,JCURIN,JTCKOV,-4,'ABCU',0,0,NPCKOV,3,-1)
      ENDIF
      Q(JTCKOV+1)=NPCKOV
      DO 10 J=1, NPCKOV
         Q(JTCKOV+1+J) = PPCKOV(J)
         Q(JABSCO+  J) = MAX(1E-10,ABSCO(J))
         Q(JEFFIC+  J) = EFFIC(J)
         IF(RINDEX(1).GE.1.) THEN
            Q(JINDEX+ J) = RINDEX(J)
            IF(J.GT.1) THEN
               Q(JCURIN+J)=0.5*((1/RINDEX(J-1)**2)+(1./RINDEX(J)**2))
               Q(JCURIN+J)=Q(JCURIN+J-1)+(PPCKOV(J)-PPCKOV(J-1))*
     +                     Q(JCURIN+J)
            ELSE
               Q(JCURIN+J)=0.
            ENDIF
         ENDIF
   10 CONTINUE
*
  999 CONTINUE
      END
+DECK,GSDK
*CMZ :  3.21/03 02/08/94  18.13.20  by  S.Ravndal
*-- Author :
      SUBROUTINE GSDK(IPART,BRATIO,MODE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Defines branching ratios and decay modes for standard         *
C.    *  GEANT particles.                                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPART                                *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCNUM
+SEQ,GCUNIT
      DIMENSION BRATIO(6)
      DIMENSION MODE(6)
C.
C.    ------------------------------------------------------------------
C.
      IF (IPART.LE.0)                              GO TO 99
      IF (IPART.GT.NPART)                          GO TO 99
C
C     Particle pointer.
C
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0)                                GO TO 99
C
C     Book decay links and data banks.
C
      JDK1=LQ(JPA-1)
      JDK2=LQ(JPA-2)
      IF(JDK1+JDK2.NE.0) THEN
         WRITE(CHMAIL, 10000)
         CALL GMAIL(1,0)
         CALL GPPART(IPART)
         CALL MZDROP(IXCONS,LQ(JPA-1),' ')
         CALL MZDROP(IXCONS,LQ(JPA-2),' ')
      ENDIF
      CALL MZBOOK(IXCONS,JDK1,JPA,-1,'PABR',0,0,6,3,0)
      JPA=LQ(JPART-IPART)
      CALL MZBOOK(IXCONS,JDK2,JPA,-2,'PAMO',0,0,6,2,0)
      JPA=LQ(JPART-IPART)
      JDK1=LQ(JPA-1)
      IQ(JDK1-5)=IPART
      IQ(JDK2-5)=IPART
C
C     Store branching ratios & decay modes.
C
      DO 20 I=1,6
         Q(JDK1+I) = BRATIO(I)
         IQ(JDK2+I) = MODE(I)
   20 CONTINUE
C
  99  RETURN
10000 FORMAT(' *** GSDK ***: Warning, redefinition of decay ',
     +       'for particle:')
      END
+DECK,GSMATE
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSMATE(IMAT,NAMATE,A,Z,DENS,RADL,ABSL,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       Store material parameters                                *
C.    *                                                                *
C.    *                                                                *
C.    *             The Material data structure JMATE                  *
C.    *             ---------------------------------                  *
C.    *                                                                *
C.    *                                         | JMATE                *
C.    *    NMATE           IMATE                v                      *
C.    *     ......................................                     *
C.    *     |              | |                 | |                     *
C.    *     ......................................                     *
C.    *                     |                                          *
C.    *                     | JMA                                      *
C.    *                     v                                          *
C.    *                    .....................                       *
C.    *                    | 1 |               |                       *
C.    *                    .....               |                       *
C.    *                    | 2 |  Material     |                       *
C.    *                    |...|               |                       *
C.    *                    | 3 |   Name        |                       *
C.    *                    |...|               |                       *
C.    *                    | 4 |               |                       *
C.    *                    |...|               |                       *
C.    *                    | 5 |               |                       *
C.    *                    .....................                       *
C.    *                    | 6 |   A           |                       *
C.    *                    |...|...............|                       *
C.    *                    | 7 |   Z           |                       *
C.    *                    |...|...............|                       *
C.    *                    | 8 |   Density     |                       *
C.    *                    |...|...............|                       *
C.    *                    | 9 |   RADL        |                       *
C.    *                    |...|...............|                       *
C.    *                    | 10|   ABSL        |                       *
C.    *                    |...|...............|                       *
C.    *                    | 11|   NMIXT       |                       *
C.    *                    |...|...............|                       *
C.    *                    |   |               |                       *
C.    *                    .....................                       *
C.    *                                                                *
C.    * JMA = LQ(JMATE-IMATE) pointer to material IMATE                *
C.    *                                                                *
C.    *   When  the subroutine  GPHYSI is  called at  initialisation   *
C.    * time  the following  banks  are  created for  each  material   *
C.    * (tabulation of energy loss and cross-section).                 *
C.    *                                               | JMATE          *
C.    * NMATE                     IMATE               v                *
C.    * ................................................               *
C.    * |                        | |                 | |               *
C.    * ................................................               *
C.    *                           | JMA = LQ(JMATE-IMATE)              *
C.    *                           v                              11    *
C.    * ............................................................   *
C.    * |  13 12 11 10 9 8 7 6 5 4 3 2 1 | |  Material parameters  |   *
C.    * ............................................................   *
C.    *    |  |  |  |  | | | | | | | | |                               *
C.    *    |  |  |  |  | | | | | | | | v  JMAEL = LQ(JMA-1)            *
C.    *    |  |  |  |  | | | | | | | |                         270     *
C.    *    |  |  |  |  | | | | | | | |................................ *
C.    *    |  |  |  |  | | | | | | | ||Energy loss for electron/positro*
C.    *    |  |  |  |  | | | | | | | |............................     *
C.    *    |  |  |  |  | | | | | | | v  JMAMU = LQ(JMA-2)       90     *
C.    *    |  |  |  |  | | | | | | |..............................     *
C.    *    |  |  |  |  | | | | | | ||Energy loss for muons       |     *
C.    *    |  |  |  |  | | | | | | |..............................     *
C.    *    |  |  |  |  | | | | | | v  JMAAL = LQ(JMA-3)         90     *
C.    *    |  |  |  |  | | | | | |................................     *
C.    *    |  |  |  |  | | | | | ||Energy loss for other particles|    *
C.    *    |  |  |  |  | | | | | |................................     *
C.    *    |  |  |  |  | | | | | v  JPROB = LQ(JMA-4)           30     *
C.    *    |  |  |  |  | | | | |..................................     *
C.    *    |  |  |  |  | | | | ||Some material constants         |     *
C.    *    |  |  |  |  | | | | |..................................     *
C.    *    |  |  |  |  | | | | v  JMIXT = LQ(JMA-5)             11     *
C.    *    |  |  |  |  | | | |....................................     *
C.    *    |  |  |  |  | | | ||Mixture or compound parameters    |     *
C.    *    |  |  |  |  | | | |....................................     *
C.    *    |  |  |  |  | | | v  JPHOT = LQ(JMA-6) and JMUNU     90     *
C.    *    |  |  |  |  | | |......................................     *
C.    *    |  |  |  |  | | ||Photo-effect cross-section          |     *
C.    *    |  |  |  |  | | |......................................     *
C.    *    |  |  |  |  | | v  JANNI = LQ(JMA-7)                 90     *
C.    *    |  |  |  |  | |........................................     *
C.    *    |  |  |  |  | ||Positron annihilation cross-section   |     *
C.    *    |  |  |  |  | |........................................     *
C.    *    |  |  |  |  | V  JCOMP = LQ(JMA-8)                   90     *
C.    *    |  |  |  |  |..........................................     *
C.    *    |  |  |  |  ||Compton scattering cross-section        |     *
C.    *    |  |  |  |  |..........................................     *
C.    *    |  |  |  |  V  JBREM = LQ(JMA-9)                     90     *
C.    *    |  |  |  | ............................................     *
C.    *    |  |  |  | |Bremsstrahlung cross-section              |     *
C.    *    |  |  |  | ............................................     *
C.    *    |  |  |  V  JPAIR = LQ(JMA-10)                       90     *
C.    *    |  |  | ...............................................     *
C.    *    |  |  | |Pair production cross-section                |     *
C.    *    |  |  | ...............................................     *
C.    *    |  |  V  JDRAY = LQ(JMA-11)                         210     *
C.    *    |  | ..................................................     *
C.    *    |  | |Moller and Bhabha cross-sections                |     *
C.    *    |  | ..................................................     *
C.    *    |  V  JPFIS = LQ(JMA-12)                             90     *
C.    *    | .....................................................     *
C.    *    | |Photo fission cross section                        |     *
C.    *    | .....................................................     *
C.    *    V  JRAYL = LQ(JMA-13)                                62     *
C.    *   ........................................................     *
C.    *   |Rayleigh scattering cross section and atomic form fact|     *
C.    *   ........................................................     *
C.    * V  JMUNU = LQ(JMA-14)                                  90      *
C.    *   ........................................................     *
C.    * V  JRANG = LQ(JMA-15)                                 180      *
C.    * V........................................................      *
C.    *  |Stopping range for electrons/positrons                |      *
C.    *  ........................................................      *
C.    * V  JRANG = LQ(JMA-16)                                 180      *
C.    * V........................................................      *
C.    *  |Stopping range for muons / other particles            |      *
C.    *  ........................................................      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM    ,<GXINT> GINC3              *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCMZFO
+SEQ,GCUNIT
      DIMENSION UBUF(1)
      CHARACTER*(*) NAMATE
      CHARACTER*20 NAME
C.
C.    ------------------------------------------------------------------
C.
      IF(IMAT.LE.0)GO TO 99
      IF(JMATE.LE.0)THEN
         CALL MZBOOK(IXCONS,JMATE,JMATE,1,'MATE',NMATE,NMATE,0,3,0)
         IQ(JMATE-5)=0
      ENDIF
      IF(IMAT.GT.NMATE)THEN
         CALL MZPUSH(IXCONS,JMATE,IMAT-NMATE,0,'I')
         NMATE=IMAT
         JMA1=0
      ELSE
         JMA1=LQ(JMATE-IMAT)
         IF(JMA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPMATE(IMAT)
            CALL MZDROP(IXCONS,LQ(JMATE-IMAT),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JMA,JMATE,-IMAT,'MATE',20,20,NWBUF+11,IOMATE,0)
C
      NAME=NAMATE
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JMA+1),4,20)
C
      Q(JMA + 6) = A
      Q(JMA + 7) = Z
      Q(JMA + 8) = DENS
      Q(JMA + 9) = RADL
      Q(JMA + 10) = ABSL
      Q(JMA + 11) = 1.
      IF(NWBUF.GT.0)CALL UCOPY(UBUF,Q(JMA+12),NWBUF)
C
      IF(JMA1.GT.0) THEN
         CALL GPMATE(-IMAT)
      ENDIF
C
10000 FORMAT(' *** GSMATE ***: Warning, material redefinition:')
  99  CONTINUE
      END
 
+DECK,GSMIXT
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSMIXT(IMAT,NAMATE,A,Z,DENS,NLMAT,WMAT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines mixture OR COMPOUND IMAT as composed by          *
C.    *       THE BASIC NLMAT materials defined by arrays A,Z and WMAT *
C.    *                                                                *
C.    *       If NLMAT.GT.0 then WMAT contains the PROPORTION BY       *
C.    *       WEIGTHS OF EACH BASIC MATERIAL IN THE MIXTURE.           *
C.    *                                                                *
C.    *       If NLMAT.LT.0 then WMAT contains the number of atoms     *
C.    *       of a given kind into the molecule of the COMPOUND        *
C.    *       In this case, WMAT in output is changed to relative      *
C.    *       weigths.                                                 *
C.    *                                                                *
C.    *       nb : the radiation length is computed according          *
C.    *            the EGS manual slac-210 uc-32 June-78               *
C.    *                           formula  2-6-8 (37)                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCUNIT
+SEQ,GCMZFO
      DIMENSION WMAT(1),A(1),Z(1)
      CHARACTER*(*) NAMATE
      CHARACTER*20 NAME
      DATA ALR2AV , AL183 / 1.39621E-03  ,  5.20948 /
C.
C.    ------------------------------------------------------------------
C.
      IF (IMAT.LE.0)GO TO 99
      IF(JMATE.LE.0)THEN
         CALL MZBOOK(IXCONS,JMATE,JMATE,1,'MATE',NMATE,NMATE,0,3,0)
         IQ(JMATE-5)=0
      ENDIF
      IF(IMAT.GT.NMATE)THEN
         CALL MZPUSH(IXCONS,JMATE,IMAT-NMATE,0,'I')
         NMATE=IMAT
         JMA1=0
      ELSE
         JMA1=LQ(JMATE-IMAT)
         IF(JMA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPMATE(IMAT)
            CALL MZDROP(IXCONS,LQ(JMATE-IMAT),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JMA,JMATE,-IMAT,'MATE',20,20,11,IOMATE,0)
C
      NAME=NAMATE
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JMA+1),4,20)
C
C             Store mixture parameters
C             and parameter for Pair/Brems and
C             Photoelectric routines
C
      NLM    = IABS(NLMAT)
      IF (NLM.LE.0)GO TO 90
      CALL MZBOOK(IXCONS,JMIXT,JMA,-5,'MAMI',2,2,4*NLM,3,0)
      CALL MZBOOK(IXCONS,JMI1,JMIXT,-1,'MAM1',0,0,10,3,0)
      JMA = LQ(JMATE- IMAT)
      IQ(JMIXT-5)=IMAT
      IQ(JMI1-5)=IMAT
C
C             Compute proportion by weigths in the compound
C
      IF(NLMAT.LT.0) THEN
         AMOL   = 0.
         ZMOL   = 0.
         DO 10 I= 1,NLM
         AMOL   = AMOL + WMAT(I)*A(I)
         ZMOL   = ZMOL + WMAT(I)*Z(I)
   10    CONTINUE
         DO 20 I= 1,NLM
         WMAT(I)= WMAT(I)*A(I) / AMOL
   20    CONTINUE
      ENDIF
C
C             Compute effective mixture parameters
C
      AEFF   = 0.
      ZEFF   = 0.
      RADINV = 0.
      DO 40 I = 1,NLM
         AEFF   = AEFF + WMAT(I)*A(I)
         ZEFF   = ZEFF + WMAT(I)*Z(I)
         ZC     = Z(I)
         ALZ    = LOG(ZC)/3.
         XINV   = ZC*(ZC+GXSI(ZC))*(AL183-ALZ-GFCOUL(ZC))/A(I)
         RADINV = RADINV + WMAT(I)*XINV
         Q(JMIXT+3*NLM+I)=XINV
         Q(JMIXT + 2* NLM + I) = WMAT(I)
         Q(JMIXT + NLM + I) = Z(I)
         Q(JMIXT + I) = A(I)
   40 CONTINUE
      RADINV = ALR2AV * DENS * RADINV
      RADEFF = 1. / RADINV
      CALL GHMIX(A,WMAT,NLM,AHEFF)
      ABSEFF=10000.*AHEFF/(6.022*DENS*GHSIGM(5.,8,AHEFF))
C
      Q(JMA + 6) = AEFF
      Q(JMA + 7) = ZEFF
      Q(JMA + 8) = DENS
      Q(JMA + 9) = RADEFF
      Q(JMA + 10) = ABSEFF
      Q(JMA + 11) = NLM
      Q(JMI1 + 1) = AHEFF
      IF(NLMAT.GT.0)THEN
         Q(JMI1 + 2) = AEFF
         Q(JMI1 + 3) = ZEFF
      ELSE
         Q(JMI1 + 2) = AMOL
         Q(JMI1 + 3) = ZMOL
      ENDIF
C
      IF(JMA1.GT.0) THEN
         CALL GPMATE(-IMAT)
      ENDIF
C
      GO TO 99
C
  90  CHMAIL=' ***** GSMIXT ERROR. MIXTURE WITH NO COMPONENTS'
      CALL GMAIL(0,0)
C
  99  RETURN
10000 FORMAT(' *** GSMIXT ***: Warning, material redefinition:')
      END
+DECK,GSPART
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSPART(IPART,NAPART,ITRTYP,AMASS,CHARGE,TLIFE,
     +            UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store particle parameters                                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPART                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCMZFO
+SEQ,GCUNIT
      DIMENSION UBUF(1)
      CHARACTER*(*) NAPART
      CHARACTER*20 NAME
C.
C.    ------------------------------------------------------------------
C.
      IF(IPART.LE.0)GO TO 99
      IF(JPART.LE.0)THEN
         CALL MZBOOK(IXCONS,JPART,JPART,1,'PART',NPART,NPART,0,3,0)
         IQ(JPART-5)=0
      ENDIF
      IF(IPART.GT.NPART)THEN
         CALL MZPUSH(IXCONS,JPART,IPART-NPART,0,'I')
         NPART=IPART
         JPA1=0
      ELSE
         JPA1=LQ(JPART-IPART)
         IF(JPA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPPART(IPART)
            CALL MZDROP(IXCONS,LQ(JPART-IPART),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JPA,JPART,-IPART,'PART',2,2,NWBUF+9,IOPART,0)
C
      NAME=NAPART
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JPA+1),4,20)
C
      Q(JPA + 6) = ITRTYP
      Q(JPA + 7) = AMASS
      Q(JPA + 8) = CHARGE
      Q(JPA + 9) = TLIFE
      IF(NWBUF.GT.0)CALL UCOPY(UBUF,Q(JPA+10),NWBUF)
C
      IF(JPA1.GT.0) THEN
         CALL GPPART(-IPART)
      ENDIF
C
  99  RETURN
10000 FORMAT(' *** GSPART ***: Warning, particle redefinition:')
      END
+DECK,GSTMED
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSTMED(KTMED,NATMED,NMAT,ISVOL,IFIELD,FIELDM,TMAXFD,
     +        STEMAX,DEEMAX,EPSIL,STMIN,UBUF,NWBUF)
*
***********************************************************************
*                                                                     *
*                                                                     *
*       Store tracking media parameters                               *
*                                                                     *
*    Stores the  parameters of the tracking  medium ITMED in  the data*
*  structure JTMED.                                                   *
*  ITMED     tracking medium number 0<ITMED<100                       *
*  NATMED    tracking medium name (up to 20 characters ended by $)    *
*  NMAT      material number corresponding to ITMED                   *
*  ISVOL     =0 if not a sensitive volume                             *
*  IFIELD    = 0  if no magnetic field                                *
*            = -1  reserved for user decision in GUSWIM               *
*            = 1  tracking performed with GRKUTA                      *
*            = 2  tracking performed with GHELIX                      *
*            = 3  tracking performed with GHELX3                      *
*  FIELDM    maximum field value (in Kilogauss)                       *
*  TMAXFD    maximum  angle due  to field  permitted in  one step  (in*
*            degrees)                                                 *
*  STEMAX    Maximum step allowed                                     *
*            (in cm)                                                  *
*  DEEMAX    maximum fractional energy loss in one step               *
*  EPSIL     tracking precision (in cm)                               *
*  STMIN     minimum step  due to energy  loss or  multiple scattering*
*            (in cm)                                                  *
*  UBUF      array of NWBUF additional parameters                     *
*  NWBUF                                                              *
*                                                                     *
*                                                                     *
*          The Tracking Medium data structure JTMED                   *
*          ----------------------------------------                   *
*                                                                     *
*                                         | JTMED                     *
*    NTMED           ITMED                v                           *
*     ..........................................................      *
*     |               | |                | | Standard Trac.media      *
*     ..........................................................      *
*                      | JT                                           *
*                      v                                              *
*                    ..........................                       *
*                    | 1 |                    |                       *
*                    .....                    |                       *
*                    | 2 |  Tracking medium   |                       *
*                    |...|                    |                       *
*                    | 3 |   Name             |                       *
*                    |...|                    |                       *
*                    | 4 |                    |                       *
*                    |...|                    |                       *
*                    | 5 |                    |                       *
*                    ..........................                       *
*                    | 6 |   NMAT             |                       *
*                    |...|....................|                       *
*                    | 7 |   ISVOL            |                       *
*                    |...|....................|                       *
*                    | 8 |   IFIELD           |                       *
*                    |...|....................|                       *
*                    | 9 |   FIELDM           |                       *
*                    |...|....................|                       *
*                    | 10|   TMAXFD           |                       *
*                    |...|....................|                       *
*                    | 11|   STEMAX           |                       *
*                    |...|....................|                       *
*                    | 12|   DEEMAX           |                       *
*                    |...|....................|                       *
*                    | 13|   EPSIL            |                       *
*                    |...|....................|                       *
*                    | 14|   STMIN            |                       *
*                    |...|....................|                       *
*                    | 15|   User words ....  |                       *
*                    ..........................                       *
*   JT = LQ(JTMED-ITMED) pointer to tracking medium ITMED             *
*                                                                     *
*    ==>Called by : <USER>, UGEOM    ,<GXINT> GINC3                   *
*       Author    R.Brun  *********                                   *
*                                                                     *
***********************************************************************
*
+SEQ,GCBANK
+SEQ,GCCUTS
+SEQ,GCPHYS
+SEQ,GCONSP
+SEQ,GCUNIT
+SEQ,GCNUM
+SEQ,GCMZFO
+SEQ,GCTRAK.
      DIMENSION MECA(5,13)
      EQUIVALENCE (MECA(1,1),IPAIR)
      DIMENSION UBUF(1),CUTVEC(10)
      EQUIVALENCE (CUTVEC,CUTGAM)
      CHARACTER*(*) NATMED
      CHARACTER*20 NAME
C.
C.    ------------------------------------------------------------------
C.
      ITMED=ABS(KTMED)
      IF(JTMED.LE.0)THEN
         CALL MZBOOK(IXCONS,JTMED,JTMED,1,'TMED',NTMED,NTMED,40,3,0)
         CALL UCOPY(CUTVEC,Q(JTMED+1),10)
         IQ(JTMED-5)=0
         DO 10 I=1,13
            Q(JTMED+10+I)=MECA(1,I)
   10    CONTINUE
         Q(JTMED+10+21)=ILABS
         Q(JTMED+10+22)=ISYNC
         Q(JTMED+10+23)=ISTRA
      ENDIF
      IF(ITMED.GT.NTMED)THEN
         CALL MZPUSH(IXCONS,JTMED,ITMED-NTMED,0,'I')
         NTMED=ITMED
         JTM1=0
      ELSE
         JTM1=LQ(JTMED-ITMED)
         IF(JTM1.GT.0) THEN
            WRITE(CHMAIL,10100)
            CALL GMAIL(1,0)
            CALL GPTMED(ITMED)
            CALL MZDROP(IXCONS,LQ(JTMED-ITMED),' ')
         ENDIF
      ENDIF
      NW=NWBUF+14
      CALL MZBOOK(IXCONS,JTM,JTMED,-ITMED,'TMED',10,10,NW,IOTMED,0)
C
      NAME=NATMED
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JTM+1),4,20)
C
      EPS=EPSIL
      IF(EPSIL.LE.0.0) THEN
         WRITE(CHMAIL,10000) ITMED, EPSIL
         CALL GMAIL(0,0)
         EPS=1.E-4
      END IF
      IF(IFIELD.NE.0.AND.FIELDM.EQ.0.0) THEN
         WRITE(CHMAIL,10200) ITMED, IFIELD
         CALL GMAIL(0,0)
      END IF
      IF(IGAUTO.NE.0.AND.ITMED.GT.0)THEN
         DE=-1.
         ST=-1.
         SM=-1.
      ELSE
         DE=DEEMAX
         ST=STMIN
         SM=STEMAX
      ENDIF
      Q(JTM + 6) = NMAT
      Q(JTM + 7) = ISVOL
      Q(JTM + 8) = IFIELD
      Q(JTM + 9) = FIELDM
      Q(JTM + 10) = TMAXFD
      Q(JTM + 11) = SM
      Q(JTM + 12) = DE
      Q(JTM + 13) = EPS
      Q(JTM + 14) = ST
      IF(NWBUF.GT.0)CALL UCOPY(UBUF,Q(JTM+15),NWBUF)
C
      IF(JTM1.GT.0) THEN
         CALL GPTMED(-ITMED)
      ENDIF
C
10000 FORMAT('0*** GSTMED *** Warning, medium = ',I5,
     +       ', value of EPSIL=',E10.3,' reset to 1 micron')
10100 FORMAT(' *** GSTMED *** Warning, tracking medium redefinition:')
10200 FORMAT('0*** GSTMED *** Warning, medium = ',I5,
     +       ', IFIELD = ',I3,' and FIELDM = 0.0 is illegal')
  999 CONTINUE
      END
+DECK,GSTPAR
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSTPAR(ITMED,CHPAR,PARVAL)
*
************************************************************************
*                                                                      *
*  To change the value of cut  or mechanism "CHPAR"                    *
*      to a new value PARVAL  for tracking medium ITMED                *
*    The  data   structure  JTMED   contains  the   standard  tracking *
*  parameters (CUTS and flags to control the physics processes)  which *
*  are used  by default  for all  tracking media.   It is  possible to *
*  redefine individually  with GSTPAR  any of  these parameters  for a *
*  given tracking medium.                                              *
*  ITMED     tracking medium number                                    *
*  CHPAR     is a character string (variable name)                     *
*  PARVAL    must be given as a floating point.                        *
*  For     example     to     change    CUTGAM     to     0.0001       *
*                                                                      *
*    ==>Called by : <USER>                                             *
*       Author    R.Brun     *********                                 *
*                                                                      *
************************************************************************
*
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCCUTS
+SEQ,GCUNIT
+SEQ,GCNUM
      DIMENSION CUTS(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      CHARACTER*(*) CHPAR
C.
C.    ------------------------------------------------------------------
C.
      IF(ITMED.LE.0)GO TO 90
      IF(ITMED.GT.NTMED)GO TO 90
      JTM=LQ(JTMED-ITMED)
      IF(JTM.LE.0)GO TO 90
      JTMN=LQ(JTM)
      IF(JTMN.EQ.0)THEN
         CALL MZBOOK(IXCONS,JTMN,JTM,0,'TCUT',0,0,40,3,0)
         IQ(JTMN-5)=ITMED
         DO 10 I=1,10
            Q(JTMN+I)=CUTS(I)
  10     CONTINUE
         DO 20 I=1,13
            Q(JTMN+10+I)=MECA(1,I)
  20     CONTINUE
*
* *** New mechanisms in version 3.16
         Q(JTMN+10+21)=ILABS
         Q(JTMN+10+22)=ISYNC
         Q(JTMN+10+23)=ISTRA
      ENDIF
C
      ITPAR=0
      IF(CHPAR.EQ.'CUTGAM')ITPAR=1
      IF(CHPAR.EQ.'CUTELE')ITPAR=2
      IF(CHPAR.EQ.'CUTNEU')ITPAR=3
      IF(CHPAR.EQ.'CUTHAD')ITPAR=4
      IF(CHPAR.EQ.'CUTMUO')ITPAR=5
      IF(CHPAR.EQ.'BCUTE' )ITPAR=6
      IF(CHPAR.EQ.'BCUTM' )ITPAR=7
      IF(CHPAR.EQ.'DCUTE' )ITPAR=8
      IF(CHPAR.EQ.'DCUTM' )ITPAR=9
      IF(CHPAR.EQ.'PPCUTM')ITPAR=10
      IF(CHPAR.EQ.'PAIR'  )ITPAR=11
      IF(CHPAR.EQ.'COMP'  )ITPAR=12
      IF(CHPAR.EQ.'PHOT'  )ITPAR=13
      IF(CHPAR.EQ.'PFIS'  )ITPAR=14
      IF(CHPAR.EQ.'DRAY'  )ITPAR=15
      IF(CHPAR.EQ.'ANNI'  )ITPAR=16
      IF(CHPAR.EQ.'BREM'  )ITPAR=17
      IF(CHPAR.EQ.'HADR'  )ITPAR=18
      IF(CHPAR.EQ.'MUNU'  )ITPAR=19
      IF(CHPAR.EQ.'DCAY'  )ITPAR=20
      IF(CHPAR.EQ.'LOSS'  )ITPAR=21
      IF(CHPAR.EQ.'MULS'  )ITPAR=22
      IF(CHPAR.EQ.'RAYL'  )ITPAR=23
      IF(CHPAR.EQ.'GHCOR1')ITPAR=26
      IF(CHPAR.EQ.'GHCOR2')ITPAR=27
      IF(CHPAR.EQ.'GHCOR3')ITPAR=28
      IF(CHPAR.EQ.'GHCOR4')ITPAR=29
      IF(CHPAR.EQ.'BIRK1' )ITPAR=27
      IF(CHPAR.EQ.'BIRK2' )ITPAR=28
      IF(CHPAR.EQ.'BIRK3' )ITPAR=29
      IF(CHPAR.EQ.'LABS' ) ITPAR=31
      IF(CHPAR.EQ.'SYNC' ) ITPAR=32
      IF(CHPAR.EQ.'STRA' ) ITPAR=33
      IF(ITPAR.NE.0)THEN
         Q(JTMN+ITPAR)=PARVAL
         IF(ITPAR.EQ.21)THEN
            KLOSS=PARVAL+0.001
            IF(KLOSS.EQ.3.OR.KLOSS.EQ.1)Q(JTMN+15)=1.
         ENDIF
      ELSE
         WRITE(CHMAIL,1000)ITMED,CHPAR
         CALL GMAIL(0,0)
      ENDIF
      GO TO 99
C
  90  WRITE(CHMAIL,2000)ITMED
      CALL GMAIL(0,0)
C
 1000 FORMAT(' ***** GSTPAR error for tracking medium ',
     +  I3,' Tracking parameter ',A,'  not defined ***** ')
 2000 FORMAT(' ***** GSTPAR error. Tracking medium NR ',
     +  I3,' not defined ***** ')
  99  CONTINUE
      END
 
+DECK,GXSI
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      FUNCTION GXSI (Z)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  COMPUTE SCREENING FACTOR   FOR PAIR PRODUCTION AND BREM       *
C.    *  REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78              *
C.    *                        FORMULA 2.7.22                          *
C.    *                                                                *
C.    *    ==>Called by : GSMIXT                                       *
C.    *       Author    M.Maire *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DATA AL183  , AL1440 / 5.20948 , 7.27239 /
      ALZ  = LOG(Z)/3.
      GXSI  = (AL1440 - 2*ALZ) / (AL183 - ALZ - GFCOUL(Z))
      END
+DECK,GHMIX
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GHMIX(A, W, N, AEFF)
C
C     ******************************************************************
C     *                                                                *
C     *   Works out an effective atomic weight AEFF for a material     *
C     * with N elements of atomic weight A(I) in proportion W(I) by    *
C     * weight.  The criterion is that the hadronic interaction        *
C     * length of a 5 GeV/c pion is correct.  Errors on the calculated *
C     * hadronic interaction length for other momenta and other        *
C     * particles in GEANT version 3.04 are less than 1% in most cases.*
C     * For details see Memorandum OPAL/0037N/JA/md, ref. Hadron       *
C     * Milestone 84/003, Calculation of Hadronic Interaction Lengths  *
C     * for Mixtures.                                                  *
C.    *                                                                *
C.    *    ==>Called by : GSMIXT                                       *
C.    *       Author    J.Allison  *********                           *
C     *                                                                *
C     ******************************************************************
C
+SEQ,GCUNIT
      DIMENSION A(N), W(N)
C.
C.    ------------------------------------------------------------------
C.
C         Work out PINT which is proportional to the interaction
C         probability.  Also work out the mean atomic weight, i.e. that
C         weighted by proportion by numbers, as starting value for
C         iterative method of finding AEFF.
C
      PINT   = 0.
      AINV   = 0.
      WTOT   = 0.
      DO 10 I = 1, N
         PINT   = PINT + W(I) * GHSIGM(5., 8, A(I)) / A(I)
         AINV   = AINV + W(I) / A(I)
         WTOT   = WTOT + W(I)
  10  CONTINUE
C
      IF ( ABS ( WTOT - 1. ) .GT. 0.01 ) GO TO 98
C
C         Work out AEFF which gives PINT for 5 GeV/c pion.
C         (This is a short Newton's method loop.)
C
      AEFF   = 1. / AINV
      PNEW   = GHSIGM ( 5., 8, AEFF ) / AEFF
      DA     = 1.
      ITER   = 0
   20 CONTINUE
      ITER   = ITER + 1
      AEFF   = AEFF + DA
      POLD   = PNEW
      DAOLD  = DA
      PNEW   = GHSIGM ( 5., 8, AEFF ) / AEFF
      DP     = PNEW - POLD
      DA     = (PINT - PNEW ) * DAOLD / DP
      IF ( ( ITER .GT. 1 ) .AND. ( ABS ( DA ) .GT. ABS ( DAOLD ) ) )
     +                            GO TO 97
      IF ( ABS ( DA ) .GT. 0.01 ) GO TO 20
C
      RETURN
C
C            Error conditions.
C
  97  CONTINUE
      WRITE (CHMAIL,197)
      CALL GMAIL(0,0)
 197  FORMAT ( ' ***** GHMIX : ',
     +'HADRONIC INTERACTION MIXTURE ROUTINE NOT CONVERGING')
      RETURN
C
  98  CONTINUE
      WRITE (CHMAIL,198) WTOT
      CALL GMAIL(0,0)
 198  FORMAT ( ' ***** GHMIX : ',
     +'FRACTIONS BY WEIGHT OF MIXTURES DO NOT ADD UP TO 1',F10.4)
      END
+PATCH,GHITS
+DECK,DOCGHITS,IF=DOC
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*           Introduction to the Detector Response package              *
*           ---------------------------------------------              *
*                                                                      *
*                                                                      *
* THE DETECTOR RESPONSE PACKAGE                                        *
*                                                                      *
* In the context of GEANT3:                                            *
*                                                                      *
* - a hit is  the user defined 'quantum of  information' recorded at   *
*   tracking  time to  keep  track of  the  interaction between  one   *
*   particle  and  a  given  sensitive  detector,  and  regarded  as   *
*   necessary to compute the digitisations later.                      *
*                                                                      *
* - a  digitisation is  the  user defined  'quantum of  information'   *
*   simulating  the  response of  a  given  detector element,  after   *
*   tracking  of a  complete event.                                    *
*                                                                      *
*  The detector response package consists  of tools to store in, and   *
* retrieve or print from, the  data structures JSET, JHITS and JDIGI   *
* the information  relevant to  the hits  and digitisations.   A few   *
* subroutines which  may help the  user to  solve some of  the usual   *
* problems of  digitisation in simple  detectors have been  added to   *
* the package,  e.g. the intersection of  a track with a  plane or a   *
* cylinder  and  the  digitisation  of conventional  drift  and  MWP   *
* chambers.                                                            *
*  For complex  set-ups with different  types of detectors  the user   *
* has normally  to define several  types of hits  and digitisations.   *
* In addition to the hits generated  by all particles of the current   *
* event,   computing  the   digitisations   requires  usually   some   *
* information about the intrinsic characteristics and performance of   *
* the detectors.                                                       *
*  The information to be recorded  for the hits and digitisations is   *
* highly  experiment dependent,  therefore only  a framework  can be   *
* proposed  to  store  it.   The solution  adopted  here  should  be   *
* satisfactory  for most  of  the applications.   Feedback from  the   *
* users is needed and will be welcome.                                 *
*  Two remarks can be made:                                            *
*                                                                      *
* - the stability of the information to be stored is usually reached   *
*   much earlier for the hits than for the digitisations.  Therefore   *
*   the user  may save computing  time by designing  an intermediate   *
*   event output at the hits level.                                    *
* - the scheme proposed for storing  the digitisations should in any   *
*   case be considered  as an intermediate stage,   a reshuffling of   *
*   the data  being necessary  if the  user wants  to simulate  more   *
*   closely the specific format of the real data acquisition system.   *
*                                                                      *
* SETS AND DETECTORS                                                   *
*                                                                      *
* The reader is assumed to be  familiar with the way the geometrical   *
* setup is described [GEOM 001],  in particular with the concepts of   *
* logical volume structure  and of physical path  through the volume   *
* tree.                                                                *
*  The  user  is  required  to  classify  into  sets  all  sensitive   *
* detectors for which  storing the hits in the  data structure JHITS   *
* is wanted.                                                           *
*  The 4-character names  which identify the sets  are user defined,   *
* and the list of sets which the  user wants to activate for a given   *
* run  can be  entered  through the  data card  SETS.   The user  is   *
* entirely  free to  group  together,  in one  or  in several  sets,   *
* detectors  of   the  same  type   or  of  different   types.   For   *
* convenience, it is  recommended to have at least one  set for each   *
* main   component  of   the   setup,   e.g.  hadron   calorimeters,   *
* electromagnetic calorimeters, vertex chamber, etc.                   *
*   A detector  can be  declared as  sensitive through  the tracking   *
* medium  parameter  ISVOL,  and  allocated to  a  set  through  the   *
* subroutine GSDET.   Currently, the active sets  and detectors have   *
* to be  redefined for every run.   Tools will be provided  later to   *
* read in part  or the whole of the information  from a previous run   *
* and  to  update the  relevant  structures  according to  the  user   *
* requirements.                                                        *
*   Each (logical) detector is identified by the 4-character name of   *
* the corresponding volume.  As a  given volume may describe several   *
* similar  detectors   of  the   physical  setup,   some  additional   *
* information is needed for associating  correctly the hits with the   *
* physical detectors.  The user has  to enter the (shortest) list of   *
* volume names,  the vector NAMESV, which  permits identification of   *
* the  path through  the  physical  tree, even  in  the presence  of   *
* multiple copies at  the volume level or at any  lower level in the   *
* tree.   The  identification  will  be  achieved  when  needed,  by   *
* specifying a list  of volume numbers, the vector NUMBV,  in one to   *
* one  correspondence with  the above  list of  volume names.   This   *
* list,  after  packing,  will  constitute  the  identifier  of  the   *
* physical detector.                                                   *
*                                                                      *
* THE BASIC USER TOOLS                                                 *
*                                                                      *
* The  data structure  JSET is  built through  calls to  the routine   *
* GSDET  which  allocates  detectors   to  sets  and  defines  their   *
* parameters,  and  to the  auxiliary  routines  GSDETH, GSDETD  and   *
* GSDETU which  store respectively in  the structure JSET,  for each   *
* logical detector separately:                                         *
*                                                                      *
* - the parameters required  for the storage of the  hit elements in   *
*   the  data  structure JHITS,  such  as  the packing  and  scaling   *
*   conventions.                                                       *
*                                                                      *
* - the parameters required for the  storage of the digitisations in   *
*   the structure JDIGI,  such as the packing  conventions. the user   *
*   parameters, which  may consist,  for instance, of  the intrinsic   *
*   detector characteristics needed for computing the digitisations.   *
*                                                                      *
*  To  permit storage  of more  than  one type  of hit  for a  given   *
* sensitive  detector, detector  'aliases'  can  be defined  through   *
* calls  to  the routine  GSDETA.   They  are  entered in  the  JSET   *
* structure  as  additional  detectors, with  the  same  geometrical   *
* characteristics  as the  original  one.  Then,  the  user has  the   *
* possibility to  call the  appropriate routines GSDETH,  GSDETD and   *
* GSDETU.                                                              *
*  During  the   tracking,  for  each  step   inside  the  sensitive   *
* detectors, under control of the subroutine GUSTEP, the hits can be   *
* stored in the data structure  JHITS with the subroutine GSAHIT (or   *
* GSCHIT,  more  appropriate for  calorimetry).   For  each hit  the   *
* information consists of:                                             *
*                                                                      *
* - the reference to the track in the structure JKINE,                 *
* - the packed identifier of the physical detector, and                *
* - the packed data for the different elements of the hit.             *
*                                                                      *
*  When  the tracking  has been  completed for  the whole  event the   *
* digitisations can be computed in  the user subroutine GUDIGI which   *
* may  extract the  hits with  the subroutine  GFHITS and  store the   *
* digitisations  in the  data structure  JDIGI, with  the subroutine   *
* GSDIGI.   For each  digitisation the  information should  at least   *
* consist of:                                                          *
*                                                                      *
* - the reference to the track(s),                                     *
* - the packed identifier of the physical detector, and                *
* - the packed data for the digitisation itself.                       *
*                                                                      *
* RETRIEVAL OF GEOMETRICAL INFORMATION                                 *
*                                                                      *
*  The packed  identifier of as  physical detector stored a  part of   *
* the hit  (or digitisation) information, is  returned (unpacked) by   *
* the routines GFHITS  or GFDIGI which extract  the information from   *
* the JHITS  or JDIGI structures,  and may  be used to  retrieve the   *
* identity and geometrical characteristics of the given detector.      *
*   At  the  moment this  is  automatized  through  the use  of  the   *
* routines GFPATH  (which assumes that the  sensitive detectors have   *
* been declared  through the routine  GSDETV, not GSDET)  and GLVOLU   *
* which fills the common /GCVOLU/.                                     *
*   GFPATH prepares the lists LNAM  and LNUM required by the routine   *
* GLVOLU [GEOM 001].                                                   *
*   Worth  is in  progress in  this area  and might  lead to  a more   *
* transparent approach.  Therefore, the  routines GSDETV, GGDETV and   *
* GFPATH  and  their action  on  the  structure  JSETS will  not  be   *
* documented in more detail now.                                       *
*                                                                      *
************************************************************************
+DECK,GCDERR
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GCDERR (ICD,ERP,ERS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       ROUTINE TO CALCULATE THE ERROR ON THE CURRENT DIVISION   *
C.    *       INFORMATION AS OBTAINED BY "GCDRIF"                      *
C.    *                                                                *
C.    *       INPUT:  ICD = DIGITIZED CURRENT DIVISION INFORMATION     *
C.    *                     ( 0 ... 1000 )                             *
C.    *               ERP = VARIANCE OF GAUSSIAN DISTRIBUTED PEDESTAL  *
C.    *                     ERRORS ON THE MEASURED PULSE HEIGHTS       *
C.    *                     RELATIVE TO THE SUM OF THE PULSE HEIGHTS   *
C.    *               ERS = VARIANCE OF GAUSSIAN DISTRIBUTED SLOPE     *
C.    *                     ERRORS ON THE MEASURED PULSE HEIGHTS       *
C.    *                     RELATIVE TO EACH PULSE HEIGHT              *
C.    *       OUTPUT: ICD = VALUE UPDATED ACCORDING TO RANDOM ERRORS   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Author    D.Mitaroff  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      COMMON  /GCYDR/ ZL
      DIMENSION RNDM(4)
C
      Z = ICD
C
C---- CALCULATE PEDESTAL ERRORS FOR VARIANCE BEING 1.
      CALL GRNDM(RNDM,4)
*          call rannor(eps1,eps2)
      RY=RNDM(1)
      RZ=RNDM(2)
      RX=6.283185*RZ
      A1=SQRT(-2.*LOG(RY))
      EPS1=A1*SIN(RX)
      EPS2=A1*COS(RX)
      DZP = - EPS1 * Z + EPS2 * (ZL - Z)
C
C---- CALCULATE SLOPE ERRORS FOR VARIANCE BEING 1.
*          call rannor(eps1,eps2)
      RY=RNDM(3)
      RZ=RNDM(4)
      RX=6.283185*RZ
      A1=SQRT(-2.*LOG(RY))
      EPS1=A1*SIN(RX)
      EPS2=A1*COS(RX)
      DZS = (EPS2 - EPS1) * Z * (ZL - Z) / ZL
C
C---- CALCULATE NEW VALUE OF ICD FOR VARIANCES ERP, ERS.
      Z = Z + ERP * DZP + ERS * DZS
      IF (Z .LT. 0.)   Z = 0.
      IF (Z .GT. ZL)   Z = ZL
C
      ICD = Z
C
      END
+DECK,GCDRIF
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE  GCDRIF (RADD,ZMIN,ZMAX,DETREP,HITREP,IOUT)
C.
C.    **************************************************************************
C.    *                                                                        *
C.    *              Digitisation of Drift-  Chambers                          *
C.    *              --------------------------------                          *
C.    *                                                                        *
C.    *   Digitisation routine for a cylindrical drift chamber.                *
C.    * RADD      radius of cylinder in cm                                     *
C.    * ZMIN      z of lower end of cylinder                                   *
C.    * ZMAX      z of upper end of "                                          *
C.    * DETREP(1) number of wires                                              *
C.    * DETREP(2) wire spacing in PHI (radians)                                *
C.    * DETREP(3) cosine of wire angle                                         *
C.    * DETREP(4) sine of wire angle (signed like dphi/dz)                     *
C.    * DETREP(5) dphi/dz along wire                                           *
C.    * DETREP(6)  phi of point with z=0 on wire 1                             *
C.    * DETREP(7) drift velocity (cm/nsec)                                     *
C.    * DETREP(8) quantity describing the drift angle                          *
C.    *           if.ne.0 ==> user routine GUDTIM                              *
C.    * HITREP(1) phi coordinate of intersection                               *
C.    * HITREP(2) z coordinate                                                 *
C.    * HITREP(3) dphi/dr                                                      *
C.    * HITREP(4) dz/dr                                                        *
C.    * IOUT(1)   wire number (1..NWI with  increasing phi)  (-1 for           *
C.    *           bad DETREP parameters)                                       *
C.    * IOUT(2)   drift time (nsec) (+/- for phi(hit)>/< phi(wire)             *
C.    * IOUT(3)   digitised current division information (rel.  pos.           *
C.    *           along wire of charge) (per mille)                            *
C.    * IOUT(4)   amount of charge deposited to wire                           *
C.    * Coordinate systems along wire                                          *
C.    *     I.             Charge                   I.                         *
C.    *     .              |                        .                          *
C.    *     |              .                        |                          *
C.    *     =========================================  SENSE WIRE              *
C.    * ...................................................> Z (cm)            *
C.    *     Z              Z.                       Z.                         *
C.    *      L                                                                 *
C.    * ...............................................> X (arbitrary scale)   *
C.    *     0              X.                       L                          *
C.    *           X.                  (L-X.)                                   *
C.    * The scaling used is such that L . 1000.                                *
C.    * Knowing the position Z. of the deposit of charge,                      *
C.    *            Z.-ZL                                                       *
C.    *    X.                          =                           L           *
C.    * .          .....                                                       *
C.    *            Z.-ZL                                                       *
C.    * This information is stored into IOUT(3).                               *
C.    *   Routine to  calculate the  error on  the current  division           *
C.    * information as obtained by "GCDRIFT".                                  *
C.    * ICD       digitized     current     division     information           *
C.    *           (0 ... 1000)                                                 *
C.    * ERP       variance of Gaussian  distributed pedestral errors           *
C.    *           on the measured pulse heights  relative to the sum           *
C.    *           of the pulse heights                                         *
C.    * ERS       variance of  Gaussian distributed slope  errors on           *
C.    *           the measured  pulse heights  relative to  the each           *
C.    *           pulse heights                                                *
C.    *   Here we  assume that X.  has been determined  by measuring           *
C.    * the pulse heights I., I. with some statistical errors.                 *
C.    * X.   is then given by the formula                                      *
C.    *     X. = L . I./I.   with  I. . I.+I.                                  *
C.    * and its error is determined by                                         *
C.    *     .X. = -(X./I.) .I. + (L-X./I.) .I.                                 *
C.    * with the errors on measuring the pulse heights                         *
C.    *      .I. = .. + ...I.                                                  *
C.    *      .I. = .. + ...I.                                                  *
C.    * ..,  .. are of dimension  (I)  and represent the "pedestral"           *
C.    * errors;                                                                *
C.    * .., .. are the "slope" errors.                                         *
C.    * All  are   assumed  to  be  distributed   independently  (no           *
C.    * correlations), randomly and Gaussian around zero. This gives           *
C.    * the final result                                                       *
C.    *           ..      ..                  X.(L-X.)                         *
C.    *   .X. = - .. X. + .. (L-X.) + (..-..) ........                         *
C.    *           I.      I.                     L                             *
C.    *         ..................   .................                         *
C.    *               "pedestal"          "slope"                              *
C.    * In  GCDERR,  the X. derived from GCDRIF is set to                      *
C.    *      X. = X. + .X.    (but 0 . X. . L)                                 *
C.    * using  ERP .....  variance for ./I.  ,  ../I.  distributions           *
C.    *        ERS .....  variance for .., ..  distributions.                  *
C.    *                                                                        *
C.    *    ==>Called by : <USER>, GUDIGI                                       *
C.    *       Author    D.Mitaroff *********                                   *
C.    *                                                                        *
C.    **************************************************************************
C.
      DIMENSION  DETREP(8), HITREP(4), IOUT(4)
+SEQ,GCONSP
C.
C.    -----------------------------------------------------------------
C.
      ZREL    = 1000.
      IOUT(1) = -1
      NWI = DETREP(1)
      WSP = DETREP(2)
      DVL = DETREP(7)
      IF (WSP .EQ. 0.)   GOTO 99
      IF (DVL .EQ. 0.)   GOTO 99
C
C---- CALCULATE WIRE NUMBER.
      FI = HITREP(1)
      ZZ = HITREP(2)
      FI0 = DETREP(6) + ZZ * DETREP(5)
      DFI = FI - FI0
   10 IF (DFI .GE. 0.)    GOTO 11
      DFI = DFI + TWOPI
      GOTO 10
   11 IF (DFI .LT. TWOPI)   GOTO 12
      DFI = DFI - TWOPI
      GOTO 11
   12 IW = DFI / WSP + 0.5
      DIS = DFI - IW * WSP
      IF (IW .EQ. NWI)   IW = 0
      IOUT(1) = IW + 1
C
C---- CALCULATE DRIFT TIME.
      DIS = DIS * RADD * DETREP(3)
      IF ( DETREP(8) .NE. 0. )   GOTO 2
      IOUT(2) = DIS / DVL
      GOTO 3
C
C---- DRIFT TIME BY USER ROUTINE.
    2 IOUT(2) = GUDTIM (DETREP,HITREP,IW+1,DIS)
C
C---- CALCULATE CURRENT DIVISION INFORMATION.
    3 Z0 = ZZ + DIS * DETREP(4)
      IF (Z0 .LT. ZMIN)   Z0 = ZMIN
      IF (Z0 .GT. ZMAX)   Z0 = ZMAX
      IOUT(3) = ZREL * (Z0 - ZMIN) / (ZMAX - ZMIN)
      IOUT(4) = 0
C.
  99  RETURN
      END
+DECK,GCMWPC
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GCMWPC (DETREP,HITREP,IOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Routine to compute one or  two digitisations produced by a   *
C.    * hit on a cylindrical MWPC.                                     *
C.    * DETREP(1) number of wires                                      *
C.    * DETREP(2) wire spacing (radians)                               *
C.    * DETREP(3) dtheta/dz along the wires                            *
C.    * DETREP(4) theta of a point on wire 1                           *
C.    * DETREP(5) z of a point on wire 1                               *
C.    * DETREP(6) gap width                                            *
C.    * HITREP(1) theta coordinate of intersection                     *
C.    * HITREP(2) z coordinate                                         *
C.    * HITREP(3) dtheta/dr                                            *
C.    * HITREP(4) dz/dr                                                *
C.    * IOUT(1)   wire number (-1-missing)                             *
C.    * IOUT(2)   cluster size                                         *
C.    * IOUT(3)   wire number of second cluster if any                 *
C.    * IOUT(4)   cluster size                                         *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Author    M.Hansroul  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
      DIMENSION HITREP(4), DETREP(6), IOUT(4)
+SELF,IF=-SINGLE
      DOUBLE PRECISION ONE
+SELF
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      IOUT(1) = - 1
      IOUT(3) = - 1
      ZS     = DETREP(2)
      IF (ZS.EQ.0.)                                   GO TO 99
C.
C.            COMPUTE WIRE NUMBER
C.
      HG     = .5 * DETREP(6)
      DT     = HG * HITREP(3)
      DZ     = HG * HITREP(4)
      T1     = HITREP(1) - DT
      T2     = HITREP(1) + DT
      Z1     = HITREP(2) - DZ
      Z2     = HITREP(2) + DZ
C
      Z0     = DETREP(5)
      DT     = DETREP(3)
      DZ     = Z1 - Z0
      T1     = T1 - DZ * DT
      DZ     = Z2 - Z0
      T2     = T2 - DZ * DT
      T0     = DETREP(4)
C
      T1     = MOD (ONE*T1,TWOPI)
      T2     = MOD (ONE*T2,TWOPI)
      T0     = MOD (ONE*T0,TWOPI)
      IF (T1.LT.0.) T1 = T1 + TWOPI
      IF (T2.LT.0.) T2 = T2 + TWOPI
      IF (T0.LT.0.) T0 = T0 + TWOPI
C
      NN     = 0
      W1     = (T1 - T0) / ZS
      IF (W1.LE.0.)THEN
         NN     = NN + 1
         W1     = W1 + TWOPI / ZS
      ENDIF
C
      W2     = (T2 - T0) / ZS
      IF (W2.LE.0.)THEN
         NN     = NN + 1
         W2     = W2 + TWOPI / ZS
      ENDIF
C
      W1     = W1 + 1.5
      W2     = W2 + 1.5
      IW1    = W1
      IW2    = W2
      NWIR   = DETREP(1)
      IF (NN.NE.1)THEN
C.
C.            1 CLUSTER
C.
         IWMIN  = MIN (IW1,IW2)
         IWMAX  = MAX (IW1,IW2)
         IF (IWMIN.GT.NWIR)                              GO TO 99
C
         IWMAX  = MIN (NWIR,IWMAX)
C
         IOUT(1) = IWMIN
         IOUT(2) = IWMAX - IWMIN + 1
      ELSE
C.
C.            SPECIAL CASE: SIGNAL ON WIRE 1
C.            AND ON WIRE 'NWIRES' --> 2 CLUSTERS
C.
         IW     = MIN (IW1,IW2)
         IW     = MIN (IW,NWIR)
         IOUT(1) = 1
         IOUT(2) = IW
         IW     = MAX (IW1,IW2)
         IF (IW.GT.NWIR)                                 GO TO 99
         IOUT(3) = IW
         IOUT(4) = NWIR - IW + 1
      ENDIF
C
  99  RETURN
      END
+DECK,GCUBS
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GCUBS(X,Y,D1,D2,A)
C.
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Calculates a cubic through P1,(-X,Y1),(X,Y2),P2          *
C.    *       where Y2=-Y1                                             *
C.    *        Y=A(1)+A(2)*X+A(3)*X**2+A(4)*X**3                       *
C.    *        The coordinate system is assumed to be the cms system   *
C.    *        of P1,P2.                                               *
C.    *                                                                *
C.    *    ==>Called by : GIPLAN,GICYL                                 *
C.    *       Author    H.Boerner  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
      REAL X,Y,D1,D2,A(4)
C.
C.
C.    ------------------------------------------------------------------
C.
C.
      IF (X.EQ.0.)                               GO TO 10
C
C
      FACT   = (D1 - D2) * 0.25
      A(1)   = - 1. * FACT * X
      A(3)   = FACT / X
      A(2)   = (6. * Y - (D1 + D2) * X) / (4. * X)
      A(4)   = ((D1 + D2)*X - 2.*Y) / (4.*X**3)
      RETURN
C
  10  A(1)   = 0.
      A(2)   = 1.
      A(3)   = 0.
      A(4)   = 0.
      END
+DECK,GFDET
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFDET(IUSET,IUDET,NV,NAMESV,NBITSV,IDTYPE
     +                ,NWHI,NWDI,ISET,IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       returns volume parameters for detector IUDET of set IUSET*
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * NV        number of volume descriptors                         *
C.    * NAMESV    vector of NV volume descriptors (4 characters)       *
C.    * NBITSV    vector of  NV bit numbers  for packing  the volume   *
C.    *           numbers                                              *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for the primary allocation of HITS   *
C.    *           banks                                                *
C.    * NWDI      number of words for the primary allocation of DIGI   *
C.    *           banks when first allocation not sufficient           *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The vector NAMESV (length NV)  contains the list of volume   *
C.    *   names which  permit the  identification of  every physical   *
C.    *   detector with detector name IUDET.    [See example in HITS   *
C.    *   110].                                                        *
C.    * - Each  element of  the vector  NBITSV (length  NV)  is  the   *
C.    *   number  of  bits  used  for  packing  the  number  of  the   *
C.    *   corresponding volume,  when building the packed identifier   *
C.    *   of a given physical detector.                                *
C.    * - Vectors NAMESV and NBITSV must be dimensionned at least      *
C.    *   to NV in the calling routine.                                *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun , M.Maire *********                     *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      DIMENSION NBITSV(1)
      CHARACTER*4 NAMESV(1),IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      ISET=0
      IDET=0
C
C             Check if detector IUDET has been defined
C
      IF (JSET.LE.0) GO TO 90
      NSET = IQ(JSET-1)
      IF (NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET.EQ.0) GO TO 90
      JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.LE.0) GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF (IDET.EQ.0) GO TO 95
      JD=LQ(JS-IDET)
      NV=IQ(JD+2)
      NWHI=IQ(JD+7)
      NWDI=IQ(JD+8)
C
      IF(NV.GT.0)THEN
         DO 10 I=1,NV
            CALL UHTOC(IQ(JD+2*I+ 9),4,NAMESV(I),4)
            NBITSV(I)=IQ(JD+2*I+10)
  10     CONTINUE
      ENDIF
C
      CALL GFATT(IUDET,'DTYP',IDTYPE)
      GO TO 99
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDET ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDET ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,GFDETA
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFDETA (IUSET,IUALI,IALI)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Returns the position IALI of the detector alias IUALI      *
C.    *                                                                *
C.    *    ==>Called by : <USER>,                                      *
C.    *       Author    F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      CHARACTER*4 IUSET,IUALI
C
C.    ------------------------------------------------------------------
C.
      IF (JSET.LE.0) GO TO 90
      NSET = IQ(JSET-1)
      IF (NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET.EQ.0) GO TO 90
      JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.LE.0) GO TO 90
      CALL GLOOK(IUALI,IQ(JS+1),NDET,IALI)
      IF (IALI.EQ.0) GO TO 95
      GO TO 99
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETA ERROR FOR SET ',A4)
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUALI
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETA ERROR FOR SET ',A4,' ALIAS ',A4,
     + ' NOT FOUND')
C
   99 RETURN
      END
+DECK,GFDETD
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFDETD(IUSET,IUDET,ND,NAMESD,NBITSD)
C.
C.    ******************************************************************
C.    *                                                                *
C.    * Returns digitisation  parameters for  detector IUDET  of set   *
C.    * IUSET.                                                         *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ND        number of elements per digitisation                  *
C.    * NAMESD    the  ND   variable  names  for   the  digitisation   *
C.    *           elements                                             *
C.    * NBITSD    the  ND  bit  numbers  for  packing  the  variable   *
C.    *           values.                                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      DIMENSION NBITSD(1)
      CHARACTER*4 IUSET,IUDET,NAMESD(1)
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 95
      JD=LQ(JS-IDET)
      JDD=LQ(JD-2)
      ND=IQ(JD+6)
C
      IF(ND.GT.0)THEN
         DO 10 I=1,ND
            CALL UHTOC(IQ(JDD+2*I-1),4,NAMESD(I),4)
            NBITSD(I)=IQ(JDD+2*I )
  10     CONTINUE
      ENDIF
      GO TO 99
C
C              Error
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETD ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETD ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,GFDETH
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFDETH(IUSET,IUDET,NH,NAMESH,NBITSH,ORIG,FACT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Returns hit parameters for detector IUDET of set IUSET.      *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * NH        number of elements per hit                           *
C.    * NAMESH    the NH variable names for the hit elements           *
C.    * NBITSH    the NH bit numbers for packing the variable values   *
C.    * ORIG      The quantity packed in the structure JHITS for the   *
C.    *           Ith variable is a  positive integer with NBITSH(I)   *
C.    *           bits and such that                                   *
C.    * FACT      IVAR(I) = (VAR(I)+ORIG(I))*FACT(I)                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun ,M.Maire *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      DIMENSION NBITSH(1),ORIG(1),FACT(1)
      CHARACTER*4 IUSET,IUDET,NAMESH(1)
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 95
      JD=LQ(JS-IDET)
      JDH=LQ(JD-1)
      NH=IQ(JD+4)
C
      IF(NH.GT.0)THEN
         DO 10 I=1,NH
            CALL UHTOC(IQ(JDH+4*I-3),4,NAMESH(I),4)
            NBITSH(I)=IQ(JDH+4*I-2)
            ORIG(I)  = Q(JDH+4*I-1)
            FACT(I)  = Q(JDH+4*I )
  10     CONTINUE
      ENDIF
      GO TO 99
C
C              Error
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETH ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETH ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,GFDETU
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFDETU(IUSET,IUDET,NUPAR,NW,UPAR)
C.
C.    *******************************************************************
C.    *                                                                 *
C.    *  Return in UPAR the first NUPAR user parameters of detector     *
C.    *  IUDET. NW is the total number of parameters(output), or zero   *
C.    *  if an  error occured.                                          *
C.    *                                                                 *
C.    *    ==>Called by : <USER>                                        *
C.    *       Author    W.Gebel  *********                              *
C.    *                                                                 *
C.    *******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      DIMENSION UPAR(1)
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      NW=0
      NSET=IQ(JSET-1)
      IF(NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,IS)
      IF(IS.LE.0) GO TO 90
      JS=LQ(JSET-IS)
      ND=IQ(JS-1)
      IF(ND.LE.0) GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),ND,ID)
      IF(ID.LE.0) GO TO 95
      JD=LQ(JS-ID)
      JU=LQ(JD-3)
      IF(JU.NE.0)THEN
         NW=IQ(JU-1)
         IF(NUPAR.GT.0) CALL UCOPY(Q(JU+1),UPAR(1),NUPAR)
      ENDIF
      GO TO 99
C
C              Error
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETU ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETU ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,GFDIGI
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFDIGI(IUSET,IUDET,NTDIM,NVDIM,NDDIM,NDMAX,NUMVS
     +,                 LTRA,NTRA,NUMBV,KDIGI,NDIGS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *   Returns  the   digitisations  for   the  physical   volume   *
C.    * specified by the  list NUMVS with generic  volume name IUDET   *
C.    * belonging to set IUSET.                                        *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user    detector   identifier    (name   of    the   *
C.    *           corresponding sensitive volume)                      *
C.    * NTDIM     1st  dimension of  LTRA  (max.   number of  tracks   *
C.    *           contributing)                                        *
C.    * NVDIM     1st  dimension of  NUMVS,  NUMBV  (usually =NV, the  *
C.    *           number of volume descriptors which permit to iden-   *
C.    *           tify a given detector, possibly smaller than NV)     *
C.    * NDDIM     1st dimension of KDIGI (argument ND of GSDETD)       *
C.    * NDMAX     is  the  maximum  number of  digitisations  to  be   *
C.    *           returned                                             *
C.    * NUMVS     is a  1-Dim array that  must contain on  input the   *
C.    *           geometric  path  of  the  detector  volume  to  be   *
C.    *           selected.                                            *
C.    *           All 0  interpreted as  'all physical  volumes with   *
C.    *           generic name IUDET'                                  *
C.    * LTRA      is a 2-Dim  array that will contain  on output for   *
C.    *           each digitisation the numbers  of the tracks which   *
C.    *           have produced it                                     *
C.    * NTRA      is a 1-Dim  array that will contain  on output for   *
C.    *           each  digitisation  the  total  number  of  tracks   *
C.    *           contributing.                                        *
C.    *           In case this  number is greater than  NTDIM,  only   *
C.    *           the  first  NTDIM  corresponding   tracks  can  be   *
C.    *           returned on LTRA                                     *
C.    * NUMBV     is a 2-Dim  array that will contain  on output for   *
C.    *           each digitisation the list of volume numbers which   *
C.    *           identify each physical volume                        *
C.    * KDIGI     is  a 2-Dim  array  that  will contain  the  NDIGI   *
C.    *           digitisations                                        *
C.    * NDIGI     is  the  total  number of  digitisations  in  this   *
C.    *           detector.                                            *
C.    *           In  case  the  total number  of  digitisations  is   *
C.    *           greater than NDMAX,   NDIGI is set to  NDMAX+1 and   *
C.    *           only NDMAX digitisations are returned                *
C.    *     -  KDIGI(1,I)  =  digitisation type  1 for  digitisation   *
C.    *   number I                                                     *
C.    *     - NUMBV(1,I) = volume number 1 for digitisation number I   *
C.    *     -  LTRA (1,I)   =  first  track number  contributing  to   *
C.    *   digitisation number I                                        *
C.    *   In the calling  routine,  the arrays LTRA,   NTRA,  NUMVS,   *
C.    * NUMBV, KDIGI must be dimensioned to:                           *
C.    *    LTRA (NTDIM,NDMAX)                                          *
C.    *    NTRA (NDMAX)                                                *
C.    *    NUMVS(NVDIM)                                                *
C.    *    NUMBV(NVDIM,NDMAX)                                          *
C.    *    KDIGI(NDDIM,NDMAX)                                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    W.Gebel  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
      PARAMETER (NVMAX=20)
      DIMENSION NUMVT(NVMAX),NUMVS(NVDIM),NUMBV(NVDIM,1)
      DIMENSION LTRA(NTDIM,1),NTRA(1),KDIGI(NDDIM,1)
      EQUIVALENCE (WS(1),NUMVT(1))
      CHARACTER*4 IUSET,IUDET
C.
C.    --------------------------------------------------------------------------
C.
C             Find if selected set, detector exists
C
      NDIGS=0
      IF(JDIGI.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 999
C
      JS=LQ(JSET-ISET)
      JDI=LQ(JDIGI-ISET)
      IF(JS.LE.0)GO TO 999
      IF(JDI.LE.0)GO TO 999
      NDET=IQ(JS-1)
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.EQ.0)GO TO 999
C
      JD=LQ(JS-IDET)
      JDID=LQ(JDI-IDET)
      IF(JDID.LE.0)GO TO 999
      JDDI=LQ(JD-2)
C
      ILAST=IQ(JDI+IDET)
      IF(ILAST.EQ.0)GO TO 999
      NV=IQ(JD+2)
      ND=IQ(JD+6)
C
C
C             Loop on all digits
C
C
      IDIG=0
      I=0
      NWDI=0
C
   10 CONTINUE
      I=I+NWDI
      IF(I.GE.ILAST)GO TO 110
      NWDI=IQ(JDID+I+1)
      NK=2
C
      NTRM1= IBITS(IQ(JDID+I+NK),0,16)
      NTRT = NTRM1+1
      NWTR = NTRT/2+1
      NK   = NK+NWTR
C
C             Find the selected volume
C             (if NO volumes exist take ALL digits)
C
      IF(NV.GT.0)THEN
         K=1
         DO 40 IV=1,NV
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   K=1
                   NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IQ(JDID+I+NK)
               IF(IV.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IBITS(IQ(JDID+I+NK),K-1,NB)
               K=K+NB
            ENDIF
            IF(IV.LE.NVDIM)THEN
               IF(NUMVS(IV).NE.0)THEN
                  IF(NUMVS(IV).NE.NUMVT(IV))GO TO 10
               ENDIF
            ENDIF
   40    CONTINUE
         NK=NK+1
      ENDIF
C
C
C
C ========>   Now store number of tracks and volume numbers,
C             and fetch track numbers and digits
C
      IDIG=IDIG+1
      IF(IDIG.GT.NDMAX)GO TO 110
C
      NTRA(IDIG)=NTRT
      NVMIN=MIN(NV,NVDIM)
      CALL VZERO (NUMBV(1,IDIG),NVDIM)
      CALL UCOPY (NUMVT(1),NUMBV(1,IDIG),NVMIN)
C
C             Get track numbers
C
      MK=NK
      NK=2
      IF(NTRT.GT.0)THEN
         IF(NTRM1.GE.1)THEN
            DO 54 ITR=1,NTRM1,2
               IF(ITR.LE.NTDIM)THEN
                  LTRA(ITR ,IDIG)=IBITS(IQ(JDID+I+NK),16,16)
               ENDIF
               NK=NK+1
               IF(ITR.LT.NTDIM)THEN
                  LTRA(ITR+1,IDIG)=IBITS(IQ(JDID+I+NK), 0,16)
               ENDIF
   54       CONTINUE
         ENDIF
         IF(NTRT.LE.NTDIM)THEN
           IF(MOD(NTRT,2).EQ.1)
     +               LTRA(NTRT,IDIG)=IBITS(IQ(JDID+I+NK),16,16)
         ENDIF
      ENDIF
      NK=MK
C
C             Get unpacked digits
C
      IF(ND.LE.0)GO TO 10
      K=1
      DO 90 ID=1,ND
         NB=IQ(JDDI+2*ID)
         IF(NB.LE.0)THEN
            IF(K.GT.1)THEN
                K=1
                NK=NK+1
            ENDIF
            IF(ID.LE.NDDIM)KDIGI(ID,IDIG)=IQ(JDID+I+NK)
            IF(ID.NE.ND)NK=NK+1
         ELSE
            IF(K+NB.GT.33)THEN
               K=1
               NK=NK+1
            ENDIF
            IF(ID.LE.NDDIM)KDIGI(ID,IDIG)=IBITS(IQ(JDID+I+NK),K-1,NB)
            K=K+NB
         ENDIF
  90  CONTINUE
C
      GO TO 10
C
 110  NDIGS=IDIG
C
 999  RETURN
      END
+DECK,GFHITS
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFHITS(IUSET,IUDET,NVDIM,NHDIM,NHMAX,ITRS,NUMVS
     +,                 ITRA,NUMBV,HITS,NHITS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *   Returns the  hits produced  by track ITRS  (if 0,   by all   *
C.    * tracks)  in the physical volume  specified by the list NUMVS   *
C.    * with generic volume name IUDET belonging to set IUSET.         *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user    detector   identifier    (name   of    the   *
C.    *           corresponding sensitive volume)                      *
C.    * NVDIM     1st dimension of NUMBV and NUMVS (usually =NV, the   *
C.    *           number of volume descriptors which permit to identify*
C.    *           a given detector, eventually smaller than  NV)       *
C.    * NHDIM     1st  dimension  of  array  HITS  (argument  NH  of   *
C.    *           GSDETH)                                              *
C.    * NHMAX     maximum number of hits to be returned                *
C.    * ITRS      number of  the selected  track.   If  ITRS=0,  all   *
C.    *           tracks are taken                                     *
C.    * NUMVS     is a  1-Dim array that  must contain on  input the   *
C.    *           geometric  path  of  the  detector  volume  to  be   *
C.    *           selected.    All 0  interpreted  as 'all  physical   *
C.    *           volumes with generic names IUDET'                    *
C.    * ITRA      is a 1-Dim  array that will contain  on output for   *
C.    *           each  hit  the  number  of  the  track  which  has   *
C.    *           produced it                                          *
C.    * NUMBV     2-Dim array that  will contain on output  for each   *
C.    *           hit the list of volume numbers which identify each   *
C.    *           physical volume.   Zeroed when no more volumes are   *
C.    *           stored                                               *
C.    * HITS      2-Dim array that will contain the NHITS hits         *
C.    * NHITS     returns the number of selected  hits.  In case the   *
C.    *           total number of hits is greater than NHMAX,  NHITS   *
C.    *           is set to NHMAX+1 and only NHMAX hits are returned   *
C.    *   - HITS(1,I)  is the element 1 for hit number I               *
C.    *   - NUMBV(1,I) is the volume number 1 for hit number I         *
C.    *   - ITRA(I)    is  the  track number  corresponding  to  hit   *
C.    * number I                                                       *
C.    *   In the calling routine the arrays NUMVS,  NUMBV,  HITS and   *
C.    * ITRA must be dimensioned to:                                   *
C.    *     NUMVS(NVDIM)                                               *
C.    *     NUMBV(NVDIM,NHMAX)                                         *
C.    *     HITS(NHDIM,NHMAX)                                          *
C.    *     ITRA(NHMAX)                                                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
      PARAMETER (NVMAX=20)
      DIMENSION NUMVT(NVMAX),NUMVS(NVDIM),NUMBV(NVDIM,1),ITRA(1)
      DIMENSION HITS(NHDIM,1)
      EQUIVALENCE (WS(1),NUMVT(1))
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
C             Find if selected set, detector exists
C
      NHITS=0
      IF(JHITS.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 999
C
      JS=LQ(JSET-ISET)
      JH=LQ(JHITS-ISET)
      IF(JS.LE.0)GO TO 999
      IF(JH.LE.0)GO TO 999
      NDET=IQ(JS-1)
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.EQ.0)GO TO 999
C
      JD=LQ(JS-IDET)
      JHD=LQ(JH-IDET)
      IF(JHD.LE.0)GO TO 999
      JDH=LQ(JD-1)
C
      ILAST=IQ(JH+IDET)
      IF(ILAST.EQ.0)GO TO 999
      NV=IQ(JD+2)
      NH=IQ(JD+4)
      NW=IQ(JD+1)+IQ(JD+3)+1
C
C
C             Loop on all hits
C
C
      IHIT=0
      DO 100 I=1,ILAST,NW
C
C             Find the selected track
C
      ITRT=IQ(JHD+I)
      IF(ITRS.NE.0 .AND. ITRS.NE.ITRT)GO TO 100
C
C             Find the selected volume
C             (if NO volumes exist take ALL hits)
C
      NK=1
      IF(NV.GT.0)THEN
         K=1
         DO 40 IV=1,NV
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   K=1
                   NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IQ(JHD+I+NK)
               IF(IV.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                 K=1
                 NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IBITS(IQ(JHD+I+NK),K-1,NB)
               K=K+NB
            ENDIF
            IF(IV.LE.NVDIM)THEN
               IF(NUMVS(IV).NE.0)THEN
                  IF(NUMVS(IV).NE.NUMVT(IV))GO TO 100
               ENDIF
            ENDIF
   40    CONTINUE
         NK=NK+1
      ENDIF
C
C
C
C ========>   Now store track number and volume numbers and fetch hits
C
      IHIT=IHIT+1
      IF(IHIT.GT.NHMAX)GO TO 110
C
      ITRA(IHIT)=ITRT
      NVMIN=MIN(NV,NVDIM)
      DO 55 J=1,NVDIM
  55  NUMBV(J,IHIT)=0
      DO 57 J=1,NVMIN
  57  NUMBV(J,IHIT)=NUMVT(J)
C
C             Get unpacked hits
C             Hits origin is shifted . Division by scale factor
C
      IF(NH.GT.0)THEN
      K=1
      DO 90 IH=1,NH
         NB=IQ(JDH+4*IH-2)
         IF(NB.LE.0)THEN
            IF(K.GT.1)THEN
                K=1
                NK=NK+1
            ENDIF
            KHIT=IQ(JHD+I+NK)
            NK=NK+1
         ELSE
            IF(K+NB.GT.33)THEN
               K=1
               NK=NK+1
            ENDIF
            KHIT=IBITS(IQ(JHD+I+NK),K-1,NB)
            K=K+NB
         ENDIF
         IF(IH.LE.NHDIM)THEN
            HITS(IH,IHIT)=FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
         ENDIF
  90  CONTINUE
      ENDIF
 100  CONTINUE
C
 110  NHITS=IHIT
C
 999  RETURN
      END
+DECK, GFNDIG.
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFNDIG (IUSET, IUDET, NDIGI)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GFNDIG (IUSET, IUDET, NDIGI*)                         *
C.    *                                                                *
C.    *   Returns the number of digits belonging to the detector IUDET *
C.    *   of set IUSET                                                 *
C.    *                                                                *
C.    *   IUSET    User set identifier                                 *
C.    *   IUDET    User detector identifier (name of the corresponding *
C.    *            sensivitive volume)                                 *
C.    *   NDIGI    returns the total number of digits                  *
C.    *                                                                *
C.    *   Called by : <USER>                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      CHARACTER*4     IUSET, IUDET
C.
C.    ------------------------------------------------------------------
*
* *** Find if selected set, detector exists
*
      NDIGI = 0
      IF (JDIGI.LE.0)   GO TO 999
      NSET  = IQ(JSET-1)
      CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
      IF (ISET.LE.0)    GO TO 999
*
      JS    = LQ(JSET-ISET)
      JDI   = LQ(JDIGI-ISET)
      IF (JS.LE.0)      GO TO 999
      IF (JDI.LE.0)     GO TO 999
      NDET  = IQ(JS-1)
      CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
      IF (IDET.LE.0)    GO TO 999
*
      JDID  = LQ(JDI-IDET)
      IF (JDID.LE.0)    GO TO 999
      ILAST = IQ(JDI+IDET)
*
      IF (ILAST.NE.0) NDIGI = IQ(JDID+ILAST)
*                                                             END GFNDIG
  999 CONTINUE
      END
+DECK, GFNHIT.
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFNHIT (IUSET, IUDET, NHITS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GFNHIT (IUSET, IUDET, NHITS*)                         *
C.    *                                                                *
C.    *   Returns the number of hits belonging to the detector IUDET   *
C.    *   of set IUSET                                                 *
C.    *                                                                *
C.    *   IUSET    User set identifier                                 *
C.    *   IUDET    User detector identifier (name of the corresponding *
C.    *            sensivitive volume)                                 *
C.    *   NHITS    returns the total number of hits                    *
C.    *                                                                *
C.    *   Called by : <USER>                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      CHARACTER*4     IUSET, IUDET
C.
C.    ------------------------------------------------------------------
*
* *** Find if selected set, detector exists
*
      NHITS = 0
      IF (JHITS.LE.0)   GO TO 999
      NSET  = IQ(JSET-1)
      CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
      IF (ISET.LE.0)    GO TO 999
*
      JS    = LQ(JSET-ISET)
      JH    = LQ(JHITS-ISET)
      IF (JS.LE.0)      GO TO 999
      IF (JH.LE.0)      GO TO 999
      NDET  = IQ(JS-1)
      CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
      IF (IDET.LE.0)    GO TO 999
*
      JD    = LQ(JS-IDET)
      JHD   = LQ(JH-IDET)
      IF (JHD.LE.0)     GO TO 999
      NFIX  = IQ(JD+1) + IQ(JD+3) + 1
      ILAST = IQ(JH+IDET)
*
      IF (ILAST.GT.0) NHITS = ILAST / NFIX
*                                                             END GFNHIT
  999 CONTINUE
      END
+DECK,GFPATH
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFPATH (ISET, IDET, NUMBV, NLEV, LNAM, LNUM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Return the lists of NLEV volume names (LNAM) and numbers  *
C.    *      (LNUM) which identify the path through the JVOLUM data    *
C.    *      structure for the volume corresponding to the detector    *
C.    *      at position IDET in set at position ISET identified by    *
C.    *      the list of node identifiers given in NUMBV.              *
C.    *                                                                *
C.    *      NLEV is expected to be greater than 1                     *
C.    *      and no checks are performed on the validity of ISET/IDET  *
C.    *      In case of user error NLEV returns with the value 0.      *
C.    *                                                                *
C.    *   ==> Called by : <USER>                                       *
C.    *         Author  F.Bruyant  **********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
      INTEGER  LNAM(*), LNUM(*), NUMBV(*)
C.
C.    -----------------------------------------------------------------
C.
      JS = LQ(JSET-ISET)
      JD = LQ(JS-IDET)
      NV = IQ(JD+2)
      IPJD = JD +10 +2*NV
      LNAM(1) = IQ(IPJD+1)
      LNUM(1) = 1
      NLEV = IQ(IPJD+2)
C
      NSOL = IQ(JD+9)
      IF (NSOL.EQ.1) THEN
C
C       Usual case
C
        I = 0
        DO 10 N = 2,NLEV
          IPJD = IPJD +2
          LNAM(N) = IQ(IPJD+1)
          LNUM(N) = 1
          IF (IQ(IPJD+2).LE.1) GO TO 10
          I = I +1
          LNUM(N) = NUMBV(I)
   10   CONTINUE
C
      ELSE IF (NSOL.GT.1) THEN
C
C       Case with multiple path
C
        IPSTO = IPJD
        DO 90 IS = 1,NSOL
          IPJDD = JD +8
          DO 30 I = 1,NV
            IPJDD = IPJDD +2
            IF (NUMBV(I).EQ.0)  GO TO 30
            IPJD = IPSTO
            DO 20 N = 2,NLEV
              IPJD = IPJD +2
              IF (IQ(IPJD+1).EQ.IQ(IPJDD+1))  GO TO 30
   20       CONTINUE
            GO TO 81
   30     CONTINUE
C
C         Fill LNAM,LNUM
C
          IPJD = IPSTO
          DO 40 N = 2,NLEV
            IPJD = IPJD +2
            LNAM(N) = IQ(IPJD+1)
            LNUM(N) = 1
   40     CONTINUE
          IPJDD = JD +8
          DO 60 I = 1,NV
            IPJDD = IPJDD +2
            IF (NUMBV(I).EQ.0)  GO TO 60
            IPJD = IPSTO
            DO 50 N = 2,NLEV
              IPJD = IPJD +2
              IF (IQ(IPJD+1).NE.IQ(IPJDD+1))  GO TO 50
              IF (NUMBV(I).GT.IQ(IPJD+2)) GO TO 991
              LNUM(N) = NUMBV(I)
              GO TO 60
   50       CONTINUE
   60     CONTINUE
          GO TO 999
C
   81     IF (IS.EQ.NSOL)  GO TO 991
          IPSTO = IPSTO +2*NLEV
          NLEV = IQ(IPSTO+2)
C
   90   CONTINUE
C
      ELSE
C
C       User error
C
        GO TO 991
C
      ENDIF
      GO TO 999
C
  991 NLEV = 0
      WRITE (CHMAIL, 1000) IQ(JD+9)
      CALL GMAIL(0,0)
C
 1000 FORMAT (' ***** GFPATH USER ERROR, IQ(JD+9)=',I2)
C
  999 RETURN
      END
+DECK,GGDETV.
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GGDETV (ISET, IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routine - to compute and store the list of volumes which    *
C.    *    permit to identify uniquely any detector volume specified   *
C.    *    by  the set number ISET, the detector number IDET and the   *
C.    *    corresponding list of volume copy numbers                   *
C.    *            - to compute and store the physical path(s) through *
C.    *    the JVOLUM data structure down to the given detector volume *
C.    *                                                                *
C.    *    ==>Called by : GHCLOS                                       *
C.    *         Author  F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCBANK.
+SEQ, GCFLAG.
+SEQ, GCNUM.
+SEQ, GCUNIT.
C.
      PARAMETER (NLVMAX=15,NSKMAX=20,NVMAX=20)
      INTEGER  IVOSK(NSKMAX,NLVMAX-1), LIMUL(NLVMAX), LINAM(NLVMAX)
     +,        LIST(2), NSK(NLVMAX-1)
      EQUIVALENCE (LINAM(1),WS(1)), (LIMUL(1),WS(NLVMAX+1)), (IVOSK(1,1)
     +,   WS(2*NLVMAX+1)), (NSK(1),WS((NSKMAX+2)*(NLVMAX-1)+3))
     +,   (LIST(1),WS((NSKMAX+3)*(NLVMAX-1)+3))
C.
C.         -------------------------------------------------------------
C.
      JS = LQ(JSET-ISET)
      JD = LQ(JS-IDET)
C
C     Check that JD bank has been created by GSDETV (not GSDET)
C      or has not been already processed.
C
      IF (IQ(JD+9).NE.-1) GO TO 999
      IQ(JD+9) = -2
      IHDET = IQ(JS+IDET)
      IF (IDEBUG.NE.0) THEN
         WRITE (CHMAIL, 1001) IHDET
         CALL GMAIL (0,0)
 1001    FORMAT (' GGDETV : Detector ',A4)
      ENDIF
C
C     Check that current detector is not an alias
C
      IALI = IQ(JD+10)
      IF (IALI.NE.0) GO TO 200
      NSOL = 0
      NV = 0
 
      NLIST = 0
      CALL VZERO (NSK, NLVMAX-1)
      NLEV = 1
      LINAM(1) = IHDET
      MULT1 = 1
   10 IVOS = IUCOMP (LINAM(NLEV), IQ(JVOLUM+1), NVOLUM)
C
C     Search for detector parents up to top of tree
C
   20 IF (IVOS.EQ.1) GO TO 60
C
      DO 40 IVO=1,NVOLUM
         IF (IVO.EQ.IVOS) GO TO 40
         JVO = LQ(JVOLUM-IVO)
         NIN = Q(JVO+3)
         IF (NIN.EQ.0) GO TO 40
         IF (NSOL.GT.0) THEN
C           Skip mother banks already found
            IF (IUCOMP (IVO, IVOSK(1,NLEV), NSK(NLEV)) .NE. 0) GO TO 40
         ENDIF
C
         IF (NIN.LT.0) THEN
C           Division case
            JDIV = LQ(JVO-1)
            IF (IFIX(Q(JDIV+2)).NE.IVOS) GO TO 40
            MULTI = ABS(Q(JDIV+3))
            IF (MULTI.EQ.0)  MULTI = 255
         ELSE
C           Position case
            MULTI = 0
            DO 30 IN=1,NIN
               JIN = LQ(JVO-IN)
               IF (IFIX(Q(JIN+2)).NE.IVOS) GO TO 30
               MULTI = MAX(MULTI, IFIX(Q(JIN+3)))
   30       CONTINUE
            IF (MULTI.EQ.0) GO TO 40
         ENDIF
C
C     New level found
C
         LIMUL(NLEV) = MULTI
         IF (NLEV.EQ.NLVMAX) GO TO 920
         IF (NSK(NLEV).EQ.NSKMAX) GO TO 930
         NSK(NLEV) = NSK(NLEV) +1
         IVOSK(NSK(NLEV),NLEV) = IVO
         NLEV = NLEV +1
         LINAM(NLEV) = IQ(JVOLUM+IVO)
         IVOS = IVO
         GO TO 20
C
   40 CONTINUE
C
C     No more path found at current level
C
      IF (NSK(NLEV).EQ.0) GO TO 910
      IF (NSK(NLEV).GT.1.OR.LIMUL(NLEV+1).GT.1) THEN
         DO 50 N = 1,NSK(NLEV)
            IVO = IVOSK(N,NLEV)
            NANEW = IQ(JVOLUM+IVO)
            IPJD = JD +10
            IF (NV.GT.0) THEN
               DO 49 I = 1,NV
                  IF (NANEW.EQ.IQ(IPJD+1)) GO TO 50
                  IPJD = IPJD +2
   49          CONTINUE
            ENDIF
            IF (NV.EQ.NVMAX) GO TO 940
            NV = NV +1
            IQ(IPJD+1) = NANEW
   50    CONTINUE
      ENDIF
      GO TO 90
C
C     Store current solution
C
   60 NSOL = NSOL +1
      LIMUL(NLEV) = 0
      IF (LIMUL(1).GT.MULT1) MULT1 = LIMUL(1)
+SELF, IF=DEBUGG.
      IF (IDEBUG.NE.0) THEN
         WRITE (CHMAIL, 1002) NSOL, NLEV
         CALL GMAIL (0,0)
         WRITE (CHMAIL, 1012) (LINAM(I),LIMUL(I),I=1,NLEV)
         CALL GMAIL (0,0)
 1002    FORMAT (' GGDETV DEBUG : NSOL,NLEV ',2I3)
 1012    FORMAT (15(1X,A4,I3))
      ENDIF
+SELF.
C
      DO 80 N = NLEV,1,-1
         LIST(NLIST+1) = LINAM(N)
         LIST(NLIST+2) = LIMUL(N)
         IF (N.EQ.NLEV)  LIST(NLIST+2) = NLEV
         NLIST = NLIST +2
   80 CONTINUE
      IF (NLEV.LT.3) GO TO 100
      NLEV = NLEV -1
C
   90 NSK(NLEV) = 0
      NLEV = NLEV -1
      IF (NLEV.GT.0) GO TO 10
C
  100 IF (MULT1.GT.1) THEN
        NV = NV +1
        IQ(JD+9+2*NV) = LINAM(1)
      ENDIF
C
C     Perform final operations on JD bank
C
      NW = 0
      IF (NV.EQ.0) GO TO 150
C
C     Compute maximum multiplicities
C
      DO 120 N = 1,NLIST,2
         IPJD = JD +10
         DO 110 I = 1,NV
            IF (IQ(IPJD+1).EQ.LIST(N))
     +          IQ(IPJD+2)=MAX(IQ(IPJD+2),LIST(N+1))
            IPJD = IPJD +2
  110    CONTINUE
  120 CONTINUE
C
      IF (IDEBUG.NE.0) THEN
         I2 = 0
  125    I1 = I2 + 1
         I2 = I1 + 14
         IF (I2.GT.NV) I2 = NV
         WRITE (CHMAIL, 1003) (IQ(JD+10+I),I=2*I1-1,2*I2)
         CALL GMAIL (0, 0)
         IF (I2.LT.NV)  GO TO 125
 1003    FORMAT (10X,15(1X,A4,I3))
      ENDIF
C
C     Compute corresponding bit numbers for packing
C
      IPJD = JD +10
      K = 32
      DO 140 N = 1,NV
         NBITS = 0
  130    NBITS = NBITS +1
         IF (IQ(IPJD+2).GT.2**NBITS-1) GO TO 130
         IF (NBITS.GE.32)  NBITS = 0
         IQ(IPJD+2) = NBITS
         IPJD = IPJD +2
         IF (NBITS.EQ.0) THEN
            K = 32
            NW = NW +1
         ELSE
            K = K +NBITS
            IF (K.LE.32) GO TO 140
            K = NBITS
            NW = NW +1
         ENDIF
  140 CONTINUE
C
  150 IQ(JD+1) = NW
      IQ(JD+2) = NV
      IQ(JD+9) = NSOL
C
      NDATA = 10 +2*NV +NLIST
      ND = IQ(JD-1)
      CALL MZPUSH (IXCONS, JD, 0, NDATA-ND, 'I')
      CALL UCOPY (LIST, IQ(JD+2*NV+11), NLIST)
+SELF, IF=DEBUGG.
      IF (IDEBUG.NE.0) THEN
         ND1=MIN(10,NDATA)
         WRITE (CHMAIL, 1004) NDATA,(IQ(JD+I),I=1,ND1)
         CALL GMAIL (0,0)
         DO 160 II=ND1+1,NDATA,10
            ND2=MIN(II+9,NDATA)
            WRITE (CHMAIL, 1005) (IQ(JD+I),I=II,ND2)
            CALL GMAIL (0,0)
 160     CONTINUE
 1004    FORMAT (' GGDETV DEBUG : NDATA ',I3,'  JD --> ',10I4)
 1005    FORMAT (10(1X,A4,I4))
      ENDIF
+SELF.
      GO TO 999
C
C     Current detector IDET is an alias
C
  200 CONTINUE
      IF (IDEBUG.NE.0) THEN
         IHALI = IQ(JS+IALI)
         WRITE (CHMAIL, 1006) IHALI
         CALL GMAIL (0,0)
 1006    FORMAT ('       Alias of detector ',A4)
      ENDIF
C
      IDM = IQ(JD+10)
      JDM = LQ(JS-IDM)
      NDM = IQ(JDM-1)
      ND = IQ(JD-1)
      CALL MZPUSH (IXCONS, JD, 0, NDM-ND, 'I')
      NWHI = IQ(JD+7)
      NWDI = IQ(JD+8)
      JS = LQ(JSET-ISET)
      JDM  = LQ(JS-IDM)
      CALL UCOPY (IQ(JDM+1), IQ(JD+1), NDM)
      IQ(JD+7) = NWHI
      IQ(JD+8) = NWDI
      IQ(JD+10) = IDM
      GO TO 999
C
C     Errors
C
  910 WRITE (CHMAIL, 1000) LINAM(NLEV)
      CALL GMAIL (0,0)
 1000 FORMAT (' GGDETV : Hanging volume ',A4)
      GO TO 990
  920 CHMAIL=' GGDETV : Parameter NLVMAX too small'
      CALL GMAIL (0,0)
      GO TO 990
  930 CHMAIL=' GGDETV : Parameter NSKMAX too small'
      CALL GMAIL (0,0)
      GO TO 990
  940 CHMAIL=' GGDETV : NVMAX (= size of NUMBV) too small'
      CALL GMAIL (0,0)
  990 IEOTRI = 1
C
  999 RETURN
      END
+DECK,GICYL
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GICYL(R,X1,X2,S1,S2,IC,XINT,SINT,PZINT,IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Intersection of a Track with a Cylinder or a Plane         *
C.    *     --------------------------------------------------         *
C.    *                                                                *
C.    *   Calculates intersection of track (x1,x2)  with cylindrical   *
C.    * detector of radius R.  The track  is approximated by a cubic   *
C.    * in the track length.  To  improve stability,  the coordinate   *
C.    * system is shifted.                                             *
C.    * R         radius of cylinder in cm                             *
C.    * X1        x,y,z,xp,yp,zp of 1st point                          *
C.    * X2        x,y,z,xp,yp,zp of 2nd point                          *
C.    * S1(2)     S at 1st (2nd) point                                 *
C.    * IC        =1 straight line defined by x+xp                     *
C.    * IC        =2 straight line defined by x1+x2                    *
C.    * IC        =3 cubic model                                       *
C.    * XINT      x,y,z,xp,yp,zp at intersection point                 *
C.    * SINT      S at intersection point                              *
C.    * PZINT     phi,z,dphi/dr,dz/dr                                  *
C.    * IFLAG     =1 if track intersects cylinder, =0 if not           *
C.    *   Calculates  intersection  of  track  (x1,x2)   with  plane   *
C.    * parallel to (X-Z).   The track is approximated by a cubic in   *
C.    * the  track length.   To improve  stability,  the  coordinate   *
C.    * system is shifted.                                             *
C.    * YC        Y coordinate of plane                                *
C.    * X1,...    as for GICYL                                         *
C.    * IFLAG     =1 if track intersects plane,                        *
C.    *           =0 if not                                            *
C.    * Warning:  the default accuracy is  10 microns.  The value of   *
C.    *         EPSI  (internal variable)   must  be  changed for  a   *
C.    *         better precision.                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *                                                                *
C.    *       AUTHORS:R.BRUN/JJ.DUMONT FROM AN ORIGINAL ROUTINE BY     *
C.    *       H. BOERNER  KEK  OCTOBER 1982                            *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X1(6),X2(6),XINT(6),PZINT(4),A(4),B(4),C(4)
C
      DATA MAXHIT/100/
      DATA EPSI2/0.000001/
C.
C.
C.    ------------------------------------------------------------------
C.
C.
      IFLAG  = 1
      R12    = X1(1) * X1(1) + X1(2) * X1(2)
      R22    = X2(1) * X2(1) + X2(2) * X2(2)
      R2     = R * R
      DR2  = R22-R2
C
C             TRACK CROSSING THE CYLINDER FROM INSIDE OR OUTSIDE ?
C
      IF (R22.LT.R12)                            GO TO 5
      IF (R2.LT.R12)                             GO TO 90
      IF (R2.GT.R22)                             GO TO 90
      DRCTN  = 1.
      IF (IC.EQ.3) GO TO 7
C
      IF(IC.EQ.2) GOTO 30
      S=S1
      DXDS=X1(4)
      DYDS=X1(5)
      DZDS=X1(6)
      BX=X1(1)-DXDS*S
      BY=X1(2)-DYDS*S
      BZ=X1(3)-DZDS*S
      GO TO 40
C
   5  IF (R2.LT.R22)                             GO TO 90
      IF (R2.GT.R12)                             GO TO 90
      DRCTN  = - 1.
C
      IF(IC.EQ.3) GOTO 7
      IF(IC.EQ.2) GOTO 30
      S=S2
      DXDS=X2(4)
      DYDS=X2(5)
      DZDS=X2(6)
      BX=X2(1)-DXDS*S
      BY=X2(2)-DYDS*S
      BZ=X2(3)-DZDS*S
      GOTO 40
C
   30 DX=X2(1)-X1(1)
      DY=X2(2)-X1(2)
      DZ=X2(3)-X1(3)
      DS=SQRT(DX*DX+DY*DY+DZ*DZ)
      S=S1
      DXDS=DX/DS
      DYDS=DY/DS
      DZDS=DZ/DS
      BX=X1(1)-DXDS*S
      BY=X1(2)-DYDS*S
      BZ=X1(3)-DZDS*S
C
   40 AE=DYDS*DYDS+DXDS*DXDS
      IF(AE.EQ.0.) GO TO 30
      BE=DXDS*BX+DYDS*BY
      CE=BY*BY+BX*BX-R2
      SG=SIGN(1.,DR2)
      XX=BE*BE-AE*CE
      IF(XX.LE.0.) GOTO 30
      TRLEN=(SG*SQRT(ABS(XX))-BE)/AE
      XINT(1)=DXDS*TRLEN+BX
      XINT(2)=DYDS*TRLEN+BY
      XINT(3)=DZDS*TRLEN+BZ
      SINT=TRLEN
      XINT(4)=DXDS
      XINT(5)=DYDS
      XINT(6)=DZDS
      GO TO 200
C
C             SHIFT COORDINATE SYSTEM SUCH THAT CENTER OF GRAVITY=0
C
   7  IF(R.LE.0.)                                GO TO 90
      SHIFTX = (X1(1) + X2(1)) * 0.5
      SHIFTY = (X1(2) + X2(2)) * 0.5
      SHIFTZ = (X1(3) + X2(3)) * 0.5
      SHIFTS = (S1 + S2) * 0.5
C
C             ONLY ONE VALUE NECESSARY SINCE X1= -X2 ETC.
C
      XSHFT  = X1(1) - SHIFTX
      YSHFT  = X1(2) - SHIFTY
      ZSHFT  = X1(3) - SHIFTZ
      SSHFT  = S1 - SHIFTS
C
      PABS1  = SQRT(X1(4)**2 + X1(5)**2 + X1(6)**2)
      PABS2  = SQRT(X2(4)**2 + X2(5)**2 + X2(6)**2)
      IF (PABS1.EQ.0..OR.PABS2.EQ.0.)            GO TO 90
C
C             PARAMETRIZE THE TRACK BY A CUBIC THROUGH X1,X2
C
      CALL GCUBS(SSHFT,XSHFT,X1(4)/PABS1,X2(4)/PABS2,A)
      CALL GCUBS(SSHFT,YSHFT,X1(5)/PABS1,X2(5)/PABS2,B)
      CALL GCUBS(SSHFT,ZSHFT,X1(6)/PABS1,X2(6)/PABS2,C)
C
C             ITERATE TO FIND THE TRACK LENGTH CORRESPONDING TO
C             THE INTERSECTION OF TRACK AND CYLINDER.
C             START AT S=0. MIDDLE OF THE SHIFTED INTERVAL.
C
      DINTER = ABS(S2 - S1) * 0.5
      S      = 0.
C
      DO 10 I = 1,MAXHIT
         X = SHIFTX + A(1) + S * (A(2) + S * (A(3) + S * A(4)))
         Y = SHIFTY + B(1) + S * (B(2) + S * (B(3) + S * B(4)))
         RN2    = X * X + Y * Y
         DR2    = (R2 - RN2) * DRCTN
         IF (ABS(DR2).LT.EPSI2)                     GO TO 20
         DINTER = DINTER * 0.5
         IF (DR2.LT.0.)S = S - DINTER
         IF (DR2.GE.0.)S = S + DINTER
  10  CONTINUE
C
C             COMPUTE INTERSECTION IN ORIGINAL COORDINATES
C
  20  CONTINUE
      XINT(1) = SHIFTX + A(1) + S * (A(2) + S * (A(3) + S * A(4)))
      XINT(2) = SHIFTY + B(1) + S * (B(2) + S * (B(3) + S * B(4)))
      XINT(3) = SHIFTZ + C(1) + S * (C(2) + S * (C(3) + S * C(4)))
      XINT(4) = A(2) + S * (2. * A(3) + 3. * S * A(4))
      XINT(5) = B(2) + S * (2. * B(3) + 3. * S * B(4))
      XINT(6) = C(2) + S * (2. * C(3) + 3. * S * C(4))
C
C             COMPUTE PHIHIT,ZHIT AND CORRESPONDING DERIVATIVES
C
      SINT   = S + SHIFTS
  200 TERM   = 1. / (XINT(4) * XINT(1) + XINT(5) * XINT(2))
      PZINT(1) = ATAN2(XINT(2),XINT(1))
      PZINT(2) = XINT(3)
      PZINT(3) = (XINT(1) * XINT(5) - XINT(2) * XINT(4)) * TERM / R
      PZINT(4) = TERM * XINT(6) * R
      RETURN
C
  90  IFLAG  = 0
      END
+DECK,GIPLAN
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GIPLAN(YC,X1,X2,S1,S2,IC,XINT,SINT,PZINT,IFLAG)
C.
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Calculates intersection of track (X1,X2)                 *
C.    *       with plane parallel to (X-Z)                             *
C.    *        The track is approximated by a cubic in the             *
C.    *       track length.                                            *
C.    *       To improve stability, the coordinate system              *
C.    *       is shifted.                                              *
C.    *       input parameters                                         *
C.    *        YC    = Y COORDINATE OF PLANE                           *
C.    *        X1    = X,Y,Z,XP,YP,ZP OF 1ST POINT                     *
C.    *        X2    =                   2ND                           *
C.    *        S1(2) = S AT 1ST(2ND) POINT                             *
C.    *        IC    = 1 STRAIGHT LINE DEFINED BY X+XP                 *
C.    *        IC    = 2 STRAIGHT LINE DEFINED BY X1+X2                *
C.    *        IC    = 3 CUBIC MODEL                                   *
C.    *                                                                *
C.    *      output parameters                                         *
C.    *        XINT  = X,Y,Z,XP,YP,ZP AT INTERSECTION POINT            *
C.    *        SINT  = S AT INTERSECTION POINT                         *
C.    *        PZINT = PHI,Z,DPHI/DR,DZ/DR                             *
C.    *        IFLAG = 1 IF TRACK INTERSECTS PLANE                     *
C.    *              = 0 IF NOT                                        *
C.    *                                                                *
C.    *      Warning : the default accuracy is 10 microns. The value   *
C.    *      of EPSI must be changed for a better precision            *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *                                                                *
C.    *        Authors: R.BRUN/JJ.DUMONT from an original routine by   *
C.    *       H. BOERNER  KEK  OCTOBER 1982                            *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X1(6),X2(6),XINT(6),PZINT(4),A(4),B(4),C(4)
C
      DATA MAXHIT/100/
      DATA EPSI/0.001/
C.
C.
C.    ------------------------------------------------------------------
C.
C.
      IFLAG  = 1
      DRCTN  = 1.
C
C             Track crossing the plane from above or below ?
C
      IF (X2(2).LT.X1(2))                        GO TO 5
      IF (YC.LT.X1(2))                           GO TO 90
      IF (YC.GT.X2(2))                           GO TO 90
      IF (IC.EQ.2) GO TO 30
      IF (IC.EQ.3) GO TO 7
C
      S=S1
      DXDS=X1(4)
      DYDS=X1(5)
      DZDS=X1(6)
      BX=X1(1)-DXDS*(X1(2)-YC)/DYDS
      BZ=X1(3)-DZDS*(X1(2)-YC)/DYDS
      TRL2=(BX-X1(1))**2+(X1(2)-YC)**2+(BZ-X1(3))**2
      GO TO 40
C
   5  IF (YC.LT.X2(2))                           GO TO 90
      IF (YC.GT.X1(2))                           GO TO 90
      IF(IC.EQ.2) GO TO 30
      DRCTN  = - 1.
C
      IF(IC.EQ.3) GOTO 7
      S=S2
      DXDS=X2(4)
      DYDS=X2(5)
      DZDS=X2(6)
      BX=X2(1)-DXDS*(X2(2)-YC)/DYDS
      BZ=X2(3)-DZDS*(X2(2)-YC)/DYDS
      TRL2=(BX-X2(1))**2+(X2(2)-YC)**2+(BZ-X2(3))**2
      GOTO 40
C
   30 DX=X2(1)-X1(1)
      DY=X2(2)-X1(2)
      DZ=X2(3)-X1(3)
      DS=SQRT(DX*DX+DY*DY+DZ*DZ)
      S=S1
      DXDS=DX/DS
      DYDS=DY/DS
      DZDS=DZ/DS
      BX=X1(1)-DX*(X1(2)-YC)/DY
      BZ=X1(3)-DZ*(X1(2)-YC)/DY
      TRL2=(BX-X1(1))**2+(X1(2)-YC)**2+(BZ-X1(3))**2
C
   40 TRLEN=SQRT(TRL2)*DRCTN+S
      XINT(1)=BX
      XINT(2)=YC
      XINT(3)=BZ
      SINT=TRLEN
      XINT(4)=DXDS
      XINT(5)=DYDS
      XINT(6)=DZDS
      GO TO 200
C
C               Shift coordinate system such that center of gravity=0
C
   7  IF(YC.LE.0.)                                GO TO 90
      SHIFTX = (X1(1) + X2(1)) * 0.5
      SHIFTY = (X1(2) + X2(2)) * 0.5
      SHIFTZ = (X1(3) + X2(3)) * 0.5
      SHIFTS = (S1 + S2) * 0.5
C
C             Only one value necessary since X1= -X2 etc...
C
      XSHFT  = X1(1) - SHIFTX
      YSHFT  = X1(2) - SHIFTY
      ZSHFT  = X1(3) - SHIFTZ
      SSHFT  = S1 - SHIFTS
C
      PABS1  = SQRT(X1(4)**2 + X1(5)**2 + X1(6)**2)
      PABS2  = SQRT(X2(4)**2 + X2(5)**2 + X2(6)**2)
      IF (PABS1.EQ.0..OR.PABS2.EQ.0.)            GO TO 90
C
C              Parametrize the track by a cubic through X1, X2
C
      CALL GCUBS(SSHFT,XSHFT,X1(4)/PABS1,X2(4)/PABS2,A)
      CALL GCUBS(SSHFT,YSHFT,X1(5)/PABS1,X2(5)/PABS2,B)
      CALL GCUBS(SSHFT,ZSHFT,X1(6)/PABS1,X2(6)/PABS2,C)
C
C              Iterate to find the track length corresponding to
C              the intersection of track and plane.
C              Start at S=0. middle of the shifted interval.
C
      DINTER = ABS(S2 - S1) * 0.5
      S      = 0.
C
      DO 10 I = 1,MAXHIT
         Y = SHIFTY + B(1) + S * (B(2) + S * (B(3) + S * B(4)))
         DR=(YC-Y)*DRCTN
         IF (ABS(DR).LT.EPSI)                     GO TO 20
         DINTER = DINTER * 0.5
         IF (DR.LT.0.)S = S - DINTER
         IF (DR.GE.0.)S = S + DINTER
  10  CONTINUE
C
C              Compute intersection in original coordinates
C
  20  CONTINUE
      XINT(1) = SHIFTX + A(1) + S * (A(2) + S * (A(3) + S * A(4)))
      XINT(2)=YC
      XINT(3) = SHIFTZ + C(1) + S * (C(2) + S * (C(3) + S * C(4)))
      XINT(4) = A(2) + S * (2. * A(3) + 3. * S * A(4))
      XINT(5) = B(2) + S * (2. * B(3) + 3. * S * B(4))
      XINT(6) = C(2) + S * (2. * C(3) + 3. * S * C(4))
C
C             Compute PHIHIT,ZHIT and corresponding derivatives
C
      SINT   = S + SHIFTS
  200 TERM   = 1. / (XINT(4) * XINT(1) + XINT(5) * XINT(2))
      PZINT(1) = ATAN2(XINT(2),XINT(1))
      PZINT(2) = XINT(3)
      PZINT(3) = (XINT(1) * XINT(5) - XINT(2) * XINT(4)) * TERM / YC
      PZINT(4) = TERM * XINT(6) * YC
      RETURN
C
  90  IFLAG  = 0
      END
+DECK,GPDIGI
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GPDIGI(IUSET,IUDET)
C.
C.    **************************************************************************
C.    *                                                                        *
C.    *       Print DIGIts in detector IUDET of set IUSET                      *
C.    *       (in case IUSET/IUDET = *, take all sets/detectors)               *
C.    *                                                                        *
C.    *       JDI=LQ(JDIGI-ISET)                                               *
C.    *       JDID=LQ(JDI-IDET)                                                *
C.    *       IQ(JDI+IDET)= pointer to LAST USED word in JDID                  *
C.    *                                                                        *
C.    *          Each digit is packed in JDID in the following format          *
C.    *          -- Track  numbers packed                                      *
C.    *          -- Volume numbers packed                                      *
C.    *          -- Digits packed                                              *
C.    *                                                                        *
C.    *    ==>Called by : <USER>, GPRINT                                       *
C.    *       Author    W.Gebel  *********                                     *
C.    *                                                                        *
C.    **************************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      PARAMETER (NDEMX=100,NVMAX=20)
      DIMENSION KDIGI(NDEMX),NUMBV(NVMAX),KWS(130),LTR(3)
      EQUIVALENCE (WS(1),NUMBV(1)),(WS(101),KDIGI(1))
      CHARACTER*4 IUSET,IUDET
C.    ------------------------------------------------------------------
C.
      IF(JDIGI.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      NS1=1
      NS2=NSET
      IF(IUSET(1:1).NE.'*')THEN
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF(ISET.LE.0)GO TO 999
         NS1=ISET
         NS2=ISET
      ENDIF
C
C             Loop on all selected sets
C
      DO 230 ISET=NS1,NS2
      JS=LQ(JSET-ISET)
      JDI=LQ(JDIGI-ISET)
      IF(JDI.LE.0)GO TO 230
      NDET=IQ(JS-1)
      ND1=1
      ND2=NDET
      IF(IUDET(1:1).NE.'*')THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.EQ.0)GO TO 230
         ND1=IDET
         ND2=IDET
      ENDIF
C
C             Loop on selected detectors for this set
C
      DO 220 IDET=ND1,ND2
      JD=LQ(JS-IDET)
      JDID=LQ(JDI-IDET)
      IF(JDID.LE.0)GO TO 220
      JDDI=LQ(JD-2)
C
      WRITE(CHMAIL,1000)IQ(JS+IDET),IQ(JSET+ISET)
      CALL GMAIL(0,0)
C
C             Get volumes / digitisings names and print header line
C
      ILAST=IQ(JDI+IDET)
      IF(ILAST.EQ.0)GO TO 220
      NV=IQ(JD+2)
      ND=IQ(JD+6)
C
      CALL VBLANK(KWS,130)
      K=3
      IF(NV.GT.0)THEN
C        Number of printed elements limited to 15
         NVM=MIN(NV,15)
         DO 22 I=1,NVM
            CALL UBLOW(IQ(JD+2*I+9),KWS(K),4)
  22     K=K+5
         K=K+5
      ENDIF
      IF(ND.GT.0)THEN
         DO 26 I=1,ND
            IF(K.LE.101) CALL UBLOW(IQ(JDDI+2*I-1),KWS(K),4)
            K=K+8
  26     CONTINUE
         IF(K.GT.104)K=104
      ENDIF
      WRITE(CHMAIL,2000)(KWS(I),I=1,K)
      CALL GMAIL(0,1)
C
C             Now loop on all digits
C             to get track numbers, volume numbers and digits
C
      IDIG=0
      I=0
      NWDI=0
C
   30 CONTINUE
      I=I+NWDI
      IF(I.GE.ILAST)GO TO 220
      NK=2
      IDIG=IDIG+1
      CALL VZERO (LTR(1),3)
C
C             Get unpacked (first 3) tracks producing this digit
C             (2 tracks packed in 1 word; 1st half of 1st word: NTRA-1)
C
      NWDI=IQ(JDID+I+1)
      NTRM1=IBITS(IQ(JDID+I+NK), 0,16)
      NTRA=NTRM1+1
      IF(NTRA.GE.1)LTR(1)=IBITS(IQ(JDID+I+NK),16,16)
      NK=NK+1
      IF(NTRA.GE.2)LTR(2)=IBITS(IQ(JDID+I+NK), 0,16)
      IF(NTRA.GE.3)LTR(3)=IBITS(IQ(JDID+I+NK),16,16)
      NWTR=NTRA/2+1
      NK=NWTR+2
C
C             Get unpacked volume numbers
C
      IF(NV.GT.0)THEN
         K=1
         DO 50 IV=1,NV
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               NUMBV(IV)=IQ(JDID+I+NK)
               K=1
               NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               NUMBV(IV)=IBITS(IQ(JDID+I+NK),K-1,NB)
               K=K+NB
            ENDIF
  50     CONTINUE
         IF(K.NE.1)NK=NK+1
      ENDIF
C
C             Get unpacked digits
C
      IF(ND.GT.0)THEN
         K=1
         DO 90 ID=1,ND
            NB=IQ(JDDI+2*ID)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IF(ID.LE.NDEMX) KDIGI(ID)=IQ(JDID+I+NK)
               K=1
               NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               IF(ID.LE.NDEMX) KDIGI(ID)=IBITS(IQ(JDID+I+NK),K-1,NB)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
C             Do the printout
C             (fitting in 1 line of 128 characters per each digit)
C
      IF(NV.EQ.0)GO TO 119
      IF(NV.GT.15)NV=15
      GO TO (101,102,103,104,105,106,107,108,109,110
     +,      111,112,113,114,115), NV
C
  101 NDP=MIN(ND,12)
      WRITE(CHMAIL,3001)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  102 NDP=MIN(ND,11)
      WRITE(CHMAIL,3002)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  103 NDP=MIN(ND,10)
      WRITE(CHMAIL,3003)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  104 NDP=MIN(ND,10)
      WRITE(CHMAIL,3004)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  105 NDP=MIN(ND, 9)
      WRITE(CHMAIL,3005)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  106 NDP=MIN(ND, 8)
      WRITE(CHMAIL,3006)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  107 NDP=MIN(ND, 8)
      WRITE(CHMAIL,3007)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  108 NDP=MIN(ND, 7)
      WRITE(CHMAIL,3008)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  109 NDP=MIN(ND, 7)
      WRITE(CHMAIL,3009)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  110 NDP=MIN(ND, 6)
      WRITE(CHMAIL,3010)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  111 NDP=MIN(ND, 5)
      WRITE(CHMAIL,3011)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  112 NDP=MIN(ND, 5)
      WRITE(CHMAIL,3012)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  113 NDP=MIN(ND, 4)
      WRITE(CHMAIL,3013)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  114 NDP=MIN(ND, 4)
      WRITE(CHMAIL,3014)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  115 NDP=MIN(ND, 3)
      WRITE(CHMAIL,3015)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  119 NDP=MIN(ND,12)
      WRITE(CHMAIL,3000)IDIG,(LTR(J),J=1,3)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
C
 220  CONTINUE
 230  CONTINUE
C
C
 1000 FORMAT(' =====>DIGITS OF DETECTOR ** ',A4,
     +' ** OF SET ** ',A4,' **')
 2000 FORMAT(' DIGIT    TR1  TR2  TR3  ',104A1)
 3000 FORMAT(1X,I5,2X,3I5,3X,             12(1X,I7))
 3001 FORMAT(1X,I5,2X,3I5,3X, 1(1X,I4),2X,12(1X,I7))
 3002 FORMAT(1X,I5,2X,3I5,3X, 2(1X,I4),2X,11(1X,I7))
 3003 FORMAT(1X,I5,2X,3I5,3X, 3(1X,I4),2X,10(1X,I7))
 3004 FORMAT(1X,I5,2X,3I5,3X, 4(1X,I4),2X,10(1X,I7))
 3005 FORMAT(1X,I5,2X,3I5,3X, 5(1X,I4),2X, 9(1X,I7))
 3006 FORMAT(1X,I5,2X,3I5,3X, 6(1X,I4),2X, 8(1X,I7))
 3007 FORMAT(1X,I5,2X,3I5,3X, 7(1X,I4),2X, 8(1X,I7))
 3008 FORMAT(1X,I5,2X,3I5,3X, 8(1X,I4),2X, 7(1X,I7))
 3009 FORMAT(1X,I5,2X,3I5,3X, 9(1X,I4),2X, 7(1X,I7))
 3010 FORMAT(1X,I5,2X,3I5,3X,10(1X,I4),2X, 6(1X,I7))
 3011 FORMAT(1X,I5,2X,3I5,3X,11(1X,I4),2X, 5(1X,I7))
 3012 FORMAT(1X,I5,2X,3I5,3X,12(1X,I4),2X, 5(1X,I7))
 3013 FORMAT(1X,I5,2X,3I5,3X,13(1X,I4),2X, 4(1X,I7))
 3014 FORMAT(1X,I5,2X,3I5,2X,14(1X,I4),2X, 4(1X,I7))
 3015 FORMAT(1X,I5,2X,3I5,3X,15(1X,I4),2X, 3(1X,I7))
 999  RETURN
      END
+DECK,GPDRIF
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GPDRIF (DETREP,HITREP,IOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *     DETREP(1)=NUMBER OF WIRES                                  *
C     *           (2)=WIRE SPACING                                     *
C     *           (3)=SIN (ALPHA) (ALPHA=ANGLE OF THE NORMAL           *
C     *                            TO THE WIRE WITH RESPECT TO         *
C     *                            AXIS I)                             *
C     *           (4)=COS (ALPHA)                                      *
C     *           (5)=DISTANCE OF WIRE 1 FROM THE ORIGIN               *
C     *           (6)=DRIFT VELOCITY (CM/NSEC)                         *
C     *                                                                *
C     *     HITREP(1)=X COORDINATE OF INTERSECTION                     *
C     *           (2)=Y COORDINATE                                     *
C     *                                                                *
C     *     IOUT(1)=WIRE NUMBER                                        *
C     *         (2)=DRIFT TIME (SIGNED TO AVOID RIGHT/LEFT AMBIGUITY)  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Authors    F.Carena, M.Hansroul  *********               *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION HITREP(2), DETREP(6), IOUT(2)
C.
C.    ------------------------------------------------------------------
C.
      IOUT(1) = - 1
      SP     = DETREP(2)
      DV     = DETREP(6)
      IF (SP.EQ.0.)                                   GO TO 99
      IF (DV.EQ.0.)                                   GO TO 99
C
      X      = HITREP(1)
      Y      = HITREP(2)
      SA     = DETREP(3)
      CA     = DETREP(4)
      U      = X * CA + Y * SA
      OR     = DETREP(5)
      W      = (U - OR) / SP + 1.5
C
      IW     = W
      NWIR   = DETREP(1)
      IF (IW.GT.NWIR)                                 GO TO 99
      IF (IW.LE.0)                                    GO TO 99
C
      DIST   = U - OR - (IW - 1) * SP
      TDRIF  = DIST / DV
C
      IOUT(1) = IW
      IOUT(2) = TDRIF
C
  99  RETURN
      END
+DECK,GPHITS
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GPHITS(IUSET,IUDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints HITS into detector IUDET of set IUSET             *
C.    *                                                                *
C.    *       If IPKHIT in /CGDRAW/ is greater than zero,              *
C.    *       only hit nr. IPKHIT is printed.                          *
C.    *                                                                *
C.    *       JH=LQ(JHITS-ISET)                                        *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)= pointer to first free word in JHD           *
C.    *         Each hit is packed into JHD in the following format    *
C.    *        --Track number ITRA not packed                          *
C.    *        --Volume numbers packed                                 *
C.    *        --Hits transformed and packed                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT ,<GXINT>, GINC4, GKHITS       *
C.    *       Authors : R.Brun      **********                         *
C.    *                 P.Zanarini  *                                  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCDRAW
      PARAMETER (NHEMX=100,NVMAX=20)
      DIMENSION HITS(NHEMX),KWS(120),NUMBV(NVMAX)
      EQUIVALENCE (WS(1),NUMBV(1)),(WS(101),HITS(1)),(WS(201),KWS(1))
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      IF(JHITS.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      NS1=1
      NS2=NSET
      IF(IUSET(1:1).NE.'*')THEN
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF(ISET.LE.0)GO TO 999
         NS1=ISET
         NS2=ISET
      ENDIF
C
C             loop on all selected sets
C
      DO 130 ISET=NS1,NS2
      JS=LQ(JSET-ISET)
      JH=LQ(JHITS-ISET)
      IF(JS.LE.0)GO TO 130
      IF(JH.LE.0)GO TO 130
      NDET=IQ(JS-1)
      ND1=1
      ND2=NDET
      IF(IUDET(1:1).NE.'*')THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.EQ.0)GO TO 130
         ND1=IDET
         ND2=IDET
      ENDIF
C
C             loop on selected detectors for this set
C
      DO 120 IDET=ND1,ND2
      JD=LQ(JS-IDET)
      JHD=LQ(JH-IDET)
      IF(JHD.LE.0)GO TO 120
      JDH=LQ(JD-1)
C
      WRITE(CHMAIL,1000)IQ(JS+IDET),IQ(JSET+ISET)
      CALL GMAIL(1,1)
C
      ILAST=IQ(JH+IDET)
      IF(ILAST.EQ.0)GO TO 120
      NV=IQ(JD+2)
      NH=IQ(JD+4)
      NW=IQ(JD+1)+IQ(JD+3)+1
C
      CALL VBLANK(KWS,120)
      K=0
      IF(NV.GT.0) THEN
C        Number of printed elements limited to 9
         NVM=MIN(NV,NVMAX)
         DO 22 I=1,NVM
            CALL UBLOW(IQ(JD+2*I+9),KWS(K+1),4)
            K=K+5
  22     CONTINUE
      ENDIF
      IF(NH.GT.0)THEN
         K=K+5
         IP0 = K
         NHM=MIN(NH,NHEMX)
         DO 26 I=1,NHM
            IF(K.GT.110)GO TO 26
            NH1=I
            CALL UBLOW(IQ(JDH+4*I-3),KWS(K+1),4)
            K=K+10
  26     CONTINUE
      ENDIF
      WRITE(CHMAIL,2000)(KWS(I),I=1,K)
      CALL GMAIL(0,0)
C
      IF(NH.GT.0)THEN
         IF(NH1.LT.NHM)THEN
            CALL VBLANK(KWS,IP0)
            DO 40 NHP1=NH1+1,NHM,NH1
               NHP2=NHP1+NH1-1
               NHP2=MIN(NHP2,NHM)
               K=IP0
               DO 30 I=NHP1,NHP2
                  CALL UBLOW(IQ(JDH+4*I-3),KWS(K+1),4)
                  K=K+10
  30           CONTINUE
               WRITE(CHMAIL,2100)(KWS(I),I=1,K)
               CALL GMAIL(0,0)
  40        CONTINUE
         ENDIF
      ENDIF
C
C             Now loop on all hits to get volume numbers and hits
C
      IHIT=0
      DO 110 I=1,ILAST,NW
      IHIT=IHIT+1
C
C             IPKHIT in /CGDRAW/ is used to print just that hit
C
      IF (IPKHIT.GT.0.AND.IHIT.NE.IPKHIT) GO TO 110
C
      ITRA=IQ(JHD+I)
C
C             Get unpacked volume numbers
C
      NK=1
      IF(NV.GT.0)THEN
         K=1
         DO 50 IV=1,NVM
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   K=1
                   NK=NK+1
               ENDIF
               NUMBV(IV)=IQ(JHD+I+NK)
               IF(IV.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               NUMBV(IV)=IBITS(IQ(JHD+I+NK),K-1,NB)
               K=K+NB
            ENDIF
  50  CONTINUE
      NK=NK+1
      ENDIF
C
C             Get unpacked hits
C             Hits origin is shifted . Division by scale factor
C
      IF(NH.GT.0)THEN
         K=1
         DO 90 IH=1,NHM
            NB=IQ(JDH+4*IH-2)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               KHIT=IQ(JHD+I+NK)
               K=1
               NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               KHIT=IBITS(IQ(JHD+I+NK),K-1,NB)
               K=K+NB
            ENDIF
            HITS(IH)=FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
  90  CONTINUE
      ENDIF
C
      WRITE(CHMAIL,3000)IHIT,ITRA,(NUMBV(L),L=1,NV)
      IF(NH.GT.0)THEN
         IP0=NV*5+15
         DO 100 NHP1=1,NHM,NH1
            NHP2=NHP1+NH1-1
            NHP2=MIN(NHP2,NHM)
            WRITE(CHMAIL(IP0+1:),4000)(HITS(L),L=NHP1,NHP2)
            CALL GMAIL(0,0)
            CHMAIL(1:IP0)=' '
 100     CONTINUE
      ENDIF
C
      IF(IHIT.EQ.IPKHIT)GO TO 999
C
 110  CONTINUE
 120  CONTINUE
 130  CONTINUE
C
 1000 FORMAT(' =====>HITS IN DETECTOR ** ',A4,
     +' ** OF SET ** ',A4,' **')
 2000 FORMAT('  HIT TRACK ',120A1)
 2100 FORMAT(12X,120A1)
 3000 FORMAT(1X,I4,I6,20I5)
 4000 FORMAT(12(G10.3))
 999  RETURN
      END
+DECK,GPMWPC
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GPMWPC (DETREP,HITREP,IOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *     DETREP(1)=NUMBER OF WIRES                                  *
C     *           (2)=WIRE SPACING                                     *
C     *           (3)=SIN (ALPHA) (ALPHA=ANGLE OF THE NORMAL           *
C     *                            TO THE WIRE WITH RESPECT TO         *
C     *                            AXIS I)                             *
C     *           (4)=COS (ALPHA)                                      *
C     *           (5)=DISTANCE OF WIRE 1 FROM THE ORIGIN               *
C     *           (6)=GAP WIDTH                                        *
C     *                                                                *
C     *     HITREP(1)=X COORDINATE OF INTERSECTION                     *
C     *           (2)=Y COORDINATE                                     *
C     *           (3)=DX/DZ                                            *
C     *           (4)=DY/DZ                                            *
C     *                                                                *
C     *     IOUT(1)=WIRE NUMBER                                        *
C     *         (2)=CLUSTER SIZE                                       *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Authors    F.Carena, M.Hansroul  *********               *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION HITREP(4), DETREP(6), IOUT(2)
C.
C.    ------------------------------------------------------------------
C.
      IOUT(1) = - 1
      SP     = DETREP(2)
      IF (SP.EQ.0.)                                   GO TO 99
C
      HG     = .5 * DETREP(6)
      DX     = HG * HITREP(3)
      DY     = HG * HITREP(4)
      X1     = HITREP(1) - DX
      X2     = HITREP(1) + DX
      Y1     = HITREP(2) - DY
      Y2     = HITREP(2) + DY
      SA     = DETREP(3)
      CA     = DETREP(4)
      U1     = X1 * CA + Y1 * SA
      U2     = X2 * CA + Y2 * SA
      OR     = DETREP(5)
      W1     = (U1 - OR) / SP + 1.5
      W2     = (U2 - OR) / SP + 1.5
C
      IW1    = W1
      IW2    = W2
      IWMIN  = MIN (IW1,IW2)
      IWMAX  = MAX (IW1,IW2)
      NWIR   = DETREP(1)
      IF (IWMIN.GT.NWIR)                              GO TO 99
      IF (IWMAX.LE.0)                                 GO TO 99
C
      IWMIN  = MAX (1,IWMIN)
      IWMAX  = MIN (NWIR,IWMAX)
C
      IOUT(1) = IWMIN
      IOUT(2) = IWMAX - IWMIN + 1
C
  99  RETURN
      END
+DECK,GPSETS
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GPSETS(IUSET,IUDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints set and detector parameters                       *
C.    *                                                                *
C.    *        IUSET  user set identifier                              *
C.    *               If * prints all detectors of all sets            *
C.    *        IUDET  user detector identifier                         *
C.    *               If * prints all detectors of set IUSET           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT   ,<GXINT> GINC4              *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      IF(IUSET(1:1).EQ.'*')THEN
         WRITE(CHMAIL,1000)
         CALL GMAIL(0,0)
      ENDIF
      IF(JSET.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      NS1=1
      NS2=NSET
      IF(IUSET(1:1).NE.'*')THEN
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF(ISET.LE.0)GO TO 999
         NS1=ISET
         NS2=ISET
      ENDIF
C
C             loop on all selected sets
C
      DO 130 ISET=NS1,NS2
      JS=LQ(JSET-ISET)
      IF(JS.LE.0)GO TO 130
      NDET=IQ(JS-1)
      ND1=1
      ND2=NDET
      IF(IUDET(1:1).NE.'*')THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.EQ.0)GO TO 130
         ND1=IDET
         ND2=IDET
      ENDIF
C
C             loop on selected detectors for this set
C
      DO 120 IDET=ND1,ND2
      JD=LQ(JS-IDET)
      IF(JD.LE.0)GO TO 120
      NV=IQ(JD+2)
      NWHI=IQ(JD+7)
      NWDI=IQ(JD+8)
C
      WRITE(CHMAIL,2000)IQ(JSET+ISET),IQ(JS+IDET),NWHI,NWDI
      CALL GMAIL(0,0)
C
      IF(NV.NE.0)THEN
         DO 10 I=1,NV
            WRITE(CHMAIL,3000)IQ(JD+2*I+9),IQ(JD+2*I+10)
            CALL GMAIL(0,0)
  10     CONTINUE
      ENDIF
C
      JDH=LQ(JD-1)
      IF(JDH.GT.0)THEN
         NH=IQ(JD+4)
         IF(NH.GT.0)THEN
            DO 30 I=1,NH
               WRITE(CHMAIL,4000)IQ(JDH+4*I-3),IQ(JDH+4*I-2),
     +                           Q(JDH+4*I-1),Q(JDH+4*I)
               CALL GMAIL(0,0)
  30        CONTINUE
         ENDIF
      ENDIF
C
      JDD=LQ(JD-2)
      IF(JDD.GT.0)THEN
         ND=IQ(JD+6)
         IF(ND.GT.0)THEN
            DO 50 I=1,ND
               WRITE(CHMAIL,5000)IQ(JDD+2*I-1),IQ(JDD+2*I)
               CALL GMAIL(0,0)
  50        CONTINUE
         ENDIF
      ENDIF
C
      JDU=LQ(JD-3)
      IF(JDU.GT.0)THEN
         NU=IQ(JDU-1)
         IF(NU.GT.0)THEN
            WRITE(CHMAIL,6000)
            CALL GMAIL(0,0)
            DO 60 I=1,NU,10
               L2=I+9
               IF(L2.GT.NU)L2=NU
               WRITE(CHMAIL,7000)(Q(JDU+L),L=I,L2)
               CALL GMAIL(0,0)
  60        CONTINUE
         ENDIF
      ENDIF
C
 120  CONTINUE
 130  CONTINUE
C
 1000 FORMAT('0',51('='),3X,'SETS AND DETECTORS',3X,50('='))
 2000 FORMAT('   SET ',A4,'  DETECTOR ',A4,'  NWHI=',I6,'  NWDI=',I6)
 3000 FORMAT(10X,'VOLUME ',A4,'  NBITSD=',I4)
 4000 FORMAT(10X,'HIT ELEMENT =',A4,'  NBITSH=',I4,
     +'  ORIG =',E12.4,'  FACT =',E12.4)
 5000 FORMAT(10X,'DIGIT ELEMENT =',A4,'  NBITSD=',I4)
 6000 FORMAT(10X,'USER PARAMETERS')
 7000 FORMAT(5X,10E12.4)
 999  RETURN
      END
+DECK, GRHITS.
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GRHITS (IUSET, IUDET, NTRA, ITRA)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GRHITS (IUSET, IUDET, NTRA, ITRA)                     *
C.    *                                                                *
C.    *   Removes the hits produced by the tracks ITRA(1...NTRA) in    *
C.    *   the generic volume name IUDET belonging to the set IUSET.    *
C.    *                                                                *
C.    *   IUSET    User set identifier                                 *
C.    *   IUDET    User detector identifier (name of the corresponding *
C.    *            sensivitive volume)                                 *
C.    *   NTRA     Number of tracks whose hits are to be removed       *
C.    *   ITRA     Track indices whose hits are to be removed          *
C.    *                                                                *
C.    *   Called by : <USER>                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      COMMON /GC1HIT/ LOC(2), JD, JDH, JH, JHD, JHDN, JS
      DIMENSION       ITRA(*)
      CHARACTER*(*)   IUSET, IUDET
      SAVE JHDNN
      DATA JHDNN/0/
*
*     ------------------------------------------------------------------
*
      IF (NTRA.LE.0)                  GO TO 999
      IF (JSET.LE.0)                  GO TO 999
      IF (JHITS.LE.0)                 GO TO 999
*
* *** Find the selected set(s)
*
      NSET  = IQ(JSET-1)
      IF (IUSET(1:1).EQ.'*') THEN
         NS1   = 1
         NS2   = NSET
      ELSE
         CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
         IF (ISET.LE.0)               GO TO 999
         NS1   = ISET
         NS2   = ISET
      ENDIF
      CALL MZLINT (IXSTOR, '/GC1HIT/', LOC, JD, JS)
*
* *** Loop over selected sets
*
      DO 30  ISET = NS1, NS2
         JS    = LQ(JSET-ISET)
         JH    = LQ(JHITS-ISET)
         IF (JS.LE.0.OR.JH.LE.0)      GO TO 30
         NDET  = IQ(JS-1)
*
*  **    Find the selected detector(s)
*
         IF (IUDET(1:1).EQ.'*') THEN
            ND1   = 1
            ND2   = NDET
         ELSE
            CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
            IF (IDET.EQ.0)            GO TO 30
            ND1   = IDET
            ND2   = IDET
         ENDIF
*
*  **    Loop over selected detectors
*
         DO 20 IDET = ND1, ND2
            JD    = LQ(JS-IDET)
            JHD   = LQ(JH-IDET)
            IF (JD.LE.0)              GO TO 20
            IF (JHD.LE.0)             GO TO 20
            JDH   = LQ(JD-1)
            IF (JDH.LE.0)             GO TO 20
            ILAST = IQ(JH+IDET)
            IF (ILAST.EQ.0)           GO TO 20
            NW    = IQ(JD+1) + IQ(JD+3) + 1
*
*  **       Shunt the original bank and lift a new SJDH bank
*
            CALL ZSHUNT (IXDIV, JHD, JHDNN, 2, 0)
            CALL MZBOOK (IXDIV, JHDN, JH, -IDET, 'SJHD', 0, 0, ILAST,
     +                   1, -1)
            IQ(JHDN-5) = IQ(JHD-5)
*
*  **       Copy the relevant part
*
            LAST  = 0
            DO 10 I = 1, ILAST, NW
               II    = IUCOMP (IQ(JHD+I), ITRA, NTRA)
               IF (II.LE.0) THEN
                  CALL UCOPY (IQ(JHD+I), IQ(JHDN+LAST+1), NW)
                  LAST  = LAST + NW
               ENDIF
   10       CONTINUE
*
*  **       Drop the old bank
*
            IF (LAST.LT.ILAST) THEN
               CALL VZERO (IQ(JHDN+LAST+1), ILAST-LAST)
            ENDIF
            IQ(JH+IDET) = LAST
            CALL MZDROP (IXDIV, JHD, ' ')
   20    CONTINUE
   30 CONTINUE
*
  100 LOC(1) = 0
*                                                             END GRHITS
  999 CONTINUE
      END
+DECK,GSAHIT
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routines to Communicate with the JHITS data structure       *
C.    *   ---------------------------------------------------------    *
C.    *                                                                *
C.    *   Stores  element  values  for current  hit  into  the  data   *
C.    * structure JHITS.                                               *
C.    * ISET      set number  (can be obtained from  /GCSETS/ filled   *
C.    *           by GFINDS)                                           *
C.    * IDET      detector    number   "           "               "   *
C.    *           "                                                    *
C.    * ITRA      track number producing this hit                      *
C.    * NUMBV     array  of  volume numbers  corresponding  to  list   *
C.    *           NAMESV of GSDET                                      *
C.    * HITS      array of values for current hit elements             *
C.    * IHIT      on return, current hit number.  If =0, hit has not   *
C.    *           been stored.                                         *
C.    *                                                                *
C.    *       JH=LQ(JHITS-ISET)                                        *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)= pointer to LAST USED word in JHD            *
C.    *         Each hit is packed into JHD in the following format    *
C.    *        --Track number ITRA not packed                          *
C.    *        --Volume numbers packed                                 *
C.    *        --Hits transformed and packed                           *
C.    *                                                                *
C.    *                The Hit data structure JHITS                    *
C.    *                ----------------------------                    *
C.    *                                                                *
C.    *                                            | JHITS             *
C.    *    NSET                  ISET              v                   *
C.    *     ..........................................                 *
C.    *     |                   |  |              |  |                 *
C.    *     ..........................................                 *
C.    *                           |                                    *
C.    *                           | JH                                 *
C.    *      NDET    IDET         v               NDET                 *
C.    *        .....................................                   *
C.    *        |      |  |      |  |               |                   *
C.    *        .....................................                   *
C.    *                |                                               *
C.    *                | JHD                                           *
C.    *                v                                               *
C.    *               .........................................        *
C.    *               |  | 1st hit        | 2nd hit, etc.     |        *
C.    *               .........................................        *
C.    *                         Bank layout                            *
C.    * JH            =  LQ(JHITS-ISET,)  pointer  to  hits for  set   *
C.    *           number ISET                                          *
C.    * JHD           = LQ(JH-IDET),   pointer to  hits of  detector   *
C.    *           IDET                                                 *
C.    *                  of set ISET                                   *
C.    * IQ(JH+IDET)    number of words  used so far for  storing the   *
C.    *           hits                                                 *
C.    *                  of detector IDET                              *
C.    * IQ(JHD+1)       1st word of 1st hit                            *
C.    * IQ(JHD+NWH+1)  1st word of 2nd hit                             *
C.    *                      JS=LQ(JSET-ISET)                          *
C.    *                      JD=LQ(JS-IDET)                            *
C.    *                      NWH=IQ(JD+3)                              *
C.    *   The JHITS structure is filled with the routines GSAHIT and   *
C.    * GSCHIT.   The routine GFHITS can be used to get the hits for   *
C.    * a detector IDET and set ISET.                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(1),HITS(1)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      IHIT=0
      IF(JSET.LE.0)GO TO 99
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 99
      IF(ISET.LE.0)GO TO 99
      IF(ISET.GT.NSET)GO TO 99
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 99
      IF(IDET.LE.0)GO TO 99
      IF(IDET.GT.NDET)GO TO 99
      JD=LQ(JS-IDET)
      JDH=LQ(JD-1)
      IF(JDH.LE.0)GO TO 99
      NW=IQ(JD+1)+IQ(JD+3)+1
      NH=IQ(JD+4)
      NV=IQ(JD+2)
C
C              Create HITS master bank
C
      IF(JHITS.EQ.0)THEN
         CALL MZBOOK(IXDIV,JHITS,JHITS,1,'HITS',NSET,NSET,0,2,0)
         IQ(JHITS-5)=0
      ENDIF
      JH=LQ(JHITS-ISET)
      IF(JH.EQ.0)THEN
         CALL MZBOOK(IXDIV,JH,JHITS,-ISET,'HITS',NDET,NDET,NDET,2,0)
      ENDIF
C
      JHD=LQ(JH-IDET)
      IF(JHD.EQ.0)THEN
C
C            Create Hits bank
C
         NWHI=IQ(JD+7)
         CALL MZBOOK(IXDIV,JHD,JH,-IDET,'SJHD',0,0,NWHI,1,0)
         IQ(JHD-5)=1000*ISET+IDET
         ILAST=0
      ELSE
C
C           Check if enough space. If not increase bank size
C
         NHD=IQ(JHD-1)
         ILAST=IQ(JH+IDET)
         NFREE=NHD-ILAST
         IF(NFREE.LE.NW)THEN
            NWHI2=MAX(100,NW,IQ(JD+7)/2)
            CALL MZPUSH(IXDIV,JHD,0,NWHI2,'I')
            JS  = LQ(JSET-ISET)
            JD  = LQ(JS-IDET)
            JDH = LQ(JD-1)
            JH  = LQ(JHITS-ISET)
         ENDIF
      ENDIF
C
      IQ(JH+IDET)=ILAST+NW
      IHIT=IQ(JH+IDET)/NW
C
C ========>    Store track number,volumes numbers and hits
C
      IQ(JHD+ILAST+1)=ITRA
C
C
C           Store packed volume numbers
C
      NK=ILAST+2
      IF(NV.GT.0)THEN
         K=1
C
         DO 50 I=1,NV
            NB=IQ(JD+2*I+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=NUMBV(I)
               K=1
               IF(I.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(NUMBV(I),0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  50     CONTINUE
         NK=NK+1
      ENDIF
C
C          Store packed hits
C          Before packing, hits are changed to integers
C          Origin is shifted to have only positive integers
C          Result is multiplied by a constant to get resolution
C
      IF(NH.GT.0)THEN
         K=1
         DO 90 I=1,NH
            NB=IQ(JDH+4*I-2)
            XHIT=(HITS(I)+Q(JDH+4*I-1))*Q(JDH+4*I)
            IF(NB.EQ.0)THEN
               VALMX=2.147483E+9
            ELSE
               VALMX=2.**NB-1.
            ENDIF
            IFLAG=0
            IF(XHIT.LT.0.)THEN
               XHIT=0.
               IFLAG=1
            ELSE IF(XHIT.GT.VALMX)THEN
               XHIT=VALMX
               IFLAG=1
            ENDIF
            IF(IFLAG.NE.0)THEN
               NMESS=NMESS+1
               IF(NMESS.LT.10)THEN
                  WRITE(CHMAIL,1000)IQ(JSET+ISET),IQ(JS+IDET),I,HITS(I)
     +             ,Q(JDH+4*I-1),Q(JDH+4*I)
                  CALL GMAIL(0,0)
               ENDIF
            ENDIF
C
            KHIT=XHIT+0.5
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=KHIT
               NK=NK+1
               K=1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(KHIT,0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
 1000 FORMAT(' ***** GSAHIT OVERFLOW WHEN IUSET= ',A4,' IUDET= ',
     +A4,' HITS(',I2,')=',E14.7,' ORIG= ',E14.7,' FACT= ',E14.7)
  99  RETURN
      END
+DECK,GSCHIT
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSCHIT(ISET,IDET,ITRA,NUMBV,HITS,NHSUM,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store HITS values into detector IUDET of set IUSET       *
C.    *                                                                *
C.    *       NUMBV  volume numbers                                    *
C.    *       HITS  array of values for the elements of current hit    *
C.    *       ITRA  track number associated to this hit                *
C.    *       IHIT  output parameter containing the hit number         *
C.    *             If IHIT=0  hit has not been stored                 *
C.    *                                                                *
C.    *       Same action as GSAHIT but in case the physical volume    *
C.    *       specified by NUMBV contains already some hit for the     *
C.    *       same track, then the routine will sum up the last NHSUM  *
C.    *       elements of the hit.                                     *
C.    *        In order to use that routine , no packing must be       *
C.    *        specified for these NHSUM last hits.                    *
C.    *        If NHSUM.LE.0 then GSCHIT is the same as GSAHIT.        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(*),HITS(*)
      PARAMETER (MAXINT=2147483647)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      CALL GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
      IF(IHIT.LE.1)GO TO 999
      IF(NHSUM.LE.0)GO TO 999
C
      NV=IQ(JD+1)
      NH=IQ(JD+3)
      NW=NV+NH+1
      JNEWH = JHD+(IHIT-1)*NW
      JCURR = JNEWH
C
      DO 30 I=1,IHIT-1
         JCURR = JCURR-NW
C
C             Check if track number is ITRA
C
         IF(ITRA.NE.IQ(JCURR+1))GO TO 999
C
C             Check if volume numbers are the same
C
         DO 10 J=2,NV+1
            IF(IQ(JCURR+J).NE.IQ(JNEWH+J))GO TO 30
   10    CONTINUE
C
C             Volumes are the same. Now sum the last NHSUM hits
C
         DO 20 K=NW,NW-NHSUM+1,-1
            IF(IQ(JCURR+K).GT.MAXINT-IQ(JNEWH+K)) THEN
               IQ(JCURR+K) = MAXINT
               NMESS=NMESS+1
               IF(NMESS.LT.10)THEN
                  WRITE(CHMAIL,10000)IQ(JSET+ISET),IQ(JS+IDET)
                  CALL GMAIL(0,0)
               ENDIF
            ELSE
               IQ(JCURR+K)=IQ(JCURR+K)+IQ(JNEWH+K)
            ENDIF
   20    CONTINUE
C
C             Remove temporarily stored hit
C
         IHIT=IHIT-1
         IQ(JH+IDET)=IQ(JH+IDET)-NW
         GO TO 999
   30 CONTINUE
C
10000 FORMAT(' ***** GSCHIT OVERFLOW WHEN IUSET= ',A4,' IUDET= ',A4)
  999 CONTINUE
      END
+DECK,GSDET
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDET(IUSET,IUDET,NV,NAMESV,NBITSV,IDTYPE
     +                ,NWHI,NWDI,ISET,IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines volume parameters for detector IUDET of set IUSET*
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    * NV        number of volume descriptors                         *
C.    * NAMESV    vector of NV volume descriptors (4 characters)       *
C.    * NBITSV    vector of  NV bit numbers  for packing  the volume   *
C.    *           numbers                                              *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for the primary allocation of HITS   *
C.    *           banks                                                *
C.    * NWDI      number of words for the primary allocation of DIGI   *
C.    *           banks when first allocation not sufficient           *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The vector NAMESV (length NV)  contains the list of volume   *
C.    *   names which  permit the  identification of  every physical   *
C.    *   detector with detector name IUDET.    [See example in HITS   *
C.    *   110].                                                        *
C.    * - Each  element of  the vector  NBITSV (length  NV)  is  the   *
C.    *   number  of  bits  used  for  packing  the  number  of  the   *
C.    *   corresponding volume,  when building the packed identifier   *
C.    *   of a given physical detector.                                *
C.    * - For more details see the example given in GSDETH.            *
C.    * - The detector type  IDTYPE is not used  internally by GEANT   *
C.    *   and  can be  defined by  the user  to distinguish  quickly   *
C.    *   between various kinds of detectors,  in the routine GUSTEP   *
C.    *   for example.                                                 *
C.    *                                                                *
C.    *       IQ(JSET+ISET) = IUSET                                    *
C.    *       JS = LQ(JSET-ISET) + pointer to set parameters           *
C.    *       IQ(JS+IDET)=IUDET                                        *
C.    *       JD= LQ(JS-1)  = pointer to detector IDET                 *
C.    *       IQ(JD+1)=Total number of words to store packed volumes   *
C.    *       IQ(JD+2)=NV                                              *
C.    *       IQ(JD+3)=Number of words required per hit                *
C.    *       IQ(JD+4)=Number of different hits types                  *
C.    *       IQ(JD+5)=Number of words required per digit              *
C.    *       IQ(JD+6)=Number of different digit types                 *
C.    *       IQ(JD+7)=NWHI                                            *
C.    *       IQ(JD+8)=NWDI                                            *
C.    *       IQ(JD+9)=Number of paths through the JVOLUM tree         *
C.    *       IQ(JD+10)= For an alias only, IDET of main detector      *
C.    *       IQ(JD+2*I+9) = name of volume i = NAMESV(I)              *
C.    *       IQ(JD+2*I+10)= number of bits/volume = NBITSV(I)         *
C.    *                                                                *
C.    *            The Detector Set data structure JSET                *
C.    *            ------------------------------------                *
C.    *                                                                *
C.    *                                        | JSET                  *
C.    *    NSET            ISET                v         NSET          *
C.    *     ................................................           *
C.    *     |              | |               |  | Set names|           *
C.    *     ................................................           *
C.    *                     | JS                                       *
C.    *                     |                                          *
C.    *    NDET       IDET  v                    NDET                  *
C.    *     ........................................                   *
C.    *     |        |  |  | | Detector names      |                   *
C.    *     ........................................                   *
C.    *               | JD                                             *
C.    *      -3 -2 -1 v                                                *
C.    *     ................................................           *
C.    *     |  |  |  |  |   Parameters of GSDET            |           *
C.    *     ................................................           *
C.    *      |  |  |                                                   *
C.    *      |  |  |  JDH                                              *
C.    *      |  |  |                                                   *
C.    *      |  |  |           .............................           *
C.    *      |  |  ............| Parameters of GSDETH      |           *
C.    *      |  |              .............................           *
C.    *      |  |                                                      *
C.    *      |  | JDD                                                  *
C.    *      |  |                                                      *
C.    *      |  |              .............................           *
C.    *      |  ...............|  Parameters of GSDETD     |           *
C.    *      |                 .............................           *
C.    *      |                                                         *
C.    *      |  JDU                                                    *
C.    *      |                 .............................           *
C.    *      ..................| Parameters of GSDETU      |           *
C.    *                        .............................           *
C.    *  JS = LQ(JSET-ISET) pointer to detector set number ISET        *
C.    * The JSET data structure is filled by GSDET, GSDETH,  GSDETD,   *
C.    * GSDETU and eventually by GSDETA.                               *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCMZFO
      PARAMETER (NVMAX=20)
      DIMENSION NBITSV(1),NAV(NVMAX)
      CHARACTER*4 NAMESV,IUSET,IUDET
      EQUIVALENCE (WS(1),NAV(1))
C.
C.    ------------------------------------------------------------------
C.
      ISET=0
      IDET=0
      IF(NV.GT.15)GO TO 94
C
C             Check if volume IUDET has been defined
C
      IF(JVOLUM.LE.0)GO TO 90
      NVOLUM=IQ(JVOLUM-1)
      CALL GLOOK(IUDET,IQ(JVOLUM+1),NVOLUM,IVOL)
      IF(IVOL.EQ.0)GO TO 90
C
      IF(JSET.EQ.0)THEN
C
C               Create mother JSET bank
C
         CALL MZBOOK(IXCONS,JSET,JSET,1,'SETS',0,0,0,5,0)
         IQ(JSET-5)=0
         NSET=0
      ELSE
         NSET=IQ(JSET-1)
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF (ISET.NE.0) GO TO 30
      ENDIF
C
C               Create JS bank
C
      CALL MZPUSH(IXCONS,JSET,1,1,'I')
      NSET=NSET+1
C
      ISET=NSET
      CALL UCTOH(IUSET,IQ(JSET+ISET),4,4)
      CALL MZBOOK(IXCONS,JS,JSET,-ISET,'SETS',0,0,0,5,0)
C
C            Check if detector has already been defined
C
  30  JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.NE.0)THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.NE.0) GO TO 92
      ENDIF
C
C                If not, create detector bank
C
      CALL MZPUSH(IXCONS,JS,1,1,'I')
      NDET=NDET+1
      IDET=NDET
      CALL UCTOH(IUDET,IQ(JS+IDET),4,4)
      CALL MZBOOK(IXCONS,JD,JS,-IDET,'SEJD',4,4,10+2*NV,IOSEJD,0)
      IQ(JD-5)=10*ISET+IDET
C
      NW=0
      IF(NV.GT.0)THEN
         CALL UCTOH(NAMESV,NAV,4,4*NV)
         K=32
         DO 70 I=1,NV
            NB=NBITSV(I)
            IF(NB.LT.0)NB=0
            IF(NB.GE.32)NB=0
            IQ(JD+2*I+ 9)=NAV(I)
            IQ(JD+2*I+10)=NB
            IF(NB.LE.0)THEN
               NW=NW+1
               K=32
            ELSE
               K=K+NB
               IF(K.GT.32)THEN
                  K=NB
                  NW=NW+1
               ENDIF
            ENDIF
  70     CONTINUE
      ENDIF
  80  IQ(JD+1)=NW
      IQ(JD+2)=NV
      IQ(JD+7)=NWHI
      IQ(JD+8)=NWDI
      IQ(JD+10)=0
C
C             Now enter set,det into JVOLUM data structure
C
      CALL GSATT(IUDET,'SET ',ISET)
      CALL GSATT(IUDET,'DET ',IDET)
      CALL GSATT(IUDET,'DTYP',IDTYPE)
      GO TO 99
C
C              Errors
C
  90  WRITE(CHMAIL,1000)IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDET ERROR, VOLUME ',A4,' NOT DEFINED')
      GO TO 99
C
  92  WRITE(CHMAIL,2000)IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT(' ***** GSDET ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' ALREADY DEFINED')
      GO TO 99
C
  94  WRITE(CHMAIL,3000)NV
      CALL GMAIL(0,0)
 3000 FORMAT(' ***** GSDET ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' Too many descriptors:',I5)
C
  99  RETURN
      END
+DECK,GSDETA
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDETA (IUSET, IUDET, IUALI, NWHI, NWDI, IALI)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                 Handling Detector Aliases                      *
C.    *                 --------------------------                     *
C.    *                                                                *
C.    * Detector  'aliases'  can  be  specified  for  any  sensitive   *
C.    * detector for  which the  user needs to  store more  than one   *
C.    * type of hit.                                                   *
C.    *   Defines an  alias IUALI for  detector IUDET of  set IUSET.   *
C.    * Enters it in the JSET structure as an additional detector in   *
C.    * the corresponding set,  at the position IALI.  Copies to the   *
C.    * link  position  IALI  the  GSDET  parameter  bank  from  the   *
C.    * original detector  IUDET,  with empty  links to  the GSDETH,   *
C.    * GSDETD and GSDETU parameter banks.    The user can therefore   *
C.    * call  these   three  routines   again  with   the  arguments   *
C.    * appropriate to the  detector IUALI.  Several aliases  can be   *
C.    * defined  for the  same  detector through  as  many calls  to   *
C.    * GSDETA.                                                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCMZFO
      CHARACTER*4 IUSET,IUDET,IUALI
C.
C.    ------------------------------------------------------------------
C.
      IF (JSET.LE.0) GO TO 90
      NSET = IQ(JSET-1)
      IF (NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET.LE.0) GO TO 90
      JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.LE.0) GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF (IDET.LE.0) GO TO 90
      CALL GLOOK(IUALI,IQ(JS+1),NDET,IALI)
      IF (IALI.NE.0) GO TO 95
      JD = LQ(JS-IDET)
      NDATA = IQ(JD-1)
C
      CALL MZPUSH(IXCONS, JS, 1, 1,'I')
      NDET = NDET +1
      IALI = NDET
      CALL UCTOH(IUALI,IQ(JS+IALI),4,4)
C
      CALL MZBOOK(IXCONS,JD2,JS,-IALI, 'SEJD',4,4, NDATA,IOSEJD,0)
      IQ(JD2-5)=10*ISET+IALI
      JD = LQ(JS-IDET)
      CALL UCOPY (IQ(JD+1), IQ(JD2+1), NDATA)
      IQ(JD2+7) = NWHI
      IQ(JD2+8) = NWDI
      IQ(JD2+10) = IDET
      GO TO 99
C
   90 WRITE (CHMAIL, 1000) IUSET, IUDET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GSDETA ERROR FOR SET ',A4,' OR DETECTOR ',A4)
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET, IUALI
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GSDETA ERROR FOR SET ', A4, ' ALIAS NAME '
     +, A4, ' ALREADY USED')
C
  99  RETURN
      END
+DECK,GSDETD
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDETD(IUSET,IUDET,ND,NAMESD,NBITSD)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Handling sensitive DETector Digitisation parameters        *
C.    *     ---------------------------------------------------        *
C.    *                                                                *
C.    * Defines digitisation  parameters for  detector IUDET  of set   *
C.    * IUSET.                                                         *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    * ND        number of elements per digitisation                  *
C.    * NAMESD    the  ND   variable  names  for   the  digitisation   *
C.    *           elements                                             *
C.    * NBITSD    the  ND  bit  numbers  for  packing  the  variable   *
C.    *           values.                                              *
C.    *   The  routine  is  used at  initialisation  time  once  the   *
C.    * geometrical  volumes  have  been  defined  to  describe  the   *
C.    * digitisation elements  and the way  to do packing  in memory   *
C.    * and on tape.  Let us use the same example as in GSDETH.  The   *
C.    * non  geometrical  information  we want  to  store  for  each   *
C.    * digitisation is for example:                                   *
C.    *  - ADC  pulse height in a lead glass block.                    *
C.    * Example of one digitisation in that scheme:                    *
C.    *       EPHI 12                                                  *
C.    *       EZRI 41                                                  *
C.    *       BLOC  3                                                  *
C.    *       ADC  789                                                 *
C.    * The FORTRAN  coding to  define the  digitisation information   *
C.    * could be:                                                      *
C.    *   DATA NAMESD/'ADC '/                                          *
C.    *   DATA NBITSD/16/                                              *
C.    *       CALL GSDETD('ECAL','BLOC',1,NAMESD,NBITSD)               *
C.    *   Returns the digitisation parameters  for detector IUDET of   *
C.    * set IUSET.  All arguments as explained in GSDETD.              *
C..   *                                                                *
C.    *       JS = LQ(JSET-ISET)                                       *
C.    *       JD = LQ(JS-IDET)                                         *
C.    *       JDD= LQ(JD-2)                                            *
C.    *       IQ(JDD+2*I-1)=NAMESD(I)                                  *
C.    *       IQ(JDD+2*I)  =NBITSD(I)                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCMZFO
      PARAMETER (NDEMX=100)
      DIMENSION NBITSD(1),NAMD(NDEMX)
      CHARACTER*4 NAMESD(1),IUSET,IUDET
      EQUIVALENCE (WS(1),NAMD(1))
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 90
      JD=LQ(JS-IDET)
C
      CALL MZBOOK(IXCONS,JDD,JD,-2,'SJDD',0,0,2*ND,IOSJDD,0)
C
      NW=0
      IF(ND.GT.0)THEN
         CALL UCTOH(NAMESD,NAMD,4,4*ND)
         K=32
         DO 30 I=1,ND
            NB=NBITSD(I)
            IF(NB.LT.0)NB=0
            IF(NB.GE.32)NB=0
            IQ(JDD+2*I-1)=NAMD(I)
            IQ(JDD+2*I )=NB
            IF(NB.LE.0)THEN
               NW=NW+1
               K=32
            ELSE
               K=K+NB
               IF(K.GT.32)THEN
                  K=NB
                  NW=NW+1
               ENDIF
            ENDIF
  30     CONTINUE
      ENDIF
      IQ(JD+5)=NW
      IQ(JD+6)=ND
      GO TO 99
C
C              Error
C
  90  WRITE(CHMAIL,1000)IUSET,IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDETD ERROR FOR SET ',A4,' OR DETECTOR ',A4)
C
  99  RETURN
      END
+DECK,GSDETH
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDETH(IUSET,IUDET,NH,NAMESH,NBITSH,ORIG,FACT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *          Handling sensitive DETector Hit parameters            *
C.    *          ------------------------------------------            *
C.    *                                                                *
C.    *   Defines hit parameters for detector IUDET of set IUSET.      *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    * NH        number of elements per hit                           *
C.    * NAMESH    the NH variable names for the hit elements           *
C.    * NBITSH    the NH bit numbers for packing the variable values   *
C.    * ORIG      The quantity packed in the structure JHITS for the   *
C.    *           Ith variable is a  positive integer with NBITSH(I)   *
C.    *           bits and such that                                   *
C.    * FACT      IVAR(I) = (VAR(I)+ORIG(I))*FACT(I)                   *
C.    *   The  routine  is  used at  initialisation  time  once  the   *
C.    * geometrical volumes  have been defined  to describe  the hit   *
C.    * elements and the way to do packing in memory and on tape.      *
C.    *                           EXAMPLE                              *
C.    *   Assume an electromagnetic calorimeter ECAL divided into 40   *
C.    * PHI  sections called  EPHI.   Each  EPHI division  is  again   *
C.    * divided along  the Z axis in  60 objects called  EZRI.  Each   *
C.    * EZRI  is finally  divided into  4 lead  glass blocks  called   *
C.    * BLOC.                                                          *
C.    * The geometrical  information to describe  one hit  will then   *
C.    * be:                                                            *
C.    *  - The EPHI section number (between 1 and 40)                  *
C.    *  - The EZRI division number (between 1 and 60)                 *
C.    *  - The BLOC number (1 to 4)                                    *
C.    * The variables we want to store for each hit are for example:   *
C.    *  - X     x position of the hit in the lead glass block         *
C.    *  - Y     y                                                     *
C.    *  - Z     z                                                     *
C.    *  - E     energy of the particle at this point                  *
C.    *  - ELOS  the energy deposited into this block                  *
C.    * Example of one hit in that scheme:                             *
C.    *       EPHI 12                                                  *
C.    *       EZRI 41                                                  *
C.    *       BLOC  3                                                  *
C.    *        X    7.89 cm                                            *
C.    *        Y    -345.6 cm                                          *
C.    *        Z    1234.8 cm                                          *
C.    *        E    12 Gev                                             *
C.    *        ELOS  11.85 Gev                                         *
C.    * The FORTRAN  coding to  define the  set/det/hits information   *
C.    * could be:                                                      *
C.    *   DIMENSION NAMESV(3),NBITSV(3)                                *
C.    *   DIMENSION NAMESH(5),NBITSH(5),ORIG(5),FACT(5)                *
C.    *   DATA NAMESV/'EPHI','EZRI','BLOC'/                            *
C.    *   DATA NBITSV/6,6,3/                                           *
C.    *   DATA NAMESH/'X   ','Y   ','Z   ','E   ','ELOS'/              *
C.    *   DATA NBITSH/5*16/                                            *
C.    *   DATA ORIG/3*1000.,0.,0./                                     *
C.    *   DATA FACT/3*10.,2*100./                                      *
C.    *       CALL GSDET ('ECAL','BLOC',3,NAMESV,NBITSV,2,100,100,     *
C.    *      +                         ISET,IDET)                      *
C.    *       CALL GSDETH('ECAL','BLOC',5,NAMESH,NBITSH,ORIG,FACT)     *
C.    *   Returns  the hit  parameters  for  detector IUDET  of  set   *
C.    * IUSET.  All arguments are explained above.                     *
C..   *                                                                *
C.    *                                                                *
C.    *       JS = LQ(JSET-ISET)                                       *
C.    *       JD = LQ(JS-IDET)                                         *
C.    *       JDH= LQ(JD-1)                                            *
C.    *       IQ(JDH+4*I-3)= NAMESH(I)                                 *
C.    *       IQ(JDH+4*I-2)= NBITSH(I)                                 *
C.    *        Q(JDH+4*I-1)= ORIG(I)                                   *
C.    *        Q(JDH+4*I)  = FACT(I)                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCMZFO
      PARAMETER (NHEMX=100)
      DIMENSION NBITSH(1),ORIG(1),FACT(1),NAMH(NHEMX)
      CHARACTER*4 NAMESH(1),IUSET,IUDET
      EQUIVALENCE (WS(1),NAMH(1))
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 90
      JD=LQ(JS-IDET)
C
      CALL MZBOOK(IXCONS,JDH,JD,-1,'SJDH',0,0,4*NH,IOSJDH,0)
C
      NW=0
      IF(NH.GT.0)THEN
         CALL UCTOH(NAMESH,NAMH,4,4*NH)
         K=32
         DO 30 I=1,NH
            NB=NBITSH(I)
            IF(NB.LT.0)NB=0
            IF(NB.GE.32)NB=0
            IQ(JDH+4*I-3)=NAMH(I)
            IQ(JDH+4*I-2)=NB
            Q(JDH+4*I-1)=ORIG(I)
            Q(JDH+4*I )=FACT(I)
            IF(FACT(I).LE.0.)Q(JDH+4*I)=1.
            IF(NB.LE.0)THEN
               NW=NW+1
               K=32
            ELSE
               K=K+NB
               IF(K.GT.32)THEN
                  K=NB
                  NW=NW+1
               ENDIF
            ENDIF
  30     CONTINUE
      ENDIF
      IQ(JD+3)=NW
      IQ(JD+4)=NH
      GO TO 99
C
C              Error
C
  90  WRITE(CHMAIL,1000)IUSET,IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDETH ERROR FOR SET ',A4,' OR DETECTOR ',A4)
C
  99  RETURN
      END
+DECK,GSDETU
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDETU(IUSET,IUDET,NUPAR,UPAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Storing and Retrieving User Detector parameters           *
C.    *      -----------------------------------------------           *
C.    *                                                                *
C.    *   Stores user parameters for detector IUDET of set IUSET.      *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    * NUPAR     number of user parameters                            *
C.    * UPAR      array of NUPAR user floating point parameters.       *
C.    *   The  routine  is  used at  initialisation  time  once  the   *
C.    * geometrical volumes have been defined.                         *
C.    *                                                                *
C.    *                                                                *
C.    *       JS = LQ(JSET-ISET)                                       *
C.    *       JD = LQ(JS-IDET)                                         *
C.    *       JDU= LQ(JD-1)                                            *
C.    *       Q(JDU+1) = UPAR(1)  1st user parameter,etc               *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      DIMENSION UPAR(1)
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 90
      JD=LQ(JS-IDET)
C
      IF(NUPAR.LE.0)GO TO 90
      CALL MZBOOK(IXCONS,JDU,JD,-3,'SJDU',0,0,NUPAR,3,0)
C
      CALL UCOPY(UPAR,Q(JDU+1),NUPAR)
      GO TO 99
C
C              Error
C
  90  WRITE(CHMAIL,1000)IUSET,IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDETU ERROR FOR SET ',A4,' OR DETECTOR ',A4)
C
  99  RETURN
      END
+DECK,GSDETV
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDETV (IUSET, IUDET, IDTYPE, NWHI, NWDI, ISET, IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines detector IUDET as a member of set IUSET          *
C.    *     and prepares the DETector structure                        *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for primary allocation of HITS banks *
C.    * NWDI      number of words for primary allocation of DIGI banks *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The path through the volume tree will be automatically set   *
C.    *   in GGDETV,called by GGCLOS, after all volumes have been      *
C.    *   positionned.                                                 *
C.    * - The detector type  IDTYPE is not used  internally by GEANT   *
C.    *   and  can be  defined by  the user  to distinguish  quickly   *
C.    *   between various kinds of detectors,  in the routine GUSTEP   *
C.    *   for example.                                                 *
C.    *                                                                *
C.    *       IQ(JSET+ISET) = IUSET                                    *
C.    *       JS = LQ(JSET-ISET) = pointer to set IUSET                *
C.    *       IQ(JS+IDET)=IUDET                                        *
C.    *       JD= LQ(JS-1)  = pointer to detector IUDET                *
C.    *       IQ(JD+1)=Number of words to store packed volume numbers  *
C.    *       IQ(JD+2)=Number of volume descriptors                    *
C.    *       IQ(JD+3)=Number of words per hit                         *
C.    *       IQ(JD+4)=Number of elements per hit                      *
C.    *       IQ(JD+5)=Number of words per digitisation                *
C.    *       IQ(JD+6)=Number of elements per digitisation             *
C.    *       IQ(JD+7)=NWHI, primary size of hit bank                  *
C.    *       IQ(JD+8)=NWDI, primary size of digitisation bank         *
C.    *       IQ(JD+9)=Number of paths through the JVOLUM tree         *
C.    *       IQ(JD+10)=For aliases only, IDET of mother detector      *
C.    *       IQ(JD+11)=Name of first volume descriptor                *
C.    *       IQ(JD+12)=Number of bits for packing its number          *
C.    *       ...                                                      *
C.    *       IQ(JD+9+2*NV)=Name of last volume descriptor             *
C.    *       IQ(JD+10+2*NV)=Number of bits for packing its number     *
C.    *       then for each possible path                              *
C.    *       list of names and numbers for all levels                 *
C.    *       (The number of levels is entered as number attached to   *
C.    *       the first name which is the top of the JVOLUM tree)      *
C.    *                                                                *
C.    *            The Detector Set data structure JSET                *
C.    *            ------------------------------------                *
C.    *                                                                *
C.    *                                        | JSET                  *
C.    *    NSET            ISET                v         NSET          *
C.    *     ................................................           *
C.    *     |              | |               |  | Set names|           *
C.    *     ................................................           *
C.    *                     | JS                                       *
C.    *                     |                                          *
C.    *    NDET       IDET  v                    NDET                  *
C.    *     ........................................                   *
C.    *     |        |  |  | | Detector names      |                   *
C.    *     ........................................                   *
C.    *                  | JD                                          *
C.    *       -3  -2  -1 v                                             *
C.    *     ................................................           *
C.    *     |   |   |   |  | Volume parameters, in GGDETV  |           *
C.    *     ................................................           *
C.    *              JDH                                               *
C.    *          JDD                                                   *
C.    *      JDU                                                       *
C.    *                                                                *
C.    * The JSET structure is filled by GSDETV + GGDETV, and by        *
C.    *      GSDETH, GSDETD and GSDETU, eventually by GSDETA.          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors   R.Brun, F.Bruyant    **********                *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCMZFO
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      ISET = 0
      IDET = 0
C
C     Check if volume IUDET has been defined
C
      IF (JVOLUM.LE.0) GO TO 920
      NVOLUM = IQ(JVOLUM-1)
      CALL GLOOK (IUDET, IQ(JVOLUM+1), NVOLUM, IVOL)
      IF (IVOL.EQ.0) GO TO 920
C
C     Check that volume IVOL is a sensitive medium
C
      JVO = LQ(JVOLUM-IVOL)
      ITM = Q(JVO+4)
      JTM = LQ(JTMED-ITM)
      IF (Q(JTM+7).EQ.0.)THEN
         WRITE (CHMAIL,1000) IUDET
         CALL GMAIL(0,0)
      ENDIF
C
      IF (JSET.EQ.0)THEN
C
C     Create mother JSET bank
C
         CALL MZBOOK (IXCONS, JSET, JSET, 1, 'SETS', 0,0,0, 5, 0)
         IQ(JSET-5)=0
         NSET = 0
      ELSE
C
         NSET = IQ(JSET-1)
         CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
         IF (ISET.NE.0) GO TO 30
      ENDIF
C
C     Create JSET bank
C
      CALL MZPUSH (IXCONS, JSET, 1, 1, 'I')
      NSET = NSET +1
C
      ISET = NSET
      CALL UCTOH (IUSET, IQ(JSET+ISET), 4, 4)
      CALL MZBOOK (IXCONS, JS, JSET, -ISET, 'SETS', 0,0,0, 5, 0)
      IQ(JS-5) = ISET
C
C     Check if detector has already been defined
C
  30  JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.NE.0)THEN
         CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
         IF (IDET.NE.0) GO TO 930
      ENDIF
C
C     If not, create detector bank
C
      CALL MZPUSH (IXCONS, JS, 1, 1, 'I')
      NDET = NDET +1
      IDET = NDET
      CALL UCTOH (IUDET, IQ(JS+IDET), 4, 4)
      CALL MZBOOK (IXCONS, JD, JS, -IDET, 'SEJD', 4,4,100, IOSEJD, 0)
      IQ(JD-5) = IDET
C
      IQ(JD+7) = NWHI
      IQ(JD+8) = NWDI
      IQ(JD+9) = -1
C
C     Now enter Set/Det into JVOLUM data structure
C
      CALL GSATT (IUDET, 'SET ', ISET)
      CALL GSATT (IUDET, 'DET ', IDET)
      CALL GSATT (IUDET, 'DTYP', IDTYPE)
      GO TO 999
C
C     Errors
C
  920 WRITE (CHMAIL,2000) IUDET
      CALL GMAIL(0,0)
      GO TO 999
C
  930 WRITE (CHMAIL,3000)  IUSET, IUDET
      CALL GMAIL(0,0)
C
 1000 FORMAT (' ***** GSDETV - ISVOL=0 FOR DETECTOR',A4,' - WARNING!')
 2000 FORMAT (' ***** GSDETV ERROR, VOLUME ',A4,' NOT DEFINED')
 3000 FORMAT (' ***** GSDETV ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' ALREADY DEFINED')
C
  999 RETURN
      END
+DECK,GSDIGI
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDIGI(ISET,IDET,LTRA,NTRA,NUMBV,KDIGI,IDIG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routines to Communicate with the data structure JDIGI       *
C.    *   ---------------------------------------------------------    *
C.    *                                                                *
C.    *   Stores element  values for  current digitisation  into the   *
C.    * data structure JDIGI.                                          *
C.    * ISET      set number                                           *
C.    * IDET      detector number                                      *
C.    * LTRA      list  of   NTRA  track   numbers  producing   this   *
C.    *           digitisation                                         *
C.    * NUMBV     volume  numbers corresponding  to  list NAMESV  of   *
C.    *           GSDET                                                *
C.    * KDIGI     integer  array of  values  for current  digisation   *
C.    *           elements                                             *
C.    * IDIG      on return, current digitisation number.              *
C.    *           If =0 digitisation has not been stored.              *
C.    *                                                                *
C.    *           The Digitisation data structure JDIGI                *
C.    *           -------------------------------------                *
C.    *                                                                *
C.    *                                            | JDIGI             *
C.    *    NSET                  ISET              v                   *
C.    *     ..........................................                 *
C.    *     |                   |  |              |  |                 *
C.    *     ..........................................                 *
C.    *                           |                                    *
C.    *                           | JDIG                               *
C.    *      NDET    IDET         v               NDET                 *
C.    *        .....................................                   *
C.    *        |      |  |      |  |               |                   *
C.    *        .....................................                   *
C.    *                |                                               *
C.    *                | JDD                                           *
C.    *                v                                               *
C.    *               ...........................................      *
C.    *               |  | 1st digitisation | 2nd digitisation, etc.   *
C.    *               ...........................................      *
C.    *                         Bank layout                            *
C.    * JDIG           = LQ(JDIGI-ISET),   pointer to  digitisations   *
C.    *                for set ISET                                    *
C.    * JDD            = LQ(JDIG-IDET),  pointer to digitisations of   *
C.    *                detector IDET of set ISET                       *
C.    * IQ(JDIG+IDET)  pointer to last word of last digitisation for   *
C.    *                this detector                                   *
C.    * IQ(JDD+1)      1st word of first digitisation                  *
C.    * IQ(JDD+NWD+1)  1st word of second digitisation                 *
C.    *                JS=LQ(JSET-ISET)                                *
C.    *                JD=LQ(JS-IDET)                                  *
C.    *                NWD=IQ(JD+5)                                    *
C.    *   The JDIGI  structure is  filled with  the routine  GSDIGI.   *
C.    * The routine GFDIGI can be used  to get the digitisations for   *
C.    * a detector IDET and set ISET.                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Authors    R.Brun, W.Gebel  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDDI,JDI,JDID,LOCAL(15)
      DIMENSION NUMBV(1),KDIGI(1),LTRA(1)
C.
C.    ------------------------------------------------------------------
C.
C             Find if selected set, detector exists
C
      IDIG=0
C
      IF(JSET.LE.0)GO TO 99
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 99
      IF(ISET.LE.0)GO TO 99
      IF(ISET.GT.NSET)GO TO 99
C
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 99
      IF(IDET.LE.0)GO TO 99
      IF(IDET.GT.NDET)GO TO 99
C
      JD=LQ(JS-IDET)
      JDDI=LQ(JD-2)
      IF(JDDI.LE.0)GO TO 99
      NW=IQ(JD+1)+IQ(JD+5)+2
      ND=IQ(JD+6)
      NV=IQ(JD+2)
      NWTR=NTRA/2+1
      NWD=NW+NWTR
C
C              Create DIGItisation master bank
C
      IF(JDIGI.EQ.0)THEN
         CALL MZBOOK(IXDIV,JDIGI,JDIGI,1,'DIGI',NSET,NSET,0,2,0)
         IQ(JDIGI-5)=0
      ENDIF
      JDI=LQ(JDIGI-ISET)
      IF(JDI.EQ.0)THEN
         CALL MZBOOK(IXDIV,JDI,JDIGI,-ISET,'DIGI',NDET,NDET,NDET,2,0)
      ENDIF
C
      JDID=LQ(JDI-IDET)
      IF(JDID.EQ.0)THEN
C
C            Create DIGItisation bank
C
         NWDI=IQ(JD+8)
         CALL MZBOOK(IXDIV,JDID,JDI,-IDET,'SJDI',0,0,NWDI,1,0)
         IQ(JDI+IDET)=0
      ENDIF
C
C           Check if enough space. If not increase bank size
C
  10  NDID=IQ(JDID-1)
      ILAST=IQ(JDI+IDET)
      NFREE=NDID-ILAST
      IF(NFREE.LE.NWD)THEN
         NWDI2=MAX(100,NWD,IQ(JD+8)/2)
         CALL MZPUSH(IXDIV,JDID,0,NWDI2,'I')
         GO TO 10
      ENDIF
C
      IQ(JDI+IDET)=ILAST+NWD
      IF(ILAST.NE.0)IDIG=IQ(JDID+ILAST)
      IDIG=IDIG+1
C
C
C
C
C ========>    Store tracks numbers, volumes numbers and digits
C
      IQ(JDID+ILAST+1)=NWD
      IQ(JDID+ILAST+NWD)=IDIG
      NK=ILAST+2
C
C             Store packed track numbers
C             Every 2 consecutive numbers into 1 word
C             1st half of 1st word: NTRA-1
C
      IQ(JDID+NK)=0
      IF(NTRA.GT.0)THEN
         NTRM1=NTRA-1
         CALL MVBITS(NTRM1,0,16,IQ(JDID+NK),0)
         IF(NTRM1.GE.1)THEN
            DO 23 ITR=1,NTRM1,2
               CALL MVBITS(LTRA(ITR),0,16,IQ(JDID+NK),16)
               NK=NK+1
               CALL MVBITS(LTRA(ITR+1),0,16,IQ(JDID+NK),0)
   23       CONTINUE
         ENDIF
         IF(MOD(NTRA,2).EQ.1)
     +          CALL MVBITS(LTRA(NTRA),0,16,IQ(JDID+NK),16)
      ENDIF
      NK=NK+1
C
C           Store packed volume numbers
C
      IF(NV.GT.0)THEN
         K=1
C
         DO 50 I=1,NV
            NB=IQ(JD+2*I+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JDID+NK)=NUMBV(I)
                K=1
               IF(I.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(NUMBV(I),0,NB,IQ(JDID+NK),K-1)
               K=K+NB
            ENDIF
  50     CONTINUE
         NK=NK+1
      ENDIF
C
C          Store packed digits
C
      IF(ND.GT.0)THEN
         K=1
         DO 90 I=1,ND
            NB=IQ(JDDI+2*I)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JDID+NK)=KDIGI(I)
               NK=NK+1
               K=1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(KDIGI(I),0,NB,IQ(JDID+NK),K-1)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
  99  RETURN
      END
+PATCH,GIOPA
+DECK,DOCGIOPA,IF=DOC
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                       The I/O service routines                       *
*                       ------------------------                       *
*                                                                      *
*  The  I/O routines  permit  to  read and  write,  the GEANT3  data   *
* structures.   The  possibility  exists  to  write  and  read  data   *
* structures to/from  direct access  files, in machine  dependent or   *
* independent format  and to/from direct  access files.  All  I/O is   *
* done via the  ZEBRA I/O routines both for direct  access files (FZ   *
* package) and for direct access files (RZ package).                   *
*  Data can  be generated on one  type of machine, for  example full   *
* detector simulation,  and the data  produced can be analyzed  on a   *
* different machine.                                                   *
*  The data structures written to tape or disk can be read either in   *
* whole or in part.                                                    *
*                                                                      *
*                                                                      *
*                     Routines to perform I/O                          *
*                     -----------------------                          *
*                                                                      *
*       CALL GCLOSE(LUN, IER)                                          *
*                                                                      *
*   LUN       Logical unit number                                      *
*   IER       Error flag                                               *
*                                                                      *
*  Close sequential  FZ file open  with logical unit LUN.   If LUN=0   *
* close all  FZ files.  IER=1  if the file is  no FZ file  open with   *
* logical unit LUN is found, 0 otherwise.                              *
*                                                                      *
*      CALL GFIN(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)                     *
*                                                                      *
*   LUN       Logical unit number                                      *
*   CHOBJ     CHARACTER*4 array containing the data structures to be   *
*             read (DIGI,DRAW,HEAD,HITS,KINE,MATE,PART,ROTM,RUNG,      *
*             SETS,STAK,STAT,TMED,VERT,VOLU,JXYZ,SCAN). In addition    *
*             the following keywords are defined:                      *
*             INIT = DRAW,MATE,PART,ROTM,RUNG,SETS,TMED,VOLU,SCAN      *
*             KINE = KINE,VERT                                         *
*             TRIG = DIGI,HEAD,HITS,KINE,VERT,JXYZ                     *
*   NKEYS     Number of valid elements in the array CHOBJ              *
*   IDVERS    Version to be retrieved. If IDVERS=0 the first version   *
*             found will be retrieved.                                 *
*   CHOPT     Character option.                                        *
*   IER       Error flag. -1 if nothing has been read in. >0  in not   *
*             all the requested data structures have been read in.     *
*                                                                      *
*                                                                      *
*                                                                      *
*  Routine  to  read GEANT  object(s)  from    a  FZ file  The  data   *
* structures from disk are read in memory.                             *
*                                                                      *
*      CALL GFOUT(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)                    *
*                                                                      *
*  See above for  the parameters.  Routine to  write GEANT object(s)   *
* into a  FZ file  The data  structures are  written from  memory to   *
* disk.                                                                *
*                                                                      *
*      CALL GOPEN(LUN,LUNTYP,LEN,IER)                                  *
*                                                                      *
*   LUN       Logical unit                                             *
*   LUNTYP    CHARACTER variable specifying the format of the FZ       *
*             file. Possible options are I,O,A,X. See the FZ manual    *
*             for more information.                                    *
*   LEN       Logical record length of the FZ file.                    *
*   IER       Error flag. 0 if file has been open correctly.           *
*                                                                      *
*  Routine to open a FZ file for input or output.                      *
*                                                                      *
*      CALL GREND (LUN)                                                *
*                                                                      *
*    LUN      Logical unit                                             *
*                                                                      *
*  Routine to close the RZ direct access file opened with logical      *
* unit LUN.                                                            *
*                                                                      *
*      CALL GRFILE(LUN,CHFILE,CHOPTT)                                  *
*                                                                      *
*    LUN      Logical unit number                                      *
*    CHFILE   Name of the file to be open                              *
*    CHOPTT   Character option                                         *
*                                                                      *
*  Routine to open an  RZ file for input or output.   If option I is   *
* given, then  the INIT data structures  will be read from  the file   *
* and if the option O is given they will be written to the file.       *
*                                                                      *
*      CALL GRIN(CHOBJT,IDVERS,CHOPT)                                  *
*                                                                      *
*   CHOBJT    CHARACTER*4 variable with the name of the data           *
*             structure to be retrieved. See GFIN for more details.    *
*   IDVERS    Version of the data structure to be retrieved. If 0      *
*             the first found data structure will be retrieved.        *
*   CHOPT     Option variable                                          *
*                                                                      *
*  Routine  to  read  from  a  RZ  direct  access  file  GEANT  data   *
* structures.                                                          *
*                                                                      *
*      CALL GRLEAS(JBANK)                                              *
*                                                                      *
*   JBANK     Pointer to a data structure                              *
*                                                                      *
*  Routine to release unused space  in the data structure pointed to   *
* by JBANK.                                                            *
*                                                                      *
*      CALL GRMDIR(CHDIR,CHOPT)                                        *
*                                                                      *
*    CHDIR    Name of the directory                                    *
*    CHOPT    Character option                                         *
*                                                                      *
*  Routine to create a GEANT subdirectory in an RZ file.               *
*                                                                      *
*      CALL GROUT(CHOBJT,IDVERS,CHOPT)                                 *
*                                                                      *
*  Routine  to  write  to  a   RZ  direct  access  file  GEANT  data   *
* structures.  See GRIN for explanations on the parameters.            *
*                                                                      *
************************************************************************
+DECK,GCLOSE
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GCLOSE (LUN,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to close I/O units                               *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       IER      error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGLAST                               *
C.    *       Authors    R.Brun, F.Carena  *********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCUNIT
C.
C.    ------------------------------------------------------------------
C.
      IER=0
      IF(LUN.EQ.0)THEN
         CALL FZENDO(LUN,'T')
         CALL FZENDI(LUN,'T')
      ELSE
         DO 10 I=1,NUNITS
            IF(LUN.EQ.ABS(LUNITS(I)))THEN
               IF(LUNITS(I).LT.0)THEN
                  CALL FZENDI(LUN,'T')
               ELSE
                  CALL FZENDO(LUN,'T')
               ENDIF
               LUNITS(I)=0
               GOTO 999
            ENDIF
   10    CONTINUE
         IER=1
      ENDIF
  999 CONTINUE
      END
+DECK,GFIN.
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFIN(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read GEANT object(s) fromin the FZ file       *
C.    *       The data structures from disk are read in memory         *
C.    *                                                                *
C.    *       LUN    Logical unit                                      *
C.    *                                                                *
C.    *       CHOBJ  The type of data structure to be read:            *
C.    *              MATE material                                     *
C.    *              TMED tracking medium                              *
C.    *              VOLU volumes                                      *
C.    *              ROTM rotation matrix                              *
C.    *              SETS detector set                                 *
C.    *              PART particle                                     *
C.    *              SCAN geometry                                     *
C.    *              INIT read all above                               *
C.    *              KINE this keyword will trigger the read of        *
C.    *                   KINE and VERT unless the flag 'S' is set     *
C.    *              DIGI digitisation                                 *
C.    *              DRAW drawing                                      *
C.    *              HEAD event header                                 *
C.    *              HITS hits                                         *
C.    *              RUNG run                                          *
C.    *              STAK particle temporary stack                     *
C.    *              STAT volume statistic                             *
C.    *              VERT vertex                                       *
C.    *              JXYZ track points                                 *
C.    *              TRIG this keyword will trigger the read of        *
C.    *                   DIGI, HEAD, HITS, KINE, VERT abd JXYZ        *
C.    *                   unless the 'S' flag is set                   *
C.    *                                                                *
C.    *       NKEYS  number of keys in vector CHOBJ                    *
C.    *                                                                *
C.    *       IDVERS version of the data structure to be read in       *
C.    *                                                                *
C.    *       CHOPT  List of options                                   *
C.    *                   'I'      read only initialisation data       *
C.    *                            structures                          *
C.    *                   'K'      read only KINE and TRIG data        *
C.    *                            structures                          *
C.    *                   'T'      read only DIGI, HEAD, HITS, KINE,   *
C.    *                            VERT and JXYZ data structures       *
C.    *              even if other keys are specified in CHOBJ         *
C.    *                                                                *
C.    *                   'S'       interpret KINE to mean only        *
C.    *                             KINE and TRIG and INIT to mean     *
C.    *                             nothing                            *
C.    *                   'Q'       quiet option, no message is        *
C.    *                             printed                            *
C.    *                                                                *
C.    *       IER    error flag. <0 ZEBRA error flag as returned in    *
C.    *                             IQUEST(1)                          *
C.    *                           0 read completed successfully        *
C.    *                          >0 if only IER structures read in     *
C.    *                                                                *
C.    *    The FZ data base has been created via GOPEN/GFOUT           *
C.    *                                                                *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GOPEN(1,'I',1024,IER)                                *
C.    *      CALL GFIN (1,'VOLU',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'MATE',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'TMED',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'ROTM',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'PART',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'SCAN',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'SETS',1,0,' ',IER)                          *
C.    *                                                                *
C.    *    ==>Called by : <USER> ,GOPEN                                *
C.    *       Author    F.Carminati *******                            *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCFLAG.
+SEQ,GCONSP.
+SEQ,GCNUM.
+SEQ,GCCUTS.
+SEQ,GCSCAL.
+SEQ,GCDRAW.
+SEQ,GCVOLU.
+SEQ,GCUNIT.
+SEQ,GCTIME
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),LINIT(NLINIT),LKINE(NLKINE)
      DIMENSION LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),IVERSI(NMKEY),LDIV(2),IRESUL(NMKEY)
      DIMENSION IDOLD(8), IDNEW(8), VEROLD(8), VERNEW(8)
      DIMENSION IUHEAD(2),ITRAN(23)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 KNAMES(NMKEY),CHOBJ(*)
      CHARACTER*(*) CHOPT
      DATA KNAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +     'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +     'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA ITRAN/7,6,13,16,8,10,2,9,8*0,3,15,5,17,4,1,21/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA IDNEW / 8*0 /
      DATA VERNEW / 8*0. /
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
      KVOL=JVOLUM
      IER=0
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTS=INDEX(CHOPT,'s')+INDEX(CHOPT,'S')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
*     Save old JRUNG dates and versions
      IF(JRUNG.GT.0) THEN
         DO 10 J=1,8
            IDOLD(J) = IQ(JRUNG+10+J)
            VEROLD(J) = Q(JRUNG+20+J)
   10    CONTINUE
      ENDIF
*
      NLINK=0
      DO 100 JKEY=1,NKEYS
         IF(IOPTS.EQ.0) THEN
         IF(CHOBJ(JKEY).EQ.'INIT') THEN
            DO 30 J=1, NLINIT
               DO 20  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LINIT(J)) GO TO 30
   20          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LINIT(J)
   30       CONTINUE
            GO TO 100
         ELSEIF(CHOBJ(JKEY).EQ.'TRIG') THEN
            DO 50 J=1, NLTRIG
               DO 40  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LTRIG(J)) GO TO 50
   40          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LTRIG(J)
   50       CONTINUE
            GO TO 100
         ELSEIF(CHOBJ(JKEY).EQ.'KINE') THEN
            DO 70 J=1, NLKINE
               DO 60  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LKINE(J)) GO TO 70
   60          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LKINE(J)
   70       CONTINUE
            GO TO 100
         ENDIF
         ENDIF
            DO 90 J=1,NMKEY
               IF(CHOBJ(JKEY).EQ.KNAMES(J)) THEN
                  DO 80 MLINK=1,NLINK
                     IF(LINK(MLINK).EQ.J) GO TO 100
   80             CONTINUE
                  NLINK=NLINK+1
                  LINK(NLINK)=J
                  GO TO 100
               ENDIF
   90       CONTINUE
            WRITE(CHMAIL,10300) CHOBJ(JKEY)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
  100 CONTINUE
*
      IF(IOPTI.GT.0) THEN
         DO 120 J=1, NLINK
            DO 110 K=1, NLINIT
               IF(LINK(J).EQ.LINIT(K)) GO TO 120
  110       CONTINUE
            WRITE(CHMAIL,10000) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  120    CONTINUE
      ELSEIF(IOPTK.GT.0) THEN
         DO 140 J=1, NLINK
            DO 130 K=1, NLKINE
               IF(LINK(J).EQ.LKINE(K)) GO TO 140
  130       CONTINUE
            WRITE(CHMAIL,10100) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  140    CONTINUE
      ELSEIF(IOPTT.GT.0) THEN
         DO 160 J=1, NLINK
            DO 150 K=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(K)) GO TO 160
  150       CONTINUE
            WRITE(CHMAIL,10200) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  160    CONTINUE
      ENDIF
      IOFF=0
      DO 170 J=1, NLINK
         IF(LINK(J).EQ.0) THEN
            IOFF=IOFF-1
         ELSE
            LINK(J+IOFF)=LINK(J)
         ENDIF
  170 CONTINUE
      NLINK=NLINK+IOFF
      NPOS=0
      DO 171 JL=1,NLINK
         IF(LINK(JL).EQ.9.OR.LINK(JL).EQ.3) THEN
            NPOS=JL
            GOTO 172
         ENDIF
  171 CONTINUE
  172 CONTINUE
*
      IF(NLINK.LE.0) THEN
         WRITE(CHMAIL,10400)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
         GOTO 999
      ENDIF
*
      IF(IOPTI+IOPTK+IOPTT.EQ.0) THEN
*
*        We have to choose which event header to read, JRUNG or JHEAD
*        If the banks list contains banks depending from both headers,
*        the result is unpredictable. Error message to be inserted later.
         DO 168 J=1, NLINK
            DO 161 L=1, NLINIT
               IF(LINK(J).EQ.LINIT(L)) THEN
                  IOPTI=-1
                  GOTO 169
               ENDIF
  161       CONTINUE
            DO 162 L=1, NLKINE
               IF(LINK(J).EQ.LKINE(L)) THEN
                  IOPTK=-1
                  GOTO 169
               ENDIF
  162       CONTINUE
            DO 163 L=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(L)) THEN
                  IOPTT=-1
                  GOTO 169
               ENDIF
  163       CONTINUE
  168    CONTINUE
  169    CONTINUE
      ENDIF
*
      DO 180 J=1, NLINK
         IVERSI(J)=0
         IRESUL(J)=0
  180 CONTINUE
*
*               Go for next start of event data structure
  190 IF(IOPTI.NE.0) THEN
         IF(JRUNG.NE.0)CALL MZDROP(IXCONS,JRUNG,' ')
         NUH=2
         CALL FZIN(LUN,IXCONS,JRUNG,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GE.2) THEN
            IER = -IQUEST(1)
            GO TO 240
         ENDIF
         IF(NPOS.NE.0) THEN
            IVERSI(NPOS)=IUHEAD(1)
            IRESUL(NPOS)=1
         ENDIF
      ELSEIF(IOPTT+IOPTK.NE.0) THEN
         IF(JHEAD.NE.0)CALL MZDROP(IXDIV,JHEAD,' ')
         NUH=2
         CALL FZIN(LUN,IXDIV,JHEAD,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GE.2) THEN
            IER = -IQUEST(1)
            GO TO 240
         ENDIF
         IF(NPOS.NE.0) THEN
            IVERSI(NPOS)=IUHEAD(1)
            IRESUL(NPOS)=1
         ENDIF
      ENDIF
*
      IVERIN = IUHEAD(1)
      IF(IDVERS.NE.0.AND.IDVERS.NE.IVERIN) THEN
         DO 200 I=1,NLINK
            LINK(I)=-ABS(LINK(I))
  200    CONTINUE
         GOTO 190
      ELSE
         IF (IDVERS .EQ. 0) IDVERS = IVERIN
         DO 210 I=1,NLINK
            LINK(I)= ABS(LINK(I))
  210    CONTINUE
      ENDIF
      NK   = IUHEAD(2)
      IF(NK.GT.10) THEN
         WRITE(CHMAIL,11100) NK
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
         GO TO 999
      ENDIF
      DO 230 IK=1,NK
C
C              Read next header
C
         NUH=2
         CALL FZIN(LUN,0,0,0,'S',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 320
         IKEY=ITRAN(IUHEAD(1))
         DO 220 I=1,NLINK
            NKEY=LINK(I)
            IF(IKEY.EQ.NKEY)THEN
               IDIV=LDIV(IXD(NKEY))
               IF(NKEY.LE.20)THEN
                  IF(JNAMES(NKEY).NE.0)THEN
                     CALL MZDROP(IDIV,JNAMES(NKEY),'L')
                     JNAMES(NKEY)=0
                  ENDIF
                  CALL FZIN(LUN,IDIV,JNAMES(NKEY),1,'A',NUH,IUHEAD)
               ELSE
                  NKL=NKEY-20
                  IF(ISLINK(NKL).NE.0)THEN
                     CALL MZDROP(IDIV,ISLINK(NKL),'L')
                     ISLINK(NKL)=0
                  ENDIF
                  CALL FZIN(LUN,IDIV,ISLINK(NKL),1,'A',NUH,IUHEAD)
               ENDIF
               IF(IQUEST(1).LE.2.AND.IQUEST(1).GE.0) THEN
                  IVERSI(I)=IVERIN
                  IRESUL(I)=1
                  GOTO 230
               ELSE
                  GOTO 320
               ENDIF
            ENDIF
  220    CONTINUE
  230 CONTINUE
*
  240 NIN=0
      DO 250 I=1,NLINK
         IF(IRESUL(I).EQ.1) THEN
            WRITE(CHMAIL,10500) KNAMES(LINK(I)), IVERSI(I)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            NIN=NIN+1
         ELSEIF(LINK(I).GT.0) THEN
            WRITE(CHMAIL,10600) KNAMES(LINK(I))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         ELSEIF(LINK(I).LT.0) THEN
            WRITE(CHMAIL,10700) KNAMES(-LINK(I)), IDVERS
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         ENDIF
  250 CONTINUE
*
      IF(NIN.EQ.0) THEN
         WRITE(CHMAIL,10800)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IF(IER.GE.0) IER=-1
         GOTO 999
      ELSEIF(NIN.LT.NLINK) THEN
         IER=NIN
      ENDIF
*
      IF(KVOL.NE.JVOLUM)THEN
         NVOLUM=IQ(JVOLUM-1)
         CALL MZGARB(IXCONS,0)
         CALL GGDVLP
         CALL GGNLEV
      ENDIF
*
      IF(JVOLUM.GT.0) THEN
         NLEVEL=0
         NVOLUM=0
         DO 260 J=1, IQ(JVOLUM-2)
            IF(LQ(JVOLUM-J).EQ.0) GOTO 270
            NVOLUM=NVOLUM+1
  260    CONTINUE
  270    CONTINUE
      ENDIF
*
      IF(JTMED.NE.0 )THEN
         CALL UCOPY(Q(JTMED+1),CUTGAM,10)
         NTMED=IQ(JTMED-2)
      ENDIF
*
      IF(JPART.NE.0 ) NPART = IQ(JPART-2)
      IF(JVERTX.NE.0) NVERTX = IQ(JVERTX+1)
      IF(JKINE.NE.0) NTRACK = IQ(JKINE+1)
      IF(JMATE.NE.0 ) NMATE = IQ(JMATE-2)
      IF(JROTM.NE.0 ) NROTM = IQ(JROTM-2)
      IF(JDRAW.GT.0 ) THEN
         NKVIEW = IQ(JDRAW-2)
      ELSE
         NKVIEW = 0
C
C             Book JDRAW structure for view banks
C
         CALL MZBOOK(IXCONS,JDRAW,JDRAW,1,'DRAW',0,0,0,3,0)
      ENDIF
 
C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
      IF(JRUNG.GT.0) THEN
*
*             Here we deal with version numbers If JRUNG has been read in,
*             then save the version numbers of the new JRUNG and restore
*             the current version number for KINE, HITS and DIGI
         DO 300 J=1, NLINK
            IF(IVERSI(J).GT.0) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'RUNG') THEN
                  DO 280 I=1,8
                     IDNEW(I) = IQ(JRUNG+10+I)
                     VERNEW(I) = Q(JRUNG+20+I)
  280             CONTINUE
*
*             And we put back the old version numbers because,
*             in principle, KINE, HITS and DIGI have not be read in
                  DO 290 I=3,8
                     IQ(JRUNG+10+I) = IDOLD(I)
                     Q(JRUNG+20+I) = VEROLD(I)
  290             CONTINUE
               ENDIF
            ENDIF
  300    CONTINUE
*
*            And here we do it again for KINE, HITS and DIGI
         DO 310 J=1, NLINK
            IF(IVERSI(J).GT.0) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'KINE') THEN
                  IF(IDNEW(3).GT.0) THEN
                     IQ(JRUNG+13) = IDNEW(3)
                     IQ(JRUNG+14) = IDNEW(4)
                     Q(JRUNG+23) = VERNEW(3)
                     Q(JRUNG+24) = VERNEW(4)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'HITS') THEN
                  IF(IDNEW(5).GT.0) THEN
                     IQ(JRUNG+15) = IDNEW(5)
                     IQ(JRUNG+16) = IDNEW(6)
                     Q(JRUNG+25) = VERNEW(5)
                     Q(JRUNG+26) = VERNEW(6)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'DIGI') THEN
                  IF(IDNEW(7).GT.0) THEN
                     IQ(JRUNG+17) = IDNEW(7)
                     IQ(JRUNG+18) = IDNEW(8)
                     Q(JRUNG+27) = VERNEW(7)
                     Q(JRUNG+28) = VERNEW(8)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'MATE'.OR. KNAMES(NKEY) .EQ.'TMED'
     +         ) THEN
                  IF(VERNEW(1).NE.0) THEN
*                We know which version number we are reading
                     IF(VERNEW(1).LT.GVERSN) THEN
                        WRITE(CHMAIL,10900) KNAMES(NKEY),VERNEW(1),
     +                  GVERSN
                        IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
                        WRITE(CHMAIL,11000)
                        IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
  310    CONTINUE
      ENDIF
  320 CONTINUE
*
10000 FORMAT(' *** GFIN *** Key ',A4,' ignored for initialization')
10100 FORMAT(' *** GFIN *** Key ',A4,' ignored for kinematics')
10200 FORMAT(' *** GFIN *** Key ',A4,' ignored for trigger')
10300 FORMAT(' *** GFIN *** Unknown key ',A4)
10400 FORMAT(' *** GFIN *** No valid key given')
10500 FORMAT(' *** GFIN *** Data structure ',A4,' version ',I10,
     +       ' successfully read in ')
10600 FORMAT(' *** GFIN *** Data structure ',A4,' was not found')
10700 FORMAT(' *** GFIN *** Data structure ',A4,' version ',I10,
     +       ' was not found')
10800 FORMAT(' *** GFIN *** Nothing found to read !')
10900 FORMAT(' *** GFIN *** ',A4,' data structure ',
     +       'version ',F6.4,' current version is ',F6.4)
11000 FORMAT('              Please call subroutine GPHYSI before ',
     +       'tracking')
11100 FORMAT(' *** GFIN ***  Illegal number of links ',I10)
  999 CONTINUE
      END
+DECK,GFOUT.
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GFOUT(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write GEANT object(s) into the FZ file        *
C.    *       The data structures in memory are written on disk        *
C.    *                                                                *
C.    *       LUN    Logical unit                                      *
C.    *                                                                *
C.    *       CHOBJ  The type of data structure to be written:         *
C.    *              MATE material                                     *
C.    *              TMED tracking medium                              *
C.    *              VOLU volumes                                      *
C.    *              ROTM rotation matrix                              *
C.    *              SETS detector set                                 *
C.    *              PART particle                                     *
C.    *              SCAN geometry                                     *
C.    *              INIT all above                                    *
C.    *              KINE this keyword will trigger the write of       *
C.    *                   KINE and VERT unless the flag 'S' is set     *
C.    *              DIGI digitisation                                 *
C.    *              DRAW drawing                                      *
C.    *              HEAD event header                                 *
C.    *              HITS hits                                         *
C.    *              RUNG run                                          *
C.    *              STAK particle temporary stack                     *
C.    *              STAT volume statistic                             *
C.    *              VERT vertex                                       *
C.    *              JXYZ track points                                 *
C.    *              TRIG this keyword will trigger the write of       *
C.    *                   DIGI, HEAD, HITS, KINE, VERT abd JXYZ        *
C.    *                   unless the 'S' flag is set                   *
C.    *                                                                *
C.    *       NKEYS  number of keys in vector CHOBJ                    *
C.    *                                                                *
C.    *       IDVERS version of the data structure to be written out   *
C.    *                                                                *
C.    *       CHOPT  List of options                                   *
C.    *                   'I'      write only initialisation data      *
C.    *                            structures                          *
C.    *                   'K'      write only KINE and TRIG data       *
C.    *                            structures                          *
C.    *                   'T'      write only DIGI, HEAD, HITS, KINE,  *
C.    *                            VERT and JXYZ data structures       *
C.    *              even if other keys are specified in CHOBJ         *
C.    *                                                                *
C.    *                   'S'       interpret KINE to mean only        *
C.    *                             KINE and TRIG and INIT to mean     *
C.    *                             nothing                            *
C.    *                   'Q'       quiet option, no message is        *
C.    *                             printed                            *
C.    *                                                                *
C.    *       IER    error flag. <0 ZEBRA error flag as returned in    *
C.    *                             IQUEST(1)                          *
C.    *                           0 read completed successfully        *
C.    *                          >0 if only IER structures read in     *
C.    *                                                                *
C.    *    The FZ data base can be read in via GOPEN/GFIN              *
C.    *                                                                *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GOPEN(1,'O',1024,IER)                                *
C.    *      CALL GFOUT (1,'VOLU',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'MATE',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'TMED',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'ROTM',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'PART',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'SCAN',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'SETS',1,0,' ',IER)                         *
C.    *                                                                *
C.    *    ==>Called by : <USER> ,GOPEN                                *
C.    *       Author    F.Carminati *******                            *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCFLAG.
+SEQ,GCONSP.
+SEQ,GCNUM.
+SEQ,GCCUTS.
+SEQ,GCSCAL.
+SEQ,GCDRAW.
+SEQ,GCVOLU.
+SEQ,GCUNIT.
+SEQ,GCTIME.
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),LINIT(NLINIT),LKINE(NLKINE)
      DIMENSION LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),IVERSI(NMKEY),LDIV(2),IRESUL(NMKEY)
      DIMENSION IUHEAD(2),ITRAN(23),JTRAN(23)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 KNAMES(NMKEY),CHOBJ(*)
      CHARACTER*(*) CHOPT
      DATA KNAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +     'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +     'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA ITRAN/7,6,13,16,8,10,2,9,8*0,3,15,5,17,4,1,21/
      DATA JTRAN/22,7,17,21,19,2,1,5,8,6,2*0,3,0,18,4,20,3*0,23,2*0/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      IER=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTS=INDEX(CHOPT,'s')+INDEX(CHOPT,'S')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
      NLINK=0
      DO 90  JKEY=1,NKEYS
         IF(IOPTS.EQ.0) THEN
         IF(CHOBJ(JKEY).EQ.'INIT') THEN
            DO 20 J=1, NLINIT
               DO 10  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LINIT(J)) GO TO 20
   10          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LINIT(J)
   20       CONTINUE
            GO TO 90
         ELSEIF(CHOBJ(JKEY).EQ.'TRIG') THEN
            DO 40 J=1, NLTRIG
               DO 30  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LTRIG(J)) GO TO 40
   30          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LTRIG(J)
   40       CONTINUE
            GO TO 90
         ELSEIF(CHOBJ(JKEY).EQ.'KINE') THEN
            DO 60 J=1, NLKINE
               DO 50  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LKINE(J)) GO TO 60
   50          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LKINE(J)
   60       CONTINUE
            GO TO 90
         ENDIF
         ENDIF
            DO 80 J=1,NMKEY
               IF(CHOBJ(JKEY).EQ.KNAMES(J)) THEN
                  DO 70 MLINK=1,NLINK
                     IF(LINK(MLINK).EQ.J) GO TO 90
   70             CONTINUE
                  NLINK=NLINK+1
                  LINK(NLINK)=J
                  GO TO 90
               ENDIF
   80       CONTINUE
            WRITE(CHMAIL,10300) CHOBJ(JKEY)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
   90 CONTINUE
*
      IF(IOPTI.GT.0) THEN
         DO 110 J=1, NLINK
            DO 100 K=1, NLINIT
               IF(LINK(J).EQ.LINIT(K)) GO TO 110
  100       CONTINUE
            WRITE(CHMAIL,10000) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  110    CONTINUE
      ELSEIF(IOPTK.GT.0) THEN
         DO 130 J=1, NLINK
            DO 120 K=1, NLKINE
               IF(LINK(J).EQ.LKINE(K)) GO TO 130
  120       CONTINUE
            WRITE(CHMAIL,10100) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  130    CONTINUE
      ELSEIF(IOPTT.GT.0) THEN
         DO 150 J=1, NLINK
            DO 140 K=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(K)) GO TO 150
  140       CONTINUE
            WRITE(CHMAIL,10200) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  150    CONTINUE
      ENDIF
*
      IOFF=0
      DO 160 J=1, NLINK
         IF(LINK(J).EQ.0) THEN
           IOFF=IOFF-1
         ELSE
           LINK(J+IOFF)=LINK(J)
         ENDIF
  160 CONTINUE
      NLINK=NLINK+IOFF
      IF(IOPTI+IOPTK+IOPTT.EQ.0) THEN
*
*        We have to choose which event header to write, JRUNG or JHEAD
*        If the banks list contains banks which depends on both headers,
*        the result is unpredictable. Error message to be inserted later.
         DO 168 J=1, NLINK
            DO 161 L=1, NLINIT
               IF(LINK(J).EQ.LINIT(L)) THEN
                  IOPTI=-1
                  GOTO 169
               ENDIF
  161       CONTINUE
            DO 162 L=1, NLKINE
               IF(LINK(J).EQ.LKINE(L)) THEN
                  IOPTK=-1
                  GOTO 169
               ENDIF
  162       CONTINUE
            DO 163 L=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(L)) THEN
                  IOPTT=-1
                  GOTO 169
               ENDIF
  163      CONTINUE
  168    CONTINUE
  169    CONTINUE
      ENDIF
*
      IF(NLINK.LE.0) THEN
         WRITE(CHMAIL,10400)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
         GOTO 999
      ENDIF
*
      NWOUT=0
      IOFW =0
      DO 170 J=1,NLINK
         IVERSI(J)=0
         IRESUL(J)=0
         NKEY=LINK(J)
         IF(NKEY.EQ.3.OR.NKEY.EQ.9) THEN
            IOFW=1
            NPOS=J
         ENDIF
         LINK(J)=-ABS(LINK(J))
         IF(NKEY.LE.20)THEN
            IF(JNAMES(NKEY).NE.0) THEN
               LINK(J)=ABS(LINK(J))
               NWOUT=NWOUT+1
            ENDIF
         ELSE
            NKL=NKEY-20
            IF(ISLINK(NKL).NE.0) THEN
               LINK(J)=ABS(LINK(J))
               NWOUT=NWOUT+1
            ENDIF
         ENDIF
  170 CONTINUE
*
*               Write next start of event data structure
      IUHEAD(1)=IDVERS
      IUHEAD(2)=NWOUT-IOFW
      NUH=2
      IF(IOPTI.NE.0) THEN
         CALL FZOUT(LUN,IXCONS,JRUNG,1,'L',2,NUH,IUHEAD)
      ELSEIF(IOPTT+IOPTK.NE.0) THEN
         CALL FZOUT(LUN,IXDIV,JHEAD,1,'L',2,NUH,IUHEAD)
      ENDIF
      IF(IQUEST(1).EQ.0) THEN
         IVERSI(NPOS)=IDVERS
         IRESUL(NPOS)=1
      ELSE
         WRITE(CHMAIL,10500) KNAMES(LINK(NPOS))
      ENDIF
*
      DO 180 IK=1,NLINK
*
*              Write selected data structures
         NKEY=LINK(IK)
         IF(NKEY.GT.0) THEN
            IF(NKEY.EQ.9) THEN
               GOTO 180
            ELSEIF(NKEY.EQ.3) THEN
               GOTO 180
            ELSEIF(NKEY.EQ.1) THEN
               CALL GRLEAS(JDIGI)
            ELSEIF(NKEY.EQ.4) THEN
               CALL GRLEAS(JHITS)
            ENDIF
            IDIV=LDIV(IXD(NKEY))
            JKEY=JTRAN(NKEY)
            IF(NKEY.LE.20)THEN
               CALL FZOUT(LUN,IDIV,JNAMES(NKEY),0,'L',2,1,JKEY)
            ELSE
               NKL=NKEY-20
               CALL FZOUT(LUN,IDIV,ISLINK(NKL),0,'L',2,1,JKEY)
            ENDIF
            IF(IQUEST(1).EQ.0) THEN
               IVERSI(IK)=IDVERS
               IRESUL(IK)=1
            ELSE
               WRITE(CHMAIL,10500) KNAMES(NKEY)
            ENDIF
         ENDIF
  180 CONTINUE
*
      NOUT=0
      DO 190 I=1,NLINK
         IF(IRESUL(I).EQ.1) THEN
            WRITE(CHMAIL,10600) KNAMES(ABS(LINK(I))),IVERSI(I)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            NOUT=NOUT+1
         ELSE
            WRITE(CHMAIL,10700) KNAMES(ABS(LINK(I)))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         ENDIF
  190 CONTINUE
*
      IF(NOUT.LE.0) THEN
         WRITE(CHMAIL,10800)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
      ELSEIF(NOUT.LT.NLINK) THEN
         IER=NOUT
      ENDIF
*
10000 FORMAT(' *** GFOUT *** Key ',A4,' ignored for initialization')
10100 FORMAT(' *** GFOUT *** Key ',A4,' ignored for kinematics')
10200 FORMAT(' *** GFOUT *** Key ',A4,' ignored for trigger')
10300 FORMAT(' *** GFOUT *** Unknown key ',A4)
10400 FORMAT(' *** GFOUT *** No valid key given')
10500 FORMAT(' *** GFOUT *** Problems writing data structure ',A4)
10600 FORMAT(' *** GFOUT *** Data structure ',A4,' version ',I10,
     +       ' successfully written out')
10700 FORMAT(' *** GFOUT *** Data structure ',A4,' not found')
10800 FORMAT(' *** GFOUT *** Nothing written out !')
  999 CONTINUE
      END
+DECK,GGET
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GGET (LUN,KEYSU,NUKEYS,IDENT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read in data structures                       *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       KEYSU    Keywords to select data structures              *
C.    *       NKEYS    Number of keywords                              *
C.    *       IER      Error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUKINE                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCFLAG
+SEQ,GCNUM
+SEQ,GCDRAW
+SEQ,GCCUTS
      COMMON/QUEST/IQUEST(100)
C
      CHARACTER*4 KLEY(22)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYS(22),IUHEAD(2)
      DIMENSION KSEL(14),LKEY(22),LKNUM(22),LINK(14),JLINK(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      SAVE IFIRST,LKEY
      DATA LINK/7,6,13,16,8,10,2,9,3,15,5,17,4,1/
      DATA KLEY/'PART','MATE','TMED','VOLU','ROTM','SETS','DRAW','RUNG'
     +         ,'INIT','INIT','INIT','INIT','INIT','INIT','INIT','INIT'
     +         ,'HEAD','KINE','KINE','JXYZ','HITS','DIGI'/
      DATA LKNUM/1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,10,11,12,13,14/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,88)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GGET *** Obsolete routine. Please use GFIN')
C
      IDENT=-1
      IER    = 0
      NKEYS=IABS(NUKEYS)
      IF (NKEYS.LE.0)                                 GO TO 99
      CALL UCTOH(KEYSU,KEYS,4,4*NKEYS)
C
      IF(NUKEYS.LT.0)THEN
        I1=1
        I2=15
        K1=1
        K2=7
      ELSE
        I1=18
        I2=22
        K1=10
        K2=14
      ENDIF
C
      NKT=0
      DO 10 K=K1,K2
  10  KSEL(K)=0
      DO 20 I=I1,I2
      N=LKNUM(I)
      DO 20 IK=1,NKEYS
      IF(KEYS(IK).EQ.LKEY(I))THEN
         KSEL(N)=1
         NKT=NKT+1
      ENDIF
  20  CONTINUE
      IF(NKT.EQ.0)GO TO 99
      NUH=2
C
C               Go for next start of event data structure
C
      IF(NUKEYS.LT.0)THEN
         IF(JRUNG.NE.0)CALL MZDROP(IXCONS,JRUNG,' ')
         CALL FZIN(LUN,IXCONS,JRUNG,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
         IDIV=IXCONS
      ELSE
         IF(JHEAD.NE.0)CALL MZDROP(IXDIV,JHEAD,' ')
         CALL FZIN(LUN,IXDIV,JHEAD,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
         IDIV=IXDIV
      ENDIF
C
      IDENT= IUHEAD(1)
      NK   = IUHEAD(2)
      IF(NK.LE.0)GO TO 99
      IF(NK.GT.10)GO TO 99
      DO 30 I=1,NK
C
C              Read next header
C
         NUH=2
         CALL FZIN(LUN,IDIV,0,0,'S',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
         KS=IUHEAD(1)
         IF(KS.LE.0)GO TO 30
         IF(KS.GT.14)GO TO 30
         IF(KSEL(KS).EQ.0)GO TO 30
         IL=LINK(KS)
         IF(JLINK(IL).NE.0)CALL MZDROP(IDIV,JLINK(IL),' ')
C
C              Read pending data structure
C
         CALL FZIN(LUN,IDIV,JLINK(IL),1,'A',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
  30  CONTINUE
C
C             Fill header bank
C             Reconstruct NKVIEW,NVOLUM,NVERTX,NTRACK
C             Reconstruct NMATE, NTMED, NPART
C
      IF(NUKEYS.LT.0)THEN
         IF(KSEL(1).NE.0.AND.JPART.GT.0) NPART=IQ(JPART-2)
         IF(KSEL(2).NE.0.AND.JMATE.NE.0) NMATE=IQ(JMATE-2)
         IF(KSEL(3).NE.0.AND.JTMED.NE.0) THEN
            CALL UCOPY(Q(JTMED+1),CUTGAM,10)
            NTMED=IQ(JTMED-2)
         ENDIF
         IF(KSEL(4).NE.0.AND.JVOLUM.GT.0) THEN
            NVOLUM=0
            DO 40 J=1, IQ(JVOLUM-2)
               IF(LQ(JVOLUM-J).EQ.0) GO TO 50
               NVOLUM=NVOLUM+1
  40        CONTINUE
  50        CONTINUE
         END IF
         IF(KSEL(7).NE.0.AND.JDRAW.GT.0) NKVIEW=IQ(JDRAW-2)
      ENDIF
C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
C
      IF(KSEL(10).GT.0)THEN
         NVERTX=0
         NTRACK=0
         IF(JVERTX.GT.0)NVERTX=IQ(JVERTX+1)
         IF(JKINE .GT.0)NTRACK=IQ(JKINE +1)
      ENDIF
      GO TO 99
C
C             Error, EOF,etc
C
  90  IER=IQUEST(1)
C
  99  RETURN
      END
+DECK,GOPEN
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GOPEN (LUN,LUNTYP,LEN,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to open I/O units                                *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       LUNTYP   ZEBRA flag    I,O,X  (must be CHARACTER)        *
C.    *                'I' LUN is an INPUT file                        *
C.    *                'O' LUN is an OUTPUT file                       *
C.    *                'X' LUN is in exchange mode format              *
C.    *       LEN      Buffer length (see FZFILE)                      *
C.    *       IER      error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCUNIT
      CHARACTER*(*) LUNTYP
C.
C.    ------------------------------------------------------------------
C.
      IF (NUNITS.LT.5)THEN
         CALL FZFILE(LUN,LEN,LUNTYP)
         NUNITS = NUNITS + 1
         LUNITS(NUNITS) = LUN
         IF(INDEX(LUNTYP,'I').NE.0)LUNITS(NUNITS)=-LUN
         IER    = 0
      ELSE
         IER    = 1
      ENDIF
C
      END
+DECK,GREND
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GREND (LUN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to close an RZ file                              *
C.    *                                                                *
C.    *       CHDIR    Top directory name of the file                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*5 CHDIR
C.
C.    ------------------------------------------------------------------
C.
      IF(LUN.LT.10) THEN
         WRITE(CHDIR,'(''LUN'',I1)') LUN
      ELSE
         WRITE(CHDIR,'(''LUN'',I2)') LUN
      ENDIF
      CALL RZEND(CHDIR)
C
      END
+DECK,GRFILE
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GRFILE(LUN,CHFILE,CHOPTT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to open a GEANT/RZ data base.                    *
C.    *                                                                *
C.    *       LUN logical unit number associated to the file           *
C.    *                                                                *
C.    *       CHFILE RZ file name                                      *
C.    *                                                                *
C.    *       CHOPT is a character string which may be                 *
C.    *          'N' To create a new file                              *
C.    *          'U' to open an existing file for update               *
C.    *          ' ' to open an existing file for read only            *
C.    *          'Q' The initial allocation (default 1000 records)     *
C.    *              is given in IQUEST(10)                            *
C.    *          'X' Open the file in exchange format                  *
C.    *          'I' Read all data structures from file to memory      *
C.    *          'O' Write all data structures from memory to file     *
C.    *                                                                *
C.    *    Note:                                                       *
C.    *         If options 'I' or 'O' all data structures are read or  *
C.    *            written from/to file and the file is closed.        *
C.    *         See routine GRMDIR to create subdirectories            *
C.    *         See routines GROUT,GRIN to write,read objects          *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
      COMMON/QUEST/IQUEST(100)
      CHARACTER*(*) CHFILE,CHOPTT
      CHARACTER*8 CHOPT,CHTOP,CHTAGS(2)
      CHARACTER*10 CHOPT1,CHOPT2
      SAVE CHTAGS,CHTOP
      DATA CHTAGS,CHTOP/'Object','Version','        '/
C.
C.    ------------------------------------------------------------------
C.
*
      CHOPT=CHOPTT
      CALL CLTOU(CHOPT)
      IOPTN=INDEX(CHOPT,'N')
      IOPTU=INDEX(CHOPT,'U')
      IOPTQ=INDEX(CHOPT,'Q')
      IOPTI=INDEX(CHOPT,'I')
      IOPTO=INDEX(CHOPT,'O')
      IF(IOPTN.EQ.0.AND.IOPTU.EQ.0)IOPTO=0
      IF(IOPTN.NE.0)IOPTI=0
*
*          Open file
*
      CHOPT2 = CHOPT//'XW'
      CHOPT1 = CHOPT//'X'
      CALL RZOPEN(LUN,CHTOP,CHFILE,CHOPT2,1024,ISTAT)
      IF(ISTAT.NE.0)GO TO 99
*
      IF(IOPTN.NE.0)THEN
         IF(IOPTQ.NE.0)THEN
            NQUOT=IQUEST(10)
            IF(NQUOT.LT.100.OR.NQUOT.GT.100000)NQUOT=1000
         ELSE
            NQUOT=1000
         ENDIF
         CALL RZMAKE(LUN,CHTOP,2,'HI',CHTAGS,NQUOT,CHOPT1)
      ELSE
         CALL RZFILE(LUN,CHTOP,CHOPT1)
      ENDIF
*
*           Read/write initialisation structures
*
      IF(IOPTI.NE.0)THEN
         CALL GRIN('INIT',0,' ')
      ENDIF
      IF(IOPTO.NE.0)THEN
         CALL GROUT('INIT',1,' ')
      ENDIF
      IF(IOPTI.NE.0.OR.IOPTO.NE.0)THEN
         CALL RZEND(CHTOP)
         CLOSE(LUN)
      ENDIF
*
  99  CONTINUE
      END
+DECK,GRGET
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GRGET (KEYSU,ID1,ID2,ID3,ICYCLE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read  data structures from a RZ file          *
C.    *                                                                *
C.    *       KEYSU    Keyword to select data structure                *
C.    *       ID1      First  RZ KEY identifier (ex IDRUN)             *
C.    *       ID2      Second RZ KEY identifier (ex IDEVT)             *
C.    *       ID3      Third  RZ KEY identifier (user free)            *
C.    *       ICYCLE   Cycle number                                    *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUKINE                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCFLAG
+SEQ,GCNUM
+SEQ,GCDRAW
+SEQ,GCCUTS
C
      DIMENSION CUTVEC(10)
      EQUIVALENCE (CUTVEC,CUTGAM)
C
      CHARACTER*4 KLEY(19)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYRZ(4)
      DIMENSION LINIT(8),LKINE(2),LTRIG(6)
      DIMENSION LKEY(19),LINK(10),JLINK(17),KSEL(17),IXD(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      EQUIVALENCE (LKEY(18),KINIT),(LKEY(19),KTRIG),(LKEY(5),KKINE)
C
      SAVE IFIRST,LKEY
      DATA KLEY/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART','ROTM'
     +         ,'RUNG','SETS','STAK','STAT','TMED','TRAC','VERT','VOLU'
     +         ,'JXYZ','INIT','TRIG'/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2/
      DATA LINIT/2,6,7,8,9,10,13,16/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA NLINIT/8/
      DATA NLKINE/2/
      DATA NLTRIG/6/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,76)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GRGET *** Obsolete routine. Please use GRIN')
C
      CALL UCTOH(KEYSU,KEY,4,4)
      CALL VZERO(KSEL,17)
C
      IF(KEY.EQ.KINIT)THEN
         CALL UCOPY(LINIT,LINK,NLINIT)
         NLINK=NLINIT
      ELSEIF(KEY.EQ.KKINE)THEN
         CALL UCOPY(LKINE,LINK,NLKINE)
         NLINK=NLKINE
      ELSEIF(KEY.EQ.KTRIG)THEN
         CALL UCOPY(LTRIG,LINK,NLTRIG)
         NLINK=NLTRIG
      ELSE
         IL=IUCOMP(KEY,LKEY,17)
         IF(IL.EQ.0)GO TO 50
         LINK(1)=IL
         NLINK=1
      ENDIF
C
C               Read data structure(s)
C
      KEYRZ(2)=ID1
      KEYRZ(3)=ID2
      KEYRZ(4)=ID3
C
      DO 10 I=1,NLINK
         IL=LINK(I)
         IF(JLINK(IL).NE.0)THEN
            CALL MZDROP(IXCONS,JLINK(IL),' ')
            JLINK(IL)=0
         ENDIF
         KEYRZ(1)=LKEY(IL)
         IF(IXD(IL).NE.2)THEN
            IDIV=IXCONS
         ELSE
            IDIV=IXDIV
         ENDIF
         CALL RZIN(IDIV,JLINK(IL),1,KEYRZ,ICYCLE,' ')
         KSEL(IL)=1
   10 CONTINUE
C
C             Fill header bank
C             Reconstruct NKVIEW,NVOLUM,NVERTX,NTRACK
C             Reconstruct NMATE, NTMED, NPART
C
      IF(KSEL(6).NE.0.AND.JMATE.GT.0) NMATE=IQ(JMATE-2)
      IF(KSEL(7).NE.0.AND.JPART.GT.0) NPART=IQ(JPART-2)
      IF(KSEL(13).NE.0.AND.JTMED.NE.0 ) THEN
         DO 20 J=1,10
            CUTVEC(J) = Q(JTMED+J)
   20    CONTINUE
         NTMED=IQ(JTMED-2)
      ENDIF
      IF(KSEL(16).NE.0.AND.JVOLUM.GT.0) THEN
         NVOLUM=0
         DO 30 J=1, IQ(JVOLUM-2)
            IF(LQ(JVOLUM-J).EQ.0) GO TO 40
            NVOLUM=NVOLUM+1
   30    CONTINUE
   40    CONTINUE
      END IF
      IF(KSEL( 2).NE.0.AND.JDRAW.GT.0 ) NKVIEW=IQ(JDRAW-2)
C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
C
      IF(KSEL(5).GT.0)THEN
         NVERTX=0
         NTRACK=0
         IF(JVERTX.GT.0)NVERTX=IQ(JVERTX+1)
         IF(JKINE .GT.0)NTRACK=IQ(JKINE +1)
      ENDIF
C
   50 RETURN
      END
+DECK,GRIN
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GRIN(CHOBJT,IDVERS,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read GEANT object(s) fromin the RZ file       *
C.    *         at the Current Working Directory (See RZCDIR)          *
C.    *       The data structures from disk are read in memory         *
C.    *           (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)                 *
C.    *                                                                *
C.    *       CHOBJ  The type of object to be read:                    *
C.    *              MATE read JMATE structure                         *
C.    *              TMED read JTMED structure                         *
C.    *              VOLU read JVOLUM structure                        *
C.    *              ROTM read JROTM structure                         *
C.    *              SETS read JSET  structure                         *
C.    *              PART read JPART structure                         *
C.    *              SCAN read LSCAN structure                         *
C.    *              INIT read all initialisation structures           *
C.    *                                                                *
C.    *       IDVERS is a positive integer which specifies the version *
C.    *           number of the object(s).                             *
C.    *                                                                *
C.    *       CHOPT List of options (none for the time being)          *
C.    *                                                                *
C.    *                                                                *
C.    *    The RZ data base has been created via GRFILE/GROUT          *
C.    *                                                                *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GRFILE(1,'Geometry.dat',' ')                         *
C.    *      CALL GRIN ('VOLU',1,' ')                                  *
C.    *      CALL GRIN ('MATE',1,' ')                                  *
C.    *      CALL GRIN ('TMED',1,' ')                                  *
C.    *      CALL GRIN ('ROTM',1,' ')                                  *
C.    *      CALL GRIN ('PART',1,' ')                                  *
C.    *      CALL GRIN ('SCAN',1,' ')                                  *
C.    *      CALL GRIN ('SETS',1,' ')                                  *
C.    *                                                                *
C.    *      The same result can be achieved by:                       *
C.    *      CALL GRFILE(1,'Geometry.dat','I')                         *
C.    *                                                                *
C.    *    ==>Called by : <USER> ,GRFILE                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCFLAG.
+SEQ,GCONSP.
+SEQ,GCNUM.
+SEQ,GCCUTS.
+SEQ,GCSCAL.
+SEQ,GCDRAW.
+SEQ,GCVOLU.
+SEQ,GCUNIT
+SEQ,GCTIME
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),KEYS(2),LINIT(NLINIT),LKINE(NLKINE)
      DIMENSION LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),IVERSI(NMKEY),LDIV(2),IRESUL(NMKEY)
      DIMENSION IDOLD(8), IDNEW(8), VEROLD(8), VERNEW(8)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 CHOBJ,CKEY,KNAMES(NMKEY)
      CHARACTER*(*) CHOPT,CHOBJT
      DATA KNAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +     'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +     'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA IDNEW / 8*0 /
      DATA VERNEW / 8*0. /
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
      KVOL=JVOLUM
      CHOBJ=CHOBJT
*
*     Save old JRUNG dates and versions
      IF(JRUNG.GT.0) THEN
         DO 10 J=1,8
            IDOLD(J) = IQ(JRUNG+10+J)
            VEROLD(J) = Q(JRUNG+20+J)
   10    CONTINUE
      ENDIF
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
      IF(CHOBJ.EQ.'INIT') THEN
         CHOBJ='*'
         IOPTI=1
         IOPTT=0
         IOPTK=0
         IF(JDRAW.NE.0)CALL MZDROP(IXSTOR,JDRAW,'L')
         IF(JSTAK.NE.0)CALL MZDROP(IXSTOR,JSTAK,'L')
         IF(JGPAR.NE.0)CALL MZDROP(IXSTOR,JGPAR,'L')
      ELSEIF(CHOBJ.EQ.'TRIG') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=1
         IOPTK=0
      ELSEIF(CHOBJ.EQ.'KINE') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=0
         IOPTK=1
      ENDIF
*
      IF(CHOBJ.EQ.'*') THEN
         IF(IOPTI.NE.0) THEN
            DO 20 J=1, NLINIT
               LINK(J)=LINIT(J)
   20       CONTINUE
            NLINK=NLINIT
         ELSEIF(IOPTT.NE.0) THEN
            DO 30 J=1, NLTRIG
               LINK(J)=LTRIG(J)
   30       CONTINUE
            NLINK=NLTRIG
         ELSEIF(IOPTK.NE.0) THEN
            DO 40 J=1, NLKINE
               LINK(J)=LKINE(J)
   40       CONTINUE
            NLINK=NLKINE
         ENDIF
      ELSE
         NLINK=0
         DO 100 J=1, NMKEY
            IF(CHOBJ.EQ.KNAMES(J)) THEN
               IF(IOPTI.NE.0) THEN
                  DO 50 L=1, NLINIT
                     IF(LINIT(L).EQ.J) GOTO 80
   50             CONTINUE
                  GOTO 90
               ELSEIF(IOPTT.NE.0) THEN
                  DO 60 L=1, NLTRIG
                     IF(LTRIG(L).EQ.J) GOTO 80
   60             CONTINUE
                  GOTO 90
               ELSEIF(IOPTK.NE.0) THEN
                  DO 70 L=1, NLKINE
                     IF(LKINE(L).EQ.J) GOTO 80
   70             CONTINUE
                  GOTO 90
               ENDIF
   80          NLINK=1
               LINK(1)=J
               GOTO 110
*
   90          WRITE(CHMAIL,10000) CHOBJ, CHOPT
               CALL GMAIL(0,0)
               GOTO 999
*
            ENDIF
  100    CONTINUE
      ENDIF
*
  110 IF(NLINK.EQ.0) THEN
         WRITE(CHMAIL,10100) CHOBJ
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
      DO 120 J=1, NLINK
         IVERSI(J)=0
         IRESUL(J)=0
  120 CONTINUE
*
      IKEY=0
  130 CONTINUE
      IKEY=IKEY+1
      CALL RZINK(IKEY,9999,'S')
      IF(IQUEST(1).NE.0) THEN
         IQUEST(1)=0
         GOTO 150
      ENDIF
      CALL UHTOC(IQUEST(21),4,CKEY,4)
      DO 140 I=1,NLINK
         NKEY=ABS(LINK(I))
         IF(CKEY.EQ.KNAMES(NKEY))THEN
            IF(IDVERS.NE.0.AND.IDVERS.NE.IQUEST(22)) THEN
               LINK(I)=-ABS(LINK(I))
               GOTO 130
            ENDIF
            KEYS(1)=IQUEST(21)
            KEYS(2)=IQUEST(22)
            IDIV=LDIV(IXD(NKEY))
            IF(NKEY.LE.20)THEN
               IF(JNAMES(NKEY).NE.0)THEN
                  CALL MZDROP(IDIV,JNAMES(NKEY),'L')
                  JNAMES(NKEY)=0
               ENDIF
               CALL RZIN(IDIV,JNAMES(NKEY),1,KEYS,9999,' ')
            ELSE
               NKL=NKEY-20
               IF(ISLINK(NKL).NE.0)THEN
                  CALL MZDROP(IDIV,ISLINK(NKL),'L')
                  ISLINK(NKL)=0
               ENDIF
               CALL RZIN(IDIV,ISLINK(NKL),1,KEYS,9999,' ')
            ENDIF
            IF(IQUEST(1).EQ.0) THEN
               IVERSI(I)=IQUEST(22)
               IRESUL(I)=1
            ENDIF
         ENDIF
  140 CONTINUE
      GOTO 130
*
  150 NIN=0
      DO 160 I=1,NLINK
         IF(IRESUL(I).EQ.1) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10200) KNAMES(LINK(I)), IVERSI(I)
            CALL GMAIL(0,0)
            ENDIF
            NIN=NIN+1
         ELSEIF(LINK(I).GT.0) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10300) KNAMES(LINK(I))
            CALL GMAIL(0,0)
            ENDIF
         ELSEIF(LINK(I).LT.0) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10400) KNAMES(-LINK(I)), IDVERS
            CALL GMAIL(0,0)
            ENDIF
         ENDIF
  160 CONTINUE
*
      IF(NIN.EQ.0) THEN
         WRITE(CHMAIL,10500)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
      IF(KVOL.NE.JVOLUM)THEN
         NVOLUM=IQ(JVOLUM-1)
         CALL MZGARB(IXCONS,0)
         CALL GGDVLP
         CALL GGNLEV
      ENDIF
*
      IF(JVOLUM.GT.0) THEN
         NLEVEL=0
         NVOLUM=0
         DO 170 J=1, IQ(JVOLUM-2)
            IF(LQ(JVOLUM-J).EQ.0) GOTO 180
            NVOLUM=NVOLUM+1
  170    CONTINUE
  180    CONTINUE
      ENDIF
*
      IF(JTMED.NE.0 )THEN
         CALL UCOPY(Q(JTMED+1),CUTGAM,10)
         NTMED=IQ(JTMED-2)
      ENDIF
*
      IF(JPART.NE.0 ) NPART  = IQ(JPART-2)
      IF(JVERTX.NE.0) NVERTX = IQ(JVERTX-2)
      IF(JMATE.NE.0 ) NMATE  = IQ(JMATE-2)
      IF(JROTM.NE.0 ) NROTM  = IQ(JROTM-2)
      IF(JDRAW.GT.0 ) THEN
         NKVIEW = IQ(JDRAW-2)
      ELSE
         NKVIEW = 0
C
C             Book JDRAW structure for view banks
C
         CALL MZBOOK(IXCONS,JDRAW,JDRAW,1,'DRAW',0,0,0,3,0)
      ENDIF
 
C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
      IF(JRUNG.GT.0) THEN
*
*             Here we deal with version numbers If JRUNG has been read in,
*             then save the version numbers of the new JRUNG and restore
*             the current version number for KINE, HITS and DIGI
         DO 210 J=1, NLINK
            IF(IRESUL(J).EQ.1) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'RUNG') THEN
                  DO 190 I=1,8
                     IDNEW(I) = IQ(JRUNG+10+I)
                     VERNEW(I) = Q(JRUNG+20+I)
  190             CONTINUE
*
*             And we put back the old version numbers because,
*             in principle, KINE, HITS and DIGI have not be read in
                  DO 200 I=3,8
                     IQ(JRUNG+10+I) = IDOLD(I)
                     Q(JRUNG+20+I) = VEROLD(I)
  200             CONTINUE
               ENDIF
            ENDIF
  210    CONTINUE
*
*            And here we do it again for KINE, HITS and DIGI
         DO 220 J=1, NLINK
            IF(IRESUL(J).EQ.1) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'KINE') THEN
                  IF(IDNEW(3).GT.0) THEN
                     IQ(JRUNG+13) = IDNEW(3)
                     IQ(JRUNG+14) = IDNEW(4)
                     Q(JRUNG+23) = VERNEW(3)
                     Q(JRUNG+24) = VERNEW(4)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'HITS') THEN
                  IF(IDNEW(5).GT.0) THEN
                     IQ(JRUNG+15) = IDNEW(5)
                     IQ(JRUNG+16) = IDNEW(6)
                     Q(JRUNG+25) = VERNEW(5)
                     Q(JRUNG+26) = VERNEW(6)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'DIGI') THEN
                  IF(IDNEW(7).GT.0) THEN
                     IQ(JRUNG+17) = IDNEW(7)
                     IQ(JRUNG+18) = IDNEW(8)
                     Q(JRUNG+27) = VERNEW(7)
                     Q(JRUNG+28) = VERNEW(8)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'MATE'.OR.
     +                KNAMES(NKEY).EQ.'TMED') THEN
                  IF(VERNEW(1).NE.0) THEN
*                We know which version number we are reading
                     IF(VERNEW(1).LT.GVERSN) THEN
                        WRITE(CHMAIL,10600)
     +                        KNAMES(NKEY),VERNEW(1),GVERSN
                        CALL GMAIL(0,0)
                        WRITE(CHMAIL,10700)
                        CALL GMAIL(0,0)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
  220    CONTINUE
      ENDIF
*
10000 FORMAT(' *** GRIN *** Data structure ',A4,' not read in ',
     +       'phase ',A)
10100 FORMAT(' *** GRIN *** Unknown key ',A4)
10200 FORMAT(' *** GRIN *** Data structure ',A4,' version ',I10,
     +       ' successfully read in ')
10300 FORMAT(' *** GRIN *** Data structure ',A4,' was not found')
10400 FORMAT(' *** GRIN *** Data structure ',A4,' version ',I10,
     +       ' was not found')
10500 FORMAT(' *** GRIN *** Nothing found to read !')
10600 FORMAT(' *** GRIN *** ',A4,' data structure ',
     +       'version ',F6.4,' current version is ',F6.4)
10700 FORMAT('              Please call subroutine GPHYSI before ',
     +       'tracking')
  999 CONTINUE
      END
+DECK,GRLEAS
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GRLEAS(JBANK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Release unused space in data structure pointed by JBANK. *
C.    *       JBANK can be either JHITS or JDIGI                       *
C.    *                                                                *
C.    *    ==>Called by : GSAVE                                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
C.
C.    ------------------------------------------------------------------
C.
      IF(JBANK.LE.0)GO TO 99
      NS=IQ(JBANK-2)
      IF(NS.LE.0)GO TO 99
      DO 20 IS=1,NS
         JB=LQ(JBANK-IS)
         IF(JB.GT.0)THEN
            ND=IQ(JB-1)
            IF(ND.GT.0)THEN
               DO 10 ID=1,ND
                  JBD=LQ(JB-ID)
                  IF(JBD.GT.0)THEN
                     NPUSH=IQ(JBD-1)-IQ(JB+ID)
                     IF(NPUSH.GT.0)CALL MZPUSH(IXDIV,JBD,0,-NPUSH,'I')
                  ENDIF
  10           CONTINUE
            ENDIF
         ENDIF
  20  CONTINUE
C
  99  RETURN
      END
+DECK,GRMDIR
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GRMDIR(CHDIR,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to create a "standard" GEANT subdirectory        *
C.    *                                                                *
C.    *       CHDIR Subdirectory name                                  *
C.    *                                                                *
C.    *       CHOPT is a character string which may be                 *
C.    *          ' ' To create a subdirectory                          *
C.    *          'S' To create a subdirectory and set the new          *
C.    *              Current Directory to this directory.              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*(*) CHDIR,CHOPT
      CHARACTER*8 CHTAGS(2)
      DATA CHTAGS/'Object','Version'/
C.
C.    ------------------------------------------------------------------
C.
      CALL UOPTC(CHOPT,'S',IOPTS)
*
      CALL RZMDIR(CHDIR,2,'HI',CHTAGS)
      IF(IOPTS.NE.0)THEN
         CALL RZCDIR(CHDIR,' ')
      ENDIF
*
      END
+DECK,GROUT
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GROUT(CHOBJT,IDVERS,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write GEANT object(s) in the RZ file          *
C.    *         at the Current Working Directory (See RZCDIR)          *
C.    *       Input is taken from the data structures in memory        *
C.    *           (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)                 *
C.    *                                                                *
C.    *       CHOBJ  The type of object to be written:                 *
C.    *              MATE write JMATE structure                        *
C.    *              TMED write JTMED structure                        *
C.    *              VOLU write JVOLUM structure                       *
C.    *              ROTM write JROTM structure                        *
C.    *              SETS write JSET  structure                        *
C.    *              PART write JPART structure                        *
C.    *              SCAN write LSCAN structure                       *
C.    *              INIT write all initialisation structures          *
C.    *                                                                *
C.    *       IDVERS is a positive integer which specifies the version *
C.    *           number of the object(s).                             *
C.    *                                                                *
C.    *       CHOPT List of options (none for the time being)          *
C.    *                                                                *
C.    *    Note that if the cross-sections and energy loss tables      *
C.    *       are available in the data structure JMATE, then they are *
C.    *       saved on the data base.                                  *
C.    *                                                                *
C.    *                                                                *
C.    *    The data structures saved by this routine can be retrieved  *
C.    *    with the routine GRIN.                                      *
C.    *                                                                *
C.    *    Before calling this routine a RZ data base must have been   *
C.    *    created using GRFILE.                                       *
C.    *    The data base must be closed with RZEND.                    *
C.    *                                                                *
C.    *    The RZ data base can be transported between different       *
C.    *    machines in using the ZEBRA RZ utility RZTOFZ.              *
C.    *                                                                *
C.    *    The interactive version of GEANT provides facilities        *
C.    *    to interactively update, create and display objects.        *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GRFILE(1,'Geometry.dat','N')                         *
C.    *      CALL GROUT('VOLU',1,' ')                                  *
C.    *      CALL GROUT('MATE',1,' ')                                  *
C.    *      CALL GROUT('TMED',1,' ')                                  *
C.    *      CALL GROUT('ROTM',1,' ')                                  *
C.    *      CALL GROUT('PART',1,' ')                                  *
C.    *      CALL GROUT('SCAN',1,' ')                                  *
C.    *      CALL GROUT('SETS',1,' ')                                  *
C.    *                                                                *
C.    *      The same result can be achieved by:                       *
C.    *      CALL GRFILE(1,'Geometry.dat','NO')                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>,GRFILE                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK,GCFLAG,GCNUM,GCCUTS,GCSCAL,GCDRAW,GCUNIT
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),KEYS(2)
      DIMENSION LINIT(NLINIT),LKINE(NLKINE),LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),LDIV(2)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 CHOBJ,NAMES(NMKEY)
      CHARACTER*(*) CHOPT,CHOBJT
      DATA NAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +    'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +    'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
      CHOBJ=CHOBJT
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
      IF(CHOBJ.EQ.'INIT') THEN
         CHOBJ='*'
         IOPTI=1
         IOPTT=0
         IOPTK=0
      ELSEIF(CHOBJ.EQ.'TRIG') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=1
         IOPTK=0
      ELSEIF(CHOBJ.EQ.'KINE') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=0
         IOPTK=1
      ENDIF
*
      IF(CHOBJ.EQ.'*') THEN
         IF(IOPTI.NE.0) THEN
            DO 10 J=1, NLINIT
               LINK(J)=LINIT(J)
   10       CONTINUE
            NLINK=NLINIT
         ELSEIF(IOPTT.NE.0) THEN
            DO 20 J=1, NLTRIG
               LINK(J)=LTRIG(J)
   20       CONTINUE
            NLINK=NLTRIG
         ELSEIF(IOPTK.NE.0) THEN
            DO 30 J=1, NLKINE
               LINK(J)=LKINE(J)
   30       CONTINUE
            NLINK=NLKINE
         ENDIF
      ELSE
         NLINK=0
         DO 90 J=1, NMKEY
            IF(CHOBJ.EQ.NAMES(J)) THEN
               IF(IOPTI.NE.0) THEN
                  DO 40 L=1, NLINIT
                     IF(LINIT(L).EQ.J) GOTO 70
   40             CONTINUE
                  GOTO 80
               ELSEIF(IOPTT.NE.0) THEN
                  DO 50 L=1, NLTRIG
                     IF(LTRIG(L).EQ.J) GOTO 70
   50             CONTINUE
                  GOTO 80
               ELSEIF(IOPTK.NE.0) THEN
                  DO 60 L=1, NLKINE
                     IF(LKINE(L).EQ.J) GOTO 70
   60             CONTINUE
                  GOTO 80
               ENDIF
   70          NLINK=1
               LINK(1)=J
               GOTO 100
*
   80          WRITE(CHMAIL,10000) CHOBJ, CHOPT
               CALL GMAIL(0,0)
               GOTO 999
*
            ENDIF
   90    CONTINUE
      ENDIF
*
  100 IF(NLINK.EQ.0) THEN
         WRITE(CHMAIL,10100) CHOBJ
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
      NOUT=0
      DO 110 I=1,NLINK
         NKEY=LINK(I)
         CALL UCTOH(NAMES(NKEY),KEYS,4,4)
         KEYS(2)=IDVERS
         IDIV=LDIV(IXD(NKEY))
         IF(NKEY.LE.20)THEN
            IF(JNAMES(NKEY).GT.0)    THEN
               CALL RZOUT(IDIV,JNAMES(NKEY),KEYS,ICYCLE,' ')
               LINK(I)=-LINK(I)
            ENDIF
         ELSE
            IF(ISLINK(NKEY-20).GT.0)    THEN
               CALL RZOUT(IDIV,ISLINK(NKEY-20),KEYS,ICYCLE,' ')
               LINK(I)=-LINK(I)
            ENDIF
         ENDIF
         IF(LINK(I).GT.0) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10200) NAMES(LINK(I))
            CALL GMAIL(0,0)
            ENDIF
            GOTO 110
         ELSEIF(LINK(I).LT.0) THEN
            IF(IQUEST(1).EQ.0) THEN
            IF(IOPTQ.EQ.0) THEN
               WRITE(CHMAIL,10300) NAMES(-LINK(I)), IDVERS
               CALL GMAIL(0,0)
            ENDIF
               NOUT=NOUT+1
            ELSE
               WRITE(CHMAIL,10400) NAMES(-LINK(I))
               CALL GMAIL(0,0)
            ENDIF
         ENDIF
  110 CONTINUE
*
      IF(NOUT.EQ.0) THEN
         WRITE(CHMAIL,10500)
         CALL GMAIL(0,0)
      ENDIF
*
10000 FORMAT(' *** GROUT *** Data structure ',A4,' not written ',
     +       'in phase ',A)
10100 FORMAT(' *** GROUT *** Unknown key ',A4)
10200 FORMAT(' *** GROUT *** Data structure ',A4,' was not found')
10300 FORMAT(' *** GROUT *** Data structure ',A4,' version ',I10,
     +       ' saved to disk')
10400 FORMAT(' *** GROUT *** Error in writing data structure ',
     +        A4,' to disk')
10500 FORMAT(' *** GROUT *** Nothing written to disk !')
  999 CONTINUE
      END
+DECK,GRSAVE
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GRSAVE(KEYSU,ID1,ID2,ID3,ICYCLE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write out data structures on a RZ file        *
C.    *                                                                *
C.    *       KEYSU    Keyword to select data structure(s)             *
C.    *       ID1      First  RZ KEY identifier (ex IDRUN)             *
C.    *       ID2      Second RZ KEY identifier (ex IDEVT)             *
C.    *       ID3      Third  RZ KEY identifier (user free)            *
C.    *       ICYCLE   Cycle number (output)                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUOUT                         *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      CHARACTER*4 KLEY(19)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYRZ(4)
      DIMENSION LINIT(8),LKINE(2),LTRIG(6)
      DIMENSION LKEY(19),LINK(10),JLINK(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      EQUIVALENCE (LKEY(18),KINIT),(LKEY(19),KTRIG),(LKEY(5),KKINE)
      SAVE IFIRST,LKEY
C
      DATA KLEY/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART','ROTM'
     +         ,'RUNG','SETS','STAK','STAT','TMED','TRAC','VERT','VOLU'
     +         ,'JXYZ','INIT','TRIG'/
      DATA LINIT/2,6,7,8,9,10,13,16/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA NLINIT/8/
      DATA NLKINE/2/
      DATA NLTRIG/6/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,76)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GRSAVE *** Obsolete routine. Please use GROUT')
C
      CALL UCTOH(KEYSU,KEY,4,4)
C
      IF(KEY.EQ.KINIT)THEN
         CALL UCOPY(LINIT,LINK,NLINIT)
         NLINK=NLINIT
      ELSEIF(KEY.EQ.KKINE)THEN
         CALL UCOPY(LKINE,LINK,NLKINE)
         NLINK=NLKINE
      ELSEIF(KEY.EQ.KTRIG)THEN
         CALL UCOPY(LTRIG,LINK,NLTRIG)
         NLINK=NLTRIG
      ELSE
         IL=IUCOMP(KEY,LKEY,17)
         IF(IL.EQ.0)GO TO 99
         LINK(1)=IL
         NLINK=1
      ENDIF
C
C               Write data structure(s)
C
      KEYRZ(2)=ID1
      KEYRZ(3)=ID2
      KEYRZ(4)=ID3
C
      DO 10 I=1,NLINK
         IL=LINK(I)
         IF(JLINK(IL).EQ.0)GO TO 10
         KEYRZ(1)=LKEY(IL)
         IF(IL.EQ.4)CALL GRLEAS(JHITS)
         IF(IL.EQ.1)CALL GRLEAS(JDIGI)
         CALL RZOUT(IXSTOR,JLINK(IL),KEYRZ,ICYCLE,'L')
  10  CONTINUE
C
  99  RETURN
      END
+DECK,GSAVE
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GSAVE(LUN,KEYSU,NUKEYS,IDENT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write out data structures                     *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       KEYSU    Keywords to select data structures              *
C.    *       NKEYS    Number of keywords                              *
C.    *       IER      Error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUOUT                         *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
      CHARACTER*4 KLEY(22)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYS(22),IUHEAD(2)
      DIMENSION KSEL(14),LKEY(22),LKNUM(22),LINK(14),JLINK(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      COMMON/QUEST/IQUEST(100)
      SAVE IFIRST,LKEY
C
      DATA LINK/7,6,13,16,8,10,2,9,3,15,5,17,4,1/
      DATA KLEY/'PART','MATE','TMED','VOLU','ROTM','SETS','DRAW','RUNG'
     +         ,'INIT','INIT','INIT','INIT','INIT','INIT','INIT','INIT'
     +         ,'HEAD','KINE','KINE','JXYZ','HITS','DIGI'/
      DATA LKNUM/1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,10,11,12,13,14/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,88)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GSAVE *** Obsolete routine. Please use GFOUT')
C
      IER    = 0
      NKEYS=IABS(NUKEYS)
      IF (NKEYS.LE.0)                                 GO TO 99
      CALL UCTOH(KEYSU,KEYS,4,4*NKEYS)
C
      IF(NUKEYS.LT.0)THEN
        I1=1
        I2=15
        K1=1
        K2=7
      ELSE
        I1=18
        I2=22
        K1=10
        K2=14
      ENDIF
C
      DO 10 K=K1,K2
  10  KSEL(K)=0
      NK=0
      DO 25 I=I1,I2
         N=LKNUM(I)
         DO 20 IK=1,NKEYS
            IF(KEYS(IK).EQ.LKEY(I))THEN
               IL=LINK(N)
               IF(JLINK(IL).NE.0)THEN
                  KSEL(N)=1
                  NK=NK+1
               ENDIF
            ENDIF
  20     CONTINUE
  25  CONTINUE
C
      IUHEAD(1)=IDENT
      IUHEAD(2)=NK
      IF(NUKEYS.LT.0)THEN
C
C======>      Write RUN header and constants
C
         CALL FZOUT(LUN,IXCONS,JRUNG,1,'L',2,2,IUHEAD)
         IF(IQUEST(1).NE.0)GO TO 90
         DO 30 I=1,7
            IF(KSEL(I).NE.0)THEN
               IL=LINK(I)
               CALL FZOUT(LUN,IXCONS,JLINK(IL),0,'L',2,1,I)
               IF(IQUEST(1).NE.0)GO TO 90
            ENDIF
  30     CONTINUE
C
      ELSE
C
C======>      Write event header and data structures
C             Released unused space in JHITS and JDIGI
C
         IF(KSEL(13).NE.0)CALL GRLEAS(JHITS)
         IF(KSEL(14).NE.0)CALL GRLEAS(JDIGI)
C
         CALL FZOUT(LUN,IXDIV,JHEAD,1,' ',2,2,IUHEAD)
         IF(IQUEST(1).NE.0)GO TO 90
         DO 40 I=10,14
            IF(KSEL(I).NE.0)THEN
               IL=LINK(I)
               CALL FZOUT(LUN,IXDIV ,JLINK(IL),0,'L',2,1,I)
               IF(IQUEST(1).NE.0)GO TO 90
            ENDIF
  40     CONTINUE
C
      ENDIF
      GO TO 99
C
C             Error
C
  90  IER=IQUEST(1)
C
  99  RETURN
      END
+PATCH,GKINE
+DECK,DOCGKINE,IF=DOC
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
*
************************************************************************
*            -----------------------------------------------           *
*            The Kinematics data structures JVERTX and JKINE           *
*            -----------------------------------------------           *
*                                                                      *
*                                          | JVERTX                    *
*     NVERTX          IVERT                v                           *
*      ...............................................                 *
*      |              | |                 | | NVERTX |                 *
*      ...............................................                 *
*                      |                                               *
*                      | JV                                            *
*                      v                                               *
*           ..........................                                 *
*           | 1 |   VX               |                                 *
*           |...|....................|                                 *
*           | 2 |   VY               |                                 *
*           |...|....................|                                 *
*           | 3 |   VZ               |                                 *
*           |...|....................|                                 *
*           | 4 |   TOF              |                                 *
*           |...|....................|                                 *
*           | 5 |   NTBEAM           |                                 *
*           |...|....................|                                 *
*           | 6 |   NTTARG           |                                 *
*           |...|....................|                                 *
*           | 7 |   no. of tracks    |                                 *
*           |...|....................|                                 *
*           | 8 |   List of tracks   |                                 *
*           |...|....................|                                 *
*           | 9 |                    |                                 *
*           ..........................                                 *
*                                                                      *
*  JV        = LQ(JVERTX-IVERT) pointer to parameters of vertex        *
*            number IVERT                                              *
*  Q(JV+1)   x coordinate of this vertex.                              *
*                                                                      *
*  The JVERTX  banks are filled  by the routine GSVERT.   The Vertex   *
* parameters are retrieved by the routine GFVERT.                      *
*                                                                      *
*                                                                      *
*                                          | JKINE                     *
*     NTRACK          ITRA                 v                           *
*      ...............................................                 *
*      |              | |                 | | NTRACK |                 *
*      ...............................................                 *
*                      |                                               *
*                      | JK                                            *
*                      v                                               *
*           ..........................                                 *
*           | 1 |   PX               |                                 *
*           |...|....................|                                 *
*           | 2 |   PY               |                                 *
*           |...|....................|                                 *
*           | 3 |   PZ               |                                 *
*           |...|....................|                                 *
*           | 4 |   Energy           |                                 *
*           |...|....................|                                 *
*           | 5 |   IPART            |                                 *
*           |...|....................|                                 *
*           | 6 |   Vertex origin    |                                 *
*           |...|....................|                                 *
*           | 7 |   no. of vertices  |                                 *
*           |...|....................|                                 *
*           | 8 |   List of vertices |                                 *
*           |...|....................|                                 *
*           | 9 |                    |                                 *
*           ..........................                                 *
*                                                                      *
*  JK        = LQ(JKINE-ITRA)   pointer to parameters  of track        *
*            number ITRA                                               *
*  Q(JK+1)   x component of the momentum for this track.               *
*                                                                      *
*  The  JKINE  banks  are  filled  by  the  routine  GSKINE.   Track   *
* parameters are obtained by GFKINE.                                   *
*                                                                      *
************************************************************************
+DECK,GFKINE
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFKINE(ITRA,VERT,PVERT,IPART,NVERT,UBUF,NWBUF)
*
************************************************************************
*                                                                      *
*           Storing/Retrieving Vertex and Track parameters             *
*           ----------------------------------------------             *
*                                                                      *
*  Stores vertex parameters.                                           *
*  VERT      array of (x,y,z) position of the vertex                   *
*  NTBEAM    beam track number origin of the vertex                    *
*            =0 if none exists                                         *
*  NTTARG    target track number origin of the vertex                  *
*  UBUF      user array of NUBUF floating point numbers                *
*  NUBUF                                                               *
*  NVTX      new vertex number (=0 in case of error).                  *
*  Prints vertex parameters.                                           *
*  IVTX      for vertex IVTX.                                          *
*            (For all vertices if IVTX=0)                              *
*  Stores long life track parameters.                                  *
*  PLAB      components of momentum                                    *
*  IPART     type of particle (see GSPART)                             *
*  NV        vertex number origin of track                             *
*  UBUF      array of NUBUF floating point user parameters             *
*  NUBUF                                                               *
*  NT        track number (if=0 error).                                *
*  Retrieves long life track parameters.                               *
*  ITRA      track number for which parameters are requested           *
*  VERT      vector origin of the track                                *
*  PVERT     4 momentum components at the track origin                 *
*  IPART     particle type (=0 if track ITRA does not exist)           *
*  NVERT     vertex number origin of the track                         *
*  UBUF      user words stored in GSKINE.                              *
*  Prints initial track parameters.                                    *
*  ITRA      for track ITRA                                            *
*            (For all tracks if ITRA=0)                                *
*                                                                      *
*    ==>Called by : <USER>, GTREVE                                     *
*       Author    R.Brun  *********                                    *
*                                                                      *
************************************************************************
*
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCTRAK
      DIMENSION VERT(3),PVERT(4),UBUF(*)
C.
C.    ------------------------------------------------------------------
C.
      IPART  = 0
      IF (JKINE.LE.0)GO TO 99
      IF (ITRA.LE.0)GO TO 99
      IF (ITRA.GT.NTRACK)GO TO 99
C
      JK = LQ(JKINE- ITRA)
      IF (JK.LE.0)GO TO 99
      NV = Q(JK + 6)
      IF (JVERTX.LE.0)GO TO 99
      JV = LQ(JVERTX- NV)
      IF (JV.LE.0)GO TO 99
      DO 10 I=1,3
  10  VERT(I) = Q(JV + I)
*     TOFG=Q(JV+4)
C
      DO 20 I=1,4
  20  PVERT(I) = Q(JK + I)
      IPART = Q(JK + 5)
      NVERT = Q(JK + 6)
      NLINK = IQ(JK-2)
      NWBUF  = 0
      IF (NLINK.LE.0)GO TO 99
      JKU = LQ(JK- 1)
      IF (JKU.LE.0)GO TO 99
      NWBUF = IQ(JKU-1)
      DO 30 I=1,NWBUF
  30  UBUF(I)=Q(JKU+I)
C
  99  RETURN
      END
+DECK,GFVERT.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFVERT(NVTX,V,NTBEAM,NTTARG,TOFG,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Retrieves the parameter of a vertex bank                 *
C     *       Vertex is generated from tracks NTBEAM NTTARG            *
C     *       NVTX is the new vertex number                            *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    F.Carminati                   *********       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      DIMENSION V(3),UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      IF (JVERTX.EQ.0.OR.NVERTX.LE.0)THEN
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      IF(NVTX.GT.NVERTX) THEN
         WRITE(CHMAIL,10100)NVERTX
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      JV=LQ(JVERTX-NVTX)
      IF(JV.LE.0) THEN
         WRITE(CHMAIL,10100)NVERTX
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      DO 10 I=1,3
         V(I) = Q(JV + I)
   10 CONTINUE
      TOFG = Q(JV + 4)
      NTBEAM = Q(JV + 5)
      NTTARG = Q(JV + 6)
*
      NWBUF=0
      IF(IQ(JV-2).GE.1) THEN
         JUV=LQ(JV-1)
         IF(JUV.GT.0) THEN
            NWBUF=IQ(JUV-1)
            DO 20 IBUF=1,NWBUF
               UBUF(IBUF)=Q(JUV+IBUF)
   20       CONTINUE
         ENDIF
      ENDIF
*
10000 FORMAT(' **** GFVERT: No vertex stored in memory')
10100 FORMAT(' **** GFVERT: Vertex ',I10,' does not exist')
  999 CONTINUE
      END
+DECK,GLUDKY
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GLUDKY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        GEANT INTERFACE TO THE LUND MONTE-CARLO                 *
C.    *        FOR TAU DECAY GENERATION ONLY                           *
C.    *                                                                *
C.    *  THIS INTERFACE TO LUND                                        *
C.    *  A) INHIBITS DECAYS OF K0S,SIG+,SIG-,XI0,XI-,LAM,OM-           *
C.    *  B) ACCEPTS STABLE PARTICLES ONLY                              *
C.    *  C) CONVERTS THE PARTICLE CODES TO GEANT CONVENTIONS           *
C.    *                                                                *
C.    *  THUS THE PARTICLES FORWARDED TO GEANT ARE                     *
C.    *  GAMMA,ELECTRON,NEUTRINO(E,MU,TAU),MU-,PI+,K+,K0S,K0L,         *
C.    *  PROTON,NEUTRON,SIG(+,-),XI(0,-),LAM,OM-                       *
C.    *  ....  AND THEIR ANTIPARTICLES                                 *
C.    *                                                                *
C.    *       That routine can be called from the user routine GUDCAY  *
C.    *                                                                *
C.    *       Author    R.Hemingway  26 SEPT 1985                      *
C.    *                                                                *
C.    ******************************************************************
C.
C
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,LUJETS
+SEQ,LUDAT3
      PARAMETER (NSEL=44)
      DIMENSION IPLUND(NSEL)
      DATA IPLUND/
     +    22,   -11,    11,    12,   -13,    13,   111,   211,
     +  -211,   130,   321,  -321,  2112,  2212, -2212,   310,
     +   221,  3122,  3222,  3212,  3112,  3322,  3312,  3334,
     + -2112, -3122, -3112, -3212, -3222, -3322, -3312, -3334,
     +   -15,    15,   411,  -411,   421,  -421,   431,  -431,
     +  4122,    24,   -24,    23/
*.
*.    ------------------------------------------------------------------
*.
      IF (IFINIT(6).EQ.0)THEN
*
*--  Set some particles to be stable in LUND so that GEANT can handle
*--  their tracking and decays. (K0s, sigma+-, xi0-, lambda0, omega-)
*
         MDCY(LUCOMP(310) ,1)=0
         MDCY(LUCOMP(3222),1)=0
         MDCY(LUCOMP(3112),1)=0
         MDCY(LUCOMP(3322),1)=0
         MDCY(LUCOMP(3312),1)=0
         MDCY(LUCOMP(3122),1)=0
         MDCY(LUCOMP(3334),1)=0
         IFINIT(6) = 1
      ENDIF
C
      IF(IPART.EQ.33.OR.IPART.EQ.34) THEN
         N=0
         EDKY=GETOT
         THDKY=ACOS(VECT(6))
         PHDKY=ATAN2(VECT(5),VECT(4))
*
*            for TAU+ TAU-
*            could be extended to all charm particles
*
         CALL LU1ENT(1,IPLUND(IPART),EDKY,THDKY,PHDKY)
         CALL LUEXEC
         NGKINE=0
         DO 20 I = 1,N
            IF(K(I,1).GE.1.AND.K(I,1).LE.10) THEN
               DO 10 IGE=1, NSEL
                  IF(IPLUND(IGE).EQ.K(I,2)) THEN
                     NGKINE=NGKINE+1
                     GKIN(1,NGKINE)=P(I,1)
                     GKIN(2,NGKINE)=P(I,2)
                     GKIN(3,NGKINE)=P(I,3)
                     GKIN(4,NGKINE)=P(I,4)
                     GKIN(5,NGKINE)=IGE
                     GPOS(1,NGKINE)=V(I,1)
                     GPOS(2,NGKINE)=V(I,2)
                     GPOS(3,NGKINE)=V(I,3)
                     TOFD(NGKINE)  =V(I,4)*10.*CLIGHT
                  ENDIF
   10          CONTINUE
            ENDIF
   20    CONTINUE
      ENDIF
*
      END
+DECK,GLUND
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GLUND
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        GEANT INTERFACE TO THE LUND MONTE-CARLO                 *
C.    *                                                                *
C.    *  FOR TECHNICAL DETAILS OF THE LUND MONTE CARLO,SEE             *
C.    *  1. THE LUND MONTE CARLO FOR JET FRAGMENTATION - T.SJOSTRAND   *
C.    *     LU TP 82-3  and COMPUTER PHYSICS COMMUNICATION 27(1982)243 *
C.    *  2. THE LUND MONTE CARLO FOR E+E- JET PHYSICS  - T.SJOSTRAND   *
C.    *     LU TP 82-7 and COMPUTER PHYSICS COMMUNICATION 28(1983)229  *
C.    *                                                                *
C.    *    The parameters to use the LUND interface are set in GLUNDI  *
C.    *    They can be changed by data cards (see GLUNDI)              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE                               *
C.    *       Author    R.Hemingway  *********                         *
C.    *       modified by R.Brun  18/11/85 **                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION VERT(3)
+SEQ,GCBANK
+SEQ,GCFLAG
+SEQ,GCPUSH
+SEQ,LUJETS
+SEQ,GCLUND
      PARAMETER (NSEL=44)
      DIMENSION IPLUND(NSEL)
      REAL      PGEANT(3),BUF(1)
      EQUIVALENCE (BUF,K)
      DATA IPLUND/
     +    22,   -11,    11,    12,   -13,    13,   111,   211,
     +  -211,   130,   321,  -321,  2112,  2212, -2212,   310,
     +   221,  3122,  3222,  3212,  3112,  3322,  3312,  3334,
     + -2112, -3122, -3112, -3212, -3222, -3322, -3312, -3334,
     +   -15,    15,   411,  -411,   421,  -421,   431,  -431,
     +  4122,    24,   -24,    23/
*.
*.    ------------------------------------------------------------------
*.
      IF (IFINIT(3).EQ.0)  CALL GLUNDI
*
      CALL LUEEVT(IFLUND,ECLUND)
*
      NCVERT = 10
      NCKINE = N+10
      NCJXYZ = NCKINE
      NPVERT =  5
      NPKINE = 10
      NPJXYZ = 10
*
      VERT(1)   = 0.
      VERT(2)   = 0.
      VERT(3)   = 0.
      NWBUF=2+10*N
      CALL GSVERT(V,0,0,BUF,NWBUF,NVTX)
      IF (NVTX.GT.0) THEN
         DO 20 I = 1,N
            IF(K(I,1).GE.1.AND.K(I,1).LE.10) THEN
               DO 10 IGE=1, NSEL
                  IF(IPLUND(IGE).EQ.K(I,2)) THEN
                     PGEANT(1)=P(I,1)
                     PGEANT(2)=P(I,2)
                     PGEANT(3)=P(I,3)
                     CALL GSKINE(PGEANT,IGE,NVTX,BUF,0,NT)
                     GOTO 20
                  ENDIF
   10          CONTINUE
            ENDIF
   20    CONTINUE
*
         JV = LQ(JVERTX-1)
         JUV = LQ(JV-1)
         Q(JUV+1)= 527.0
         Q(JUV+2)= N
*
*     Copy the LUND record into a bank of real variables.
*
         DO 30 NP=1, N
            Q(JUV+2    +NP) = K(NP,1)
            Q(JUV+2+  N+NP) = K(NP,2)
            Q(JUV+2+2*N+NP) = K(NP,3)
            Q(JUV+2+3*N+NP) = K(NP,4)
            Q(JUV+2+4*N+NP) = K(NP,5)
            Q(JUV+2+5*N+NP) = P(NP,1)
            Q(JUV+2+6*N+NP) = P(NP,2)
            Q(JUV+2+7*N+NP) = P(NP,3)
            Q(JUV+2+8*N+NP) = P(NP,4)
            Q(JUV+2+9*N+NP) = P(NP,5)
   30    CONTINUE
*
      ENDIF
      END
+DECK,GLUNDI
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GLUNDI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        GEANT INTERFACE TO THE LUND MONTE-CARLO                 *
C.    *            (Initialization routine)                            *
C.    *                                                                *
C.    *  FOR TECHNICAL DETAILS OF THE LUND MONTE CARLO,SEE             *
C.    *  1. THE LUND MONTE CARLO FOR JET FRAGMENTATION - T.SJOSTRAND   *
C.    *     LU TP 82-3  and COMPUTER PHYSICS COMMUNICATION 27(1982)243 *
C.    *  2. THE LUND MONTE CARLO FOR E+E- JET PHYSICS  - T.SJOSTRAND   *
C.    *     LU TP 82-7 and COMPUTER PHYSICS COMMUNICATION 28(1983)229  *
C.    *                                                                *
C.    *  THE PARTICLES FORWARDED TO GEANT ARE                          *
C.    *  GAMMA,ELECTRON,NEUTRINO(E,MU,TAU),MU-,PI+,K+,K0S,K0L,         *
C.    *  PROTON,NEUTRON,SIG(+,-),XI(0,-),LAM,OM-                       *
C.    *  ....  AND THEIR ANTIPARTICLES                                 *
C.    *                                                                *
C.    *                                                                *
C.    *  THE USER MUST SUPPLY TWO PARAMETERS FOR EVENT GENERATION      *
C.    *  VIA     CALL LUEEVT(IFLUND,ECLUND)     WHERE                  *
C.    *  IFLUND=THE FLAVOUR CODE (1=U,2=D,3=S,4=C,5=B,6=T,0=MIX)       *
C.    *  ECLUND=THE TOTAL CMS ENERGY                                   *
C.    *                                                                *
C.    *     GLUNDI is automatically called by GLUND.                   *
C.    *     GLUNDI can be called by the user in the initialization     *
C.    *     routine UGINIT just before reading data cards (GFFGO)      *
C.    *     In this case the default parameters can be changed by      *
C.    *     the data cards KTYP,PMAS,PWID,MSTE,LUND and IDB            *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE                               *
C.    *       Author    R.Hemingway , D.Ward *********                 *
C.    *       modified by R.Brun 18/11/85 ******                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCFLAG
+SEQ,LUDAT1
+SEQ,LUDAT3
+SEQ,GCLUND
C.
C.    ------------------------------------------------------------------
C.
      IF (IFINIT(3).EQ.0)THEN
*
*              Set defaults
*
         IFINIT(3) = 1
         IFLUND = 0
         ECLUND = 92.25
*
*--  Initial state radiative effects     MSTJ(107) =  1
*
         MSTJ(107)= 1
*
*--  Set some particles to be stable in LUND so that GEANT can handle
*--  their tracking and decays. (K0s, sigma+-, xi0-, lambda0, omega-)
*
         MDCY(LUCOMP(310) ,1)=0
         MDCY(LUCOMP(3222),1)=0
         MDCY(LUCOMP(3112),1)=0
         MDCY(LUCOMP(3322),1)=0
         MDCY(LUCOMP(3312),1)=0
         MDCY(LUCOMP(3122),1)=0
         MDCY(LUCOMP(3334),1)=0
*
         CALL FFKEY('LUND',IFLUND,2,'MIXED')
      ENDIF
C
      END
+DECK,GPKINE.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GPKINE(IT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints kinematics bank JKINE for track number IT         *
C.    *       If IT=0 Prints all kinematics banks                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCUNIT
C.
C.    ------------------------------------------------------------------
C.
      WRITE(CHMAIL,1000)
      CALL GMAIL(1,0)
C
      I1=1
      I2=NTRACK
      IF(IT.NE.0)I1=IT
      IF(IT.NE.0)I2=IT
      IF(I2.GT.NTRACK)GO TO 99
      IF(I1.LT.1)GO TO 99
      IF(JKINE.LE.0)GO TO 99
C
      DO 20 ITRACK=I1,I2
         JK=LQ(JKINE-ITRACK)
         IF(JK.NE.0)THEN
            IPART=Q(JK+5)
            JPA=LQ(JPART-IPART)
            NL=IQ(JK-2)
            NG=Q(JK+7)+7
            NW=MIN(NG,16)
            WRITE(CHMAIL,2000)ITRACK,IQ(JPA+1),IQ(JPA+2),IQ(JPA+3),IPART
     +       ,(Q(JK+I),I=1,4),Q(JK+6),(INT(Q(JK+L)),L=8,NW)
   10       CALL GMAIL(0,0)
            IF(NG-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NG,NW+9)
               WRITE(CHMAIL,3000) (INT(Q(JK+L)),L=NS,NW)
               GO TO 10
            END IF
            IF(NL.GT.0) THEN
               JUK = LQ(JK-1)
               IF (JUK.GT.0) THEN
                  WRITE(CHMAIL,4000)
                  CALL GMAIL(0,0)
                  ND  = IQ(JUK-1)
                  NW=MIN(ND,9)
                  WRITE(CHMAIL,5000) (Q(JUK+L),L=1,NW)
   15             CALL GMAIL(0,0)
                  IF(ND-NW.GT.0) THEN
                     NS=NW+1
                     NW=MIN(ND,NW+9)
                     WRITE(CHMAIL,5000) (Q(JUK+L),L=NS,NW)
                     GO TO 15
                  END IF
               END IF
            END IF
         ENDIF
   20 CONTINUE
C
 1000 FORMAT(3X,'Kine',5X,'Name',10X,'Type',5X,'Px',9X,'Py',
     +       9X,'Pz',7X,'Energy',5X,'Vorigin',2X,'Vgener')
 2000 FORMAT(1X,I5,6X,3A4,I5,5(1X,F10.4),9(1X,I4))
 3000 FORMAT(84X,9(1X,I4))
 4000 FORMAT(62X,'User words')
 5000 FORMAT(1X,9(2X,E12.5))
C
  99  RETURN
      END
+DECK,GPKINX.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GPKINX(IT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints kinematics bank JKINE for track number IT         *
C.    *       If IT=0 Prints all kinematics banks                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  S.Giani *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCUNIT
      CHARACTER*20 NAME
      CHARACTER*32 CHLINE,CHSTRI(50)
C.
C.    ------------------------------------------------------------------
C.
*      WRITE(CHMAIL,1000)
*      CALL GMAIL(1,0)
C
      I1=1
      I2=NTRACK
      IF(IT.NE.0)I1=IT
      IF(IT.NE.0)I2=IT
      IF(I2.GT.NTRACK)GO TO 999
      IF(I1.LT.1)GO TO 999
      IF(JKINE.LE.0)GO TO 999
C
      DO 40 ITRACK=I1,I2
         JK=LQ(JKINE-ITRACK)
         IF(JK.NE.0)THEN
            IPART=Q(JK+5)
            JPA=LQ(JPART-IPART)
            NL=IQ(JK-2)
            NG=Q(JK+7)+7
            NW=MIN(NG,16)
            CHLINE='Kine='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(ITRACK,CHLINE(ILEN:))
            CHSTRI(1)=CHLINE
            CALL UHTOC(IQ(JPA+1),4,NAME,20)
            CHLINE='Name='
            ILEN=LENOCC(CHLINE)+1
            CHLINE(ILEN:)=NAME
            CHSTRI(2)=CHLINE
            CHLINE='Type='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IPART,CHLINE(ILEN:))
            CHSTRI(3)=CHLINE
            CHLINE='Px='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+1),CHLINE(ILEN:))
            CHSTRI(4)=CHLINE
            CHLINE='Py='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+2),CHLINE(ILEN:))
            CHSTRI(5)=CHLINE
            CHLINE='Pz='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+3),CHLINE(ILEN:))
            CHSTRI(6)=CHLINE
            CHLINE='Energy='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+4),CHLINE(ILEN:))
            CHSTRI(7)=CHLINE
            CHLINE='Vorigin='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+6),CHLINE(ILEN:))
*      WRITE(CHLINE(ILEN:),1002)Q(JK+6)
            CHSTRI(8)=CHLINE
            DO 10 JJ=8,NW
               CHLINE='Vgener='
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(INT(Q(JK+JJ)),CHLINE(ILEN:))
*       WRITE(CHLINE(ILEN:),1002)INT(Q(JK+JJ)
               CHSTRI(1+JJ)=CHLINE
   10       CONTINUE
            NLINE=8
            IF(NW.GE.8)NLINE=8+(NW-8+1)
            CALL IGMESS(NLINE,CHSTRI,'PICK','P')
*            WRITE(CHMAIL,2000)ITRACK,IQ(JPA+1),IQ(JPA+2),IQ(JPA+3),IPART
*     +       ,(Q(JK+I),I=1,4),Q(JK+6),(INT(Q(JK+L)),L=8,NW)
*   10       CALL GMAIL(0,0)
   20       CONTINUE
            IF(NG-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NG,NW+9)
               WRITE(CHMAIL,10200) (INT(Q(JK+L)),L=NS,NW)
               CALL GMAIL(0,0)
               GO TO 20
            END IF
            IF(NL.GT.0) THEN
*               WRITE(CHMAIL,10300)
*               CALL GMAIL(0,0)
*               JUK = LQ(JK-1)
*               NL  = IQ(JUK-1)
*               NW=MIN(NL,9)
*               WRITE(CHMAIL,10400) (Q(JUK+L),L=1,NW)
*   30          CALL GMAIL(0,0)
*               IF(NL-NW.GT.0) THEN
*                  NS=NW+1
*                  NW=MIN(NL,NW+9)
*                  WRITE(CHMAIL,10400) (Q(JUK+L),L=NS,NW)
*                  GO TO 30
*               END IF
            END IF
         ENDIF
   40 CONTINUE
C
10000 FORMAT(3X,'Kine',5X,'Name',10X,'Type',5X,'Px',9X,'Py',
     +       9X,'Pz',7X,'Energy',5X,'Vorigin',2X,'Vgener')
10100 FORMAT(1X,I5,6X,3A4,I5,5(1X,F10.4),9(1X,I4))
10200 FORMAT(84X,9(1X,I4))
10300 FORMAT(62X,'User words')
10400 FORMAT(1X,9(2X,E12.5))
10500 FORMAT(E12.5)
C
  999 CONTINUE
      END
+DECK,GPVERT.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GPVERT(IV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints vertex bank JVERTX for vertex number IV           *
C.    *       If IV=0 Prints all vertex banks                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCUNIT
C.
C.    ------------------------------------------------------------------
C.
      WRITE(CHMAIL,1000)
      CALL GMAIL(1,0)
C
      I1=1
      I2=NVERTX
      IF(IV.NE.0)I1=IV
      IF(IV.NE.0)I2=IV
      IF(I2.GT.NVERTX)GO TO 99
      IF(I1.LT.1)GO TO 99
      IF(JVERTX.LE.0)GO TO 99
C
      DO 20 IVERT=I1,I2
         JV=LQ(JVERTX-IVERT)
         IF(JV.NE.0)THEN
            TOFGN=Q(JV+4)*1.E+9
            NL=IQ(JV-2)
            NG=Q(JV+7)+7
            NW=MIN(NG,16)
            WRITE(CHMAIL,2000)IVERT,(Q(JV+I),I=1,3),TOFGN,
     +          INT(Q(JV+5)),INT(Q(JV+6)),(INT(Q(JV+L)),L=8,NW)
  10        CALL GMAIL(0,0)
            IF(NG-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NG,NW+9)
               WRITE(CHMAIL,3000)(INT(Q(JV+L)),L=NS,NW)
               GOTO 10
            ENDIF
            IF(NL.GT.0) THEN
               JUV = LQ(JV-1)
               IF(JUV.GT.0) THEN
                  WRITE(CHMAIL,4000)
                  CALL GMAIL(0,0)
                  ND  = IQ(JUV-1)
                  NW=MIN(ND,9)
                  WRITE(CHMAIL,5000) (Q(JUV+L),L=1,NW)
   15             CALL GMAIL(0,0)
                  IF(ND-NW.GT.0) THEN
                     NS=NW+1
                     NW=MIN(ND,NW+9)
                     WRITE(CHMAIL,5000) (Q(JUV+L),L=NS,NW)
                     GO TO 15
                  END IF
               END IF
            END IF
         ENDIF
   20 CONTINUE
C
 1000 FORMAT(3X,'Vert',8X,'Vx',11X,'Vy',11X,'Vz',8X,'Tofg',
     +       3X,'Tbeam',3X,'Targ',14X,'Gener tracks')
 2000 FORMAT(2X,I4,3(1X,F12.4),1X,F10.4,2X,2(I5,2X),9(1X,I4))
 3000 FORMAT(72X,9(1X,I4))
 4000 FORMAT(62X,'User words')
 5000 FORMAT(1X,9(2X,E12.5))
C
  99  RETURN
      END
+DECK,GSKINE
*CMZ :  3.21/02 28/03/94  01.30.59  by  S.Giani
*-- Author :
      SUBROUTINE GSKINE(PLAB,IPART,NV,BUF,NWBUF,NT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Store kinematics of track NT into data structure         *
C     *       Track is coming from vertex NV                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCPUSH
      DIMENSION PLAB(3),BUF(1)
      SAVE JV
C.
C.    ------------------------------------------------------------------
C.
      IF(NV.LE.0)GO TO 10
      IF(NV.GT.NVERTX)GO TO 90
      JV = LQ(JVERTX- NV)
      IF(JV.LE.0)GO TO 90
C
   10 NT     = NTRACK + 1
      IF (JKINE.EQ.0)THEN
         CALL MZBOOK(IXDIV,JKINE,JKINE,1,'KINE',NCKINE,NCKINE,1,2,0)
         IQ(JKINE-5)=0
      ENDIF
      IF(NT.GT.IQ(JKINE-2)) CALL MZPUSH(IXDIV,JKINE,NPKINE,0,'I')
C
      CALL MZBOOK(IXDIV,JK,JKINE,-NT,'KINE',1,1,8,3,0)
C
      IF (JPART.LE.0) GO TO 90
      IF (IPART.GT.IQ(JPART-2)) GO TO 90
      JPA = LQ(JPART- IPART)
      IF (JPA.LE.0) GO TO 90
      P2     = PLAB(1)**2 + PLAB(2)**2 + PLAB(3)**2
      AMASS = Q(JPA + 7)
      E      = SQRT(P2 + AMASS*AMASS)
C
C            Store kinematics in JKINE
C
      Q(JK + 1) = PLAB(1)
      Q(JK + 2) = PLAB(2)
      Q(JK + 3) = PLAB(3)
      Q(JK + 4) = E
      Q(JK + 5) = IPART
      Q(JK + 6) = NV
C
C            Copy user words
C
      IF(NWBUF.GT.0)THEN
         CALL MZBOOK(IXDIV,JUK,JK,-1,'KINU',0,0,NWBUF,3,0)
         IQ(JUK-5)=NT
C
         DO 15 I=1,NWBUF
            Q(JUK+I)=BUF(I)
   15    CONTINUE
      ENDIF
C
C
C            Connect track NT to vertex NV
C
      IF(NV.GT.0)THEN
         JV = LQ(JVERTX- NV)
         NTG = Q(JV + 7)
         NFREE=IQ(JV-1)-7-NTG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JV,0,2,'I')
         Q(JV + NTG + 8) = NT
         Q(JV + 7) = NTG + 1
      ENDIF
C
      NTRACK = NT
      IQ(JKINE+1)=NTRACK
      GO TO 99
C
C            Error
C
  90  NT     = 0
  99  RETURN
      END
+DECK,GSKINU.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GSKINU (ITRA,NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in JKINE  user bank,          *
C     *       for track ITRA. (ITRA must be an already existing track) *
C     *       IADR is the stating location within the bank.            *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCFLAG.
*
      DIMENSION UBUF(1)
*
      IF ((JKINE.GT.0).AND.(LQ(JKINE-ITRA).GT.0)) THEN
*
         JK = LQ(JKINE-ITRA)
         NDATA = IADR + NWBUF
         IF (LQ(JK-1).EQ.0) THEN
            CALL MZBOOK (IXDIV,JKU,JK,-1,'KINU',0,0,NDATA,3,0)
            IQ(JKU-5) = ITRA
         ELSE
            JKU = LQ(JK-1)
            NFREE = IQ(JKU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXDIV,JKU,0,-NFREE,'I')
         ENDIF
*
         DO 10 I=1,NWBUF
            Q(JKU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
      ELSE
*
         IADR = 0
         WRITE(CHMAIL,1000) IEVENT,ITRA
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSKINU: No JKINE bank in memory for ievent:',I7,
     &       '   or track:',I4,'does not exist')
*
      END
+DECK,GSVERT
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GSVERT(V,NTBEAM,NTTARG,UBUF,NWBUF,NVTX)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Creates a new vertex bank                                *
C     *       Vertex is generated from tracks NTBEAM NTTARG            *
C     *       NVTX is the new vertex number                            *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCPUSH
+SEQ,GCTRAK
      DIMENSION V(3),UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      NVTX   = NVERTX + 1
      IF (JVERTX.EQ.0)THEN
         CALL MZBOOK(IXDIV,JVERTX,JVERTX,1,'VERT',NCVERT,NCVERT,1,2,0)
         IQ(JVERTX-5)=0
      ENDIF
      IF(NVTX.GT.IQ(JVERTX-2)) CALL MZPUSH(IXDIV,JVERTX,NPVERT,0,'I')
C
      CALL MZBOOK(IXDIV,JV,JVERTX,-NVTX,'VERT',1,1,9,3,0)
C
      IF(NWBUF.GT.0)THEN
         CALL MZBOOK(IXDIV,JUV,JV,-1,'VERU',0,0,NWBUF,3,0)
         IQ(JUV-5)=NVTX
         DO 3 I=1,NWBUF
   3     Q(JUV+I)=UBUF(I)
      ENDIF
      DO 4 I=1,3
   4  Q(JV + I) = V(I)
      Q(JV + 4) = TOFG
      Q(JV + 5) = NTBEAM
      Q(JV + 6) = NTTARG
      NTK=0
      IF(JKINE.GT.0)NTK=IQ(JKINE-2)
      IF(NTBEAM.GT.NTK)GO TO 90
      IF(NTBEAM.LT.0)GO TO 90
      IF(NTTARG.GT.NTK)GO TO 90
      IF(NTTARG.LT.0)GO TO 90
      IF(NTBEAM.NE.0)THEN
         JK = LQ(JKINE- NTBEAM)
         IF(JK.EQ.0)GO TO 90
         NVG = Q(JK + 7)
         NFREE=IQ(JK-1)-7-NVG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JK,0,2,'I')
         Q(JK + NVG + 8) = NVTX
         Q(JK + 7) = NVG + 1
      ENDIF
C
      IF(NTTARG.NE.0)THEN
         JK = LQ(JKINE- NTTARG)
         NVG = Q(JK + 7)
         NFREE=IQ(JK-1)-7-NVG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JK,0,2,'I')
         Q(JK + NVG + 8) = NVTX
         Q(JK + 7) = NVG + 1
      ENDIF
C
      NVERTX = NVTX
      IQ(JVERTX+1)=NVERTX
      GO TO 99
C
C             Error
C
  90  NVTX   = 0
  99  RETURN
      END
+DECK,GSVERU.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GSVERU (IVTX,NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in VERTEX user bank,          *
C     *       for vertex IVTX. (IVTX must be an already existing vertex)*
C     *       IADR is the stating location within the bank.            *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCFLAG.
*
      DIMENSION UBUF(1)
*
      IF ((JVERTX.GT.0).AND.(LQ(JVERTX-IVTX).GT.0)) THEN
*
         JV = LQ(JVERTX-IVTX)
         NDATA = IADR + NWBUF
         IF (LQ(JV-1).EQ.0) THEN
            CALL MZBOOK (IXDIV,JVU,JV,-1,'VERU',0,0,NDATA,3,0)
            IQ(JVU-5) = IVTX
         ELSE
            JVU = LQ(JV-1)
            NFREE = IQ(JVU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXDIV,JVU,0,-NFREE,'I')
         ENDIF
*
         DO 10 I=1,NWBUF
            Q(JVU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
      ELSE
*
         IADR = 0
         WRITE(CHMAIL,1000) IEVENT,IVTX
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSVERU: No Vertex bank in memory for ievent:',I7,
     &       '   or vertex:',I4,'does not exist')
*
      END
+DECK,GTAU
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GTAU
C.
C.    ******************************************************************
C.    *                                                                *
C.    *            Generates the process e+e- -> tau+ tau-             *
C.    *             can be called from GUKINE                          *
C.    *                                                                *
C.    *       Author    R.Hemingway  26 Sept 1985                      *
C.    *       Obsoleted in 3.15                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCUNIT.
      WRITE(CHMAIL,10000)
10000 FORMAT('Obsolete GTAU reached. This routine is now dummy.')
      CALL GMAIL(1,1)
C
      END
+PATCH,GPHYS
+DECK,DOCGPHYS,IF=DOC
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                  Introduction to the section PHYS                    *
*                  --------------------------------                    *
*                                                                      *
*                                                                      *
* THE PHYSICS PROCESSES                                                *
*                                                                      *
*  The processes  currently implemented in GEANT3  can be classified   *
* as follows:                                                          *
*                                                                      *
* - Decays in flight                                                   *
* - Multiple scattering (Gaussian or Moliere)                          *
* - Continuous electromagnetic processes                               *
* - Discrete electromagnetic processes                                 *
* - Hadronic interactions                                              *
* - Muon nucleus-interactions.                                         *
*                                                                      *
*  The  fist  two  are  controlled  by  the  routines  GDECAY  which   *
* generates the decay products and  GMULTS which computes the change   *
* in  the angle  due to  multiple scattering  over a  given tracking   *
* step.   The  others  are  reviewed  separately  in  the  following   *
* paragraphs.                                                          *
*  For  convenience the  particles are  given a  'tracking type'  in   *
* GEANT, depending on their interaction with matter:                   *
*                                                                      *
*   ITRTYP = 1  photon                                                 *
*            2  electron and positron                                  *
*            3  neutral particles                                      *
*            4  charged hadrons                                        *
*            5  muon                                                   *
*            6  'Geantino'                                             *
*            7  Cerenkov photon                                        *
*            8  Ion                                                    *
*                                                                      *
*  The  paragraph  5  gives  a  summary  of  the  physics  processes   *
* activated for  each type  of particle with  the momentum  range of   *
* validity when relevant.  GPHYSI controls the initialisation of the   *
* various processes.                                                   *
*                                                                      *
* CONTINUOUS ELECTROMAGNETIC PROCESSES                                 *
*                                                                      *
* GMOLI     Initializes Moliere scattering                             *
* GPROBI    initializes material 'constants'  used for computing the   *
*           probability of various interactions.                       *
* GDRELA    Control routine  to fill   DE/DX tables for  energy loss   *
*           due to ionisation.                                         *
* GDRELP    Calculates  energy loss  due to  ionisation for  charged   *
*           particles other than electrons and positrons.              *
* GDRELE    Calculates energy  loss due to ionisation  for electrons   *
*           and  positrons.  As  Moller  and  Bhabba scattering  are   *
*           treated  as discrete  processes the  energy loss  due to   *
*           ionisation is a function  of the electron kinetic energy   *
*           cut-off DCUTE below which these processes are treated as   *
*           a continuous energy loss [BASE 030, common /GCPHYS/].      *
* GBRELA    Initializes   Bremsstrahlung  cross-section   and  fills   *
*           energy  loss tables  for Bremsstrahlung.   Both formulae   *
*           depend on  the photon  energy cut-off BCUTE  below which   *
*           Bremsstrahlung is  treated as  a continuous  energy loss   *
*           [BASE 030, common /GCPHYS/].                               *
* GPRELA    Fills  DE/DX  tables  for  energy loss  by  direct  pair   *
*           production  for high  energy  muons.  The  corresponding   *
*           discrete process is not considered.                        *
* GRANGI    Calculates    the    stopping     range    tables    for   *
*           electron/positron, muon and proton.                        *
* GMULOF    Calculates the tables for the maximum step allowed to to   *
*           continuous processes: Bending  in magnetic field, energy   *
*           loss and multiple scattering.                              *
* GCOEFF    Calculates  the   interpolation  coefficients   for  the   *
*           energy/Range relation  to be used in  the calculation of   *
*           the energy loss.                                           *
*                                                                      *
* DISCRETE ELECTROMAGNETIC PROCESSES                                   *
*                                                                      *
*   For the simulation of each  given discrete physics process three   *
* tasks have to be performed:                                          *
*                                                                      *
* - The evaluation  of the step  length.  This is computed  from the   *
*   updated  probability for  the  occurrence of  the process.   The   *
*   corresponding code  has been  inserted directly in  the tracking   *
*   routines for each tracking type as appropriate.                    *
* - After transport  of the  particle, the  generation of  the final   *
*   state particles (GEANT routines GPHOT, GCOMP, etc.)                *
* - If the  particle survives  after the interaction,  recompute the   *
*   probability.                                                       *
*                                                                      *
*   It should be outlined that the  evaluation of the step length is   *
* made independently  for each  process which  can occur,  the final   *
* step  size  being the  minimum  of  all  and the  process  finally   *
* considered being the corresponding one.                              *
*                                                                      *
* GPHOTI    Tabulates  cross-section  for photo-electric  effect  at   *
*           initialisation time                                        *
* GPHOT     Simulates photo-electric mechanism                         *
* GCOMPI    Tabulates  cross-section  for  Compton  intersection  at   *
*           initialisation time                                        *
* GCOMP     Simulates Compton scattering                               *
* GPRSGA    Tabulates   cross-section   for   pair   production   at   *
*           initialisation time                                        *
* GPAIRG    Simulates electron pair production by photons              *
* GBRSGA    Tabulates    cross-section    for   Bremsstrahlung    at   *
*           initialisation time                                        *
* GBREME    Simulates  hard  Bremsstrahlung   by  electrons.  -  see   *
*           cut-off BCUTE in routine GBRELA above                      *
* GDRSGA    Tabulates cross-section for  delta-ray at initialisation   *
*           time                                                       *
* GDRAY     Simulates delta rays (Moller or Bhabba scattering) - see   *
*           cut-off DCUTE in routine GDRELE above                      *
* GANNII    Tabulates  cross-section  for positron  annihilation  at   *
*           initialisation time                                        *
* GANNI     Simulates positron annihilation in flight                  *
* GANNIR    Simulates positron annihilation at rest.                   *
* GPFISI    Tabulates cross-section for photo-fission                  *
* GPFIS     Simulates photo-fission                                    *
*                                                                      *
* HADRONIC PROCESSES                                                   *
*                                                                      *
*   For GHEISHA:                                                       *
* GPGHEI    returns the hadronic cross section                         *
* GHEISH    Simulates  hadronic  interactions, program  GHEISHA  (H.   *
*           Fesefeldt) in GEANH file.                                  *
*                                                                      *
*   For FLUKA:                                                         *
* FLDIST    returns the hadronic cross section                         *
* FLUFIN    Simulates    hadronic   interactions,    program   FLUKA   *
*           (A.Ferrari et al.) in GEANH file.                          *
*                                                                      *
* MUON INTERACTION                                                     *
*                                                                      *
* GBRELM    Tabulates energy loss by soft Bremsstrahlung               *
* GBRSGM    Tabulates cross-section for hard Bremsstrahlung            *
* GBREMM    Generates hard Bremsstrahlung                              *
* GPAIRI    Tabulates cross-section for direct pair production         *
* GPAIRM    Generate direct pair production                            *
* GMUNUI    Tabulates cross-section for nuclear interaction            *
* GMUNU     Generates nuclear interaction                              *
* GDRELM    Tabulates energy loss by soft delta rays                   *
* GDRSGA    Tabulates cross-section for hard delta rays                *
* GDRAY     Generates delta rays                                       *
*                                                                      *
************************************************************************
+DECK,GANNI.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GANNI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates positron annihilation                               *
C.    *                                                                *
C.    *    ==>Called by : GTELEC                                       *
C.    *       Author    L.Urban *********                              *
C.    *       10/06/93: modified by Georges Azuelos (Vancouver)        *
C     *                 to include 1-quantum annihilation              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCPHYS.
+SEQ,GCTRAK.
+SEQ,GCCUTS.
+SEQ,GCKING.
+SEQ,GCONSP.
+SEQ,GCBANK.
+SEQ,GCMULO.
+SEQ,GCJLOC.
+SEQ,GCMATE.
      DIMENSION PGAM(3),RNDM(2)
      LOGICAL ROTATE
      PARAMETER (ALFA=7.29735E-3)
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(11)
      IF((IANNI.NE.1).OR.((GETOT+EMASS).LE.CUTGAM)) THEN
         ISTOP = 2
         DESTEP = DESTEP + GETOT + EMASS
         GEKIN = 0.
         GETOT = EMASS
         VECT(7)= 0.
         GO TO 999
      ENDIF
C
      XE=GETOT
      GAM=XE/EMASS
      GAM2=GAM**2
      GAM1=MAX(GAM2-1.,0.)
      GAMP1=GAM+1.
      C=SQRT(GAM1)
*
      SIG=(GAM2+4.*GAM+1.)*LOG(GAM+C)/GAM1-(GAM+3.)/C
      SIG=0.5*Q(JPROB+17)*SIG/GAMP1
*
      BIND=0.5*(Z*ALFA)**2*EMASS
      E1Q=XE+EMASS-BIND
      IF(E1Q .GT. 0.)THEN
         GVE=VECT(7)/EMASS
         SIG1=GAM2+2.*(GAM+2.)/3.-(GAM+2.)/GVE*LOG(GAM+GVE)
         SIG1=2.*Q(JPROB+18)*SIG1/(GVE*GAMP1**2)
      ELSE
         SIG1=0.
      END IF
*
      SIG=SIG+SIG1
      CALL GRNDM(RNDM,1)
C
      IF(RNDM(1).GE.SIG1/SIG)THEN
         GAMP12=GAMP1**2
         P=VECT(7)
         E0=1./(GAMP1+C)
C
   10    CALL GRNDM(RNDM,2)
         E=E0*((1.-E0)/E0)**RNDM(1)
C
         SCREJ=(GAMP12+2.*GAMP1-2.-GAMP12*E-1./E)/(GAMP12-2.)
         IF(RNDM(2).GT.SCREJ) GOTO 10
C
         EPHOT1=(XE+EMASS)*E
C
         COSTH=(GEKIN+EMASS*(2.*E-1.)/E)/P
         SINTH=SQRT((1.-COSTH)*(1.+COSTH))
         CALL GRNDM(RNDM,1)
         PHI = TWOPI * RNDM(1)
         COSPHI = COS(PHI)
         SINPHI = SIN(PHI)
C
         PGAM(1) = EPHOT1* SINTH * COSPHI
         PGAM(2) = EPHOT1* SINTH * SINPHI
         PGAM(3) = EPHOT1* COSTH
C
C             Rotate tracks into GEANT system and store.
C
         CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
         NGGAMM = 0
         IF(EPHOT1.GT.CUTGAM) THEN
            NGGAMM = NGGAMM + 1
            NGKINE = NGKINE + 1
            GKIN(1,NGKINE) = PGAM(1)
            GKIN(2,NGKINE) = PGAM(2)
            GKIN(3,NGKINE) = PGAM(3)
            GKIN(4,NGKINE) = EPHOT1
            GKIN(5,NGKINE) = 1
            TOFD(NGKINE)=0.
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
            IF(ROTATE)
     +      CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
         ELSE
            DESTEP = DESTEP + EPHOT1
         ENDIF
C
C             Momentum vector of second photon.
C
         EPHOT2 = GETOT + EMASS - EPHOT1
         IF(EPHOT2.GT.CUTGAM) THEN
            NGGAMM = NGGAMM + 1
            NGKINE = NGKINE + 1
            GKIN(1,NGKINE) = - PGAM(1)
            GKIN(2,NGKINE) = - PGAM(2)
            GKIN(3,NGKINE) = P - PGAM(3)
            GKIN(4,NGKINE) = EPHOT2
            GKIN(5,NGKINE) = 1
            TOFD(NGKINE)=0.
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
            IF(ROTATE)
     +      CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
         ELSE
            DESTEP = DESTEP + EPHOT2
         ENDIF
      ELSE
C 1-quantum annihilation
         P=VECT(7)
         EPHOT=E1Q
C Assume photon collinear with positron
         PGAM(1) = 0.
         PGAM(2) = 0.
         PGAM(3) = EPHOT
C
C             Rotate tracks into GEANT system and store.
C
         CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
         NGGAMM = 0
         IF(EPHOT.GT.CUTGAM) THEN
            NGGAMM = NGGAMM + 1
            NGKINE = NGKINE + 1
            GKIN(1,NGKINE) = PGAM(1)
            GKIN(2,NGKINE) = PGAM(2)
            GKIN(3,NGKINE) = PGAM(3)
            GKIN(4,NGKINE) = EPHOT
            GKIN(5,NGKINE) = 1
            TOFD(NGKINE)=0.
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
            IF(ROTATE)
     +      CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
         ELSE
            DESTEP = DESTEP + EPHOT
         ENDIF
      END IF
C
      IF(NGGAMM.GT.0) THEN
         ISTOP = 1
      ELSE
         ISTOP = 2
      ENDIF
C
 999  CONTINUE
      END
+DECK,GANNI2
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GANNI2
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Generates positron annihilation at rest                  *
C.    *       (alias of GANNIR , directly called from GPAIRG)          *
C.    *                                                                *
C.    *    ==>Called by : GPAIRG,GPAIRM                                *
C.    *       Author    M.Maire *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCPHYS
+SEQ,GCTRAK
+SEQ,GCKING
+SEQ,GCCUTS
+SEQ,GCONSP
      DIMENSION RNDM(2)
C.
      KCASE = NAMEC(11)
      IF((IANNI.NE.1).OR.(EMASS.LE.CUTGAM)) THEN
         DESTEP = DESTEP + 2*EMASS
         GO TO 999
      ENDIF
      CALL GRNDM(RNDM,2)
      CT=-1.+2.*RNDM(1)
      ST=SQRT((1.-CT)*(1.+CT))
      PHI=TWOPI*RNDM(2)
      NGKINE=NGKINE+1
      GKIN(1,NGKINE)=EMASS*ST*COS(PHI)
      GKIN(2,NGKINE)=EMASS*ST*SIN(PHI)
      GKIN(3,NGKINE)=EMASS*CT
      GKIN(4,NGKINE)=EMASS
      GKIN(5,NGKINE)=1.
      TOFD(NGKINE)=0.
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
      NGKINE=NGKINE+1
      DO 10 J=1,3
   10 GKIN(J,NGKINE)=-GKIN(J,NGKINE-1)
      GKIN(4,NGKINE)=EMASS
      GKIN(5,NGKINE)=1.
      TOFD(NGKINE)=0.
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
  999 CONTINUE
      END
+DECK,GANNII.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GANNII
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for positron annihilation                                     *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, L.Urban  *********                    *
C.    *       10/06/93: modified by Georges Azuelos (Vancouver)        *
C     *                 to include 1-quantum annihilation              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCTRAK
+SEQ,GCMATE.
+SEQ,GCONSP.
+SEQ,GCJLOC.
+SEQ,GCMULO.
C.
C.    ------------------------------------------------------------------
C.
      SIG=0.
      IF(Z.GE.1.) THEN
         XE=ELOW(IEKBIN)+EMASS
         GAM=XE/EMASS
         GAM2=GAM**2
         GAM1=MAX(GAM2-1.,0.)
         C=SQRT(GAM1)
*
         SIG=(GAM2+4.*GAM+1.)*LOG(GAM+C)/GAM1-(GAM+3.)/C
         SIG=0.5*Q(JPROB+17)*SIG/(GAM+1.)
         PE=SQRT((XE-EMASS)*(XE+EMASS))
*
         GVE=PE/EMASS
         SIG1=GAM2+2.*(GAM+2.)/3.-(GAM+2.)/GVE*LOG(GAM+GVE)
         SIG1=2.*Q(JPROB+18)*SIG1/(GVE*(GAM+1.)**2)
*
         SIG=SIG+SIG1
      ENDIF
      IF(SIG.GT.0.)THEN
         Q(JANNI+IEKBIN)=1./SIG
      ELSE
         Q(JANNI+IEKBIN)=BIG
      ENDIF
C
      END
+DECK,GANNIR
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GANNIR
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates positron annihilation in rest                       *
C.    *                                                                *
C.    *    ==>Called by : GTELEC                                       *
C.    *       Author    L.Urban, M.Maire *********                     *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCPHYS
+SEQ,GCTRAK
+SEQ,GCCUTS
+SEQ,GCKING
+SEQ,GCONSP
      DIMENSION RNDM(2)
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(11)
      IF((IANNI.NE.1).OR.(EMASS.LE.CUTGAM)) THEN
          ISTOP = 2
          DESTEP = DESTEP + 2*EMASS
          RETURN
      ENDIF
         ISTOP = 1
         CALL GRNDM(RNDM,2)
         CT=-1.+2.*RNDM(1)
         ST=SQRT(ABS(1.-CT*CT))
         PHI=TWOPI*RNDM(2)
         NGKINE=NGKINE+1
         GKIN(1,NGKINE)=EMASS*ST*COS(PHI)
         GKIN(2,NGKINE)=EMASS*ST*SIN(PHI)
         GKIN(3,NGKINE)=EMASS*CT
         GKIN(4,NGKINE)=EMASS
         GKIN(5,NGKINE)=1.
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         NGKINE=NGKINE+1
         DO 30 J=1,3
  30     GKIN(J,NGKINE)=-GKIN(J,NGKINE-1)
         GKIN(4,NGKINE)=EMASS
         TOFD(NGKINE)=0.
         GKIN(5,NGKINE)=1.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
      END
+DECK,GAVRL2.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      REAL FUNCTION GAVRL2(GAMA,BETA,XM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  L2 shell x-section a la Gavrila                               *
C.    *    Gama  - L2 shell photoelectron gama                         *
C.    *    Beta  - L2 shell photoelectron beta                         *
C.    *    XM    - ratio of the electron mass to the photon energy     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE
      DOUBLE PRECISION G,G2,G3,B,P1,P2,P3
+SELF
      G = GAMA
      G2 = G*G
      G3 = G2*G
      B  = BETA
      P1 = (9*G3-5*G2+24*G-16)
      P2 = -(G2+3*G-8)
      P3 = 1
      IF(B.GT.0.0001) P3 = LOG(G*(1+B))/(B*G)
      GAVRL2 = (P1+P2*P3)*B*G*XM**5
      END
+DECK,GAVRL3.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      REAL FUNCTION GAVRL3(GAMA,BETA,XM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  L3 shell x-section a la Gavrila                               *
C.    *    Gama  - L3 shell photoelectron gama                         *
C.    *    Beta  - L3 shell photoelectron beta                         *
C.    *    XM    - ratio of the electron mass to the photon energy     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE
      DOUBLE PRECISION G,G2,G3,B,P1,P2,P3
+SELF
      G = GAMA
      G2 = G*G
      G3 = G2*G
      B  = BETA
      P1 = (4*G3-6*G2+5*G+3)
      P2 = -(G2-3*G+4)
      P3 = 1
      IF(BETA.GT.0.0001) P3 = LOG(G*(1+B))/(B*G)
      GAVRL3 = (P1+P2*P3)*B*G*XM**5
      END
+DECK,gbflos.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GBFLOS(T,C)
C.    ******************************************************************
C.    *                                                                *
C.    *  It calculates a weight factor for the positron continuous     *
C.    *       bremsstrahlung energy loss.                              *
C.    *                                                                *
C.    *  Input:T kinetic energy (GeV)                                  *
C.    *        C cut for bremsstrahlung (BCUTE)                        *
C.    *        ETA ratio of positron to electron brems loss            *
C.    *  Output: weight factor                                         *
C.    *                                                                *
C.    *  ===>   positron loss = FLOS * electron loss   <===            *
C.    *                                                                *
C.    *  Author   L. Urban                                             *
C.    *                                                                *
C.    ******************************************************************
C.
      ETA = GCBREM(T)
      IF(ETA.LT.0.0001) THEN
         F=1.E-10
      ELSEIF(ETA.GT.0.9999) THEN
         F=1.
      ELSE
C
         E0=C/T
         IF(E0.GT.1.) E0=1.
C
         IF(E0.LT.1.E-8) THEN
            F=1.
         ELSE
            ALFA=1./ETA
            E1=1.-E0
            F=ETA*(1.-E1**ALFA)/E0
         ENDIF
C
      ENDIF
*
      GBFLOS=F
      END
+DECK,GBFSIG.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GBFSIG(T,C)
C.    ******************************************************************
C.    *                                                                *
C.    *  It calculates a weight factor for the positron discrete       *
C.    *       (hard) bremsstrahlung cross section                      *
C.    *                                                                *
C.    *  Input:T kinetic energy (GeV)                                  *
C.    *        C cut for bremsstrahlung (BCUTE)                        *
C.    *        ETA ratio of positron to electron brems cross section   *
C.    *  Output: weight factor                                         *
C.    *                                                                *
C.    *  ===>  positron sigma = Fsig * electron sigma  <===            *
C.    *                                                                *
C.    *  Author   L. Urban                                             *
C.    *                                                                *
C.    ******************************************************************
C.
      ETA = GCBREM(T)
      IF(ETA.LT.0.0001) THEN
         F=1.E-10
      ELSEIF(ETA.GT.0.9999) THEN
         F=1.
      ELSE
C
         E0=C/T
C
         IF(E0.GE.1.) THEN
            F=1.E-10
         ELSE
            ALFA=1./ETA
            E1=1.-E0
            F=ETA*E1**ALFA/E1
         ENDIF
      ENDIF
C
      GBFSIG=F
      END
+DECK,GBIRK.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GBIRK(EDEP)
*
************************************************************************
*                                                                      *
* *** apply BIRK's saturation law to energy deposition ***             *
* *** only organic scintillators implemented in this version MODEL=1   *
*                                                                      *
* Note : the material is assumed ideal, which means that impurities    *
*        and aging effects are not taken into account                  *
*                                                                      *
* algorithm : edep = destep / (1. + RKB*dedx + C*(dedx)**2)            *
*                                                                      *
* the values of RKB and C can be entered via :                         *
*                                                                      *
* call gstpar(imate,'BIRK1',value) to set the model (must be 1 or 2)   *
* call gstpar(imate,'BIRK2',value) to set RKB                          *
* call gstpar(imate,'BIRK3',value) to set C                            *
*                                                                      *
* the basic units of the coefficient are g/(Mev*cm**2)                 *
* because the de/dx is obtained in Mev/cm                              *
*                                                                      *
* exp. values from NIM 80 (1970) 239-244 :                             *
*                                                                      *
* RKB = 0.013  g/mev*cm**2  and  C = 9.6e-6  g**2/(Mev**2)(cm**4)      *
*                                                                      *
*    ==>Called by : <USER>,GUSTEP                                      *
*       Author    R.Brun , N.Van Eijndhoven    *********               *
*                                                                      *
************************************************************************
*
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCKINE.
+SEQ,GCMATE.
+SEQ,GCTRAK.
C.
C.    ------------------------------------------------------------------
C.
      EDEP=DESTEP
C
C --- no saturation law for neutral particles ---
      IF (ABS(CHARGE) .LE. 1.E-10) GO TO 99
C
C --- get the values for the BIRK coefficients stored via GSTPAR ---
      JTMN=LQ(JTM)
      IF (JTMN .LE. 0)GO TO 99
      MODEL=Q(JTMN+27)
      IF(MODEL.GT.2)GO TO 99
      RKB=Q(JTMN+28)/DENS
      C=Q(JTMN+29)/DENS**2
C
C --- correction for particles with more than 1 charge unit ---
C --- based on alpha particle data (only apply for MODEL=1) ---
      IF(MODEL.EQ.1)THEN
         IF (ABS(CHARGE) .GE. 2.) RKB=RKB*7.2/12.6
      ENDIF
C
      DEDXCM=1000.*Q(JLOSS+IEKBIN)
C
      EDEP=DESTEP/(1.+RKB*DEDXCM+C*DEDXCM**2)
C
  99  RETURN
      END
 
+DECK,GBRELA
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GBRELA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialize the bremsstrahlung energy loss tables              *
C.    *            ( See L.Urban report)                               *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    G.Patrick, L.Urban  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCMULO
+SEQ,GCJLOC
+SEQ,GCTRAK
+SEQ,GCCUTS
+SEQ,GCMATE
+SEQ,GCONSP
+SEQ,GCPHYS
      DIMENSION DEM(8)
      DATA DEM/-6.76228E-1,4.35611E-1,-4.69224E-1,-7.05133E-3,
     +        1.31200,-8.07563E-1,-6.96166E-1,3.62549E-1/
C.
C.    ------------------------------------------------------------------
C.
C            Number of constituents(ie. element,mixture or compound).
C
      NLMAT = Q(JMA+11)
      NLM    = IABS(NLMAT)
      IF (NLMAT.EQ.0)                             GO TO 999
      IF(Z.LT.1.)                                 GO TO 999
C
      JEL1=LQ(JMA-1)
      JEL2=LQ(JMA-2)
      ICHAN=IEKBIN
      XE     = ELOW(ICHAN)
      XE1    = 10.**(EKBIN(1)+(ICHAN-0.5)/GEKA)
C
C==========>  A,Bremsstrahlung losses for electrons
C             special treatment for compounds/mixtures
C
      IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
         DEDX=GBRELE(Z,XE,BCUTE)
         DEDX=AVO*DENS*DEDX/A
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DEDX1=GBRELE(Z,XE1,BCUTE)
            DEDX1=AVO*DENS*DEDX1/A
         ENDIF
      ELSE
C
C             compound/mixture
C
         DEDX=0.
         DEDX1=0.
         DO 10 L=1,NLM
            J = JMIXT+NLM+L
            AA = Q(J-NLM)
            ZZ = Q(J)
            WMAT= Q(J+NLM)
            S = GBRELE(ZZ,XE,BCUTE)
            S = WMAT*S/AA
            DEDX= DEDX+AVO*DENS*S
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               S = GBRELE(ZZ,XE1,BCUTE)
               S = WMAT*S/AA
               DEDX1= DEDX1+AVO*DENS*S
            ENDIF
   10    CONTINUE
      ENDIF
C
      IF(DEDX.LT.0.)DEDX=0.
      Q(JEL1+ICHAN)=Q(JEL1+ICHAN)+DEDX
      FACT = GBFLOS(XE,BCUTE)
      Q(JEL1+ICHAN+NEK1)=Q(JEL1+ICHAN+NEK1)+FACT*DEDX
*
      IF(ISTRA.NE.0) Q(JEL1+ICHAN+2*NEK1) = DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         IF(DEDX1.LT.0.)DEDX1=0.
         WS(ICHAN)=WS(ICHAN)+DEDX1
         FACT = GBFLOS(XE1,BCUTE)
         WS(NEKBIN+ICHAN)=WS(NEKBIN+ICHAN)+FACT*DEDX1
      ENDIF
C
C===========>  B, Bremsstrahlung losses for muons
C
      IF(XE.GE.1.)GO TO 20
      CONS1=3.26485E-8*Z*Z*DENS/A
      CONS2=LOG(2.70511)-LOG(A)/3.
      R=EMMU/(XE+EMMU)
      RL=LOG(R)
      DEDX=DEM(1)+RL*DEM(3)+R*(DEM(5)+R*DEM(7))
      DEDX=DEDX+CONS2*(DEM(2)+RL*DEM(4)+R*(DEM(6)+R*DEM(8)))
      DEDX=CONS1*XE*DEDX
      IF(DEDX.LT.0.)DEDX=0.
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX
*
      IF(ISTRA.NE.0) Q(JEL2+ICHAN+NEK1) = DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         R=EMMU/(XE1+EMMU)
         RL=LOG(R)
         DEDX1=DEM(1)+RL*DEM(3)+R*(DEM(5)+R*DEM(7))
         DEDX1=DEDX1+CONS2*(DEM(2)+RL*DEM(4)+R*(DEM(6)+R*DEM(8)))
         DEDX1=CONS1*XE1*DEDX1
         IF(DEDX1.LT.0.)DEDX1=0.
         WS(NEKBIN*2+ICHAN) = WS(NEKBIN*2+ICHAN)+DEDX1
      ENDIF
      GO TO 999
C
   20 IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
         DEDX=GBRELM(Z,XE,BCUTM)
         DEDX=AVO*DENS*DEDX/A
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DEDX1=GBRELM(Z,XE1,BCUTM)
            DEDX1=AVO*DENS*DEDX1/A
         ENDIF
      ELSE
C
C             compound/mixture
C
         DEDX=0.
         DEDX1=0.
         DO 30 L=1,NLM
            J = JMIXT+NLM+L
            AA = Q(J-NLM)
            ZZ = Q(J)
            WMAT= Q(J+NLM)
            S = GBRELM(ZZ,XE,BCUTM)
            S = WMAT*S/AA
            DEDX= DEDX+AVO*DENS*S
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               S = GBRELM(ZZ,XE1,BCUTM)
               S = WMAT*S/AA
               DEDX1= DEDX1+AVO*DENS*S
            ENDIF
   30    CONTINUE
      ENDIF
C
      IF(DEDX.LT.0.)DEDX=0.
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX
*
      IF(ISTRA.NE.0) Q(JEL2+ICHAN+NEK1) = DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         IF(DEDX1.LT.0.)DEDX1=0.
         WS(NEKBIN*2+ICHAN)=WS(NEKBIN*2+ICHAN)+DEDX1
      ENDIF
C
  999 CONTINUE
      END
+DECK,GBRELE.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GBRELE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates energy loss by soft Bremsstrahlung                 *
C.    *         (in GeV barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRELA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCMATE
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
+SELF,IF=-BETHE.
      DATA C1/-0.960613E-01, 0.631029E-01,-0.142819E-01, 0.150437E-02
     +      ,-0.733286E-04, 0.131404E-05, 0.859343E-01,-0.529023E-01
     +      , 0.131899E-01,-0.159201E-02, 0.926958E-04,-0.208439E-05
     +      ,-0.684096E+01, 0.370364E+01,-0.786752E+00, 0.822670E-01
     +      ,-0.424710E-02, 0.867980E-04,-0.200856E+01, 0.129573E+01
     +      ,-0.306533E+00, 0.343682E-01,-0.185931E-02, 0.392432E-04
     +      , 0.127538E+01,-0.515705E+00, 0.820644E-01,-0.641997E-02
     +      , 0.245913E-03,-0.365789E-05, 0.115792E+00,-0.463143E-01
     +      , 0.725442E-02,-0.556266E-03, 0.208049E-04,-0.300895E-06
     +      ,-0.271082E-01, 0.173949E-01,-0.452531E-02, 0.569405E-03
     +      ,-0.344856E-04, 0.803964E-06, 0.419855E-02,-0.277188E-02
     +      , 0.737658E-03,-0.939463E-04, 0.569748E-05,-0.131737E-06
     +      ,-0.318752E-03, 0.215144E-03,-0.579787E-04, 0.737972E-05
     +      ,-0.441485E-06, 0.994726E-08, 0.938233E-05,-0.651642E-05
     +      , 0.177303E-05,-0.224680E-06, 0.132080E-07,-0.288593E-09/
      DATA C2/-0.245667E-03, 0.833406E-04,-0.129217E-04, 0.915099E-06
     +      ,-0.247179E-07, 0.147696E-03,-0.498793E-04, 0.402375E-05
     +      , 0.989281E-07,-0.133378E-07,-0.737702E-02, 0.333057E-02
     +      ,-0.553141E-03, 0.402464E-04,-0.107977E-05,-0.641533E-02
     +      , 0.290113E-02,-0.477641E-03, 0.342008E-04,-0.900582E-06
     +      , 0.574303E-05, 0.908521E-04,-0.256900E-04, 0.239921E-05
     +      ,-0.741271E-07,-0.341260E-04, 0.971711E-05,-0.172031E-06
     +      ,-0.119455E-06, 0.704166E-08, 0.341740E-05,-0.775867E-06
     +      ,-0.653231E-07, 0.225605E-07,-0.114860E-08,-0.119391E-06
     +      , 0.194885E-07, 0.588959E-08,-0.127589E-08, 0.608247E-10/
      DATA AKSI,BETA,VE/2.51,0.99,0.00004/
+SELF,IF=BETHE.
      DATA C1/ 0.834459E-02, 0.443979E-02,-0.101420E-02, 0.963240E-04
     +      ,-0.409769E-05, 0.642589E-07, 0.464473E-02,-0.290378E-02
     +      , 0.547457E-03,-0.426949E-04, 0.137760E-05,-0.131050E-07
     +      ,-0.547866E-02, 0.156218E-02,-0.167352E-03, 0.101026E-04
     +      ,-0.427518E-06, 0.949555E-08,-0.406862E-02, 0.208317E-02
     +      ,-0.374766E-03, 0.317610E-04,-0.130533E-05, 0.211051E-07
     +      , 0.158941E-02,-0.385362E-03, 0.315564E-04,-0.734968E-06
     +      ,-0.230387E-07, 0.971174E-09, 0.467219E-03,-0.154047E-03
     +      , 0.202400E-04,-0.132438E-05, 0.431474E-07,-0.559750E-09
     +      ,-0.220958E-02, 0.100698E-02,-0.596464E-04,-0.124653E-04
     +      , 0.142999E-05,-0.394378E-07, 0.477447E-03,-0.184952E-03
     +      ,-0.152614E-04, 0.848418E-05,-0.736136E-06, 0.190192E-07
     +      ,-0.552930E-04, 0.209858E-04, 0.290001E-05,-0.133254E-05
     +      , 0.116971E-06,-0.309716E-08, 0.212117E-05,-0.103884E-05
     +      ,-0.110912E-06, 0.655143E-07,-0.613013E-08, 0.169207E-09/
      DATA C2/ 0.301125E-04,-0.461920E-04, 0.871485E-05,-0.622331E-06
     +      , 0.151800E-07,-0.478023E-04, 0.247530E-04,-0.381763E-05
     +      , 0.232819E-06,-0.494487E-08,-0.336230E-04, 0.223822E-04
     +      ,-0.384583E-05, 0.252867E-06,-0.572599E-08, 0.105335E-04
     +      ,-0.567074E-06,-0.216564E-06, 0.237268E-07,-0.658131E-09
     +      , 0.282025E-05,-0.671965E-06, 0.565858E-07,-0.193843E-08
     +      , 0.211839E-10, 0.157544E-04,-0.304104E-05,-0.624410E-06
     +      , 0.120124E-06,-0.457445E-08,-0.188222E-05,-0.407118E-06
     +      , 0.375106E-06,-0.466881E-07, 0.158312E-08, 0.945037E-07
     +      , 0.564718E-07,-0.319231E-07, 0.371926E-08,-0.123111E-09/
      DATA AKSI,BETA,VE/2.10,1.00,0.001/
+SELF.
      DATA CORFAC/0.805485E-10/
C.
C.    ------------------------------------------------------------------
C.
      GBRELE=0.
      IF(BCUT.LE.0.) GOTO 99
      IF(T.GT.100.) THEN
          TT=100.
      ELSE
          TT=T
      ENDIF
      E=TT+EMASS
      EC=BCUT
      IF(BCUT.GT.TT) EC=TT
C
      X=LOG(TT/EMASS)
      Y=LOG(EC/(E*VE))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
             ENDIF
             XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
      IF(T.GT.100.) S=S*T/TT
C
+SELF,IF=-BETHE.
      CORR=1./(1.+CORFAC*DENS*Z*E*E/(A*EC*EC))
+SELF,IF=BETHE.
      CORR=1.
+SELF.
      FAC=ZZ*(ZZ+AKSI)*E*E*(EC*CORR/TT)**BETA/(E+EMASS)
      IF(FAC.LE.0.) GOTO 99
C
      GBRELE=FAC*S
C
  99  RETURN
      END
+DECK,GBRELM
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GBRELM(Z,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  To calculate energy loss due to soft muon BREMSSTRAHLUNG.     *
C.    *                                                                *
C.    *    ==>Called by : GBRELA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
      DIMENSION C(52),D(28)
      DATA C/0.615548E-07,-0.858333E-07, 0.148015E-06,-0.220289E-07
     +      , 0.162987E-08,-0.305945E-10, 0.170957E-06,-0.272156E-06
     +      , 0.610418E-07,-0.768052E-08, 0.391729E-09,-0.104624E-10
     +      , 0.412993E-07,-0.373362E-08,-0.110920E-08, 0.571124E-09
     +      ,-0.477538E-10, 0.169448E-11, 0.323774E-08,-0.305497E-08
     +      , 0.758138E-09,-0.121885E-09, 0.857707E-11,-0.253742E-12
     +      , 0.133703E-08,-0.676756E-09, 0.147782E-09,-0.136039E-10
     +      , 0.556182E-12,-0.634277E-14, 0.847418E-10,-0.288608E-10
     +      , 0.224661E-11, 0.514422E-13,-0.122288E-13, 0.333673E-15
     +      ,-0.153886E-08, 0.100179E-08,-0.149457E-09, 0.734506E-11
     +      ,-0.507324E-09, 0.146362E-09,-0.126608E-10, 0.778818E-13
     +      ,-0.161333E-10,-0.199252E-11, 0.100270E-11,-0.347404E-13
     +      ,-0.465077E-11, 0.121078E-11,-0.131113E-12, 0.431515E-14/
      DATA D/-0.389616E-05,-0.130106E-09, 0.101380E-04, 0.259032E-07
     +      ,-0.816804E-07,-0.961867E-05,-0.603907E-08, 0.192015E-07
     +      , 0.772670E-08, 0.459337E-05, 0.761272E-09,-0.251956E-08
     +      , 0.483037E-10,-0.289802E-08,-0.117497E-05,-0.484372E-10
     +      , 0.155476E-09,-0.218604E-10, 0.812047E-10, 0.380265E-09
     +      , 0.154338E-06, 0.118357E-11,-0.367778E-11, 0.119199E-11
     +      ,-0.273719E-11,-0.201239E-11,-0.221931E-10,-0.818793E-08/
C
      DATA AKSI,BETA,DEL/2.20,1.24,0.58/
C
      DATA CONMX/0.130653/
C        CONMX=0.75*SQRT(2.7182...)*EMMU
C.
C.    ------------------------------------------------------------------
C.
      GBRELM=0.
      IF(BCUT.LE.0.) GOTO 99
C
      Z3=Z**0.333333
      E=T+EMMU
      ECMAX=E-CONMX*Z3
      X=LOG(E/EMMU)
      IF(BCUT.GE.ECMAX) GOTO 60
C
      Y=LOG(BCUT/EMMU)
      S=0.
      YY=1.
      DO 30 I=1,6
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      SS=0.
      YY=1.
      DO 50 I=1,4
         XX=1.
         DO 40 J=1,4
            K=4*I+J+32
            SS=SS+C(K)*XX*YY
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=E*(BCUT/E)**BETA
      FAC=Z*(Z+AKSI*(1.+DEL*LOG(Z)))*FAC
      GBRELM=FAC*S
      GOTO 99
C
  60  Y=Z3
      S=D(1)
      K=1
      XX=1.
      YPX=Y/X
      DO 80 I=1,6
         II=I+1
         XX=XX*X
         XXYY=XX
         DO 70 J=1,II
            K=K+1
            S=S+D(K)*XXYY
            XXYY=XXYY*YPX
  70     CONTINUE
  80  CONTINUE
      IF(S.LE.0.) GOTO 99
C
      FAC=Z*(Z+1.)*ECMAX
      IF(FAC.LE.0.) GOTO 99
      GBRELM=FAC*S
C
  99  RETURN
      END
+DECK,GBREME.
*CMZ :  3.21/03 02/08/94  19.37.36  by  S.Ravndal
*-- Author :
      SUBROUTINE GBREME
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates discrete hard BREMSSTRAHLUNG by electrons.          *
C.    *                                                                *
C.    *  The secondary photon energy is sampled from a                 *
C.    *  parametrization of the bremsstrahlung calculation of          *
C.    *  Seltzer and Berger (NIM B12,p.95(1985)) for electron          *
C.    *  energies 1 keV - 10 GeV . For higher energies the             *
C.    *  parametrization agrees with the screened Bethe-Heitler        *
C.    *  bremsstrahlung spectrum.Migdal corrections are applied        *
C.    *      by default. The routine works ( together                  *
C.    *  with the routines GBRELE and GBRSGE ) without the Migdal      *
C.    *  corrections using the Patchy switch +USE,BETHE.               *
C.    *                                                                *
C.    *  NOTE :                                                        *
C.    *      BCUTE is the cut-off energy above which the photon energy *
C.    *      spectrum is generated.                                    *
C.    *                                                                *
C.    *    ==>Called by : GTELEC                                       *
C.    *       Authors    L.Urban    29/10/93 *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCJLOC
+SEQ,GCONSP
+SEQ,GCTRAK
+SEQ,GCKING
+SEQ,GCMATE
+SEQ,GCCUTS
      DIMENSION RNDM(2)
      PARAMETER (CORFAC=0.805485E-10)
      PARAMETER (TLIM=0.000999)
      PARAMETER  (
     +AL00=-0.205398E+01,AL01= 0.238815E-01,AL02= 0.525483E-03,
     +AL10=-0.769748E-01,AL11=-0.691499E-01,AL12= 0.222453E-02,
     +AL20= 0.406463E-01,AL21=-0.101281E-01,AL22= 0.340919E-03,
     +A10 = 0.467733E+01,A11 =-0.619012E+00,A12 = 0.202225E-01,
     +A20 =-0.734101E+01,A21 = 0.100462E+01,A22 =-0.320985E-01,
     +A30 = 0.293119E+01,A31 =-0.403761E+00,A32 = 0.125153E-01,
     +BL00= 0.104133E+01,BL01=-0.943291E-02,BL02=-0.454758E-03,
     +BL10= 0.119253E+00,BL11= 0.407467E-01,BL12=-0.130718E-02,
     +BL20=-0.159391E-01,BL21= 0.727752E-02,BL22=-0.194405E-03,
     +B10 = 0.423071E+01,B11 =-0.610995E+00,B12 = 0.195531E-01,
     +B20 =-0.712527E+01,B21 = 0.969160E+00,B22 =-0.274255E-01,
     +B30 = 0.269925E+01,B31 =-0.363283E+00,B32 = 0.955316E-02)
C.    ------------------------------------------------------------------
C.
C             Ensure cut-off avoids infra-red catastrophe.
C
      IF (GEKIN.LE.BCUTE) GO TO 30
      KCASE=NAMEC(9)
C
*******************************>  Z3=Q(JPROB+2)
      Z3=(Z*(Z+1.))**0.3333333
      IF(Z3.LE.0.)GO TO 30
      Z32=Z3**2
      EEL1   = GETOT
      XC=BCUTE/GEKIN
      ALXC=LOG(XC)
      U=LOG(GEKIN/EMASS)
      U2=U**2
      V=LOG(Z)
*
      IF(GEKIN.LE.TLIM) THEN
         AL0=AL00+AL01*Z3+AL02*Z32
         AL1=AL10+AL11*Z3+AL12*Z32
         AL2=AL20+AL21*Z3+AL22*Z32
         AL=AL0+AL1*U+AL2*U2
         BL0=BL00+BL01*Z3+BL02*Z32
         BL1=BL10+BL11*Z3+BL12*Z32
         BL2=BL20+BL21*Z3+BL22*Z32
         BL=BL0+BL1*U+BL2*U2
         GMAX=1.+AL*XC+BL*XC**2
         IF(GEKIN.LT.0.0001) THEN
            G1=1.+AL+BL
            IF(G1.GT.GMAX) GMAX=G1
            X0=-BL/(2.*AL)
            IF((XC.LT.X0).AND.(X0.LT.1.)) THEN
               G0=1.+AL*X0+BL*X0**2
               IF(G0.GT.GMAX) GMAX=G0
            ENDIF
         ENDIF
      ELSE
         U3=U2*U
         A1=A10+A11*Z3+A12*Z32
         A2=A20+A21*Z3+A22*Z32
         A3=A30+A31*Z3+A32*Z32
         AH=1.+A1/U+A2/U2+A3/U3
         B1=B10+B11*Z3+B12*Z32
         B2=B20+B21*Z3+B22*Z32
         B3=B30+B31*Z3+B32*Z32
         BH=0.75+B1/U+B2/U2+B3/U3
*
         F=4*V-0.55*V**2
         DEL0=136.*EMASS/(Z3*EEL1)
         EPC=XC*GEKIN/EEL1
         DC=DEL0*EPC/(1.-EPC)
         CC=42.392-F
*
         IF(DC.LE.1.) THEN
            DC2=DC**2
            F1=(42.392-7.796*DC+1.961*DC2-F)/CC
            F2=(41.734-6.484*DC+1.250*DC2-F)/CC
         ELSE
            F1=(42.24-8.368*LOG(DC+0.952)-F)/CC
            IF(F1.LT.0.) F1=0.
            F2=F1
         ENDIF
*
         GMAX=(1.-AH*EPC)*F1+BH*EPC**2*F2
      ENDIF
*
      CORR0=CORFAC*DENS*Z/A
      EPM=GEKIN/EEL1
      SC0=1.+CORR0/(EPM*EPM)
*
*     sample photon energy  ( according to 1/Ephoton)
*
   10 CALL GRNDM(RNDM,2)
*
      X=EXP(RNDM(1)*ALXC)
      EP=X*GEKIN/EEL1
*
*     Migdal correction for Ephoton->0. or no correction (Bethe)
*
+SELF,IF=-BETHE.
      CORR=SC0/(1.+CORR0/(EP*EP))
+SELF,IF=BETHE.
      CORR=1.
+SELF.
*
*     calculate rejection function g(x)
*
      IF(GEKIN.LE.TLIM) THEN
         G=1.+AL*X+BL*X**2
      ELSE
         D=DEL0*EP/(1.-EP)
         IF(D.LE.1.) THEN
            D2=D**2
            F1=(42.392-7.796*D+1.961*D2-F)/CC
            F2=(41.734-6.484*D+1.250*D2-F)/CC
         ELSE
            F1=(42.24-8.368*LOG(D+0.952)-F)/CC
            IF(F1.LT.0.) F1=0.
            F2=F1
         ENDIF
         G=(1.-AH*EP)*F1+BH*EP**2*F2
      ENDIF
      G=G*CORR/GMAX
      IF(RNDM(2).GT.G) GOTO 10
*
*     photon energy is sampled according to the Seltzer-Berger spectrum
*
      EGAMMA=EEL1*EP
C
C        CUT ON ENERGY THRESHOLD ?
C
      IF((IBREM.NE.1).OR.(EGAMMA.LE.CUTGAM)) THEN
         DESTEP = DESTEP + EGAMMA
         GO TO 20
      ENDIF
C
C             Generate emitted photon angles with respect to a Z-axis
C             defined along parent track. PHI is generated isotropically
C             and THETA is assigned a universal angular distribution
C
      EMASS1 = EMASS
      THETA  = GBTETH(EEL1, EMASS1, EP)*EMASS/EEL1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      NGKINE = NGKINE + 1
      GKIN(1,1)=EGAMMA*SINTH*COSPHI
      GKIN(2,1)=EGAMMA*SINTH*SINPHI
      GKIN(3,1)=EGAMMA*COSTH
      GKIN(4,1)=EGAMMA
      GKIN(5,1)=1.
      TOFD(1)  =0.
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
C             Rotate photon into GEANT system
C
      CALL GVROT(VECT(4),GKIN)
C
C             Correct track for lost energy
C
   20 CONTINUE
      GEKIN = GEKIN - EGAMMA
      GETOT = GEKIN + EMASS
      VECT(7)=SQRT (ABS((GETOT+EMASS)*GEKIN))
      CALL GEKBIN
C
C             Update probabilities
C
   30 CALL GRNDM(RNDM,1)
      ZINTBR=-LOG(RNDM(1))
C
      END
+DECK,GBREMM
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GBREMM
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates discrete hard BREMSSTRAHLUNG by muons.              *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GTMUON                                       *
C.    *       Author     L.Urban  *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCONSP
+SEQ,GCTRAK
+SEQ,GCJLOC
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCCUTS
      DIMENSION RNDM(2)
C.
C.    ------------------------------------------------------------------
C.
C             Ensure cut-off avoids infra-red catastrophe.
C
      EEM1   = GETOT
      IF (GEKIN.LE.BCUTM) GO TO 900
      KCASE  = NAMEC(9)
C
      C1   = Q(JPROB+31)
      C2   = Q(JPROB+32)
      C3   = Q(JPROB+33)
      VC   = BCUTM/EEM1
      VM   = 1.-C3/EEM1
      IF(VM.LE.0.)GO TO 900
      CREJ = C2/EEM1
C
  50  CALL GRNDM(RNDM,2)
      R    = RNDM(1)
      V    = VC*(VM/VC)**R
C
C             Compute rejection function
C
      V1   = 1.-V
      F1   = C1-LOG(1.+CREJ*V/V1)
      SCREJ= (V1+0.75*V*V)*F1/C1
      IF(RNDM(2).GT.SCREJ)GO TO 50
C
C             Photon energy
C
      EGAMMA=EEM1*V
C
C        CUT ON ENERGY THRESHOLD ?
C
      IF((IBREM.NE.1).OR.(EGAMMA.LE.CUTGAM)) THEN
          NGKINE = 0
          DESTEP = DESTEP + EGAMMA
          GO TO 800
      ENDIF
C
C             Generate emitted photon angles with respect to a Z-axis
C             defined along parent track. PHI is generated isotropically
C             and THETA is assigned a universal angular distribution
C
      THETA  = GBTETH(EEM1, AMASS, V)*AMASS/EEM1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      NGKINE = 1
      GKIN(1,1)=EGAMMA*SINTH*COSPHI
      GKIN(2,1)=EGAMMA*SINTH*SINPHI
      GKIN(3,1)=EGAMMA*COSTH
      GKIN(4,1)=EGAMMA
      GKIN(5,1)=1.
      TOFD(1)  =0.
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
C             Rotate photon into GEANT system
C
      CALL GVROT(VECT(4),GKIN)
C
C             Correct track for lost energy
C
  800 CONTINUE
      GEKIN = GEKIN - EGAMMA
      GETOT = GEKIN + AMASS
      VECT(7)=SQRT (ABS((GETOT+AMASS)*GEKIN))
      CALL GEKBIN
C
C             Update probabilities
C
  900 CALL GRNDM(RNDM,1)
      ZINTBR=-LOG(RNDM(1))
      SLBREM=SLENG
      STEPBR=BIG
C
      END
+DECK,GBRSGA
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GBRSGA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) electron BREMSSTRAHLUNG.                   *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCMATE
+SEQ,GCONSP
+SEQ,GCJLOC
+SEQ,GCCUTS
+SEQ,GCMULO
C.
C.    ------------------------------------------------------------------
C.
C=======>                 Electrons & Positrons
C
      SIG=0.
      IF(Z.LT.1.)GO TO 20
C
C             Calculate mean free path using total cross-section
C             formula of L.Urban (see Write-up)
C
      T      = ELOW(IEKBIN)
      IF(JMIXT.EQ.0)THEN
C
C           element
C
         SIG=GBRSGE(Z,T,BCUTE)
         SIG=AVO*DENS*SIG/A
      ELSE
C
C           compound/mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         SIG=0.
         DO 10 I=1,NLM
            J   = JMIXT+NLM+I
            AA  = Q(J-NLM)
            ZZ  = Q(J)
            WMAT= Q(J+NLM)
            S   = GBRSGE(ZZ,T,BCUTE)
            S   = WMAT*S/AA
            SIG = SIG+AVO*DENS*S
  10     CONTINUE
      ENDIF
C
  20  IF(SIG.GT.0.)THEN
         Q(JBREM+IEKBIN)=1./SIG
         Q(JBREM+NEK1+IEKBIN)=1./(SIG*GBFSIG(T,BCUTE))
      ELSE
         Q(JBREM+IEKBIN)=BIG
         Q(JBREM+NEK1+IEKBIN)=BIG
      ENDIF
C
C=======>                 Muons
C
      SIG=0.
      IF(Z.LT.1.)GO TO 40
C
C             Calculate mean free path using total cross-section
C             formula of L.Urban (see Write-up)
C
      IF(T.LT.1.)GO TO 40
      IF(JMIXT.EQ.0)THEN
C
C           element
C
         SIG=GBRSGM(Z,T,BCUTM)
         SIG=AVO*DENS*SIG/A
      ELSE
C
C           compound/mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         SIG=0.
         DO 30 I=1,NLM
            J   = JMIXT+NLM+I
            AA  = Q(J-NLM)
            ZZ  = Q(J)
            WMAT= Q(J+NLM)
            S   = GBRSGM(ZZ,T,BCUTM)
            S   = WMAT*S/AA
            SIG = SIG+AVO*DENS*S
  30     CONTINUE
      ENDIF
C
  40  IF(SIG.GT.0.)THEN
         Q(JBREM+IEKBIN+2*NEK1)=1./SIG
      ELSE
         Q(JBREM+IEKBIN+2*NEK1)=BIG
      ENDIF
C
      END
+DECK,GBRSGE.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GBRSGE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) electron BREMSSTRAHLUNG.                   *
C.    *         (SIG in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRSGA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCMATE
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      SAVE C
+SELF,IF=-BETHE.
      PARAMETER (AKSI=1.80,ALFA=0.98,VS=0.0001)
      DATA C1/ 0.430748E-02, 0.576058E-02,-0.122564E-02, 0.114843E-03
     +      ,-0.489452E-05, 0.795991E-07, 0.326746E-02,-0.132872E-02
     +      , 0.217197E-03,-0.179769E-04, 0.766114E-06,-0.125603E-07
     +      , 0.326452E-02,-0.175331E-02, 0.415488E-03,-0.507652E-04
     +      , 0.297569E-05,-0.651741E-07, 0.847189E-03,-0.433923E-03
     +      , 0.116672E-03,-0.166799E-04, 0.110237E-05,-0.263383E-07
     +      , 0.846052E-04,-0.415764E-04, 0.129610E-04,-0.212844E-05
     +      , 0.152871E-06,-0.384393E-08, 0.300838E-05,-0.136833E-05
     +      , 0.507296E-06,-0.943623E-07, 0.720305E-08,-0.187210E-09
     +      , 0.448230E-01,-0.210048E-01, 0.379434E-02,-0.328431E-03
     +      , 0.136710E-04,-0.220593E-06,-0.539248E-02, 0.330244E-02
     +      ,-0.733726E-03, 0.732312E-04,-0.336810E-05, 0.583913E-07
     +      ,-0.106983E-02, 0.378021E-03,-0.384854E-04, 0.978156E-06
     +      , 0.410622E-07,-0.174250E-08,-0.117501E-04,-0.983887E-05
     +      , 0.239644E-05,-0.190104E-06, 0.619226E-08,-0.680932E-10/
      DATA C2/ 0.168074E-03,-0.934609E-04, 0.141293E-04,-0.854216E-06
     +      , 0.183287E-07, 0.932144E-04,-0.234926E-04, 0.136656E-05
     +      , 0.351109E-07,-0.330189E-08, 0.174523E-04, 0.253854E-05
     +      ,-0.171643E-05, 0.183074E-06,-0.566331E-08, 0.111970E-05
     +      , 0.112776E-05,-0.386924E-06, 0.367597E-07,-0.108504E-08
     +      , 0.171604E-07, 0.738801E-07,-0.218761E-07, 0.199032E-08
     +      ,-0.576173E-10,-0.105531E-03, 0.362995E-04,-0.433334E-05
     +      , 0.207664E-06,-0.330250E-08,-0.168293E-05,-0.773204E-06
     +      , 0.227974E-06,-0.159385E-07, 0.321958E-09, 0.167046E-05
     +      ,-0.440761E-06, 0.396377E-07,-0.151053E-08, 0.215624E-10/
+SELF,IF=BETHE.
      PARAMETER (AKSI=1.80,ALFA=1.00,VS=0.0001)
      DATA C1/ 0.111394E-01, 0.138592E-02,-0.274910E-03, 0.198389E-04
     +      ,-0.472291E-06,-0.668760E-09, 0.839876E-02,-0.449619E-02
     +      , 0.917722E-03,-0.874992E-04, 0.390015E-05,-0.653499E-07
     +      , 0.464718E-02,-0.260321E-02, 0.582582E-03,-0.631769E-04
     +      , 0.325801E-05,-0.638109E-07, 0.101243E-02,-0.532089E-03
     +      , 0.129100E-03,-0.161260E-04, 0.958116E-06,-0.212606E-07
     +      , 0.926006E-04,-0.455288E-04, 0.124755E-04,-0.182510E-05
     +      , 0.122078E-06,-0.294182E-08, 0.308111E-05,-0.134712E-05
     +      , 0.436230E-06,-0.751770E-07, 0.552327E-08,-0.140541E-09
     +      , 0.292552E-02,-0.830719E-03, 0.210705E-04, 0.103750E-04
     +      ,-0.953318E-06, 0.236453E-07, 0.110907E-02,-0.219463E-03
     +      , 0.128517E-04,-0.554575E-06, 0.507378E-07,-0.182214E-08
     +      ,-0.639866E-03, 0.209918E-03,-0.250183E-04, 0.138030E-05
     +      ,-0.358845E-07, 0.366305E-09, 0.300095E-04,-0.133668E-04
     +      , 0.198606E-05,-0.133100E-06, 0.414062E-08,-0.485929E-10/
      DATA C2/ 0.938677E-04,-0.613470E-04, 0.981984E-05,-0.646289E-06
     +      , 0.150731E-07, 0.331764E-04, 0.447248E-05,-0.313021E-05
     +      , 0.329777E-06,-0.997210E-08, 0.876484E-08, 0.110042E-04
     +      ,-0.313406E-05, 0.280040E-06,-0.794116E-08,-0.103097E-05
     +      , 0.220550E-05,-0.569158E-06, 0.491359E-07,-0.136987E-08
     +      ,-0.781963E-07, 0.123162E-06,-0.302825E-07, 0.255485E-08
     +      ,-0.702300E-10,-0.193213E-03, 0.640349E-04,-0.720586E-05
     +      , 0.329673E-06,-0.514682E-08, 0.362138E-04,-0.142783E-04
     +      , 0.184063E-05,-0.967983E-07, 0.179386E-08, 0.496130E-06
     +      , 0.210105E-06,-0.538512E-07, 0.372388E-08,-0.812734E-10/
+SELF.
C.
C.    ------------------------------------------------------------------
C.
      GBRSGE=0.
      IF(BCUT.LE.0.) GOTO 99
      E=T+EMASS
      IF(BCUT.GE.T) GOTO 99
      EC=BCUT
C
      X=LOG(E/EMASS)
      Y=LOG(E*VS/EC)
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=ZZ*(ZZ+AKSI)*E*E*(LOG(T/EC))**ALFA/(T*(E+EMASS))
      IF(FAC.LE.0.) GOTO 99
C
      GBRSGE=FAC*S
C
  99  RETURN
      END
+DECK,GBRSGM
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GBRSGM(Z,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) muon BREMSSTRAHLUNG.                       *
C.    *         (SIG in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRSGA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
      DIMENSION C(52)
      SAVE C
      PARAMETER (AKSI=2.30,ALFA=1.06,GAM=0.63)
C
      PARAMETER (CONMX=0.130653)
C       CONMX=0.75*SQRT(2.7182...)*EMMU
      DATA C/ 0.949313E-07,-0.819600E-07, 0.529075E-07,-0.832023E-08
     +      , 0.539299E-09,-0.127042E-10,-0.165784E-08,-0.307788E-07
     +      , 0.977905E-08,-0.113658E-08, 0.574481E-10,-0.106221E-11
     +      , 0.968339E-09,-0.108640E-08,-0.177634E-09, 0.889497E-10
     +      ,-0.876878E-11, 0.264303E-12, 0.216263E-08,-0.152680E-08
     +      , 0.380989E-09,-0.455274E-10, 0.264172E-11,-0.596016E-13
     +      , 0.444927E-09,-0.272978E-09, 0.645634E-10,-0.748783E-11
     +      , 0.424890E-12,-0.940837E-14, 0.162289E-10,-0.362486E-11
     +      ,-0.576652E-12, 0.211269E-12,-0.185482E-13, 0.522065E-15
     +      ,-0.215590E-09, 0.112204E-09,-0.819133E-11, 0.145128E-12
     +      ,-0.206029E-09, 0.559940E-10,-0.483350E-11, 0.134252E-12
     +      ,-0.368469E-10, 0.999457E-11,-0.904967E-12, 0.272717E-13
     +      ,-0.303446E-11, 0.853429E-12,-0.785466E-13, 0.236435E-14/
C.
C.    ------------------------------------------------------------------
C.
      GBRSGM=0.
      IF(BCUT.GE.T) GOTO 99
C
      E=T+EMMU
      ECMAX=E-CONMX*Z**0.333333
      IF(BCUT.GE.ECMAX) GOTO 99
      X=LOG(E/EMMU)
      Y=LOG(BCUT/EMMU)
C
      S=0.
      YY=1.
      DO 30 I=1,6
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      SS=0.
      YY=1.
      DO 50 I=1,4
         XX=1.
         DO 40 J=1,4
            K=4*I+J+32
            SS=SS+C(K)*XX*YY
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=LOG(ECMAX/BCUT)
      IF(FAC.LE.0.) GOTO 99
      FAC=Z*(Z+AKSI*(1.+GAM*LOG(Z)))*FAC**ALFA
      GBRSGM=FAC*S
C
  99  RETURN
      END
+DECK,GBTETH.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      REAL FUNCTION GBTETH(ENER,PARTM,EFRAC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Universal distribution function for the Bremsstrahlung       *
C.    *   and pair production angles. This function approximates       *
C.    *   the real distribution function which can be found in         *
C.    *   Yung-Su Tsai: Rev. Mod. Phys. 46,815(1974)                   *
C.    *     +erratum  : Rev. Mod. Phys. 49,421(1977)                   *
C.    *                                                                *
C.    *   Called by : GBREME, GBREMM, GPAIRG                           *
C.    *   Authors   : L.Urban                                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP.
+SEQ,GCMATE.
      DIMENSION RNDM(3)
      PARAMETER (ALFA=0.625)
*     ----------------------------------------------------------
* GEANT 3.15
*     GBTETH=1.
*     GOTO 999
* Angular distribution with d=const
*     D=27.
* Angular distribution with d=d(Z,E,y)
      D=0.13*(0.8+1.3/Z)*(100.+1./ENER)*(1.+EFRAC)
*     -------------------------------------------------------------
*
      W1=9./(9.+D)
      UMAX=ENER*PI/PARTM
*
10    CALL GRNDM(RNDM,3)
*
      IF(RNDM(1).LE.W1) THEN
         BETA=ALFA
      ELSE
         BETA=3.*ALFA
      ENDIF
*
      U=-(LOG(RNDM(2)*RNDM(3)))/BETA
*
*     cut : theta should be .LE. PI  !!
*     this condition depend on E in the case of d=const too!!!!!
*
      IF(U.GE.UMAX) GOTO 10
*
      GBTETH=U
*
 999  CONTINUE
      END
+DECK,gcbrem.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GCBREM(T)
C.    ******************************************************************
C.    *                                                                *
C.    *  It calculates the ratio of positron to electron               *
C.    *       bremsstrahlung energy loss.                              *
C.    *                                                                *
C.    *  Input:kinetic energy in GeV                                   *
C.    *  Output: ratio of positron to electron brems energy loss       *
C.    *                                                                *
C.    *  ( The ratio is calculated from a function fitted to the       *
C.    *    results of L.Kim et al.,PHYS.REV.A33,3002(1986)    )        *
C.    *                                                                *
C.    *  Author   L. Urban                                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCMATE
+SEQ,GCONSP
      PARAMETER (AA=7522100.,A1=0.415,A3=0.0021,A5=0.00054)
C.
      CFAC=0.
      IF(Z.LE.0.) GOTO 10
      X=LOG(AA*T/Z**2)
*
      IF(X.LE.-8.) GOTO 10
*
      IF(X.GE.+9.) THEN
         CFAC=1.
      ELSE
         W=A1*X+A3*X**3+A5*X**5
         CFAC=0.5+ATAN(W)/PI
      ENDIF
*
   10 GCBREM = CFAC
*
      END
+DECK,GCOEFF.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GCOEFF
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the coefficients for the energy loss               *
C.    *     interpolation                                              *
C.    *     There are 4 tables : electron,positron,muon,proton         *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author      F.Carminati *********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCJLOC
+SEQ,GCMULO
+SEQ,GCONSP
+SEQ,GCMATE
+SELF, IF=-SINGLE
      DOUBLE PRECISION CX1,CX2,CX3,CY1,CY2,CY3,CDEN1,CDEN2,CDEN3
      DOUBLE PRECISION ACOEFF,BCOEFF,CCOEFF,XRAT,CCOEF1,CCOEF3
      DOUBLE PRECISION SQEPSM,CFACT
      PARAMETER (EPSMAC=1E-6)
+SELF,IF=SINGLE
      PARAMETER (EPSMAC=1E-11)
+SELF
*
      SQEPSM = MAX(1.,91./NEK1)*10.*SQRT(EPSMAC)
      DO 10 IEKBIN=1,NEK1-2
*
         I1 = IEKBIN
         I2 = I1 + 1
         I3 = I2 + 1
         CY1 = ELOW(I1)
         CY2 = ELOW(I2)
         CY3 = ELOW(I3)
         IECOEF = 3*(IEKBIN-1)
*
* *** Electrons
*
         JRANG = LQ(JMA-15)
         JCOEF = LQ(JMA-17)
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
* *** Positons
*
         JRANG = LQ(JMA-15) + NEK1
         JCOEF = LQ(JMA-17) +3*NEK1
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
* *** Muons
*
         JRANG = LQ(JMA-16)
         JCOEF = LQ(JMA-18)
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
* *** Protons
*
         JRANG = LQ(JMA-16) + NEK1
         JCOEF = LQ(JMA-18) +3*NEK1
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
   10 CONTINUE
*
      END
+DECK,GCOMP
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GCOMP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates photon-electron COMPTON scattering.                 *
C.    *                                                                *
C.    *  The scattered photon energy is sampled using the quantum-     *
C.    *  mechanical KLEIN-NISHINA formula. For this, the random       *
C.    *  number techniques of BUTCHER and MESSEL(NUC. PHYS.20(1960),   *
C.    *  15) are employed.                                             *
C.    *  NOTE :                                                        *
C.    *  (1) Effects due to binding of atomic electrons are            *
C.    *      ignored(recoil electron energy assumed large compared     *
C.    *      with binding energy).                                     *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCPHYS
+SEQ,GCTRAK
+SEQ,GCKING
+SEQ,GCONSP
+SEQ,GCCUTS
      DIMENSION PGAM(3)
      REAL RNDM(5)
      LOGICAL ROTATE
C.
C.    ------------------------------------------------------------------
C.
      KCASE  = NAMEC(7)
      EGAM1  = VECT(7)
      EZERO  = EGAM1/EMASS
      EMINI  = 1.+2.*EZERO
      EMIN   = 1./EMINI
      DSIG1  = LOG(EMINI)
      DSIG2  = 0.5*(1.-EMIN*EMIN)
      DSIGT  = DSIG1+DSIG2
C
C             Decide which part of F(E)=1/E+E to sample from.
C
   10 CALL GRNDM(RNDM,3)
      IF (DSIG1.LT.DSIGT*RNDM(1))THEN
C
C             Sample from F2(E) distribution.
C
         BRD    = RNDM(2)
         CALL GRNDM(RNDM(4),1)
         IF (EZERO.GE.(EZERO+1.)*RNDM(4))THEN
            CALL GRNDM(RNDM(5),1)
            BRD    = MAX(BRD,RNDM(5))
         ENDIF
C
         BR     = EMIN+(1.-EMIN)*BRD
      ELSE
         BR     = EMIN*EXP(DSIG1*RNDM(2))
      ENDIF
C
C             Scattered photon energy.
C
      EGAM2  = BR*EGAM1
C
C             Calculate rejection function G(E).
C
      T      = EMASS*(1.-BR)/EGAM2
      SINTH  = MAX(0.,T*(2.-T))
      REJ    = 1.0-(BR*SINTH)/(1.+BR*BR)
      IF (RNDM(3).GT.REJ)                        GO TO 10
C
C             Successful sampling of scattered photon.
C
C             CUTS ON ENERGY THRESHOLDS ?
C
      TEL     = EGAM1-EGAM2
      IF((EGAM2.LE.CUTGAM).AND.(TEL.LE.CUTELE)) THEN
         ISTOP = 2
         VECT(7) = 0.
         GEKIN = 0.
         GETOT = 0.
         NGKINE = 0.
         DESTEP = DESTEP + EGAM1
         RETURN
      ENDIF
C
C             Generate photon angles with respect to a Z-axis
C             defined along the parent photon.
C             PHI is generated isotropically
C
      SINTH  = SQRT(SINTH)
      COSTH  = 1.-T
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      PGAM(1) = EGAM2*SINTH*COSPHI
      PGAM(2) = EGAM2*SINTH*SINPHI
      PGAM(3) = EGAM2*COSTH
C
C             Momentum vector of recoil electron.
C
      NGKINE = 1
      EEL    = TEL + EMASS
      GKIN(1,1) = -PGAM(1)
      GKIN(2,1) = -PGAM(2)
      GKIN(3,1) = EGAM1-PGAM(3)
      GKIN(4,1)=EEL
      GKIN(5,1)=3
      TOFD(NGKINE)=0.
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
C             Rotate electron and scattered photon into GEANT system
C
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
      IF(ROTATE) THEN
         CALL GDROT(PGAM(1),COSTH,SINTH,COSPH,SINPH)
         CALL GDROT(GKIN,COSTH,SINTH,COSPH,SINPH)
      ENDIF
C
C             Correct photon for energy lost and scattered angle
C
      DO 60 I=1,3
   60 VECT(I+3) = PGAM(I)/EGAM2
      VECT(7) = EGAM2
      GETOT = EGAM2
      GEKIN = EGAM2
      CALL GEKBIN
C
C              Stop electron ?
C
      IF((ICOMP.NE.1).OR.(TEL.LE.CUTELE)) THEN
         NGKINE = 0
         DESTEP = DESTEP + TEL
      ENDIF
C
C             Update probabilities
C
      CALL GRNDM(RNDM,1)
      ZINTCO=-LOG(RNDM(1))
C
      END
+DECK,GCOMPI
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GCOMPI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for COMPTON scattering.                                       *
C.    *                                                                *
C.    *  The total cross-section of L.Urban is used to estimate the    *
C.    *  photon mean free path.                                        *
C.    *    It gives a good description of the data from 10KeV to       *
C.    *    100/Z GeV                                                   *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, L.Urban  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,GCMATE
+SEQ,GCJLOC
+SEQ,GCMULO
      DIMENSION PCOMP(12),P(4)
      DATA AC,BC,CC/20.,230.,440./
      DATA PCOMP/ 0.27965,-0.18300,0.67527E+1,-0.19798E+2,
     +            0.19756E-4,-0.10205E-1,-0.73913E-1,0.27079E-1,
     +           -0.39178E-6,0.68241E-4,0.60480E-4,0.30274E-3/
      DATA PI2R2I/2.004275/
C.
C.    ------------------------------------------------------------------
C.
C             Energy cut-off above which we ignore COMPTON scattering.
C
      SIG=0.
      IF(Z.LT.1.)GO TO 90
      EGAM   = ELOW(IEKBIN)
      X=EGAM/EMASS
      IF(EGAM.GT.(100./Z))GO TO 90
      X2=X*X
      JPROB=LQ(JMA-4)
C
      DO 20 I=1,4
         C=1.
         P(I)=0.
         DO 10 J=1,3
            JJ=4*J+I-4
            P(I)=P(I)+C*PCOMP(JJ)
            C=C*Z
  10     CONTINUE
  20  CONTINUE
C
      SIG=P(1)*LOG(1.+2.*X)/X
      SIG=SIG+(P(2)+P(3)*X+P(4)*X2)/(1.+AC*X+BC*X2+CC*X2*X)
      SIG=PI2R2I*Q(JPROB+17)*SIG
C
  90  IF(SIG.GT.0.)THEN
         Q(JCOMP+IEKBIN)=1./SIG
      ELSE
         Q(JCOMP+IEKBIN)=BIG
      ENDIF
C
      END
+DECK,GDECA2
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDECA2(XM0,XM1,XM2,PCM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates two body decay process with isotropic angular       *
C.    *  distribution in CMS.                                          *
C.    *                                                                *
C.    *    ==>Called by : GDECAY                                       *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
      DIMENSION PCM(4,2)
      DIMENSION RNDM(2)
C.
C.    ------------------------------------------------------------------
C.
C             Generate first decay product in CMS.
C
      E1=(XM0*XM0+XM1*XM1-XM2*XM2)/(2.*XM0)
      P1=SQRT(ABS((E1-XM1)*(E1+XM1)))
C
C             Isotropic decay angular distribution.
C
      CALL GRNDM(RNDM,2)
      COSTH=2.*RNDM(1)-1.
      IF(ABS(COSTH).GE.1.0) THEN
         COSTH=SIGN(1.,COSTH)
         SINTH=0.
      ELSE
         SINTH=SQRT((1.-COSTH)*(1.+COSTH))
      ENDIF
      PHI=TWOPI*RNDM(2)
C
C             Polar co-ordinates to momentum components.
C
      PCM(1,1)=P1*SINTH*COS(PHI)
      PCM(2,1)=P1*SINTH*SIN(PHI)
      PCM(3,1)=P1*COSTH
      PCM(4,1)=E1
C
C             Generate second decay product.
C
      PCM(1,2)=-PCM(1,1)
      PCM(2,2)=-PCM(2,1)
      PCM(3,2)=-PCM(3,1)
      PCM(4,2)=SQRT(PCM(1,2)**2+PCM(2,2)**2+PCM(3,2)**2+XM2*XM2)
C
      END
+DECK,GDECA3
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDECA3(XM0,XM1,XM2,XM3,PCM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine simulates three-body decays in center-of-mass.  *
C.    *   Written by Jurgen Schukraft and Vincent Hedberg for R807.    *
C.    *   Adapted for Geant3 by Sverker Johansson (Aug-1987).          *
C.    *   (Quite extensive modifications; comments etc. are not always *
C.    *    consistent with the code anymore. )                         *
C.    *                                                                *
C.    *   As it is, the decay is done according to pure phase-space.   *
C.    *   There is code in the routine to properly treat K decays (V-A)*
C.    *   but it is not used. (Requires an additional parameter        *
C.    *   in the call, to tell which type of decay.)                   *
C.    *                                                                *
C.    *    ==>Called by : GDECAY                                       *
C.    *       Author    S. Johansson  *********                        *
C.    *                                                                *
C.    ******************************************************************
C.
***************************************************************
******* original name :                     *******************
******SUBROUTINE  D E C 3 B (ID,IP,K1,K2,K3)*******************
***************************************************************
C--------------------------------------------------------
C      O B S O L E T E   C O M M E N T   ! ! !
C     THIS ROUTINE SIMULATES THE THREE-BODY DECAYS OF:
C--------------------------------------------------------
C     ID = 1 : ETA   INTO  PI0 + PI0 + PI0     PHASE SPACE
C     ID = 2 : OMEGA INTO  PI0 + PI- + PI+        - " -
C     ID = 3 : ETAPR INTO  PI0 + PI0 + ETA        - " -
C     ID = 4 : K+/-  INTO  E+/- + PI0 + NU        (V-A)
C     ID = 5 : K0L   INTO  E+/- + PI-/+ + NU      - " -
C     ID = 6 : D     INTO  E   +  K  + NU      PHASE SPACE
C     ID = 7 : D     INTO  E   +  K* + NU         - " -
**      (** or any other decay; input is now masses
**          rather than process ID   S.J.
**          But the ID parameter could someday be useful
**          since it controls the non-phase-space code. ***)
C--------------------------------------------------------
C     THE OUTPUT COMMON BLOCK /LAB/ PLAB(20,J) IS FILLED
*       (** Not a common block anymore.  S.J. **)
C     ACCORDING TO THE ORDER OF THE SECONDARY PARTICLES
C     AS THEY APPEARE IN THE COMMENTS ABOVE. FOR EXAMPLE,
C     IN THE CASE OF ID=6 (D-MESON DECAY)
C     J = K1 IN PLAB(20,J) CORRESPONDS TO ELECTRON,
C     J = K2  -- " -- " -- " -- " --  K-MESON,
C     J = K3  -- " -- " -- " -- " --  NEUTRINO
C--------------------------------------------------------
      DIMENSION  P(20,20)
      DIMENSION  HM(4,7)
      DIMENSION  PCM(4,3)
      DIMENSION RNDM(3)
*
****************************************************
*   Translation from new to old input parameters :
*      ( S.J. )
****************************************************
      ID = 1
      HM(1,ID) = XM1
      HM(2,ID) = XM2
      HM(3,ID) = XM3
      HM(4,ID) = XM0
      K1 = 1
      K2 = 2
      K3 = 3
      PI2 = 2. * 3.141592654
***********************
*  Original code :
C--------------------------------------------------------
C     SIMULATION OF SECONDARY PARTICLE MOMENTA
C     IN THE REST FRAME OF PARENT PARTICLE
C--------------------------------------------------------
      T0=HM(4,ID)-HM(1,ID)-HM(2,ID)-HM(3,ID)
  10  CALL GRNDM(RNDM,2)
      G1=RNDM(1)
      G2=RNDM(2)
      GMI=MIN(G1,G2)
      GMA=MAX(G1,G2)
      TE=GMI*T0
      TM=(1.-GMA)*T0
      TN=(GMA-GMI)*T0
      PA1=SQRT(TE**2+2.*HM(1,ID)*TE)
      PA2=SQRT(TM**2+2.*HM(2,ID)*TM)
      PA3=SQRT(TN**2+2.*HM(3,ID)*TN)
C--------------------------------------------------------
C     CHECK OF THE MOMENTUM CONSERVATION
C--------------------------------------------------------
      PMMM=MAX(PA1,PA2)
      PMAX=MAX(PA3,PMMM)
      SP=PA1+PA2+PA3
      IF(PMAX.GE.SP-PMAX) GOTO 10
      P(4,K1)=TE+HM(1,ID)
      P(4,K2)=TM+HM(2,ID)
      P(4,K3)=TN+HM(3,ID)
C--------------------------------------------------------
C     ACCOUNTING FOR MATRIX ELEMENT (FOR ID=4 AND 5)
*     (** Calculates correct (V-A) decay for kaons.       **)
*     (** Now inactive.  Change ID to activate it. (S.J)  **)
C--------------------------------------------------------
      IF(ID.NE.4.AND.ID.NE.5) GOTO 20
      EEM=((HM(4,ID)-HM(2,ID))**2+HM(1,ID)**2-
     *      HM(3,ID)**2)/(2.*(HM(4,ID)-HM(2,ID)))
      HMMAX=EEM*(HM(4,ID)-HM(2,ID)-EEM)+
     *      0.5*(EEM**2-HM(1,ID)**2)
      HMA=P(4,K1)*P(4,K3)+0.25*(PA1**2+PA3**2-PA2**2)
      CALL GRNDM(RNDM,1)
      GG=RNDM(1)
      IF(HMA.LT.GG*HMMAX) GOTO 10
C--------------------------------------------------------
C     CALCULATIONS OF MOMENTA
C--------------------------------------------------------
20    CONTINUE
      CALL GRNDM(RNDM,3)
      CTE=2.*RNDM(1)-1.
      STE=SQRT(ABS(1.-CTE**2))
      FE =PI2*RNDM(2)
      CFE=COS(FE)
      SFE=SIN(FE)
      P(1,K1)=PA1*STE*CFE
      P(2,K1)=PA1*STE*SFE
      P(3,K1)=PA1*CTE
      CTEN=(PA2**2-PA1**2-PA3**2)/(2.*PA1*PA3)
      STEN=SQRT(ABS(1.-CTEN**2))
      FEN =PI2*RNDM(3)
      CFEN=COS(FEN)
      SFEN=SIN(FEN)
      P(1,K3)=PA3*(STEN*CFEN*CTE*CFE-STEN*SFEN*SFE+CTEN*STE*CFE)
      P(2,K3)=PA3*(STEN*CFEN*CTE*SFE+STEN*SFEN*CFE+CTEN*STE*SFE)
      P(3,K3)=PA3*(-STEN*CFEN*STE+CTEN*CTE)
      P(1,K2)=-P(1,K1)-P(1,K3)
      P(2,K2)=-P(2,K1)-P(2,K3)
      P(3,K2)=-P(3,K1)-P(3,K3)
C-------------------------------------------------------
***   Re-translation from old to new output arrays : ***
***     (S.J.)                                       ***
***--------------------------------------------------***
      DO 37 I=1,4
        DO 38 J=1,3
          PCM(I,J) = P(I,J)
 38     CONTINUE
 37   CONTINUE
      END
+DECK,GDECAY.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDECAY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Control routine for generation of particle decays.            *
C.    *                                                                *
C.    *  MODE(I)        I'th decay mode of current particle            *
C.    *  BRATIO(I)      branching ratio for I'th decay mode of         *
C.    *                 current particle.                              *
C.    *                                                                *
C.    *    ==>Called by : GHSTOP,GTHADR,GTNEUT,GTMUON                  *
C.    *       Author    G.Patrick *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,GCKING
+SEQ,GCKINE
+SEQ,GCUNIT
+SEQ,GCPHYS
+SEQ,GCJUMP, IF=USRJMP
      DIMENSION BAREA(7)
      DIMENSION BETA(4)
      DIMENSION BRATIO(6)
      DIMENSION MODE(6)
      DIMENSION NTYPE(3)
      DIMENSION PCM(4,3)
      DIMENSION XM(3)
      DIMENSION RNDM(1)
      LOGICAL ROTATE
C.
C.    ------------------------------------------------------------------
C.
C             Search for parent particle in decay list.
C
C
      KCASE   = NAMEC(5)
      NGKINE  = 0
      IF(IDCAY.EQ.2) THEN
         DESTEP = DESTEP+GETOT
         ISTOP  = 2
         GO TO 99
      ENDIF
      DMASS = AMASS
      JPA = LQ(JPART-IPART)
      JDK1 = LQ(JPA-1)
      JDK2 = LQ(JPA-2)
      IF (JDK1.LE.0)                               GO TO 90
      IF (JDK2.LE.0)                               GO TO 90
      DO 5 I=1,6
         BRATIO(I)=Q(JDK1+I)
         MODE(I)=IQ(JDK2+I)
   5  CONTINUE
C
C             Generate branching ratio and select decay mode.
C
      NBR      = 1
      BAREA(1) = 0.
      DO 10 I=2,7
         BRADD    = BRATIO(I-1)
         IF (BRADD.EQ.0.) GO TO 20
         NBR      = NBR+1
         BAREA(I) = BAREA(I-1)+BRADD
  10  CONTINUE
C
  20  CALL GRNDM(RNDM,1)
      BRAND    = 100.*RNDM(1)
      IF (BRAND.GE.BAREA(NBR)) GO TO 99
      ID       = IABS((LOCATF(BAREA,NBR,BRAND)))
C
C             Unpack decay mode.
C
      MXX      = MODE(ID)
      NTYPE(1) = MOD(MXX,100)
      NTYPE(2) = MOD(MXX/100,100)
      JP1 = LQ(JPART-NTYPE(1))
      JP2 = LQ(JPART-NTYPE(2))
      XM(1) = Q(JP1+7)
      XM(2) = Q(JP2+7)
      IF (MXX.LT.10000)THEN
C
C             Two body decay.
C
         NGKINE  = 2
         IF (TLIFE.LT.1.E-15) THEN
            XMTOT = XM(1)+XM(2)
            DO 30 I=1,1000
C--  Create Lorentz distributed energy with FWHM HBAR/TLIFE.
C--  (via integral-transformation of Lorentz-distribution)
C--                 (M.Guckes)
              CALL GRNDM(RNDM,1)
              RMASS = DMASS
     1                + 3.291086E-25/TLIFE * TAN(PI*(RNDM(1)-0.5))
              IF (RMASS.GE.XMTOT) GO TO 40
 30         CONTINUE
            WRITE(CHMAIL,1000) IPART, NTYPE(1), NTYPE(2)
            CALL GMAIL(0,0)
            NGKINE=0
            GO TO 99
 40         DMASS = RMASS
         END IF
         CALL GDECA2(DMASS,XM(1),XM(2),PCM)
      ELSE
C
C             Three body decay.
C
         NTYPE(3) = MXX/10000
         NGKINE  = 3
         JP3 = LQ(JPART-NTYPE(3))
         XM(3) = Q(JP3+7)
         IF (TLIFE.LT.1.E-15) THEN
            XMTOT = XM(1)+XM(2)+XM(3)
            DO 31 I=1,1000
C--  Create Lorentz distributed energy with FWHM HBAR/TLIFE.
C--  (via integral-transformation of Lorentz-distribution)
              CALL GRNDM(RNDM,1)
              RMASS = DMASS
     1                + 3.291086E-25/TLIFE * TAN(PI*(RNDM(1)-0.5))
              IF (RMASS.GE.XMTOT) GO TO 41
 31         CONTINUE
            WRITE(CHMAIL,1000) IPART, NTYPE(1), NTYPE(2), NTYPE(3)
            CALL GMAIL(0,0)
            NGKINE=0
            GO TO 99
 41         DMASS = RMASS
         END IF
         CALL GDECA3(DMASS,XM(1),XM(2),XM(3),PCM)
      ENDIF
C
C             LORENTZ boost into LAB system defined along parent vector
C             followed by rotation back into GEANT system.
C
      P0       = VECT(7)
      E0       = SQRT(P0*P0+DMASS*DMASS)
      BETA(1)  = 0.
      BETA(2)  = 0.
      BETA(3)  = -P0/E0
      BETA(4)  = E0/DMASS
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
C
      DO 60 K=1,NGKINE
         IF (P0.LE.0.) THEN
            DO 59 I = 1,3
   59       GKIN(I,K) = PCM(I,K)
         ELSE
            CALL GLOREN (BETA, PCM(1,K), GKIN(1,K))
         ENDIF
         IF(ROTATE) CALL GDROT  (GKIN(1,K),COSTH,SINTH,COSPH,SINPH)
         GKIN(4,K)=SQRT(GKIN(1,K)**2+GKIN(2,K)**2+GKIN(3,K)**2+XM(K)**2)
         GKIN(5,K)=NTYPE(K)
         TOFD(K)=0.
         GPOS(1,K) = VECT(1)
         GPOS(2,K) = VECT(2)
         GPOS(3,K) = VECT(3)
  60  CONTINUE
      GO TO 99
C
C             No branching ratio defined. Call user routine
C
+SELF, IF=-USRJMP
  90  CALL GUDCAY
+SELF, IF=USRJMP
  90  CALL JUMPT0(JUDCAY)
+SELF
C
  99  RETURN
 1000 FORMAT(' ***** GDECAY ERROR : Not enough energy available for ',
     +       'decay of resonance',I3,' to',3I3,'; no decay.')
      END
+DECK,GDRAY
*CMZ :  3.21/02 02/07/94  18.28.12  by  S.Giani
*-- Author :
      SUBROUTINE GDRAY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Delta rays                                          *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTHADR,GTMUON                         *
C.    *       Authors    D.Ward, L.Urban  ********                     *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCPHYS
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCCUTS
      DIMENSION PELS(3)
      DIMENSION RNDM(2)
      LOGICAL ROTATE
C.
C.    ------------------------------------------------------------------
C.
      P=VECT(7)
      XE=GETOT
      TE=GEKIN
      GAM=XE/AMASS
      GAM2=GAM*GAM
      T=GAM-1.
      X=DCUTE/(T*EMASS)
C
      KCASE = NAMEC(10)
      IF(IPART.EQ.3)   THEN
C
C======>       Moller scattering
C
        IF(X.GE.0.5) GO TO 90
        CC=1.-2.*X
C
  10    CALL GRNDM(RNDM,2)
        E=X/(1.-CC*RNDM(1))
C
        B1=4./(9.*GAM2-10.*GAM+5.)
        B2=T*T*B1
        B3=(2.*GAM2+2.*GAM-1.)*B1
        E1=1.-E
C
        SCREJ=B2*E*E-B3*E/E1+B1*GAM2/(E1*E1)
C
        IF(RNDM(2).GT.SCREJ) GOTO 10
C
      ELSEIF(IPART.EQ.2)THEN
C
C======>       Bhabha scattering
C
        IF(X.GE.1.) GO TO 90
        X1=1.-X
  20    CALL GRNDM(RNDM,2)
        E=X/(1.-X1*RNDM(1))
C
        Y=1./(GAM+1.)
        Y2=Y*Y
        C=1.-2.*Y
        B1=2.-Y2
        B2=C*(3.+Y2)
        C2=C*C
        B4=C2*C
        B3=C2+B4
        B0=GAM2/(GAM2-1.)
C
        SCREJ=(((B4*E-B3)*E+B2)*E-B1)*E+B0
        SCREJ=SCREJ/((((B4*X-B3)*X+B2)*X-B1)*X+B0)
        IF(RNDM(2).GT.SCREJ) GOTO 20
C
      ELSE
C
C======>     Heavy particle.
C
        TMAX=2.*EMASS*(GAM2-1.)/
     +  (1.+2.*GAM*EMASS/AMASS+(EMASS/AMASS)**2)
        IF(TMAX.LE.DCUTM)  GOTO 90
  40    CALL GRNDM(RNDM,2)
        E=1./DCUTM+RNDM(1)*(1./TMAX-1./DCUTM)
        E=1./E
        BET2=1.-1./GAM2
        SCREJ=1.-BET2*(E/TMAX)
C ---         extra term for spin 1/2 parent.
        IF(AMASS.GT.0.9 .OR. AMASS.LT.0.12)
     +  SCREJ=SCREJ+0.5*(E/GETOT)**2
        IF(RNDM(2).GT.SCREJ) GO TO 40
        E=E/(T*EMASS)
C
      ENDIF
C
      EEL=(T*E+1.)*EMASS
      TEL=EEL-EMASS
      PEL=SQRT(ABS((EEL+EMASS)*TEL))
      COSTH=(XE*EEL+EMASS*(TEL-XE))/(P*PEL)
      IF(COSTH.GE.1.) THEN
         COSTH=1.
         SINTH=0.
      ELSEIF(COSTH.LE.-1.) THEN
         COSTH=-1.
         SINTH=0.
      ELSE
         SINTH=SQRT((1.+COSTH)*(1.-COSTH))
      ENDIF
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      NGKINE = 1
      GKIN(1,1)=PEL*SINTH*COSPHI
      GKIN(2,1)=PEL*SINTH*SINPHI
      GKIN(3,1)=PEL*COSTH
      GKIN(4,1)=EEL
      GKIN(5,1)=3
      TOFD(NGKINE)=0.
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
      PELS(1)=-GKIN(1,1)
      PELS(2)=-GKIN(2,1)
      PELS(3)=P-GKIN(3,1)
C
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
      IF(ROTATE) THEN
         CALL GDROT(PELS(1),COSTH,SINTH,COSPH,SINPH)
         CALL GDROT(GKIN,COSTH,SINTH,COSPH,SINPH)
      ENDIF
C
C             Correct track vector for lost energy and scattered angles
C
      TELS=TE-TEL
      EELS=TELS+AMASS
      PEELS=SQRT(ABS((EELS+AMASS)*TELS))
      IF(PEELS.GT.0.)THEN
         DO 55 I=1,3
            VECT(I+3) = PELS(I)/PEELS
  55     CONTINUE
      ENDIF
      VECT(7) = PEELS
      GEKIN=TELS
      GETOT=EELS
      CALL GEKBIN
      IF((IDRAY.NE.1).OR.(TEL.LE.CUTELE)) THEN
          NGKINE = 0
          DESTEP = DESTEP + TEL
      ENDIF
C
C             Update probabilities
C
  90  CALL GRNDM(RNDM,1)
      ZINTDR=-LOG(RNDM(1))
      SLDRAY=SLENG
      STEPDR=BIG
C
      END
+DECK,GDRELA
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDRELA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialise ionisation energy loss by filling proton DE/DX     *
C.    *  tables for each material.                                     *
C.    *                                                                *
C.    *  For chemical mixtures,compounds & molecules the approximation *
C.    *  is made that                                                  *
C.    *                                                                *
C.    *          DE/DX = W(1)*DE/DX(1)+W(2)*DE/DX(2)...+W(N)*DE/DX(N)  *
C.    *  with,                                                         *
C.    *          DE/DX(i) appropriate to the i'th constituent.         *
C.    *                                                                *
C.    *  For mixtures    W(i) = fractional wght of each element.       *
C.    *  For molecules   W(i) = No. atoms*atomic wght/molecular wght.  *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, G.Patrick  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCMULO
+SEQ,GCJLOC
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,GCMATE
C.
C.    ------------------------------------------------------------------
C.
C            Number of constituents(ie. element,mixture or compound).
C
      NLMAT = Q(JMA+11)
      NLMAT  = IABS(NLMAT)
      IF (NLMAT.EQ.0) GO TO 999
      IF(Z.LT.1.) GO TO 999
C
      JEL1=LQ(JMA-1)
      JEL2=LQ(JMA-2)
      JEL3=LQ(JMA-3)
C
      ICHAN=IEKBIN
      T      = ELOW(ICHAN)
      T1     = 10.**(EKBIN(1)+(ICHAN-0.5)/GEKA)
C
C==========>  A,Ionisation losses for particles other than electrons
C            Simple element.
C
      IF (NLMAT.EQ.1) THEN
         CALL GDRELP(A,Z,DENS,T,DEDX)
         IF(DEDX.LT.0.)DEDX=0.
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            CALL GDRELP(A,Z,DENS,T1,DEDX1)
            IF(DEDX1.LT.0.)DEDX1=0.
         ENDIF
      ELSE
C
C            Mixture/compound : Loop over chemical constituents.
C
         DEDX = 0.
         DEDX1 = 0.
         DO 10 L=1,NLMAT
            AA = Q(JMIXT+L)
            ZZ = Q(JMIXT+NLMAT+L)
            WGHT = Q(JMIXT+2*NLMAT+L)
            CALL GDRELP(AA,ZZ,DENS*WGHT,T,DEDXC)
            IF(DEDXC.LT.0.)DEDXC=0.
            DEDX = DEDX + WGHT*DEDXC
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               CALL GDRELP(AA,ZZ,DENS*WGHT,T1,DEDXC1)
               IF(DEDXC1.LT.0.)DEDXC1=0.
               DEDX1 = DEDX1 + WGHT*DEDXC1
            ENDIF
   10    CONTINUE
      ENDIF
C
      Q(JEL3+ICHAN)=Q(JEL3+ICHAN)+DEDX*DENS
      IF(ICHAN.NE.NEK1) THEN
         WS(NEKBIN*3+ICHAN) = WS(NEKBIN*3+ICHAN)+DEDX1*DENS
      ENDIF
C
C===========>  B, Ionisation losses for muons
C
C     Simple element
      IF(NLMAT.EQ.1) THEN
         CALL GDRELM(A,Z,DENS,T,DEDX)
         IF(DEDX.LT.0.)DEDX=0.
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            CALL GDRELM(A,Z,DENS,T1,DEDX1)
            IF(DEDX1.LT.0.)DEDX1=0.
         ENDIF
      ELSE
C
C     Mixture/compound
C
         DEDX = 0.
         DEDX1 = 0.
         DO 20 L=1,NLMAT
            AA=Q(JMIXT+L)
            ZZ=Q(JMIXT+NLMAT+L)
            WGHT=Q(JMIXT+2*NLMAT+L)
            CALL GDRELM(AA,ZZ,DENS*WGHT,T,DEDXC)
            IF(DEDXC.LT.0.)DEDXC=0.
            DEDX=DEDX+WGHT*DEDXC
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               CALL GDRELM(AA,ZZ,DENS*WGHT,T1,DEDXC1)
               IF(DEDXC1.LT.0.)DEDXC1=0.
               DEDX1 = DEDX1 + WGHT*DEDXC1
            ENDIF
   20    CONTINUE
      ENDIF
C
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX*DENS
      IF(ICHAN.NE.NEK1) THEN
         WS(NEKBIN*2+ICHAN) = WS(NEKBIN*2+ICHAN)+DEDX1*DENS
      ENDIF
C
C===========>  C, Ionisation losses for electrons/positrons
C
      CALL GDRELE(T,-1.,JMA,DEDX)
      Q(JEL1+ICHAN)=Q(JEL1+ICHAN)+DEDX
      CALL GDRELE(T,+1.,JMA,DEDX)
      Q(JEL1+ICHAN+NEK1)=Q(JEL1+ICHAN+NEK1)+DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         CALL GDRELE(T1,-1.,JMA,DEDX1)
         WS(ICHAN)=WS(ICHAN)+DEDX1
         CALL GDRELE(T1,+1.,JMA,DEDX1)
         WS(NEKBIN+ICHAN)=WS(NEKBIN+ICHAN)+DEDX1
      ENDIF
C
  999 CONTINUE
      END
+DECK,GDRELE
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDRELE(EEL,CHARGE,JMA,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Compute ion losses for electron/positron                 *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    G.Patrick *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCONSP
+SEQ,GCCUTS
C
      DATA CONS/0.153536E-3/
C.
C.    ------------------------------------------------------------------
C.
      JPROB=LQ(JMA-4)
C
      GAM=EEL/EMASS + 1.
      GAM2=GAM*GAM
      T=GAM-1.
      DEDX=0.
      IF(T.LE.0.)GO TO 99
      TCME=DCUTE/EMASS
      BET2=1.-1./GAM2
C     ------------------------------
      IF(CHARGE.GT.0.) THEN
         Y=1./(1.+GAM)
         D=TCME
         IF(T.LT.TCME) D=T
         D2=D*D/2.
         D3=2.*D2*D/3.
         D4=D2*D2
         F=LOG(T*D)-BET2*(T+2.*D-Y*(3.*D2
     *    +Y*(D-D3+Y*(D2-T*D3+D4))))/T
C
      ELSE
        D=TCME
         IF(T.LT.2.*TCME) D=0.5*T
         F=-1.-BET2+LOG((T-D)*D)+T/(T-D)
     *    +(0.5*D*D+(1.+2.*T)*LOG(1.-D/T))/GAM2
      ENDIF
C
      POTL=Q(JPROB+11)
      FAC=Q(JPROB+12)
      C=Q(JPROB+13)
      X0=Q(JPROB+14)
      X1=Q(JPROB+15)
      AA=Q(JPROB+16)
C
      X=LOG(GAM2-1.)/4.606
      DEL=0.
      IF(X.GT.X0)THEN
         DEL=4.606*X+C
         IF(X.LE.X1)DEL=DEL+AA*(X1-X)**3.
      ENDIF
C
      DEDX=CONS*FAC*(LOG(2.*T+4.)-2.*POTL+F-DEL)/BET2
      IF(DEDX.LT.0.)DEDX=0.
C
  99  RETURN
      END
+DECK,GDRELI.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDRELI(A1,Z1,A2,Z2,DENS,T,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of an ion with charge Z1,    *
C.    *  atomic weight A1 and kinetic energy T in an element           *
C.    *  of atomic number Z2, atomic weight A2 and density             *
C.    *    DENS  ( the density is just used for the calculation        *
C.    *  of the density effect in the case of high T ).                *
C.    *  The routine reproduces the experimental and/or tabulated      *
C.    *  mean energy losses reasonably well.                           *
C.    *                                                                *
C.    *  The mean stopping power is obtained by calculating the proton *
C.    *  energy loss S at the equivalent proton kinetic energy  and    *
C.    *  multiplying this value by the effective charge of the ion.    *
C.    *  This method is used for high T ( T/A1 > Tamax , where         *
C.    *   Tamax depend on Z1 and Z2 , Tamax .le. few MeV).             *
C.    *  In the case of low T , the energy loss curve has been         *
C.    *  extrapolated down to T -> 0.                                  *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCCUTS
+SEQ,GCUNIT
      PARAMETER (AMU=0.93149432,D=0.00015357)
*
      EM=A1*AMU
      TA=PMASS*T/EM
*
      Z11=Z1*Z1
      TAMAX=(120.902-3.121*Z1+0.270*Z11)-(35.988-27.794*Z1+0.120*Z11)*
     +                                                   LOG(Z2)
      TAMAX=0.000001*TAMAX
*
*     calculate  stopping power (total loss) , save DCUTM before
*
      CUTSAV=DCUTM
      DCUTM=BIG
*
      IF(TA.GE.TAMAX) THEN
*
*     "high energy" case
*
         CALL GDRELP(A2,Z2,DENS,TA,S)
         S=Z1**2*GEFCH2(Z1,Z2,TA)*S
      ELSE
*
*     "low energy" case
*
         CALL GDRELP(A2,Z2,DENS,TAMAX,S0)
         S0=Z1**2*GEFCH2(Z1,Z2,TAMAX)*S0
         R=TA/TAMAX
         S=S0*(2.*SQRT(R)-R)
      ENDIF
*
      DCUTM=CUTSAV
      TMAX=2.*EMASS*T*(T+2.*EM)/EM**2
*
*     check whether restricted loss needed ?
*     if restricted loss , calculate the loss from delta rays
*
      IF(DCUTM.LT.TMAX) THEN
         BET2=T*(T+2.*EM)/(T+EM)**2
         R=DCUTM/TMAX
         DELTA=-LOG(R)-BET2*(1.-R)
         DELTA=D*Z2*Z1**2*DELTA/(A2*BET2)
         S=S-DELTA
         IF(S.LT.0.) S=0.
      ENDIF
*
      DEDX=S
*
      END
+DECK,GDRELM.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDRELM(A,Z,DENS,T,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of a  MUON  with kinetic     *
C.    *  energy T in an element of atomic number Z, atomic weight A    *
C.    *  and density DENS ( the density is just used for the           *
C.    *  calculation of the density effect in the case of high T).     *
C.    *                                                                *
C.    *   ------------------------------------------------------       *
C.    *   It calls GDRELP with the substitution EMMU -- > PMASS !      *
C.    *    ( and put back the right value of PMASS after)       !      *
C.    *   -----------------------------------------------------        *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
*
      CALL GDRELX(A,Z,DENS,T,REAL(EMMU),DEDX)
*
      END
+DECK,GDRELP.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDRELP(A,Z,DENS,T,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of a  MUON  with kinetic     *
C.    *  energy T in an element of atomic number Z, atomic weight A    *
C.    *  and density DENS ( the density is just used for the           *
C.    *  calculation of the density effect in the case of high T).     *
C.    *                                                                *
C.    *   ------------------------------------------------------       *
C.    *   It calls GDRELP with the substitution EMMU -- > PMASS !      *
C.    *    ( and put back the right value of PMASS after)       !      *
C.    *   -----------------------------------------------------        *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
*
      CALL GDRELX(A,Z,DENS,T,REAL(PMASS),DEDX)
*
      END
+DECK,GDRELX.
*CMZ :  3.21/03 06/10/94  18.22.43  by  S.Giani
*-- Author :
      SUBROUTINE GDRELX(A,Z,DENS,T,HMASS,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of a particle with kinetic   *
C.    *  energy T in an element of atomic number Z, atomic weight A    *
C.    *  and density DENS ( the density is just used for the           *
C.    *  calculation of the density effect in the case of high T).     *
C.    *  The routine reproduces the experimental and/or tabulated      *
C.    *  energy losses rather well down to T -> 0.                     *
C.    *  Simple parametrization is used for  T .le. T2L=2 MeV (see     *
C.    *  H.H.Andersen,J.F.Ziegler:Hydrogen stopping powers and         *
C.    *  ranges in all element,Pergamon Press,1977.).                  *
C.    *  For T .gt. T2L=2 MeV the corrected Bethe-Bloch stopping       *
C.    *  power / restricted energy loss formula is used.               *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCCUTS
+SEQ,GCUNIT
      PARAMETER (AMUKEV=931494.32,D=0.000153537,T1L=0.00001,T2L=0.002)
      PARAMETER (EMPROT=0.9382723)
      DIMENSION B(6,92),C(6,92),CECOF(6)
*
      DATA ((B(I,J),I=1,6),J=1,19) /
     +     1.262,1.44,242.6,12000.,0.1159,18.8,
     +     1.229,1.397,484.5,5873.,0.05225,41.7,
     +     1.411,1.6,725.6,3013.,0.04578,47.6,
     +     2.248,2.59,966.,153.8,0.03475,62.7,
     +     2.474,2.815,1206.,1060.,0.02855,76.0,
     +     2.631,2.989,1445.,957.2,0.02819,77.3,
     +     2.954,3.35,1683.,1900.,0.02513,86.7,
     +     2.652,3.,1920.,2000.,0.0223,97.7,
     +     2.085,2.352,2157.,2634.,0.01816,120.,
     +     1.951,2.199,2393.,2699.,0.01568,139.,
     +     2.542,2.869,2628.,1854.,0.01472,148.,
     +     3.792,4.293,2862.,1009.,0.01397,156.,
     +     4.154,4.739,2766.,164.5,0.02023,162.,
     +     4.15,4.7,3329.,550.,0.01321,165.,
     +     3.232,3.647,3561.,1560.,0.01267,172.,
     +     3.447,3.891,3792.,1219.,0.01211,180.,
     +     5.047,5.714,4023.,878.6,0.01178,185.,
     +     5.731,6.5,4253.,530.,0.01123,194.,
     +     5.151,5.833,4482.,545.7,0.01129,193./
      DATA ((B(I,J),I=1,6),J=20,38) /
     +     5.521,6.252,4710.,553.3,0.01112,196.,
     +     5.201,5.884,4938.,560.9,0.009995,218.,
     +     4.862,5.496,5165.,568.5,0.009474,230.,
     +     4.48,5.055,5391.,952.3,0.009117,239.,
     +     3.983,4.489,5616.,1336.,0.008413,259.,
     +     3.469,3.907,5725.,1461.,0.008829,270.,
     +     3.519,3.963,6065.,1243.,0.007782,280.,
     +     3.14,3.535,6288.,1372.,0.007361,296.,
     +     3.553,4.004,6205.,555.1,0.008763,310.,
     +     3.696,4.175,4673.,387.8,0.02188,322.,
     +     4.21,4.75,6953.,295.2,0.006809,320.,
     +     5.041,5.697,7173.,202.6,0.006725,324.,
     +     5.554,6.3,6496.,110.,0.009689,330.,
     +     5.323,6.012,7611.,292.5,0.006447,338.,
     +     5.874,6.656,7395.,117.5,0.007684,340.,
     +     5.611,6.335,8046.,365.2,0.006244,349.,
     +     6.411,7.25,8262.,220.,0.006087,358.,
     +     5.694,6.429,8478.,292.9,0.006087,358.,
     +     6.339,7.159,8693.,330.3,0.006003,363./
      DATA ((B(I,J),I=1,6),J=39,57)  /
     +     6.407,7.234,8907.,367.8,0.005889,370.,
     +     6.734,7.603,9120.,405.2,0.005765,378.,
     +     6.902,7.791,9333.,442.7,0.005587,390.,
     +     6.425,7.248,9545.,480.2,0.005367,406.,
     +     6.799,7.671,9756.,517.6,0.005315,410.,
     +     6.108,6.887,9966.,555.1,0.005151,423.,
     +     5.924,6.677,10180.,592.5,0.004919,443.,
     +     5.238,5.9,10380.,630.,0.004758,458.,
     +     5.623,6.354,7160.,337.6,0.01394,466.,
     +     5.814,6.554,10800.,355.5,0.004626,471.,
     +     6.23,7.024,11010.,370.9,0.00454,480.,
     +     6.41,7.227,11210.,386.4,0.004474,487.,
     +     7.5,8.48,8608.,348.,0.009074,494.,
     +     6.979,7.871,11620.,392.4,0.004402,495.,
     +     7.725,8.716,11830.,394.8,0.004376,498.,
     +     8.231,9.289,12030.,397.3,0.004384,497.,
     +     7.287,8.218,12230.,399.7,0.004447,490.,
     +     7.899,8.911,12430.,402.1,0.004511,483.,
     +     8.041,9.071,12630.,404.5,0.00454,480./
      DATA ((B(I,J),I=1,6),J=58,76)  /
     +     7.489,8.444,12830.,406.9,0.00442,493.,
     +     7.291,8.219,13030.,409.3,0.004298,507.,
     +     7.098,8.,13230.,411.8,0.004182,521.,
     +     6.91,7.786,13430.,414.2,0.004058,537.,
     +     6.728,7.58,13620.,416.6,0.003976,548.,
     +     6.551,7.38,13820.,419.,0.003877,562.,
     +     6.739,7.592,14020.,421.4,0.003863,564.,
     +     6.212,6.996,14210.,423.9,0.003725,585.,
     +     5.517,6.21,14400.,426.3,0.003632,600.,
     +     5.219,5.874,14600.,428.7,0.003498,623.,
     +     5.071,5.706,14790.,433.,0.003405,640.,
     +     4.926,5.542,14980.,433.5,0.003342,652.,
     +     4.787,5.386,15170.,435.9,0.003292,662.,
     +     4.893,5.505,15360.,438.4,0.003243,672.,
     +     5.028,5.657,15550.,440.8,0.003195,682.,
     +     4.738,5.329,15740.,443.2,0.003186,684.,
     +     4.574,5.144,15930.,442.4,0.003144,693.,
     +     5.2,5.851,16120.,441.6,0.003122,698.,
     +     5.07,5.704,16300.,440.9,0.003082,707./
      DATA ((B(I,J),I=1,6),J=77,92)  /
     +     4.945,5.563,16490.,440.1,0.002965,735.,
     +     4.476,5.034,16670.,439.3,0.002871,759.,
     +     4.856,5.46,18320.,438.5,0.002542,755.,
     +     4.308,4.843,17040.,487.8,0.002882,756.,
     +     4.723,5.311,17220.,537.,0.002913,748.,
     +     5.319,5.982,17400.,586.3,0.002871,759.,
     +     5.956,6.7,17800.,677.,0.00266,765.,
     +     6.158,6.928,17770.,586.3,0.002812,775.,
     +     6.204,6.979,17950.,586.3,0.002776,785.,
     +     6.181,6.954,18120.,586.3,0.002748,793.,
     +     6.949,7.82,18300.,586.3,0.002737,796.,
     +     7.506,8.448,18480.,586.3,0.002727,799.,
     +     7.649,8.609,18660.,586.3,0.002697,808.,
     +     7.71,8.679,18830.,586.3,0.002641,825.,
     +     7.407,8.336,19010.,586.3,0.002603,837.,
     +     7.29,8.204,19180.,586.3,0.002573,847./
      DATA C/92*0.,92*0.,92*0.,92*0.,92*0.,92*0./
      DATA CECOF/0.42237,0.0304,-0.00038,3.858,-0.1668,0.00158/
      DATA EPS/0.000001/
*     ------------------------------------------------------------------
*      in the case of non-integer Z the low energy parameters
*      and the ionization potential are taken at INT(Z) !
*
      IZ=INT(Z+EPS)
      IF((IZ.LT.1).OR.(IZ.GT.92)) GOTO 10
*
*     Calculate coefficients C(I,J) if it has not been done already
*
      IF(C(1,IZ).LT.EPS) THEN
         FAC=AVO/A
         C(1,IZ)=FAC*AMUKEV**0.5*B(1,IZ)
         C(2,IZ)=FAC*AMUKEV**0.45*B(2,IZ)
         C(3,IZ)=FAC*B(3,IZ)/AMUKEV
         C(4,IZ)=B(4,IZ)/AMUKEV
         C(5,IZ)=AMUKEV*B(5,IZ)
*
*                     POTI=16.E-9*Z**0.9
*
         POTI=B(6,IZ)*1.E-9
*
*
         C(6,IZ)=POTI
*
      ENDIF
*     ----------------------------------------------------------------
      T1LIM=HMASS*T1L/EMPROT
      T2LIM=HMASS*T2L/EMPROT
*
*     Calculate dE/dx
*     ---> for T .le. T1LIM (very low energy)
*
      IF(T.LE.T1LIM) THEN
         TAU=T/HMASS
         DEDX=C(1,IZ)*TAU**0.5
      ELSE
*
*     ---> for T1LIM .lt. T   and  T .le. T2LIM (low energy)
*
         IF(T.LE.T2LIM) THEN
            TAU=T/HMASS
            SL=C(2,IZ)*TAU**0.45
            SH=C(3,IZ)*LOG(1.+C(4,IZ)/TAU+C(5,IZ)*TAU)/TAU
            DEDX=SL*SH/(SL+SH)
*
*     ---> for T .gt. T2LIM ( "high " energy , Bethe-Bloch formula)
*
         ELSE
            P=SQRT(T*(T+2.*HMASS))
            E=T+HMASS
            BET2=(P/E)**2
            ETA=P/HMASS
            ETA2=ETA*ETA
*+++ new line follows.....
            B2G2=ETA*ETA
*+++ end of correction
            TMAX=2.*EMASS*T*(T+2.*HMASS)
*+++  correction of the next line
*           TMAX=TMAX/(HMASS**2+EMASS**2+EMASS*(T+HMASS))
            TMAX=TMAX/(HMASS**2+EMASS**2+2.*EMASS*E)
*+++ end of correction
*
*         density correction
*
            POTI=C(6,IZ)
            CC=1.+2.*LOG(POTI/(28.8E-9*SQRT(DENS*Z/A)))
*         condensed material ? ( dens .gt. 0.05 ? )
            IF(DENS.GT.0.05) THEN
               IF(POTI.LT.1.E-7) THEN
                  IF(CC.LT.3.681) THEN
                     X0=0.2
                  ELSE
                     X0=0.326*CC-1.
                  ENDIF
                  X1=2.
               ELSE
                  IF(CC.LT.5.215) THEN
                     X0=0.2
                  ELSE
                     X0=0.326*CC-1.5
                  ENDIF
                  X1=3.
               ENDIF
*         gas ?   ( dens . le . 0.05 ? )
            ELSE
               IF(CC.LE.12.25) THEN
                  IP=INT((CC-10.)/0.5)+1
                  IF(IP.LT.0) IP=0
                  IF(IP.GT.4) IP=4
                  X0=1.6+0.1*FLOAT(IP)
                  X1=4.
               ELSE
                  IF(CC.LE.13.804) THEN
                     X0=2.
                     X1=5.
                  ELSE
                     X0=0.326*CC-2.5
                     X1=5.
                  ENDIF
               ENDIF
            ENDIF
*
            XA=CC/4.606
            XM=3.
            AA=4.606*(XA-X0)/(X1-X0)**XM
*
            X=LOG10(ETA)
            DELTA=0.
            IF(X.GT.X0) THEN
               DELTA=4.606*X-CC
               IF(X.LT.X1) DELTA=DELTA+AA*(X1-X)**XM
            ENDIF
*
*         calculate shell correction
*
            POTSQ=POTI*POTI
            IF(ETA.GT.0.13) THEN
               F1=1./ETA2
               F2=F1*F1
               F3=F1*F2
               F4=(F1*CECOF(1)+F2*CECOF(2)+F3*CECOF(3))*1.E+12
               F5=(F1*CECOF(4)+F2*CECOF(5)+F3*CECOF(6))*1.E+18
               CE=F4*POTSQ+F5*POTSQ*POTI
            ELSE
               ETA2=0.0169
               F1=1./ETA2
               F2=F1*F1
               F3=F1*F2
               F4=(F1*CECOF(1)+F2*CECOF(2)+F3*CECOF(3))*1.E+12
               F5=(F1*CECOF(4)+F2*CECOF(5)+F3*CECOF(6))*1.E+18
               CE=F4*POTSQ+F5*POTSQ*POTI
               CE=CE*LOG(T/T2LIM)/LOG(0.0079/T2LIM)
            ENDIF
*
            F1=D*Z/(A*BET2)
*
*         stopping power or restricted dE/dx ?
*
*+++  correction of the next few lines
*           IF(DCUTM.GE.TMAX) THEN
*              F2=2.*(LOG(TMAX/POTI)-BET2)
*           ELSE
*              F2=LOG(TMAX*DCUTM/POTSQ)-BET2*(1.+DCUTM/TMAX)
*           ENDIF
            TUPP=DCUTM
            IF(TMAX.LT.DCUTM) TUPP=TMAX
            F2=LOG(2.*EMASS*B2G2/POTI)+LOG(TUPP/POTI)
     +         -BET2*(1.+TUPP/TMAX)
*+++ end of correction
            DEDX=F1*(F2-DELTA-2.*CE/Z)
*
*
            TAU=T2LIM/HMASS
            SL=C(2,IZ)*TAU**0.45
            SH=C(3,IZ)*LOG(1.+C(4,IZ)/TAU+C(5,IZ)*TAU)/TAU
            ST=SL*SH/(SL+SH)
*
            TMAX=2.*EMASS*T2LIM*(T2LIM+2.*HMASS)
*+++  correction of the next line
*           TMAX=TMAX/(HMASS**2+EMASS**2+EMASS*(T2LIM+HMASS))
            TMAX=TMAX/(HMASS**2+EMASS**2+2.*EMASS*(T2LIM+HMASS))
*+++  end of correction
            BET2=T2LIM*(T2LIM+2.*HMASS)/(T2LIM+HMASS)**2
            SBB=2.*(LOG(TMAX/POTI)-BET2)
            SBB=D*Z*SBB/(A*BET2)
            CORBB=(ST/SBB-1.)*T2LIM
*
            DEDX=DEDX*(1.+CORBB/T)
*
         ENDIF
      ENDIF
*
      RETURN
   10 WRITE (CHMAIL,10000) Z
      CALL GMAIL(1,1)
10000 FORMAT(5X,'***GDRELP  (Z.LT.1.).OR.(Z.GT.92.) ==> Z=',F10.1)
      END
+DECK,GDROT
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDROT(P,COSTH,SINTH,COSPH,SINPH)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Rotates vector from one reference system into another.        *
C.    *  THETA and PHI are anti-clockwise Eulerian angles between the  *
C.    *  two systems.                                                  *
C.    *                                                                *
C.    *    ==>Called by : GBREME,GCOMP,GDECAY,GDECA3,GDRAY,GPAIRG      *
C.    *       Author    M.Hansroul, G.Patrick  *********               *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P(3)
+SELF,IF=-SINGLE
      DOUBLE PRECISION P1,P2,P3
+SELF
C.
C.    ------------------------------------------------------------------
C.
      P1=P(1)
      P2=P(2)
      P3=P(3)
      P(1)=P1*COSTH*COSPH - P2*SINPH + P3*SINTH*COSPH
      P(2)=P1*COSTH*SINPH + P2*COSPH + P3*SINTH*SINPH
      P(3)=-P1*SINTH                 + P3*COSTH
C
      END
+DECK,GDRPRT.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDRPRT(IPART,IMATE,STEP,MPOINT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Landau fluctuations and/or delta-rays generation .            *
C.    *  print the value of some relevant parameters (see phys 332) :  *
C.    *  Tmax, zeta, kapa and the regime for fluctuations              *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IPART   Geant particle number                                 *
C.    *  IMATE   Geant material number                                 *
C.    *  STEP    cm                                                    *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire    *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCBANK
+SEQ, GCONSP
+SEQ, GCUNIT.
+SEQ, GCMULO.
*
      PARAMETER (MXPOIN=100)
      DIMENSION TCUT(5)
      DIMENSION TKINV(MXPOIN),DEDXMV(MXPOIN),DNTOTV(MXPOIN)
      CHARACTER REGIME*14,KUNIT*4,NAPART*8,NAMATE*8
*
      PARAMETER (DGEV=0.153536 E-3)
*
* *** incident particle
      JPA = LQ(JPART-IPART)
      CALL UHTOC (IQ(JPA+1),4,NAPART,8)
      AMASS = Q(JPA+7)
      CHARG = Q(JPA+8)
      EAMAS = EMASS/AMASS
*
* *** material
      JMA = LQ(JMATE-IMATE)
      IF(JMA.LE.0.OR.IMATE.GT.IQ(JMATE-2)) THEN
         WRITE(CHMAIL,10000) IMATE
         GOTO 999
      ENDIF
      CALL UHTOC (IQ(JMA+1),4,NAMATE,8)
      AMT = Q(JMA+6)
      ZMT = Q(JMA+7)
      RO  = Q(JMA+8)
      JPR = LQ(JMA-4)
*
* *** mean ionization potential (GeV)
*     POTI=16E-9*ZMT**0.9
      POTI=Q(JPR+9)
*
      CONS = DGEV*CHARG*CHARG*STEP*RO*ZMT/AMT
*
      WRITE (CHMAIL,10200) NAPART,NAMATE,STEP
      CALL GMAIL(1,0)
      WRITE (CHMAIL,10100)
      CALL GMAIL(0,1)
      WRITE (CHMAIL,10300)
      CALL GMAIL(0,1)
*
* *** loop on kinetic energy
      NPOINT = MIN(MPOINT,MXPOIN)
      TKINI = ELOW(1)
      TKEND = ELOW(NEK1)
      STEPL = (TKEND/TKINI)**(1./(NPOINT-1))
      TKINV(1) = TKINI
      DO 10 JTK=2,NPOINT
         TKINV(JTK) = TKINV(JTK-1)*STEPL
   10 CONTINUE
      CALL GFTMAT(IMATE,IPART,'LOSS',NPOINT,TKINV,DEDXMV,TCUT,IXST)
      CALL GFTMAT(IMATE,IPART,'DRAY',NPOINT,TKINV,DNTOTV,TCUT,IXST)
      DO 20  I=1,NPOINT
         TKIN  = TKINV(I)
         DEDXM = DEDXMV(I)
         DNTOT = DNTOTV(I)
         TKM = TKIN/AMASS
         GAMA = TKM + 1.
         GAM2 = GAMA**2
         BTA2 = TKM*(TKM+2.)/GAM2
*        maximum transferable energy (gev)
         TMAX = (2*EMASS*GAM2*BTA2)/(1.+2*GAMA*EAMAS+EAMAS**2)
         IF(IPART.EQ.3) TMAX=0.5*TMAX
*
* ***    mean de/dx on material
         DEGEV = STEP*DEDXM*1.E-3
         DEPOT = DEGEV/POTI
*
* ***    total number of delta ray production
         DNTOT = DNTOT*STEP
*
* ***    low energy tranfert
         ZETA = CONS/BTA2
         DNLOW = ZETA/POTI
*
* ***    high energy transfert
         DNHIG = ZETA/TMAX
*
* ***    regime
         DNMIN = MIN(DNLOW,DEPOT)
         IF(DNMIN.GE.50.) THEN
            IF (DNHIG.GE.10. ) THEN
               REGIME = 'Gauss'
            ELSEIF (DNHIG.GE.0.01) THEN
               REGIME = 'Vavilov'
            ELSE
               REGIME = 'Landau'
            ENDIF
         ELSE
            IFREE = 1
            IF(DNMIN.GE.0.01) THEN
               REGIME = 'Urban/'
               IFREE  = 7
            ENDIF
            IF(DNMIN.GE.1..AND.DNMIN.LT.30.) THEN
               REGIME(IFREE:) = 'ASHO/'
               IFREE  = 12
            ENDIF
            REGIME(IFREE:) = 'PAI'
         ENDIF
*
* ***    print
         CALL GEVKEV (TKIN,TKUN,KUNIT)
         WRITE (CHMAIL,10400) TKUN,KUNIT,DNTOT,DEPOT,DNLOW,DNHIG,
     +   REGIME
         CALL GMAIL(0,0)
   20 CONTINUE
*
10000 FORMAT(' **** GDRPRT: Material N ',I3,' has not been defined')
10100 FORMAT (9X,'For an explication of the ''regimes'' field ',
     +           'see the GEANT manual')
10200 FORMAT (5X,'*** Energy loss straggling for ',A8,' in ',A8,
     +           ', step ',F8.4,' cm')
10300 FORMAT (4X,'   Ekin ','     N d-rays','      dE/I    ',
     +    '    xi/I    ','   xi/Emax ','    regime')
10400 FORMAT (4X,F5.1,A4,4E12.3,4X,A14)
*
  999 CONTINUE
      END
+DECK,GDRSGA
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GDRSGA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for Delta rays (Moller or Bhabba)                             *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    D.Ward, L.Urban  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,GCMATE
+SEQ,GCJLOC
+SEQ,GCCUTS
+SEQ,GCMULO
C.
C.    ------------------------------------------------------------------
C.
      Q(JDRAY+IEKBIN       )=BIG
      Q(JDRAY+IEKBIN+  NEK1)=BIG
      Q(JDRAY+IEKBIN+2*NEK1)=BIG
      IF(Z.LT.1.) GOTO 99
      JPROB=LQ(JMA-4)
      TKIN=ELOW(IEKBIN)
C
C=======>              A,   MUONS
C
      IF(TKIN.GT.DCUTM)THEN
         XE=TKIN+EMMU
         GAM=XE/EMMU
         GAM2=GAM**2
         BET2=1.-1./GAM2
         TMAX=2.*EMASS*(GAM2-1.)/
     +     (1.+2.*GAM*EMASS/EMMU+(EMASS/EMMU)**2)
         IF(TMAX.GT.DCUTM)THEN
            Y=DCUTM/TMAX
            SIG=(1.-Y+BET2*Y*LOG(Y))/DCUTM
            SIG=SIG+(TMAX-DCUTM)/(2.*XE**2)
            SIG=SIG*Q(JPROB+17)*EMASS/BET2
            IF(SIG.GT.0.)Q(JDRAY+IEKBIN+2*NEK1)=1./SIG
         ENDIF
      ENDIF
C
C======>            B,    ELECTRONS
C
      IF(TKIN.GT.DCUTE)THEN
C
         XE=TKIN+EMASS
         GAM=XE/EMASS
         GAM2=GAM*GAM
         BET2=1.-1./GAM2
         T=GAM-1.
         X=DCUTE/(T*EMASS)
         X1=1.-X
C
C     Moller
C
         IF(T.GT.2.*DCUTE/EMASS)THEN
            B1=T*T/GAM2
            B2=(2.*GAM-1.)/GAM2
            SIG=(B1*(0.5-X)+1./X-1./X1-B2*LOG(X1/X))/BET2
            SIG=Q(JPROB+17)*SIG/T
            IF(SIG.GT.0.)Q(JDRAY+IEKBIN)=1./SIG
         ENDIF
C
C     Bhabha
C
         IF(T.GT.DCUTE/EMASS)THEN
            Y=1./(GAM+1.)
            Y2=Y*Y
            C=1.-2.*Y
            B1=2.-Y2
            B2=C*(3.+Y2)
            C2=C*C
            B4=C2*C
            B3=C2+B4
            SIG=(1./X-1.)/BET2+B1*LOG(X)
     +           +B2*(1.-X)-B3*(1.-X*X)/2.+B4*(1.-X**3)/3.
            SIG=Q(JPROB+17)*SIG/T
            IF(SIG.GT.0.)Q(JDRAY+IEKBIN+NEK1)=1./SIG
         ENDIF
      ENDIF
C
  99  RETURN
      END
+DECK,GEFCH2
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GEFCH2(Z1,Z2,TK)
C.    *******************************************************************
C.    *                                                                 *
C.    *  Calculates  gamma**2=( eff.charge/z1)**2 for heavy ions        *
C.    *   (see e.g. F.Hubert et al. Atomic Data and Nuclear Data        *
C.    *             Tables,Vol.40,1.(1990) )                            *
C.    *                                                                 *
C.    *  The stopping power S for a given combination of stopping       *
C.    *  medium and heavy ion can be calculated according to            *
C.    *  the scaling law                                                *
C.    *                                                                 *
C.    *            S = (gamma*Z1)**2*Sref/Zref**2                       *
C.    *                                                                 *
C.    *    where Z1 the ion charge , gamma*Z1 is the effective charge,  *
C.    *          Sref is the stopping power of the same medium          *
C.    *          for a reference ion of the same velocity and           *
C.    *          of effective charge Zref.                              *
C.    *                                                                 *
C.    *  Input: Z1 atomic number of the ion                             *
C.    *         Z2 atomic number of the medium                          *
C.    *         TK E/A in GeV (ion kin.energy/atomic weight)            *
C.    *                                                                 *
C.    *******************************************************************
C.
      ALZ2=LOG(Z2)
      TKMEV=1000.*TK
C
      X1=1.164+0.2319*EXP(-0.004302*Z2)+1.658*EXP(-0.05170*Z1)
      X2=8.144+0.09876*ALZ2
      X3=0.3140+0.01072*ALZ2
      X4=0.5218+0.02521*ALZ2
      EE=MAX(-50.,-X2*TKMEV**X3/Z1**X4)
C     .........................
      GA=1.-X1*EXP(EE)
C
      GEFCH2=GA**2
      END
+DECK,GFANG.
*CMZ :  3.21/02 06/07/94  18.28.55  by  S.Giani
*-- Author :
      SUBROUTINE GFANG(P,COSTH,SINTH,COSPH,SINPH,ROTATE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Finds theta-phi angles for a particle with director cosines P *
C.    *  The logical flag ROTATE indicates whether the the director    *
C.    *  cosines are along the Z axis (.FALSE.) or not (.TRUE.).       *
C.    *                                                                *
C.    *    ==>Called by :                                              *
C.    *       Author    F.Carminati  *********                         *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P(*)
+SELF,IF=-SINGLE
      DOUBLE PRECISION DUX, DUY, DUZ, DSITH2, ONE, DNORM
+SELF
      LOGICAL ROTATE
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      DUX      = P(1)
      DUY      = P(2)
      DUZ      = P(3)
      ROTATE   = .TRUE.
      IF(ABS(DUZ).GE.0.85) THEN
         DSITH2=DUX**2+DUY**2
         IF(DSITH2.GT.0.) THEN
            COSTH  = SIGN(ONE,DUZ)*SQRT(ONE-DSITH2)
            DSITH  = SQRT(DSITH2)
            SINTH  = DSITH
            COSPH  = DUX/DSITH
            SINPH  = DUY/DSITH
         ELSEIF(DUZ.GT.0.)THEN
            ROTATE = .FALSE.
            COSTH =  1.
            SINTH =  0.
            COSPH =  1.
            SINPH =  0.
         ELSE
            COSTH = -1.
            SINTH =  0.
            COSPH =  1.
            SINPH =  0.
         ENDIF
      ELSE
         COSTH  = DUZ
         DSITH  = SQRT((ONE+DUZ)*(ONE-DUZ))
         SINTH  = DSITH
         DNORM  = ONE/SQRT(DUX**2+DUY**2)
         COSPH  = DUX*DNORM
         SINPH  = DUY*DNORM
      ENDIF
*
      END
+DECK,GFLUCT.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFLUCT(DEMEAN,DE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Subroutine to decide which method is used to simulate        *
C.    *   the straggling around the mean energy loss.                  *
C.    *                                                                *
C.    *                                                                *
C.    *   DNMIN:  <---------->1<-------->30<--------->50<--------->    *
C.    *                                                                *
C.    *   LOSS=2  :                                                    *
C.    *   STRA=0  <----------GLANDZ-------------------><--GLANDO-->    *
C.    *   LOSS=1,3:                                                    *
C.    *   STRA=0  <---------------------GLANDZ-------------------->    *
C.    *                                                                *
C.    *   STRA=1  <-----------PAI---------------------><--GLANDZ-->    *
+SELF,IF=ASHO
C.    *   STRA=2  <---PAI----><---ASHO---><----PAI----><--GLANDZ-->    *
C.    *                                                                *
+SELF
C.    *                                                                *
C.    *   DNMIN :  an estimation of the number of collisions           *
C.    *            with energy close to the ionization energy          *
C.    *            (see PHYS333)                                       *
C.    *                                                                *
C.    *   Input  : DEMEAN (mean energy loss)                           *
C.    *   Output : DE   (energy loss in the current step)              *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTMUON,GTHADR                         *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCBANK
+SEQ, GCJLOC
+SEQ, GCONSP
+SEQ, GCMATE
+SEQ, GCCUTS
+SEQ, GCKINE
+SEQ, GCMULO
+SEQ, GCPHYS
+SEQ, GCTRAK
*
      PARAMETER (EULER=0.577215,GAM1=EULER-1)
      PARAMETER (P1=.60715,P2=.67794,P3=.52382E-1,P4=.94753,
     +           P5=.74442,P6=1.1934)
      PARAMETER (DGEV=0.153536 E-3, DNLIM=50)
+SELF,IF=ASHO
      PARAMETER (ASHMIN=1,ASHMAX=30)
+SELF
      DIMENSION RNDM(2)
      FLAND(X) = P1+P6*X+(P2+P3*X)*EXP(P4*X+P5)
*
      IF(STEP.LE.0) THEN
         DE=DEMEAN
      ELSE
         DEDX = DEMEAN/STEP
         POTI=Q(JPROB+9)
         IF(ISTRA.EQ.0.AND.ILOSS.NE.2) THEN
            CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,Q(JPROB+10))
         ELSE
*
* *** mean ionization potential (GeV)
*        POTI=16E-9*Z**0.9
*
            GAMMA = GETOT/AMASS
            BETA = VECT(7)/GETOT
            BET2 = BETA**2
*
* ***    low energy transfer
            XI = DGEV*CHARGE**2*STEP*DENS*Z/(A*BET2)
*
* ***    regime
* ***    ISTRA = 1 --> PAI + URBAN
+SELF,IF=ASHO
* ***    ISTRA = 2 --> PAI + URBAN + ASHO
+SELF
            DNMIN = MIN(XI,DEMEAN)/POTI
*
            IF (ISTRA.EQ.0) THEN
               IF(DNMIN.GE.DNLIM) THEN
*
*  Energy straggling using Gaussian, Landau & Vavilov theories.
*
*  STEP   =  current step-length (cm)
*
*  DELAND =  DE/DX - <DE/DX>     (GeV)
*
*  Author      : G.N. Patrick
*
                  IF(STEP.LT.1.E-7)THEN
                     DELAND=0.
                  ELSE
*
*     Maximum energy transfer to atomic electron (GeV).
                     ETA = BETA*GAMMA
                     RATIO = EMASS/AMASS
*
*     Calculate Kappa significance ratio.
*                 EMAX=(2*EMASS*ETA**2)/(1+2*RATIO*GAMMA+RATIO**2)
*                 CAPPA = XI/EMAX
                     CAPPA = XI*(1+2*RATIO*GAMMA+RATIO**2)/(2*EMASS*
     +               ETA**2)
                     IF (CAPPA.GE.10.) THEN
*
*     +-----------------------------------+
*     I Sample from Gaussian distribution I
*     +-----------------------------------+
                        SIGMA = XI*SQRT((1.-0.5*BET2)/CAPPA)
                        CALL GRNDM(RNDM,2)
                        F1 = -2.*LOG(RNDM(1))
                        DELAND = SIGMA*SQRT(F1)*COS(TWOPI*RNDM(2))
                     ELSE
                        XMEAN = -BET2-LOG(CAPPA)+GAM1
                        IF (CAPPA.LT.0.01) THEN
                           XLAMX = FLAND(XMEAN)
*     +---------------------------------------------------------------+
*     I Sample lambda variable from Kolbig/Schorr Landau distribution I
*     +---------------------------------------------------------------+
*  10                   CALL GRNDM(RNDM,1)
*                       IF( RNDM(1) .GT. 0.980 ) GO TO 10
*                       XLAMB = GLANDR(RNDM(1))
*     +---------------------------------------------------------------+
*     I Sample lambda variable from James/Hancock Landau distribution I
*     +---------------------------------------------------------------+
   10                      CALL GLANDG(XLAMB)
                           IF(XLAMB.GT.XLAMX) GO TO 10
                        ELSE
*            +---------------------------------------------------------+
*            I Sample lambda variable (Landau not Vavilov) from        I
*            I Rotondi&Montagna&Kolbig Vavilov distribution            I
*            +---------------------------------------------------------+
                           CALL GRNDM(RNDM,1)
                           XLAMB = GVAVIV(CAPPA,BET2,RNDM(1))
                        ENDIF
*
*     Calculate DE/DX - <DE/DX>
                        DELAND = XI*(XLAMB-XMEAN)
                     ENDIF
                  ENDIF
                  DE = DEMEAN + DELAND
               ELSE
                  CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,
     +            Q(JPROB+ 10))
               ENDIF
            ELSE IF (ISTRA.LE.2) THEN
               IF(DNMIN.GE.DNLIM) THEN
                  CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,
     +            Q(JPROB+ 10))
               ELSE
                  NMEC = NMEC+1
                  LMEC(NMEC)=109
+SELF,IF=ASHO
                  IF (DNMIN.GE.ASHMIN.AND.DNMIN.LT.ASHMAX .AND.ISTRA.EQ
     +            .2) THEN
                     CALL GASHO(VECT(7),AMASS,STEP,DE)
                  ELSE
                     DE = GSTREN(GAMMA,DCUTE,STEP)
                  ENDIF
+SELF,IF=-ASHO
                  DE = GSTREN(GAMMA,DCUTE,STEP)
+SELF
*
* ***   Add brem losses to ionisation
                  IF(ITRTYP.EQ.2) THEN
                     JBASE = LQ(JMA-1)+2*NEK1+IEKBIN
                     DE = DE +(1.-GEKRAT)*Q(JBASE)+GEKRAT*Q(JBASE+1)
                  ELSEIF(ITRTYP.EQ.5) THEN
                     JBASE = LQ(JMA-2)+NEK1+IEKBIN
                     DE = DE +(1.-GEKRAT)*Q(JBASE)+GEKRAT*Q(JBASE+1)
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      END
+DECK,GFNRDT.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFNRDT(Z,ESHL,NSHL,NWORD,NONRAD,PRB,ENER)
C.
C.    ******************************************************************
C.    *                                                                *
C     *   Fetch Non-Radiative Decay probability Table and the modes    *
C.    *       the nonradiative shells decay                            *
C.    *                                                                *
C.    *    ==>Called by : GFSHDC                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,GCCUTS.
+CDE,GCPMXZ.
+CDE,GCPHNR.
      REAL  ONEEV
      PARAMETER (ONEEV = 1.E-9)
      DIMENSION ESHL(*),PRB(*),ENER(*),NONRAD(*)
      IZ = Z
      NWORD = 0
      DO 10 J = 1,NSHL
         NONRAD(J) = 0
         ESHELL = ESHL(J)
         IF(ESHELL.GT.0.0) THEN
            I1 = IGNRFN((J-1)*2+1,IZ)
            I2 = IGNRFN((J-1)*2+2,IZ)
            IF(I1*I2.GT.0) THEN
               NONRAD(J) = 1
               NWORD = NWORD+1
               ENER(NWORD) = ESHELL-ESHL(I1)-ESHL(I2)
               ENER(NWORD) = ENER(NWORD)*ONEEV
               IF(ENER(NWORD).LE.CUTELE) ENER(NWORD) = -ENER(NWORD)
               PRB(NWORD) = 1.
            ENDIF
         ENDIF
   10 CONTINUE
      END
+DECK,GFRDT.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFRDT(ZZ,ESHL,NSHL,NWORD,NRAD,PRB,ENER)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Fetch Radiative Decay probability Tables and the modes   *
C.    *       the radiative shells decay                               *
C.    *                                                                *
C.    *    ==>Called by : GFSHDC                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,GCCUTS.
+CDE,GCPMXZ.
+CDE,GCPHRD.
      REAL ONEEV
      PARAMETER (ONEEV = 1.E-9)
      DIMENSION ESHL(*),PRB(*),ENER(*),NRAD(*)
      IZ = ZZ
      NWORD = 0
      DO 30 J = 1,NSHL
         NRAD(J) = 0
         ESHELL = ESHL(J)
         IF(ESHELL.GT.0.0) THEN
            IF(J.EQ.1) THEN
               NR = KSHLS
               NS = 0
            ELSEIF(J.EQ.2) THEN
               NR = L1SHLS
               NS = KSHLS
            ELSEIF(J.EQ.3) THEN
               NR = L2SHLS
               NS = KSHLS+L1SHLS
            ELSEIF(J.EQ.4) THEN
               NR = L3SHLS
               NS = KSHLS+L1SHLS+L2SHLS
            ENDIF
            NWS = NWORD+1
            QS = 0.0
            DO 10 I = 1,NR
               QS = QS+GPHRAT(NS+I,IZ)
               IF(GPHRAT(NS+I,IZ).GT.0.0) THEN
                  NWORD = NWORD+1
                  NRAD(J) = NRAD(J)+1
                  PRB(NWORD) = QS
                  ENER(NWORD) = ESHELL-ESHL(ISHLTR(NS+I))
                  ENER(NWORD) = ENER(NWORD)*ONEEV
                  IF(ENER(NWORD).LE.CUTGAM) ENER(NWORD) = -ENER(NWORD)
               ENDIF
   10       CONTINUE
            IF(QS.GT.0.0) THEN
               QS1 = 1./QS
               DO 20 I = NWS,NWORD
                  PRB(I) = PRB(I)*QS1
   20          CONTINUE
            ENDIF
         ENDIF
   30 CONTINUE
      END
+DECK,GFSDPR.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFSDPR(Z,NSHL,PRB)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Fetch probability of radiative shells decay              *
C.    *                                                                *
C.    *    ==>Called by : GFSHDC                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,GCPMXZ.
+CDE,GCPHPR.
      DIMENSION PRB(NSHL)
      IZ = Z
      DO 10 I = 1,NSHL
         PRB(I) = GFLUPR(I,IZ)
   10 CONTINUE
      END
+DECK,GFSHDC.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFSHDC(IELEM,Z)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Fetch Shell Decay Constants                                   *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHXSI                                       *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCONSP.
+CDE,GCUNIT.
      REAL ONEEV
      PARAMETER (ONEEV = 1.E-9)
      DIMENSION PRB(4),PRBR(92),ER(92),PRBNR(92),ENR(92)
      DIMENSION ESHL(24),NRAD(24),NONRAD(24)
      PARAMETER (NFNBIN = 17, NSHELL = 4)
C
C Push NZ JPFN banks which will contain constants for each Z
C
      JPHXS = LQ(JPHOT-1)
C
C Get Z, the shell potentials and the decay modes
C
      DO 10 I = 1,24
         ESHL(I) = 0.0
         NRAD(I) = 0
         NONRAD(I) = 0
   10 CONTINUE
      DO 20 I = 1,4
         PRB(I) = 0.0
   20 CONTINUE
      DO 30 I = 1,92
         PRBNR(I) = 0.0
         PRBNR(I) = 0.0
         ENR(I) = 0.0
         ER(I) = 0.0
   30 CONTINUE
      CALL GFSHLS(Z,ESHL,NSHLL)
      CALL GFRDT(Z,ESHL,NSHELL,NWR,NRAD,PRBR,ER)
      CALL GFNRDT(Z,ESHL,NSHELL,NWNR,NONRAD,PRBNR,ENR)
C Calculate how many words are needed for the final state bank JPHFN
      NWORD = 0
      DO 40 J = 1,NSHELL
         IF(NRAD(J).GT.0) NWORD = NWORD+2*NRAD(J)+1
         IF(NONRAD(J).GT.0) NWORD = NWORD+2*NONRAD(J)+1
   40 CONTINUE
      NBOOK = NWORD+NFNBIN
      JPHFN = LQ(JPHXS-IELEM)
C Push bank to store final state parameters
      CALL MZPUSH(IXCONS,JPHFN,0,NBOOK,'R')
      NUSED = 5*Q(JPHFN+1)+1
      JPHFN = JPHFN+NUSED
      Q(JPHFN+1) = NSHELL
C Get probability of the shell radiative decay
      CALL GFSDPR(Z,NSHELL,PRB)
C
C Copy potentials and radiative decay probabilities
C
      DO 50 J = 1,NSHELL
         IF(ESHL(J).GT.0.0) THEN
            Q(JPHFN+1+J) = ESHL(J)*ONEEV
            Q(JPHFN+1+J+NSHELL) = PRB(J)
         ELSE
C if the shell potential is zero set it to -1
            Q(JPHFN+1+J) = -1.
            Q(JPHFN+1+J+NSHELL) = -1.
         ENDIF
   50 CONTINUE
C
C Now configurations of the final state
C
      K = 18
      KR = 1
      KNR = 1
      IF(NWORD.GT.0) THEN
         Q(JPHFN+10) = 18+NUSED
         DO 100 J = 1,NSHELL
            IF(ESHL(J).GT.0.0) THEN
               IF(NRAD(J).GT.0) THEN
                  IF(J.GT.1) Q(JPHFN+9+J) = K+NUSED
                  Q(JPHFN+K) = NRAD(J)
                  K = K+1
                  KER = KR+NRAD(J)-1
                  DO 60 L = KR,KER
                     Q(JPHFN+K) = PRBR(L)
                     K = K+1
   60             CONTINUE
                  DO 70 L = KR,KER
                     Q(JPHFN+K) = ER(L)
                     K = K+1
   70             CONTINUE
                  KR = KR+NRAD(J)
               ENDIF
               IF(NONRAD(J).GT.0) THEN
                  Q(JPHFN+13+J) = K+NUSED
                  Q(JPHFN+K) = NONRAD(J)
                  K = K+1
                  KNER = KNR+NONRAD(J)-1
                  DO 80 L = KNR,KNER
                     Q(JPHFN+K) = PRBNR(L)
                     K = K+1
   80             CONTINUE
                  DO 90 L = KNR,KNER
                     Q(JPHFN+K) = ENR(L)
                     K = K+1
   90             CONTINUE
                  KNR = KNR+NONRAD(J)
               ENDIF
            ENDIF
  100    CONTINUE
      ELSE
C You should never land here unless Z < 6
         IF(Z.GT.5.) THEN
C               CALL MZDROP(IXCONS,JPHFN,'L')
            WRITE(CHMAIL,'(A25,I3)') ' GFSHDC. JPHFN Z > 5. Z = ',Z
            CALL GMAIL(0,0)
         ENDIF
      ENDIF
      END
+DECK,GFSHLS.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFSHLS(Z,GSHPOT,NSHELL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Fetch the shells' potentials for e given Z               *
C.    *       The potentials are in eV !!!                             *
C.    *                                                                *
C.    *    ==>Called by : GPHXSI,GFSHDC                                *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      IMPLICIT NONE
+CDE,GCPMXZ.
+CDE,GCSHPT.
+CDE,GCUNIT.
      REAL ZZ,Z,GSHPOT(*)
      INTEGER I,IZ,NSHELL
      ZZ = Z
      IF(ZZ.LT.1.OR.ZZ.GT.MAXELZ) THEN
         IF(ZZ.LT. 1) WRITE(CHMAIL,10000) ZZ
         IF(ZZ.GT.MAXELZ) WRITE(CHMAIL,10100) ZZ
         CALL GMAIL(0,0)
      ELSE
         IZ = IFIX(ZZ)
         NSHELL = NSHLLS(IZ)
         DO 10 I = 1,NSHLLS(IZ)
            GSHPOT(I) = ESHELL(N1ST(IZ)-1+I)
   10    CONTINUE
      ENDIF
10000 FORMAT(' ***** GFSHLS ERROR:',
     +       '  Z of the material is less than   1.',
     +       ' Actual Z =',I5,'.')
10100 FORMAT(' ***** GFSHLS ERROR:',
     +       '  Z of the material is bigger than 100.',
     +       ' Actual Z =',I5,' (I5).')
      END
+DECK,GLANDE.
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      FUNCTION GLANDE(X)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine DENLAN (G110)                *
C.    *                                                                *
C.    *    ==>Called by : GVACOE                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P1(0:4),P2(0:4),P3(0:4),P4(0:4),P5(0:4),P6(0:4)
      DIMENSION Q1(0:4),Q2(0:4),Q3(0:4),Q4(0:4),Q5(0:4),Q6(0:4)
      DIMENSION A1(1:3),A2(1:2)
C
      DATA (P1(I),I=0,4),(Q1(J),J=0,4)
     1/ 0.42598 94875E+0,-0.12497 62550E+0, 0.39842 43700E-1,
     2 -0.62982 87635E-2, 0.15111 62253E-2,
     3  1.0             ,-0.33882 60629E+0, 0.95943 93323E-1,
     4 -0.16080 42283E-1, 0.37789 42063E-2/
C
      DATA (P2(I),I=0,4),(Q2(J),J=0,4)
     1/ 0.17885 41609E+0, 0.11739 57403E+0, 0.14888 50518E-1,
     2 -0.13949 89411E-2, 0.12836 17211E-3,
     3  1.0             , 0.74287 95082E+0, 0.31539 32961E+0,
     4  0.66942 19548E-1, 0.87906 09714E-2/
C
      DATA (P3(I),I=0,4),(Q3(J),J=0,4)
     1/ 0.17885 44503E+0, 0.93591 61662E-1, 0.63253 87654E-2,
     2  0.66116 67319E-4,-0.20310 49101E-5,
     3  1.0             , 0.60978 09921E+0, 0.25606 16665E+0,
     4  0.47467 22384E-1, 0.69573 01675E-2/
C
      DATA (P4(I),I=0,4),(Q4(J),J=0,4)
     1/ 0.98740 54407E+0, 0.11867 23273E+3, 0.84927 94360E+3,
     2 -0.74377 92444E+3, 0.42702 62186E+3,
     3  1.0             , 0.10686 15961E+3, 0.33764 96214E+3,
     4  0.20167 12389E+4, 0.15970 63511E+4/
C
      DATA (P5(I),I=0,4),(Q5(J),J=0,4)
     1/ 0.10036 75074E+1, 0.16757 02434E+3, 0.47897 11289E+4,
     2  0.21217 86767E+5,-0.22324 94910E+5,
     3  1.0             , 0.15694 24537E+3, 0.37453 10488E+4,
     4  0.98346 98876E+4, 0.66924 28357E+5/
C
      DATA (P6(I),I=0,4),(Q6(J),J=0,4)
     1/ 0.10008 27619E+1, 0.66491 43136E+3, 0.62972 92665E+5,
     2  0.47555 46998E+6,-0.57436 09109E+7,
     3  1.0             , 0.65141 01098E+3, 0.56974 73333E+5,
     4  0.16591 74725E+6,-0.28157 59939E+7/
C
      DATA (A1(I),I=1,3)
     1/ 0.41666 66667E-1,-0.19965 27778E-1, 0.27095 38966E-1/
C
      DATA (A2(I),I=1,2)
     1/-0.18455 68670E+1,-0.42846 40743E+1/
C
      V=X
      IF(V .LT. -5.5) THEN
       U=EXP(V+1.0)
       GLANDE=0.3989422803*(EXP(-1.0/U)/SQRT(U))*
     1        (1.0+(A1(1)+(A1(2)+A1(3)*U)*U)*U)
      ELSE IF(V .LT. -1.0) THEN
       U=EXP(-V-1.0)
       GLANDE=EXP(-U)*SQRT(U)*
     1        (P1(0)+(P1(1)+(P1(2)+(P1(3)+P1(4)*V)*V)*V)*V)/
     2        (Q1(0)+(Q1(1)+(Q1(2)+(Q1(3)+Q1(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 1.0) THEN
       GLANDE=(P2(0)+(P2(1)+(P2(2)+(P2(3)+P2(4)*V)*V)*V)*V)/
     1        (Q2(0)+(Q2(1)+(Q2(2)+(Q2(3)+Q2(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 5.0) THEN
       GLANDE=(P3(0)+(P3(1)+(P3(2)+(P3(3)+P3(4)*V)*V)*V)*V)/
     1        (Q3(0)+(Q3(1)+(Q3(2)+(Q3(3)+Q3(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 12.0) THEN
       U=1.0/V
       GLANDE=U**2*(P4(0)+(P4(1)+(P4(2)+(P4(3)+P4(4)*U)*U)*U)*U)/
     1             (Q4(0)+(Q4(1)+(Q4(2)+(Q4(3)+Q4(4)*U)*U)*U)*U)
      ELSE IF(V .LT. 50.0) THEN
       U=1.0/V
       GLANDE=U**2*(P5(0)+(P5(1)+(P5(2)+(P5(3)+P5(4)*U)*U)*U)*U)/
     1             (Q5(0)+(Q5(1)+(Q5(2)+(Q5(3)+Q5(4)*U)*U)*U)*U)
      ELSE IF(V .LT. 300.0) THEN
       U=1.0/V
       GLANDE=U**2*(P6(0)+(P6(1)+(P6(2)+(P6(3)+P6(4)*U)*U)*U)*U)/
     1             (Q6(0)+(Q6(1)+(Q6(2)+(Q6(3)+Q6(4)*U)*U)*U)*U)
      ELSE
       U=1.0/(V-V*LOG(V)/(V+1.0))
       GLANDE=U**2*(1.0+(A2(1)+A2(2)*U)*U)
      END IF
      RETURN
      END
 
+DECK,GLANDG
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GLANDG(YRAN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine GENLAN                       *
C.    *  Generation of LANDAU-distributed random numbers by 4-point    *
C.    *  interpolation in the previously-tabulated inverse cumulative  *
C.    *  distribution                                                  *
C.    *                                                                *
C.    *    ==>Called by : GLANDO                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (RANGE1=0.807069,RANGE2=0.994869)
      PARAMETER (X1BOT =0.0     ,X2BOT =0.791240)
      PARAMETER (GP1INV=118.836 ,GP2INV=486.178 )
C
      DIMENSION XCUM1(100) , XCUM2(100)
      DIMENSION RNDM(1)
C
C====>  1ST TABLE OF INVERSE CUMULATIVE LANDAU POINTS. ( 0.0<P<0.833 )
      DATA XCUM1(  1) / -2.57000 /   ,   XCUM1(  2) / -2.15412 /
      DATA XCUM1(  3) / -1.94167 /   ,   XCUM1(  4) / -1.79583 /
      DATA XCUM1(  5) / -1.67975 /   ,   XCUM1(  6) / -1.58090 /
      DATA XCUM1(  7) / -1.49341 /   ,   XCUM1(  8) / -1.41397 /
      DATA XCUM1(  9) / -1.34057 /   ,   XCUM1( 10) / -1.27185 /
      DATA XCUM1( 11) / -1.20686 /   ,   XCUM1( 12) / -1.14490 /
      DATA XCUM1( 13) / -1.08545 /   ,   XCUM1( 14) / -1.02809 /
      DATA XCUM1( 15) /  -.97249 /   ,   XCUM1( 16) /  -.91839 /
      DATA XCUM1( 17) /  -.86557 /   ,   XCUM1( 18) /  -.81386 /
      DATA XCUM1( 19) /  -.76308 /   ,   XCUM1( 20) /  -.71311 /
      DATA XCUM1( 21) /  -.66384 /   ,   XCUM1( 22) /  -.61515 /
      DATA XCUM1( 23) /  -.56696 /   ,   XCUM1( 24) /  -.51919 /
      DATA XCUM1( 25) /  -.47176 /   ,   XCUM1( 26) /  -.42462 /
      DATA XCUM1( 27) /  -.37769 /   ,   XCUM1( 28) /  -.33092 /
      DATA XCUM1( 29) /  -.28426 /   ,   XCUM1( 30) /  -.23767 /
      DATA XCUM1( 31) /  -.19109 /   ,   XCUM1( 32) /  -.14447 /
      DATA XCUM1( 33) /  -.09779 /   ,   XCUM1( 34) /  -.05100 /
      DATA XCUM1( 35) /  -.00405 /   ,   XCUM1( 36) /   .04308 /
      DATA XCUM1( 37) /   .09044 /   ,   XCUM1( 38) /   .13806 /
      DATA XCUM1( 39) /   .18598 /   ,   XCUM1( 40) /   .23423 /
      DATA XCUM1( 41) /   .28285 /   ,   XCUM1( 42) /   .33187 /
      DATA XCUM1( 43) /   .38134 /   ,   XCUM1( 44) /   .43128 /
      DATA XCUM1( 45) /   .48174 /   ,   XCUM1( 46) /   .53275 /
      DATA XCUM1( 47) /   .58435 /   ,   XCUM1( 48) /   .63658 /
      DATA XCUM1( 49) /   .68948 /   ,   XCUM1( 50) /   .74309 /
      DATA XCUM1( 51) /   .79746 /   ,   XCUM1( 52) /   .85263 /
      DATA XCUM1( 53) /   .90865 /   ,   XCUM1( 54) /   .96556 /
      DATA XCUM1( 55) /  1.02342 /   ,   XCUM1( 56) /  1.08228 /
      DATA XCUM1( 57) /  1.14219 /   ,   XCUM1( 58) /  1.20322 /
      DATA XCUM1( 59) /  1.26542 /   ,   XCUM1( 60) /  1.32887 /
      DATA XCUM1( 61) /  1.39362 /   ,   XCUM1( 62) /  1.45976 /
      DATA XCUM1( 63) /  1.52736 /   ,   XCUM1( 64) /  1.59650 /
      DATA XCUM1( 65) /  1.66727 /   ,   XCUM1( 66) /  1.73976 /
      DATA XCUM1( 67) /  1.81407 /   ,   XCUM1( 68) /  1.89032 /
      DATA XCUM1( 69) /  1.96860 /   ,   XCUM1( 70) /  2.04905 /
      DATA XCUM1( 71) /  2.13180 /   ,   XCUM1( 72) /  2.21699 /
      DATA XCUM1( 73) /  2.30477 /   ,   XCUM1( 74) /  2.39531 /
      DATA XCUM1( 75) /  2.48878 /   ,   XCUM1( 76) /  2.58540 /
      DATA XCUM1( 77) /  2.68535 /   ,   XCUM1( 78) /  2.78889 /
      DATA XCUM1( 79) /  2.89626 /   ,   XCUM1( 80) /  3.00775 /
      DATA XCUM1( 81) /  3.12364 /   ,   XCUM1( 82) /  3.24429 /
      DATA XCUM1( 83) /  3.37005 /   ,   XCUM1( 84) /  3.50136 /
      DATA XCUM1( 85) /  3.63866 /   ,   XCUM1( 86) /  3.78246 /
      DATA XCUM1( 87) /  3.93334 /   ,   XCUM1( 88) /  4.09194 /
      DATA XCUM1( 89) /  4.25900 /   ,   XCUM1( 90) /  4.43533 /
      DATA XCUM1( 91) /  4.62186 /   ,   XCUM1( 92) /  4.81960 /
      DATA XCUM1( 93) /  5.02974 /   ,   XCUM1( 94) /  5.25368 /
      DATA XCUM1( 95) /  5.49312 /   ,   XCUM1( 96) /  5.74987 /
      DATA XCUM1( 97) /  6.02605 /   ,   XCUM1( 98) /  6.32428 /
      DATA XCUM1( 99) /  6.64773 /   ,   XCUM1(100) /  7.00000 /
C
C====>  2ND TABLE OF INVERSE CUMULATIVE LANDAU POINTS. ( 0.791<P<0.995 )
      DATA XCUM2(  1) /   5.50000 /   ,   XCUM2(  2) /   5.56120 /
      DATA XCUM2(  3) /   5.62347 /   ,   XCUM2(  4) /   5.68684 /
      DATA XCUM2(  5) /   5.75133 /   ,   XCUM2(  6) /   5.81699 /
      DATA XCUM2(  7) /   5.88383 /   ,   XCUM2(  8) /   5.95191 /
      DATA XCUM2(  9) /   6.02125 /   ,   XCUM2( 10) /   6.09190 /
      DATA XCUM2( 11) /   6.16391 /   ,   XCUM2( 12) /   6.23732 /
      DATA XCUM2( 13) /   6.31219 /   ,   XCUM2( 14) /   6.38855 /
      DATA XCUM2( 15) /   6.46646 /   ,   XCUM2( 16) /   6.54597 /
      DATA XCUM2( 17) /   6.62712 /   ,   XCUM2( 18) /   6.70998 /
      DATA XCUM2( 19) /   6.79460 /   ,   XCUM2( 20) /   6.88103 /
      DATA XCUM2( 21) /   6.96935 /   ,   XCUM2( 22) /   7.05962 /
      DATA XCUM2( 23) /   7.15192 /   ,   XCUM2( 24) /   7.24633 /
      DATA XCUM2( 25) /   7.34294 /   ,   XCUM2( 26) /   7.44182 /
      DATA XCUM2( 27) /   7.54306 /   ,   XCUM2( 28) /   7.64676 /
      DATA XCUM2( 29) /   7.75300 /   ,   XCUM2( 30) /   7.86188 /
      DATA XCUM2( 31) /   7.97351 /   ,   XCUM2( 32) /   8.08800 /
      DATA XCUM2( 33) /   8.20548 /   ,   XCUM2( 34) /   8.32610 /
      DATA XCUM2( 35) /   8.44997 /   ,   XCUM2( 36) /   8.57725 /
      DATA XCUM2( 37) /   8.70808 /   ,   XCUM2( 38) /   8.84262 /
      DATA XCUM2( 39) /   8.98103 /   ,   XCUM2( 40) /   9.12349 /
      DATA XCUM2( 41) /   9.27021 /   ,   XCUM2( 42) /   9.42141 /
      DATA XCUM2( 43) /   9.57730 /   ,   XCUM2( 44) /   9.73812 /
      DATA XCUM2( 45) /   9.90410 /   ,   XCUM2( 46) /  10.07552 /
      DATA XCUM2( 47) /  10.25265 /   ,   XCUM2( 48) /  10.43584 /
      DATA XCUM2( 49) /  10.62540 /   ,   XCUM2( 50) /  10.82169 /
      DATA XCUM2( 51) /  11.02508 /   ,   XCUM2( 52) /  11.23598 /
      DATA XCUM2( 53) /  11.45487 /   ,   XCUM2( 54) /  11.68222 /
      DATA XCUM2( 55) /  11.91855 /   ,   XCUM2( 56) /  12.16441 /
      DATA XCUM2( 57) /  12.42045 /   ,   XCUM2( 58) /  12.68734 /
      DATA XCUM2( 59) /  12.96580 /   ,   XCUM2( 60) /  13.25663 /
      DATA XCUM2( 61) /  13.56075 /   ,   XCUM2( 62) /  13.87912 /
      DATA XCUM2( 63) /  14.21280 /   ,   XCUM2( 64) /  14.56296 /
      DATA XCUM2( 65) /  14.93088 /   ,   XCUM2( 66) /  15.31799 /
      DATA XCUM2( 67) /  15.72593 /   ,   XCUM2( 68) /  16.15650 /
      DATA XCUM2( 69) /  16.61170 /   ,   XCUM2( 70) /  17.09378 /
      DATA XCUM2( 71) /  17.60523 /   ,   XCUM2( 72) /  18.14884 /
      DATA XCUM2( 73) /  18.72792 /   ,   XCUM2( 74) /  19.34622 /
      DATA XCUM2( 75) /  20.00796 /   ,   XCUM2( 76) /  20.71792 /
      DATA XCUM2( 77) /  21.48176 /   ,   XCUM2( 78) /  22.30618 /
      DATA XCUM2( 79) /  23.19862 /   ,   XCUM2( 80) /  24.16809 /
      DATA XCUM2( 81) /  25.22547 /   ,   XCUM2( 82) /  26.38320 /
      DATA XCUM2( 83) /  27.65658 /   ,   XCUM2( 84) /  29.06490 /
      DATA XCUM2( 85) /  30.63048 /   ,   XCUM2( 86) /  32.38211 /
      DATA XCUM2( 87) /  34.35555 /   ,   XCUM2( 88) /  36.59607 /
      DATA XCUM2( 89) /  39.16212 /   ,   XCUM2( 90) /  42.13195 /
      DATA XCUM2( 91) /  45.61204 /   ,   XCUM2( 92) /  49.74758 /
      DATA XCUM2( 93) /  54.74189 /   ,   XCUM2( 94) /  60.89935 /
      DATA XCUM2( 95) /  68.67370 /   ,   XCUM2( 96) /  78.81480 /
      DATA XCUM2( 97) /  92.61047 /   ,   XCUM2( 98) / 112.50807 /
      DATA XCUM2( 99) / 143.78539 /   ,   XCUM2(100) / 200.00000 /
C.
C.    ------------------------------------------------------------------
C.
      CALL GRNDM(RNDM,1)
      X = RNDM(1)
      IF(X .LT. 0.004) THEN
*
* *** Extreme left-hand tail
         YRAN = -SQRT(ABS(LOG(X)))
*
      ELSEIF(X.LE.RANGE1) THEN
*
* *** 4-point interpolation in the first cumulative table
         TABPO1 = (X-X1BOT)*GP1INV
         J = TABPO1 + 1
         J = MAX(J,2)
         J = MIN(J,98)
         P = TABPO1 - (J-1)
         A = (P+1.0) * XCUM1(J+2) - (P-2.0) * XCUM1(J-1)
         B = (P-1.0) * XCUM1(J)   - P       * XCUM1(J+1)
         YRAN = A*P*(P-1.0)*0.16666667+B*(P+1.0)*(P-2.0)*0.5
*
      ELSEIF(X.LE.RANGE2) THEN
*
* *** 4-point interpolation in the first cumulative table
         TABPO2 = (X-X2BOT)*GP2INV
         J = TABPO2 + 1
         J = MAX(J,2)
         J = MIN(J,98)
         P = TABPO2 - (J-1)
         A = (P+1.0) * XCUM2(J+2) - (P-2.0) * XCUM2(J-1)
         B = (P-1.0) * XCUM2(J)   - P       * XCUM2(J+1)
         YRAN = A*P*(P-1.0)*0.16666667+B*(P+1.0)*(P-2.0)*0.5
*
      ELSE
*
* *** 1/x**2 sampling for extreme Landau tail
         CALL GRNDM(RNDM,1)
         YRAN=200./RNDM(1)
*
      ENDIF
      END
+DECK,GLANDO
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GLANDO(IMODE,STEP,Z,A,RHO,P,E,XMASS,DE,IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *  GLANDO                                                        *
C.    *  ------                                                        *
C.    *                                                                *
C.    *  Energy straggling using Gaussian, Landau & Vavilov theories.  *
C.    *                                                                *
C.    *  Input                                                         *
C.    *  -----                                                         *
C.    *  IMODE  =  3   Landau(RANLAN)  sampling                        *
C.    *         =  4   Landau(GENLAN)  sampling                        *
C.    *         =  5   Vavilov(DINVAV) sampling                        *
C.    *         =  6   Gaussian sampling                               *
C.    *         =  2   Automatic selection of relevant distribution    *
C.    *                                                                *
C.    *  STEP   =  current step-length (cm)                            *
C.    *                                                                *
C.    *  Output                                                        *
C.    *  ------                                                        *
C.    *  DE     =  DE/DX - <DE/DX>     (GeV)                           *
C.    *                                                                *
C.    *  IFLAG  =  3   Landau(RANLAN) sampling used                    *
C.    *         =  4   Landau(GENLAN) sampling used                    *
C.    *         =  5   Vavilov(GVAVIV) sampling used                   *
C.    *         =  6   Gaussian sampling used                          *
C.    *                                                                *
C.    *  Warning                                                       *
C.    *  -------                                                       *
C.    *  Only Landau sampling should be used since this has been well  *
C.    *  tested whereas both Vavilov and Gaussian sampling are being   *
C.    *  developed.                                                    *
C.    *                                                                *
C.    *  Author      : G.N. Patrick                                    *
C.    *  Date        : 03.05.1985                                      *
C.    *  Last update : 09.09.1985                                      *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (EULER=0.577215)
      PARAMETER (P1=.60715,P2=.67794,P3=.52382E-1,P4=.94753,
     +           P5=.74442,P6=1.1934)
+SEQ,GCONSP
      DIMENSION RNDM(2)
      FLAND(X) = P1+P6*X+(P2+P3*X)*EXP(P4*X+P5)
C.
C.    ------------------------------------------------------------------
C.
      IF(STEP.LT.1.E-7)THEN
         DE=0.
         IFLAG=0
         RETURN
      ENDIF
C
C     Calculate xi factor (KeV).
C
      BETA   = P/E
      GAMMA  = E/XMASS
      XI     = (153.5*Z*STEP*RHO)/(A*BETA*BETA)
C
C     Maximum energy transfer to atomic electron (KeV).
C
      ETA    = BETA*GAMMA
      ETASQ  = ETA*ETA
      RATIO  = EMASS/XMASS
      F1     = 2.*EMASS*ETASQ
      F2     = 1.+2.*RATIO*GAMMA+RATIO*RATIO
      EMAX   = F1*1.E+6/F2
C
C     Calculate Kappa significance ratio.
C
      CAPPA  = XI/EMAX
C
C     Choose correct function if IMODE set to automatic selection.
C
      IMODEI = IMODE
      IF (IMODEI.EQ.2)    THEN
         IF (CAPPA.LT.0.01)                              IMODEI = 4
*****    IF (CAPPA.GE.0.01.AND.CAPPA.LE.10.)             IMODEI = 3
         IF (CAPPA.GE.0.01.AND.CAPPA.LE.10.)             IMODEI = 5
         IF (CAPPA.GT.10.)                               IMODEI = 6
      ENDIF
C
C     +---------------------------------------------------------------+
C     I Sample lambda variable from Kolbig/Schorr Landau distribution I
C     +---------------------------------------------------------------+
C
   10 CONTINUE
      IF (IMODEI.EQ.3) THEN
         XMEAN = -BETA**2-LOG(XI/EMAX)+EULER-1.
         XLAMX = FLAND(XMEAN)
   20    CALL GRNDM(RNDM,1)
         IF( RNDM(1) .GT. 0.980 ) GO TO 20
         XLAMB = GLANDR(RNDM(1))
         IF(XLAMB.GT.XLAMX) GO TO 20
         IFLAG  = 3
C
C            +----------------------------------------------+
C            I  Sample lambda variable from James & Hancock I
C            I  Landau distribution                         I
C            +----------------------------------------------+
C
 
      ELSEIF (IMODEI.EQ.4) THEN
         XMEAN = -BETA**2-LOG(XI/EMAX)+EULER-1.
         XLAMX = FLAND(XMEAN)
  25     CALL GLANDG(XLAMB)
         IF(XLAMB.GT.XLAMX) GO TO 25
         IFLAG = 4
C
C            +---------------------------------------------------------+
C            I Sample lambda variable (Landau not Vavilov) from        I
C            I Rotondi&Montagna&Kolbig Vavilov distribution            I
C            +---------------------------------------------------------+
C
      ELSEIF (IMODEI.EQ.5) THEN
C
C            Keep within computation bounds.
C
         RKA = CAPPA
         BE2 = BETA*BETA
         CALL GRNDM(RNDM,1)
         XLAMB = GVAVIV(RKA,BE2,RNDM(1))
         IFLAG = 5
C
C     +-----------------------------------+
C     I Sample from Gaussian distribution I
C     +-----------------------------------+
C
      ELSEIF (IMODEI.EQ.6) THEN
         SIGMA  = XI*EMAX*(1.-(BETA*BETA/2.))
         SIGMA  = SQRT(SIGMA)
   30    CALL GRNDM(RNDM,2)
         IF(RNDM(1).LE.0.)GO TO 30
         F1     = -2.*LOG(RNDM(1))
         DEKEV  = SIGMA*SQRT(F1)*COS(2.*PI*RNDM(2))
         IFLAG  = 6
         GOTO 40
      ENDIF
C
C     Calculate DE/DX - <DE/DX>
C
      DEKEV  = XI*(XLAMB+BETA*BETA+LOG(XI/EMAX)-EULER+1.)
C
   40 DE=DEKEV*1.E-6
      END
+DECK,GLANDR
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GLANDR(X)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine RANLAN for restricted        *
C.    *  Landau distribution.                                          *
C.    *                                                                *
C.    *    ==>Called by : GLANDO                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION F(-1:1002)
      DATA (F(I),I= -1,100)
     A/     7*0.,                                        -2.244733,
     B -2.204365,-2.168163,-2.135219,-2.104898,-2.076740,-2.050397,
     C -2.025605,-2.002150,-1.979866,-1.958612,-1.938275,-1.918760,
     D -1.899984,-1.881879,-1.864385,-1.847451,-1.831030,-1.815083,
     E -1.799574,-1.784473,-1.769751,-1.755383,-1.741346,-1.727620,
     F -1.714187,-1.701029,-1.688130,-1.675477,-1.663057,-1.650858,
     G -1.638868,-1.627078,-1.615477,-1.604058,-1.592811,-1.581729,
     H -1.570806,-1.560034,-1.549407,-1.538919,-1.528565,-1.518339,
     I -1.508237,-1.498254,-1.488386,-1.478628,-1.468976,-1.459428,
     J -1.449979,-1.440626,-1.431365,-1.422195,-1.413111,-1.404112,
     K -1.395194,-1.386356,-1.377594,-1.368906,-1.360291,-1.351746,
     L -1.343269,-1.334859,-1.326512,-1.318229,-1.310006,-1.301843,
     M -1.293737,-1.285688,-1.277693,-1.269752,-1.261863,-1.254024,
     N -1.246235,-1.238494,-1.230800,-1.223153,-1.215550,-1.207990,
     O -1.200474,-1.192999,-1.185566,-1.178172,-1.170817,-1.163500,
     P -1.156220,-1.148977,-1.141770,-1.134598,-1.127459,-1.120354,
     Q -1.113282,-1.106242,-1.099233,-1.092255/
C
      DATA (F(I),I=101,200)
     A/-1.085306,-1.078388,-1.071498,-1.064636,-1.057802,-1.050996,
     B -1.044215,-1.037461,-1.030733,-1.024029,-1.017350,-1.010695,
     C -1.004064, -.997456, -.990871, -.984308, -.977767, -.971247,
     D  -.964749, -.958271, -.951813, -.945375, -.938957, -.932558,
     E  -.926178, -.919816, -.913472, -.907146, -.900838, -.894547,
     F  -.888272, -.882014, -.875773, -.869547, -.863337, -.857142,
     G  -.850963, -.844798, -.838648, -.832512, -.826390, -.820282,
     H  -.814187, -.808106, -.802038, -.795982, -.789940, -.783909,
     I  -.777891, -.771884, -.765889, -.759906, -.753934, -.747973,
     J  -.742023, -.736084, -.730155, -.724237, -.718328, -.712429,
     K  -.706541, -.700661, -.694791, -.688931, -.683079, -.677236,
     L  -.671402, -.665576, -.659759, -.653950, -.648149, -.642356,
     M  -.636570, -.630793, -.625022, -.619259, -.613503, -.607754,
     N  -.602012, -.596276, -.590548, -.584825, -.579109, -.573399,
     O  -.567695, -.561997, -.556305, -.550618, -.544937, -.539262,
     P  -.533592, -.527926, -.522266, -.516611, -.510961, -.505315,
     Q  -.499674, -.494037, -.488405, -.482777/
C
      DATA (F(I),I=201,300)
     A/ -.477153, -.471533, -.465917, -.460305, -.454697, -.449092,
     B  -.443491, -.437893, -.432299, -.426707, -.421119, -.415534,
     C  -.409951, -.404372, -.398795, -.393221, -.387649, -.382080,
     D  -.376513, -.370949, -.365387, -.359826, -.354268, -.348712,
     E  -.343157, -.337604, -.332053, -.326503, -.320955, -.315408,
     F  -.309863, -.304318, -.298775, -.293233, -.287692, -.282152,
     G  -.276613, -.271074, -.265536, -.259999, -.254462, -.248926,
     H  -.243389, -.237854, -.232318, -.226783, -.221247, -.215712,
     I  -.210176, -.204641, -.199105, -.193568, -.188032, -.182495,
     J  -.176957, -.171419, -.165880, -.160341, -.154800, -.149259,
     K  -.143717, -.138173, -.132629, -.127083, -.121537, -.115989,
     L  -.110439, -.104889, -.099336, -.093782, -.088227, -.082670,
     M  -.077111, -.071550, -.065987, -.060423, -.054856, -.049288,
     N  -.043717, -.038144, -.032569, -.026991, -.021411, -.015828,
     O  -.010243, -.004656,  .000934,  .006527,  .012123,  .017722,
     P   .023323,  .028928,  .034535,  .040146,  .045759,  .051376,
     Q   .056997,  .062620,  .068247,  .073877/
C
      DATA (F(I),I=301,400)
     A/  .079511,  .085149,  .090790,  .096435,  .102083,  .107736,
     B   .113392,  .119052,  .124716,  .130385,  .136057,  .141734,
     C   .147414,  .153100,  .158789,  .164483,  .170181,  .175884,
     D   .181592,  .187304,  .193021,  .198743,  .204469,  .210201,
     E   .215937,  .221678,  .227425,  .233177,  .238933,  .244696,
     F   .250463,  .256236,  .262014,  .267798,  .273587,  .279382,
     G   .285183,  .290989,  .296801,  .302619,  .308443,  .314273,
     H   .320109,  .325951,  .331799,  .337654,  .343515,  .349382,
     I   .355255,  .361135,  .367022,  .372915,  .378815,  .384721,
     J   .390634,  .396554,  .402481,  .408415,  .414356,  .420304,
     K   .426260,  .432222,  .438192,  .444169,  .450153,  .456145,
     L   .462144,  .468151,  .474166,  .480188,  .486218,  .492256,
     M   .498302,  .504356,  .510418,  .516488,  .522566,  .528653,
     N   .534747,  .540850,  .546962,  .553082,  .559210,  .565347,
     O   .571493,  .577648,  .583811,  .589983,  .596164,  .602355,
     P   .608554,  .614762,  .620980,  .627207,  .633444,  .639689,
     Q   .645945,  .652210,  .658484,  .664768/
C
      DATA (F(I),I=401,500)
     A/  .671062,  .677366,  .683680,  .690004,  .696338,  .702682,
     B   .709036,  .715400,  .721775,  .728160,  .734556,  .740963,
     C   .747379,  .753807,  .760246,  .766695,  .773155,  .779627,
     D   .786109,  .792603,  .799107,  .805624,  .812151,  .818690,
     E   .825241,  .831803,  .838377,  .844962,  .851560,  .858170,
     F   .864791,  .871425,  .878071,  .884729,  .891399,  .898082,
     G   .904778,  .911486,  .918206,  .924940,  .931686,  .938446,
     H   .945218,  .952003,  .958802,  .965614,  .972439,  .979278,
     I   .986130,  .992996,  .999875, 1.006769, 1.013676, 1.020597,
     J  1.027533, 1.034482, 1.041446, 1.048424, 1.055417, 1.062424,
     K  1.069446, 1.076482, 1.083534, 1.090600, 1.097681, 1.104778,
     L  1.111889, 1.119016, 1.126159, 1.133316, 1.140490, 1.147679,
     M  1.154884, 1.162105, 1.169342, 1.176595, 1.183864, 1.191149,
     N  1.198451, 1.205770, 1.213105, 1.220457, 1.227826, 1.235211,
     O  1.242614, 1.250034, 1.257471, 1.264926, 1.272398, 1.279888,
     P  1.287395, 1.294921, 1.302464, 1.310026, 1.317605, 1.325203,
     Q  1.332819, 1.340454, 1.348108, 1.355780/
C
      DATA (F(I),I=501,600)
     A/ 1.363472, 1.371182, 1.378912, 1.386660, 1.394429, 1.402216,
     B  1.410024, 1.417851, 1.425698, 1.433565, 1.441453, 1.449360,
     C  1.457288, 1.465237, 1.473206, 1.481196, 1.489208, 1.497240,
     D  1.505293, 1.513368, 1.521465, 1.529583, 1.537723, 1.545885,
     E  1.554068, 1.562275, 1.570503, 1.578754, 1.587028, 1.595325,
     F  1.603644, 1.611987, 1.620353, 1.628743, 1.637156, 1.645593,
     G  1.654053, 1.662538, 1.671047, 1.679581, 1.688139, 1.696721,
     H  1.705329, 1.713961, 1.722619, 1.731303, 1.740011, 1.748746,
     I  1.757506, 1.766293, 1.775106, 1.783945, 1.792810, 1.801703,
     J  1.810623, 1.819569, 1.828543, 1.837545, 1.846574, 1.855631,
     K  1.864717, 1.873830, 1.882972, 1.892143, 1.901343, 1.910572,
     L  1.919830, 1.929117, 1.938434, 1.947781, 1.957158, 1.966566,
     M  1.976004, 1.985473, 1.994972, 2.004503, 2.014065, 2.023659,
     N  2.033285, 2.042943, 2.052633, 2.062355, 2.072110, 2.081899,
     O  2.091720, 2.101575, 2.111464, 2.121386, 2.131343, 2.141334,
     P  2.151360, 2.161421, 2.171517, 2.181648, 2.191815, 2.202018,
     Q  2.212257, 2.222533, 2.232845, 2.243195/
C
      DATA (F(I),I=601,700)
     A/ 2.253582, 2.264006, 2.274468, 2.284968, 2.295507, 2.306084,
     B  2.316701, 2.327356, 2.338051, 2.348786, 2.359562, 2.370377,
     C  2.381234, 2.392131, 2.403070, 2.414051, 2.425073, 2.436138,
     D  2.447246, 2.458397, 2.469591, 2.480828, 2.492110, 2.503436,
     E  2.514807, 2.526222, 2.537684, 2.549190, 2.560743, 2.572343,
     F  2.583989, 2.595682, 2.607423, 2.619212, 2.631050, 2.642936,
     G  2.654871, 2.666855, 2.678890, 2.690975, 2.703110, 2.715297,
     H  2.727535, 2.739825, 2.752168, 2.764563, 2.777012, 2.789514,
     I  2.802070, 2.814681, 2.827347, 2.840069, 2.852846, 2.865680,
     J  2.878570, 2.891518, 2.904524, 2.917588, 2.930712, 2.943894,
     K  2.957136, 2.970439, 2.983802, 2.997227, 3.010714, 3.024263,
     L  3.037875, 3.051551, 3.065290, 3.079095, 3.092965, 3.106900,
     M  3.120902, 3.134971, 3.149107, 3.163312, 3.177585, 3.191928,
     N  3.206340, 3.220824, 3.235378, 3.250005, 3.264704, 3.279477,
     O  3.294323, 3.309244, 3.324240, 3.339312, 3.354461, 3.369687,
     P  3.384992, 3.400375, 3.415838, 3.431381, 3.447005, 3.462711,
     Q  3.478500, 3.494372, 3.510328, 3.526370/
C
      DATA (F(I),I=701,800)
     A/ 3.542497, 3.558711, 3.575012, 3.591402, 3.607881, 3.624450,
     B  3.641111, 3.657863, 3.674708, 3.691646, 3.708680, 3.725809,
     C  3.743034, 3.760357, 3.777779, 3.795300, 3.812921, 3.830645,
     D  3.848470, 3.866400, 3.884434, 3.902574, 3.920821, 3.939176,
     E  3.957640, 3.976215, 3.994901, 4.013699, 4.032612, 4.051639,
     F  4.070783, 4.090045, 4.109425, 4.128925, 4.148547, 4.168292,
     G  4.188160, 4.208154, 4.228275, 4.248524, 4.268903, 4.289413,
     H  4.310056, 4.330832, 4.351745, 4.372794, 4.393982, 4.415310,
     I  4.436781, 4.458395, 4.480154, 4.502060, 4.524114, 4.546319,
     J  4.568676, 4.591187, 4.613854, 4.636678, 4.659662, 4.682807,
     K  4.706116, 4.729590, 4.753231, 4.777041, 4.801024, 4.825179,
     L  4.849511, 4.874020, 4.898710, 4.923582, 4.948639, 4.973883,
     M  4.999316, 5.024942, 5.050761, 5.076778, 5.102993, 5.129411,
     N  5.156034, 5.182864, 5.209903, 5.237156, 5.264625, 5.292312,
     O  5.320220, 5.348354, 5.376714, 5.405306, 5.434131, 5.463193,
     P  5.492496, 5.522042, 5.551836, 5.581880, 5.612178, 5.642734,
     Q  5.673552, 5.704634, 5.735986, 5.767610/
C
      DATA (F(I),I=801,900)
     A/ 5.799512, 5.831694, 5.864161, 5.896918, 5.929968, 5.963316,
     B  5.996967, 6.030925, 6.065194, 6.099780, 6.134687, 6.169921,
     C  6.205486, 6.241387, 6.277630, 6.314220, 6.351163, 6.388465,
     D  6.426130, 6.464166, 6.502578, 6.541371, 6.580553, 6.620130,
     E  6.660109, 6.700495, 6.741297, 6.782520, 6.824173, 6.866262,
     F  6.908795, 6.951780, 6.995225, 7.039137, 7.083525, 7.128398,
     G  7.173764, 7.219632, 7.266011, 7.312910, 7.360339, 7.408308,
     H  7.456827, 7.505905, 7.555554, 7.605785, 7.656608, 7.708035,
     I  7.760077, 7.812747, 7.866057, 7.920019, 7.974647, 8.029953,
     J  8.085952, 8.142657, 8.200083, 8.258245, 8.317158, 8.376837,
     K  8.437300, 8.498562, 8.560641, 8.623554, 8.687319, 8.751955,
     L  8.817481, 8.883916, 8.951282, 9.019600, 9.088889, 9.159174,
     M  9.230477, 9.302822, 9.376233, 9.450735, 9.526355, 9.603118,
     N  9.681054, 9.760191, 9.840558, 9.922186,10.005107,10.089353,
     O 10.174959,10.261958,10.350389,10.440287,10.531693,10.624646,
     P 10.719188,10.815362,10.913214,11.012789,11.114137,11.217307,
     Q 11.322352,11.429325,11.538283,11.649285/
C
      DATA (F(I),I=901,1002)
     A/11.762390,11.877664,11.995170,12.114979,12.237161,12.361791,
     B 12.488946,12.618708,12.751161,12.886394,13.024498,13.165570,
     C 13.309711,13.457026,13.607625,13.761625,13.919145,14.080314,
     D 14.245263,14.414134,14.587072,14.764233,14.945778,15.131877,
     E 15.322712,15.518470,15.719353,15.925570,16.137345,16.354912,
     F 16.578520,16.808433,17.044929,17.288305,17.538873,17.796967,
     G 18.062943,18.337176,18.620068,18.912049,19.213574,19.525133,
     H 19.847249,20.180480,20.525429,20.882738,21.253102,21.637266,
     I 22.036036,22.450278,22.880933,23.329017,23.795634,24.281981,
     J 24.789364,25.319207,25.873062,26.452634,27.059789,27.696581,
     K 28.365274,29.068370,29.808638,30.589157,31.413354,32.285060,
     L 33.208568,34.188705,35.230920,36.341388,37.527131,38.796172,
     M 40.157721,41.622399,43.202525,44.912465,46.769077,48.792279,
     N 51.005773,53.437996,56.123356,59.103894,              20*0./
C.
C.    ------------------------------------------------------------------
C.
      U=1000.0*X
      I=U
      U=U-FLOAT(I)
      GLANDR=F(I)+U*(F(I+1)-F(I))
      IF(I .GE. 70 .AND. I .LE. 800) RETURN
      GLANDR=GLANDR-0.25*U*(1.0-U)*(F(I+2)-F(I+1)-F(I)+F(I-1))
      IF(I .GE.  7 .AND. I .LE. 980) RETURN
      IF(I. LT. 7) THEN
         IF(X.LT.1.E-10)THEN
            V=-30.
         ELSE
            V=LOG(X)
         ENDIF
         U=1.0/V
         GLANDR=((0.99858950+(3.45213058E1+1.70854528E1*U)*U)/
     1           (1.0       +(3.41760202E1+4.01244582  *U)*U))*
     2           (-LOG(-0.91893853-V)-1.0)
      ELSE
         U=1.0-X
         V=U**2
         IF(X .LE. 0.999) THEN
            GLANDR=(1.00060006+2.63991156E2*U+4.37320068E3*V)/
     1             ((1.0       +2.57368075E2*U+3.41448018E3*V)*U)
         ELSE
            GLANDR=(1.00001538+6.07514119E3*U+7.34266409E5*V)/
     1             ((1.0       +6.06511919E3*U+6.94021044E5*V)*U)
         ENDIF
      ENDIF
      END
+DECK,GLANDS.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GLANDS(X)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine DSTLAN (G110)                *
C.    *                                                                *
C.    *    ==>Called by : GVACOE                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P1(0:4),P2(0:3),P3(0:3),P4(0:3),P5(0:3),P6(0:3)
      DIMENSION Q1(0:4),Q2(0:3),Q3(0:3),Q4(0:3),Q5(0:3),Q6(0:3)
      DIMENSION A1(1:3),A2(1:3)
C
      DATA (P1(I),I=0,4),(Q1(J),J=0,4)
     1/ 0.25140 91491E+0,-0.62505 80444E-1, 0.14583 81230E-1,
     2 -0.21088 17737E-2, 0.74112 47290E-3,
     3  1.0             ,-0.55711 75625E-2, 0.62253 10236E-1,
     4 -0.31373 78427E-2, 0.19314 96439E-2/
C
      DATA (P2(I),I=0,3),(Q2(J),J=0,3)
     1/ 0.28683 28584E+0, 0.35643 63231E+0, 0.15235 18695E+0,
     2  0.22513 04883E-1,
     3  1.0             , 0.61911 36137E+0, 0.17207 21448E+0,
     4  0.22785 94771E-1/
C
      DATA (P3(I),I=0,3),(Q3(J),J=0,3)
     1/ 0.28683 29066E+0, 0.30038 28436E+0, 0.99509 51941E-1,
     2  0.87338 27185E-2,
     3  1.0             , 0.42371 90502E+0, 0.10956 31512E+0,
     4  0.86938 51567E-2/
C
      DATA (P4(I),I=0,3),(Q4(J),J=0,3)
     1/ 0.10003 51630E+1, 0.45035 92498E+1, 0.10858 83880E+2,
     2  0.75360 52269E+1,
     3  1.0             , 0.55399 69678E+1, 0.19335 81111E+2,
     4  0.27213 21508E+2/
C
      DATA (P5(I),I=0,3),(Q5(J),J=0,3)
     1/ 0.10000 06517E+1, 0.49094 14111E+2, 0.85055 44753E+2,
     2  0.15321 53455E+3,
     3  1.0             , 0.50099 28881E+2, 0.13998 19104E+3,
     4  0.42000 02909E+3/
C
      DATA (P6(I),I=0,3),(Q6(J),J=0,3)
     1/ 0.10000 00983E+1, 0.13298 68456E+3, 0.91621 49244E+3,
     2 -0.96050 54274E+3,
     3  1.0             , 0.13398 87843E+3, 0.10559 90413E+4,
     4  0.55322 24619E+3/
C
      DATA (A1(I),I=1,3)
     1/-0.45833 33333E+0, 0.66753 47222E+0,-0.16417 41416E+1/
C
      DATA (A2(I),I=1,3)
     1/ 1.0             ,-0.42278 43351E+0,-0.20434 03138E+1/
C
      V=X
      IF(V .LT. -5.5) THEN
       U=EXP(V+1.0)
       GLANDS=0.3989422803*EXP(-1.0/U)*SQRT(U)*
     1        (1.0+(A1(1)+(A1(2)+A1(3)*U)*U)*U)
      ELSE IF(V .LT. -1.0) THEN
       U=EXP(-V-1.0)
       GLANDS=(EXP(-U)/SQRT(U))*
     1        (P1(0)+(P1(1)+(P1(2)+(P1(3)+P1(4)*V)*V)*V)*V)/
     2        (Q1(0)+(Q1(1)+(Q1(2)+(Q1(3)+Q1(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 1.0) THEN
       GLANDS=(P2(0)+(P2(1)+(P2(2)+P2(3)*V)*V)*V)/
     1        (Q2(0)+(Q2(1)+(Q2(2)+Q2(3)*V)*V)*V)
      ELSE IF(V .LT. 4.0) THEN
       GLANDS=(P3(0)+(P3(1)+(P3(2)+P3(3)*V)*V)*V)/
     1        (Q3(0)+(Q3(1)+(Q3(2)+Q3(3)*V)*V)*V)
      ELSE IF(V .LT. 12.0) THEN
       U=1.0/V
       GLANDS=(P4(0)+(P4(1)+(P4(2)+P4(3)*U)*U)*U)/
     1        (Q4(0)+(Q4(1)+(Q4(2)+Q4(3)*U)*U)*U)
      ELSE IF(V .LT. 50.0) THEN
       U=1.0/V
       GLANDS=(P5(0)+(P5(1)+(P5(2)+P5(3)*U)*U)*U)/
     1        (Q5(0)+(Q5(1)+(Q5(2)+Q5(3)*U)*U)*U)
      ELSE IF(V .LT. 300.0) THEN
       U=1.0/V
       GLANDS=(P6(0)+(P6(1)+(P6(2)+P6(3)*U)*U)*U)/
     1        (Q6(0)+(Q6(1)+(Q6(2)+Q6(3)*U)*U)*U)
      ELSE
       U=1.0/(V-V*LOG(V)/(V+1.0))
       GLANDS=1.0-(A2(1)+(A2(2)+A2(3)*U)*U)*U
      END IF
      RETURN
      END
 
+DECK,GLANDZ.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GLANDZ(Z,STEP,P,E,DEDX,DE,POTI,POTIL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Energy straggling using a Monte Carlo model.                  *
C.    *  It can be used with or without delta ray generation.          *
C.    *                                                                *
C.    *   It is a NEW VERSION of the model , which reproduces          *
C.    *   the experimental data rather well.                           *
C.    *                                                                *
C.    *  Input : STEP  = current step-length (cm)                      *
C.    *                                                                *
C.    *  Output: DE    = actual energy loss (Gev)                      *
C.    *                 ( NOT the fluctuation DE/DX-<DE/DX> !)         *
C.    *                                                                *
C.    *     ==> Called by : GTELEC,GTHADR,GTMUON                       *
C.    *                                                                *
C.    *  Author      : L.Urban                                         *
C.    *  Date        : 28.04.1988       Last update :  1.02.90         *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP.
+SEQ,GCFLAG
+SEQ,GCKINE.
+SEQ,GCCUTS.
      PARAMETER (MAXRND=100)
      DIMENSION RNDM(MAXRND),APOIS(3),NPOIS(3),FPOIS(3)
+SELF,IF=-SINGLE.
      DOUBLE PRECISION E1,E2,P2,B2,BG2,TM,DEC,W,WW,WWW,RR
      DOUBLE PRECISION X,AK,ALFA,EA,SA,AKL,REALK,FPOIS
      DOUBLE PRECISION ONE,HALF,ZERO
      PARAMETER (HMXINT=2**30)
+SELF,IF=SINGLE.
      PARAMETER (HMXINT=2**45)
+SELF.
      PARAMETER (ONE=1,HALF=ONE/2,ZERO=0)
      PARAMETER (RCD=0.40, RCD1=1.-RCD, PROBLM=0.01)
      PARAMETER( C1=4, C2=16)
*
*     ------------------------------------------------------------------
*
*     POTI=1.6E-8*Z**0.9
*     POTIL=LOG(POTI)
*
      IF(Z.GT.2.) THEN
         F2=2./Z
      ELSE
         F2=0.
      ENDIF
      F1=1.-F2
*
      E2 = 1.E-8*Z*Z
      E2L= LOG(E2)
      E1L= (POTIL-F2*E2L)/F1
      E1 = EXP(E1L)
*
*
      P2=P*P
      B2=P2/(E*E)
      BG2=P2/(AMASS*AMASS)
      IF(ITRTYP.EQ.2) THEN
         TM=P2/(E+EMASS)
         IF(CHARGE.LT.0.) TM=TM/2.
         TM=TM-POTI
         IF(TM.GT.DCUTE) TM=DCUTE
      ELSE
         TM=EMASS*P2/(0.5*AMASS*AMASS+EMASS*E)
         TM=TM-POTI
         IF(TM.GT.DCUTM) TM=DCUTM
      ENDIF
*
*
* *** Protection against negative TM    ---------------------
*     TM can be negative only for heavy particles with  a very
*     low kinetic energy (e.g. for proton with T  100-300 kev)
      TM=MAX(TM,ZERO)
*
      W  = TM+POTI
      WW = W/POTI
      WWW= 2.*EMASS*BG2
      WL = LOG(WWW)
      CSB=STEP*RCD1*DEDX/(WL-POTIL-B2)
      APOIS(1)=CSB*F1*(WL-E1L-B2)/E1
      APOIS(2)=CSB*F2*(WL-E2L-B2)/E2
*
      IF(TM.GT.0.) THEN
         APOIS(3)=RCD*DEDX*STEP*TM/(POTI*W*LOG(WW))
      ELSE
         APOIS(1)=APOIS(1)/RCD1
         APOIS(2)=APOIS(2)/RCD1
         APOIS(3)=0.
      ENDIF
*
*    calculate the probability of the zero energy loss
*
      APSUM=APOIS(1)+APOIS(2)+APOIS(3)
      IF(APSUM.LT.50.) THEN
         PROB=EXP(-APSUM)
      ELSE
         PROB=0.
      ENDIF
*
*
*      do it differently if prob > problm  <====================
      IF(PROB.GT.PROBLM) THEN
         E0=1.E-8
         EMEAN=DEDX*STEP
         IF(TM.LE.0.) THEN
*      excitation only ....
            APOIS(1)=EMEAN/E0
*
            CALL GPOISS(APOIS,NPOIS,1)
            FPOIS(1)=NPOIS(1)
            DE=FPOIS(1)*E0
*
         ELSE
*         ionization only ....
            EM=TM+E0
            APOIS(1)=EMEAN*(EM-E0)/(EM*E0*LOG(EM/E0))
            CALL GPOISS(APOIS,NPOIS,1)
            NN=NPOIS(1)
            DE=0.
*
            IF(NN.GT.0) THEN
               RCORR=1.
               IF(NN.GT.MAXRND) THEN
                  RCORR=FLOAT(NN)/MAXRND
                  NN=MAXRND
*
               ENDIF
               W=(EM-E0)/EM
               CALL GRNDM(RNDM,NN)
               DO 10 I=1,NN
                  DE=DE+E0/(1.-W*RNDM(I))
   10          CONTINUE
               DE=RCORR*DE
*
            ENDIF
         ENDIF
         GOTO 999
      ENDIF
*
      IF(MAX(APOIS(1),APOIS(2),APOIS(3)).LT.HMXINT) THEN
         CALL GPOISS(APOIS,NPOIS,3)
         FPOIS(1)=NPOIS(1)
         FPOIS(2)=NPOIS(2)
         FPOIS(3)=NPOIS(3)
      ELSE
         DO 20 JPOIS=1, 3
            IF(APOIS(JPOIS).LT.HMXINT) THEN
               CALL GPOISS(APOIS(JPOIS),NPOIS(JPOIS),1)
               FPOIS(JPOIS)=NPOIS(JPOIS)
            ELSE
               CALL GRNDM(RNDM,2)
               FPOIS(JPOIS)=ABS(SQRT(-2.*LOG(RNDM(1)*ONE)
     +         *APOIS(JPOIS))*SIN(TWOPI*RNDM(2)*ONE)+APOIS(JPOIS))
            ENDIF
   20    CONTINUE
      ENDIF
 
*
*          Now we have all three numbers in REAL/DOUBLE
*          variables. REALK is actually an INTEGER that now may
*          exceed the machine representation limit for integers.
*
      DE=FPOIS(1)*E1+FPOIS(2)*E2
*
*     smear to avoid peaks in the energy loss (note: E1<<E2)
*
      IF(DE.GT.0.) THEN
         CALL GRNDM(RNDM,1)
         DE=DE+E1*(1.-2.*RNDM(1))
      ENDIF
*
      ALFA=1.
      REALK=0
      DEC=0.
*
      ANC=FPOIS(3)
      IF(ANC.GE.C2) THEN
         R=ANC/(C2+ANC)
         AN=ANC*R
         SN=C1*R
         CALL GRNDM(RNDM,2)
         RR=SQRT(-2.*LOG(RNDM(1)))
         PHI=TWOPI*RNDM(2)
         X=RR*COS(PHI)
         AK=AN+SN*X
         ALFA=WW*(C2+ANC)/(C2*WW+ANC)
         EA=AK*POTI*ALFA*LOG(ALFA)/(ALFA-1.)
         SA=SQRT(ABS(AK*ALFA*POTI*POTI-EA*EA/AK))
         AKL=(EA-C1*SA)/POTI
         IF(AK.LE.AKL) THEN
            X=RR*SIN(PHI)
            DEC=EA+SA*X
            REALK=AK+HALF-MOD(AK+HALF,ONE)
         ELSE
            ALFA=1.
         ENDIF
      ENDIF
      NN=NINT(FPOIS(3)-REALK)
      IF(NN.GT.MAXRND) THEN
         W=1.-ALFA/WW
         WW=POTI*ALFA
*
*     Here we take a gaussian distribution to avoid loosing
*     too much time in computing
*
         AVERAG=-LOG(1.-W)/W
         SIGMA =SQRT(NN*(1./(1.-W)-AVERAG**2))
         CALL GRNDM(RNDM,2)
         DEC   = DEC+WW*(NN*AVERAG+SIGMA*SQRT(-2.*LOG(RNDM(1)))*
     +           SIN(TWOPI*RNDM(2)))
         DE=DE+DEC
      ELSEIF(NN.GT.0) THEN
         W=1.-ALFA/WW
         WW=POTI*ALFA
         CALL GRNDM(RNDM,NN)
         DO 30 I=1,NN
            DEC=DEC+WW/(1.-W*RNDM(I))
   30    CONTINUE
         DE=DE+DEC
      ENDIF
*
  999 CONTINUE
      END
+DECK,GLISUR
*CMZ :  3.21/02 03/07/94  19.08.44  by  S.Giani
*-- Author :
      SUBROUTINE GLISUR(X0,X1,MEDI0,MEDI1,U,PDOTU,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  This routine simulates the surface profile of a boundary      *
C.    *  between two media as seen by an approaching particle with     *
C.    *  coordinates and direction given by X0. The surface is         *
C.    *  identified by the arguments MEDI0 and MEDI1 which are the     *
C.    *  media indices of the region in which the track is presently   *
C.    *  and the one which it approaches, respectively. The input      *
C.    *  vector X1 contains the coordinates of a point on the other    *
C.    *  side of the boundary from X0, and lying within medium MEDI1.  *
C.    *  The result is a unit vector U normal to the surface of        *
C.    *  reflection at X0 and pointing into the medium from which the  *
C.    *  track is approaching. The quality of the surface finish is    *
C.    *  described by the parameter POLISH, which varies from 0 to 1.  *
C.    *  POLISH=0 means maximum roughness, with effective plane of     *
C.    *  reflection distributed as cos(alpha), where alpha is the      *
C.    *  angle between the unit normal to the effective plane of       *
C.    *  reflection and the normal to the nominal medium boundary at   *
C.    *  X0. POLISH=1 means perfect smoothness. In between the surface *
C.    *  is modeled by a bell-shaped distribution in alpha, with       *
C.    *  limits defined by                                             *
C.    *              sin(alpha) = +/- (1-POLISH)                       *
C.    *  At the interface between two media, the surface POLISH        *
C.    *  parameter is taken from a user routine GUPLSH(MEDI0,MEDI1).   *
C.    *  The indices MEDI0 and MEDI1 refer to the media declared by    *
C.    *  the user. If GGPERP returns an error, there was a precision   *
C.    *  problem with the tracking, and point X0 is on the same side   *
C.    *  of the surface as X1. In this case (or any other error        *
C.    *  condition from GGPERP) a return is made with IERR ^=0. If     *
C.    *  IERR=0 on return then U contains a valid unit vector.         *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    F.Carminati, R.Jones ***********               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCVOLU.
+SEQ,GCVOL1.
C
      REAL X0(6),X1(3),U(3)
      REAL D(3),RNDM(3)
 
*
* *** Decide which volume defines the surface
      IF (NLEVEL.GE.NLEVL1) THEN
         LVOL = 1
      ELSE
         LVOL = -1
         DO 10 I=2,NLEVEL
            IF ((NAMES1(I).NE.NAMES(I)).OR. (NUMBR1(I).NE.NUMBER(I)))
     +      LVOL = 1
   10    CONTINUE
      END IF
*
* *** Find the nominal unit normal to the surface
      IF (LVOL.EQ.1) THEN
         CALL GGPERP(X0,U,IERR)
      ELSE
         LVOL = NLEVEL
         NLEVEL = NLEVL1
         CALL GGPERP(X0,U,IERR)
         U(1) = -U(1)
         U(2) = -U(2)
         U(3) = -U(3)
         NLEVEL = LVOL
      END IF
      IF (IERR.NE.0) GO TO 999
      PDOTU = X0(4)*U(1) + X0(5)*U(2) + X0(6)*U(3)
      POLISH=GUPLSH(MEDI0,MEDI1)
      IF (POLISH.LT.1.) THEN
*
* *** Generate distortion vector D within a uniform sphere
         DIAM = 2.*(1.-POLISH)
         DIA2 = DIAM**2
         IROUND = 0
   20    IF(IROUND.GT.5) GO TO 999
         IROUND = IROUND+1
         CALL GRNDM(RNDM,3)
         D(1) = RNDM(1)-0.5
         D(2) = RNDM(2)-0.5
         D(3) = RNDM(3)-0.5
         D2 = D(1)**2+D(2)**2+D(3)**2
         IF (D2.GT.0.25) GO TO 20
         D(1) = D(1)*DIAM
         D(2) = D(2)*DIAM
         D(3) = D(3)*DIAM
         D2 = D2*DIA2
*
* *** Insure that V=U+D will cause reflection away from surface
         PDOTD = X0(4)*D(1) + X0(5)*D(2) + X0(6)*D(3)
         PDOTV = PDOTU+PDOTD
         UDOTD = U(1)*D(1) + U(2)*D(2) + U(3)*D(3)
         V2 = 1+D2+2*UDOTD
         IF (PDOTD*V2+PDOTV*(1.-D2).GT.0.) GO TO 20
*
* *** Normalize V and call it U
         VABS = 1./SQRT(V2)
         U(1) = (U(1)+D(1))*VABS
         U(2) = (U(2)+D(2))*VABS
         U(3) = (U(3)+D(3))*VABS
         PDOTU = PDOTV*VABS
      END IF
  999 CONTINUE
      END
+DECK,GLOREN
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GLOREN(BETA,PA,PB)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Routine to transform momentum and energy from the        *
C     *       Lorentz frame A to the Lorentz frame B                   *
C     *                                                                *
C     *       PA(1)                                                    *
C     *       PA(2)     Momentum components in frame A                 *
C     *       PA(3)                                                    *
C     *       PA(4)     Energy                                         *
C     *       PB(..)   same quantities in frame B                      *
C     *                                                                *
C     *       BETA(1)    Components of velocity of frame B             *
C     *       BETA(2)        as seen from frame A                      *
C     *       BETA(3)                                                  *
C     *       BETA(4)    1./SQRT(1.-BETA**2)                           *
C.    *                                                                *
C.    *    ==>Called by : GDECAY,GDECA3                                *
C.    *       Author    M.Hansroul  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION BETA(4),PA(4),PB(4)
C.
C.    ------------------------------------------------------------------
C.
      BETPA  = BETA(1)*PA(1) + BETA(2)*PA(2) + BETA(3)*PA(3)
      BPGAM  = (BETPA * BETA(4)/(BETA(4) + 1.) - PA(4)) * BETA(4)
      PB(1) = PA(1) + BPGAM  * BETA(1)
      PB(2) = PA(2) + BPGAM  * BETA(2)
      PB(3) = PA(3) + BPGAM  * BETA(3)
      PB(4) =(PA(4) - BETPA) * BETA(4)
      END
 
+DECK,GMCOUL.    NEW
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMCOUL(OMEGA,DIN)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Generate NSCA single scatters in small angle approxima.  *
C.    *       for a particle with parameters VECT in common /GCTRAK/   *
C.    *                                                                *
C.    *       This subroutine must be called with the correct values   *
C.    *       of the constants OMC & CHC which depend of the medium    *
C.    *                                                                *
C.    *       OMC and CHC are computed at initialisation time (GMOLI)  *
C.    *       No lateral displacement of the particle with respect     *
C.    *       the incident direction is included.                      *
C.    *       No path length correction is included                    *
C.    *                                                                *
C.    *       Output angles overwrite VECT                             *
C.    *                                                                *
C.    *    ==>Called by : GMULTS                                       *
C.    *         Author G. Lynch (LBL)  (adapted by M. Maire  1.02.90)  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCTRAK
+SEQ,GCONSP,GCMULO
      PARAMETER (NSCMX = 50)
      DIMENSION DIN(3),RNDM(2*NSCMX)
      PARAMETER (OMCF=1.167)
*
*     ------------------------------------------------------------------
*
* *** Compute number of scatters (Poisson distr. with mean OMEGA0)
*
      OMEGA0 = OMCF*OMEGA
      CALL GPOISS (OMEGA0,NSCA,1)
      IF (NSCA.LE.0)THEN
         DIN(1) = 0.
         DIN(2) = 0.
         DIN(3) = 1.
         RETURN
      ENDIF
      NSCA = MIN(NSCA,NSCMX)
      CALL GRNDM (RNDM,2*NSCA)
*
* *** THMIN2 is the screening angle
      THMIN2 = (CHCMOL**2)/(OMCF*OMCMOL*(VECT(7)**2))
*
      SUMX = 0.
      SUMY = 0.
      DO 12 I=1,NSCA
         THET  = SQRT(THMIN2*((1./RNDM(I)) - 1.))
         PHI   = TWOPI*RNDM(NSCA+I)
         SUMX  = SUMX + THET*COS(PHI)
         SUMY  = SUMY + THET*SIN(PHI)
   12 CONTINUE
      THETA  = SQRT(SUMX**2 + SUMY**2)
      IF(THETA.NE.0.) THEN
      COSTH  = COS(THETA)
      SINTH  = SIN(THETA)
      CSPHI  = SUMX/THETA
      SNPHI  = SUMY/THETA
*
      DIN(1) = SINTH*CSPHI
      DIN(2) = SINTH*SNPHI
      DIN(3) = COSTH
      ELSE
         DIN(1) = 0.
         DIN(2) = 0.
         DIN(3) = 1.
      ENDIF
*
      END
+DECK,GMGAUS.    EX GMUL
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMGAUS(BETA2,DIN)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Compute multiple scattering angles for a particle        *
C.    *       with parameters VECT in common /GCTRAK/                  *
C.    *       in current medium described in common /GCMATE/           *
C.    *       Output angles overwrite VECT                             *
C.    *                                                                *
C.    *    ==>Called by : GMULTS                                       *
C.    *       Authors    R.Brun, M.Maire, G.Lynch  *********           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCTRAK,GCPHYS.
+SEQ,GCMULO.
+SEQ,GCONSP.
      DIMENSION DIN(3),RNDM(3)
*
*     ------------------------------------------------------------------
*
* *** Computes mean deviation angles in radian
*
*     Scattering corresponding to OMEGA0 = 4E4 scatters and F=0.98.
*
      SIGMA  = 2.557 * CHCMOL*SQRT(STMULS)/(GETOT*BETA2)
*
      CALL GRNDM(RNDM,3)
      PHI = TWOPI*RNDM(2)
      THETA  = SIGMA*SQRT(-2.*LOG(RNDM(1)))
      IF(RNDM(3).GT.0.5)THETA=-THETA
      SINT   = SIN(THETA)
      DIN(1) = SINT*SIN(PHI)
      DIN(2) = SINT*COS(PHI)
      DIN(3) = COS(THETA)
*
      END
+DECK,GMOL4
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMOL4(Y,X,VAL,ARG,EPS,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    * ROUTINE TAKEN FROM IBM SCIENTIFIC SUBROUTINE PACKAGE           *
C.    *                                                                *
C.    * 4 POINT CONTINUED FRACTION INTERPOLATION                       *
C.    * Y=INTERPOLATED VALUE FOR THE ARGUMENT X .                      *
C.    * VAL=VALUE ARRAY .                                              *
C.    * ARG=ARGUMENT ARRAY .                                           *
C.    * EPS=DESIRED ACCURACY .                                         *
C.    * OUTPUT ERROR PARAMETER IER = 0 ACCURACY O.K.                   *
C.    *                            = 1 ACCURACY CAN NOT BE TESTED      *
C.    *                                IN 4TH ORDER INTERPOLATION .    *
C.    *                            = 2 TWO IDENTICAL ELEMENTS IN THE   *
C.    *                                ARGUMENT ARRAY .                *
C.    *                                                                *
C.    *    ==>Called by : GMOLIE                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION ARG(4),VAL(4)
C.
C.    ------------------------------------------------------------------
C.
      IER=1
      Y=VAL(1)
      P2=1.
      P3=Y
      Q2=0.
      Q3=1.
      DO 16 I=2,4
         II=0
         P1=P2
         P2=P3
         Q1=Q2
         Q2=Q3
         Z=Y
         JEND=I-1
   3     AUX=VAL(I)
         DO 10 J=1,JEND
            H=VAL(I)-VAL(J)
            IF(ABS(H).GT.1.E-6*ABS(VAL(I)))GO TO 9
            IF(ARG(I).EQ.ARG(J))GO TO 17
            IF(J.LT.JEND)GO TO 8
            II=II+1
            III=I+II
            IF(III.GT.4)GO TO 19
            VAL(I)=VAL(III)
            VAL(III)=AUX
            AUX=ARG(I)
            ARG(I)=ARG(III)
            ARG(III)=AUX
            GO TO 3
   8        VAL(I)=1.E36
            GO TO 10
   9        VAL(I)=(ARG(I)-ARG(J))/H
  10     CONTINUE
         P3=VAL(I)*P2+(X-ARG(I-1))*P1
         Q3=VAL(I)*Q2+(X-ARG(I-1))*Q1
         IF(Q3.NE.0.)THEN
            Y=P3/Q3
         ELSE
            Y=1.E36
         ENDIF
         DELT=ABS(Z-Y)
         IF(DELT.LE.EPS)GO TO 19
  16  CONTINUE
      RETURN
  17  IER=2
      RETURN
  19  IER=0
      END
+DECK,GMOLI.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMOLI (AC,ZC,WMAT,NLM,DENS,OMC,CHC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering.                                                *
C.    *                                                                *
C.    * WMAT=proportion by weight of NLM  individual constituents of   *
C.    *      charge ZC and atomic weight AC for the mixture/compound   *
C.    * DENS=density in gm/cm**3                                       *
C.    * Warning : the beta and charge dependance of ZX is omitted      *
C.    *                                                                *
C.    *    ==>Called by : GPROBI                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DIMENSION WMAT(*),AC(*),ZC(*)
      PARAMETER (ZETA=1)
*
*     ------------------------------------------------------------------
*
      ZS=0.
      ZE=0.
      ZX=0.
      DO 15 I=1,NLM
         TMP=(WMAT(I)/AC(I))*ZC(I)*(ZC(I)+ZETA)
         ZS=ZS+TMP
         ZE=ZE-0.66666*TMP*LOG(ZC(I))
         ZX=ZX+TMP*LOG(1.+3.34*(ZC(I)/137.036)**2)
15    CONTINUE
      CHC=0.39612E-3*SQRT(DENS*ZS)
      OMC=6702.33*ZS*DENS*EXP((ZE-ZX)/ZS)
*
      END
+DECK,GMOLI1,IF=VER314
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMOLI1(AC,ZC,DENS,BETA2,OMC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering (case of a simple material)                     *
C.    *                                                                *
C.    *    ==>Called by : GMULOF                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DATA ZETA / 1. /
*
*     ------------------------------------------------------------------
*
      ZS=(1./AC)*ZC*(ZC+ZETA)
      ZE=-0.66666*ZS*LOG(ZC)
      ZX=ZS*LOG(1.+3.34*(ZC/(BETA2*137.036))**2)
      OMC=6702.33*ZS*DENS*EXP((ZE-ZX)/ZS)
*
      END
+DECK,GMOLI2,IF=VER314
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMOLI2(AC,ZC,WMAT,NLM,DENS,BETA2,OMC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering.                                                *
C.    *                                                                *
C.    * WMAT=proportion by weight of NLM  individual constituents of   *
C.    *      charge ZC and atomic weight AC for the mixture/compound   *
C.    * DENS=density in gm/cm**3                                       *
C.    *                                                                *
C.    *    ==>Called by : GMULOF                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DIMENSION WMAT(1),AC(1),ZC(1)
      DATA ZETA / 1. /
*
*     ------------------------------------------------------------------
*
      ZS=0.
      ZE=0.
      ZX=0.
      DO 15 I=1,NLM
         TMP=(WMAT(I)/AC(I))*ZC(I)*(ZC(I)+ZETA)
         ZS=ZS+TMP
         ZE=ZE-0.66666*TMP*LOG(ZC(I))
         ZX=ZX+TMP*LOG(1.+3.34*(ZC(I)/(BETA2*137.036))**2)
15    CONTINUE
      OMC=6702.33*ZS*DENS*EXP((ZE-ZX)/ZS)
*
      END
 
+DECK,GMOLIE.    EX GMOL
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMOLIE(OMEGA,BETA2,DIN)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Computes MOLIERE multiple scattering for a particle      *
C.    *       with parameters VECT in common /GCTRAK/                  *
C.    *                                                                *
C.    *       This subroutine must be called with the correct values   *
C.    *       of the constants OMC & CHC which depend of the medium    *
C.    *                                                                *
C.    *       OMC AND CHC are computed at initialisation time (GMOLI)  *
C.    *       No lateral displacement of the particle with respect     *
C.    *       the incident direction is included.                      *
C.    *       No path length correction is included                    *
C.    *                                                                *
C.    *  Generation of multiple scattering according to                *
C.    *  Moliere theory corrected for finite angle scattering          *
C.    *                                                                *
C.    *  evolved from Cern library program MLR                         *
C.    *                                                                *
C.    *  OMEGA & CHIC are number of scatterings and critical angle     *
C.    *  of the medium for a given incident particle                   *
C.    *                                                                *
C.    *  COSTH and SINTH are the cosine and sine of the generated      *
C.    *  scattering angle between 0 and 180 degrees                    *
C.    *                                                                *
C.    * THRED(NA)=reduced angles of Moliere theory                     *
C.    *                                                                *
C.    * F0I(NA),F1I(NA),F2I(NA)= integrale of Moliere functions        *
C.    *                                                                *
C.    *  4 point continued fraction interpolation is used to invert    *
C.    *  the total distribution function integral                      *
C.    *                                                                *
C.    * XINT= argument value                                           *
C.    * ARG= argument values of the table (arg,val)                    *
C.    * VAL= function values of the table (arg,val)                    *
C.    * THRI= the resulting interpolated function value                *
C.    *                                                                *
C.    *    ==>Called by : GMOLIE                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCTRAK,GCPHYS.
+SEQ,GCMULO.
+SEQ,GCONSP.
      PARAMETER (ENEPER = 2.7182818)
      DIMENSION DIN(3),RNDM(3)
      DIMENSION TINT(40),ARG(4),VAL(4),THRED(40),F0I(40),F1I(40),F2I(40)
      DATA THRED/
     +   0.00, 0.10, 0.20, 0.30
     +,  0.40, 0.50, 0.60, 0.70
     +,  0.80, 0.90, 1.00, 1.10
     +,  1.20, 1.30, 1.40, 1.50
     +,  1.60, 1.70, 1.80, 1.90
     +,  2.00, 2.20, 2.40, 2.60
     +,  2.80, 3.00, 3.20, 3.40
     +,  3.60, 3.80, 4.00, 5.00
     +,  6.00, 7.00, 8.00, 9.00
     +, 10.00,11.00,12.00,13.00/
      DATA F0I/
     +  0.000000E+00 ,0.995016E-02 ,0.392106E-01 ,0.860688E-01
     + ,0.147856E+00 ,0.221199E+00 ,0.302324E+00 ,0.387374E+00
     + ,0.472708E+00 ,0.555142E+00 ,0.632121E+00 ,0.701803E+00
     + ,0.763072E+00 ,0.815480E+00 ,0.859142E+00 ,0.894601E+00
     + ,0.922695E+00 ,0.944424E+00 ,0.960836E+00 ,0.972948E+00
     + ,0.981684E+00 ,0.992093E+00 ,0.996849E+00 ,0.998841E+00
     + ,0.999606E+00 ,0.999877E+00 ,0.999964E+00 ,0.999990E+00
     + ,0.999998E+00 ,0.999999E+00 ,0.100000E+01 ,0.100000E+01
     + ,0.100000E+01 ,0.100000E+01 ,0.100000E+01 ,0.100000E+01
     + ,1.,1.,1.,1./
      DATA F1I/
     +  0.000000E+00,0.414985E-02,0.154894E-01,0.310312E-01
     + ,0.464438E-01,0.569008E-01,0.580763E-01,0.468264E-01
     + ,0.217924E-01,-0.163419E-01,-0.651205E-01,-0.120503E+00
     + ,-0.178272E+00,-0.233580E+00,-0.282442E+00,-0.321901E+00
     + ,-0.350115E+00,-0.366534E+00,-0.371831E+00,-0.367378E+00
     + ,-0.354994E+00,-0.314803E+00,-0.266539E+00,-0.220551E+00
     + ,-0.181546E+00,-0.150427E+00,-0.126404E+00,-0.107830E+00
     + ,-0.933106E-01,-0.817375E-01,-0.723389E-01,-0.436650E-01
     + ,-0.294700E-01,-0.212940E-01,-0.161406E-01,-0.126604E-01
     + ,-0.102042E-01,-0.840465E-02,-0.704261E-02,-0.598886E-02/
      DATA F2I/
     +  0.0,0.121500E-01,0.454999E-01,0.913000E-01
     + ,0.137300E+00,0.171400E+00,0.183900E+00,0.170300E+00
     + ,0.132200E+00,0.763000E-01,0.126500E-01,-0.473500E-01
     + ,-0.936000E-01,-0.119750E+00,-0.123450E+00,-0.106300E+00
     + ,-0.732800E-01,-0.312400E-01,0.128450E-01,0.528800E-01
     + ,0.844100E-01,0.114710E+00,0.106200E+00,0.765830E-01
     + ,0.435800E-01,0.173950E-01,0.695001E-03,-0.809500E-02
     + ,-0.117355E-01,-0.125449E-01,-0.120280E-01,-0.686530E-02
     + ,-0.385275E-02,-0.231115E-02,-0.147056E-02,-0.982480E-03
     + ,-0.682440E-03,-0.489715E-03,-0.361190E-03,-0.272582E-03/
*
*     ------------------------------------------------------------------
*
*
* *** Compute Theta angle from Moliere distribution
*
      CHIC  = CHCMOL*SQRT(STMULS)/(GETOT*BETA2)
      COSTH=1.
      SINTH=0.
      IF(OMEGA.LE.ENEPER)GO TO 90
      CNST=LOG(OMEGA)
      B=5.
      DO 10 L=1,10
         IF(ABS(B).LT.1.E-10)THEN
            B=1.E-10
         ENDIF
         DB=-(B-LOG(ABS(B))-CNST)/(1.-1./B)
         B=B+DB
         IF(ABS(DB).LE.0.0001)GO TO 20
   10 CONTINUE
      GO TO 90
   20 CONTINUE
      IF(B.LE.0.)GO TO 90
      BINV = 1./B
      TINT(1) = 0.
      DO 30 JA=2,4
         TINT(JA)=F0I(JA)+(F1I(JA)+F2I(JA)*BINV)*BINV
   30 CONTINUE
      NMAX = 4
   40 CONTINUE
      CALL GRNDM(RNDM,3)
      XINT=RNDM(2)
      DO 50 NA=3,40
         IF(NA.GT.NMAX) THEN
            TINT(NA)=F0I(NA)+(F1I(NA)+F2I(NA)*BINV)*BINV
            NMAX=NA
         ENDIF
         IF(XINT.LE.TINT(NA-1)) GO TO 60
   50 CONTINUE
      IF(XINT.LE.TINT(40)) THEN
         NA=40
         GOTO 60
      ELSE
         TMP=1.-(1.-B*(1.-XINT))**5
         IF(TMP.LE.0.)GO TO 40
         THRI=5./TMP
         GO TO 80
      ENDIF
   60 CONTINUE
      NA = MAX(NA-1,3)
      NA3 = NA-3
      DO 70 M=1,4
         NA3M=NA3+M
         ARG(M)=TINT(NA3M)
         VAL(M)=THRED(NA3M)**2
   70 CONTINUE
      F=THRED(NA)*.02
      CALL GMOL4(THRI,XINT,VAL,ARG,F,IER)
   80 CONTINUE
      TH=CHIC*SQRT(ABS(B*THRI))
      IF(TH.GT.PI)GO TO 40
      SINTH=SIN(TH)
      TEST=TH*(RNDM(3))**2
      IF(TEST.GT.SINTH)GO TO 40
      COSTH=COS(TH)
      GOTO 100
   90 CONTINUE
      CALL GRNDM(RNDM,1)
*
* *** Calculate SINE and COSINE of a random angle between 0 and 360 deg
*
  100 PHI = RNDM(1)*TWOPI
*
      DIN(1) = SINTH*SIN(PHI)
      DIN(2) = SINTH*COS(PHI)
      DIN(3) = COSTH
*
      END
+DECK,GMOLIO.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMOLIO(AC,ZC,WMAT,NLM,DENS,BETA2,CHARG2,OMC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering.                                                *
C.    *                                                                *
C.    * WMAT=proportion by weight of NLM  individual constituents of   *
C.    *      charge ZC and atomic weight AC for the mixture/compound   *
C.    * DENS=density in gm/cm**3                                       *
C.    *                                                                *
C.    *    ==>Called by : GMULOF                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DIMENSION WMAT(*),AC(*),ZC(*)
      PARAMETER (ZETA=1.)
*
* *** This is equal to 3.34/137.036**2
*
      PARAMETER (CONST1 = 1.778595E-4)
*
*     ------------------------------------------------------------------
*
      ZS     = 0.
      ZE     = 0.
      ZX     = 0.
      CONST  = CONST1*CHARG2/BETA2
      DO 10 I=1,NLM
         TMP   = (WMAT(I)/AC(I))*ZC(I)*(ZC(I)+ZETA)
         ZS    = ZS+TMP
         ZE    = ZE-0.66666*TMP*LOG(ZC(I))
         ZX    = ZX+TMP*LOG(1.+CONST*ZC(I)**2)
  10  CONTINUE
      OMC    = 6702.33*ZS*DENS*EXP((ZE-ZX)/ZS) * CHARG2
*
      END
 
+DECK,GMOLS,IF=VER314.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMOLS (OMEGA,CHIC,COSTH,SINTH)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generation of multiple scattering according to                *
C.    *  Moliere theory corrected for finite angle scattering          *
C.    *                                                                *
C.    *  evolved from Cern library program MLR                         *
C.    *                                                                *
C.    *  OMEGA & CHIC are number of scatterings and critical angle     *
C.    *  of the medium for a given incident particle                   *
C.    *                                                                *
C.    *  COSTH and SINTH are the cosine and sine of the generated      *
C.    *  scattering angle between 0 and 180 degrees                    *
C.    *                                                                *
C.    * THRED(NA)=reduced angles of Moliere theory                     *
C.    *                                                                *
C.    * F0I(NA),F1I(NA),F2I(NA)= integrale of Moliere functions        *
C.    *                                                                *
C.    *  4 point continued fraction interpolation is used to invert    *
C.    *  the total distribution function integral                      *
C.    *                                                                *
C.    * XINT= argument value                                           *
C.    * ARG= argument values of the table (arg,val)                    *
C.    * VAL= function values of the table (arg,val)                    *
C.    * THRI= the resulting interpolated function value                *
C.    *                                                                *
C.    *    ==>Called by : GMOLIE                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION TINT(40),ARG(4),VAL(4),THRED(40),F0I(40),F1I(40),F2I(40)
      DIMENSION RNDM(1)
      SAVE TINT
      DATA TINT(1)/0./
      DATA THRED/
     *   0.00, 0.10, 0.20, 0.30
     *,  0.40, 0.50, 0.60, 0.70
     *,  0.80, 0.90, 1.00, 1.10
     *,  1.20, 1.30, 1.40, 1.50
     *,  1.60, 1.70, 1.80, 1.90
     *,  2.00, 2.20, 2.40, 2.60
     *,  2.80, 3.00, 3.20, 3.40
     *,  3.60, 3.80, 4.00, 5.00
     *,  6.00, 7.00, 8.00, 9.00
     *, 10.00,11.00,12.00,13.00/
      DATA F0I/
     *  0.000000E+00 ,0.995016E-02 ,0.392106E-01 ,0.860688E-01
     * ,0.147856E+00 ,0.221199E+00 ,0.302324E+00 ,0.387374E+00
     * ,0.472708E+00 ,0.555142E+00 ,0.632121E+00 ,0.701803E+00
     * ,0.763072E+00 ,0.815480E+00 ,0.859142E+00 ,0.894601E+00
     * ,0.922695E+00 ,0.944424E+00 ,0.960836E+00 ,0.972948E+00
     * ,0.981684E+00 ,0.992093E+00 ,0.996849E+00 ,0.998841E+00
     * ,0.999606E+00 ,0.999877E+00 ,0.999964E+00 ,0.999990E+00
     * ,0.999998E+00 ,0.999999E+00 ,0.100000E+01 ,0.100000E+01
     * ,0.100000E+01 ,0.100000E+01 ,0.100000E+01 ,0.100000E+01
     * ,1.,1.,1.,1./
      DATA F1I/
     *  0.000000E+00,0.414985E-02,0.154894E-01,0.310312E-01
     * ,0.464438E-01,0.569008E-01,0.580763E-01,0.468264E-01
     * ,0.217924E-01,-0.163419E-01,-0.651205E-01,-0.120503E+00
     * ,-0.178272E+00,-0.233580E+00,-0.282442E+00,-0.321901E+00
     * ,-0.350115E+00,-0.366534E+00,-0.371831E+00,-0.367378E+00
     * ,-0.354994E+00,-0.314803E+00,-0.266539E+00,-0.220551E+00
     * ,-0.181546E+00,-0.150427E+00,-0.126404E+00,-0.107830E+00
     * ,-0.933106E-01,-0.817375E-01,-0.723389E-01,-0.436650E-01
     * ,-0.294700E-01,-0.212940E-01,-0.161406E-01,-0.126604E-01
     * ,-0.102042E-01,-0.840465E-02,-0.704261E-02,-0.598886E-02/
      DATA F2I/
     *  0.0,0.121500E-01,0.454999E-01,0.913000E-01
     * ,0.137300E+00,0.171400E+00,0.183900E+00,0.170300E+00
     * ,0.132200E+00,0.763000E-01,0.126500E-01,-0.473500E-01
     * ,-0.936000E-01,-0.119750E+00,-0.123450E+00,-0.106300E+00
     * ,-0.732800E-01,-0.312400E-01,0.128450E-01,0.528800E-01
     * ,0.844100E-01,0.114710E+00,0.106200E+00,0.765830E-01
     * ,0.435800E-01,0.173950E-01,0.695001E-03,-0.809500E-02
     * ,-0.117355E-01,-0.125449E-01,-0.120280E-01,-0.686530E-02
     * ,-0.385275E-02,-0.231115E-02,-0.147056E-02,-0.982480E-03
     * ,-0.682440E-03,-0.489715E-03,-0.361190E-03,-0.272582E-03/
*
*     ------------------------------------------------------------------
*
      CNST=LOG(OMEGA)
      IF(CNST.LE.1.)GO TO 190
      B=5.
      DO 20 L=1,10
         IF(ABS(B).LT.1.E-10)THEN
            B=1.E-10
         ENDIF
         DB=-(B-LOG(ABS(B))-CNST)/(1.-1./B)
         B=B+DB
         IF(ABS(DB).LE.0.0001)GO TO 30
  20  CONTINUE
      GO TO 190
  30  CONTINUE
      IF(B.LE.0.)GO TO 190
      BSQ=B*B
  31  CONTINUE
      CALL GRNDM(RNDM,1)
      XINT=RNDM(1)
      DO 50 NA=2,40
         TINT(NA)=F0I(NA)+F1I(NA)/B+F2I(NA)/BSQ
         S=XINT-TINT(NA)
         IF(S.LE.0.)GO TO 60
  50  CONTINUE
      GO TO 180
  60  CONTINUE
      IF(NA.GE.40)THEN
         NA=39
      ELSE
         TINT(NA+1)=F0I(NA+1)+F1I(NA+1)/B+F2I(NA+1)/BSQ
      ENDIF
      IF(NA.LE.2)THEN
         NA=3
         TINT(4)=F0I(4)+F1I(4)/B+F2I(4)/BSQ
      ENDIF
      NA3=NA-3
      DO 70 M=1,4
         NA3M=NA3+M
         ARG(M)=TINT(NA3M)
         VAL(M)=THRED(NA3M)**2
   70 CONTINUE
      F=THRED(NA)/50.
      CALL GMOL4(THRI,XINT,VAL,ARG,F,IER)
 200  CONTINUE
      TH=CHIC*SQRT(ABS(B*THRI))
      IF(TH.GT.3.141593)GO TO 31
      SINTH=SIN(TH)
      CALL GRNDM(RNDM,1)
      TEST=TH*(RNDM(1))**2
      IF(TEST.GT.SINTH)GO TO 31
      COSTH=COS(TH)
      RETURN
 180  CONTINUE
      TMP=1.-(1.-B*(1.-XINT))**5
      IF(TMP.LE.0.)GO TO 31
      THRI=5./TMP
      GO TO 200
 190  CONTINUE
      COSTH=1.
      SINTH=0.
*
      END
+DECK,GMULOF.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMULOF
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates table of steps for multiple scattering             *
C.    *     energy loss and magnetic field for electrons,muons         *
C.    *           (cannot be tabuled for hadrons)                      *
C.    *   : smuls  = min (Tbethe , 10*radl)                            *
C.    *   : sloss  = DEEMAX*GEKIN/DEDX                                 *
C.    *   : sfield = CFLD*P                                            *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, Y.Dufour, M.Maire  *********          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK,GCJLOC.
+SEQ,GCONSP,GCMULO,GCKINE.
+SEQ,GCMATE,GCTRAK,GCKING.
+SEQ,GCTMED,GCCUTS,GCPHYS.
*
      LOGICAL CERKOV
*
*-----------------------------------------------------------------------
*
      SMULS  = BIG
      SLOSS  = BIG
      SFIELD = BIG
      STOPMX = BIG
      STCKOV = BIG
      JPROB  = LQ(JMA-4)
      JMIXT  = LQ(JMA-5)
      OMC    = Q(JPROB+21)
      CHC2   = Q(JPROB+25)**2
      NLMAT=Q(JMA+11)
      NLM=IABS(NLMAT)
      IF (FIELDM.NE.0.) CFLD = 3333.*DEGRAD*TMAXFD/ABS(FIELDM)
*
      IF(ITCKOV.NE.0.AND.IQ(JTM-2).GE.3.AND. LQ(JTM-3)
     +.NE.0.AND.LQ(LQ(JTM-3)-3).NE.0) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag and calculate the
* ***  relevant pointers.
*
         CERKOV = .TRUE.
         JTCKOV = LQ(JTM-3)
         JABSCO = LQ(JTCKOV-1)
         JEFFIC = LQ(JTCKOV-2)
         JINDEX = LQ(JTCKOV-3)
         JCURIN = LQ(JTCKOV-4)
         NPCKOV = Q(JTCKOV+1)
      ELSE
         CERKOV = .FALSE.
      ENDIF
*
* *** Electrons
*
      JRANG = LQ(JMA-15)
      IKCUT = GEKA*LOG10(CUTELE) + GEKB
      GKC   = (CUTELE-ELOW(IKCUT))/(ELOW(IKCUT+1)-ELOW(IKCUT))
      STOPC = (1.-GKC)*Q(JRANG+IKCUT) + GKC*Q(JRANG+IKCUT+1)
      JMULOF = LQ(JTM-1)
      Q(JMULOF+NEK1+1) = IKCUT
      Q(JMULOF+NEK1+2) = STOPC
*
* *** Recompute STMIN ?
*     set STMIN to the range of an electron at energy=CUTELE + 200KeV
*     divided by sqrt(RADL) (important for light materials)
*
      IF(STMIN.LT.0.)THEN
         XES=CUTELE+2.E-4
         IKS = GEKA*LOG10(XES) + GEKB
         GKS   = (XES-ELOW(IKS))/(ELOW(IKS+1)-ELOW(IKS))
         STMIN = (1.-GKS)*Q(JRANG+IKS) + GKS*Q(JRANG+IKS+1) - STOPC
         IF(Q(JTM+7).EQ.0.)THEN
            STMIN = 2.*STMIN/SQRT(RADL)
         ELSE
            STMIN = 5.*STMIN/RADL
         ENDIF
      ENDIF
      Q(JTM+14)=STMIN
*
      DO 10 IEKBIN=1,NEK1
         GEKIN = ELOW(IEKBIN)
         GETOT = GEKIN + EMASS
         PMOM2 = GEKIN*(GETOT+EMASS)
         PMOM  = SQRT(PMOM2)
         BETA2 = PMOM2/(GETOT**2)
*
         IF (IMULS.GT.0.) THEN
            IF(JMIXT.LE.0)THEN
               CALL GMOLIO(A,Z,1.,1,DENS,BETA2,1.,OMC)
            ELSE
               CALL GMOLIO(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +                    NLM,DENS,BETA2,1.,OMC)
            ENDIF
            PMCH2  = PMOM2/CHC2
            TBETHE = (PMCH2*BETA2)/LOG(OMC*PMCH2)
            TMXCOR = 2232.*RADL*PMOM2*BETA2
            SMULS  = MIN(TBETHE,TMXCOR,10.*RADL)
         ENDIF
*
         IF (IFIELD*FIELDM.NE.0.) THEN
            SFIELD = CFLD*PMOM
         ENDIF
*
         IF (ILOSS*DEEMAX.GT.0.) THEN
            IF (IEKBIN.LE.IKCUT) THEN
               STOPMX = 0.
               SLOSS  = 0.
            ELSE
               STOPMX = Q(JRANG+IEKBIN)
               EKF = (1.-DEEMAX)*GEKIN
               IF (EKF.LE.ELOW(1)) EKF = ELOW(1)
               IKF = GEKA*LOG10(EKF) + GEKB
               GKR = (EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
               SLOSS = STOPMX-(1.-GKR)*Q(JRANG+IKF)-GKR*Q(JRANG+IKF+1)
               IF (SLOSS.LE.0.) SLOSS = 0.
               STOPMX = STOPMX-STOPC
               IF (STOPMX.LE.0.) STOPMX = 0.
            ENDIF
         ENDIF
         IF(CERKOV) THEN
            CHARGE = 1.
            VECT(7) = PMOM
            CALL GNCKOV
            STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         ENDIF
*
         STEP = MIN(SMULS,SLOSS,SFIELD,STCKOV)
         IF (STEP.LT.STMIN) THEN
            STEP = MIN(STMIN,STOPMX)
         ENDIF
         Q(JMULOF+IEKBIN) = STEP
   10 CONTINUE
      DO 20 I=1,IKCUT
         Q(JMULOF+I)=0.5*Q(JMULOF+IKCUT+1)
   20 CONTINUE
*
* *** Muons
*
      JRANG = LQ(JMA-16)
      IKCUT = GEKA*LOG10(CUTMUO) + GEKB
      GKC   = (CUTMUO-ELOW(IKCUT))/(ELOW(IKCUT+1)-ELOW(IKCUT))
      STOPC = (1.-GKC)*Q(JRANG+IKCUT) + GKC*Q(JRANG+IKCUT+1)
      JMULOF = LQ(JTM-2)
      Q(JMULOF+NEK1+1)=IKCUT
      Q(JMULOF+NEK1+2)=STOPC
*
      DO 30 IEKBIN=1,NEK1
         GEKIN = ELOW(IEKBIN)
         GETOT = GEKIN + EMMU
         PMOM2 = GEKIN*(GETOT+EMMU)
         PMOM  = SQRT(PMOM2)
         BETA2 = PMOM2/(GETOT**2)
*
         IF (IMULS.GT.0.) THEN
            IF(JMIXT.LE.0)THEN
               CALL GMOLIO(A,Z,1.,1,DENS,BETA2,1.,OMC)
            ELSE
               CALL GMOLIO(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +                    NLM,DENS,BETA2,1.,OMC)
            ENDIF
            PMCH2  = PMOM2/CHC2
            TBETHE = (PMCH2*BETA2)/LOG(OMC*PMCH2)
            TMXCOR = 2232.*RADL*PMOM2*BETA2
            SMULS  = MIN(TBETHE,TMXCOR,10.*RADL)
         ENDIF
*
         IF (IFIELD*FIELDM.NE.0.) THEN
            SFIELD = CFLD*PMOM
         ENDIF
*
         IF (ILOSS*DEEMAX.GT.0.) THEN
            IF (IEKBIN.LE.IKCUT) THEN
               STOPMX = 0.
               SLOSS  = 0.
            ELSE
               STOPMX = Q(JRANG+IEKBIN)
               EKF = (1.-DEEMAX)*GEKIN
               IF (EKF.LE.ELOW(1)) EKF = ELOW(1)
               IKF = GEKA*LOG10(EKF) + GEKB
               GKR = (EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
               SLOSS = STOPMX-(1.-GKR)*Q(JRANG+IKF)-GKR*Q(JRANG+IKF+1)
               IF (SLOSS.LE.0.) SLOSS = 0.
               STOPMX = STOPMX-STOPC
               IF (STOPMX.LE.0.) STOPMX = 0.
            ENDIF
         ENDIF
         IF(CERKOV) THEN
            CHARGE = 1.
            VECT(7) = PMOM
            CALL GNCKOV
            STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         ENDIF
*
         STEP = MIN(SMULS,SLOSS,SFIELD,STCKOV)
         IF (STEP.LT.STMIN) THEN
            STEP = MIN(STMIN,STOPMX)
         ENDIF
         Q(JMULOF+IEKBIN) = STEP
   30 CONTINUE
      DO 40 I=1,IKCUT
         Q(JMULOF+I)=0.5*Q(JMULOF+IKCUT+1)
   40 CONTINUE
*
      END
+DECK,GMULTS.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GMULTS
C
C     ******************************************************************
C     *                                                                *
C     *       Steering routine for the multiple scattering.            *
C     *       select Moliere theory , Gaussian approximation           *
C     *       or single Coulomb scattering depending of their range    *
C     *       of validity.                                             *
C     *                                                                *
C     *    ==>Called by : GTELEC , GTHADR , GTMUON                     *
C.    *       Author     M.Maire  *********                            *
C     *                                                                *
C     ******************************************************************
*
      PARAMETER (THRMOL=50.,THRGAU=0.01)
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCTRAK.
+SEQ,GCKINE.
+SEQ,GCPHYS.
+SEQ,GCMATE.
+SEQ,GCMULO.
      DIMENSION DIN(3)
*
      BETA2 = (VECT(7)/GETOT)**2
      IF(BETA2.LE.0.) RETURN
      IF(IMULS.EQ.3) THEN
         CALL GMGAUS(BETA2,DIN)
*
      ELSE
         CHARG2=CHARGE**2
*
*     Here we decide whether we have to recalculate OMCMOL or not.
*     OMCMOL has been calculated in GMULOF according to a formula
*     which contains the term (1 + 3.34*(Alpha*z*Z/Beta)**2) where
*     z is the incident charge (CHARGE), setting Beta=1 and z=1.
*     We do not recalculate OMCMOL if:
*
*              3.34*(Z*Alpha)**2*((z/Beta)**2-1) << 1
*                   Z**2*(z**2-Beta**2)/Beta**2  << 3.34/Alpha**2 = 5500
*                   Z**2*(z**2-Beta**2)  <= 50.*Beta**2
*
*     We further multiply the first term for the number of elements
*     in the mixture because the approssimation is particularly bad
*     for mixtures so we make the condition more restrictive.
*     All this thanks to Gerry Lynch.
*
         IF(Z**2*(CHARG2-BETA2)*Q(JMA+11).GT.THRMOL*BETA2) THEN
            NLM=Q(JMA+11)
*
            IF(NLM.EQ.1)THEN
               CALL GMOLIO(A,Z,1.,1,DENS,BETA2,CHARG2,OMCMOL)
*
            ELSE
               CALL GMOLIO(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +         NLM,DENS,BETA2,CHARG2,OMCMOL)
*
            ENDIF
         ELSE
            JPROB = LQ(JMA-4)
            OMCMOL = Q(JPROB+21)*CHARG2
*
         ENDIF
*
         OMEGA = OMCMOL*STMULS/BETA2
*
         IF (OMEGA.LE.20.) THEN
            CALL GMCOUL(OMEGA,DIN)
*
         ELSE
            CALL GMOLIE(OMEGA,BETA2,DIN)
*
         ENDIF
      ENDIF
*
* *** Computes rotation matrix around particle direction
* *** Compute new direction cosines
*
      VMM = SQRT(VECT(4)*VECT(4)+VECT(5)*VECT(5))
      IF (VMM.NE.0.) THEN
         PD1=VECT(4)/VMM
         PD2=VECT(5)/VMM
         V4= PD1*VECT(6)*DIN(1) -PD2*DIN(2) +VECT(4)*DIN(3)
         V5= PD2*VECT(6)*DIN(1) +PD1*DIN(2) +VECT(5)*DIN(3)
         V6= -VMM*DIN(1) +VECT(6)*DIN(3)
      ELSE
         V4= DIN(1)
         V5= DIN(2)
         V6= DIN(3)*SIGN(1.,VECT(6))
      ENDIF
*
* *** Renormalize direction cosines
*
      VP = 1./SQRT(V4*V4+V5*V5+V6*V6)
      VECT(4) = V4*VP
      VECT(5) = V5*VP
      VECT(6) = V6*VP
*
      END
+DECK,GPAIRG,T=F77
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
+SELF,IF=HPUX
$OPTIMIZE OFF
+SELF
      SUBROUTINE GPAIRG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates e+e- pair production by photons.                    *
C.    *                                                                *
C.    *  The secondary electron energies are sampled using the         *
C.    *  Coulomb corrected BETHE-HEITLER cross-sections.For this the   *
C.    *   modified version of the random number techniques of          *
C.    *   BUTCHER and MESSEL (NUCL.PHYS,20(1960),15) are employed.     *
C.    *                                                                *
C.    *  NOTE :                                                        *
C.    *  (1) Effects due to the breakdown of the BORN approximation at *
C.    *      low energies are ignored.                                 *
C.    *  (2) The differential cross-section implicitly takes account   *
C.    *      of pair production in both nuclear and atomic electron    *
C.    *      fields. However, triplet production is not generated.     *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCJLOC
+SEQ,GCONSP
+SEQ,GCTRAK
+SEQ,GCKING
+SEQ,GCPHYS
+SEQ,GCCUTS
      DIMENSION NTYPEL(2)
      DIMENSION RNDM(2)
      LOGICAL ROTATE
      PARAMETER (ONE=1,ONETHR=ONE/3,EMAS2=2*EMASS)
C.
C.    ------------------------------------------------------------------
C.
C             If not enough energy : no pair production
C
      EGAM   = VECT(7)
      IF (EGAM.LT.EMAS2) GO TO 999
C
      KCASE  = NAMEC(6)
      IF(IPAIR.NE.1) THEN
         ISTOP  = 2
         NGKINE = 0
         DESTEP = DESTEP + EGAM
         VECT(7)= 0.
         GEKIN  = 0.
         GETOT  = 0.
         GO TO 999
      ENDIF
C
C             For low energy photons approximate the electron energy by
C             sampling from a uniform distribution in the interval
C             EMASS -> EGAM/2.
C
      IF (EGAM.LE.2.1E - 03)THEN
         CALL GRNDM(RNDM,1)
         EEL1   = EMASS + (RNDM(1)*(0.5*EGAM - EMASS))
         GO TO 20
      ENDIF
C
      Z3=Q(JPROB+2)
      F=8.*Q(JPROB+3)
      IF(EGAM.GT.0.05) F=F+8.*Q(JPROB+4)
      X0=EMASS/EGAM
      DX=0.5-X0
      DMIN=544.*X0/Z3
      DMIN2=DMIN*DMIN
      IF(DMIN.LE.1.)THEN
         F10=42.392-7.796*DMIN+1.961*DMIN2-F
         F20=41.405-5.828*DMIN+0.8945*DMIN2-F
      ELSE
         F10=42.24-8.368*LOG(DMIN+0.952)-F
         F20=F10
      ENDIF
C
C             Calculate limit for screening variable,DELTA, to ensure
C             that screening rejection functions always remain
C             positive.
C
      DMAX=EXP((42.24-F)/8.368)-0.952
C
C             Differential cross-section factors which form
C             the coefficients of the screening functions.
C
      DSIG1=DX*DX*F10/3.
      DSIG2=0.5*F20
      BPAR   = DSIG1 / (DSIG1 + DSIG2)
C
C             Decide which screening rejection function to use and
C             sample the electron/photon fractional energy BR.
C
   10 CALL GRNDM(RNDM,2)
      IF(RNDM(1).LT.BPAR)THEN
         X=0.5-DX*RNDM(2)**ONETHR
         IREJ=1
      ELSE
         X=X0+DX*RNDM(2)
         IREJ   = 2
      ENDIF
C
C             Calculate DELTA ensuring positivity.
C
      D=0.25*DMIN/(X*(1.-X))
      IF(D.GE.DMAX) GOTO 10
      D2=D*D
C
C             Calculate F1 and F2 functions using approximations.
C             F10 and F20 are the F1 and F2 functions calculated for the
C             DELTA=DELTA minimum.
C
      IF(D.LE.1.)THEN
         F1=42.392-7.796*D+1.961*D2-F
         F2=41.405-5.828*D+0.8945*D2-F
      ELSE
         F1=42.24-8.368*LOG(D+0.952)-F
         F2=F1
      ENDIF
      IF(IREJ.NE.2)THEN
         SCREJ=F1/F10
      ELSE
         SCREJ=F2/F20
      ENDIF
C
C             Accept or reject on basis of random variate.
C
      CALL GRNDM(RNDM,1)
      IF(RNDM(1).GT.SCREJ) GOTO 10
      EEL1=X*EGAM
C
C             Successful sampling of first electron energy.
C
C             Select charges randomly.
C
   20 NTYPEL(1) = 2
      CALL GRNDM(RNDM,2)
      IF (RNDM(1).GT.0.5) NTYPEL(1) = 3
      NTYPEL(2) = 5 - NTYPEL(1)
C
C             Generate electron decay angles with respect to a Z-axis
C             defined along the parent photon.
C             PHI is generated isotropically and THETA is assigned
C             a universal angular distribution
C
      EMASS1 = EMASS
      THETA  = GBTETH(EEL1, EMASS1, X)*EMASS/EEL1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      PHI    = TWOPI*RNDM(2)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Rotate tracks into GEANT system
C
      CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
      NGKINE = 0
      TEL1 = EEL1 - EMASS
      IF(TEL1.GT.CUTELE) THEN
         PEL1 = SQRT((EEL1+EMASS)*TEL1)
         NGKINE = NGKINE + 1
         GKIN(1,NGKINE) = PEL1 * SINTH * COSPHI
         GKIN(2,NGKINE) = PEL1 * SINTH * SINPHI
         GKIN(3,NGKINE) = PEL1 * COSTH
         GKIN(4,NGKINE) = EEL1
         GKIN(5,NGKINE) = NTYPEL(1)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL1
         IF(NTYPEL(1).EQ.2) CALL GANNI2
      ENDIF
C
C             Momentum vector of second electron. Recoil momentum of
C             target nucleus/electron ignored.
C
      EEL2=EGAM-EEL1
      TEL2=EEL2-EMASS
      IF(TEL2.GT.CUTELE) THEN
         PEL2 = SQRT((EEL2+EMASS)*TEL2)
         NGKINE = NGKINE + 1
         GKIN(1,NGKINE)=-PEL2*SINTH*COSPHI
         GKIN(2,NGKINE)=-PEL2*SINTH*SINPHI
         GKIN(3,NGKINE)=PEL2*COSTH
         GKIN(4,NGKINE)=EEL2
         GKIN(5,NGKINE) = NTYPEL(2)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL2
         IF(NTYPEL(2).EQ.2) CALL GANNI2
      ENDIF
      ISTOP = 1
      IF(NGKINE.EQ.0) ISTOP = 2
 999  CONTINUE
      END
+SELF,IF=HPUX
$OPTIMIZE ON
+SELF
+DECK,GPAIRM
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPAIRM
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates direct pair production by muons                     *
C.    *                                                                *
C.    *    ==>Called by : GTMUON                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCONSP
+SEQ,GCTRAK
+SEQ,GCMATE
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCPHYS
+SEQ,GCCUTS
      DIMENSION RNDM(2)
      LOGICAL ROTATE
C
C         CVM= 3*SQRT(e)*EMMU/4
C         EM6= 6*EMMU**2
      DATA CVM,EM6/0.130652,0.066983/
      DATA AL10T/9.212/
C.
C.    ------------------------------------------------------------------
C.
      IF(GEKIN.LE.PPCUTM)GO TO 900
      EEM1=GETOT
      KCASE=NAMEC(6)
C
      VMIN=4*EMASS/EEM1
      VMAX=1.-CVM*Z**0.333333/EEM1
      IF(VMAX.LE.VMIN)GO TO 900
      VC  = PPCUTM/EEM1
      ALE=LOG(EEM1)
      ALFA=1.+ALE/AL10T
      V0=0.18*(4.+ALE/AL10T)*ALFA*(ALFA*VMIN)**0.6666667
      BETA=0.1*(1.+3.*ALE/AL10T)
      B=0.9/(1.+0.4*ALE+0.022*ALE*ALE)
      AA=1.+2.*B*LOG(VC/V0)
      IF(AA.LE.1.) AA=1.05
      A1=1.-AA
      CC=EXP(-0.25*A1*A1/B)
      A1R=1./A1
      C1=VMAX**A1
      C2=VC**A1
C
C     SAMPLE V AND RO
C
  50  CALL GRNDM(RNDM,2)
      R=RNDM(1)
      V=(R*C1+(1.-R)*C2)**A1R
      IF(V.LE.VMIN) GOTO 50
      IF(V.LT.V0) THEN
        SCREJ=CC*((V-VMIN)/(V0-VMIN))**BETA*(V0/V)**A1
      ELSE
        SCREJ=CC*(V0/V)**(A1+B*LOG(V/V0))
      ENDIF
      IF(RNDM(2).GT.SCREJ) GOTO 50
      R0MAX= SCREJ*(1.-EM6/(EEM1**2*(1.-V)))
      CALL GRNDM(RNDM,2)
      R0   = R0MAX*(2.*RNDM(1)-1.)
C
C           Energies
C
      EPP  = V*EEM1
      IF(IPAIR.NE.1)THEN
         NGKINE=0
         DESTEP=DESTEP+EPP
         GO TO 60
      ENDIF
      EPOS = 0.5*EPP*(1.+R0)
      EMIN = EPP-EPOS
C
C           Angles
C
      THETA = AMASS/EEM1
      SINTH = SIN(THETA)
      COSTH = COS(THETA)
      PHI   = TWOPI*RNDM(2)
      COSPHI= COS(PHI)
      SINPHI= SIN(PHI)
C
      CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C           Positron
C
      NGKINE = 0
      TPOS   = EPOS-EMASS
      IF(TPOS.GT.CUTELE)THEN
         PPOS  = SQRT((EPOS+EMASS)*TPOS)
         NGKINE= NGKINE+1
         GKIN(1,NGKINE)=PPOS*SINTH*COSPHI
         GKIN(2,NGKINE)=PPOS*SINTH*SINPHI
         GKIN(3,NGKINE)=PPOS*COSTH
         GKIN(4,NGKINE)=EPOS
         GKIN(5,NGKINE)=2.
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP=DESTEP+TPOS
         CALL GANNI2
      ENDIF
C
C           Electron
C
      TMIN=EMIN-EMASS
      IF(TMIN.GT.CUTELE)THEN
         PMIN  = SQRT((EMIN+EMASS)*TMIN)
         NGKINE= NGKINE+1
         GKIN(1,NGKINE)=-PMIN*SINTH*COSPHI
         GKIN(2,NGKINE)=-PMIN*SINTH*SINPHI
         GKIN(3,NGKINE)=PMIN*COSTH
         GKIN(4,NGKINE)=EMIN
         GKIN(5,NGKINE)=3.
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP=DESTEP+TMIN
      ENDIF
C
C           Correct muon track
C
  60  GEKIN  = GEKIN-EPP
      GETOT  = GEKIN+AMASS
      VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
      CALL GEKBIN
C
C           Update probabilities
C
 900  CALL GRNDM(RNDM,1)
      ZINTPA = -LOG(RNDM(1))
      SLPAIR = SLENG
      STEPPA = BIG
C
      END
+DECK,GPHAK.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      REAL FUNCTION GPHAK(BET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Photoelectron Angular ditribution from K shell      *
C.    *   from L1 shell ditribution ENTRY GPHAL1                       *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
      DOUBLE PRECISION SAUT1,SAUT2,SAUT3,DRN
      DOUBLE PRECISION COST,SIN2T,X,ANOR,AMAJOR
      DOUBLE PRECISION GAMA,G1,G2,BETA,B1,ONE,HALF
      PARAMETER (BETMAX=0.999999)
      PARAMETER (ONE=1,HALF=ONE/2)
      DIMENSION RAN(2),BETVAL(7),AMAJOR(7)
      DATA BETVAL / 0.8601,0.901,0.9901,0.99901,0.999901,0.9999901,
     +              0.99999901 /
      DATA AMAJOR / 1.02,1.1,4.3,19.,68.,221.,704. /
      DATA ANOR / 0.0 /
C
C L1 shell entry
C
      ENTRY GPHAL1(BET)
C
      BETA = MIN(BET,BETMAX)
      B1 = ONE-BETA
      G2 = ONE/((ONE-BETA)*(ONE+BETA))
      GAMA = SQRT(G2)
      G1 = GAMA-ONE
      DO 10 I = 1,7
       IF(BETA.LE.BETVAL(I)) THEN
        ANOR = AMAJOR(I)*G2
        ANOR = ONE/ANOR
        GO TO 20
       ENDIF
   10 CONTINUE
   20 SAUT2 = HALF*GAMA*G1*(GAMA-2)
      GPHAK = 0.0
   30 CONTINUE
      CALL GRNDM(RAN,2)
      DRN = 2*RAN(1)
      SAUT1 = (DRN-B1)/(DRN*BETA+B1)
      COST = SAUT1
      X = ONE-BETA*COST
      SIN2T = (ONE-COST)*(ONE+COST)
      SAUT3 = SIN2T/(X**2)*(ONE+SAUT2*X)*ANOR
      IF(RAN(2).GT.SAUT3) GO TO 30
      GPHAK = COST
      GPHAL1 = GPHAK
      END
+DECK,GPHAL2.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GPHAL2(BET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Photoelectron Angular ditribution from L2 shell     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
      DOUBLE PRECISION SAUT1,SAUT2,SAUT3,SAUT4,SAUT5,SAUT6,SAUT7
      DOUBLE PRECISION S1,S2,S3,S4,S5,S6,S7,ONE,HALF
      DOUBLE PRECISION COST,SIN2T,X,XI,XI2,XI3,ANOR,DRN
      DOUBLE PRECISION GAMA,G1,G2,G3,G4,G5,BETA,B1
      DOUBLE PRECISION BETVAL,AMAJOR
      PARAMETER(BETMAX=0.999999)
      PARAMETER (ONE=1,HALF=ONE/2)
      DIMENSION BETVAL(15),AMAJOR(15),RAN(2)
      DATA BETVAL / 0.0101,0.101,0.2,0.301,0.401,0.501
     +             ,0.601,0.701,0.801,0.901,0.9901,0.99901
     +             ,0.999901,0.9999901,0.99999901 /
      DATA AMAJOR / 2.05,2.2,2.4,2.6,2.72,3.0,3.2,3.6
     +             ,4.4,6.2,25.,88.,280.,900.,2880. /
      DATA ANOR / 0.0 /
      BETA = MIN(BET,BETMAX)
      B1 = ONE-BETA
      G2 = ONE/((ONE-BETA)*(ONE+BETA))
      GAMA = SQRT(G2)
      G3 = G2*GAMA
      G4 = G2**2
      G5 = G4*GAMA
      G1 = GAMA-ONE
      DO 10 I = 1,15
       IF(BETA.LE.BETVAL(I)) THEN
        ANOR = AMAJOR(I)*G5
        GO TO 20
       ENDIF
   10 CONTINUE
   20 CONTINUE
      ANOR = ONE/ANOR
      S1 = HALF*GAMA*(3*GAMA+1)
      S2 = -0.125D0*G2*(9*G2+30*GAMA-7)
      S3 = 0.25D0*G3*(G3+6*G2+11*GAMA-2)
      S4 = -.125D0*G4*G1*(GAMA+7)
      S5 = 2*(GAMA+ONE)
      S6 = 2*GAMA*(GAMA+ONE)
      S7 = 0.125D0*G4*BETA**2*(3*GAMA+ONE)
      GPHAL2 = 0.0
   30 CONTINUE
      CALL GRNDM(RAN,2)
      DRN = 2*RAN(1)
      COST = (DRN-B1)/(DRN*BETA+B1)
      X = ONE-BETA*COST
      XI  = ONE/X
      XI2 = XI**2
      XI3 = XI**3
      SIN2T = (ONE-COST)*(ONE+COST)
      SAUT1 = S1*XI2
      SAUT2 = S2*XI
      SAUT3 = S3
      SAUT4 = S4*X
      SAUT5 = S5*XI3-S6*XI2-S7*XI
      SAUT6 = SAUT5*SIN2T
      SAUT7 = (SAUT1+SAUT2+SAUT3+SAUT4+SAUT6)*ANOR
      IF(RAN(2).GT.SAUT7) GO TO 30
      GPHAL2 = COST
      END
+DECK,GPHAL3.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GPHAL3(BET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Photoelectron Angular ditribution from L3 shell     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
      DOUBLE PRECISION SAUT1,SAUT2,SAUT3,SAUT4,SAUT5,SAUT6,SAUT7
      DOUBLE PRECISION S1,S2,S3,S4,S5,S6,S7,BETVAL,AMAJOR
      DOUBLE PRECISION COST,SIN2T,X,XI,XI2,XI3,ANOR,DRN
      DOUBLE PRECISION GAMA,G1,G2,G3,G4,G5,BETA,B1
      PARAMETER(BETMAX=0.999998)
      PARAMETER (ONE=1,HALF=ONE/2)
      DIMENSION BETVAL(13),AMAJOR(13),RAN(2)
      DATA BETVAL / 0.0101,0.101,0.2,0.401,0.601
     +             ,0.701,0.801,0.901,0.9901,0.99901
     +             ,0.999901,0.9999901,0.99999901 /
      DATA AMAJOR / 2.05,2.2,2.3,2.4,2.5,2.6,2.81
     +             ,3.8,15.,54.,176.,560.,1800. /
      DATA ANOR / 0.0 /
      BETA = MIN(BET,BETMAX)
      B1 = ONE-BETA
      G2 = ONE/((ONE-BETA)*(ONE+BETA))
      GAMA = SQRT(G2)
      G3 = G2*GAMA
      G4 = G2**2
      G5 = G4*GAMA
      G1 = GAMA-ONE
      DO 10 I = 1,13
       IF(BETA.LE.BETVAL(I)) THEN
        ANOR = AMAJOR(I)*G5
        GO TO 20
       ENDIF
   10 CONTINUE
   20 CONTINUE
      ANOR = ONE/ANOR
      S1 = -HALF*GAMA*(3*GAMA-ONE)
      S2 = G2*(3*G2-ONE)
      S3 = G3*(G3-3*G2+2*GAMA+ONE)
      S4 = HALF*G4*G1*(GAMA-2)
      S5 = 2*(GAMA+ONE)
      S6 = GAMA*(3*GAMA-ONE)*(GAMA+ONE)
      S7 = G2*(G2-1)
      GPHAL3 = 0.0
   30 CONTINUE
      CALL GRNDM(RAN,2)
      DRN = 2*RAN(1)
      COST = (DRN-B1)/(DRN*BETA+B1)
      X = ONE-BETA*COST
      SIN2T = (ONE-COST)*(ONE+COST)
      XI  = ONE/X
      XI2 = XI**2
      XI3 = XI**3
      SAUT1 = S1*XI2
      SAUT2 = S2*XI
      SAUT3 = S3
      SAUT4 = S4*X
      SAUT5 = S5*XI3-S6*XI2-S7*XI
      SAUT6 = SAUT5*SIN2T
      SAUT7 = (SAUT1+SAUT2+SAUT3+SAUT4+SAUT6)*ANOR
      IF(RAN(2).GT.SAUT7) GO TO 30
      GPHAL3 = COST
      END
+DECK,gphini.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHINI
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize material constants for                        *
C.    *       the photoelectric effect                                 *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      CALL GPHRIN
      CALL GSHLIN
      CALL GPHXIN
      END
+DECK,GPHOT
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHOT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  GENERATES PHOTO ELECTRIC MECHANISM                            *
C.    *  Corrected version of L. Urban's routine.                      *
C.    *  Improvements:                                                 *
C.    *    1. Angular distributions of photoelectrons from K-L3 shells *
C.    *    2. Generation of shell decay mode                           *
C.    *    3. Probability of interactioon with a shell = function      *
C.    *       of photon energy                                         *
C.    *                                                                *
C.    *    ==>CALLED BY : GTGAMA                                       *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCPHYS
+SEQ,GCONSP
+SEQ,GCKING
+SEQ,GCCUTS
+SEQ,GCJLOC
+SEQ,GCUNIT
      DIMENSION POT(4),PROB(4),RNA(9)
      EQUIVALENCE (RNA(1),RN01),(RNA(2),RN02),(RNA(3),RN03)
      EQUIVALENCE (RNA(4),RN04),(RNA(5),RN05),(RNA(6),RN06)
      EQUIVALENCE (RNA(7),RN07),(RNA(8),RN08),(RNA(9),RN09)
      EQUIVALENCE (POT(1),POTK),(POT(2),POTL1)
      EQUIVALENCE (POT(3),POTL2),(POT(4),POTL3)
      EQUIVALENCE (PROB(1),PROBK),(PROB(2),PROBL1)
      EQUIVALENCE (PROB(3),PROBL2),(PROB(4),PROBL3)
      SAVE ZINOLD,POT,NSHELL
      DATA ZINOLD / 0.0 /
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(8)
C
C             STOP ELECTRON ?
C
C Check if the photoelectric effect was activated. If not deposit
C gamma & return
      IF(IPHOT.NE.1) THEN
         ISTOP = 2
         NGKINE= 0
         DESTEP = DESTEP + VECT(7)
         VECT(7) = 0.
         GEKIN = 0.
         GETOT = 0.
      ELSE
         E=VECT(7)
         CALL GRNDM(RNA,9)
         JPHXS = LQ(JPHOT-1)
         NZ = Q(JPHXS+1)
         IF(NZ.GT.1) THEN
            QS = 0.0
            QS2 = GPHSG1(E)*RN01
            DO 10 I = 1,NZ-1
               QS1 = GPHSGP(I,E)
               QS = QS+QS1
               IF(QS2.LE.QS) THEN
                  K = I
                  GO TO 20
               ENDIF
   10       CONTINUE
            K = NZ
   20       CONTINUE
            JPHFN = LQ(JPHXS-K)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+K)
         ELSE
            JPHFN = LQ(JPHXS-1)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+1)
         ENDIF
C COPY SHELLS POTENTIALS FROM THE ZEBRA STUCTURE
C Check if this atom was used in last entry
         IF(ZINT.NE.ZINOLD) THEN
            NSHELL = Q(JFN+1)
            DO 30 I = 1,NSHELL
               POT(I) = Q(JFN+1+I)
   30       CONTINUE
            ZINOLD = ZINT
         ENDIF
C Check if E-gamma is bigger than the L3 ionization potential.
C This will make GPHOT a little faster.
         ISHELL = 0
         PROB(1) = 0.
         PROB(2) = 0.
         PROB(3) = 0.
         PROB(4) = 0.
         IF(E.GE.POTL3) THEN
C If ZINT < 5 we can have K shell only, so
            IF(ZINT.LT.5) THEN
               IF(E.GT.POTK) THEN
                  PROBK = 1.
                  TK = E-POTK
                  ISHELL = 1
               ENDIF
            ELSE
C The probabilities given below come from crude approximation
C It uses the jump ratios and assumes that they are valid for the whole energy
C range.
               IF(E.LT.POTL2) THEN
                  PROBL3 = 1.0
                  TK = E-POTL3
                  ISHELL = 4
               ELSE
                  E3 = E-POTL3
                  GAMAL3 = E3/EMASS+1.
                  BETAL3 = SQRT(E3*(E3+2.0*EMASS))/(E+EMASS)
                  E2 = E-POTL2
                  GAMAL2 = E2/EMASS+1.
                  BETAL2 = SQRT(E2*(E2+2.0*EMASS))/(E+EMASS)
                  EFRAC = EMASS/E
                  PROBL3 = GAVRL3(GAMAL3,BETAL3,EFRAC)
                  PROBL2 = GAVRL2(GAMAL2,BETAL2,EFRAC)
                  ANOR = 1./(PROBL3+PROBL2)
                  PROBL3 = PROBL3*ANOR
                  PROBL2 = PROBL2*ANOR
                  IF(E.LT.POTL1) THEN
                     IF(RN02.LT.PROBL3) THEN
                        ISHELL = 4
                        TK = E-POTL3
                     ELSE
                        ISHELL = 3
                        TK = E-POTL2
                     ENDIF
                  ELSE
C Parametrization of L1 jump ratio gives constant 1.2
                     PROBL1 = 1.-1./1.2
                     IF(E.LT.POTK) THEN
                        PROBL2 = (1.-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBL1)*PROBL3
                     ELSE
                        PROBK = 125./ZINT+3.5
                        PROBK = 1.-1/PROBK
                        PROBL1 = (1.-PROBK)*PROBL1
                        PROBL2 = (1.-PROBK-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBK-PROBL1)*PROBL3
                     ENDIF
                     IF(POTL3.LE.0.0) PROBL3 = 0.0
                     IF(POTL2.LE.0.0) PROBL2 = 0.0
                     IF(POTL1.LE.0.0) PROBL1 = 0.0
                     ANOR = PROBK+PROBL1+PROBL2+PROBL3
                     IF(ANOR.GT.0.0) THEN
                        ANOR = 1./ANOR
                        PROBK = PROBK*ANOR
                        PROBL1 = PROBL1*ANOR+PROBK
                        PROBL2 = PROBL2*ANOR+PROBL1
                        PROBL3 = PROBL3*ANOR+PROBL2
                        ISHELL = 4
                        TK = E-POTL3
                        IF(RN02.LE.PROBK) THEN
                           ISHELL = 1
                           TK = E-POTK
                        ELSEIF(RN02.LE.PROBL1) THEN
                           ISHELL = 2
                           TK = E-POTL1
                        ELSEIF(RN02.LE.PROBL2) THEN
                           ISHELL = 3
                           TK = E-POTL2
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
            IF(TK.LE.CUTELE) ISHELL = -ISHELL
         ENDIF
         IF(ISHELL.LT.1) THEN
C None of the shells was chosen because of the CUTELE
            ISTOP = 2
            IF(ISHELL.LT.0) THEN
               DESTEP = DESTEP+TK
            ELSEIF(ISHELL.EQ.0) THEN
               DESTEP = DESTEP+VECT(7)
            ENDIF
            NGKINE= 0
            VECT(7) = 0.
            GEKIN = 0.
            GETOT = 0.
         ELSE
C
C             ENERGY AND MOMENTUM OF PHOTOELECTRON
C
            EEL=TK + EMASS
            PEL=SQRT((TK+2.*EMASS)*TK)
            BETA = PEL/EEL
            ISTOP = 1
            NGKINE = 1
            IF(ISHELL.EQ.1) THEN
               COST = GPHAK(BETA)
            ELSEIF(ISHELL.EQ.2) THEN
               COST = GPHAL1(BETA)
            ELSEIF(ISHELL.EQ.3) THEN
               COST = GPHAL2(BETA)
            ELSEIF(ISHELL.EQ.4) THEN
               COST = GPHAL3(BETA)
            ENDIF
            PHI = TWOPI*RN03
            COSPHI = COS(PHI)
            SINPHI = SIN(PHI)
            SINT = SQRT((1.-COST)*(1.+COST))
            GKIN(1,NGKINE) = PEL*SINT*COSPHI
            GKIN(2,NGKINE) = PEL*SINT*SINPHI
            GKIN(3,NGKINE) = PEL*COST
            GKIN(4,NGKINE) = EEL
            GKIN(5,NGKINE) = 3.
            TOFD(NGKINE) = 0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
C
C             ROTATE ELECTRON AND SCATTERED PHOTON INTO GEANT SYSTEM
C
            CALL GVROT(VECT(4),GKIN)
         ENDIF
         IF(ISHELL.NE.0) THEN
            ISHELL = ABS(ISHELL)
            IF(ZINT.GE.5.AND.POT(ISHELL).GT.MIN(CUTGAM,CUTELE)) THEN
C Generate shell decay mode
               IF(RN04.LE.Q(JFN+1+NSHELL+ISHELL)) THEN
                  IF(POT(ISHELL).LE.CUTGAM) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
C Radiative shell decay
                     JS = JFN+1+2*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 40 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 50
                        ENDIF
   40                CONTINUE
   50                CONTINUE
                  ENDIF
               ELSE
                  IF(POT(ISHELL).LE.CUTELE) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
c Nonradiative decay
                     JS = JFN+1+3*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 60 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTELE) THEN
                              EEL=TSEC + EMASS
                              PEL=SQRT((TSEC+2.*EMASS)*TSEC)
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = PEL*SINT*COSPHI
                              GKIN(2,NGKINE) = PEL*SINT*SINPHI
                              GKIN(3,NGKINE) = PEL*COST
                              GKIN(4,NGKINE) = EEL
                              GKIN(5,NGKINE) = 3.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 70
                        ENDIF
   60                CONTINUE
   70                CONTINUE
                  ENDIF
               ENDIF
            ELSE
               DESTEP = DESTEP+POT(ISHELL)
            ENDIF
         ENDIF
      ENDIF
      END
+DECK,GPHOTI
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHOTI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C     *  for PHOTOELECTRIC EFFECT using the empirical                  *
C     *  formula of L.Urban (see WRITE UP) for Z > 100                 *
C.    *                                                                *
C     *  otherwise Sandia parametrization                              *
C     *   F.Biggs & R. Lighthill, SAND87-0070, UC-34, May 1990         *
C     *                                                                *
C     *  NOTE:                                                         *
C     *  (1) Above 0.050 GeV ( 50 MeV) a cut is imposed as the         *
C     *   contribution from photoeffect is negligible for EGAM.GT.0.050*
C     *  (2) From 10KeV to 100KeV a special parametrization            *
C     *       has been introduced                                      *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,GCMATE
+SEQ,GCJLOC
+SEQ,GCMULO
C.
C.    ------------------------------------------------------------------
C.
C             universal energy cut-off
C
      SIG=0.
      EGAM=ELOW(IEKBIN)
      IF(EGAM.LE.0.05) THEN
C
         IF(Z.GT.100) THEN
C Below good old stuff
            IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
               JPROB=LQ(JMA-4)
               SIG=GPHSIG(Z,EGAM)*AVO*DENS/A
            ELSE
C
C             compound/mixture
C
               NLMAT=Q(JMA+11)
               NLM=IABS(NLMAT)
               SIG=0.
               DO 10 I=1,NLM
                  J=JMIXT+I
                  AA=Q(J)
                  ZZ=Q(J+NLM)
                  WMAT=Q(J+2*NLM)
                  S=GPHSIG(ZZ,EGAM)
                  S=S*WMAT/AA
                  SIG=SIG+AVO*DENS*S
   10          CONTINUE
            ENDIF
C
C
         ELSEIF(Z.GE.1.) THEN
C New x-sections. Sandia parametrization
            JPROB=LQ(JMA-4)
            SIG = 0.0
            IF(EGAM.GE.1.E-8) SIG=GPHSG1(EGAM)*DENS
         ENDIF
      ENDIF
      IF(SIG.GT.0.)THEN
         Q(JPHOT+IEKBIN)=1./SIG
      ELSE
         Q(JPHOT+IEKBIN)=BIG
      ENDIF
C
      END
+DECK,GPHRIN.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHRIN
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize decay mode rates' constants for               *
C.    *       the photoelectric effect                                 *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GPHINI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      IMPLICIT NONE
+CDE,GCPMXZ.
+CDE,GCPHPR.
+CDE,GCPHNR.
+CDE,GCPHRD.
      INTEGER I,J,ITRN
      REAL TMP,TMP1
      DIMENSION TMP(ISHLS,MAXELZ),TMP1(4,MAXELZ)
      DIMENSION ITRN(29)
      DATA ITRN / 3,4,6, 7,11,12,
     +            3,4,6, 7,11,12,18,19,
     +            4,5,8,10,13,17,20,
     +            5,8,9,10,13,14,17,20 /
      DATA (TMP(J,1),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,2),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,3),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,4),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,  5),J=1,ISHLS) /
     +  0.333E+00, 0.667E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.333E+00, 0.667E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  6),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.332E+00, 0.668E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  7),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.332E+00, 0.668E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  8),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.331E+00, 0.669E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  9),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.331E+00, 0.669E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J, 10),J=1,ISHLS) /
     +  0.335E+00, 0.665E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.329E+00, 0.671E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J, 11),J=1,ISHLS) /
     +  0.335E+00, 0.665E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.328E+00, 0.672E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.233E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 12),J=1,ISHLS) /
     +  0.335E+00, 0.665E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.326E+00, 0.674E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.159E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 13),J=1,ISHLS) /
     +  0.333E+00, 0.661E+00, 0.203E-02, 0.404E-02
     +, 0.000E+00, 0.000E+00, 0.291E+00, 0.608E+00
     +, 0.342E-01, 0.663E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.239E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 14),J=1,ISHLS) /
     +  0.330E+00, 0.654E+00, 0.562E-02, 0.111E-01
     +, 0.000E+00, 0.000E+00, 0.216E+00, 0.456E+00
     +, 0.111E+00, 0.216E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.408E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 15),J=1,ISHLS) /
     +  0.325E+00, 0.645E+00, 0.100E-01, 0.199E-01
     +, 0.000E+00, 0.000E+00, 0.141E+00, 0.300E+00
     +, 0.190E+00, 0.369E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.703E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 16),J=1,ISHLS) /
     +  0.321E+00, 0.635E+00, 0.149E-01, 0.296E-01
     +, 0.000E+00, 0.000E+00, 0.881E-01, 0.191E+00
     +, 0.246E+00, 0.475E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.120E-08, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 17),J=1,ISHLS) /
     +  0.315E+00, 0.625E+00, 0.201E-01, 0.398E-01
     +, 0.000E+00, 0.000E+00, 0.559E-01, 0.124E+00
     +, 0.281E+00, 0.540E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.199E-08, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 18),J=1,ISHLS) /
     +  0.314E+00, 0.611E+00, 0.253E-01, 0.500E-01
     +, 0.000E+00, 0.000E+00, 0.368E-01, 0.828E-01
     +, 0.302E+00, 0.579E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.324E-08, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 19),J=1,ISHLS) /
     +  0.307E+00, 0.606E+00, 0.293E-01, 0.580E-01
     +, 0.000E+00, 0.000E+00, 0.260E-01, 0.597E-01
     +, 0.313E+00, 0.601E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.480E-08, 0.976E+00
     +, 0.000E+00, 0.238E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.976E+00, 0.000E+00, 0.000E+00
     +, 0.238E-01,  4*0.0 /
      DATA (TMP(J, 20),J=1,ISHLS) /
     +  0.304E+00, 0.600E+00, 0.323E-01, 0.639E-01
     +, 0.000E+00, 0.000E+00, 0.193E-01, 0.455E-01
     +, 0.321E+00, 0.614E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.678E-08, 0.929E+00
     +, 0.000E+00, 0.709E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.929E+00, 0.000E+00, 0.000E+00
     +, 0.709E-01,  4*0.0 /
      DATA (TMP(J, 21),J=1,ISHLS) /
     +  0.303E+00, 0.597E+00, 0.335E-01, 0.661E-01
     +, 0.000E+00, 0.000E+00, 0.155E-01, 0.376E-01
     +, 0.326E+00, 0.621E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.504E-08, 0.452E+00
     +, 0.513E+00, 0.347E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.461E+00, 0.506E-01, 0.453E+00
     +, 0.353E-01,  4*0.0 /
      DATA (TMP(J, 22),J=1,ISHLS) /
     +  0.303E+00, 0.595E+00, 0.343E-01, 0.677E-01
     +, 0.000E+00, 0.000E+00, 0.128E-01, 0.317E-01
     +, 0.330E+00, 0.626E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.463E-08, 0.276E+00
     +, 0.703E+00, 0.208E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.284E+00, 0.699E-01, 0.624E+00
     +, 0.214E-01,  4*0.0 /
      DATA (TMP(J, 23),J=1,ISHLS) /
     +  0.302E+00, 0.594E+00, 0.350E-01, 0.690E-01
     +, 0.000E+00, 0.000E+00, 0.107E-01, 0.273E-01
     +, 0.333E+00, 0.629E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.471E-08, 0.191E+00
     +, 0.795E+00, 0.139E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.198E+00, 0.793E-01, 0.708E+00
     +, 0.145E-01,  4*0.0 /
      DATA (TMP(J, 24),J=1,ISHLS) /
     +  0.303E+00, 0.594E+00, 0.348E-01, 0.685E-01
     +, 0.000E+00, 0.000E+00, 0.926E-02, 0.245E-01
     +, 0.335E+00, 0.631E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.475E-08, 0.130E+00
     +, 0.861E+00, 0.888E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.136E+00, 0.863E-01, 0.769E+00
     +, 0.910E-02,  4*0.0 /
      DATA (TMP(J, 25),J=1,ISHLS) /
     +  0.302E+00, 0.592E+00, 0.359E-01, 0.708E-01
     +, 0.000E+00, 0.000E+00, 0.778E-02, 0.213E-01
     +, 0.337E+00, 0.633E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.573E-08, 0.111E+00
     +, 0.881E+00, 0.759E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.117E+00, 0.882E-01, 0.787E+00
     +, 0.803E-02,  4*0.0 /
      DATA (TMP(J, 26),J=1,ISHLS) /
     +  0.302E+00, 0.591E+00, 0.363E-01, 0.714E-01
     +, 0.000E+00, 0.000E+00, 0.675E-02, 0.192E-01
     +, 0.339E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.657E-08, 0.900E-01
     +, 0.904E+00, 0.597E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.955E-01, 0.906E-01, 0.807E+00
     +, 0.634E-02,  4*0.0 /
      DATA (TMP(J, 27),J=1,ISHLS) /
     +  0.302E+00, 0.590E+00, 0.366E-01, 0.719E-01
     +, 0.000E+00, 0.000E+00, 0.589E-02, 0.176E-01
     +, 0.341E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.767E-08, 0.751E-01
     +, 0.920E+00, 0.483E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.803E-01, 0.924E-01, 0.822E+00
     +, 0.515E-02,  4*0.0 /
      DATA (TMP(J, 28),J=1,ISHLS) /
     +  0.301E+00, 0.589E+00, 0.369E-01, 0.724E-01
     +, 0.000E+00, 0.000E+00, 0.521E-02, 0.162E-01
     +, 0.343E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.902E-08, 0.640E-01
     +, 0.932E+00, 0.398E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.690E-01, 0.938E-01, 0.833E+00
     +, 0.428E-02,  4*0.0 /
      DATA (TMP(J, 29),J=1,ISHLS) /
     +  0.302E+00, 0.590E+00, 0.366E-01, 0.717E-01
     +, 0.000E+00, 0.000E+00, 0.470E-02, 0.153E-01
     +, 0.345E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.104E-07, 0.537E-01
     +, 0.943E+00, 0.325E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.585E-01, 0.954E-01, 0.845E+00
     +, 0.134E-02,  4*0.0 /
      DATA (TMP(J, 30),J=1,ISHLS) /
     +  0.302E+00, 0.588E+00, 0.373E-01, 0.730E-01
     +, 0.000E+00, 0.000E+00, 0.416E-02, 0.141E-01
     +, 0.347E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.127E-07, 0.488E-01
     +, 0.948E+00, 0.285E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.532E-01, 0.956E-01, 0.848E+00
     +, 0.311E-02,  4*0.0 /
      DATA (TMP(J, 31),J=1,ISHLS) /
     +  0.301E+00, 0.586E+00, 0.381E-01, 0.744E-01
     +, 0.217E-03, 0.414E-03, 0.365E-02, 0.131E-01
     +, 0.346E+00, 0.631E+00, 0.208E-02, 0.373E-02
     +, 0.000E+00, 0.000E+00, 0.153E-07, 0.449E-01
     +, 0.952E+00, 0.345E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.494E-01, 0.958E-01, 0.851E+00
     +, 0.378E-02,  4*0.0 /
      DATA (TMP(J, 32),J=1,ISHLS) /
     +  0.301E+00, 0.583E+00, 0.388E-01, 0.759E-01
     +, 0.633E-03, 0.122E-02, 0.322E-02, 0.121E-01
     +, 0.344E+00, 0.624E+00, 0.595E-02, 0.106E-01
     +, 0.000E+00, 0.000E+00, 0.187E-07, 0.421E-01
     +, 0.954E+00, 0.376E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.465E-01, 0.961E-01, 0.853E+00
     +, 0.414E-02,  4*0.0 /
      DATA (TMP(J, 33),J=1,ISHLS) /
     +  0.299E+00, 0.580E+00, 0.396E-01, 0.772E-01
     +, 0.121E-02, 0.232E-02, 0.282E-02, 0.112E-01
     +, 0.341E+00, 0.614E+00, 0.110E-01, 0.197E-01
     +, 0.000E+00, 0.000E+00, 0.229E-07, 0.398E-01
     +, 0.956E+00, 0.398E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.442E-01, 0.962E-01, 0.855E+00
     +, 0.441E-02,  4*0.0 /
      DATA (TMP(J, 34),J=1,ISHLS) /
     +  0.298E+00, 0.577E+00, 0.403E-01, 0.787E-01
     +, 0.191E-02, 0.368E-02, 0.249E-02, 0.105E-01
     +, 0.336E+00, 0.604E+00, 0.170E-01, 0.302E-01
     +, 0.000E+00, 0.000E+00, 0.279E-07, 0.379E-01
     +, 0.958E+00, 0.414E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.425E-01, 0.964E-01, 0.857E+00
     +, 0.462E-02,  4*0.0 /
      DATA (TMP(J, 35),J=1,ISHLS) /
     +  0.297E+00, 0.574E+00, 0.410E-01, 0.799E-01
     +, 0.273E-02, 0.526E-02, 0.220E-02, 0.979E-02
     +, 0.331E+00, 0.592E+00, 0.235E-01, 0.417E-01
     +, 0.000E+00, 0.000E+00, 0.340E-07, 0.364E-01
     +, 0.959E+00, 0.427E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.411E-01, 0.965E-01, 0.858E+00
     +, 0.480E-02,  4*0.0 /
      DATA (TMP(J, 36),J=1,ISHLS) /
     +  0.296E+00, 0.571E+00, 0.416E-01, 0.812E-01
     +, 0.366E-02, 0.704E-02, 0.194E-02, 0.921E-02
     +, 0.325E+00, 0.579E+00, 0.305E-01, 0.539E-01
     +, 0.000E+00, 0.000E+00, 0.413E-07, 0.352E-01
     +, 0.960E+00, 0.438E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.400E-01, 0.966E-01, 0.858E+00
     +, 0.495E-02,  4*0.0 /
      DATA (TMP(J, 37),J=1,ISHLS) /
     +  0.295E+00, 0.567E+00, 0.423E-01, 0.824E-01
     +, 0.440E-02, 0.855E-02, 0.173E-02, 0.873E-02
     +, 0.321E+00, 0.569E+00, 0.358E-01, 0.636E-01
     +, 0.000E+00, 0.000E+00, 0.502E-07, 0.341E-01
     +, 0.961E+00, 0.463E-02, 0.000E+00, 0.130E-03
     +, 0.000E+00, 0.390E-01, 0.966E-01, 0.859E+00
     +, 0.529E-02, 0.000E+00, 0.000E+00, 0.148E-03, 0.0 /
      DATA (TMP(J, 38),J=1,ISHLS) /
     +  0.294E+00, 0.565E+00, 0.429E-01, 0.837E-01
     +, 0.506E-02, 0.985E-02, 0.155E-02, 0.836E-02
     +, 0.318E+00, 0.560E+00, 0.402E-01, 0.712E-01
     +, 0.000E+00, 0.000E+00, 0.607E-07, 0.331E-01
     +, 0.962E+00, 0.489E-02, 0.000E+00, 0.421E-03
     +, 0.000E+00, 0.382E-01, 0.967E-01, 0.859E+00
     +, 0.561E-02, 0.000E+00, 0.000E+00, 0.484E-03, 0.0 /
      DATA (TMP(J, 39),J=1,ISHLS) /
     +  0.293E+00, 0.562E+00, 0.436E-01, 0.848E-01
     +, 0.554E-02, 0.108E-01, 0.140E-02, 0.807E-02
     +, 0.317E+00, 0.554E+00, 0.432E-01, 0.762E-01
     +, 0.000E+00, 0.000E+00, 0.730E-07, 0.322E-01
     +, 0.957E+00, 0.501E-02, 0.496E-02, 0.465E-03
     +, 0.000E+00, 0.374E-01, 0.962E-01, 0.855E+00
     +, 0.579E-02, 0.494E-03, 0.437E-02, 0.535E-03, 0.0 /
      DATA (TMP(J, 40),J=1,ISHLS) /
     +  0.293E+00, 0.560E+00, 0.441E-01, 0.860E-01
     +, 0.595E-02, 0.116E-01, 0.127E-02, 0.785E-02
     +, 0.316E+00, 0.549E+00, 0.457E-01, 0.802E-01
     +, 0.000E+00, 0.000E+00, 0.871E-07, 0.312E-01
     +, 0.952E+00, 0.508E-02, 0.117E-01, 0.480E-03
     +, 0.000E+00, 0.367E-01, 0.957E-01, 0.850E+00
     +, 0.593E-02, 0.116E-02, 0.103E-01, 0.559E-03, 0.0 /
      DATA (TMP(J, 41),J=1,ISHLS) /
     +  0.292E+00, 0.558E+00, 0.447E-01, 0.871E-01
     +, 0.623E-02, 0.121E-01, 0.116E-02, 0.770E-02
     +, 0.316E+00, 0.546E+00, 0.472E-01, 0.823E-01
     +, 0.000E+00, 0.000E+00, 0.103E-06, 0.303E-01
     +, 0.941E+00, 0.506E-02, 0.232E-01, 0.198E-03
     +, 0.000E+00, 0.359E-01, 0.946E-01, 0.841E+00
     +, 0.595E-02, 0.232E-02, 0.204E-01, 0.233E-03, 0.0 /
      DATA (TMP(J, 42),J=1,ISHLS) /
     +  0.292E+00, 0.556E+00, 0.453E-01, 0.881E-01
     +, 0.656E-02, 0.127E-01, 0.107E-02, 0.758E-02
     +, 0.315E+00, 0.542E+00, 0.491E-01, 0.853E-01
     +, 0.000E+00, 0.000E+00, 0.123E-06, 0.295E-01
     +, 0.933E+00, 0.510E-02, 0.321E-01, 0.194E-03
     +, 0.000E+00, 0.352E-01, 0.939E-01, 0.833E+00
     +, 0.604E-02, 0.319E-02, 0.282E-01, 0.231E-03, 0.0 /
      DATA (TMP(J, 43),J=1,ISHLS) /
     +  0.291E+00, 0.554E+00, 0.458E-01, 0.890E-01
     +, 0.688E-02, 0.133E-01, 0.978E-03, 0.749E-02
     +, 0.315E+00, 0.538E+00, 0.508E-01, 0.878E-01
     +, 0.000E+00, 0.000E+00, 0.145E-06, 0.288E-01
     +, 0.924E+00, 0.510E-02, 0.416E-01, 0.189E-03
     +, 0.000E+00, 0.347E-01, 0.930E-01, 0.825E+00
     +, 0.610E-02, 0.413E-02, 0.364E-01, 0.226E-03, 0.0 /
      DATA (TMP(J, 44),J=1,ISHLS) /
     +  0.291E+00, 0.552E+00, 0.463E-01, 0.901E-01
     +, 0.716E-02, 0.139E-01, 0.902E-03, 0.745E-02
     +, 0.315E+00, 0.535E+00, 0.524E-01, 0.899E-01
     +, 0.000E+00, 0.000E+00, 0.172E-06, 0.281E-01
     +, 0.915E+00, 0.509E-02, 0.515E-01, 0.184E-03
     +, 0.000E+00, 0.341E-01, 0.921E-01, 0.817E+00
     +, 0.614E-02, 0.511E-02, 0.450E-01, 0.222E-03, 0.0 /
      DATA (TMP(J, 45),J=1,ISHLS) /
     +  0.291E+00, 0.550E+00, 0.468E-01, 0.909E-01
     +, 0.742E-02, 0.144E-01, 0.834E-03, 0.744E-02
     +, 0.315E+00, 0.531E+00, 0.538E-01, 0.918E-01
     +, 0.000E+00, 0.000E+00, 0.202E-06, 0.274E-01
     +, 0.906E+00, 0.508E-02, 0.617E-01, 0.177E-03
     +, 0.000E+00, 0.336E-01, 0.911E-01, 0.809E+00
     +, 0.618E-02, 0.612E-02, 0.540E-01, 0.216E-03, 0.0 /
      DATA (TMP(J, 46),J=1,ISHLS) /
     +  0.290E+00, 0.548E+00, 0.472E-01, 0.918E-01
     +, 0.762E-02, 0.147E-01, 0.773E-03, 0.747E-02
     +, 0.315E+00, 0.529E+00, 0.547E-01, 0.925E-01
     +, 0.000E+00, 0.000E+00, 0.236E-06, 0.267E-01
     +, 0.894E+00, 0.502E-02, 0.744E-01, 0.000E+00
     +, 0.000E+00, 0.332E-01, 0.900E-01, 0.799E+00
     +, 0.617E-02, 0.737E-02, 0.646E-01,  2*0.0 /
      DATA (TMP(J, 47),J=1,ISHLS) /
     +  0.290E+00, 0.547E+00, 0.477E-01, 0.927E-01
     +, 0.790E-02, 0.153E-01, 0.719E-03, 0.751E-02
     +, 0.315E+00, 0.525E+00, 0.564E-01, 0.947E-01
     +, 0.000E+00, 0.000E+00, 0.276E-06, 0.262E-01
     +, 0.886E+00, 0.503E-02, 0.828E-01, 0.164E-03
     +, 0.000E+00, 0.329E-01, 0.891E-01, 0.791E+00
     +, 0.624E-02, 0.820E-02, 0.723E-01, 0.202E-03, 0.0 /
      DATA (TMP(J, 48),J=1,ISHLS) /
     +  0.290E+00, 0.545E+00, 0.481E-01, 0.934E-01
     +, 0.823E-02, 0.159E-01, 0.668E-03, 0.758E-02
     +, 0.315E+00, 0.521E+00, 0.582E-01, 0.971E-01
     +, 0.000E+00, 0.000E+00, 0.323E-06, 0.257E-01
     +, 0.878E+00, 0.505E-02, 0.905E-01, 0.400E-03
     +, 0.000E+00, 0.326E-01, 0.884E-01, 0.784E+00
     +, 0.632E-02, 0.894E-02, 0.790E-01, 0.500E-03, 0.0 /
      DATA (TMP(J, 49),J=1,ISHLS) /
     +  0.290E+00, 0.543E+00, 0.484E-01, 0.941E-01
     +, 0.853E-02, 0.165E-01, 0.623E-03, 0.766E-02
     +, 0.315E+00, 0.516E+00, 0.598E-01, 0.995E-01
     +, 0.507E-03, 0.778E-03, 0.378E-06, 0.253E-01
     +, 0.871E+00, 0.507E-02, 0.978E-01, 0.503E-03
     +, 0.000E+00, 0.324E-01, 0.877E-01, 0.778E+00
     +, 0.641E-02, 0.965E-02, 0.855E-01, 0.634E-03, 0.0 /
      DATA (TMP(J, 50),J=1,ISHLS) /
     +  0.289E+00, 0.541E+00, 0.489E-01, 0.948E-01
     +, 0.884E-02, 0.171E-01, 0.580E-03, 0.776E-02
     +, 0.314E+00, 0.511E+00, 0.614E-01, 0.101E+00
     +, 0.140E-02, 0.218E-02, 0.439E-06, 0.249E-01
     +, 0.865E+00, 0.510E-02, 0.104E+00, 0.574E-03
     +, 0.000E+00, 0.322E-01, 0.870E-01, 0.772E+00
     +, 0.651E-02, 0.103E-01, 0.914E-01, 0.732E-03, 0.0 /
      DATA (TMP(J, 51),J=1,ISHLS) /
     +  0.289E+00, 0.540E+00, 0.492E-01, 0.953E-01
     +, 0.915E-02, 0.177E-01, 0.541E-03, 0.787E-02
     +, 0.313E+00, 0.505E+00, 0.629E-01, 0.103E+00
     +, 0.260E-02, 0.406E-02, 0.511E-06, 0.245E-01
     +, 0.859E+00, 0.513E-02, 0.111E+00, 0.634E-03
     +, 0.000E+00, 0.321E-01, 0.864E-01, 0.766E+00
     +, 0.661E-02, 0.109E-01, 0.967E-01, 0.816E-03, 0.0 /
      DATA (TMP(J, 52),J=1,ISHLS) /
     +  0.289E+00, 0.537E+00, 0.496E-01, 0.961E-01
     +, 0.945E-02, 0.183E-01, 0.505E-03, 0.800E-02
     +, 0.312E+00, 0.500E+00, 0.642E-01, 0.105E+00
     +, 0.404E-02, 0.631E-02, 0.593E-06, 0.242E-01
     +, 0.854E+00, 0.516E-02, 0.116E+00, 0.688E-03
     +, 0.000E+00, 0.320E-01, 0.859E-01, 0.762E+00
     +, 0.672E-02, 0.114E-01, 0.102E+00, 0.894E-03, 0.0 /
      DATA (TMP(J, 53),J=1,ISHLS) /
     +  0.289E+00, 0.536E+00, 0.499E-01, 0.967E-01
     +, 0.974E-02, 0.189E-01, 0.473E-03, 0.816E-02
     +, 0.311E+00, 0.494E+00, 0.656E-01, 0.107E+00
     +, 0.571E-02, 0.891E-02, 0.688E-06, 0.240E-01
     +, 0.849E+00, 0.519E-02, 0.121E+00, 0.738E-03
     +, 0.000E+00, 0.319E-01, 0.854E-01, 0.757E+00
     +, 0.683E-02, 0.119E-01, 0.106E+00, 0.968E-03, 0.0 /
      DATA (TMP(J, 54),J=1,ISHLS) /
     +  0.289E+00, 0.534E+00, 0.502E-01, 0.973E-01
     +, 0.100E-01, 0.195E-01, 0.442E-03, 0.833E-02
     +, 0.309E+00, 0.488E+00, 0.667E-01, 0.108E+00
     +, 0.759E-02, 0.118E-01, 0.792E-06, 0.237E-01
     +, 0.844E+00, 0.523E-02, 0.126E+00, 0.784E-03
     +, 0.000E+00, 0.319E-01, 0.849E-01, 0.753E+00
     +, 0.694E-02, 0.123E-01, 0.110E+00, 0.104E-02, 0.0 /
      DATA (TMP(J, 55),J=1,ISHLS) /
     +  0.288E+00, 0.533E+00, 0.505E-01, 0.978E-01
     +, 0.103E-01, 0.200E-01, 0.415E-03, 0.853E-02
     +, 0.309E+00, 0.482E+00, 0.679E-01, 0.109E+00
     +, 0.900E-02, 0.142E-01, 0.915E-06, 0.235E-01
     +, 0.840E+00, 0.526E-02, 0.130E+00, 0.857E-03
     +, 0.000E+00, 0.319E-01, 0.845E-01, 0.749E+00
     +, 0.706E-02, 0.128E-01, 0.114E+00, 0.115E-02, 0.0 /
      DATA (TMP(J, 56),J=1,ISHLS) /
     +  0.289E+00, 0.531E+00, 0.508E-01, 0.984E-01
     +, 0.106E-01, 0.206E-01, 0.391E-03, 0.876E-02
     +, 0.308E+00, 0.477E+00, 0.692E-01, 0.110E+00
     +, 0.103E-01, 0.162E-01, 0.105E-05, 0.232E-01
     +, 0.836E+00, 0.529E-02, 0.135E+00, 0.928E-03
     +, 0.000E+00, 0.320E-01, 0.841E-01, 0.745E+00
     +, 0.718E-02, 0.132E-01, 0.118E+00, 0.126E-02, 0.0 /
      DATA (TMP(J, 57),J=1,ISHLS) /
     +  0.289E+00, 0.530E+00, 0.510E-01, 0.989E-01
     +, 0.108E-01, 0.211E-01, 0.368E-03, 0.903E-02
     +, 0.308E+00, 0.472E+00, 0.705E-01, 0.112E+00
     +, 0.112E-01, 0.175E-01, 0.121E-05, 0.229E-01
     +, 0.831E+00, 0.531E-02, 0.139E+00, 0.980E-03
     +, 0.108E-02, 0.320E-01, 0.836E-01, 0.740E+00
     +, 0.730E-02, 0.135E-01, 0.121E+00, 0.134E-02, 0.103E-02 /
      DATA (TMP(J, 58),J=1,ISHLS) /
     +  0.288E+00, 0.529E+00, 0.514E-01, 0.995E-01
     +, 0.109E-01, 0.212E-01, 0.348E-03, 0.938E-02
     +, 0.310E+00, 0.471E+00, 0.710E-01, 0.111E+00
     +, 0.104E-01, 0.161E-01, 0.140E-05, 0.229E-01
     +, 0.833E+00, 0.530E-02, 0.138E+00, 0.927E-03
     +, 0.000E+00, 0.323E-01, 0.839E-01, 0.742E+00
     +, 0.736E-02, 0.135E-01, 0.120E+00, 0.128E-02, 0.0 /
      DATA (TMP(J, 59),J=1,ISHLS) /
     +  0.289E+00, 0.527E+00, 0.517E-01, 0.100E+00
     +, 0.110E-01, 0.214E-01, 0.330E-03, 0.973E-02
     +, 0.311E+00, 0.469E+00, 0.718E-01, 0.112E+00
     +, 0.105E-01, 0.160E-01, 0.161E-05, 0.228E-01
     +, 0.831E+00, 0.532E-02, 0.140E+00, 0.922E-03
     +, 0.000E+00, 0.325E-01, 0.838E-01, 0.740E+00
     +, 0.745E-02, 0.136E-01, 0.121E+00, 0.129E-02, 0.0 /
      DATA (TMP(J, 60),J=1,ISHLS) /
     +  0.289E+00, 0.526E+00, 0.520E-01, 0.101E+00
     +, 0.112E-01, 0.217E-01, 0.313E-03, 0.101E-01
     +, 0.313E+00, 0.466E+00, 0.725E-01, 0.112E+00
     +, 0.105E-01, 0.158E-01, 0.185E-05, 0.227E-01
     +, 0.830E+00, 0.532E-02, 0.141E+00, 0.918E-03
     +, 0.000E+00, 0.327E-01, 0.834E-01, 0.740E+00
     +, 0.753E-02, 0.136E-01, 0.122E+00, 0.129E-02, 0.0 /
      DATA (TMP(J, 61),J=1,ISHLS) /
     +  0.289E+00, 0.524E+00, 0.522E-01, 0.101E+00
     +, 0.113E-01, 0.219E-01, 0.297E-03, 0.105E-01
     +, 0.314E+00, 0.463E+00, 0.732E-01, 0.112E+00
     +, 0.105E-01, 0.156E-01, 0.213E-05, 0.226E-01
     +, 0.830E+00, 0.532E-02, 0.142E+00, 0.912E-03
     +, 0.000E+00, 0.330E-01, 0.834E-01, 0.739E+00
     +, 0.761E-02, 0.137E-01, 0.122E+00, 0.130E-02, 0.0 /
      DATA (TMP(J, 62),J=1,ISHLS) /
     +  0.289E+00, 0.523E+00, 0.525E-01, 0.101E+00
     +, 0.114E-01, 0.221E-01, 0.283E-03, 0.110E-01
     +, 0.316E+00, 0.461E+00, 0.740E-01, 0.112E+00
     +, 0.105E-01, 0.155E-01, 0.243E-05, 0.225E-01
     +, 0.829E+00, 0.531E-02, 0.142E+00, 0.905E-03
     +, 0.000E+00, 0.333E-01, 0.835E-01, 0.737E+00
     +, 0.772E-02, 0.138E-01, 0.123E+00, 0.131E-02, 0.0 /
      DATA (TMP(J, 63),J=1,ISHLS) /
     +  0.289E+00, 0.522E+00, 0.527E-01, 0.102E+00
     +, 0.115E-01, 0.223E-01, 0.269E-03, 0.115E-01
     +, 0.318E+00, 0.458E+00, 0.747E-01, 0.112E+00
     +, 0.104E-01, 0.153E-01, 0.277E-05, 0.224E-01
     +, 0.828E+00, 0.532E-02, 0.143E+00, 0.898E-03
     +, 0.000E+00, 0.335E-01, 0.832E-01, 0.737E+00
     +, 0.779E-02, 0.138E-01, 0.123E+00, 0.131E-02, 0.0 /
      DATA (TMP(J, 64),J=1,ISHLS) /
     +  0.290E+00, 0.521E+00, 0.529E-01, 0.102E+00
     +, 0.116E-01, 0.226E-01, 0.257E-03, 0.120E-01
     +, 0.318E+00, 0.454E+00, 0.755E-01, 0.112E+00
     +, 0.111E-01, 0.161E-01, 0.315E-05, 0.223E-01
     +, 0.826E+00, 0.533E-02, 0.145E+00, 0.933E-03
     +, 0.865E-03, 0.338E-01, 0.830E-01, 0.734E+00
     +, 0.790E-02, 0.139E-01, 0.125E+00, 0.138E-02, 0.798E-03 /
      DATA (TMP(J, 65),J=1,ISHLS) /
     +  0.290E+00, 0.520E+00, 0.532E-01, 0.103E+00
     +, 0.117E-01, 0.226E-01, 0.245E-03, 0.126E-01
     +, 0.321E+00, 0.453E+00, 0.760E-01, 0.112E+00
     +, 0.104E-01, 0.148E-01, 0.360E-05, 0.223E-01
     +, 0.827E+00, 0.532E-02, 0.144E+00, 0.887E-03
     +, 0.000E+00, 0.342E-01, 0.832E-01, 0.735E+00
     +, 0.799E-02, 0.139E-01, 0.124E+00, 0.133E-02, 0.0 /
      DATA (TMP(J, 66),J=1,ISHLS) /
     +  0.290E+00, 0.519E+00, 0.534E-01, 0.103E+00
     +, 0.118E-01, 0.228E-01, 0.234E-03, 0.133E-01
     +, 0.323E+00, 0.450E+00, 0.768E-01, 0.112E+00
     +, 0.104E-01, 0.146E-01, 0.409E-05, 0.223E-01
     +, 0.827E+00, 0.534E-02, 0.145E+00, 0.880E-03
     +, 0.000E+00, 0.346E-01, 0.832E-01, 0.735E+00
     +, 0.809E-02, 0.139E-01, 0.124E+00, 0.133E-02, 0.0 /
      DATA (TMP(J, 67),J=1,ISHLS) /
     +  0.291E+00, 0.517E+00, 0.536E-01, 0.104E+00
     +, 0.118E-01, 0.229E-01, 0.224E-03, 0.139E-01
     +, 0.325E+00, 0.447E+00, 0.774E-01, 0.111E+00
     +, 0.104E-01, 0.144E-01, 0.465E-05, 0.222E-01
     +, 0.826E+00, 0.534E-02, 0.146E+00, 0.876E-03
     +, 0.000E+00, 0.349E-01, 0.831E-01, 0.734E+00
     +, 0.819E-02, 0.139E-01, 0.125E+00, 0.134E-02, 0.0 /
      DATA (TMP(J, 68),J=1,ISHLS) /
     +  0.291E+00, 0.516E+00, 0.538E-01, 0.104E+00
     +, 0.119E-01, 0.230E-01, 0.214E-03, 0.147E-01
     +, 0.327E+00, 0.445E+00, 0.780E-01, 0.111E+00
     +, 0.104E-01, 0.142E-01, 0.527E-05, 0.222E-01
     +, 0.826E+00, 0.534E-02, 0.146E+00, 0.871E-03
     +, 0.000E+00, 0.353E-01, 0.830E-01, 0.734E+00
     +, 0.830E-02, 0.139E-01, 0.125E+00, 0.134E-02, 0.0 /
      DATA (TMP(J, 69),J=1,ISHLS) /
     +  0.291E+00, 0.515E+00, 0.540E-01, 0.104E+00
     +, 0.120E-01, 0.232E-01, 0.205E-03, 0.155E-01
     +, 0.329E+00, 0.442E+00, 0.788E-01, 0.111E+00
     +, 0.104E-01, 0.140E-01, 0.598E-05, 0.222E-01
     +, 0.825E+00, 0.535E-02, 0.146E+00, 0.866E-03
     +, 0.000E+00, 0.357E-01, 0.830E-01, 0.733E+00
     +, 0.840E-02, 0.140E-01, 0.125E+00, 0.135E-02, 0.0 /
      DATA (TMP(J, 70),J=1,ISHLS) /
     +  0.292E+00, 0.514E+00, 0.542E-01, 0.105E+00
     +, 0.121E-01, 0.233E-01, 0.197E-03, 0.163E-01
     +, 0.331E+00, 0.439E+00, 0.794E-01, 0.110E+00
     +, 0.104E-01, 0.138E-01, 0.677E-05, 0.221E-01
     +, 0.825E+00, 0.536E-02, 0.147E+00, 0.861E-03
     +, 0.000E+00, 0.361E-01, 0.828E-01, 0.732E+00
     +, 0.851E-02, 0.140E-01, 0.125E+00, 0.136E-02, 0.0 /
      DATA (TMP(J, 71),J=1,ISHLS) /
     +  0.292E+00, 0.513E+00, 0.543E-01, 0.105E+00
     +, 0.121E-01, 0.235E-01, 0.189E-03, 0.172E-01
     +, 0.332E+00, 0.435E+00, 0.801E-01, 0.110E+00
     +, 0.110E-01, 0.145E-01, 0.765E-05, 0.221E-01
     +, 0.823E+00, 0.537E-02, 0.148E+00, 0.890E-03
     +, 0.649E-03, 0.365E-01, 0.827E-01, 0.730E+00
     +, 0.863E-02, 0.140E-01, 0.126E+00, 0.142E-02, 0.572E-03 /
      DATA (TMP(J, 72),J=1,ISHLS) /
     +  0.293E+00, 0.512E+00, 0.545E-01, 0.105E+00
     +, 0.122E-01, 0.237E-01, 0.181E-03, 0.181E-01
     +, 0.334E+00, 0.430E+00, 0.810E-01, 0.110E+00
     +, 0.116E-01, 0.152E-01, 0.858E-05, 0.220E-01
     +, 0.821E+00, 0.539E-02, 0.149E+00, 0.921E-03
     +, 0.160E-02, 0.369E-01, 0.825E-01, 0.728E+00
     +, 0.875E-02, 0.141E-01, 0.127E+00, 0.149E-02, 0.142E-02 /
      DATA (TMP(J, 73),J=1,ISHLS) /
     +  0.293E+00, 0.511E+00, 0.546E-01, 0.106E+00
     +, 0.124E-01, 0.239E-01, 0.174E-03, 0.191E-01
     +, 0.335E+00, 0.426E+00, 0.818E-01, 0.110E+00
     +, 0.122E-01, 0.158E-01, 0.968E-05, 0.220E-01
     +, 0.818E+00, 0.539E-02, 0.151E+00, 0.950E-03
     +, 0.278E-02, 0.373E-01, 0.822E-01, 0.726E+00
     +, 0.888E-02, 0.142E-01, 0.127E+00, 0.156E-02, 0.250E-02 /
      DATA (TMP(J, 74),J=1,ISHLS) /
     +  0.293E+00, 0.509E+00, 0.548E-01, 0.106E+00
     +, 0.125E-01, 0.242E-01, 0.167E-03, 0.202E-01
     +, 0.337E+00, 0.421E+00, 0.826E-01, 0.110E+00
     +, 0.128E-01, 0.165E-01, 0.109E-04, 0.219E-01
     +, 0.816E+00, 0.541E-02, 0.152E+00, 0.980E-03
     +, 0.420E-02, 0.377E-01, 0.820E-01, 0.723E+00
     +, 0.901E-02, 0.143E-01, 0.128E+00, 0.162E-02, 0.377E-02 /
      DATA (TMP(J, 75),J=1,ISHLS) /
     +  0.294E+00, 0.508E+00, 0.549E-01, 0.106E+00
     +, 0.126E-01, 0.244E-01, 0.161E-03, 0.213E-01
     +, 0.338E+00, 0.417E+00, 0.835E-01, 0.109E+00
     +, 0.134E-01, 0.170E-01, 0.122E-04, 0.219E-01
     +, 0.813E+00, 0.543E-02, 0.153E+00, 0.101E-02
     +, 0.581E-02, 0.381E-01, 0.817E-01, 0.721E+00
     +, 0.914E-02, 0.144E-01, 0.129E+00, 0.169E-02, 0.522E-02 /
      DATA (TMP(J, 76),J=1,ISHLS) /
     +  0.294E+00, 0.507E+00, 0.550E-01, 0.106E+00
     +, 0.127E-01, 0.246E-01, 0.155E-03, 0.225E-01
     +, 0.340E+00, 0.412E+00, 0.844E-01, 0.109E+00
     +, 0.140E-01, 0.176E-01, 0.137E-04, 0.218E-01
     +, 0.810E+00, 0.544E-02, 0.154E+00, 0.104E-02
     +, 0.762E-02, 0.384E-01, 0.814E-01, 0.718E+00
     +, 0.928E-02, 0.145E-01, 0.130E+00, 0.176E-02, 0.684E-02 /
      DATA (TMP(J, 77),J=1,ISHLS) /
     +  0.295E+00, 0.506E+00, 0.552E-01, 0.107E+00
     +, 0.128E-01, 0.249E-01, 0.149E-03, 0.239E-01
     +, 0.342E+00, 0.408E+00, 0.854E-01, 0.109E+00
     +, 0.144E-01, 0.178E-01, 0.153E-04, 0.217E-01
     +, 0.806E+00, 0.545E-02, 0.155E+00, 0.105E-02
     +, 0.109E-01, 0.388E-01, 0.810E-01, 0.714E+00
     +, 0.940E-02, 0.145E-01, 0.131E+00, 0.181E-02, 0.958E-02 /
      DATA (TMP(J, 78),J=1,ISHLS) /
     +  0.295E+00, 0.505E+00, 0.553E-01, 0.107E+00
     +, 0.129E-01, 0.251E-01, 0.144E-03, 0.253E-01
     +, 0.343E+00, 0.403E+00, 0.863E-01, 0.109E+00
     +, 0.151E-01, 0.184E-01, 0.172E-04, 0.217E-01
     +, 0.803E+00, 0.547E-02, 0.157E+00, 0.109E-02
     +, 0.125E-01, 0.393E-01, 0.807E-01, 0.711E+00
     +, 0.955E-02, 0.146E-01, 0.132E+00, 0.188E-02, 0.111E-01 /
      DATA (TMP(J, 79),J=1,ISHLS) /
     +  0.296E+00, 0.503E+00, 0.554E-01, 0.107E+00
     +, 0.130E-01, 0.254E-01, 0.140E-03, 0.270E-01
     +, 0.348E+00, 0.392E+00, 0.881E-01, 0.110E+00
     +, 0.158E-01, 0.190E-01, 0.192E-04, 0.216E-01
     +, 0.799E+00, 0.549E-02, 0.158E+00, 0.111E-02
     +, 0.148E-01, 0.397E-01, 0.803E-01, 0.708E+00
     +, 0.969E-02, 0.147E-01, 0.132E+00, 0.195E-02, 0.131E-01 /
      DATA (TMP(J, 80),J=1,ISHLS) /
     +  0.296E+00, 0.502E+00, 0.555E-01, 0.107E+00
     +, 0.131E-01, 0.256E-01, 0.133E-03, 0.283E-01
     +, 0.347E+00, 0.393E+00, 0.882E-01, 0.108E+00
     +, 0.163E-01, 0.194E-01, 0.214E-04, 0.216E-01
     +, 0.796E+00, 0.551E-02, 0.159E+00, 0.114E-02
     +, 0.165E-01, 0.401E-01, 0.801E-01, 0.705E+00
     +, 0.984E-02, 0.147E-01, 0.133E+00, 0.203E-02, 0.147E-01 /
      DATA (TMP(J, 81),J=1,ISHLS) /
     +  0.297E+00, 0.501E+00, 0.556E-01, 0.108E+00
     +, 0.132E-01, 0.259E-01, 0.129E-03, 0.301E-01
     +, 0.348E+00, 0.388E+00, 0.891E-01, 0.108E+00
     +, 0.170E-01, 0.200E-01, 0.240E-04, 0.215E-01
     +, 0.793E+00, 0.553E-02, 0.160E+00, 0.117E-02
     +, 0.183E-01, 0.406E-01, 0.798E-01, 0.703E+00
     +, 0.999E-02, 0.148E-01, 0.134E+00, 0.210E-02, 0.163E-01 /
      DATA (TMP(J, 82),J=1,ISHLS) /
     +  0.297E+00, 0.500E+00, 0.557E-01, 0.108E+00
     +, 0.133E-01, 0.261E-01, 0.124E-03, 0.319E-01
     +, 0.350E+00, 0.382E+00, 0.901E-01, 0.107E+00
     +, 0.176E-01, 0.206E-01, 0.267E-04, 0.215E-01
     +, 0.790E+00, 0.555E-02, 0.161E+00, 0.120E-02
     +, 0.200E-01, 0.411E-01, 0.795E-01, 0.700E+00
     +, 0.101E-01, 0.149E-01, 0.135E+00, 0.218E-02, 0.179E-01 /
      DATA (TMP(J, 83),J=1,ISHLS) /
     +  0.298E+00, 0.498E+00, 0.557E-01, 0.108E+00
     +, 0.134E-01, 0.263E-01, 0.120E-03, 0.338E-01
     +, 0.352E+00, 0.377E+00, 0.910E-01, 0.107E+00
     +, 0.183E-01, 0.212E-01, 0.298E-04, 0.215E-01
     +, 0.787E+00, 0.557E-02, 0.163E+00, 0.123E-02
     +, 0.216E-01, 0.415E-01, 0.792E-01, 0.697E+00
     +, 0.103E-01, 0.150E-01, 0.135E+00, 0.226E-02, 0.194E-01 /
      DATA (TMP(J, 84),J=1,ISHLS) /
     +  0.299E+00, 0.497E+00, 0.558E-01, 0.108E+00
     +, 0.135E-01, 0.266E-01, 0.116E-03, 0.358E-01
     +, 0.354E+00, 0.371E+00, 0.921E-01, 0.106E+00
     +, 0.190E-01, 0.218E-01, 0.332E-04, 0.214E-01
     +, 0.785E+00, 0.560E-02, 0.164E+00, 0.126E-02
     +, 0.232E-01, 0.420E-01, 0.789E-01, 0.694E+00
     +, 0.105E-01, 0.150E-01, 0.136E+00, 0.234E-02, 0.208E-01 /
      DATA (TMP(J, 85),J=1,ISHLS) /
     +  0.299E+00, 0.496E+00, 0.559E-01, 0.108E+00
     +, 0.135E-01, 0.268E-01, 0.112E-03, 0.381E-01
     +, 0.356E+00, 0.365E+00, 0.930E-01, 0.106E+00
     +, 0.197E-01, 0.223E-01, 0.369E-04, 0.214E-01
     +, 0.782E+00, 0.562E-02, 0.165E+00, 0.129E-02
     +, 0.247E-01, 0.426E-01, 0.786E-01, 0.692E+00
     +, 0.106E-01, 0.151E-01, 0.137E+00, 0.243E-02, 0.222E-01 /
      DATA (TMP(J, 86),J=1,ISHLS) /
     +  0.300E+00, 0.495E+00, 0.560E-01, 0.109E+00
     +, 0.136E-01, 0.270E-01, 0.108E-03, 0.405E-01
     +, 0.358E+00, 0.360E+00, 0.940E-01, 0.105E+00
     +, 0.204E-01, 0.227E-01, 0.411E-04, 0.214E-01
     +, 0.779E+00, 0.565E-02, 0.166E+00, 0.133E-02
     +, 0.262E-01, 0.431E-01, 0.783E-01, 0.689E+00
     +, 0.108E-01, 0.151E-01, 0.138E+00, 0.251E-02, 0.235E-01 /
      DATA (TMP(J, 87),J=1,ISHLS) /
     +  0.301E+00, 0.493E+00, 0.560E-01, 0.109E+00
     +, 0.137E-01, 0.273E-01, 0.105E-03, 0.430E-01
     +, 0.360E+00, 0.354E+00, 0.951E-01, 0.104E+00
     +, 0.211E-01, 0.232E-01, 0.457E-04, 0.214E-01
     +, 0.776E+00, 0.568E-02, 0.167E+00, 0.136E-02
     +, 0.276E-01, 0.437E-01, 0.781E-01, 0.687E+00
     +, 0.110E-01, 0.152E-01, 0.138E+00, 0.260E-02, 0.248E-01 /
      DATA (TMP(J, 88),J=1,ISHLS) /
     +  0.301E+00, 0.492E+00, 0.561E-01, 0.109E+00
     +, 0.138E-01, 0.275E-01, 0.101E-03, 0.456E-01
     +, 0.362E+00, 0.348E+00, 0.960E-01, 0.103E+00
     +, 0.218E-01, 0.236E-01, 0.508E-04, 0.214E-01
     +, 0.774E+00, 0.571E-02, 0.168E+00, 0.139E-02
     +, 0.291E-01, 0.425E-01, 0.779E-01, 0.685E+00
     +, 0.112E-01, 0.153E-01, 0.139E+00, 0.269E-02, 0.261E-01 /
      DATA (TMP(J, 89),J=1,ISHLS) /
     +  0.302E+00, 0.491E+00, 0.561E-01, 0.109E+00
     +, 0.139E-01, 0.277E-01, 0.978E-04, 0.485E-01
     +, 0.364E+00, 0.341E+00, 0.971E-01, 0.103E+00
     +, 0.224E-01, 0.240E-01, 0.564E-04, 0.215E-01
     +, 0.771E+00, 0.574E-02, 0.170E+00, 0.142E-02
     +, 0.305E-01, 0.448E-01, 0.775E-01, 0.681E+00
     +, 0.113E-01, 0.153E-01, 0.140E+00, 0.277E-02, 0.272E-01 /
      DATA (TMP(J, 90),J=1,ISHLS) /
     +  0.303E+00, 0.490E+00, 0.561E-01, 0.109E+00
     +, 0.139E-01, 0.280E-01, 0.946E-04, 0.515E-01
     +, 0.366E+00, 0.335E+00, 0.981E-01, 0.102E+00
     +, 0.231E-01, 0.243E-01, 0.626E-04, 0.215E-01
     +, 0.769E+00, 0.577E-02, 0.171E+00, 0.145E-02
     +, 0.319E-01, 0.454E-01, 0.773E-01, 0.679E+00
     +, 0.115E-01, 0.153E-01, 0.140E+00, 0.286E-02, 0.284E-01 /
      DATA (TMP(J, 91),J=1,ISHLS) /
     +  0.304E+00, 0.488E+00, 0.562E-01, 0.110E+00
     +, 0.140E-01, 0.282E-01, 0.913E-04, 0.547E-01
     +, 0.368E+00, 0.329E+00, 0.991E-01, 0.101E+00
     +, 0.237E-01, 0.244E-01, 0.695E-04, 0.215E-01
     +, 0.766E+00, 0.580E-02, 0.172E+00, 0.147E-02
     +, 0.326E-01, 0.460E-01, 0.770E-01, 0.677E+00
     +, 0.117E-01, 0.154E-01, 0.141E+00, 0.294E-02, 0.290E-01 /
      DATA (TMP(J, 92),J=1,ISHLS) /
     +  0.304E+00, 0.487E+00, 0.562E-01, 0.110E+00
     +, 0.140E-01, 0.284E-01, 0.882E-04, 0.582E-01
     +, 0.371E+00, 0.322E+00, 0.100E+00, 0.997E-01
     +, 0.243E-01, 0.245E-01, 0.772E-04, 0.215E-01
     +, 0.764E+00, 0.584E-02, 0.173E+00, 0.150E-02
     +, 0.335E-01, 0.466E-01, 0.768E-01, 0.675E+00
     +, 0.119E-01, 0.154E-01, 0.142E+00, 0.302E-02, 0.299E-01 /
      DATA (TMP(J, 93),J=1,ISHLS) /
     +  0.305E+00, 0.486E+00, 0.562E-01, 0.110E+00
     +, 0.141E-01, 0.286E-01, 0.852E-04, 0.619E-01
     +, 0.373E+00, 0.316E+00, 0.101E+00, 0.987E-01
     +, 0.249E-01, 0.246E-01, 0.855E-04, 0.216E-01
     +, 0.762E+00, 0.587E-02, 0.174E+00, 0.153E-02
     +, 0.344E-01, 0.473E-01, 0.766E-01, 0.673E+00
     +, 0.121E-01, 0.155E-01, 0.142E+00, 0.310E-02, 0.304E-01 /
      DATA (TMP(J, 94),J=1,ISHLS) /
     +  0.306E+00, 0.484E+00, 0.561E-01, 0.110E+00
     +, 0.141E-01, 0.298E-01, 0.822E-04, 0.658E-01
     +, 0.376E+00, 0.309E+00, 0.102E+00, 0.974E-01
     +, 0.254E-01, 0.246E-01, 0.949E-04, 0.216E-01
     +, 0.760E+00, 0.591E-02, 0.175E+00, 0.155E-02
     +, 0.351E-01, 0.480E-01, 0.764E-01, 0.671E+00
     +, 0.123E-01, 0.156E-01, 0.143E+00, 0.318E-02, 0.308E-01 /
      DATA (TMP(J, 95),J=1,ISHLS) /
     +  0.307E+00, 0.483E+00, 0.562E-01, 0.110E+00
     +, 0.142E-01, 0.291E-01, 0.793E-04, 0.700E-01
     +, 0.378E+00, 0.302E+00, 0.103E+00, 0.962E-01
     +, 0.259E-01, 0.245E-01, 0.105E-03, 0.216E-01
     +, 0.758E+00, 0.595E-02, 0.176E+00, 0.158E-02
     +, 0.359E-01, 0.486E-01, 0.763E-01, 0.669E+00
     +, 0.125E-01, 0.156E-01, 0.143E+00, 0.326E-02, 0.314E-01 /
      DATA (TMP(J, 96),J=1,ISHLS) /
     +  0.308E+00, 0.482E+00, 0.562E-01, 0.111E+00
     +, 0.142E-01, 0.293E-01, 0.764E-04, 0.745E-01
     +, 0.381E+00, 0.295E+00, 0.104E+00, 0.948E-01
     +, 0.265E-01, 0.245E-01, 0.116E-03, 0.217E-01
     +, 0.756E+00, 0.598E-02, 0.178E+00, 0.160E-02
     +, 0.369E-01, 0.493E-01, 0.761E-01, 0.667E+00
     +, 0.127E-01, 0.156E-01, 0.144E+00, 0.335E-02, 0.322E-01 /
      DATA (TMP(J, 97),J=1,ISHLS) /
     +  0.309E+00, 0.481E+00, 0.561E-01, 0.111E+00
     +, 0.143E-01, 0.295E-01, 0.736E-04, 0.792E-01
     +, 0.383E+00, 0.287E+00, 0.106E+00, 0.934E-01
     +, 0.271E-01, 0.244E-01, 0.129E-03, 0.218E-01
     +, 0.754E+00, 0.603E-02, 0.179E+00, 0.163E-02
     +, 0.376E-01, 0.500E-01, 0.757E-01, 0.665E+00
     +, 0.129E-01, 0.157E-01, 0.144E+00, 0.343E-02, 0.327E-01 /
      DATA (TMP(J, 98),J=1,ISHLS) /
     +  0.310E+00, 0.479E+00, 0.561E-01, 0.111E+00
     +, 0.143E-01, 0.297E-01, 0.708E-04, 0.843E-01
     +, 0.386E+00, 0.280E+00, 0.106E+00, 0.919E-01
     +, 0.276E-01, 0.242E-01, 0.143E-03, 0.218E-01
     +, 0.752E+00, 0.607E-02, 0.180E+00, 0.165E-02
     +, 0.381E-01, 0.507E-01, 0.756E-01, 0.664E+00
     +, 0.131E-01, 0.157E-01, 0.145E+00, 0.351E-02, 0.330E-01 /
      DATA (TMP(J, 99),J=1,ISHLS) /
     +  0.311E+00, 0.478E+00, 0.561E-01, 0.111E+00
     +, 0.143E-01, 0.299E-01, 0.679E-04, 0.897E-01
     +, 0.388E+00, 0.272E+00, 0.107E+00, 0.903E-01
     +, 0.281E-01, 0.240E-01, 0.158E-03, 0.219E-01
     +, 0.751E+00, 0.611E-02, 0.181E+00, 0.168E-02
     +, 0.388E-01, 0.515E-01, 0.754E-01, 0.662E+00
     +, 0.133E-01, 0.157E-01, 0.145E+00, 0.359E-02, 0.335E-01 /
      DATA (TMP(J,100),J=1,ISHLS) /
     +  0.312E+00, 0.477E+00, 0.560E-01, 0.111E+00
     +, 0.144E-01, 0.301E-01, 0.650E-04, 0.954E-01
     +, 0.391E+00, 0.264E+00, 0.108E+00, 0.885E-01
     +, 0.286E-01, 0.238E-01, 0.175E-03, 0.220E-01
     +, 0.749E+00, 0.616E-02, 0.182E+00, 0.170E-02
     +, 0.395E-01, 0.522E-01, 0.752E-01, 0.660E+00
     +, 0.135E-01, 0.158E-01, 0.146E+00, 0.367E-02, 0.339E-01 /
C
      DATA (TMP1(I,  1),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  2),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  3),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  4),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  5),I=1,4) /  0.170E-02, 3*0.0 /
      DATA (TMP1(I,  6),I=1,4) /  0.280E-02, 3*0.0 /
      DATA (TMP1(I,  7),I=1,4) /  0.520E-02, 3*0.0 /
      DATA (TMP1(I,  8),I=1,4) /  0.830E-02, 3*0.0 /
      DATA (TMP1(I,  9),I=1,4) /  0.130E-01, 3*0.0 /
      DATA (TMP1(I, 10),I=1,4) /  0.180E-01, 3*0.0 /
      DATA (TMP1(I, 11),I=1,4) /  0.230E-01, 3*0.0 /
      DATA (TMP1(I, 12),I=1,4) /
     +  0.300E-01, 0.290E-04, 0.120E-02, 0.120E-02 /
      DATA (TMP1(I, 13),I=1,4) /
     +  0.390E-01, 0.260E-04, 0.750E-03, 0.750E-03 /
      DATA (TMP1(I, 14),I=1,4) /
     +  0.500E-01, 0.300E-04, 0.370E-03, 0.380E-03 /
      DATA (TMP1(I, 15),I=1,4) /
     +  0.630E-01, 0.390E-04, 0.310E-03, 0.310E-03 /
      DATA (TMP1(I, 16),I=1,4) /
     +  0.780E-01, 0.740E-04, 0.260E-03, 0.260E-03 /
      DATA (TMP1(I, 17),I=1,4) /
     +  0.970E-01, 0.120E-03, 0.240E-03, 0.240E-03 /
      DATA (TMP1(I, 18),I=1,4) /
     +  0.118E+00, 0.180E-03, 0.220E-03, 0.220E-03 /
      DATA (TMP1(I, 19),I=1,4) /
     +  0.140E+00, 0.240E-03, 0.270E-03, 0.270E-03 /
      DATA (TMP1(I, 20),I=1,4) /
     +  0.163E+00, 0.310E-03, 0.330E-03, 0.330E-03 /
      DATA (TMP1(I, 21),I=1,4) /
     +  0.188E+00, 0.390E-03, 0.840E-03, 0.840E-03 /
      DATA (TMP1(I, 22),I=1,4) /
     +  0.214E+00, 0.470E-03, 0.150E-02, 0.150E-02 /
      DATA (TMP1(I, 23),I=1,4) /
     +  0.243E+00, 0.580E-03, 0.260E-02, 0.260E-02 /
      DATA (TMP1(I, 24),I=1,4) /
     +  0.275E+00, 0.710E-03, 0.370E-02, 0.370E-02 /
      DATA (TMP1(I, 25),I=1,4) /
     +  0.308E+00, 0.840E-03, 0.500E-02, 0.500E-02 /
      DATA (TMP1(I, 26),I=1,4) /
     +  0.340E+00, 0.100E-02, 0.630E-02, 0.630E-02 /
      DATA (TMP1(I, 27),I=1,4) /
     +  0.373E+00, 0.120E-02, 0.770E-02, 0.770E-02 /
      DATA (TMP1(I, 28),I=1,4) /
     +  0.406E+00, 0.140E-02, 0.860E-02, 0.930E-02 /
      DATA (TMP1(I, 29),I=1,4) /
     +  0.440E+00, 0.160E-02, 0.100E-01, 0.110E-01 /
      DATA (TMP1(I, 30),I=1,4) /
     +  0.474E+00, 0.180E-02, 0.110E-01, 0.120E-01 /
      DATA (TMP1(I, 31),I=1,4) /
     +  0.507E+00, 0.210E-02, 0.120E-01, 0.130E-01 /
      DATA (TMP1(I, 32),I=1,4) /
     +  0.535E+00, 0.240E-02, 0.130E-01, 0.150E-01 /
      DATA (TMP1(I, 33),I=1,4) /
     +  0.562E+00, 0.280E-02, 0.140E-01, 0.160E-01 /
      DATA (TMP1(I, 34),I=1,4) /
     +  0.589E+00, 0.320E-02, 0.160E-01, 0.180E-01 /
      DATA (TMP1(I, 35),I=1,4) /
     +  0.618E+00, 0.360E-02, 0.180E-01, 0.200E-01 /
      DATA (TMP1(I, 36),I=1,4) /
     +  0.643E+00, 0.410E-02, 0.200E-01, 0.220E-01 /
      DATA (TMP1(I, 37),I=1,4) /
     +  0.667E+00, 0.460E-02, 0.220E-01, 0.240E-01 /
      DATA (TMP1(I, 38),I=1,4) /
     +  0.690E+00, 0.510E-02, 0.240E-01, 0.260E-01 /
      DATA (TMP1(I, 39),I=1,4) /
     +  0.710E+00, 0.590E-02, 0.260E-01, 0.280E-01 /
      DATA (TMP1(I, 40),I=1,4) /
     +  0.730E+00, 0.680E-02, 0.280E-01, 0.310E-01 /
      DATA (TMP1(I, 41),I=1,4) /
     +  0.747E+00, 0.940E-02, 0.310E-01, 0.340E-01 /
      DATA (TMP1(I, 42),I=1,4) /
     +  0.765E+00, 0.100E-01, 0.340E-01, 0.370E-01 /
      DATA (TMP1(I, 43),I=1,4) /
     +  0.780E+00, 0.110E-01, 0.370E-01, 0.400E-01 /
      DATA (TMP1(I, 44),I=1,4) /
     +  0.794E+00, 0.120E-01, 0.400E-01, 0.430E-01 /
      DATA (TMP1(I, 45),I=1,4) /
     +  0.808E+00, 0.130E-01, 0.430E-01, 0.460E-01 /
      DATA (TMP1(I, 46),I=1,4) /
     +  0.820E+00, 0.140E-01, 0.470E-01, 0.490E-01 /
      DATA (TMP1(I, 47),I=1,4) /
     +  0.831E+00, 0.160E-01, 0.510E-01, 0.520E-01 /
      DATA (TMP1(I, 48),I=1,4) /
     +  0.843E+00, 0.180E-01, 0.560E-01, 0.560E-01 /
      DATA (TMP1(I, 49),I=1,4) /
     +  0.853E+00, 0.200E-01, 0.610E-01, 0.600E-01 /
      DATA (TMP1(I, 50),I=1,4) /
     +  0.862E+00, 0.370E-01, 0.650E-01, 0.640E-01 /
      DATA (TMP1(I, 51),I=1,4) /
     +  0.870E+00, 0.390E-01, 0.690E-01, 0.690E-01 /
      DATA (TMP1(I, 52),I=1,4) /
     +  0.877E+00, 0.410E-01, 0.740E-01, 0.740E-01 /
      DATA (TMP1(I, 53),I=1,4) /
     +  0.884E+00, 0.440E-01, 0.790E-01, 0.790E-01 /
      DATA (TMP1(I, 54),I=1,4) /
     +  0.891E+00, 0.460E-01, 0.830E-01, 0.850E-01 /
      DATA (TMP1(I, 55),I=1,4) /
     +  0.897E+00, 0.490E-01, 0.900E-01, 0.910E-01 /
      DATA (TMP1(I, 56),I=1,4) /
     +  0.902E+00, 0.520E-01, 0.960E-01, 0.970E-01 /
      DATA (TMP1(I, 57),I=1,4) /
     +  0.907E+00, 0.550E-01, 0.103E+00, 0.104E+00 /
      DATA (TMP1(I, 58),I=1,4) /
     +  0.912E+00, 0.580E-01, 0.110E+00, 0.111E+00 /
      DATA (TMP1(I, 59),I=1,4) /
     +  0.917E+00, 0.610E-01, 0.117E+00, 0.118E+00 /
      DATA (TMP1(I, 60),I=1,4) /
     +  0.921E+00, 0.640E-01, 0.124E+00, 0.125E+00 /
      DATA (TMP1(I, 61),I=1,4) /
     +  0.925E+00, 0.660E-01, 0.132E+00, 0.132E+00 /
      DATA (TMP1(I, 62),I=1,4) /
     +  0.929E+00, 0.710E-01, 0.140E+00, 0.139E+00 /
      DATA (TMP1(I, 63),I=1,4) /
     +  0.932E+00, 0.750E-01, 0.149E+00, 0.147E+00 /
      DATA (TMP1(I, 64),I=1,4) /
     +  0.935E+00, 0.790E-01, 0.158E+00, 0.155E+00 /
      DATA (TMP1(I, 65),I=1,4) /
     +  0.938E+00, 0.830E-01, 0.167E+00, 0.164E+00 /
      DATA (TMP1(I, 66),I=1,4) /
     +  0.941E+00, 0.890E-01, 0.178E+00, 0.174E+00 /
      DATA (TMP1(I, 67),I=1,4) /
     +  0.944E+00, 0.940E-01, 0.189E+00, 0.182E+00 /
      DATA (TMP1(I, 68),I=1,4) /
     +  0.947E+00, 0.100E+00, 0.200E+00, 0.192E+00 /
      DATA (TMP1(I, 69),I=1,4) /
     +  0.949E+00, 0.106E+00, 0.211E+00, 0.201E+00 /
      DATA (TMP1(I, 70),I=1,4) /
     +  0.951E+00, 0.112E+00, 0.222E+00, 0.210E+00 /
      DATA (TMP1(I, 71),I=1,4) /
     +  0.953E+00, 0.120E+00, 0.234E+00, 0.220E+00 /
      DATA (TMP1(I, 72),I=1,4) /
     +  0.955E+00, 0.128E+00, 0.246E+00, 0.231E+00 /
      DATA (TMP1(I, 73),I=1,4) /
     +  0.957E+00, 0.137E+00, 0.258E+00, 0.243E+00 /
      DATA (TMP1(I, 74),I=1,4) /
     +  0.958E+00, 0.147E+00, 0.270E+00, 0.255E+00 /
      DATA (TMP1(I, 75),I=1,4) /
     +  0.959E+00, 0.144E+00, 0.283E+00, 0.268E+00 /
      DATA (TMP1(I, 76),I=1,4) /
     +  0.961E+00, 0.130E+00, 0.295E+00, 0.281E+00 /
      DATA (TMP1(I, 77),I=1,4) /
     +  0.962E+00, 0.120E+00, 0.308E+00, 0.294E+00 /
      DATA (TMP1(I, 78),I=1,4) /
     +  0.963E+00, 0.114E+00, 0.321E+00, 0.306E+00 /
      DATA (TMP1(I, 79),I=1,4) /
     +  0.964E+00, 0.107E+00, 0.334E+00, 0.320E+00 /
      DATA (TMP1(I, 80),I=1,4) /
     +  0.965E+00, 0.107E+00, 0.347E+00, 0.333E+00 /
      DATA (TMP1(I, 81),I=1,4) /
     +  0.966E+00, 0.107E+00, 0.360E+00, 0.347E+00 /
      DATA (TMP1(I, 82),I=1,4) /
     +  0.967E+00, 0.112E+00, 0.373E+00, 0.360E+00 /
      DATA (TMP1(I, 83),I=1,4) /
     +  0.968E+00, 0.117E+00, 0.387E+00, 0.373E+00 /
      DATA (TMP1(I, 84),I=1,4) /
     +  0.968E+00, 0.122E+00, 0.401E+00, 0.386E+00 /
      DATA (TMP1(I, 85),I=1,4) /
     +  0.969E+00, 0.128E+00, 0.415E+00, 0.399E+00 /
      DATA (TMP1(I, 86),I=1,4) /
     +  0.969E+00, 0.134E+00, 0.429E+00, 0.411E+00 /
      DATA (TMP1(I, 87),I=1,4) /
     +  0.970E+00, 0.139E+00, 0.443E+00, 0.424E+00 /
      DATA (TMP1(I, 88),I=1,4) /
     +  0.970E+00, 0.146E+00, 0.456E+00, 0.437E+00 /
      DATA (TMP1(I, 89),I=1,4) /
     +  0.971E+00, 0.153E+00, 0.468E+00, 0.450E+00 /
      DATA (TMP1(I, 90),I=1,4) /
     +  0.971E+00, 0.161E+00, 0.479E+00, 0.463E+00 /
      DATA (TMP1(I, 91),I=1,4) /
     +  0.972E+00, 0.162E+00, 0.472E+00, 0.476E+00 /
      DATA (TMP1(I, 92),I=1,4) /
     +  0.972E+00, 0.176E+00, 0.467E+00, 0.489E+00 /
      DATA (TMP1(I, 93),I=1,4) /
     +  0.973E+00, 0.187E+00, 0.466E+00, 0.502E+00 /
      DATA (TMP1(I, 94),I=1,4) /
     +  0.973E+00, 0.205E+00, 0.464E+00, 0.514E+00 /
      DATA (TMP1(I, 95),I=1,4) /
     +  0.974E+00, 0.218E+00, 0.471E+00, 0.526E+00 /
      DATA (TMP1(I, 96),I=1,4) /
     +  0.974E+00, 0.228E+00, 0.479E+00, 0.539E+00 /
      DATA (TMP1(I, 97),I=1,4) /
     +  0.975E+00, 0.236E+00, 0.485E+00, 0.550E+00 /
      DATA (TMP1(I, 98),I=1,4) /
     +  0.975E+00, 0.244E+00, 0.490E+00, 0.560E+00 /
      DATA (TMP1(I, 99),I=1,4) /
     +  0.975E+00, 0.253E+00, 0.497E+00, 0.570E+00 /
      DATA (TMP1(I,100),I=1,4) /
     +  0.976E+00, 0.263E+00, 0.506E+00, 0.579E+00 /
C
      DO 20 J = 1,MAXELZ
         DO 10 I = 1,ISHLS
            GPHRAT(I,J) = TMP(I,J)
   10    CONTINUE
   20 CONTINUE
C
      DO 30 I = 1,29
         ISHLTR(I) = ITRN(I)
   30 CONTINUE
C
      DO 40 I = 1,MAXELZ
         GFLUPR(1,I) = TMP1(1,I)
         GFLUPR(2,I) = TMP1(2,I)
         GFLUPR(3,I) = TMP1(3,I)
         GFLUPR(4,I) = TMP1(4,I)
   40 CONTINUE
C
C K shell decay mode
      DO 50 I = 5,MAXELZ
         IF(I.LT.8) THEN
            IGNRFN(1,I) = 2
            IGNRFN(2,I) = 2
         ELSEIF(I.LT.81) THEN
            IGNRFN(1,I) = 3
            IGNRFN(2,I) = 4
         ELSE
            IGNRFN(1,I) = 3
            IGNRFN(2,I) = 3
         ENDIF
   50 CONTINUE
C L1 shell decay mode
      DO 60 I = 11,MAXELZ
         IGNRFN(3,I) = 4
         IF(I.LT.24) THEN
            IGNRFN(4,I) = 5
         ELSEIF(I.LT.49) THEN
            IGNRFN(4,I) = 9
         ELSEIF(I.LT.53) THEN
            IGNRFN(4,I) = 10
         ELSE
            IGNRFN(4,I) = 14
         ENDIF
   60 CONTINUE
C L2 shell decay mode
      DO 70 I = 12,MAXELZ
         IF(I.LT.13) THEN
            IGNRFN(5,I) = 5
            IGNRFN(6,I) = 5
         ELSEIF(I.LT.16) THEN
            IGNRFN(5,I) = 5
            IGNRFN(6,I) = 6
         ELSEIF(I.LT.29) THEN
            IGNRFN(5,I) = 6
            IGNRFN(6,I) = 7
         ELSE
            IGNRFN(5,I) = 8
            IGNRFN(6,I) = 9
         ENDIF
   70 CONTINUE
C L3 shell decay mode
      DO 80 I = 12,MAXELZ
         IF(I.LT.13) THEN
            IGNRFN(7,I) = 5
            IGNRFN(8,I) = 5
         ELSEIF(I.LT.16) THEN
            IGNRFN(7,I) = 5
            IGNRFN(8,I) = 7
         ELSEIF(I.LT.30) THEN
            IGNRFN(7,I) = 7
            IGNRFN(8,I) = 7
         ELSE
            IGNRFN(7,I) = 8
            IGNRFN(8,I) = 9
         ENDIF
   80 CONTINUE
      END
+DECK,GPHSG1.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GPHSG1(E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FUNCTION TO COMPUTE THE PHOTOEFFECT TOTAL CROSS-SECTION  *
C.    *       AS A FUNCTION OF E                                       *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOTI                                       *
C.    *                                                                *
C.    *    (1) Sandia parametrizsation is used;                        *
C.    *    (2) GPHSG1 in cm**2/g.                                      *
C.    *    (3) E in GeV                                                *
C.    *                                                                *
C.    *     J. Chwastowski 17.11.92                                    *
C.    ******************************************************************
C.
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCONSP.
+CDE,GC10EV.
+SELF, IF=-SINGLE
      DOUBLE PRECISION EINV,ECUR,ONE
+SELF
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      RES = 0.
      IF(E.LT.G10EV) GO TO 20
C Use Sandia data
      JPHXS = LQ(JPHOT-1)
      IPOINT = JPHXS+Q(JPHXS+1)*3+2
      IMAX = Q(IPOINT)
      IPOINT = IPOINT+1
      ECUR = E*1.E6
      IF(ECUR.LT.Q(IPOINT)) GO TO 20
      EINV = ONE/ECUR
      DO 10 I = 2,IMAX
         IPOINT = IPOINT+5
         IF(ECUR.LT.Q(IPOINT)) THEN
            J = IPOINT+1
            RES = EINV*(Q(J)+EINV*(Q(J+1)+EINV*(Q(J+2)+EINV*Q(J+3))))
            GO TO 20
         ENDIF
   10 CONTINUE
C This value is in cm**2/g
   20 GPHSG1 = MAX(RES,0.)
C
      END
+DECK,gphsg2.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GPHSG2(E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FUNCTION TO COMPUTE THE PHOTOEFFECT TOTAL CROSS-SECTION  *
C.    *       AS A FUNCTION OF Z AND E                                 *
C.    *                                                                *
C.    *    ==>CALLED BY : special dE/dx                                *
C.    *                                                                *
C.    *    (1) Sandia parametrizsation is used;                        *
C.    *    (2) GPHSG2 in Megabarns                                     *
C.    *    (3) E in GeV                                                *
C.    *                                                                *
C.    *     J. Chwastowski 31.03.93                                    *
C.    ******************************************************************
C.
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCONSP.
+CDE,GCMATE.
+CDE,GC10EV.
+SELF, IF=-SINGLE
      DOUBLE PRECISION EINV,ECUR,ONE,RES,ZERO
+SELF
      PARAMETER (ONE=1,ZERO=0)
C.
C.    ------------------------------------------------------------------
C.
      RES = 0.
      IF(E.LT.G10EV) GO TO 30
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      NZ     = Q(JPHXS+1)
      ECUR   = E*1E6
      EINV   = ONE/ECUR
      JWEIGH = JPHXS+2*NZ+1
      DO 20 JZ=1,NZ
         JPHFN   = LQ(JPHXS-JZ)
         IPOINT  = JPHFN+1
         IMAX    = Q(IPOINT)
         IPOINT  = IPOINT-4
         DO 10 I = 1,IMAX
            IPOINT = IPOINT+5
            IF(ECUR.LT.Q(IPOINT)) THEN
               J   = IPOINT+1
               RES = RES+Q(JWEIGH+JZ)*
     +         EINV*(Q(J)+EINV*(Q(J+1)+EINV*(Q(J+2)+EINV*Q(J+3))))
               GO TO 20
            ENDIF
   10    CONTINUE
   20 CONTINUE
C RES value is in cm**2/g
C Now in Megabarns
   30 GPHSG2 = MAX(RES,ZERO)*A/AVO*1E-6
C
      END
+DECK,GPHSGP.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GPHSGP(IELEM,E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FUNCTION TO COMPUTE THE PHOTOEFFECT TOTAL CROSS-SECTION  *
C.    *       AS A FUNCTION OF Z AND E                                 *
C.    *                                                                *
C.    *    ==>CALLED BY : special dE/dx                                *
C.    *                                                                *
C.    *    (1) Sandia parametrizsation is used;                        *
C.    *    (2) GPHSGP in cm**/g                                        *
C.    *    (3) E in GeV                                                *
C.    *                                                                *
C.    *     J. Chwastowski 31.03.93                                    *
C.    ******************************************************************
C.
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCONSP.
+CDE,GCUNIT
+CDE,GC10EV.
+SELF, IF=-SINGLE
      DOUBLE PRECISION EINV,ECUR,ONE
+SELF
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      RES = 0.
      IF(E.LT.G10EV) GO TO 20
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      IF(IELEM.GT.IQ(JPHXS-2)) THEN
         WRITE(CHMAIL,10010) IELEM, IQ(JPHXS-2)
10010 FORMAT(' *** GPHSGP : element N ',I6,' requested, ',
     +'but only ',I6,' elements in present mixture')
         CALL GMAIL(0,0)
         GOTO 20
      ENDIF
      JPHXSI = LQ(JPHXS-IELEM)
      IPOINT = JPHXSI+1
      IMAX = Q(IPOINT)
      IPOINT = IPOINT+1
      ECUR = E*1.E6
      IF(ECUR.LT.Q(IPOINT)) GO TO 20
      EINV = ONE/ECUR
      DO 10 I = 2,IMAX
         IPOINT = IPOINT+5
         IF(ECUR.LT.Q(IPOINT)) THEN
            J = IPOINT+1
            RES = EINV*(Q(J)+EINV*(Q(J+1)+EINV*(Q(J+2)+EINV*Q(J+3))))
            GO TO 20
         ENDIF
   10 CONTINUE
C This value is in cm**2/g
   20 GPHSGP = MAX(RES,0.)
C
      END
+DECK,GPHSIG
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      FUNCTION GPHSIG(Z,E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Function to compute the photoeffect total cross-section  *
C.    *       as a function of Z and E                                 *
C.    *           (E in GeV,  GPHSIG in barn)                          *
C.    *                                                                *
C.    *    ==>Called by : GPHOTI                                       *
C.    *       Author : L.Urban   *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
      DIMENSION EK(4),EL1(4),EL2(4),C(19)
      DATA EK / 0.66644E-8 , 0.22077E-9 ,-0.32552E-11, 0.18199E-13/
      DATA EL1/-0.29179E-9 , 0.87983E-10,-0.12589E-11, 0.69602E-14/
      DATA EL2/-0.68606E-9 , 0.10078E-9 ,-0.14496E-11, 0.78809E-14/
      DATA C  /-0.88893E-6 , 0.24394E-8 , 0.28835E-6 , 0.12133E-7,
     +         -0.31104E-6 ,-0.17284E-9 , 0.14400E-7 , 0.68357E-7,
     +          0.73945E-12,-0.48149E-10, 0.55823E-9 ,-0.10089E-9,
     +         -0.10927E-5 ,-0.97897E-9 , 0.12854E-6 ,-0.45803E-5,
     +          0.16858E-10, 0.12013E-6 , 0.16924E-7/
      DATA AZ,BE/3.845,2.975/
C.
C.    ------------------------------------------------------------------
C.
      Z2=Z*Z
      X=EMASS/E
      EKZ=Z2*(EK(1)+Z*(EK(2)+Z*(EK(3)+Z*EK(4))))
      IF(E.GT.EKZ)THEN
         X2=X*X
         S=C(1)/Z+C(2)*X+C(3)+C(4)*Z+C(5)/X+C(6)*Z2+C(7)*Z/X+C(8)/X2+
     +     C(9)*Z2*Z+C(10)*Z2/X+C(11)*Z/X2+C(12)/(X2*X)
         GO TO 50
      ENDIF
C
      EL1Z=Z2*(EL1(1)+Z*(EL1(2)+Z*(EL1(3)+Z*EL1(4))))
      IF(E.GT.EL1Z)THEN
         S=C(13)/Z+C(14)*X+C(15)
         GO TO 50
      ENDIF
C
      EL2Z=Z2*(EL2(1)+Z*(EL2(2)+Z*(EL2(3)+Z*EL2(4))))
      IF(E.GT.EL2Z)THEN
         S=C(16)/Z+C(17)*X+C(18)
      ELSE
         S=C(19)
      ENDIF
C
  50  GPHSIG=S*Z**AZ*X**BE
      IF(GPHSIG.LT.0.)GPHSIG=0.
C
      END
+DECK,GPHXIN.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHXIN
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize x-section constants for                       *
C.    *       the photoelectric effect                                 *
C.    *                                                                *
C.    *       The constants are from SANDIA REPORT SAND87-0070 UC-34   *
C.    *       by F. Biggs and R. Lighthill                             *
C.    *                                                                *
C.    *    ==>Called by : GPHINI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      IMPLICIT NONE
+CDE,GCPMXZ.
+CDE,GCPHXS.
+CDE,GC10EV.
+CDE,GCONSP.
      INTEGER I,J,K
      REAL TMP,TMP1
      CHARACTER*6 CTMP(MAXINT,MAXELZ)
      DIMENSION TMP(MAXPOW,MAXINT,MAXELZ),TMP1(MAXELZ)
      DATA (CTMP(I,  1),I=1,MAXINT)
     +/ 'K     ','.1    ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  2),I=1,MAXINT)
     +/ 'K     ','.15   ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  3),I=1,MAXINT)
     +/ 'K     ','.8    ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  4),I=1,MAXINT)
     +/ 'K     ','.8    ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  5),I=1,MAXINT)
     +/ 'K     ','.8    ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  6),I=1,MAXINT)
     +/ '.0457 ','K     ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  7),I=1,MAXINT)
     +/ '.0404 ','K     ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  8),I=1,MAXINT)
     +/ '.0483 ','K     ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  9),I=1,MAXINT)
     +/ '.0724 ','K     ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 10),I=1,MAXINT)
     +/ 'L3    ','L1    ','.124  ','K     ','4.    ','20.   '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 11),I=1,MAXINT)
     +/ 'L3    ','L1    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 12),I=1,MAXINT)
     +/ 'L3    ','.123  ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 13),I=1,MAXINT)
     +/ '.0159 ','L3    ','L1    ','K     ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I, 14),I=1,MAXINT)
     +/ '.0305 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 15),I=1,MAXINT)
     +/ '.0306 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 16),I=1,MAXINT)
     +/ '.0341 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 17),I=1,MAXINT)
     +/ '.0436 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 18),I=1,MAXINT)
     +/ '.0362 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 19),I=1,MAXINT)
     +/ '.0305 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 20),I=1,MAXINT)
     +/ '.0305 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 21),I=1,MAXINT)
     +/ 'M3    ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 22),I=1,MAXINT)
     +/ '.1    ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 23),I=1,MAXINT)
     +/ '.12   ','L3    ','L1    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 24),I=1,MAXINT)
     +/ '.106  ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 25),I=1,MAXINT)
     +/ '.1    ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 26),I=1,MAXINT)
     +/ '.024  ','.12   ','L3    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 27),I=1,MAXINT)
     +/ '.0308 ','.093  ','L3    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 28),I=1,MAXINT)
     +/ '.1    ','L3    ','L2    ','L1    ','K     ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I, 29),I=1,MAXINT)
     +/ '.1    ','L3    ','L1    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 30),I=1,MAXINT)
     +/ '.0307 ','.109  ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 31),I=1,MAXINT)
     +/ '.0278 ','.086  ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 32),I=1,MAXINT)
     +/ '.0305 ','.1    ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 33),I=1,MAXINT)
     +/ '.0371 ','.1    ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 34),I=1,MAXINT)
     +/ '.0371 ','.114  ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 35),I=1,MAXINT)
     +/ '.035  ','.1    ','.5    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 36),I=1,MAXINT)
     +/ '.0305 ','.097  ','.3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 37),I=1,MAXINT)
     +/ '.0305 ','M5    ','.3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 38),I=1,MAXINT)
     +/ '.0307 ','M5    ','.3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 39),I=1,MAXINT)
     +/ '.0232 ','.1677 ','.8    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 40),I=1,MAXINT)
     +/ 'M5    ','.5    ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 41),I=1,MAXINT)
     +/ '.0297 ','.2083 ','.9    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 42),I=1,MAXINT)
     +/ '.03   ','M5    ','.8    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 43),I=1,MAXINT)
     +/ '.068  ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 44),I=1,MAXINT)
     +/ '.0716 ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 45),I=1,MAXINT)
     +/ '.072  ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 46),I=1,MAXINT)
     +/ '.07   ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 47),I=1,MAXINT)
     +/ '.086  ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 48),I=1,MAXINT)
     +/ '.03   ','.098  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 49),I=1,MAXINT)
     +/ '.031  ','.103  ','M5    ','M2    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 50),I=1,MAXINT)
     +/ '.0318 ','.093  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 51),I=1,MAXINT)
     +/ '.0304 ','.096  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 52),I=1,MAXINT)
     +/ '.0528 ','.106  ','M5    ','M1    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 53),I=1,MAXINT)
     +/ '.034  ','.103  ','M5    ','M2    ','M1    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 54),I=1,MAXINT)
     +/ '.0515 ','.1073 ','M5    ','M3    ','M1    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 55),I=1,MAXINT)
     +/ '.0704 ','.111  ','M5    ','M2    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 56),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M2    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 57),I=1,MAXINT)
     +/ '.04   ','.13   ','M5    ','M3    ','M2    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 58),I=1,MAXINT)
     +/ '.053  ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 59),I=1,MAXINT)
     +/ '.04   ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 60),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M1    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 61),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 62),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 63),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 64),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 65),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 66),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 67),I=1,MAXINT)
     +/ '.0426 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 68),I=1,MAXINT)
     +/ '.0322 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 69),I=1,MAXINT)
     +/ '.031  ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 70),I=1,MAXINT)
     +/ '.075  ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 71),I=1,MAXINT)
     +/ '.09   ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 72),I=1,MAXINT)
     +/ '.0512 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 73),I=1,MAXINT)
     +/ '.0233 ','.0428 ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 74),I=1,MAXINT)
     +/ '.031  ','.0493 ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 75),I=1,MAXINT)
     +/ '.0384 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 76),I=1,MAXINT)
     +/ '.0464 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 77),I=1,MAXINT)
     +/ '.048  ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 78),I=1,MAXINT)
     +/ '.0266 ','.0735 ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 79),I=1,MAXINT)
     +/ '.07   ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 80),I=1,MAXINT)
     +/ '.09   ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 81),I=1,MAXINT)
     +/ '.0313 ','.0985 ','.386  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 82),I=1,MAXINT)
     +/ '.0311 ','.095  ','.413  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 83),I=1,MAXINT)
     +/ 'O5    ','O4    ','.0379 ','.1136 ','.362  ','M5    '
     +,'M3    ','L3    ','L2    ','L1    ','K     ','500.  ','I     ' /
      DATA (CTMP(I, 84),I=1,MAXINT)
     +/ '.0305 ','.07   ','.2415 ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 85),I=1,MAXINT)
     +/ '.0305 ','.072  ','.244  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 86),I=1,MAXINT)
     +/ '.0466 ','.093  ','.305  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 87),I=1,MAXINT)
     +/ '.0494 ','.196  ','.525  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 88),I=1,MAXINT)
     +/ '.0579 ','.15   ','.396  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 89),I=1,MAXINT)
     +/ '.0712 ','.216  ','.375  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 90),I=1,MAXINT)
     +/ 'O5    ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 91),I=1,MAXINT)
     +/ 'O5    ','.371  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 92),I=1,MAXINT)
     +/ '.0171 ','O5    ','.617  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 93),I=1,MAXINT)
     +/ 'O5    ','.431  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 94),I=1,MAXINT)
     +/ '.0306 ','O5    ','.405  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 95),I=1,MAXINT)
     +/ 'O5    ','.498  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 96),I=1,MAXINT)
     +/ 'O5    ','.498  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 97),I=1,MAXINT)
     +/ 'O5    ','.531  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 98),I=1,MAXINT)
     +/ 'O5    ','.548  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 99),I=1,MAXINT)
     +/ 'N5    ','M5    ','M4    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I,100),I=1,MAXINT)
     +/ 'N5    ','M5    ','M4    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
C
C For HYDROGEN the parametrization is changed below K shell
C  Orig. SANDIA     +   0.1000E-07,  0.0000E+00,  0.0000E+00,  0.0000E+00
C  New param        +   0.0000E+00,  0.0000E+00,  0.0000E+00,  0.0000E+00
C
      DATA ((TMP(I,J,  1),I=1,MAXPOW),J=1,MAXINT) /
     +   0.0000E+00,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.6383E+02, -0.6446E+01,  0.1317E+02, -0.5045E-01
     + ,  0.3051E+01, -0.7818E+01,  0.1144E+02,  0.6959E-01
     + ,  0.7636E-01, -0.9406E+00,  0.6144E+01,  0.1425E+01
     + ,  0.1180E-02, -0.8230E-01,  0.2880E+01,  0.5534E+01
     + ,  0.1620E-04, -0.5610E-02,  0.1214E+01,  0.1761E+02
     + ,  0.1034E-05, -0.4114E-03,  0.6287E+00,  0.3927E+02
     + ,  0.4599E-06,  0.5006E-03, -0.1425E-01,  0.1960E+03,  20*0.0 /
      DATA ((TMP(I,J,  2),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1000E-07,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1196E+04,  0.4759E+03,  0.1979E+02, -0.3540E+00
     + ,  0.1857E+02, -0.4079E+02,  0.8609E+02, -0.2618E+01
     + ,  0.1606E+01, -0.1726E+02,  0.8101E+02, -0.4928E+01
     + ,  0.3663E-02, -0.3782E+00,  0.2288E+02,  0.6006E+02
     + ,  0.5934E-03, -0.1109E+00,  0.1388E+02,  0.1680E+03
     + ,  0.1120E-04, -0.3894E-02,  0.6136E+01,  0.4354E+03
     + ,  0.4921E-05,  0.1493E-02,  0.4725E+01,  0.7128E+03,  20*0.0 /
      DATA ((TMP(I,J,  3),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.2418E+03,  0.3530E+02, -0.2699E+00,  0.5580E-03
     + , -0.1474E+03,  0.1578E+03,  0.2036E+03, -0.8521E+01
     + ,  0.4375E+01, -0.5094E+02,  0.3053E+03, -0.3064E+02
     + ,  0.4040E-01, -0.2930E+01,  0.1293E+03,  0.1828E+03
     + ,  0.3139E-02, -0.6107E+00,  0.7342E+02,  0.6852E+03
     + ,  0.4823E-04, -0.1161E-01,  0.2898E+02,  0.2129E+04
     + ,  0.2128E-04,  0.1951E-01,  0.1009E+02,  0.7144E+04,  24*0.0 /
      DATA ((TMP(I,J,  4),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.2785E+03,  0.1252E+03, -0.1912E+01,  0.8371E-02
     + , -0.4798E+03,  0.6302E+03,  0.4187E+03, -0.2783E+02
     + ,  0.1037E+02, -0.1280E+03,  0.8807E+03, -0.1646E+03
     + ,  0.1018E+00, -0.8264E+01,  0.4158E+03,  0.4366E+03
     + ,  0.5893E-02, -0.1595E+01,  0.2644E+03,  0.1566E+04
     + ,  0.2129E-03, -0.7972E-01,  0.1155E+03,  0.6065E+04
     + ,  0.7797E-04,  0.7695E-01,  0.3396E+02,  0.2439E+05,  24*0.0 /
      DATA ((TMP(I,J,  5),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.3387E+03,  0.1923E+03, -0.2742E+01,  0.1204E-01
     + , -0.9943E+03,  0.1816E+04,  0.3939E+03, -0.1755E+02
     + ,  0.3689E+01, -0.8834E+02,  0.1525E+04, -0.2145E+03
     + ,  0.6447E+00, -0.3953E+02,  0.1281E+04,  0.1768E+03
     + ,  0.1852E-02, -0.1358E+01,  0.5252E+03,  0.5160E+04
     + ,  0.4282E-03, -0.1297E+00,  0.2892E+03,  0.1601E+05
     + ,  0.1965E-03,  0.1947E+00,  0.1001E+03,  0.5902E+05,  24*0.0 /
      DATA ((TMP(I,J,  6),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5704E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.3935E+03,  0.3219E+03, -0.6549E+01,  0.2086E+00
     + , -0.9022E+03,  0.1760E+04,  0.1549E+04, -0.2280E+03
     + , -0.7363E+01, -0.1537E+01,  0.2672E+04, -0.4482E+03
     + ,  0.1640E+01, -0.9428E+02,  0.2872E+04, -0.5583E+03
     + , -0.3742E-02, -0.1232E+01,  0.9489E+03,  0.1406E+05
     + ,  0.6760E-03, -0.1164E+00,  0.6566E+03,  0.2739E+05
     + ,  0.4503E-03,  0.4692E+00,  0.2183E+03,  0.1308E+06,  20*0.0 /
      DATA ((TMP(I,J,  7),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1010E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.3622E+03,  0.3873E+03,  0.1244E+02, -0.4452E+00
     + , -0.2338E+04,  0.5732E+04, -0.2082E+03,  0.1482E+03
     + , -0.4940E+01, -0.8442E+02,  0.4620E+04, -0.1186E+04
     + ,  0.2019E+01, -0.1249E+03,  0.4609E+04, -0.9421E+03
     + ,  0.1709E-01, -0.8196E+01,  0.2345E+04,  0.1369E+05
     + ,  0.1872E-02, -0.6732E+00,  0.1282E+04,  0.5700E+05
     + ,  0.8122E-03,  0.8364E+00,  0.4410E+03,  0.2358E+06,  20*0.0 /
      DATA ((TMP(I,J,  8),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1144E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2863E+03,  0.4086E+03,  0.4436E+02, -0.1782E+01
     + , -0.7181E+02,  0.4748E+03,  0.5542E+04, -0.1363E+04
     + ,  0.2745E+01, -0.1747E+03,  0.7159E+04, -0.2213E+04
     + ,  0.3774E-01, -0.1559E+02,  0.4045E+04,  0.1810E+05
     + ,  0.3169E-02, -0.1146E+01,  0.2194E+04,  0.9131E+05
     + ,  0.1367E-02,  0.1473E+01,  0.7214E+03,  0.4048E+06,  24*0.0 /
      DATA ((TMP(I,J,  9),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1129E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2676E+03,  0.4767E+03,  0.8767E+02, -0.4504E+01
     + , -0.8907E+02,  0.6850E+03,  0.7217E+04, -0.2022E+04
     + ,  0.2813E+01, -0.2020E+03,  0.9903E+04, -0.4454E+04
     + ,  0.6097E-01, -0.2435E+02,  0.6099E+04,  0.2258E+05
     + ,  0.4857E-02, -0.1806E+01,  0.3335E+04,  0.1285E+06
     + ,  0.2041E-02,  0.2257E+01,  0.1084E+04,  0.5997E+06,  24*0.0 /
      DATA ((TMP(I,J, 10),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1000E-05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8235E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.6059E+04,  0.3242E+04, -0.1796E+03,  0.3141E+01
     + , -0.1940E+03,  0.4340E+03,  0.2357E+03, -0.1666E+02
     + , -0.8680E+02,  0.7434E+03,  0.1077E+05, -0.3822E+04
     + ,  0.3167E+01, -0.2491E+03,  0.1439E+05, -0.8187E+04
     + ,  0.1288E+00, -0.4471E+02,  0.9862E+04,  0.2497E+05
     + ,  0.5202E-02,  0.7337E-01,  0.4614E+04,  0.2256E+06
     + ,  0.3087E-02,  0.3402E+01,  0.1569E+04,  0.1147E+07,  16*0.0 /
      DATA ((TMP(I,J, 11),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5429E+02,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8874E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.5565E+03,  0.1000E+04,  0.1062E+03, -0.6846E+01
     + ,  0.1732E+01, -0.1853E+03,  0.1712E+05, -0.8415E+04
     + ,  0.2726E+00, -0.8218E+02,  0.1475E+05,  0.9467E+04
     + ,  0.2083E-02,  0.4548E+01,  0.5521E+04,  0.3358E+06
     + ,  0.4199E-02,  0.4808E+01,  0.1793E+04,  0.1898E+07,  24*0.0 /
      DATA ((TMP(I,J, 12),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.5574E+03,  0.8687E+02, -0.1493E+01,  0.8660E-02
     + , -0.2726E+05,  0.9700E+04, -0.6921E+03,  0.1446E+02
     + , -0.6179E+03,  0.1379E+04,  0.2321E+03, -0.2291E+02
     + , -0.6648E+00, -0.1084E+03,  0.2219E+05, -0.1241E+05
     + ,  0.4080E+00, -0.1205E+03,  0.2139E+05, -0.1143E+03
     + ,  0.8338E-02,  0.2236E+01,  0.8819E+04,  0.4284E+06
     + ,  0.6233E-02,  0.7344E+01,  0.2662E+04,  0.2460E+07,  24*0.0 /
      DATA ((TMP(I,J, 13),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.1654E+05,  0.1585E+03,  0.3907E+01, -0.3383E-01
     + ,  0.1122E+04, -0.4015E+02,  0.6623E+00, -0.2813E-02
     + ,  0.2390E+05, -0.6953E+03, -0.7978E+02,  0.1974E+01
     + , -0.5284E+03,  0.1399E+04,  0.4360E+03, -0.4747E+02
     + , -0.3674E+01, -0.1622E+02,  0.2732E+05, -0.1752E+05
     + ,  0.4158E+00, -0.1351E+03,  0.2716E+05,  0.3723E+03
     + ,  0.1125E-01,  0.2747E+01,  0.1174E+05,  0.5695E+06
     + ,  0.8505E-02,  0.1041E+02,  0.4429E+04,  0.2413E+07,  20*0.0 /
      DATA ((TMP(I,J, 14),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4575E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1168E+03,  0.1269E+03, -0.5506E+01,  0.6616E-01
     + , -0.6451E+03,  0.1836E+04,  0.5350E+03, -0.6436E+02
     + , -0.4056E+01, -0.1089E+02,  0.3544E+05, -0.2595E+05
     + ,  0.4945E+00, -0.1682E+03,  0.3627E+05, -0.1605E+05
     + ,  0.2716E-01, -0.5428E+01,  0.1775E+05,  0.6765E+06
     + ,  0.1127E-01,  0.1376E+02,  0.4871E+04,  0.4477E+07,  24*0.0 /
      DATA ((TMP(I,J, 15),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4728E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2227E+03,  0.2204E+03, -0.1122E+02,  0.1569E+00
     + , -0.5700E+03,  0.1909E+04,  0.7651E+03, -0.1123E+03
     + , -0.6098E+01,  0.7712E+02,  0.4196E+05, -0.3437E+05
     + ,  0.5710E+00, -0.2001E+03,  0.4505E+05, -0.3853E+05
     + ,  0.3613E-01, -0.8426E+01,  0.2277E+05,  0.8080E+06
     + ,  0.1421E-01,  0.1770E+02,  0.6221E+04,  0.5554E+07,  24*0.0 /
      DATA ((TMP(I,J, 16),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5368E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2097E+03,  0.3174E+03, -0.1815E+02,  0.2796E+00
     + , -0.4885E+03,  0.1976E+04,  0.1206E+04, -0.1934E+03
     + , -0.1021E+02,  0.2346E+03,  0.5164E+05, -0.4707E+05
     + ,  0.7467E+00, -0.2534E+03,  0.5800E+05, -0.6691E+05
     + ,  0.6338E-01, -0.3443E+02,  0.4058E+05,  0.2233E+06
     + ,  0.1867E-01,  0.2398E+02,  0.6706E+04,  0.8358E+07,  24*0.0 /
      DATA ((TMP(I,J, 17),I=1,MAXPOW),J=1,MAXINT) /
     +   0.7808E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.6163E+02,  0.3934E+03, -0.2563E+02,  0.4396E+00
     + , -0.2147E+03,  0.1269E+04,  0.2099E+04, -0.3705E+03
     + , -0.1192E+02,  0.3253E+03,  0.5927E+05, -0.5980E+05
     + ,  0.8789E+00, -0.2920E+03,  0.6860E+05, -0.1018E+06
     + ,  0.6556E-01, -0.2175E+02,  0.3895E+05,  0.9737E+06
     + ,  0.2236E-01,  0.2884E+02,  0.9717E+04,  0.9001E+07,  24*0.0 /
      DATA ((TMP(I,J, 18),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1275E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1674E+04,  0.1047E+04, -0.9010E+02,  0.2166E+01
     + , -0.2244E+03,  0.1388E+04,  0.2571E+04, -0.5113E+03
     + , -0.1446E+02,  0.4359E+03,  0.6578E+05, -0.7284E+05
     + ,  0.8786E+00, -0.3001E+03,  0.7682E+05, -0.1219E+06
     + ,  0.6779E-01, -0.2695E+02,  0.5069E+05,  0.5281E+06
     + ,  0.2598E-01,  0.3454E+02,  0.1059E+05,  0.1068E+08,  24*0.0 /
      DATA ((TMP(I,J, 19),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3111E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.6162E+02,  0.5770E+03, -0.4497E+02,  0.9218E+00
     + , -0.3601E+03,  0.2287E+04,  0.2513E+04, -0.4591E+03
     + , -0.2113E+02,  0.7161E+03,  0.8183E+05, -0.9859E+05
     + ,  0.1048E+01, -0.3644E+03,  0.9844E+05, -0.1760E+06
     + ,  0.1040E+00, -0.3553E+02,  0.6096E+05,  0.1226E+07
     + ,  0.3453E-01,  0.4621E+02,  0.1669E+05,  0.1238E+08,  24*0.0 /
      DATA ((TMP(I,J, 20),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3029E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3816E+03,  0.5887E+03, -0.4888E+02,  0.1019E+01
     + , -0.1054E+03,  0.1120E+04,  0.5115E+04, -0.1325E+04
     + , -0.3015E+02,  0.1141E+04,  0.9459E+05, -0.1195E+06
     + ,  0.1408E+01, -0.4553E+03,  0.1206E+06, -0.2531E+06
     + ,  0.1204E+00, -0.5356E+02,  0.8779E+05,  0.6252E+06
     + ,  0.4178E-01,  0.5761E+02,  0.1377E+05,  0.2019E+08,  24*0.0 /
      DATA ((TMP(I,J, 21),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1121E+04,  0.7413E+01, -0.3020E+00,  0.1510E-02
     + ,  0.2970E+03,  0.6359E+03, -0.4935E+02,  0.1044E+01
     + , -0.1507E+03,  0.1501E+04,  0.5139E+04, -0.1442E+04
     + ,  0.4615E+00, -0.2614E+03,  0.1217E+06, -0.2057E+06
     + ,  0.1509E+00, -0.6913E+02,  0.9253E+05,  0.1096E+07
     + ,  0.4833E-01,  0.6880E+02,  0.2762E+05,  0.1290E+08,  28*0.0 /
      DATA ((TMP(I,J, 22),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3596E+04, -0.6877E+02,  0.9609E+00, -0.4754E-02
     + , -0.3132E+03,  0.1024E+04, -0.1008E+03,  0.3096E+01
     + , -0.4626E+02,  0.8678E+03,  0.7308E+04, -0.2383E+04
     + ,  0.2074E+00, -0.2292E+03,  0.1371E+06, -0.2489E+06
     + ,  0.1972E+00, -0.9550E+02,  0.1106E+06,  0.1067E+07
     + ,  0.5606E-01,  0.8140E+02,  0.3106E+05,  0.1567E+08,  28*0.0 /
      DATA ((TMP(I,J, 23),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4117E+04, -0.1054E+03,  0.1531E+01, -0.7725E-02
     + , -0.4052E+03,  0.1169E+04, -0.1212E+03,  0.4148E+01
     + ,  0.9968E+04, -0.1796E+04, -0.1204E+04,  0.1481E+04
     + , -0.1429E+03,  0.1632E+04,  0.7203E+04, -0.2283E+04
     + ,  0.3940E+00, -0.2733E+03,  0.1564E+06, -0.3184E+06
     + ,  0.2007E+00, -0.8911E+02,  0.1254E+06,  0.1137E+07
     + ,  0.6449E-01,  0.9483E+02,  0.3584E+05,  0.1821E+08,  24*0.0 /
      DATA ((TMP(I,J, 24),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5069E+04, -0.7968E+02,  0.8395E+00, -0.4494E-02
     + , -0.4404E+03,  0.1301E+04, -0.1166E+03,  0.3481E+01
     + ,  0.3932E+02,  0.1537E+03,  0.1228E+05, -0.4984E+04
     + ,  0.2740E+00, -0.2665E+03,  0.1818E+06, -0.3997E+06
     + ,  0.2727E+00, -0.1288E+03,  0.1543E+06,  0.9755E+06
     + ,  0.7660E-01,  0.1142E+03,  0.4290E+05,  0.2161E+08,  28*0.0 /
      DATA ((TMP(I,J, 25),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5692E+04, -0.1278E+03,  0.1150E+01, -0.3774E-02
     + , -0.4901E+03,  0.1450E+04, -0.1365E+03,  0.4134E+01
     + , -0.3065E+02,  0.7209E+03,  0.1275E+05, -0.5462E+04
     + ,  0.2930E+00, -0.2703E+03,  0.2034E+06, -0.4886E+06
     + ,  0.2940E+00, -0.1342E+03,  0.1761E+06,  0.8747E+06
     + ,  0.8736E-01,  0.1322E+03,  0.4952E+05,  0.2436E+08,  28*0.0 /
      DATA ((TMP(I,J, 26),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.3328E+04,  0.2590E+03, -0.3812E+01,  0.1679E-01
     + ,  0.4132E+04,  0.3963E+03, -0.2505E+02,  0.3437E+00
     + , -0.2683E+02,  0.1250E+04, -0.7321E+02,  0.1137E+01
     + , -0.8128E+01,  0.6550E+03,  0.1511E+05, -0.7079E+04
     + ,  0.2151E+00, -0.2680E+03,  0.2341E+06, -0.6063E+06
     + ,  0.3511E+00, -0.1633E+03,  0.2090E+06,  0.7131E+06
     + ,  0.1026E+00,  0.1572E+03,  0.5901E+05,  0.2806E+08,  24*0.0 /
      DATA ((TMP(I,J, 27),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2074E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.6932E+04, -0.6765E-01, -0.9182E+01,  0.1423E+00
     + , -0.8228E+03,  0.1982E+04, -0.1782E+03,  0.4937E+01
     + ,  0.2092E+02,  0.3311E+03,  0.1820E+05, -0.9303E+04
     + ,  0.4947E-01, -0.2478E+03,  0.2586E+06, -0.7185E+06
     + ,  0.3588E+00, -0.1492E+03,  0.2296E+06,  0.8856E+06
     + ,  0.1154E+00,  0.1796E+03,  0.6740E+05,  0.3100E+08,  24*0.0 /
      DATA ((TMP(I,J, 28),I=1,MAXPOW),J=1,MAXINT) /
     +   0.8515E+04, -0.2121E+03,  0.2132E+01, -0.7667E-02
     + , -0.1021E+04,  0.2388E+04, -0.2361E+03,  0.7261E+01
     + ,  0.0000E+00,  0.6600E+04,  0.0000E+00,  0.0000E+00
     + ,  0.0000E+00,  0.9810E+04,  0.0000E+00,  0.0000E+00
     + , -0.1175E+03,  0.2171E+04,  0.1514E+05, -0.6042E+04
     + ,  0.1685E-01, -0.2522E+03,  0.3005E+06, -0.9000E+06
     + ,  0.4681E+00, -0.2085E+03,  0.2782E+06,  0.4399E+06
     + ,  0.1364E+00,  0.2148E+03,  0.8039E+05,  0.3626E+08,  20*0.0 /
      DATA ((TMP(I,J, 29),I=1,MAXPOW),J=1,MAXINT) /
     +   0.9992E+04, -0.3780E+03,  0.5657E+01, -0.2788E-01
     + , -0.8896E+03,  0.2391E+04, -0.1986E+03,  0.3649E+01
     + , -0.5089E+03,  0.4139E+04,  0.7468E+04, -0.6981E+03
     + , -0.9173E+02,  0.1862E+04,  0.1777E+05, -0.8202E+04
     + ,  0.7440E-02, -0.2371E+03,  0.3202E+06, -0.1028E+07
     + ,  0.4729E+00, -0.2055E+03,  0.3000E+06,  0.2182E+06
     + ,  0.1472E+00,  0.2345E+03,  0.8644E+05,  0.3990E+08,  24*0.0 /
      DATA ((TMP(I,J, 30),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1479E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1325E+05, -0.6762E+03,  0.1188E+02, -0.6785E-01
     + , -0.1330E+04,  0.3104E+04, -0.3092E+03,  0.8946E+01
     + , -0.2807E+05,  0.1091E+06, -0.1511E+06,  0.7897E+05
     + , -0.3057E+04,  0.1385E+05,  0.3780E+03, -0.2163E+03
     + , -0.8018E+02,  0.1794E+04,  0.2095E+05, -0.1070E+05
     + , -0.1158E+01, -0.3871E+02,  0.3499E+06, -0.1154E+07
     + ,  0.4820E+00, -0.1832E+03,  0.3296E+06,  0.6802E+06
     + ,  0.1669E+00,  0.2696E+03,  0.1000E+06,  0.4382E+08,  16*0.0 /
      DATA ((TMP(I,J, 31),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1479E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1211E+05, -0.7144E+03,  0.1535E+02, -0.1030E+00
     + , -0.1199E+04,  0.3215E+04, -0.3594E+03,  0.1152E+02
     + , -0.1457E+05,  0.6363E+05, -0.1011E+06,  0.6416E+05
     + ,  0.3470E+04, -0.8674E+04,  0.2548E+05, -0.8411E+04
     + , -0.9431E+02,  0.2078E+04,  0.2172E+05, -0.1101E+05
     + , -0.1253E+01, -0.2897E+02,  0.3783E+06, -0.1357E+07
     + ,  0.5591E+00, -0.2217E+03,  0.3625E+06,  0.3392E+06
     + ,  0.1949E+00,  0.2371E+03,  0.1767E+06,  0.2400E+08,  16*0.0 /
      DATA ((TMP(I,J, 32),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4941E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1269E+05, -0.9339E+03,  0.2767E+02, -0.1952E+00
     + , -0.1358E+04,  0.3695E+04, -0.4569E+03,  0.1599E+02
     + , -0.7402E+04,  0.3636E+05, -0.6670E+05,  0.5346E+05
     + , -0.3400E+03,  0.3232E+04,  0.1163E+05, -0.1089E+04
     + , -0.5940E+02,  0.1646E+04,  0.2621E+05, -0.1507E+05
     + , -0.2025E+01,  0.1283E+03,  0.4069E+06, -0.1510E+07
     + ,  0.6478E+00, -0.2603E+03,  0.4045E+06, -0.5153E+05
     + ,  0.2155E+00,  0.2609E+03,  0.2074E+06,  0.2220E+08,  16*0.0 /
      DATA ((TMP(I,J, 33),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2547E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2402E+05, -0.3110E+04,  0.1364E+03, -0.1877E+01
     + , -0.1536E+04,  0.4198E+04, -0.5497E+03,  0.1920E+02
     + , -0.4525E+04,  0.2468E+05, -0.5130E+05,  0.5102E+05
     + , -0.3858E+03,  0.1013E+05,  0.3603E+04, -0.7657E+03
     + , -0.5339E+02,  0.1649E+04,  0.2950E+05, -0.1800E+05
     + , -0.1655E+01,  0.8588E+02,  0.4504E+06, -0.1795E+07
     + ,  0.7880E+00, -0.3490E+03,  0.4641E+06, -0.1258E+07
     + ,  0.2393E+00,  0.2906E+03,  0.2360E+06,  0.2145E+08,  16*0.0 /
      DATA ((TMP(I,J, 34),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1577E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1806E+05, -0.2230E+04,  0.9408E+02, -0.1263E+01
     + , -0.1610E+04,  0.4614E+04, -0.6392E+03,  0.2252E+02
     + , -0.6637E+03,  0.4194E+04, -0.1104E+05,  0.2806E+05
     + , -0.4265E+03,  0.9660E+04,  0.5343E+04, -0.1174E+04
     + , -0.3968E+02,  0.1459E+04,  0.3327E+05, -0.2229E+05
     + , -0.3461E+01,  0.4401E+03,  0.4690E+06, -0.1943E+07
     + ,  0.8564E+00, -0.3723E+03,  0.5020E+06, -0.1430E+07
     + ,  0.2590E+00,  0.3237E+03,  0.2541E+06,  0.2321E+08,  16*0.0 /
      DATA ((TMP(I,J, 35),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2129E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1451E+05, -0.1941E+04,  0.8744E+02, -0.1214E+01
     + , -0.3534E+04,  0.6788E+04, -0.1134E+04,  0.5165E+02
     + , -0.3347E+03,  0.2195E+04,  0.1033E+04, -0.2839E+03
     + ,  0.1461E+03, -0.1050E+04,  0.3457E+04,  0.2000E+05
     + , -0.4318E+03,  0.1070E+05,  0.6548E+04, -0.1535E+04
     + , -0.4033E+02,  0.1607E+04,  0.3681E+05, -0.2478E+05
     + , -0.3955E+01,  0.5482E+03,  0.5202E+06, -0.2262E+07
     + ,  0.9718E+00, -0.4209E+03,  0.5662E+06, -0.2099E+07
     + ,  0.2907E+00,  0.3653E+03,  0.2908E+06,  0.2417E+08,  12*0.0 /
      DATA ((TMP(I,J, 36),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3691E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2024E+04, -0.2083E+03,  0.4439E+01,  0.1056E+00
     + ,  0.7648E+03,  0.5257E+04, -0.9960E+03,  0.4686E+02
     + , -0.2451E+03,  0.2199E+04,  0.1217E+04, -0.3120E+03
     + ,  0.3611E+03, -0.2974E+04,  0.1308E+05,  0.1268E+05
     + , -0.4163E+03,  0.1017E+05,  0.7535E+04, -0.1891E+04
     + , -0.9924E+00,  0.8455E-01,  0.4446E+05, -0.3490E+05
     + , -0.3076E+01,  0.4257E+03,  0.5613E+06, -0.2587E+07
     + ,  0.1050E+01, -0.4435E+03,  0.6114E+06, -0.3028E+07
     + ,  0.3136E+00,  0.3952E+03,  0.3252E+06,  0.2248E+08,  12*0.0 /
      DATA ((TMP(I,J, 37),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4606E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1441E+04, -0.1761E+03,  0.6821E+01,  0.4470E-01
     + , -0.6763E+03,  0.6772E+04, -0.1372E+04,  0.7035E+02
     + , -0.3457E+03,  0.2591E+04,  0.1242E+04, -0.3481E+03
     + ,  0.3524E+03, -0.3194E+04,  0.1657E+05,  0.1224E+05
     + , -0.4025E+03,  0.1067E+05,  0.8396E+04, -0.2275E+04
     + ,  0.5234E+01,  0.7494E+03,  0.5033E+05, -0.4276E+05
     + , -0.2207E+01,  0.2653E+03,  0.6269E+06, -0.3163E+07
     + ,  0.1101E+01, -0.4280E+03,  0.6664E+06, -0.3481E+07
     + ,  0.3467E+00,  0.4515E+03,  0.3525E+06,  0.2783E+08,  12*0.0 /
      DATA ((TMP(I,J, 38),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4850E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.7854E+03, -0.6513E+02,  0.2134E+01,  0.1138E+00
     + , -0.2484E+04,  0.8950E+04, -0.2019E+04,  0.1171E+03
     + , -0.3209E+03,  0.2818E+04,  0.1344E+04, -0.3984E+03
     + ,  0.2746E+03, -0.2830E+04,  0.2149E+05,  0.7655E+04
     + , -0.4181E+03,  0.1025E+05,  0.1159E+05, -0.3199E+04
     + , -0.4367E+02,  0.1966E+04,  0.4835E+05, -0.3788E+05
     + , -0.5177E+00, -0.2546E+02,  0.6941E+06, -0.3733E+07
     + ,  0.1296E+01, -0.5192E+03,  0.7384E+06, -0.5040E+07
     + ,  0.3800E+00,  0.4950E+03,  0.4110E+06,  0.1955E+08,  12*0.0 /
      DATA ((TMP(I,J, 39),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3854E+05, -0.1366E+04,  0.1672E+02, -0.6795E-01
     + ,  0.2849E+04, -0.2828E+03,  0.1529E+02, -0.1723E+00
     + , -0.6721E+04,  0.1290E+05, -0.3111E+04,  0.1985E+03
     + ,  0.3585E+03, -0.4223E+03,  0.6620E+04, -0.2706E+04
     + , -0.8813E+02,  0.1840E+04,  0.2198E+05, -0.1440E+04
     + , -0.4141E+03,  0.1043E+05,  0.1385E+05, -0.4020E+04
     + , -0.1282E+02,  0.1204E+04,  0.6028E+05, -0.5752E+05
     + ,  0.4265E+00, -0.1646E+03,  0.7684E+06, -0.4421E+07
     + ,  0.1334E+01, -0.4917E+03,  0.8066E+06, -0.5879E+07
     + ,  0.4194E+00,  0.5651E+03,  0.4353E+06,  0.2981E+08,  12*0.0 /
      DATA ((TMP(I,J, 40),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2993E+03,  0.1449E+03, -0.3012E+01,  0.1713E-01
     + , -0.7040E+04,  0.1434E+05, -0.3926E+04,  0.2887E+03
     + , -0.1647E+03,  0.2296E+04,  0.3166E+04, -0.1127E+04
     + , -0.2164E+03,  0.3512E+04,  0.2053E+05, -0.3382E+04
     + , -0.3996E+03,  0.1064E+05,  0.1548E+05, -0.4776E+04
     + , -0.3011E+02,  0.1794E+04,  0.6153E+05, -0.5699E+05
     + , -0.5900E+00,  0.1945E+03,  0.8031E+06, -0.4579E+07
     + ,  0.1474E+01, -0.5530E+03,  0.8907E+06, -0.7927E+07
     + ,  0.4562E+00,  0.6248E+03,  0.4760E+06,  0.3216E+08,  16*0.0 /
      DATA ((TMP(I,J, 41),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3251E+04, -0.6844E+02,  0.1575E+01, -0.1094E-01
     + ,  0.2764E+04, -0.4897E+03,  0.4237E+02, -0.8372E+00
     + , -0.2018E+04,  0.8543E+04, -0.1769E+04,  0.2770E+02
     + ,  0.2150E+03,  0.4490E+03,  0.6409E+04, -0.2429E+04
     + , -0.2981E+03,  0.6188E+04,  0.1735E+05, -0.4420E+04
     + , -0.3923E+03,  0.1102E+05,  0.1751E+05, -0.5733E+04
     + , -0.1658E+02,  0.1435E+04,  0.7050E+05, -0.7037E+05
     + , -0.2292E+01,  0.5516E+03,  0.8555E+06, -0.5018E+07
     + ,  0.1599E+01, -0.5764E+03,  0.9643E+06, -0.8517E+07
     + ,  0.4986E+00,  0.7224E+03,  0.4910E+06,  0.4104E+08,  12*0.0 /
      DATA ((TMP(I,J, 42),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.3508E+04,  0.3050E+03, -0.4620E+01,  0.1998E-01
     + ,  0.3053E+04, -0.6192E+03,  0.5104E+02, -0.9955E+00
     + , -0.7786E+04,  0.1722E+05, -0.5215E+04,  0.3992E+03
     + , -0.1114E+03,  0.1895E+04,  0.5405E+04, -0.2261E+04
     + , -0.3027E+03,  0.7576E+04,  0.1570E+05, -0.4795E+04
     + , -0.3784E+03,  0.1099E+05,  0.1983E+05, -0.6801E+04
     + , -0.1840E+02,  0.1552E+04,  0.7635E+05, -0.8181E+05
     + , -0.2256E+01,  0.7317E+03,  0.9005E+06, -0.5349E+07
     + ,  0.1540E+01, -0.4834E+03,  0.1021E+07, -0.9300E+07
     + ,  0.5359E+00,  0.7662E+03,  0.5243E+06,  0.5200E+08,  12*0.0 /
      DATA ((TMP(I,J, 43),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2680E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.7592E+03,  0.8677E+03, -0.1346E+03,  0.6198E+01
     + , -0.3269E+05,  0.4110E+05, -0.1328E+05,  0.1384E+04
     + , -0.3863E+03,  0.3458E+04,  0.3500E+04, -0.1341E+04
     + , -0.2871E+03,  0.7198E+04,  0.1867E+05, -0.5767E+04
     + , -0.1101E+03,  0.1625E+05,  0.3183E+04, -0.1491E+04
     + , -0.2936E+02,  0.1924E+04,  0.7955E+05, -0.8669E+05
     + ,  0.5721E+00,  0.7164E+02,  0.1004E+07, -0.6678E+07
     + ,  0.1769E+01, -0.5691E+03,  0.1097E+07, -0.1069E+08
     + ,  0.5748E+00,  0.8119E+03,  0.6113E+06,  0.3605E+08,  12*0.0 /
      DATA ((TMP(I,J, 44),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2116E+04,  0.1001E+03, -0.2614E+01,  0.1466E-01
     + ,  0.1947E+03,  0.7270E+03, -0.1490E+03,  0.8092E+01
     + , -0.2141E+05,  0.2872E+05, -0.8592E+04,  0.8312E+03
     + , -0.2430E+01,  0.2793E+04,  0.5237E+04, -0.2042E+04
     + , -0.2831E+03,  0.7880E+04,  0.1913E+05, -0.6518E+04
     + , -0.3547E+03,  0.1093E+05,  0.2575E+05, -0.9586E+04
     + , -0.1311E+02,  0.1428E+04,  0.9237E+05, -0.1148E+06
     + ,  0.1007E-01,  0.1277E+03,  0.1086E+07, -0.7755E+07
     + ,  0.1633E+01, -0.4030E+03,  0.1144E+07, -0.9817E+07
     + ,  0.6218E+00,  0.9117E+03,  0.5873E+06,  0.6614E+08,  12*0.0 /
      DATA ((TMP(I,J, 45),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2535E+04,  0.1329E+03, -0.3193E+01,  0.1648E-01
     + , -0.1037E+04,  0.1357E+04, -0.2412E+03,  0.1212E+02
     + ,  0.1155E+04,  0.3456E+04,  0.8529E+03, -0.3075E+03
     + , -0.4773E+03,  0.3678E+04,  0.5261E+04, -0.2225E+04
     + , -0.2665E+03,  0.7197E+04,  0.2390E+05, -0.7946E+04
     + , -0.3285E+03,  0.9342E+04,  0.3454E+05, -0.1203E+05
     + , -0.2532E+02,  0.2009E+04,  0.9447E+05, -0.1115E+06
     + , -0.3043E+01,  0.9079E+03,  0.1126E+07, -0.8086E+07
     + ,  0.1870E+01, -0.4570E+03,  0.1251E+07, -0.1191E+08
     + ,  0.6726E+00,  0.9644E+03,  0.7281E+06,  0.4409E+08,  12*0.0 /
      DATA ((TMP(I,J, 46),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1095E+05, -0.2552E+03,  0.1914E+01, -0.3916E-02
     + ,  0.2418E+04,  0.9664E+02, -0.1050E+03,  0.9047E+01
     + , -0.1605E+05,  0.3107E+05, -0.1240E+05,  0.1658E+04
     + , -0.4705E+03,  0.3846E+04,  0.5959E+04, -0.2639E+04
     + , -0.2530E+03,  0.7129E+04,  0.2620E+05, -0.9068E+04
     + , -0.3225E+03,  0.1001E+05,  0.3550E+05, -0.1354E+05
     + ,  0.1642E+02,  0.4603E+03,  0.1181E+06, -0.1737E+06
     + , -0.2888E+01,  0.8714E+03,  0.1203E+07, -0.9306E+07
     + ,  0.1857E+01, -0.3662E+03,  0.1308E+07, -0.1219E+08
     + ,  0.7151E+00,  0.1066E+04,  0.7318E+06,  0.6061E+08,  12*0.0 /
      DATA ((TMP(I,J, 47),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1054E+05, -0.1973E+03,  0.1033E+01, -0.6574E-03
     + , -0.4089E+04,  0.3916E+04, -0.8005E+03,  0.4841E+02
     + , -0.2951E+04,  0.6256E+04,  0.1909E+04, -0.8620E+03
     + , -0.2321E+02,  0.1892E+04,  0.9451E+04, -0.4150E+04
     + , -0.2547E+03,  0.7851E+04,  0.2733E+05, -0.1038E+05
     + , -0.3170E+03,  0.1045E+05,  0.3850E+05, -0.1560E+05
     + , -0.1817E+01,  0.1265E+04,  0.1192E+06, -0.1684E+06
     + , -0.4061E+01,  0.1339E+04,  0.1260E+07, -0.9752E+07
     + ,  0.2065E+01, -0.4444E+03,  0.1433E+07, -0.1533E+08
     + ,  0.7734E+00,  0.1157E+04,  0.8006E+06,  0.6214E+08,  12*0.0 /
      DATA ((TMP(I,J, 48),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1876E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8550E+04, -0.2785E+03,  0.2021E+01,  0.1032E-01
     + ,  0.4933E+03,  0.1167E+04, -0.3452E+03,  0.2759E+02
     + ,  0.2088E+04,  0.3036E+04,  0.1247E+04, -0.2691E+03
     + ,  0.7508E+01,  0.2031E+04,  0.1014E+05, -0.4621E+04
     + , -0.2454E+03,  0.8162E+04,  0.2822E+05, -0.1156E+05
     + , -0.2677E+03,  0.8244E+04,  0.4935E+05, -0.1791E+05
     + , -0.2306E+02,  0.2129E+04,  0.1161E+06, -0.1547E+06
     + , -0.8206E+01,  0.2269E+04,  0.1268E+07, -0.9746E+07
     + ,  0.2254E+01, -0.4904E+03,  0.1506E+07, -0.1642E+08
     + ,  0.8123E+00,  0.1229E+04,  0.8686E+06,  0.5293E+08,  8*0.0 /
      DATA ((TMP(I,J, 49),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1702E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2333E+05, -0.1510E+04,  0.3498E+02, -0.2775E+00
     + , -0.4354E+04,  0.4933E+04, -0.1221E+04,  0.9073E+02
     + , -0.2048E+04,  0.9964E+04, -0.2857E+04,  0.7223E+03
     + , -0.1763E+03,  0.3053E+04,  0.9756E+04, -0.4718E+04
     + , -0.2324E+03,  0.7725E+04,  0.3333E+05, -0.1361E+05
     + , -0.2675E+03,  0.8828E+04,  0.5249E+05, -0.2065E+05
     + , -0.2149E+02,  0.2143E+04,  0.1256E+06, -0.1775E+06
     + , -0.2097E+01,  0.1045E+04,  0.1428E+07, -0.1216E+08
     + ,  0.2233E+01, -0.3526E+03,  0.1578E+07, -0.1747E+08
     + ,  0.8685E+00,  0.1331E+04,  0.9171E+06,  0.6234E+08,  8*0.0 /
      DATA ((TMP(I,J, 50),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1857E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3071E+05, -0.2069E+04,  0.4886E+02, -0.3894E+00
     + ,  0.6119E+02,  0.1769E+04, -0.5287E+03,  0.4438E+02
     + ,  0.2325E+04,  0.2905E+04,  0.1395E+04, -0.1160E+03
     + , -0.8411E+03,  0.7174E+04,  0.3429E+04, -0.1945E+04
     + , -0.2078E+03,  0.6795E+04,  0.3953E+05, -0.1546E+05
     + , -0.2735E+03,  0.1006E+05,  0.5154E+05, -0.2316E+05
     + ,  0.1409E+02,  0.5245E+03,  0.1554E+06, -0.2738E+06
     + , -0.6053E+01,  0.2153E+04,  0.1430E+07, -0.1218E+08
     + ,  0.2434E+01, -0.4441E+03,  0.1694E+07, -0.2116E+08
     + ,  0.9156E+00,  0.1438E+04,  0.9506E+06,  0.6990E+08,  8*0.0 /
      DATA ((TMP(I,J, 51),I=1,MAXPOW),J=1,MAXINT) /
     +   0.7076E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2538E+05, -0.2014E+04,  0.5518E+02, -0.5093E+00
     + , -0.2753E+04,  0.3809E+04, -0.9187E+03,  0.6404E+02
     + ,  0.4191E+04,  0.1201E+04,  0.6138E+03,  0.8057E+03
     + ,  0.9566E+02,  0.1292E+04,  0.1534E+05, -0.8151E+04
     + , -0.2154E+03,  0.7884E+04,  0.3884E+05, -0.1742E+05
     + , -0.2413E+03,  0.8640E+04,  0.6267E+05, -0.2629E+05
     + , -0.2300E+02,  0.2351E+04,  0.1410E+06, -0.2130E+06
     + , -0.9816E+01,  0.3157E+04,  0.1443E+07, -0.1193E+08
     + ,  0.2470E+01, -0.3671E+03,  0.1779E+07, -0.2260E+08
     + ,  0.9713E+00,  0.1520E+04,  0.1016E+07,  0.7466E+08,  8*0.0 /
      DATA ((TMP(I,J, 52),I=1,MAXPOW),J=1,MAXINT) /
     +   0.9416E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.5818E+05,  0.1470E+05, -0.1039E+04,  0.2257E+02
     + , -0.2734E+04,  0.3947E+04, -0.9985E+03,  0.7313E+02
     + , -0.1058E+06,  0.2917E+06, -0.2491E+06,  0.7124E+05
     + , -0.4397E+02,  0.2059E+04,  0.1571E+05, -0.9021E+04
     + , -0.1946E+03,  0.7129E+04,  0.4399E+05, -0.1939E+05
     + , -0.2372E+03,  0.9166E+04,  0.6308E+05, -0.2911E+05
     + ,  0.1086E+01,  0.1149E+04,  0.1640E+06, -0.2950E+06
     + , -0.3401E+01,  0.1832E+04,  0.1571E+07, -0.1426E+08
     + ,  0.2389E+01, -0.1733E+03,  0.1798E+07, -0.2273E+08
     + ,  0.1007E+01,  0.1586E+04,  0.1076E+07,  0.7154E+08,  8*0.0 /
      DATA ((TMP(I,J, 53),I=1,MAXPOW),J=1,MAXINT) /
     +   0.7020E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2410E+05, -0.2114E+04,  0.6324E+02, -0.6266E+00
     + , -0.2554E+04,  0.4115E+04, -0.1059E+04,  0.7800E+02
     + , -0.4564E+05,  0.1181E+06, -0.9050E+05,  0.2490E+05
     + ,  0.1940E+05, -0.1268E+05, -0.1443E+05,  0.1681E+05
     + , -0.1016E+04,  0.1150E+05, -0.8322E+04,  0.1024E+05
     + , -0.1833E+03,  0.6763E+04,  0.5201E+05, -0.2240E+05
     + , -0.2150E+03,  0.8275E+04,  0.7525E+05, -0.3297E+05
     + , -0.2566E+02,  0.2615E+04,  0.1595E+06, -0.2556E+06
     + , -0.3670E+01,  0.1872E+04,  0.1719E+07, -0.1646E+08
     + ,  0.2225E+01,  0.1829E+03,  0.1881E+07, -0.2157E+08
     + ,  0.1098E+01,  0.1755E+04,  0.1154E+07,  0.8971E+08,  4*0.0 /
      DATA ((TMP(I,J, 54),I=1,MAXPOW),J=1,MAXINT) /
     +   0.6262E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.7578E+05, -0.1206E+05,  0.6503E+03, -0.1177E+02
     + , -0.1456E+04,  0.3607E+04, -0.1050E+04,  0.8562E+02
     + ,  0.5494E+05, -0.4316E+05, -0.3353E+05,  0.3122E+05
     + , -0.2422E+05,  0.6454E+05, -0.3914E+05,  0.8599E+04
     + , -0.6606E+03,  0.7269E+04,  0.6119E+04, -0.3383E+04
     + , -0.1565E+03,  0.5749E+04,  0.5985E+05, -0.2396E+05
     + , -0.2236E+03,  0.9444E+04,  0.7463E+05, -0.3742E+05
     + , -0.2010E+02,  0.2400E+04,  0.1720E+06, -0.2977E+06
     + , -0.1622E+01,  0.1830E+04,  0.1780E+07, -0.1721E+08
     + ,  0.2082E+01,  0.3625E+03,  0.1962E+07, -0.2448E+08
     + ,  0.1148E+01,  0.1892E+04,  0.1133E+07,  0.1244E+09,  4*0.0 /
      DATA ((TMP(I,J, 55),I=1,MAXPOW),J=1,MAXINT) /
     +   0.6813E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1642E+06, -0.2922E+05,  0.1724E+04, -0.3361E+02
     + , -0.2400E+04,  0.4936E+04, -0.1531E+04,  0.1354E+03
     + ,  0.1295E+05, -0.7423E+04, -0.6620E+04,  0.9125E+04
     + ,  0.6121E+03, -0.1572E+04,  0.2712E+05, -0.1563E+05
     + , -0.8402E+02,  0.2872E+04,  0.7699E+05, -0.1853E+05
     + , -0.2254E+03,  0.1010E+05,  0.7940E+05, -0.4284E+05
     + , -0.1987E+01,  0.1400E+04,  0.2040E+06, -0.4166E+06
     + , -0.4238E+01,  0.2444E+04,  0.1873E+07, -0.1899E+08
     + ,  0.2278E+01,  0.4044E+03,  0.2085E+07, -0.2635E+08
     + ,  0.1226E+01,  0.2030E+04,  0.1249E+07,  0.1169E+09,  8*0.0 /
      DATA ((TMP(I,J, 56),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5765E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1759E+04, -0.2331E+03,  0.9598E+01,  0.3960E-01
     + , -0.4276E+03,  0.2995E+04, -0.9837E+03,  0.8771E+02
     + ,  0.6154E+04,  0.1190E+04, -0.2858E+03,  0.1593E+04
     + ,  0.2420E+03, -0.4033E+03,  0.3138E+05, -0.2304E+05
     + , -0.1084E+03,  0.4043E+04,  0.7718E+05, -0.2532E+05
     + , -0.1836E+03,  0.7952E+04,  0.9545E+05, -0.4532E+05
     + ,  0.8708E+01,  0.7581E+03,  0.2258E+06, -0.5011E+06
     + , -0.5846E+01,  0.3162E+04,  0.1902E+07, -0.1948E+08
     + ,  0.2590E+01,  0.2297E+03,  0.2236E+07, -0.3193E+08
     + ,  0.1281E+01,  0.2144E+04,  0.1303E+07,  0.1193E+09,  8*0.0 /
      DATA ((TMP(I,J, 57),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4514E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2741E+05, -0.4218E+04,  0.2117E+03, -0.3183E+01
     + , -0.1231E+04,  0.4053E+04, -0.1329E+04,  0.1203E+03
     + ,  0.2431E+04,  0.3780E+04,  0.2792E+04, -0.2167E+03
     + , -0.4024E+03,  0.8837E+04,  0.2398E+04, -0.4154E+03
     + , -0.2694E+03,  0.4549E+04,  0.1944E+05, -0.1264E+05
     + , -0.9085E+02,  0.3459E+04,  0.8639E+05, -0.2558E+05
     + , -0.1485E+03,  0.6357E+04,  0.1121E+06, -0.4626E+05
     + , -0.6527E+01,  0.1901E+04,  0.2209E+06, -0.4602E+06
     + , -0.7588E+01,  0.3685E+04,  0.1991E+07, -0.2054E+08
     + ,  0.2727E+01,  0.3137E+03,  0.2346E+07, -0.3362E+08
     + ,  0.1365E+01,  0.2298E+04,  0.1393E+07,  0.1220E+09,  4*0.0 /
      DATA ((TMP(I,J, 58),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1542E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2448E+05, -0.5012E+04,  0.3411E+03, -0.7413E+01
     + , -0.1622E+04,  0.4662E+04, -0.1505E+04,  0.1385E+03
     + ,  0.5551E+05, -0.1769E+06,  0.2024E+06, -0.7125E+05
     + ,  0.4656E+04,  0.6580E+04, -0.3256E+04,  0.8079E+03
     + , -0.2828E+03,  0.1019E+05,  0.2005E+04, -0.4180E+03
     + ,  0.3264E+03, -0.7440E+03,  0.3609E+05,  0.2685E+05
     + , -0.7263E+02,  0.2822E+04,  0.9606E+05, -0.2458E+05
     + , -0.1695E+03,  0.8899E+04,  0.1139E+06, -0.5644E+05
     + ,  0.1939E+02,  0.3799E+03,  0.2661E+06, -0.6583E+06
     + , -0.1029E+02,  0.4409E+04,  0.2101E+07, -0.2280E+08
     + ,  0.2723E+01,  0.4916E+03,  0.2494E+07, -0.3595E+08
     + ,  0.1464E+01,  0.2444E+04,  0.1486E+07,  0.1376E+09
     +/
      DATA ((TMP(I,J, 59),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3935E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.5885E+02,  0.5060E+02,  0.1142E+02, -0.2858E+00
     + , -0.2475E+04,  0.8072E+04, -0.2077E+04,  0.2099E+03
     + , -0.6489E+04,  0.2485E+05, -0.1060E+05,  0.2589E+04
     + , -0.5349E+03,  0.8049E+04,  0.5499E+04, -0.9313E+03
     + , -0.3829E+03,  0.1003E+05,  0.3437E+04, -0.7202E+03
     + ,  0.1158E+03,  0.1754E+04,  0.2978E+05, -0.2081E+05
     + , -0.4523E+02,  0.1773E+04,  0.1075E+06, -0.1884E+05
     + , -0.1401E+03,  0.6504E+04,  0.1315E+06, -0.5758E+05
     + ,  0.8492E+01,  0.8664E+03,  0.2819E+06, -0.7256E+06
     + , -0.9126E+01,  0.4223E+04,  0.2290E+07, -0.2709E+08
     + ,  0.3207E+01,  0.3424E+03,  0.2697E+07, -0.4123E+08
     + ,  0.1557E+01,  0.2710E+04,  0.1566E+07,  0.1383E+09
     +/
      DATA ((TMP(I,J, 60),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2269E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1142E+04,  0.4035E+03, -0.1726E+02,  0.2479E+00
     + , -0.4138E+03,  0.3657E+04, -0.1265E+04,  0.1287E+03
     + ,  0.1241E+05, -0.6608E+04, -0.8545E+04,  0.1174E+05
     + ,  0.2239E+03,  0.1119E+05, -0.1181E+04,  0.2885E+03
     + , -0.3530E+03,  0.6609E+04,  0.1641E+05, -0.7462E+04
     + , -0.6644E+02,  0.2796E+04,  0.1098E+06, -0.2924E+05
     + , -0.1114E+03,  0.5206E+04,  0.1457E+06, -0.5559E+05
     + ,  0.8287E+01,  0.9600E+03,  0.2935E+06, -0.7637E+06
     + , -0.9944E+01,  0.4886E+04,  0.2320E+07, -0.2702E+08
     + ,  0.3820E+01,  0.8492E+02,  0.2868E+07, -0.4750E+08
     + ,  0.1633E+01,  0.2833E+04,  0.1759E+07,  0.9295E+08,  4*0.0 /
      DATA ((TMP(I,J, 61),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2285E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3175E+04, -0.4311E+03,  0.2911E+02, -0.5124E+00
     + , -0.7108E+03,  0.4102E+04, -0.1397E+04,  0.1482E+03
     + , -0.5546E+03,  0.7912E+04,  0.4958E+04, -0.7606E+03
     + , -0.5157E+03,  0.8937E+04,  0.6066E+04, -0.1148E+04
     + , -0.4607E+03,  0.9760E+04,  0.6028E+04, -0.1298E+04
     + , -0.1912E+03,  0.5138E+04,  0.2120E+05, -0.1345E+05
     + , -0.7165E+02,  0.3169E+04,  0.1166E+06, -0.3499E+05
     + , -0.2589E+03,  0.8215E+04, -0.1102E+06,  0.1824E+07
     + , -0.4251E+02,  0.4740E+04,  0.2377E+06, -0.4279E+06
     + ,  0.9003E-01,  0.2739E+04,  0.2641E+07, -0.3336E+08
     + ,  0.2857E+01,  0.1090E+04,  0.2888E+07, -0.4432E+08
     + ,  0.1742E+01,  0.3069E+04,  0.1744E+07,  0.1719E+09
     +/
      DATA ((TMP(I,J, 62),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1754E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1174E+04,  0.1370E+03, -0.4815E+01,  0.3574E-01
     + , -0.1315E+04,  0.5218E+04, -0.1900E+04,  0.2181E+03
     + , -0.5499E+03,  0.7881E+04,  0.5664E+04, -0.8952E+03
     + , -0.1126E+03,  0.3912E+04,  0.3230E+05, -0.2774E+05
     + , -0.3580E+02,  0.1576E+04,  0.1290E+06, -0.2201E+05
     + , -0.6400E+02,  0.3084E+04,  0.1751E+06, -0.4595E+05
     + ,  0.7096E+01,  0.1071E+04,  0.3267E+06, -0.9193E+06
     + , -0.1082E+02,  0.5919E+04,  0.2475E+07, -0.2997E+08
     + ,  0.3844E+01,  0.4077E+03,  0.3137E+07, -0.5576E+08
     + ,  0.1799E+01,  0.3181E+04,  0.1898E+07,  0.1263E+09,  8*0.0 /
      DATA ((TMP(I,J, 63),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2047E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.4276E+04, -0.4382E+03,  0.2276E+02, -0.3499E+00
     + , -0.4678E+03,  0.4034E+04, -0.1326E+04,  0.1388E+03
     + , -0.5507E+03,  0.7936E+04,  0.6518E+04, -0.1058E+04
     + , -0.4589E+03,  0.1019E+05,  0.5669E+04, -0.1234E+04
     + , -0.4913E+03,  0.8740E+04,  0.1016E+05, -0.2142E+04
     + , -0.2288E+03,  0.5934E+04,  0.2154E+05, -0.1326E+05
     + , -0.2466E+02,  0.1115E+04,  0.1400E+06, -0.1768E+05
     + , -0.6266E+02,  0.3143E+04,  0.1878E+06, -0.5089E+05
     + , -0.4306E+01,  0.2026E+04,  0.3280E+06, -0.9012E+06
     + , -0.7610E+01,  0.5488E+04,  0.2642E+07, -0.3287E+08
     + ,  0.3783E+01,  0.7655E+03,  0.3245E+07, -0.5731E+08
     + ,  0.1904E+01,  0.3400E+04,  0.2020E+07,  0.1315E+09
     +/
      DATA ((TMP(I,J, 64),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1620E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1627E+04,  0.8320E+02, -0.5112E+01,  0.7828E-01
     + , -0.2404E+04,  0.7220E+04, -0.2684E+04,  0.2976E+03
     + , -0.5394E+03,  0.7849E+04,  0.7295E+04, -0.1216E+04
     + , -0.4486E+03,  0.1029E+05,  0.6091E+04, -0.1380E+04
     + , -0.4679E+03,  0.9424E+04,  0.9571E+04, -0.2201E+04
     + , -0.3017E+03,  0.6938E+04,  0.1944E+05, -0.1104E+05
     + , -0.5768E+02,  0.2841E+04,  0.1366E+06, -0.4131E+05
     + , -0.3358E+02,  0.1701E+04,  0.2029E+06, -0.3312E+05
     + , -0.8668E+01,  0.2379E+04,  0.3331E+06, -0.9285E+06
     + ,  0.3209E+01,  0.1579E+04,  0.3144E+07, -0.4804E+08
     + ,  0.1966E+01,  0.3553E+04,  0.2103E+07,  0.1345E+09,  4*0.0 /
      DATA ((TMP(I,J, 65),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1879E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3021E+04, -0.1618E+03,  0.9979E+01, -0.1862E+00
     + , -0.1406E+04,  0.5621E+04, -0.1912E+04,  0.2075E+03
     + , -0.5345E+03,  0.7632E+04,  0.8660E+04, -0.1449E+04
     + , -0.4988E+03,  0.9401E+04,  0.9226E+04, -0.2000E+04
     + , -0.4700E+03,  0.9391E+04,  0.1117E+05, -0.2613E+04
     + , -0.1902E+03,  0.5724E+04,  0.2615E+05, -0.1782E+05
     + , -0.1568E+03,  0.1116E+05,  0.8757E+05, -0.7647E+05
     + , -0.4533E+02,  0.2421E+04,  0.2126E+06, -0.4859E+05
     + , -0.4721E+01,  0.2127E+04,  0.3644E+06, -0.1109E+07
     + ,  0.3903E+01,  0.1250E+04,  0.3405E+07, -0.5637E+08
     + ,  0.2077E+01,  0.3763E+04,  0.2261E+07,  0.1115E+09,  4*0.0 /
      DATA ((TMP(I,J, 66),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3294E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3167E+04, -0.4242E+02,  0.5269E+01, -0.1178E+00
     + , -0.1109E+04,  0.5234E+04, -0.1650E+04,  0.1694E+03
     + , -0.5242E+03,  0.7751E+04,  0.9341E+04, -0.1624E+04
     + , -0.4635E+03,  0.1050E+05,  0.8066E+04, -0.1930E+04
     + , -0.4608E+03,  0.9448E+04,  0.1216E+05, -0.2942E+04
     + , -0.1077E+03,  0.4675E+04,  0.3253E+05, -0.2519E+05
     + , -0.6326E+02,  0.3407E+04,  0.1499E+06, -0.5526E+05
     + , -0.7262E+02,  0.4176E+04,  0.2130E+06, -0.8026E+05
     + , -0.1800E+02,  0.3374E+04,  0.3526E+06, -0.9982E+06
     + ,  0.4112E+01,  0.1344E+04,  0.3520E+07, -0.5867E+08
     + ,  0.2166E+01,  0.3928E+04,  0.2396E+07,  0.1007E+09,  4*0.0 /
      DATA ((TMP(I,J, 67),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1647E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2949E+04, -0.5473E+02, -0.1313E+01,  0.5447E-01
     + , -0.1961E+04,  0.6859E+04, -0.2353E+04,  0.2538E+03
     + , -0.5221E+03,  0.8169E+04,  0.9852E+04, -0.1807E+04
     + , -0.4878E+03,  0.9589E+04,  0.1119E+05, -0.2580E+04
     + , -0.4549E+03,  0.9349E+04,  0.1378E+05, -0.3393E+04
     + , -0.1379E+03,  0.5032E+04,  0.3428E+05, -0.2787E+05
     + , -0.4939E+02,  0.2705E+04,  0.1628E+06, -0.5056E+05
     + , -0.4426E+02,  0.2555E+04,  0.2349E+06, -0.5948E+05
     + , -0.2988E+01,  0.2094E+04,  0.4072E+06, -0.1335E+07
     + ,  0.5131E+01,  0.5023E+03,  0.4000E+07, -0.7974E+08
     + ,  0.2274E+01,  0.4258E+04,  0.2387E+07,  0.1450E+09,  4*0.0 /
      DATA ((TMP(I,J, 68),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2419E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3178E+04, -0.8940E+02,  0.5741E+01, -0.1173E+00
     + , -0.1598E+04,  0.6371E+04, -0.2015E+04,  0.1951E+03
     + , -0.5148E+03,  0.8464E+04,  0.1038E+05, -0.1998E+04
     + , -0.4781E+03,  0.8546E+04,  0.1463E+05, -0.3195E+04
     + , -0.4470E+03,  0.9490E+04,  0.1489E+05, -0.3799E+04
     + , -0.2279E+03,  0.6501E+04,  0.3083E+05, -0.2363E+05
     + , -0.5162E+02,  0.2947E+04,  0.1710E+06, -0.5828E+05
     + , -0.5360E+02,  0.3254E+04,  0.2449E+06, -0.7821E+05
     + ,  0.6456E+01,  0.1211E+04,  0.4583E+06, -0.1684E+07
     + , -0.4025E+01,  0.2031E+04,  0.3795E+07, -0.6651E+08
     + ,  0.2386E+01,  0.4497E+04,  0.2558E+07,  0.1403E+09,  4*0.0 /
      DATA ((TMP(I,J, 69),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1729E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.5004E+04, -0.3383E+03,  0.1358E+02, -0.1932E+00
     + , -0.1721E+04,  0.6821E+04, -0.2191E+04,  0.2162E+03
     + , -0.5074E+03,  0.8420E+04,  0.1161E+05, -0.2277E+04
     + ,  0.4504E+03, -0.4717E+04,  0.9421E+05, -0.1104E+06
     + , -0.5189E+02,  0.3077E+04,  0.1808E+06, -0.6499E+05
     + , -0.5311E+02,  0.3348E+04,  0.2598E+06, -0.8657E+05
     + , -0.3887E+01,  0.2132E+04,  0.4637E+06, -0.1723E+07
     + ,  0.4124E+01,  0.2299E+04,  0.3956E+07, -0.7043E+08
     + ,  0.2512E+01,  0.4774E+04,  0.2690E+07,  0.1454E+09,  12*0.0 /
      DATA ((TMP(I,J, 70),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2440E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.5923E+04, -0.5235E+03,  0.2450E+02, -0.3644E+00
     + , -0.1402E+04,  0.6524E+04, -0.1996E+04,  0.1849E+03
     + , -0.4649E+03,  0.1046E+05,  0.8110E+04, -0.1188E+04
     + ,  0.3077E+03, -0.2145E+04,  0.8374E+05, -0.9504E+05
     + , -0.5328E+02,  0.3291E+04,  0.1869E+06, -0.7332E+05
     + , -0.7311E+02,  0.4929E+04,  0.2602E+06, -0.1239E+06
     + , -0.2434E+02,  0.4269E+04,  0.4243E+06, -0.1379E+07
     + ,  0.4575E+01,  0.2312E+04,  0.4086E+07, -0.7562E+08
     + ,  0.2606E+01,  0.4980E+04,  0.2895E+07,  0.9923E+08,  12*0.0 /
      DATA ((TMP(I,J, 71),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2123E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8368E+04, -0.1105E+04,  0.5971E+02, -0.9746E+00
     + , -0.1536E+04,  0.7063E+04, -0.2291E+04,  0.2250E+03
     + , -0.4936E+03,  0.9095E+04,  0.1255E+05, -0.2717E+04
     + ,  0.2304E+03, -0.1379E+04,  0.8594E+05, -0.1012E+06
     + , -0.5213E+02,  0.3333E+04,  0.1974E+06, -0.7977E+05
     + , -0.5333E+02,  0.3627E+04,  0.2858E+06, -0.1071E+06
     + ,  0.3726E+01,  0.1486E+04,  0.5352E+06, -0.2222E+07
     + ,  0.5266E+01,  0.2137E+04,  0.4329E+07, -0.8327E+08
     + ,  0.2736E+01,  0.5209E+04,  0.3153E+07,  0.5239E+08,  12*0.0 /
      DATA ((TMP(I,J, 72),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5463E+04, -0.2212E+03,  0.3566E+01, -0.1819E-01
     + ,  0.9488E+04, -0.1416E+04,  0.8076E+02, -0.1382E+01
     + , -0.1796E+04,  0.7903E+04, -0.2748E+04,  0.2932E+03
     + , -0.4835E+03,  0.9549E+04,  0.1284E+05, -0.2957E+04
     + ,  0.3480E+03, -0.3031E+04,  0.9762E+05, -0.1203E+06
     + , -0.6090E+02,  0.4112E+04,  0.2015E+06, -0.9934E+05
     + , -0.7386E+02,  0.5387E+04,  0.2859E+06, -0.1536E+06
     + , -0.1873E+02,  0.4102E+04,  0.4698E+06, -0.1572E+07
     + ,  0.4753E+01,  0.2673E+04,  0.4462E+07, -0.8960E+08
     + ,  0.2845E+01,  0.5554E+04,  0.3013E+07,  0.1535E+09,  12*0.0 /
      DATA ((TMP(I,J, 73),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.9358E+04,  0.4382E+03, -0.5661E+01,  0.2301E-01
     + ,  0.3537E+05, -0.2591E+04,  0.6585E+02, -0.5643E+00
     + ,  0.9000E+04, -0.1376E+04,  0.8354E+02, -0.1487E+01
     + , -0.1944E+04,  0.8490E+04, -0.3040E+04,  0.3330E+03
     + , -0.4771E+03,  0.1003E+05,  0.1338E+05, -0.3254E+04
     + ,  0.1047E+03,  0.6524E+03,  0.8380E+05, -0.1025E+06
     + , -0.5521E+02,  0.3828E+04,  0.2145E+06, -0.1019E+06
     + , -0.4987E+02,  0.3641E+04,  0.3160E+06, -0.1250E+06
     + , -0.2176E+01,  0.2172E+04,  0.5708E+06, -0.2482E+07
     + ,  0.5194E+01,  0.2794E+04,  0.4645E+07, -0.9648E+08
     + ,  0.2973E+01,  0.5785E+04,  0.3320E+07,  0.9608E+08,  8*0.0 /
      DATA ((TMP(I,J, 74),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.2084E+04,  0.1834E+03, -0.2686E+01,  0.1131E-01
     + , -0.1398E+05,  0.2451E+04, -0.1057E+03,  0.1381E+01
     + ,  0.9985E+04, -0.1816E+04,  0.1301E+03, -0.2747E+01
     + , -0.1826E+04,  0.8623E+04, -0.3114E+04,  0.3432E+03
     + , -0.4666E+03,  0.1057E+05,  0.1355E+05, -0.3503E+04
     + ,  0.1412E+03,  0.2762E+03,  0.8940E+05, -0.1129E+06
     + , -0.6206E+02,  0.4525E+04,  0.2194E+06, -0.1223E+06
     + , -0.1211E+03,  0.1058E+05,  0.2701E+06, -0.2556E+06
     + , -0.2105E+02,  0.4623E+04,  0.5109E+06, -0.1184E+07
     + ,  0.5276E+01,  0.2999E+04,  0.4828E+07, -0.1030E+09
     + ,  0.3099E+01,  0.6112E+04,  0.3348E+07,  0.1310E+09,  8*0.0 /
      DATA ((TMP(I,J, 75),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.5759E+04,  0.4019E+03, -0.6479E+01,  0.3113E-01
     + ,  0.1235E+05, -0.2571E+04,  0.1879E+03, -0.4072E+01
     + , -0.1846E+04,  0.9196E+04, -0.3553E+04,  0.4261E+03
     + , -0.4438E+03,  0.1148E+05,  0.1253E+05, -0.3520E+04
     + ,  0.1961E+03, -0.3585E+03,  0.9550E+05, -0.1180E+06
     + , -0.5721E+02,  0.4284E+04,  0.2331E+06, -0.1270E+06
     + , -0.1192E+03,  0.1081E+05,  0.2828E+06, -0.2788E+06
     + , -0.8548E+01,  0.3122E+04,  0.5972E+06, -0.2571E+07
     + ,  0.4901E+01,  0.3621E+04,  0.4969E+07, -0.1085E+09
     + ,  0.3238E+01,  0.6600E+04,  0.3237E+07,  0.2204E+09,  12*0.0 /
      DATA ((TMP(I,J, 76),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5189E+03,  0.1085E+03, -0.2362E+01,  0.1285E-01
     + ,  0.9943E+04, -0.1964E+04,  0.1499E+03, -0.3533E+01
     + , -0.1915E+04,  0.9625E+04, -0.3819E+04,  0.4641E+03
     + , -0.4312E+03,  0.1174E+05,  0.1298E+05, -0.3813E+04
     + , -0.7620E+02,  0.3809E+04,  0.8189E+05, -0.1090E+06
     + , -0.5946E+02,  0.4643E+04,  0.2401E+06, -0.1434E+06
     + , -0.1116E+03,  0.1035E+05,  0.3012E+06, -0.2961E+06
     + , -0.1803E+02,  0.4548E+04,  0.5700E+06, -0.2246E+07
     + ,  0.5735E+01,  0.3318E+04,  0.5232E+07, -0.1209E+09
     + ,  0.3351E+01,  0.6829E+04,  0.3509E+07,  0.1607E+09,  12*0.0 /
      DATA ((TMP(I,J, 77),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.9441E+02,  0.1284E+03, -0.2563E+01,  0.1347E-01
     + ,  0.9926E+04, -0.2049E+04,  0.1630E+03, -0.4025E+01
     + , -0.2391E+04,  0.1087E+05, -0.4456E+04,  0.5612E+03
     + , -0.4371E+03,  0.1150E+05,  0.1539E+05, -0.4560E+04
     + ,  0.1540E+03, -0.7160E+03,  0.1147E+06, -0.1673E+06
     + , -0.5153E+02,  0.4097E+04,  0.2582E+06, -0.1419E+06
     + , -0.1366E+03,  0.1456E+05,  0.2707E+06, -0.3461E+06
     + , -0.1995E+02,  0.4906E+04,  0.6064E+06, -0.2648E+07
     + ,  0.6213E+01,  0.3458E+04,  0.5442E+07, -0.1286E+09
     + ,  0.3505E+01,  0.7126E+04,  0.3805E+07,  0.1114E+09,  12*0.0 /
      DATA ((TMP(I,J, 78),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1220E+05, -0.3768E+03,  0.4167E+01, -0.1564E-01
     + ,  0.1396E+05, -0.1184E+04,  0.3650E+02, -0.3548E+00
     + ,  0.1172E+05, -0.2752E+04,  0.2212E+03, -0.4579E+01
     + , -0.2373E+04,  0.1129E+05, -0.4739E+04,  0.6166E+03
     + , -0.4333E+03,  0.1147E+05,  0.1710E+05, -0.5181E+04
     + , -0.7755E+02,  0.2847E+04,  0.1047E+06, -0.1599E+06
     + , -0.6719E+02,  0.5737E+04,  0.2565E+06, -0.1880E+06
     + , -0.1399E+03,  0.1605E+05,  0.2671E+06, -0.3742E+06
     + ,  0.1076E+02,  0.9617E+03,  0.7776E+06, -0.4207E+07
     + ,  0.6088E+01,  0.4001E+04,  0.5552E+07, -0.1300E+09
     + ,  0.3646E+01,  0.7453E+04,  0.3931E+07,  0.1226E+09,  8*0.0 /
      DATA ((TMP(I,J, 79),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4105E+04,  0.2410E+02, -0.1837E+01,  0.1252E-01
     + ,  0.1581E+05, -0.4931E+04,  0.5197E+03, -0.1622E+02
     + , -0.2231E+04,  0.1142E+05, -0.4781E+04,  0.6012E+03
     + , -0.4203E+03,  0.1212E+05,  0.1690E+05, -0.5448E+04
     + ,  0.1443E+03, -0.4096E+03,  0.1249E+06, -0.1944E+06
     + , -0.8194E+02,  0.7574E+04,  0.2506E+06, -0.2318E+06
     + , -0.1134E+03,  0.1194E+05,  0.3355E+06, -0.3921E+06
     + , -0.3392E+01,  0.3070E+04,  0.7247E+06, -0.3499E+07
     + ,  0.7917E+01,  0.2918E+04,  0.6095E+07, -0.1596E+09
     + ,  0.3811E+01,  0.7846E+04,  0.4248E+07,  0.4571E+08,  12*0.0 /
      DATA ((TMP(I,J, 80),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5142E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1780E+05, -0.5970E+04,  0.6765E+03, -0.2176E+02
     + , -0.2317E+04,  0.1206E+05, -0.5219E+04,  0.7004E+03
     + , -0.3961E+03,  0.1286E+05,  0.1582E+05, -0.5482E+04
     + ,  0.2241E+03, -0.2195E+04,  0.1429E+06, -0.2325E+06
     + , -0.7533E+02,  0.7084E+04,  0.2675E+06, -0.2412E+06
     + , -0.1288E+03,  0.1524E+05,  0.3090E+06, -0.4397E+06
     + ,  0.4681E+00,  0.2405E+04,  0.7958E+06, -0.4232E+07
     + ,  0.6983E+01,  0.4309E+04,  0.5980E+07, -0.1518E+09
     + ,  0.3946E+01,  0.8311E+04,  0.4256E+07,  0.8942E+08,  12*0.0 /
      DATA ((TMP(I,J, 81),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1823E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1010E+05,  0.1911E+04, -0.7721E+02,  0.9111E+00
     + ,  0.1488E+05, -0.4878E+04,  0.5536E+03, -0.1923E+02
     + , -0.2399E+04,  0.1271E+05, -0.5745E+04,  0.7873E+03
     + , -0.4087E+03,  0.1156E+05,  0.2169E+05, -0.7188E+04
     + ,  0.1551E+03, -0.9040E+03,  0.1404E+06, -0.2314E+06
     + , -0.6647E+02,  0.6324E+04,  0.2871E+06, -0.2439E+06
     + , -0.1405E+03,  0.2137E+05,  0.2340E+06, -0.4290E+06
     + , -0.1063E+02,  0.4195E+04,  0.7543E+06, -0.3747E+07
     + ,  0.7684E+01,  0.4048E+04,  0.6314E+07, -0.1714E+09
     + ,  0.4082E+01,  0.8543E+04,  0.4521E+07,  0.5178E+08,  8*0.0 /
      DATA ((TMP(I,J, 82),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1569E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.9651E+04,  0.1870E+04, -0.7761E+02,  0.9425E+00
     + ,  0.1609E+05, -0.5855E+04,  0.7149E+03, -0.2672E+02
     + , -0.2194E+04,  0.1239E+05, -0.5418E+04,  0.6794E+03
     + , -0.4016E+03,  0.1173E+05,  0.2316E+05, -0.7955E+04
     + ,  0.6749E+02,  0.6789E+03,  0.1401E+06, -0.2437E+06
     + , -0.7125E+02,  0.7126E+04,  0.2931E+06, -0.2779E+06
     + , -0.1363E+03,  0.1992E+05,  0.2721E+06, -0.4887E+06
     + , -0.8206E+01,  0.4058E+04,  0.7950E+06, -0.4115E+07
     + ,  0.7595E+01,  0.4692E+04,  0.6429E+07, -0.1747E+09
     + ,  0.4240E+01,  0.8883E+04,  0.4754E+07,  0.3448E+08,  8*0.0 /
      DATA ((TMP(I,J, 83),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.4395E+03,  0.1185E+02,  0.2207E+00, -0.1865E-02
     + ,  0.4586E+04, -0.1052E+03, -0.2706E+01,  0.7877E-01
     + ,  0.1118E+05, -0.3159E+03, -0.9250E+01,  0.2918E+00
     + , -0.1578E+05,  0.3450E+04, -0.1741E+03,  0.2596E+01
     + ,  0.2124E+05, -0.8884E+04,  0.1240E+04, -0.5312E+02
     + , -0.1835E+04,  0.1188E+05, -0.5123E+04,  0.6229E+03
     + , -0.3943E+03,  0.1129E+05,  0.2671E+05, -0.9164E+04
     + ,  0.2402E+03, -0.2657E+04,  0.1637E+06, -0.2867E+06
     + , -0.6824E+02,  0.7005E+04,  0.3089E+06, -0.2951E+06
     + , -0.1337E+03,  0.1999E+05,  0.2903E+06, -0.5342E+06
     + , -0.1411E+01,  0.3094E+04,  0.8901E+06, -0.5203E+07
     + ,  0.9935E+01,  0.3289E+04,  0.6983E+07, -0.2020E+09
     + ,  0.4425E+01,  0.9396E+04,  0.5008E+07, -0.5280E+08
     +/
      DATA ((TMP(I,J, 84),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1109E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1939E+05, -0.1380E+04,  0.3526E+02, -0.3106E+00
     + ,  0.9152E+04, -0.3829E+04,  0.5535E+03, -0.2106E+02
     + , -0.1131E+04,  0.1041E+05, -0.4126E+04,  0.4235E+03
     + , -0.3899E+03,  0.1134E+05,  0.2963E+05, -0.1038E+05
     + ,  0.4918E+03, -0.1053E+05,  0.2383E+06, -0.4647E+06
     + , -0.7471E+02,  0.8106E+04,  0.3143E+06, -0.3397E+06
     + , -0.1335E+03,  0.2199E+05,  0.2786E+06, -0.5569E+06
     + ,  0.7789E+01,  0.1767E+04,  0.1003E+07, -0.6443E+07
     + ,  0.8525E+01,  0.5102E+04,  0.6990E+07, -0.2009E+09
     + ,  0.4633E+01,  0.9868E+04,  0.5142E+07,  0.1775E+08,  8*0.0 /
      DATA ((TMP(I,J, 85),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5224E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2744E+05, -0.2310E+04,  0.6658E+02, -0.6458E+00
     + ,  0.6422E+04, -0.2954E+04,  0.4933E+03, -0.2019E+02
     + , -0.1933E+04,  0.1303E+05, -0.5806E+04,  0.6870E+03
     + , -0.3889E+03,  0.1171E+05,  0.3195E+05, -0.1160E+05
     + ,  0.3129E+03, -0.6378E+04,  0.2158E+06, -0.4073E+06
     + , -0.6880E+02,  0.7565E+04,  0.3411E+06, -0.3547E+06
     + , -0.1280E+03,  0.1941E+05,  0.3508E+06, -0.6558E+06
     + , -0.1695E+01,  0.3621E+04,  0.9665E+06, -0.5746E+07
     + ,  0.9913E+01,  0.4822E+04,  0.7370E+07, -0.2163E+09
     + ,  0.4871E+01,  0.1062E+05,  0.5352E+07, -0.2702E+08,  8*0.0 /
      DATA ((TMP(I,J, 86),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1284E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.7912E+03,  0.2111E+04, -0.1709E+03,  0.3589E+01
     + ,  0.1243E+05, -0.6150E+04,  0.1021E+04, -0.4644E+02
     + , -0.1804E+04,  0.1279E+05, -0.5624E+04,  0.6228E+03
     + , -0.3616E+03,  0.1088E+05,  0.3423E+05, -0.1248E+05
     + ,  0.1691E+03, -0.2424E+04,  0.1954E+06, -0.4008E+06
     + , -0.6756E+02,  0.7739E+04,  0.3363E+06, -0.3748E+06
     + , -0.1220E+03,  0.1976E+05,  0.3335E+06, -0.6657E+06
     + , -0.5899E+00,  0.3312E+04,  0.9833E+06, -0.6258E+07
     + ,  0.8633E+01,  0.5888E+04,  0.7122E+07, -0.2120E+09
     + ,  0.4841E+01,  0.1057E+05,  0.5286E+07,  0.1022E+08,  8*0.0 /
      DATA ((TMP(I,J, 87),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1287E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.9129E+04,  0.3064E+04, -0.1840E+03,  0.2869E+01
     + ,  0.1217E+05, -0.1865E+04, -0.1031E+04,  0.1980E+03
     + , -0.2201E+04,  0.1461E+05, -0.7082E+04,  0.9132E+03
     + , -0.3615E+03,  0.1150E+05,  0.3541E+05, -0.1363E+05
     + , -0.5769E+03,  0.1660E+05,  0.5526E+05, -0.7044E+05
     + , -0.6236E+02,  0.7249E+04,  0.3612E+06, -0.3893E+06
     + , -0.1213E+03,  0.2052E+05,  0.3455E+06, -0.7195E+06
     + , -0.8453E+01,  0.4660E+04,  0.9757E+06, -0.6010E+07
     + ,  0.1104E+02,  0.4630E+04,  0.7706E+07, -0.2445E+09
     + ,  0.5063E+01,  0.1115E+05,  0.5666E+07, -0.1082E+09,  8*0.0 /
      DATA ((TMP(I,J, 88),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1415E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.3003E+05,  0.8875E+04, -0.6798E+03,  0.1571E+02
     + ,  0.2941E+05, -0.1786E+05,  0.3591E+04, -0.2242E+03
     + , -0.1852E+04,  0.1361E+05, -0.6123E+04,  0.6294E+03
     + , -0.3547E+03,  0.1164E+05,  0.3753E+05, -0.1492E+05
     + ,  0.2933E+03, -0.6829E+04,  0.2528E+06, -0.5565E+06
     + , -0.6085E+02,  0.7287E+04,  0.3762E+06, -0.4161E+06
     + , -0.1192E+03,  0.2119E+05,  0.3500E+06, -0.7644E+06
     + , -0.1024E+02,  0.5310E+04,  0.9756E+06, -0.5773E+07
     + ,  0.1241E+02,  0.3727E+04,  0.8307E+07, -0.2833E+09
     + ,  0.5211E+01,  0.1168E+05,  0.5739E+07, -0.9046E+08,  8*0.0 /
      DATA ((TMP(I,J, 89),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1258E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2747E+04,  0.3975E+03,  0.1941E+03, -0.1439E+02
     + ,  0.1958E+05, -0.9878E+04,  0.1388E+04, -0.1778E+02
     + , -0.2098E+04,  0.1506E+05, -0.7581E+04,  0.9825E+03
     + , -0.3474E+03,  0.1153E+05,  0.4113E+05, -0.1657E+05
     + ,  0.5789E+03, -0.1507E+05,  0.3328E+06, -0.7718E+06
     + , -0.6339E+02,  0.7915E+04,  0.3884E+06, -0.4637E+06
     + , -0.1182E+03,  0.2194E+05,  0.3621E+06, -0.8244E+06
     + ,  0.8142E+01,  0.2287E+04,  0.1185E+07, -0.8439E+07
     + ,  0.1003E+02,  0.6690E+04,  0.7961E+07, -0.2545E+09
     + ,  0.5479E+01,  0.1217E+05,  0.5897E+07, -0.2287E+08,  8*0.0 /
      DATA ((TMP(I,J, 90),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1134E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1398E+05, -0.6113E+04,  0.8572E+03, -0.2963E+02
     + , -0.1466E+04,  0.1349E+05, -0.6743E+04,  0.1013E+04
     + , -0.3308E+03,  0.1094E+05,  0.4517E+05, -0.1812E+05
     + ,  0.2265E+03, -0.3796E+04,  0.2424E+06, -0.5526E+06
     + , -0.5998E+02,  0.7669E+04,  0.4039E+06, -0.4843E+06
     + , -0.1152E+03,  0.2229E+05,  0.3694E+06, -0.8743E+06
     + , -0.1965E+02,  0.7238E+04,  0.9916E+06, -0.5869E+07
     + ,  0.1150E+02,  0.6085E+04,  0.8292E+07, -0.2758E+09
     + ,  0.5620E+01,  0.1245E+05,  0.6338E+07, -0.1549E+09,  12*0.0 /
      DATA ((TMP(I,J, 91),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2194E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8794E+04, -0.2841E+04,  0.2038E+03,  0.1370E+02
     + , -0.2042E+04,  0.1581E+05, -0.8451E+04,  0.1211E+04
     + , -0.3240E+03,  0.1078E+05,  0.5022E+05, -0.2015E+05
     + ,  0.1921E+04, -0.5267E+05,  0.6573E+06, -0.1562E+07
     + , -0.6436E+02,  0.8617E+04,  0.4180E+06, -0.5495E+06
     + , -0.1129E+03,  0.2138E+05,  0.4231E+06, -0.9875E+06
     + ,  0.1526E+02,  0.1356E+04,  0.1351E+07, -0.1082E+08
     + ,  0.1254E+02,  0.5894E+04,  0.8877E+07, -0.3120E+09
     + ,  0.5918E+01,  0.1306E+05,  0.6683E+07, -0.1778E+09,  12*0.0 /
      DATA ((TMP(I,J, 92),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4400E+04, -0.1564E+03,  0.2241E+01, -0.1062E-01
     + , -0.2175E+04,  0.4327E+03, -0.1164E+02,  0.8742E-01
     + ,  0.1528E+05, -0.7106E+04,  0.1060E+04, -0.4036E+02
     + , -0.1807E+04,  0.1483E+05, -0.7405E+04,  0.8426E+03
     + , -0.3148E+03,  0.1094E+05,  0.5041E+05, -0.2121E+05
     + , -0.1100E+03,  0.4889E+04,  0.1908E+06, -0.4810E+06
     + , -0.6720E+02,  0.9489E+04,  0.4107E+06, -0.6000E+06
     + , -0.1033E+03,  0.1864E+05,  0.4878E+06, -0.1076E+07
     + ,  0.6281E+00,  0.3792E+04,  0.1281E+07, -0.1003E+08
     + ,  0.1146E+02,  0.7568E+04,  0.8699E+07, -0.3106E+09
     + ,  0.6017E+01,  0.1327E+05,  0.7079E+07, -0.2456E+09,  8*0.0 /
      DATA ((TMP(I,J, 93),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2522E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1668E+05, -0.8606E+04,  0.1441E+04, -0.6401E+02
     + , -0.2561E+04,  0.1858E+05, -0.1101E+05,  0.1791E+04
     + , -0.3232E+03,  0.1200E+05,  0.6096E+05, -0.2302E+05
     + , -0.4467E+02,  0.2778E+04,  0.2204E+06, -0.5257E+06
     + , -0.6355E+02,  0.9093E+04,  0.4439E+06, -0.6341E+06
     + , -0.1103E+03,  0.2501E+05,  0.3841E+06, -0.1044E+07
     + ,  0.5579E+01,  0.3489E+04,  0.1354E+07, -0.1078E+08
     + ,  0.1272E+02,  0.7422E+04,  0.9191E+07, -0.3336E+09
     + ,  0.6330E+01,  0.1392E+05,  0.7484E+07, -0.3064E+09,  12*0.0 /
      DATA ((TMP(I,J, 94),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3508E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2939E+04,  0.8224E+03, -0.3576E+02,  0.5087E+00
     + ,  0.1270E+05, -0.6607E+04,  0.1093E+04, -0.3674E+02
     + , -0.2063E+04,  0.1760E+05, -0.1057E+05,  0.1695E+04
     + , -0.3181E+03,  0.1245E+05,  0.5096E+05, -0.2427E+05
     + ,  0.3925E+03, -0.1022E+05,  0.3515E+06, -0.9309E+06
     + , -0.6367E+02,  0.9444E+04,  0.4539E+06, -0.6824E+06
     + , -0.1065E+03,  0.2299E+05,  0.4461E+06, -0.1181E+07
     + , -0.1248E+02,  0.6703E+04,  0.1250E+07, -0.9411E+07
     + ,  0.1781E+02,  0.3158E+04,  0.1075E+08, -0.4693E+09
     + ,  0.6490E+01,  0.1422E+05,  0.8179E+07, -0.5340E+09,  8*0.0 /
      DATA ((TMP(I,J, 95),I=1,MAXPOW),J=1,MAXINT) /
     +   0.9600E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3669E+04, -0.1927E+04,  0.3556E+03, -0.1775E+02
     + , -0.8806E+05,  0.1824E+06, -0.1119E+06,  0.2150E+05
     + , -0.8786E+03,  0.1063E+05, -0.5553E+03, -0.1750E+04
     + , -0.3188E+03,  0.1325E+05,  0.5127E+05, -0.2586E+05
     + ,  0.3232E+03, -0.9027E+04,  0.3584E+06, -0.9931E+06
     + , -0.6201E+02,  0.9427E+04,  0.4778E+06, -0.7281E+06
     + , -0.9199E+02,  0.1716E+05,  0.6101E+06, -0.1350E+07
     + , -0.3730E+01,  0.5425E+04,  0.1376E+07, -0.1109E+08
     + ,  0.1966E+02,  0.2217E+04,  0.1154E+08, -0.5298E+09
     + ,  0.6763E+01,  0.1479E+05,  0.8647E+07, -0.6116E+09,  8*0.0 /
      DATA ((TMP(I,J, 96),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1000E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3148E+04, -0.1605E+04,  0.2954E+03, -0.1411E+02
     + , -0.7979E+05,  0.1716E+06, -0.1079E+06,  0.2118E+05
     + , -0.8139E+03,  0.1040E+05,  0.4547E+03, -0.2530E+04
     + , -0.3144E+03,  0.1378E+05,  0.5160E+05, -0.2733E+05
     + , -0.2912E+03,  0.1117E+05,  0.1679E+06, -0.4469E+06
     + , -0.5879E+02,  0.9126E+04,  0.4981E+06, -0.7597E+06
     + , -0.1010E+03,  0.2212E+05,  0.5193E+06, -0.1402E+07
     + , -0.1147E+02,  0.7190E+04,  0.1327E+07, -0.1016E+08
     + ,  0.2200E+02,  0.1083E+04,  0.1208E+08, -0.5684E+09
     + ,  0.7017E+01,  0.1439E+05,  0.9471E+07, -0.8527E+09,  8*0.0 /
      DATA ((TMP(I,J, 97),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1100E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3725E+04, -0.1998E+04,  0.3728E+03, -0.1783E+02
     + , -0.1348E+06,  0.2867E+06, -0.1865E+06,  0.3853E+05
     + , -0.1092E+04,  0.1257E+05, -0.3090E+04, -0.6861E+03
     + , -0.3108E+03,  0.1396E+05,  0.5425E+05, -0.2964E+05
     + , -0.8536E+02,  0.5200E+04,  0.2278E+06, -0.6067E+06
     + , -0.6035E+02,  0.9752E+04,  0.5095E+06, -0.8199E+06
     + , -0.1018E+03,  0.2538E+05,  0.4681E+06, -0.1141E+07
     + , -0.1308E+02,  0.7916E+04,  0.1354E+07, -0.1049E+08
     + ,  0.2374E+02,  0.1750E+03,  0.1285E+08, -0.6352E+09
     + ,  0.7219E+01,  0.1592E+05,  0.9491E+07, -0.8283E+09,  8*0.0 /
      DATA ((TMP(I,J, 98),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1220E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3846E+04, -0.2092E+04,  0.3854E+03, -0.1758E+02
     + , -0.5378E+05,  0.1380E+06, -0.9898E+05,  0.2185E+05
     + , -0.9355E+03,  0.1168E+05, -0.4663E+03, -0.2379E+04
     + , -0.3044E+03,  0.1361E+05,  0.6013E+05, -0.3273E+05
     + ,  0.3450E+03, -0.1057E+05,  0.4170E+06, -0.1248E+07
     + , -0.5797E+02,  0.9571E+04,  0.5352E+06, -0.8755E+06
     + , -0.9148E+02,  0.1942E+05,  0.6490E+06, -0.1673E+07
     + , -0.5416E+02,  0.1706E+05,  0.8630E+06, -0.1792E+07
     + ,  0.2771E+02, -0.2903E+04,  0.1419E+08, -0.7456E+09
     + ,  0.7544E+01,  0.1589E+05,  0.1052E+08, -0.1089E+10,  8*0.0 /
      DATA ((TMP(I,J, 99),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1330E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.8936E+03,  0.1145E+05,  0.1094E+04, -0.3692E+04
     + , -0.2152E+03,  0.7720E+04,  0.5372E+05, -0.2276E+05
     + , -0.2914E+03,  0.1268E+05,  0.6828E+05, -0.3620E+05
     + , -0.2568E+03,  0.1341E+05,  0.8685E+05, -0.5387E+05
     + , -0.2104E+03,  0.1155E+05,  0.1107E+06, -0.7279E+05
     + ,  0.1088E+03,  0.1536E+04,  0.2458E+06, -0.6005E+06
     + , -0.5691E+02,  0.9660E+04,  0.5556E+06, -0.9320E+06
     + , -0.9167E+02,  0.2050E+05,  0.6520E+06, -0.1784E+07
     + ,  0.9687E+00,  0.5331E+04,  0.1646E+07, -0.1518E+08
     + ,  0.3315E+02, -0.7298E+04,  0.1587E+08, -0.8866E+09
     + ,  0.7728E+01,  0.1675E+05,  0.1090E+08, -0.1231E+10,  4*0.0 /
      DATA ((TMP(I,J,100),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1460E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1082E+04,  0.1308E+05, -0.9100E+03, -0.2846E+04
     + , -0.1923E+03,  0.6709E+04,  0.6231E+05, -0.2410E+05
     + , -0.2559E+03,  0.1024E+05,  0.8602E+05, -0.3977E+05
     + , -0.2466E+03,  0.1276E+05,  0.9751E+05, -0.5925E+05
     + , -0.2304E+03,  0.1518E+05,  0.9220E+05, -0.7454E+05
     + , -0.8675E+02,  0.2132E+04,  0.2568E+06, -0.6538E+06
     + , -0.5579E+02,  0.1018E+05,  0.5793E+06, -0.1018E+07
     + , -0.8637E+02,  0.1890E+05,  0.7445E+06, -0.1949E+07
     + ,  0.5556E+00,  0.5648E+04,  0.1738E+07, -0.1662E+08
     + ,  0.2968E+02, -0.2026E+04,  0.1484E+08, -0.7825E+09
     + ,  0.8135E+01,  0.1726E+05,  0.1171E+08, -0.1346E+10,  4*0.0 /
C Ionization energies
      DATA (TMP1(I), I = 1,56) /
     +     13.60, 24.59,
     +      5.39,  9.32,  8.30, 11.26, 14.53, 13.62, 17.42, 21.56,
     +      5.14,  7.65,  5.99,  8.15, 10.49, 10.36, 12.97, 15.76,
     +      4.34,  6.11,
     +      6.56,  6.83,  6.75,  6.77,  7.43,  7.90,  7.88,  7.64,
     +      7.73,  9.39,
     +                    6.00,  7.90,  9.82,  9.75, 11.81, 14.00,
     +      4.18,  5.69,
     +      6.22,  6.63,  6.76,  7.09,  7.28,  7.36,  7.46,  8.34,
     +      7.58,  8.99,  5.79,  7.34,  8.64,  9.01, 10.45, 12.13,
     +      3.89,  5.21 /
      DATA (TMP1(I), I = 57,MAXELZ) /
     +      5.58,  5.54,  5.46,  5.52,  5.55,  5.64,  5.67,  6.15,
     +      5.86,  5.94,  6.02,  6.11,  6.18,  6.25,
     +      5.43,  6.83,  7.89,  7.98,  7.88,  8.70,  9.10,  9.00,
     +      9.23, 10.44,
     +                    6.11,  7.42,  7.29,  8.42,  9.65, 10.75,
     +      3.97,  5.28,
     +      5.17,  6.08,  5.89,  6.19,  6.27,  6.06,  5.99,  6.02,
     +      6.23,  6.30,  6.42,  6.50 /
      DO 10 J = 1,MAXELZ
         DO 10 I = 1,MAXINT
            CRNGUP(I,J) = CTMP(I,J)
   10 CONTINUE
      DO 20 K = 1,MAXELZ
         DO 20 J = 1,MAXINT
            DO 20 I = 1,MAXPOW
               COFS(I,J,K) = TMP(I,J,K)
   20 CONTINUE
      DO 30 I = 1,MAXELZ
         GPOMIN(I) = MAX(TENEV,TMP1(I)*1.E-3)
   30 CONTINUE
      END
+DECK,GPHXSI.
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHXSI
*.
*.    ******************************************************************
*.    *  Creates PHXS bank containing x-section constants              *
*.    *                                                                *
*.    *    ==>CALLED BY : GPHYSI                                       *
*.    *       AUTHOR : J. CHWASTOWSKI                                  *
*.    *                                                                *
*.    ******************************************************************
*.
*      The photoelectric effect x-section bank
*       1                 - Number of elements neded to create medium = NZ
*       2      <-> NZ+1   -  Z of elements
*       NZ+1   <-> 2*NZ+1 -  0
*       2+2*NZ <-> 3*NZ+1 -  weight of x-section constants
*       3*NZ+2 <-> top    -  X-section constants
+CDE,GCBANK.
+CDE,GCPHYS.
+CDE,GCJLOC.
+CDE,GCONSP.
+CDE,GCUNIT.
+CDE,GCPMXZ.
+CDE,GCPHXS.
+CDE,GC10EV.
      CHARACTER*1 CHSHEL, CHGROU
      DIMENSION EUP(MAXINT),TMP(MAXPOW,MAXINT),ESHL(24)
      PARAMETER (NXSB=73,NXSBF=70)
      Z = Q(JMA+7)
      IPHXSP = 0
* Check Z range of validity for Sandia parametrization
      IF(Z.GE.1.AND.Z.LE.MAXELZ) THEN
*
* Find number of elements neded to create current medium
c
* Is this medium a mixture ?
         NMIX = Q(JMA+11)
         IF(NMIX.GT.1) THEN
            NZ = 0
            JMIXT=LQ(JMA-5)
            DO 10 I = 1,NMIX
               ZCUR = Q(JMIXT+NMIX+I)
               IF(ZCUR.NE.INT(ZCUR)) THEN
*
* When Z is non integer you need 2 elements
                  NZ=NZ+2
               ELSE
                  NZ=NZ+1
               ENDIF
   10       CONTINUE
            CALL GWORK(3*NZ+1)
            WS(1) = NZ
*
* Calculate weigths
*
            K = 1
            DO 20 I = 1,NMIX
               ZCUR = Q(JMIXT+NMIX+I)
               HZCUR = INT(ZCUR)
               WS(1+K) = HZCUR
               IF(ZCUR.NE.HZCUR) THEN
                  WS(1+2*NZ+K) = (HZCUR+1.-ZCUR)*Q(JMIXT+2*NMIX+I)
                  K = K+1
                  WS(1+K) = HZCUR+1
                  WS(1+2*NZ+K) = (ZCUR-HZCUR)*Q(JMIXT+2*NMIX+I)
               ELSE
                  WS(1+2*NZ+K) = Q(JMIXT+2*NMIX+I)
               ENDIF
               K = K+1
   20       CONTINUE
*
* Do Z values repeat ?
*
            K = NZ
            DO 40 I = 1,NZ-1
               Z1 = WS(1+I)
               IF(Z1.GT.0.0) THEN
                  DO 30 J = I+1,NZ
                     Z2 = WS(1+J)
                     IF(Z1.EQ.Z2) THEN
*                        WS(1+NZ+I) = WS(1+NZ+I)+WS(1+NZ+J)
                        WS(1+2*NZ+I) = WS(1+2*NZ+I)+WS(1+2*NZ+J)
                        WS(1+J) = -WS(1+J)
                        K = K-1
                     ENDIF
   30             CONTINUE
               ENDIF
   40       CONTINUE
* Now you can book a pht. eff. x-sec. constant bank and hang it as
* a first struc. link from JPHOT.
* From this bank you hang the banks for each separate Z !!!
            NW = NZ*NXSB+2
            IF(K.EQ.1) NW = NXSB+2
            CALL MZBOOK(IXCONS,JPHXS,JPHOT,-1,'PHXS',NZ,NZ,NW,3,0)
* Fill JPHXS bank and calculates the weights
            Q(JPHXS+1) = K
            NZN = K
            K = 1
            DO 50 I = 1,NZ
               IF(WS(1+I).GT.0.0) THEN
                  Q(JPHXS+1+K) = WS(1+I)
*                  Q(JPHXS+1+K+NZN) = WS(1+I+NZ)
                  Q(JPHXS+1+K+2*NZN) = WS(1+I+2*NZ)
                  K = K+1
               ENDIF
   50       CONTINUE
         ELSE
* Current medium consists of one "element"
            NZ = 1
            ZCUR = Z
            HZCUR = INT(ZCUR)
            IF(MOD(ZCUR,HZCUR).EQ.0) THEN
* Now you can book a pht. eff. x-sec. constant bank and hang it as
* a first struc. link from JPHOT.
               NW = NXSB+2
               CALL MZBOOK(IXCONS,JPHXS,JPHOT,-1,'PHXS',1,1,NW,3,0)
               Q(JPHXS+1) = 1.
               Q(JPHXS+2) = ZCUR
               Q(JPHXS+4) = 1.
            ELSE
* Somebody is cheating. We need two elements
               NZ = NZ+1
               NW = 2*NXSB+2
               CALL MZBOOK(IXCONS,JPHXS,JPHOT,-1,'PHXS',2,2,NW,3,0)
               Q(JPHXS+1) = 2.
               Q(JPHXS+2) = HZCUR
               Q(JPHXS+3) = HZCUR+1
               Q(JPHXS+6) = (HZCUR+1.-ZCUR)
               Q(JPHXS+7) = (ZCUR-HZCUR)
            ENDIF
         ENDIF
* We passed the bank booking phase and we can start real work
         NZ = Q(JPHXS+1)
* Create a temporary working space
         IBINS = 5*NZ+NZ*(MAXPOW+1)*(MAXINT+1)
         CALL GWORK(IBINS)
         DO 60 I = 1,IBINS
            WS(I) = 0.0
   60    CONTINUE
         KS = 5*NZ
         L = 0
         DO 170 N = 1,NZ
            JPHXS = LQ(JPHOT-1)
            ZCUR = Q(JPHXS+1+N)
            IZ = ZCUR
            DO 70 I = 1,24
               ESHL(I) = 0.0
   70       CONTINUE
            CALL GFSHLS(ZCUR,ESHL,NSHL)
            DO 80 I = 1,NSHL
               ESHL(I) = ESHL(I)*1.E-3
   80       CONTINUE
* Use Sandia data.
* Find out the interval upper limit.
            IMAX = 0
            DO 90 I = 1,MAXINT
               CHSHEL=CRNGUP(I,IZ)(1:1)
               CHGROU=CRNGUP(I,IZ)(2:2)
               IF(CHSHEL.EQ.'I') THEN
                  EUP(I) = 55.E11
                  IMAX = I
                  GO TO 100
               ELSEIF(CHSHEL.EQ.'K') THEN
                  EUP(I) = ESHL(1)
               ELSEIF(CHSHEL.EQ.'L') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(2)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(3)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(4)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for L '
     +               //'shell.  Maximum coded L3. Found shell '
     +               //'name: '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'M') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(5)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(6)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(7)
                  ELSEIF(CHGROU.EQ.'4') THEN
                     EUP(I) = ESHL(8)
                  ELSEIF(CHGROU.EQ.'5') THEN
                     EUP(I) = ESHL(9)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for M '
     +               //'shell.  Maximum coded M5. Found shell '
     +               //'name: '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'N') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(10)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(11)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(12)
                  ELSEIF(CHGROU.EQ.'4') THEN
                     EUP(I) = ESHL(13)
                  ELSEIF(CHGROU.EQ.'5') THEN
                     EUP(I) = ESHL(14)
                  ELSEIF(CHGROU.EQ.'6') THEN
                     EUP(I) = ESHL(15)
                  ELSEIF(CHGROU.EQ.'7') THEN
                     EUP(I) = ESHL(16)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for N '
     +               //'shell. Maximum coded N7. Found shell name:'
     +               //' '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'O') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(17)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(18)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(19)
                  ELSEIF(CHGROU.EQ.'4') THEN
                     EUP(I) = ESHL(20)
                  ELSEIF(CHGROU.EQ.'5') THEN
                     EUP(I) = ESHL(21)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for O '
     +               //'shell.  Maximum code O5. Found shell name:'
     +               //' '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'P') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(22)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(23)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(24)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for P '
     +               //'shell.  Maximum coded P3. Found shell '
     +               //'name: '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSE
                  READ(CRNGUP(I,IZ),'(F6.0)') EUP(I)
               ENDIF
               IF(EUP(I).EQ.0.0) THEN
                  WRITE(CHMAIL,'(A44,I5)') ' GPHXSI Error: Upper limit '
     +            //'= 0. Interval:',I
                  CALL GMAIL(0,0)
                  STOP 14
               ENDIF
   90       CONTINUE
  100       CONTINUE
            DO 120 I = 1,IMAX
               DO 110 J = 1,MAXPOW
                  TMP(J,I) = COFS(J,I,IZ)*Q(JPHXS+1+2*NZ+N)
  110          CONTINUE
  120       CONTINUE
* Copy upper limits and coofficients to a work bank
            K = KS+1
            WS(K) = GPOMIN(IZ)
            WS(K+1) = 0.0
            WS(K+2) = 0.0
            WS(K+3) = 0.0
            WS(K+4) = 0.0
            K = K+5
            DO 140 I = 1,IMAX
               WS(K) = EUP(I)
               K = K+1
               DO 130 J = 1,MAXPOW
                  WS(K) = TMP(J,I)
                  K = K+1
  130          CONTINUE
  140       CONTINUE
            KS = KS+(MAXINT+1)*(MAXPOW+1)
            IWS(NZ+N) = IMAX
            IWS(2*NZ+N) = 0
            IWS(3*NZ+N) = 0
*            WS(N) = Q(JPHXS+1+2*NZ+N)
* Create element x-section & final state bank
            CALL MZBOOK(IXCONS,JPHFN,JPHXS,-N,'PHFN',0,0,IMAX*5+1,3,0)
            Q(JPHFN+1) = IMAX
* Update pointer
            JPHFN = JPHFN+1
            KFN = 1
* Copy energy & x-section parameters
            DO 160 I = 1,IMAX
               Q(JPHFN+KFN) = EUP(I)
               KFN = KFN+1
               DO 150 J = 1,MAXPOW
c                  Q(JPHFN+KFN) = TMP(J,I)*Q(JPHXS+1+2*NZ+N)
                  Q(JPHFN+KFN) = TMP(J,I)
                  KFN = KFN+1
  150          CONTINUE
  160       CONTINUE
* Get shells decay parameters
            CALL GFSHDC(N,ZCUR)
  170    CONTINUE
* Now find intervals and calculate the coofs for each
         K = 0
         JPHXS = LQ(JPHOT-1)
         IF(NZ.LT.2) THEN
* Simple element so life is easy and nice
            Q(JPHXS+5) = IMAX+1
            JPHXS6 = JPHXS+6
            Q(JPHXS6) = GPOMIN(IZ)
            Q(JPHXS6+1) = 0.0
            Q(JPHXS6+2) = 0.0
            Q(JPHXS6+3) = 0.0
            Q(JPHXS6+4) = 0.0
            JPHXS6 = JPHXS6+5
            DO 190 I = 1,IMAX
               Q(JPHXS6+K) = EUP(I)
               K = K+1
               DO 180 J = 1,MAXPOW
                  Q(JPHXS6+K) = TMP(J,I)
                  K = K+1
  180          CONTINUE
  190       CONTINUE
            NPSH = NW-5*(IMAX+1)-5
         ELSE
* More elements. It will not be so easy
* The following code is difficult and probably there are better solutions
* but I could think only about this one.
            IPHXSP = JPHXS+2+3*NZ
            IPIMAX = JPHXS+2+3*NZ
            IOFFST = (MAXPOW+1)*(MAXINT+1)
            DO 250 II = 1,NZ*(MAXINT+1)
* Find the interval for which the upper limit is the smallest
               AMINV = 1.E20
               DO 200 I = 1,NZ
                  K = IWS(2*NZ+I)
                  IPOINT = 5*NZ+1+(I-1)*IOFFST+K
                  IEUP = 4*NZ+I
                  WS(IEUP) = WS(IPOINT)
                  IF(WS(IEUP).LT.AMINV) AMINV = WS(IEUP)
  200          CONTINUE
               L = 0
               DO 210 I = 1,NZ
                  IF(WS(4*NZ+I).LE.AMINV) L = L+1
  210          CONTINUE
               IF(L.LT.1) THEN
                  CHMAIL = ' GPHXSI Error: Zero intervals found.'
                  CALL GMAIL(0,0)
                  STOP 16
               ENDIF
* Copy to JPHXS bank
               Q(IPIMAX) = Q(IPIMAX)+1.
               Q(IPHXSP+1) = AMINV
               IPHXSP = IPHXSP+1
               DO 230 J = 1,MAXPOW
                  QS = 0.0
                  DO 220 I = 1,NZ
                     K = IWS(2*NZ+I)
                     IPOINT = 5*NZ+1+(I-1)*IOFFST+K+J
c                     QS = QS+WS(I)*WS(IPOINT)
                     QS = QS+WS(IPOINT)
  220             CONTINUE
                  Q(IPHXSP+1) = QS
                  IPHXSP = IPHXSP+1
  230          CONTINUE
               IF(L.EQ.NZ.AND.AMINV.EQ.55.E11) GO TO 260
* Update local pointers
               DO 240 I = 1,NZ
                  IEUP = 4*NZ+I
                  IF(WS(IEUP).LE.AMINV) THEN
                     INZ2 = 2*NZ+I
                     IF(IWS(3*NZ+I).LT.IWS(I+NZ)) THEN
                        IWS(INZ2) = IWS(INZ2)+5
                        IWS(3*NZ+I) = IWS(3*NZ+I)+1
                     ENDIF
                  ENDIF
  240          CONTINUE
  250       CONTINUE
* It is THE END of th x-secs. part, however you may not believe it.
  260       CONTINUE
            NIT=Q(IPIMAX)
            IIT = -1
  261       IIT = IIT+1
*
* It just may happen that some of the energy limits are the same
               IENE=IIT*5+1
               IF(ABS(Q(IPIMAX+IENE)-Q(IPIMAX+IENE+5)).LT.
     +                                Q(IPIMAX+IENE)*5E-4) THEN
                  DO 262 II=1,(NIT-IIT-1)*5
                     Q(IPIMAX+IENE+II)=Q(IPIMAX+IENE+II+5)
  262             CONTINUE
                  NIT=NIT-1
                  IIT=IIT-1
               ENDIF
            IF(IIT.LT.NIT-1) GO TO 261
            Q(IPIMAX)=NIT
            NPSH = NW-Q(IPIMAX)*5-3*NZ-2
         ENDIF
* Return unused locations in JPHXSI bank to the system
         IF(NPSH.GT.0) THEN
            JPHXS = LQ(JPHOT-1)
            CALL MZPUSH(IXCONS,JPHXS,0,-NPSH,'R')
         ENDIF
      ELSEIF(Z.GT.100.) THEN
* Just in case we got called
         CHMAIL = ' GPHXSI Error: Z > 100. No Sandia parameters. '
         CALL GMAIL(0,0)
      ENDIF
      END
+DECK,GPHYSI.
*CMZ :  3.21/03 06/10/94  16.31.40  by  S.Ravndal
*-- Author :
      SUBROUTINE GPHYSI
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialise material constants for all the physics        *
C.    *       mechanisms used by GEANT                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCCUTS
+SEQ,GCFLAG
+SEQ,GCJLOC
+SEQ,GCLIST
+SEQ,GCMULO
+SEQ,GCTMED
+SEQ,GCMATE
+SEQ,GCNUM
+SEQ,GCONSP
+SEQ,GCTIME
+SEQ,GCTRAK
+SEQ,GCUNIT
      DIMENSION CUTS(10),UCUT(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      CHARACTER*4 DNAME,KCUT(10)
      CHARACTER*20 CHTITL
      LOGICAL NUCRIN
C.
C.    ------------------------------------------------------------------
C.
C              Write RUN parameters, version numbers and CUTS
C
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10200)GVERSN,IGDATE,IGTIME
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10300)IDRUN
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10400)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10500)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10600)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
C
C              Get the version number of the original INIT structure
C
      OLDGVE=BIG
*
*        Set NUMOLD to 0 to force recalculation of
*        pointers in the tracking routines
      NUMOLD=0
      IF(JRUNG.NE.0)THEN
         OLDGVE =  Q(JRUNG+21)
         IQ(JRUNG+11)=IGDATE
         IQ(JRUNG+12)=IGTIME
         Q(JRUNG+21)=GVERSN
         Q(JRUNG+22)=ZVERSN
C
         DNAME='INIT'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+11),IQ(JRUNG+12), Q(JRUNG+
     +   21), Q(JRUNG+22)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         DNAME='KINE'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+13),IQ(JRUNG+14), Q(JRUNG+
     +   23), Q(JRUNG+24)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         DNAME='HITS'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+15),IQ(JRUNG+16), Q(JRUNG+
     +   25), Q(JRUNG+26)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         DNAME='DIGI'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+17),IQ(JRUNG+18), Q(JRUNG+
     +   27), Q(JRUNG+28)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         IF(NRNDM(1).EQ.0.AND.NRNDM(2).EQ.0) THEN
*
*             The random number sequence has not been explicitely
*             initialised via a data card. See whether we can initialise
*             it with the words 19/20 of the JRUNG data structure.
            IF(IQ(JRUNG+19).NE.0.OR.IQ(JRUNG+20).NE.0) THEN
               NRNDM(1) = IQ(JRUNG+19)
               NRNDM(2) = IQ(JRUNG+20)
               CALL GRNDMQ(NRNDM(1), NRNDM(2), 0, 'S')
            ENDIF
         ENDIF
         CALL GRNDMQ(IQ(JRUNG+19), IQ(JRUNG+20), 0, 'G')
         WRITE(CHMAIL,10900) IQ(JRUNG+19), IQ(JRUNG+20)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,11000)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
      ENDIF
C
C             Create energy loss and cross-section banks
C
      IF(NEKBIN.LE.0.OR.NEKBIN.GT.199)NEKBIN=90
      IF(EKMIN.GE.EKMAX.OR.EKMIN.LE.0.)THEN
         EKMIN=1.E-5
         EKMAX=1.E+4
      ENDIF
      NEK1=NEKBIN+1
      EKINV=1./LOG10(EKMAX/EKMIN)
      EKBIN(1)=LOG10(EKMIN)
      ELOW(1)=EKMIN
      GEKA=NEKBIN*EKINV
      GEKB=1.-GEKA*EKBIN(1)
      DO 10 I=2,NEK1
         EL=EKBIN(1)+(I-1)/GEKA
         EKBIN(I)=EL
         ELOW(I)=10.**EL
   10 CONTINUE
      ILOW=0
      IF(NMATE.LE.0)GO TO 999
      IF(JMATE.LE.0)GO TO 999
      IF(JTMED.LE.0)GO TO 999
C
      IF(IQ(JTMED-1).LT.40) THEN
         NPUSH=40-IQ(JTMED-1)
         CALL MZPUSH(IXCONS,JTMED,0,NPUSH,'I')
      END IF
      Q(JTMED+31)=ILABS
      Q(JTMED+32)=ISYNC
      Q(JTMED+33)=ISTRA
*
*             If Landau fluctuations activated, cancel delta rays
      KLOS=Q(JTMED+21)
      IF (KLOS .EQ. 0) Q(JTMED+15) = 0.
      IF (KLOS .EQ. 2) THEN
         Q(JTMED+ 8)=9999.
         Q(JTMED+ 9)=9999.
         Q(JTMED+15)=0.
      ENDIF
*
* If Cerenkov generation is on, activate Light absorbtion unless
* explicitely switched off by the user
*
      KLABS=Q(JTMED+31)
      IF(ITCKOV.NE.0) THEN
         IF(KLABS.EQ.-1) THEN
            Q(JTMED+31)=1
         ENDIF
      ENDIF
      Q(JTMED+31)=MAX(Q(JTMED+31),0.)
*
*             If BCUTE,BCUTM,DCUTE,DCUTM,PPCUTM not initialized (=BIG)
*             Set them to CUTGAM,CUTGAM,CUTELE,CUTELE respectively
*
      IF(Q(JTMED+ 6).GT.0.9*BIG)Q(JTMED+ 6)=Q(JTMED+1)
      IF(Q(JTMED+ 7).GT.0.9*BIG)Q(JTMED+ 7)=Q(JTMED+1)
      IF(Q(JTMED+ 8).GT.0.9*BIG)Q(JTMED+ 8)=Q(JTMED+2)
      IF(Q(JTMED+ 9).GT.0.9*BIG)Q(JTMED+ 9)=Q(JTMED+2)
      IF(Q(JTMED+10).GT.0.9*BIG)Q(JTMED+10)=0.010
      IF(Q(JTMED+10).LT.4.*EMASS)Q(JTMED+10)=4.*EMASS
C
      DO 20 K=1,10
   20 CALL GEVKEV(Q(JTMED+K),UCUT(K),KCUT(K))
      WRITE(CHMAIL,10800)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11200)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11300) (UCUT(K),KCUT(K),K=1,3)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11400) (UCUT(K),KCUT(K),K=4,5)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11500) (UCUT(K),KCUT(K),K=6,7)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11600) (UCUT(K),KCUT(K),K=8,10)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11700) (Q(JTMED+K),K=11,13)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11800) (Q(JTMED+K),K=14,16)
      CALL GMAIL(0,0)
      IF(Q(JTMED+18).EQ.3.) THEN
         NUCRIN = .TRUE.
         Q(JTMED+18)=1.
      ELSE
         NUCRIN = .FALSE.
      ENDIF
      WRITE(CHMAIL,11900) (Q(JTMED+K),K=17,19)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,12000) (Q(JTMED+K),K=20,22)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,12100) Q(JTMED+23),Q(JTMED+31),Q(JTMED+32)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,12110) Q(JTMED+33)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      IF(NUCRIN) THEN
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,12800)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,12900)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
      ENDIF
*
* ***    Here we clean up the old cross section tables if any
      DO 40  IMA=1,NMATE
         JMA=LQ(JMATE-IMA)
         IF(JMA.NE.0) THEN
            DO 30  J=1,20
               IF(LQ(JMA-J).NE.0.AND.J.NE.5) THEN
                  CALL MZDROP(IXCONS,LQ(JMA-J),'L')
               ENDIF
   30       CONTINUE
         ENDIF
   40 CONTINUE
*
* *** Call initialisation of the phtotelectric effect constants
      CALL GPHINI
      DO 180 ITM=1,NTMED
         JTM=LQ(JTMED-ITM)
         IF(JTM.LE.0) GO TO 180
         NL=10-IQ(JTM-2)
         IF(NL.GT.0)THEN
            CALL MZPUSH(IXCONS,JTM,NL,0,'I')
            JTM=LQ(JTMED-ITM)
         ENDIF
*         IF(IQ(JTM-1).LT.40) THEN
*           NPUSH=40-IQ(JTM-1)
*           CALL MZPUSH(IXCONS,JTM,0,NPUSH,'I')
*           JTM=LQ(JTMED-ITM)
*         ENDIF
         ISVOL = Q(JTM + 7)
         IFIELD = Q(JTM + 8)
         FIELDM = Q(JTM + 9)
         TMAXFD = Q(JTM + 10)
         STEMAX = Q(JTM + 11)
         DEEMAX = Q(JTM + 12)
         EPSIL = Q(JTM + 13)
         STMIN = Q(JTM + 14)
         IF (TMAXFD.LE.0..OR. (IGAUTO.NE.0.AND.TMAXFD.GT.20.)) THEN
            TMAXFD=20.
            Q(JTM+10) = TMAXFD
         ENDIF
         NMAT = Q(JTM+6)
         JMA = LQ(JMATE-NMAT)
         IF(JMA.LE.0)THEN
            WRITE(CHMAIL,12200)NMAT,ITM
            CALL GMAIL(1,1)
            GO TO 180
         ENDIF
C
C=====>       Get material parameters
C
         A=Q(JMA+6)
         Z=Q(JMA+7)
         DENS=Q(JMA+8)
         RADL=Q(JMA+9)
         IF (Z.LT.1.) THEN
            DEEMAX=0.
            STMIN =0.
            JTP=LQ(JTM)
            IF(JTP.EQ.0) THEN
               CALL MZBOOK(IXCONS,JTP,JTM,0,'TCUT',0,0,40,3,0)
               IQ(JTP-5)=ITM
               DO 50 I=1,23
                  Q(JTP+I)=Q(JTMED+I)
   50          CONTINUE
               Q(JTP+31)=Q(JTMED+31)
               Q(JTP+32)=Q(JTMED+32)
               Q(JTP+33)=Q(JTMED+33)
            ELSEIF(IQ(JTP-1).LT.40) THEN
               NPUSH=40-IQ(JTP-1)
               CALL MZPUSH(IXCONS,JTP,0,NPUSH,'I')
               JTP=LQ(JTM)
               Q(JTP+31)=Q(JTMED+31)
               Q(JTP+32)=Q(JTMED+32)
               Q(JTP+33)=Q(JTMED+33)
            ENDIF
C
C=====>     decay and synch. rad. in vacuum
C
            DO 60 I=11,23
               Q(JTP+I)=0.
   60       CONTINUE
            Q(JTP+20) = Q(JTMED+20)
            Q(JTP+31) = 0.
            Q(JTP+32) = Q(JTMED+32)
            Q(JTP+33) =0.
         ENDIF
C
C=====>       Get tracking medium parameters
C
         JTP=JTMED
         IF(LQ(JTM).NE.0)JTP=LQ(JTM)
         IF(JTP.NE.JTMED)THEN
            IF(IQ(JTP-1).LT.40) THEN
               NPUSH=40-IQ(JTP-1)
               CALL MZPUSH(IXCONS,JTP,0,NPUSH,'I')
               JTP=LQ(JTM)
               Q(JTP+31)=Q(JTMED+31)
               Q(JTP+32)=Q(JTMED+32)
               Q(JTP+33)=Q(JTMED+33)
            ENDIF
            KLOS=Q(JTP+21)
            IF (KLOS .EQ. 2) THEN
               Q(JTP+ 8)=9999.
               Q(JTP+ 9)=9999.
               Q(JTP+15)=0.
            ENDIF
*
* If Cerenkov generation is on, activate Light absorbtion unless
* explicitely switched off by the user
*
            KLABS=Q(JTP+31)
            IF(ITCKOV.NE.0) THEN
               IF(KLABS.EQ.-1) THEN
                  Q(JTP+31)=1
               ENDIF
            ENDIF
            Q(JTP+31)=MAX(Q(JTP+31),0.)
            IF(Q(JTP+ 6).GT.0.9*BIG)Q(JTP+ 6)=Q(JTP+1)
            IF(Q(JTP+ 7).GT.0.9*BIG)Q(JTP+ 7)=Q(JTP+1)
            IF(Q(JTP+ 8).GT.0.9*BIG)Q(JTP+ 8)=Q(JTP+2)
            IF(Q(JTP+ 9).GT.0.9*BIG)Q(JTP+ 9)=Q(JTP+2)
            IF(Q(JTP+10).GT.0.9*BIG)Q(JTP+10)=0.010
            IF(Q(JTP+10).LT.4.*EMASS)Q(JTP+10)=4.*EMASS
*
            CALL UHTOC(IQ(JTM+1),4,CHTITL,20)
            LAST=LNBLNK(CHTITL)
            IF(LAST.GT.0) THEN
               IF(CHTITL(LAST:LAST).EQ.'$') LAST=LAST-1
               CHTITL(LAST+1:20)=' '
            ENDIF
*
            DO 70 K=1,10
   70       CALL GEVKEV(Q(JTP+K),UCUT(K),KCUT(K))
            WRITE(CHMAIL,10100)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12300)ITM,CHTITL
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12400)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11300) (UCUT(K),KCUT(K),K=1,3)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11400) (UCUT(K),KCUT(K),K=4,5)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11500) (UCUT(K),KCUT(K),K=6,7)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11600) (UCUT(K),KCUT(K),K=8,10)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11700) (Q(JTP+K),K=11,13)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11800) (Q(JTP+K),K=14,16)
            CALL GMAIL(0,0)
            IF(Q(JTP+18).EQ.3.) THEN
               NUCRIN = .TRUE.
               Q(JTP+18)=1.
            ELSE
               NUCRIN = .FALSE.
            ENDIF
            WRITE(CHMAIL,11900) (Q(JTP+K),K=17,19)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12000) (Q(JTP+K),K=20,22)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12100) Q(JTP+23),Q(JTP+31),Q(JTP+32)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12110) Q(JTP+33)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10100)
            CALL GMAIL(0,0)
            IF(NUCRIN) THEN
               WRITE(CHMAIL,10100)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,12800)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,12900)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,10100)
               CALL GMAIL(0,0)
            ENDIF
         ENDIF
C
         DO 80 I=1,10
            CUTS(I)=Q(JTP+I)
   80    CONTINUE
         DO 90 I=1,13
            MECA(1,I)=Q(JTP+10+I)
   90    CONTINUE
         ILABS=Q(JTP+10+21)
         ISYNC=Q(JTP+10+22)
         ISTRA=Q(JTP+10+23)
C
         IF(ILOW.EQ.0)THEN
            DO 100 I=1,10
               IF(Q(JTP+I).LT.0.0000099)THEN
                  WRITE(CHMAIL,12500)
                  CALL GMAIL(1,1)
                  ILOW=1
               ENDIF
  100       CONTINUE
         ENDIF
C
C             Check consistency of different tracking media
C             referencing the same material
C
         DO 120 ITM2=ITM+1,NTMED
            JTM2=LQ(JTMED-ITM2)
            IF(JTM2.NE.0)THEN
               NMAT2=Q(JTM2+6)
               IF(NMAT2.EQ.NMAT)THEN
                  JTP2=JTMED
                  IF(LQ(JTM2).NE.0)JTP2=LQ(JTM2)
                  IF(JTP.NE.JTP2)THEN
                     IF(JTP2.NE.JTMED)THEN
                        KLOS=Q(JTP2+21)
                        IF (KLOS .EQ. 2) THEN
                           Q(JTP2+ 8)=9999.
                           Q(JTP2+ 9)=9999.
                           Q(JTP2+15)=0.
                        ENDIF
                        IF(Q(JTP2+ 6).GT.0.9*BIG)Q(JTP2+ 6)=Q(JTP2+1)
                        IF(Q(JTP2+ 7).GT.0.9*BIG)Q(JTP2+ 7)=Q(JTP2+1)
                        IF(Q(JTP2+ 8).GT.0.9*BIG)Q(JTP2+ 8)=Q(JTP2+2)
                        IF(Q(JTP2+ 9).GT.0.9*BIG)Q(JTP2+ 9)=Q(JTP2+2)
                        IF(Q(JTP2+10).GT.0.9*BIG)Q(JTP2+10)=0.010
                        IF(Q(JTP2+10).LT.4.*EMASS)Q(JTP2+10)=4.*EMASS
                     ENDIF
                     DO 110 I=6,10
                        IF(Q(JTP+I).NE.Q(JTP2+I))THEN
                           WRITE(CHMAIL,12600)NMAT
                           CALL GMAIL(1,0)
                           WRITE(CHMAIL,12700)ITM,ITM2
                           CALL GMAIL(0,1)
                           GO TO 120
                        ENDIF
  110                CONTINUE
                  ENDIF
               ENDIF
            ENDIF
  120    CONTINUE
         IF (DEEMAX.LT.0.) THEN
            IF(ISVOL.EQ.0)THEN
               DEEMAX=0.25
               IF(RADL.GT.2.)DEEMAX=0.25-0.2/SQRT(RADL)
            ELSE
               DEEMAX = 0.2/SQRT(RADL)
            ENDIF
         ENDIF
         IF(OLDGVE.LT.3.15.OR.STEMAX.LE.0.) THEN
*
*       Before version 3.15 there was no STEMAX, so we put it to BIG
            STEMAX=BIG
         ENDIF
         Q(JTM+11) = STEMAX
         Q(JTM+12) = DEEMAX
C
*
*       It can happen that several tracking media refer to the
*       same material. In this case we do not fill the cross section
*       tables more than once. But we still fill the banks of the
*       tracking medium.
         IF(LQ(JMA-1).NE.0) GOTO 160
         NPUSH=20-IQ(JMA-2)
         IF(NPUSH.GT.0)THEN
            CALL MZPUSH(IXCONS,JMA,NPUSH,0,'I')
            JTM=LQ(JTMED-ITM)
            JMA=LQ(JMATE-NMAT)
         ENDIF
*
*     Energy loss and cross-section tables
         IF(ISTRA.EQ.0) THEN
         CALL MZBOOK(IXCONS,LBANK,JMA, -1,'MAEL',0,0,2*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA, -2,'MAMU',0,0, NEK1,3,0)
         ELSE
         CALL MZBOOK(IXCONS,LBANK,JMA, -1,'MAEL',0,0,3*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA, -2,'MAMU',0,0,2*NEK1,3,0)
         ENDIF
         CALL MZBOOK(IXCONS,LBANK,JMA, -3,'MAAL',0,0, NEK1,3,0)
         CALL MZBOOK(IXCONS,JPROB,JMA, -4,'MAPR',0,0, 40,3,0)
         CALL MZBOOK(IXCONS,JPHOT,JMA, -6,'MAPH',2,2, NEK1,3,0)
         CALL MZBOOK(IXCONS,JANNI,JMA, -7,'MAAN',0,0, NEK1,3,0)
         CALL MZBOOK(IXCONS,JCOMP,JMA, -8,'MACO',0,0, NEK1,3,0)
         CALL MZBOOK(IXCONS,JBREM,JMA, -9,'MABR',0,0,3*NEK1,3,0)
         CALL MZBOOK(IXCONS,JPAIR,JMA,-10,'MAPA',0,0,2*NEK1,3,0)
         CALL MZBOOK(IXCONS,JDRAY,JMA,-11,'MADR',0,0,3*NEK1,3,0)
*
* *** Special case for heavy materials, photo-fission
         IF(A.GE.230..AND.A.LE.240..AND.IPFIS.NE.0)THEN
            CALL MZBOOK(IXCONS,JPFIS,JMA,-12,'MAPF',0,0,2*NEK1,3,0)
         ENDIF
*
* *** Rayleigh effect
         CALL MZBOOK(IXCONS,JRAYL,JMA,-13,'MARA',0,0,2*NEK1,3,0)
*
* *** Muon nuclear interactions
         IF(IMUNU.EQ.0)THEN
            JMUNU=0
         ELSE
            CALL MZBOOK(IXCONS,JMUNU,JMA,-14,'MAMN',0,0,NEK1,3,0)
         ENDIF
*
* *** stopping range
         CALL MZBOOK(IXCONS,LBANK,JMA,-15,'MASE',0,0,2*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA,-16,'MASM',0,0,2*NEK1,3,0)
*
* *** Special for photeffect
         CALL GPHXSI
*
* *** coefficients for energy loss
         CALL MZBOOK(IXCONS,LBANK,JMA,-17,'MACE',0,0,6*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA,-18,'MACM',0,0,6*NEK1,3,0)
*
* *** auxiliary tables for integration of dE/dx
         CALL GWORK(NEKBIN*4)
*
         DO 130 JWORK=1, NEKBIN*4
            WS(JWORK) = 0.
  130    CONTINUE
*
* *** Straggling for thin layers, if in effect
         IF(ISTRA.GT.0) THEN
            CALL MZBOOK(IXCONS,JTSTRA,JMA,-19,'MAST',2,2,1,3,0)
+SELF,IF=ASHO
            IF(ISTRA.EQ.2) THEN
               CALL MZBOOK(IXCONS,JTASHO,JMA,-20,'MASH',0,0,106,3,0)
            ENDIF
+SELF
         ENDIF
*
         DO 140 J=1,20
            JB=LQ(JMA-J)
            IF(JB.NE.0)IQ(JB-5)=NMAT
  140    CONTINUE
C
         JPROB=LQ(JMA-4)
         JMIXT=LQ(JMA-5)
         JPFIS=LQ(JMA-12)
*
* *** Fill above tables (energy losses,cross-sections,stopping ranges)
*
         CALL GPROBI
C
         DO 150 IEKBIN=1,NEK1
C
            CALL GDRELA
            CALL GBRELA
            CALL GPRELA
C
            CALL GPHOTI
            CALL GRAYLI
            CALL GANNII
            CALL GCOMPI
            CALL GBRSGA
            CALL GPRSGA
            CALL GDRSGA
            CALL GMUNUI
            CALL GPFISI
  150    CONTINUE
*
*           Stopping ranges
*
         CALL GRANGI
*
*           Energy loss coefficients
*
         CALL GCOEFF
* *** The table for the energy loss in thin gas layers if the tracking
*     media is defined as such
*
         IF(ISTRA.GT.0) THEN
            CALL GSTINI
+SELF,IF=ASHO
            IF (ISTRA.EQ.2) THEN
               CALL GIASHO
            ENDIF
+SELF
         ENDIF
*
* *** Multiple scattering,energy-loss and mag.field steps
  160    DO 170 J=1,2
            IF(LQ(JTM-J).NE.0) THEN
               CALL MZDROP(IXCONS,LQ(JTM-J),'L')
            ENDIF
  170    CONTINUE
         CALL MZBOOK(IXCONS,LBANK,JTM, -1,'MUEL',0,0,NEK1+2,3,0)
         IQ(LBANK-5)=ITM
         CALL MZBOOK(IXCONS,LBANK,JTM, -2,'MUMU',0,0,NEK1+2,3,0)
         IQ(LBANK-5)=ITM
         CALL GMULOF
C
  180 CONTINUE
*
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10400)
      CALL GMAIL(0,2)
C
10000 FORMAT(
     +'1************************************************************')
10100 FORMAT(
     +' *                                                          *')
10200 FORMAT(
     +' *    G E A N T  Version',F7.4,'      DATE/TIME',I7,'/',
     +   I4,2X,'*')
10300 FORMAT(
     +' *                      R U N  ',I5,10X,'              *')
10400 FORMAT(
     +' ************************************************************')
10500 FORMAT(
     +' *      Data structure   Date   Time    GVERSN    ZVERSN    *')
10600 FORMAT(
     +' *      --------------   ----   ----    ------    ------    *')
10700 FORMAT(' *',11X,A,6X,I7,2X,I4,3X,F7.4,2X,F7.2,5X,'*')
10800 FORMAT(
     +' *----------------------------------------------------------*')
10900 FORMAT(' *     Random number seeds: ',3X,I10,3X,I10,6X,'*')
11000 FORMAT(
     +' *     --------------------                                 *')
11100 FORMAT(
     +' *              Standard TPAR for this run are              *')
11200 FORMAT(
     +' *              ------------------------------              *')
11300 FORMAT(
     +' *  CUTGAM=',F6.2,A4,'  CUTELE=',F6.2,A4,'  CUTNEU=',F6.2,A4,1X,
     + '*')
11400 FORMAT(
     +' *  CUTHAD=',F6.2,A4,'  CUTMUO=',F6.2,A4,20X,'*')
11500 FORMAT(
     +' *  BCUTE =',F6.2,A4,'  BCUTM =',F6.2,A4,20X,'*')
11600 FORMAT(
     +' *  DCUTE =',F6.2,A4,'  DCUTM =',F6.2,A4,'  PPCUTM=',F6.2,A4,1X,
     + '*')
11700 FORMAT(
     +' *  IPAIR =',F10.0,'  ICOMP =',F10.0,'  IPHOT =',F10.0,1X,'*')
11800 FORMAT(
     +' *  IPFIS =',F10.0,'  IDRAY =',F10.0,'  IANNI =',F10.0,1X,'*')
11900 FORMAT(
     +' *  IBREM =',F10.0,'  IHADR =',F10.0,'  IMUNU =',F10.0,1X,'*')
12000 FORMAT(
     +' *  IDCAY =',F10.0,'  ILOSS =',F10.0,'  IMULS =',F10.0,1X,'*')
12100 FORMAT(
     +' *  IRAYL =',F10.0,'  ILABS =',F10.0,'  ISYNC =',F10.0,1X,'*')
12110 FORMAT(
     +' *  ISTRA =',F10.0, 39X,                                  '*')
 
12200 FORMAT(' ***** GPHYSI error, Material Nr=',I3,
     + ' referenced by Medium Nr=',I3)
12300 FORMAT(
     +' *     Special TPAR for TMED',I4,3X,A,5X,'*')
12400 FORMAT(
     +' *     -------------------------                            *')
12500 FORMAT(' ***** GPHYSI error, CUTS must be',
     + ' greater than 10 KeV *****')
12600 FORMAT(' ***** GPHYSI error for material nr ',I4)
12700 FORMAT(7X,'Tracking medium NR',I4,' and',I4,
     +' have different parameters')
12800 FORMAT(
     +' *  IHADR=3 not supported any more. GHEISHA will handle     *')
12900 FORMAT(
     +' *  hadronic interactions for the above tracking medium     *')
  999 CONTINUE
      END
+DECK,GPOISS
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GPOISS(AMVEC,NPVEC,LEN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates  a vector NPVEC of LEN random numbers               *
C.    *  POISSON distribued with mean values AMVEC                     *
C.    *                                                                *
C.    *  If the mean value A greater than PLIM, N is calculated        *
C.    *  according to the Gaussian approximation of the Poisson        *
C.    *  distribution.                                                 *
C.    *                                                                *
C.    *     ==> Called by : GLANDZ,GMCOUL                              *
C.    *                                                                *
C.    *  Author      : L.Urban                                         *
C.    *  Date        : 28.04.1988           Last update :  1.02.1990   *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
      REAL AMVEC(*),RNDM(2), N
      INTEGER NPVEC(*)
      PARAMETER (PLIM=16.,HMXINT=2E+9)
*
      DO 30 I=1,LEN
*     Protection against negative mean values
         N=0.
         IF(AMVEC(I).GT.0.) THEN
            IF(AMVEC(I).LE.PLIM) THEN
               CALL GRNDM(RNDM,1)
               R=RNDM(1)
               P=EXP(-AMVEC(I))
               S=P
               IF(R.LE.S) GOTO 20
   10          N=N+1.
               P=P*AMVEC(I)/N
               S=S+P
               IF(S.LT.R.AND.P.GT.1.E-30) GOTO 10
            ELSE
               CALL GRNDM(RNDM,2)
               RR=SQRT(-2.*LOG(RNDM(1)))
               PHI=TWOPI*RNDM(2)
               X=RR*COS(PHI)
               N=MIN(MAX(AMVEC(I)+X*SQRT(AMVEC(I)),0.),HMXINT)
            ENDIF
         ENDIF
*
   20    NPVEC(I) = N
   30 CONTINUE
*
      END
+DECK,GPRELA
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GPRELA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialise energy loss due to direct pair-production  and     *
C.    *  nuclear interactions by muons.                                *
C.    *                                                                *
C     *       A, Direct pair production  <=======                      *
C     *                                                                *
C.    *  The DE/DX expression of MANDO and RONCHI(NUOVO CIMENTO        *
C.    *  9(1952),517) is used which attempts to account for the effect *
C.    *  of atomic electron screening. The screening correction is     *
C.    *  applied above the energy limit defined by C. RICHARD-SERRE    *
C.    *  (CERN 71-18).                                                 *
C.    *                                                                *
C     *       B, Nuclear interactions  <=======                        *
C.    *                                                                *
C.    *  the following expression derived from the Williams-Weizsacker *
C.    *  relation for the virtual photon flux is used :                *
C.    *                                                                *
C.    *      DE/DX = FACTOR * XSEC * E                                 *
C.    *                                                                *
C.    *      where,                                                    *
C.    *      FACTOR  =  2. * N * ALPHA / PI                            *
C.    *      XSEC    =  total photo-nuclear cross-section assumed to   *
C.    *                 be independent of energy. Value of 140 mubarns *
C.    *                 calculated by averaging the results of Hesse   *
C.    *                 et al(Phys. Rev. Lett 25(1970),613).           *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCJLOC
+SEQ,GCMULO
+SEQ,GCMATE
+SEQ,GCPHYS
+SEQ,GCONSP
+SEQ,GCCUTS
+SEQ,GCTRAK
      DATA XSEC  /140.E-30/
      DATA FACTOR/2.7976238E+21/
C.
C.    ------------------------------------------------------------------
C.
      IF(Z.LT.1.) GOTO 999
      ICHAN=IEKBIN
      T    = ELOW(ICHAN)
      T1   = 10.**(EKBIN(1)+(ICHAN-0.5)/GEKA)
      IF(T.LT.1.)GO TO 999
      E    = T+EMMU
      E1   = T1+EMMU
      IF(JMIXT.EQ.0)THEN
C
C           Element
C
         DEDX = GPRELM(Z,T,PPCUTM)
         DEDX = AVO*DENS*DEDX/A
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DEDX1 = GPRELM(Z,T1,PPCUTM)
            DEDX1 = AVO*DENS*DEDX1/A
         ENDIF
      ELSE
C
C          Compound/Mixture
C
         NLMAT = Q(JMA+11)
         NLM   = IABS(NLMAT)
         DEDX  = 0.
         DEDX1 = 0.
         DO 10 L=1,NLM
            J    = JMIXT+NLM+L
            AA   = Q(J-NLM)
            ZZ   = Q(J)
            WMAT = Q(J+NLM)
            S    = GPRELM(ZZ,T,PPCUTM)
            S    = WMAT*S/AA
            DEDX = DEDX+AVO*DENS*S
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               S = GPRELM(ZZ,T1,PPCUTM)
               S = WMAT*S/AA
               DEDX1 = DEDX1+AVO*DENS*S
            ENDIF
   10    CONTINUE
      ENDIF
C
C             Nuclear interactions
C
      IF(IMUNU.EQ.0.AND.E.GE.10.) THEN
         DENU=DENS*FACTOR*XSEC*E
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DENU1=DENS*FACTOR*XSEC*E1
         ENDIF
      ELSE
         DENU=0.0
         DENU1=0.0
      ENDIF
      IF(DEDX.LT.0.)DEDX=0.
      IF(DENU.LT.0.)DENU=0.
      JEL2=LQ(JMA-2)
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX+DENU
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         IF(DEDX1.LT.0.)DEDX1=0.
         IF(DENU1.LT.0.)DENU1=0.
         WS(NEKBIN*2+ICHAN)=WS(NEKBIN*2+ICHAN)+DEDX1+DENU1
      ENDIF
C
  999 CONTINUE
      END
+DECK,GPRELM
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      FUNCTION GPRELM(Z,T,CUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To calculate DE/DX in GeV*barn/atom for direct           *
C.    *       pair production by muons.                                *
C.    *                                                                *
C.    *    ==>Called by : GPRSGA                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (AKSI=1.19,BETA=1.24,DEL=0.13,VE=0.008)
      PARAMETER (ECMIN=2.044E-3,CONMX=0.130653)
C                               CONMX=0.75*SQRT(2.7182...)*EMMU
+SEQ,GCONSP
      DIMENSION C(100),D(28),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      DATA C1/0.199979E-04,-0.247381E-04, 0.901012E-05,-0.624746E-06
     +      , 0.306301E-08, 0.568134E-09,-0.154371E-04, 0.192663E-04
     +      ,-0.638613E-05, 0.325587E-06, 0.798057E-08,-0.623709E-09
     +      , 0.334831E-04,-0.305301E-04, 0.514764E-05, 0.273273E-07
     +      ,-0.455952E-07, 0.200990E-08,-0.617418E-05,-0.119758E-04
     +      , 0.505842E-05,-0.680982E-06, 0.335650E-07,-0.465426E-09
     +      ,-0.134652E-04, 0.268825E-05, 0.722810E-07,-0.648440E-07
     +      , 0.532560E-08,-0.122207E-09,-0.354308E-05, 0.125249E-05
     +      ,-0.182348E-06, 0.125659E-07,-0.390005E-09, 0.423919E-11
     +      , 0.427113E-05,-0.570105E-05, 0.156413E-05,-0.247880E-07
     +      ,-0.534990E-08, 0.172881E-09,-0.309866E-06, 0.654607E-06
     +      ,-0.885876E-07,-0.148160E-07, 0.814881E-09, 0.144373E-10
     +      ,-0.594089E-07, 0.643470E-08,-0.204298E-07, 0.346177E-08
     +      , 0.451711E-10,-0.115400E-10, 0.849857E-08,-0.485366E-08
     +      , 0.247710E-08,-0.224799E-09,-0.125246E-10, 0.116449E-11/
      DATA C2/0.406000E-08,-0.164080E-07, 0.109450E-07,-0.201483E-08
     +      , 0.889711E-10, 0.583750E-08, 0.523552E-08,-0.713086E-08
     +      , 0.151684E-08,-0.703329E-10, 0.863004E-07,-0.107717E-06
     +      , 0.344991E-07,-0.382381E-08, 0.128222E-09,-0.659685E-07
     +      , 0.283383E-07,-0.263676E-08,-0.978698E-10, 0.109724E-10
     +      , 0.209150E-09, 0.880502E-09,-0.235454E-09, 0.120280E-10
     +      ,-0.120162E-13,-0.814192E-08, 0.402793E-08, 0.952674E-09
     +      ,-0.377756E-09, 0.198358E-10, 0.254519E-08,-0.187283E-08
     +      , 0.168056E-09, 0.293299E-10,-0.221041E-11,-0.233497E-09
     +      , 0.197097E-09,-0.321342E-10, 0.329587E-12, 0.691294E-13/
      DATA D/-0.790941E-07, 0.840429E-07, 0.738033E-08,-0.407627E-07
     +      ,-0.116392E-07, 0.358398E-08, 0.141013E-07, 0.814070E-08
     +      ,-0.423749E-08, 0.173692E-08,-0.174475E-08,-0.185530E-08
     +      , 0.737768E-09, 0.160269E-09,-0.598384E-09, 0.926201E-10
     +      , 0.133740E-09, 0.957004E-11,-0.850466E-10, 0.214267E-10
     +      , 0.967441E-10,-0.181431E-11,-0.324662E-11,-0.579085E-12
     +      ,-0.237465E-11, 0.108081E-10,-0.902849E-11,-0.408422E-11/
C.
C.    ------------------------------------------------------------------
C.
      GPRELM=0.
      IF(CUT.LT.ECMIN) GOTO 999
C
      Z3=Z**0.333333
      E=T+EMMU
      ECMAX=E-CONMX*Z3
      ECMA5=ECMAX*0.2
      X=LOG(E/EMMU)
      IF(CUT.GE.ECMAX) GOTO 160
C
      IF(CUT.LE.ECMA5) THEN
        CCUT=CUT
      ELSE
        CCUT=ECMA5
      ENDIF
      Y=LOG(CCUT/(VE*E))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 999
C
      FAC=E*((CCUT-ECMIN)/E)**BETA
      FAC=Z*(Z+AKSI*(1.+DEL*LOG(Z)))*FAC
      GPRELM=FAC*S
      IF(CUT.LE.ECMA5) GOTO 999
      GPREL5=GPRELM
C
 160  Y=Z3
      S=D(1)
      K=1
      XX=1.
      YPX=Y/X
      DO 180 I=1,6
         II=I+1
         XX=XX*X
         XXYY=XX
         DO 170 J=1,II
            K=K+1
            S=S+D(K)*XXYY
            XXYY=XXYY*YPX
 170     CONTINUE
 180  CONTINUE
      IF(S.LE.0.) GOTO 999
C
      FAC=Z*(Z+1.)*ECMAX
      IF(FAC.LE.0.) GOTO 999
      GPRELM=FAC*S
C
      IF((CUT.LE.ECMA5).OR.(CUT.GE.ECMAX)) GOTO 999
      DEL1=(GPRELM-GPREL5)/(ECMAX-ECMA5)
      GPRELM=GPREL5+DEL1*(CUT-ECMA5)
C
999   RETURN
      END
+DECK,GPROBI.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GPROBI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialise material constants used in the computation of      *
C.    *  the probability for various interactions.                     *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, G.Patrick, L.Urban  *********         *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCONSP.
+SEQ,GCMATE.
+SEQ,GCJLOC.
      DIMENSION EK(4),EL1(4),EL2(4)
      DATA EK / 0.66644E-8 , 0.22077E-9 ,-0.32552E-11, 0.18199E-13/
      DATA EL1/-0.29179E-9 , 0.87983E-10,-0.12589E-11, 0.69602E-14/
      DATA EL2/-0.68606E-9 , 0.10078E-9 ,-0.14496E-11, 0.78809E-14/
      DATA ALFA/7.29735E-3/
      DATA REL/0.2817938/
C.
C.    ------------------------------------------------------------------
C.
      IF(Z.LT.1.) GOTO 999
      AEFF=A
      JPROB = LQ(JMA-4)
      IF(JMIXT.GT.0)THEN
         JMI1=LQ(JMIXT-1)
         AEFF=Q(JMI1+1)
      ENDIF
C
C             store constants for PAIR/BREMS routines
C
      X      = (Z*ALFA)**2
      FC     = (( - 0.002 * X + 0.0083) * X - 0.0369) * X + 0.20206
      FC     = X * (FC + 1. / (1. + X))
      C1=Z**0.333333
      C2=LOG(C1)
      C3=LOG(183./C1)-FC
      C4=LOG(1440./(C1*C1))/C3
      Q(JPROB+1)=Z*(Z+C4)*C3/A
      Q(JPROB+2)=C1
      Q(JPROB+3)=C2
      Q(JPROB+4)=FC
C
C             constants for PHOTOEFFECT
C
      Z2   = Z*Z
      EKZ  = Z2*(EK(1) +Z*(EK(2) +Z*(EK(3) +Z*EK(4))))
      EL1Z = Z2*(EL1(1)+Z*(EL1(2)+Z*(EL1(3)+Z*EL1(4))))
      EL2Z = Z2*(EL2(1)+Z*(EL2(2)+Z*(EL2(3)+Z*EL2(4))))
      Q(JPROB+5)=EKZ
      Q(JPROB+6)=EL1Z
      Q(JPROB+7)=EL2Z
C
C             Constants for Hadronic interactions
C
      Q(JPROB+8)= 1000.*AEFF/(AVO*DENS)
C
C             Constants for electron/positron ionisation losses
C             and S5 for one-photon annihilation
C
      IF(JMIXT.LE.0)THEN
         POTI=16.E-9*Z**0.9
         S1=Z/A
         S5=Z**5/A*ALFA**4
      ELSE
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         S1=0.
         S2=0.
         S5=0.
         DO 10 J=1,NLM
            AJ=Q(JMIXT+J)
            ZJ=Q(JMIXT+NLM+J)
            WJ=Q(JMIXT+2*NLM+J)
            S1=S1+WJ*ZJ/AJ
            S2=S2+WJ*ZJ*LOG(ZJ)/AJ
            S5=S5+WJ*ZJ**5/AJ*ALFA**4
   10    CONTINUE
         POTI=16.E-9*EXP(0.9*S2/S1)
      ENDIF
      Q(JPROB+9) = POTI
      Q(JPROB+10) = LOG(POTI)
C
      CON1=LOG(POTI/EMASS)
      CON2=DENS*S1
      CON3=1.+2.*LOG(POTI/(28.8E-9*SQRT(CON2)))
C
C             Condensed material ?
C             (at present that means: DENS.GT.0.05 g/cm**3)
C
      IF(DENS.GT.0.05)THEN
         IF(POTI.LT.1.E-7)THEN
            IF(CON3.LT.3.681)THEN
               CON4=0.2
            ELSE
               CON4=0.326*CON3-1.
            ENDIF
            CON5=2.
         ELSE
            IF(CON3.LT.5.215)THEN
               CON4=0.2
            ELSE
               CON4=0.326*CON3-1.5
            ENDIF
            CON5=3.
         ENDIF
      ELSE
C
C             Gas (T=0 C, P= 1 ATM)
C             if T.NE. 0 C and/or P.NE. 1 ATM
C             you have to modify the variable X
C             X=>X+0.5*LOG((273+T C)/(273*P ATM))
C             in the function GDRELE
C             ------------------------
C
         IF(CON3.LE.12.25)THEN
            IP=INT((CON3-10.)/0.5)+1
            IF(IP.LT.0) IP=0
            IF(IP.GT.4) IP=4
            CON4=1.6+0.1*FLOAT(IP)
            CON5=4.
         ELSE
            IF(CON3.LE.13.804)THEN
               CON4=2.
               CON5=5.
            ELSE
               CON4=0.326*CON3-2.5
               CON5=5.
            ENDIF
         ENDIF
      ENDIF
C
      XA=CON3/4.606
      CON6=4.606*(XA-CON4)/(CON5-CON4)**3.
      Q(JPROB+11)=CON1
      Q(JPROB+12)=CON2
      Q(JPROB+13)=-CON3
      Q(JPROB+14)=CON4
      Q(JPROB+15)=CON5
      Q(JPROB+16)=CON6
C
C            constant for delta rays
C            (the same constant is used in the Compton
C              and Annihilation subroutines )
C            and for one-photon annihilation
C
      Q(JPROB+17)=AVO*TWOPI*REL*REL*DENS*S1
      Q(JPROB+18)=AVO*TWOPI*REL*REL*DENS*S5
C
C            Constants for Moliere scattering
C
      IF(JMIXT.LE.0)THEN
         CALL GMOLI(A,Z,1.,1,DENS,Q(JPROB+21),Q(JPROB+25))
      ELSE
         CALL GMOLI(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +              NLM,DENS,Q(JPROB+21),Q(JPROB+25))
      ENDIF
C
C                Constants for muon bremsstrahlung
C
      Q(JPROB+31)=LOG(189.*EMMU/(EMASS*C1))
      IF(Z.GT.10)Q(JPROB+31)=Q(JPROB+31)+LOG(0.666666/C1)
      SE         =SQRT(2.71828)
      Q(JPROB+32)=189.*SE*EMMU*EMMU/(2.*EMASS*C1)
      Q(JPROB+33)=0.75*SE*EMMU*C1
C
  999 CONTINUE
      END
+DECK,GPRSGA
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GPRSGA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for photon pair production and muon direct pair production.   *
C.    *                                                                *
C     *  semiempirical cross section formula of L.Urban is used        *
C     *  to estimate the photon mean free path in a given material     *
C     *            (see WRITEUP)                                       *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, G.Patrick, L.Urban  *********         *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCONSP
+SEQ,GCTRAK
+SEQ,GCMATE
+SEQ,GCJLOC
+SEQ,GCMULO
+SEQ,GCCUTS
C.
C.    ------------------------------------------------------------------
C.
C======>     A, Pair production by photons
C               ==========================
C               Cut on threshold kinetic energy. Special case for vacuum
C
      SST=0.
      IF(Z.LT.1.)GO TO 90
      EGAM   = ELOW(IEKBIN)
      IF (EGAM.LT.0.00099) GO TO 90
      IF (EGAM.LT.0.00199) EGAM=0.0014
C
      JPROB=LQ(JMA-4)
      IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
          SST=GPRSGG(Z,EGAM)/A
      ELSE
C
C             compound or mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         DO 10 I=1,NLM
            II=JMIXT+NLM+I
            AA=Q(II-NLM)
            ZZ=Q(II)
            W=Q(II+NLM)
            SST=SST+W*GPRSGG(ZZ,EGAM)/AA
  10     CONTINUE
      ENDIF
C
      SST=AVO*DENS*SST
C
  90  IF(SST.GT.0.)THEN
         Q(JPAIR+IEKBIN)=1./SST
      ELSE
         Q(JPAIR+IEKBIN)=BIG
      ENDIF
C
C======>     B, Direct pair production by muons
C               ===============================
C
      SST=0.
      IF(Z.LT.1.)GO TO 190
      T=ELOW(IEKBIN)
      IF(T.LT.1.)GO TO 190
      IF(T.LE.PPCUTM)GO TO 190
      IF(JMIXT.EQ.0)THEN
C
C            Element
C
         SST=GPRSGM(Z,T,PPCUTM)
         SST=SST/A
      ELSE
C
C            Compound/Mixture
C
         NLMAT=Q(JMA+11)
         NLM  =IABS(NLMAT)
         SST  =0.
         DO 110 I=1,NLM
            II   = JMIXT+NLM+I
            AA   = Q(II-NLM)
            ZZ   = Q(II)
            WMAT = Q(II+NLM)
            SST  = SST+WMAT*GPRSGM(ZZ,T,PPCUTM)/AA
 110     CONTINUE
      ENDIF
      SST=AVO*DENS*SST
C
 190  IF(SST.GT.0.)THEN
         Q(JPAIR+IEKBIN+NEK1)=1./SST
      ELSE
         Q(JPAIR+IEKBIN+NEK1)=BIG
      ENDIF
C
      END
+DECK,GPRSGG
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      FUNCTION GPRSGG(Z,E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  To calculate cross-section for e+e- production                *
C.    *  by photons (in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GPRSGA                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
      DIMENSION C(18),CC(3)
      DATA C/ 0.87842E-3,-0.19625E-2, 0.12949E-2,-0.20028E-3
     +      , 0.12575E-4,-0.28333E-6,-0.10342E-4, 0.17692E-4
     +      ,-0.82391E-5, 0.13063E-5,-0.90815E-7, 0.23586E-8
     +      ,-0.45263E-3, 0.11161E-2,-0.86749E-3, 0.21773E-3
     +      ,-0.20467E-4, 0.65372E-6/
C.
C.    ------------------------------------------------------------------
C.
      SIG=0.
      IF(E.LE.2.*EMASS)GO TO 90
      X=LOG(E/EMASS)
      DO 20 I=1,3
         CC(I)=0.
         D=1.
         DO 10 J=1,6
            JJ=6*I+J-6
            CC(I)=CC(I)+D*C(JJ)
            D=D*X
  10     CONTINUE
  20  CONTINUE
C
      SIG=Z*(Z+1.)*(CC(1)+CC(2)*Z+CC(3)/Z)
C
  90  IF(SIG.LT.0.)SIG=0.
      GPRSGG=SIG
      END
+DECK,GPRSGM
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      FUNCTION GPRSGM(Z,T,CCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To calculate cross-section in barn/atom for direct       *
C.    *       pair production by muons.                                *
C.    *                                                                *
C.    *    ==>Called by : GPRSGA                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
C
      PARAMETER (AKSI=1.16,ALFA=3.46,GAM=0.06,VS=0.019)
      PARAMETER (ECMIN=2.044E-3,CONMX=0.130653)
C        CONMX=0.75*SQRT(2.7182...)*EMMU
C
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      DATA C1/0.230181E-08,-0.280842E-08, 0.137525E-08,-0.156503E-09
     +      , 0.728088E-11,-0.122631E-12, 0.133014E-08,-0.160591E-09
     +      ,-0.390814E-09, 0.314492E-10, 0.251296E-12,-0.574223E-13
     +      , 0.604923E-09,-0.560766E-09, 0.660253E-09,-0.103474E-09
     +      , 0.621338E-11,-0.135273E-12, 0.103739E-09, 0.710290E-09
     +      ,-0.544755E-10,-0.211241E-11, 0.286443E-12,-0.644602E-14
     +      , 0.332492E-09,-0.484785E-10, 0.126921E-10,-0.165217E-11
     +      , 0.845273E-13,-0.143180E-14,-0.112267E-13, 0.113308E-11
     +      , 0.292577E-12,-0.733441E-13, 0.475747E-14,-0.976279E-16
     +      ,-0.112856E-07, 0.936398E-08,-0.291882E-08, 0.422266E-09
     +      ,-0.279042E-10, 0.678485E-12, 0.112383E-07,-0.964400E-08
     +      , 0.313121E-08,-0.440224E-09, 0.278668E-10,-0.643012E-12
     +      ,-0.414131E-08, 0.355112E-08,-0.115035E-08, 0.158539E-09
     +      ,-0.976788E-11, 0.216911E-12, 0.521380E-09,-0.442265E-09
     +      , 0.141753E-09,-0.190826E-10, 0.114038E-11,-0.242085E-13/
      DATA C2/0.572943E-10,-0.296824E-10, 0.630217E-11,-0.623179E-12
     +      , 0.211467E-13,-0.143579E-10,-0.137247E-11, 0.118670E-11
     +      ,-0.793091E-13, 0.124745E-14,-0.269884E-10, 0.125314E-10
     +      ,-0.239259E-11, 0.181151E-12,-0.470277E-14,-0.342454E-11
     +      , 0.976666E-12,-0.236792E-12, 0.213290E-13,-0.607799E-15
     +      ,-0.748844E-12, 0.178214E-12,-0.226827E-13, 0.148441E-14
     +      ,-0.367972E-16, 0.840330E-12, 0.820025E-11,-0.294797E-11
     +      , 0.294669E-12,-0.970294E-14,-0.830636E-12,-0.309273E-11
     +      , 0.124169E-11,-0.135879E-12, 0.481683E-14, 0.438223E-12
     +      , 0.259162E-12,-0.149284E-12, 0.180170E-13,-0.677948E-15/
C.
C.    ------------------------------------------------------------------
C.
      GPRSGM=0.
      CUT=CCUT
      IF(CUT.LT.ECMIN) CUT=ECMIN
C
      E=T+EMMU
      ECMAX=E-CONMX*Z**0.333333
      IF(CUT.GE.ECMAX) GOTO 99
C
      X=LOG(E/EMMU)
      Y=LOG(CUT/(VS*E))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
        YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
C     DE/DX SHOULD BE MONOTON INCREASING AS A
C     FUNCTION OF THE CUT
C     SOLUTION: LIN. INTERPOLATION FOR 0.2*ECMAX<CUT<ECMAX
C
      FAC=2.*(LOG(ECMAX/CUT))**ALFA
      FAC=Z*(Z+AKSI*(1.+GAM*LOG(Z)))*FAC
      GPRSGM=FAC*S
C
  99  RETURN
      END
+DECK,GRANGI
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GRANGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the stopping range , in cm.                        *
C.    *     (i.e. the maximum step due to the continuous energy loss)  *
C.    *      The stopping range is the integral of the inverse of the  *
C.    *      DE/DX table.                                              *
C.    *     There are 4 tables : electron,positron,muon,proton         *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author      M.Maire   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCJLOC
+SEQ,GCMULO
+SEQ,GCONSP
+SEQ,GCMATE
+SELF, IF=-SINGLE
      DOUBLE PRECISION RANGMU, RANGEL, RANGPO, RANGPR
      DOUBLE PRECISION DDXEL1, DDXMU1, DDXPR1, DDXPO1
      DOUBLE PRECISION DDXEL2, DDXMU2, DDXPR2, DDXPO2
      DOUBLE PRECISION DDXEL3, DDXMU3, DDXPR3, DDXPO3
      DOUBLE PRECISION HFACT, ONE, TEN, HLOG10, HFACT2, HFACT3
+SELF.
      PARAMETER (ONE=1,TEN=10)
*
      HLOG10 = LOG(TEN)
*
      JRANEL = LQ(JMA-15)
      JRANPO = LQ(JMA-15)+NEK1
      JRANMU = LQ(JMA-16)
      JRANPR = LQ(JMA-16)+NEK1
*
      IF(Z.LT.1) THEN
         DO 10  IEKBIN=1,NEK1
            Q(JRANEL+IEKBIN)=BIG
            Q(JRANPO+IEKBIN)=BIG
            Q(JRANMU+IEKBIN)=BIG
            Q(JRANPR+IEKBIN)=BIG
   10    CONTINUE
*
      ELSE
         SMALL = 1./BIG
         JLOSEL = LQ(JMA-1)
         JLOSPO = LQ(JMA-1)+NEK1
         JLOSMU = LQ(JMA-2)
         JLOSPR = LQ(JMA-3)
*
         JWSPEL =         -1
         JWSPPO = NEKBIN  -1
         JWSPMU = NEKBIN*2-1
         JWSPPR = NEKBIN*3-1
*
         RANGPO = 0.
         RANGMU = 0.
         RANGEL = 0.
         RANGPR = 0.
*
         Q(JRANEL+1)=0.
         Q(JRANPO+1)=0.
         Q(JRANMU+1)=0.
         Q(JRANPR+1)=0.
*
         HFACT = ONE/(6.*GEKA)
*
         DDXEL3 = ELOW(1)*HLOG10/MAX(Q(JLOSEL+1),SMALL)
         DDXMU3 = ELOW(1)*HLOG10/MAX(Q(JLOSMU+1),SMALL)
         DDXPR3 = ELOW(1)*HLOG10/MAX(Q(JLOSPR+1),SMALL)
         DDXPO3 = ELOW(1)*HLOG10/MAX(Q(JLOSPO+1),SMALL)
*
         HFACT2 = HLOG10*TEN**(EKBIN(1)+0.5/GEKA)
*
         DO 20 IEKBIN=2,NEK1
*
            HFACT3 = ELOW(IEKBIN)*HLOG10
*
* *** Electrons
*
            DDXEL1 = DDXEL3
            DDXEL3 = HFACT3/MAX(Q(JLOSEL+IEKBIN),SMALL)
            DDXEL2 = HFACT2/MAX(WS(JWSPEL+IEKBIN),SMALL)
            RANGEL = RANGEL+DDXEL1+4.*DDXEL2+DDXEL3
            Q(JRANEL+IEKBIN)=RANGEL*HFACT
*
* *** Positons
*
            DDXPO1 = DDXPO3
            DDXPO3 = HFACT3/MAX(Q(JLOSPO+IEKBIN),SMALL)
            DDXPO2 = HFACT2/MAX(WS(JWSPPO+IEKBIN),SMALL)
            RANGPO = RANGPO+DDXPO1+4.*DDXPO2+DDXPO3
            Q(JRANPO+IEKBIN)=RANGPO*HFACT
*
* *** Muons
*
            DDXMU1 = DDXMU3
            DDXMU3 = HFACT3/MAX(Q(JLOSMU+IEKBIN),SMALL)
            DDXMU2 = HFACT2/MAX(WS(JWSPMU+IEKBIN),SMALL)
            RANGMU = RANGMU+DDXMU1+4.*DDXMU2+DDXMU3
            Q(JRANMU+IEKBIN)=RANGMU*HFACT
*
* *** Protons
*
            DDXPR1 = DDXPR3
            DDXPR3 = HFACT3/MAX(Q(JLOSPR+IEKBIN),SMALL)
            DDXPR2 = HFACT2/MAX(WS(JWSPPR+IEKBIN),SMALL)
            RANGPR = RANGPR+DDXPR1+4.*DDXPR2+DDXPR3
            Q(JRANPR+IEKBIN)=RANGPR*HFACT
*
            HFACT2 = HLOG10*TEN**(EKBIN(1)+(IEKBIN-0.5)/GEKA)
*
   20    CONTINUE
      ENDIF
*
      END
+DECK,GRANGI1,IF=NEVER.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GRANGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the stopping range , in cm.                        *
C.    *     (i.e. the maximum step due to the continuous energy loss)  *
C.    *      The stopping range is the integral of the inverse of the  *
C.    *      DE/DX table.                                              *
C.    *     There are 4 tables : electron,positron,muon,proton         *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author      M.Maire   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCJLOC
+SEQ,GCMULO
+SEQ,GCONSP
+SEQ,GCMATE
*
      DO 50 IEKBIN=1,NEK1
*
* *** Electrons
*
         JLOSS = LQ(JMA-1)
         JRANG = LQ(JMA-15)
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
*
* *** Positons
*
         JLOSS = LQ(JMA-1) + NEK1
         JRANG = LQ(JMA-15) + NEK1
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
*
* *** Muons
*
         JLOSS = LQ(JMA-2)
         JRANG = LQ(JMA-16)
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
*
* *** Protons
*
         JLOSS = LQ(JMA-3)
         JRANG = LQ(JMA-16) + NEK1
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
   50 CONTINUE
*
      END
+DECK,GRAYL
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GRAYL
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates COHERENT SCATTERING mechanism                       *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Author    G.Tromba, P.Bregant                             *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCPHYS
+SEQ,GCONSP
+SEQ,GCKING
+SEQ,GCJLOC
+SEQ,GCMULO
      DIMENSION VROT(3)
      DIMENSION RNDM(2)
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(25)
      NGKINE=0
*
      IMAX=NEKBIN
      DO 2 I=2,NEK1
         IF (Q(JRAYL+I).GT.0.9*BIG) THEN
            IMAX = I-1
            GO TO 2
         ENDIF
   2  CONTINUE
C
C             Extract a value for the momentum transfer according
C             with the FORM FACTORS distribution.
C
      IF (IEKBIN.LT.IMAX) THEN
        GEKRT1=1.-GEKRAT
        A2MAX=GEKRT1*Q(JRAYL+NEK1+IEKBIN)+GEKRAT*Q(JRAYL+NEK1+IEKBIN+1)
      ELSE
        A2MAX=Q(JRAYL+NEK1+IEKBIN)
      ENDIF
      GEKIN1=1./GEKIN
   5  CALL GRNDM(RNDM,2)
      A2=RNDM(1)*A2MAX
      DO 10 I=1,(IMAX-1)
         IF (A2.LE.Q(JRAYL+I+NEK1)) THEN
            IE=I
            GO TO 20
         ENDIF
10    CONTINUE
      IE=IMAX
20    IF (IE.GT.1) THEN
        GA2RAT =(A2-Q(JRAYL+NEK1+IE-1))/(Q(JRAYL+NEK1+IE)
     +          -Q(JRAYL+NEK1+IE-1))
        QNEW   = ELOW(IE-1)*(1.-GA2RAT)+ELOW(IE)*GA2RAT
      ELSE
        GA2RAT  = A2/Q(JRAYL+NEK1+IE)
        QNEW    = ELOW(IE)*GA2RAT
      ENDIF
C
C            Find out cos(theta)
      COSTH=1.-0.5*(QNEW*GEKIN1)**2
      IF(RNDM(2).GT.0.5*(1.+COSTH**2)) GO TO 5
      SINTH=SQRT((1.-COSTH)*(1.+COSTH))
C
C            Extract PH  (PHI unif. between 0 and 2PI)
      CALL GRNDM(RNDM,2)
      PH=RNDM(1)*TWOPI
      COSPH=COS(PH)
      SINPH=SIN(PH)
C
C            Set new VECT(I), i=4,5,6
      VROT(1)=GEKIN*SINTH*COSPH
      VROT(2)=GEKIN*SINTH*SINPH
      VROT(3)=GEKIN*COSTH
C
C             Rotate scattered photon into GEANT system
C
      CALL GDROT(VROT,COSTH,SINTH,COSPH,SINPH)
 
      VMROT=1./SQRT(VROT(1)*VROT(1)+VROT(2)*VROT(2)+VROT(3)*VROT(3))
      VECT(4)=VROT(1)*VMROT
      VECT(5)=VROT(2)*VMROT
      VECT(6)=VROT(3)*VMROT
C
C            Update probabilities
C
*
      ZINTRA=-LOG(RNDM(2))
      SLRAYL=SLENG
      STEPRA=BIG
*
C
      END
 
+DECK,GRAYLI
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GRAYLI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section of current material for RAYLEIGH     *
C.    *  EFFECT using  polinomial fits of tables in log-log scale.     *
C.    *  One fit (4 coefficients) for each element is used.            *
C.    *  Atomic form factors are calculated as a function of momentum  *
C.    *  transfer using polinomial fits of data tables in log-log scale*
C.    *  One or two fits are used according with the value of NFIT.    *
C.    *  Evaluates the integral of atomic form factors which will be   *
C.    *  used in the SUBROUTINE GRAYL to sample scattering angles      *
C.    *  NOTE:                                                         *
C.    *  (1) Above 10 MeV a cut is imposed as the contribution of      *
C.    *  Rayleigh effect is negligible                                 *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    G.Tromba (*), P.Bregant (**)                   *
C.    *                                                                *
C.    *  (*) now at: Sincrotrone Trieste, Padriciano 99, Trieste (I)   *
C.    *  (**)U.S.L. n.1 Triestina                                      *
C.    *      Servizio di Fisica Sanitaria, v.Pieta' 19, 34129 Trieste  *
C     *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCONSP
+SEQ,GCMATE
+SEQ,GCJLOC
+SEQ,GCMULO
      DIMENSION COHER(4,100),CFORM(8,100),ELIM(100)
*
      DATA((COHER(I,J),I=1,4),J=1,20)/-12.646,-1.9734,.13417,.23998E-01
     +,-10.303,-1.9553,0.15913,0.29927E-01
     +,-9.1274,-2.0474,0.87874E-01,0.23572E-01
     +,-8.3066,-2.0615,0.46623E-01,0.18455E-01
     +,-7.6967,-2.0684,0.24280E-01,0.15622E-01
     +,-7.2088,-2.0633,0.15713E-01,0.14402E-01
     +,-6.8026,-2.0574,0.16437E-01,0.14518E-01
     +,-6.4403,-2.0449,0.18975E-01,0.14716E-01
     +,-6.1099,-2.0390,0.21207E-01,0.15081E-01
     +,-5.7930,-2.0384,0.19210E-01,0.14989E-01
     +,-5.5410,-2.0430,0.20118E-01,0.15698E-01
     +,-5.3138,-2.0399,0.21325E-01,0.16074E-01
     +,-5.0993,-2.0395,0.19494E-01,0.16046E-01
     +,-4.9005,-2.0397,0.17404E-01,0.15937E-01
     +,-4.7149,-2.0394,0.15412E-01,0.15788E-01
     +,-4.5420,-2.0393,0.13945E-01,0.15704E-01
     +,-4.3846,-2.0372,0.14551E-01,0.15848E-01
     +,-4.2381,-2.0316,0.16322E-01,0.16051E-01
     +,-4.1023,-2.0249,0.17752E-01,0.16300E-01
     +,-3.9704,-2.0187,0.17285E-01,0.16217E-01/
      DATA ((COHER(I,J),I=1,4),J=21,40)/-3.8342,-2.0137,.014534,.015744
     +,-3.7014,-2.0118,0.10973E-01,0.15228E-01
     +,-3.5759,-2.0127,0.80253E-02,0.14884E-01
     +,-3.4584,-2.0121,0.70340E-02,0.14731E-01
     +,-3.3494,-2.0101,0.66838E-02,0.14731E-01
     +,-3.2392,-2.0074,0.57007E-02,0.14562E-01
     +,-3.1309,-2.0050,0.41822E-02,0.14312E-01
     +,-3.0235,-2.0049,0.19877E-02,0.14052E-01
     +,-2.9211,-2.0071,0.85036E-03,0.13970E-01
     +,-2.8192,-2.0069,-0.14296E-02,0.13732E-01
     +,-2.7265,-2.0088,-0.26683E-02,0.13717E-01
     +,-2.6378,-2.0095,-0.34226E-02,0.13727E-01
     +,-2.5496,-2.0094,-0.62157E-02,0.13425E-01
     +,-2.4704,-2.0092,-0.43550E-02,0.13753E-01
     +,-2.3900,-2.0083,-0.48368E-02,0.13730E-01
     +,-2.3111,-2.0072,-0.55407E-02,0.13668E-01
     +,-2.2355,-2.0065,-0.61290E-02,0.13697E-01
     +,-2.1614,-2.0064,-0.70329E-02,0.13672E-01
     +,-2.0899,-2.0060,-0.78982E-02,0.13612E-01
     +,-2.0203,-2.0057,-0.85764E-02,0.13570E-01/
      DATA((COHER(I,J),I=1,4),J=41,60)/-1.9519,-2.0049,-.0091079,.013506
     +,-1.8851,-2.0036,-0.94870E-02,0.13472E-01
     +,-1.8210,-2.0019,-0.10066E-01,0.13410E-01
     +,-1.7554,-2.0007,-0.11089E-01,0.13247E-01
     +,-1.6914,-1.9990,-0.11844E-01,0.13139E-01
     +,-1.6279,-1.9984,-0.12922E-01,0.12987E-01
     +,-1.5659,-1.9980,-0.13635E-01,0.12948E-01
     +,-1.5073,-1.9977,-0.14136E-01,0.12937E-01
     +,-1.4501,-1.9959,-0.14206E-01,0.12957E-01
     +,-1.3942,-1.9943,-0.14863E-01,0.12876E-01
     +,-1.3378,-1.9916,-0.15680E-01,0.12738E-01
     +,-1.2820,-1.9881,-0.16880E-01,0.12511E-01
     +,-1.2231,-1.9861,-0.18942E-01,0.12204E-01
     +,-1.1658,-1.9850,-0.21146E-01,0.11896E-01
     +,-1.1112,-1.9864,-0.22968E-01,0.11769E-01
     +,-1.0594,-1.9877,-0.24247E-01,0.11707E-01
     +,-1.0104,-1.9895,-0.24993E-01,0.11718E-01
     +,-0.96289,-1.9905,-0.25026E-01,0.11788E-01
     +,-0.91458,-1.9909,-0.25128E-01,0.11807E-01
     +,-0.86838,-1.9909,-0.25111E-01,0.11847E-01/
      DATA ((COHER(I,J),I=1,4),J=61,80)/-.82136,-1.9903,-.025340,.011835
     +,-0.77441,-1.9864,-0.26074E-01,0.11635E-01
     +,-0.72869,-1.9885,-0.26020E-01,0.11761E-01
     +,-0.68337,-1.9878,-0.26532E-01,0.11712E-01
     +,-0.63683,-1.9871,-0.26966E-01,0.11650E-01
     +,-0.59154,-1.9867,-0.27440E-01,0.11604E-01
     +,-0.54758,-1.9862,-0.27986E-01,0.11561E-01
     +,-0.50282,-1.9861,-0.28229E-01,0.11547E-01
     +,-0.45943,-1.9858,-0.28501E-01,0.11535E-01
     +,-0.41677,-1.9856,-0.28696E-01,0.11540E-01
     +,-0.37528,-1.9853,-0.29045E-01,0.11529E-01
     +,-0.33450,-1.9843,-0.29095E-01,0.11545E-01
     +,-0.29346,-1.9834,-0.29469E-01,0.11511E-01
     +,-0.25286,-1.9823,-0.29847E-01,0.11469E-01
     +,-0.21251,-1.9810,-0.30285E-01,0.11412E-01
     +,-0.17200,-1.9801,-0.30821E-01,0.11368E-01
     +,-0.13190,-1.9789,-0.31515E-01,0.11257E-01
     +,-0.92060E-01,-1.9781,-0.32135E-01,0.11179E-01
     +,-0.52955E-01,-1.9775,-0.32687E-01,0.11125E-01
     +,-0.14708E-01,-1.9770,-0.33185E-01,0.11092E-01/
      DATA((COHER(I,J),I=1,4),J=81,100)/.022864,-1.9751,-.033545,.011037
     +,0.60152E-01,-1.9764,-0.33897E-01,0.11092E-01
     +,0.96158E-01,-1.9760,-0.34169E-01,0.11099E-01
     +,0.13251,-1.9753,-0.34520E-01,0.11085E-01
     +,0.16833,-1.9747,-0.34818E-01,0.11081E-01
     +,0.20362,-1.9740,-0.35032E-01,0.11086E-01
     +,0.23778,-1.9734,-0.34984E-01,0.11155E-01
     +,0.27280,-1.9725,-0.35314E-01,0.11153E-01
     +,0.30673,-1.9718,-0.35308E-01,0.11229E-01
     +,0.34031,-1.9706,-0.35518E-01,0.11187E-01
     +,0.37415,-1.9695,-0.35653E-01,0.11175E-01
     +,0.40755,-1.9670,-0.34285E-01,0.11389E-01
     +,0.44086,-1.9671,-0.35957E-01,0.11154E-01
     +,0.47375,-1.9661,-0.36059E-01,0.11145E-01
     +,0.50582,-1.9648,-0.36048E-01,0.11154E-01
     +,0.53772,-1.9635,-0.36237E-01,0.11140E-01
     +,0.56929,-1.9622,-0.36256E-01,0.11141E-01
     +,0.60044,-1.9608,-0.36340E-01,0.11134E-01
     +,0.63122,-1.9596,-0.36313E-01,0.11138E-01
     +,0.66162,-1.9582,-0.36298E-01,0.11141E-01/
*
      DATA ELIM/3*0.,3*0.13569E-04,3*0.14408E-04,3*0.15299E-04
     +,3*0.21928E-04,3*0.27876E-04,3*0.35437E-04,3*0.45049E-04
     +,3*0.50793E-04,3*0.53934E-04,3*0.57269E-04,3*0.60810E-04
     +,3*0.68563E-04,3*0.77305E-04,3*0.87161E-04,3*0.98274E-04
     +,3* 0.11080E-03,3*0.11765E-03,3*0.12493E-03,3*0.13266E-03
     +,3*0.14086E-03,3*0.15882E-03,3* 0.16864E-03,3*0.19014E-03
     +,3*0.21438E-03,3*0.22764E-03,2*0.24171E-03,3*0.27253E-03
     +,4*0.28938E-03,3*0.3072E-03,10*0./
*
      DATA((CFORM(I,J),I=1,8),J=1,10)/-22.516,-5.1310,-.90555,-.055778
     +,0.11875,0.36659E-01,0.39279E-02,0.14494E-03
     +,-19.260,-4.6034,-0.60480,-0.86935E-01
     +,0.75207E-01,0.29358E-01,0.35640E-02,0.14448E-03
     +,-16.745,-2.9900,-0.34216E-01,-0.22543
     +,-0.29032E-01,0.11312E-01,0.24065E-02,0.12420E-03
     +,-17.780,-7.8538,-1.1320,-0.56378E-01
     +,-16.730,-4.1304,0.18327,0.63285E-01
     +,-5.7128,-1.8620,-0.14825,-0.39071E-02
     +,-15.923,-4.1463,0.24609,0.83958E-01
     +,6.1359,4.3284,0.91725,0.55486E-01
     +,-15.224,-4.1486,0.28574,0.99104E-01
     +,7.9239,5.4239,1.1417,0.69696E-01
     +,-14.548,-4.1850,0.26729,0.10343
     +,5.6813,4.4241,1.0125,0.64574E-01
     +,-13.948,-4.2241,0.23705,0.10507
     +,-0.73602,1.2353,0.51040,0.38876E-01
     +,-13.380,-4.3238,0.15807,0.98704E-01
     +,-4.5122,-0.69749,0.20317,0.23107E-01
     +,-12.880,-4.3645,0.11149,0.96212E-01/
      DATA((CFORM(I,J),I=1,8),J=11,20)/-12.894,-5.1262,-0.54343,-.017585
     +,-12.442,-4.4181,0.64564E-01,0.93785E-01
     +,-18.182,-7.9979,-1.0369,-0.44947E-01
     +,-11.961,-4.4932,-0.23538E-01,0.83167E-01
     +,-7.7002,-2.7396,-0.16988,0.17141E-02
     +,-11.655,-4.3468,0.67545E-01,0.10218
     +,-11.458,-4.8625,-0.54640,-0.19752E-01
     +,-11.288,-4.3645,0.31952E-01,0.10016
     +,-13.733,-6.1918,-0.78628,-0.33620E-01
     +,-10.866,-4.4125,-0.54747E-01,0.87723E-01
     +,-6.9281,-2.5933,-0.16486,0.11230E-02
     +,-10.716,-4.2771,0.63949E-01,0.11331
     +,-9.1472,-3.9093,-0.40549,-0.12939E-01
     +,-10.308,-4.3105,-0.26699E-01,0.98791E-01
     +,-10.558,-4.7765,-0.56625,-0.22421E-01
     +,-9.9972,-4.3437,-0.82898E-01,0.92124E-01
     +,-6.0983,-2.3464,-0.13404,0.24166E-02
     +,-10.027,-4.2552,0.73490E-01,0.13009
     +,-7.9984,-3.5151,-0.35363,-0.10654E-01
     +,-9.6508,-4.2506,-0.65510E-02,0.11484/
      DATA((CFORM(I,J),I=1,8),J=21,30)/-9.2121,-4.2776,-0.49730,-.019235
     +,-9.4905,-4.2588,0.32597E-02,0.12279
     +,-3.9128,-1.2033,0.75797E-01,0.14897E-01
     +,-9.3296,-4.1979,0.42817E-01,0.13360
     +,-5.1579,-1.9987,-0.76380E-01,0.56926E-02
     +,-9.0348,-4.1729,-0.43368E-02,0.12460
     +,-6.1115,-2.6115,-0.19286,-0.13208E-02
     +,-8.7478,-4.1599,-0.57064E-01,0.11511
     +,-4.5827,-1.7167,-0.21089E-01,0.91965E-02
     +,-8.6469,-4.1430,-0.21725E-01,0.12790
     +,-5.4795,-2.3056,-0.13495,0.22647E-02
     +,-8.4099,-4.1228,-0.55178E-01,0.12251
     +,-6.1802,-2.7722,-0.22505,-0.32066E-02
     +,-8.2279,-4.0934,-0.62350E-01,0.12269
     +,-5.8290,-2.5908,-0.19000,-0.10226E-02
     +,-8.0551,-4.0478,-0.60875E-01,0.12369
     +,-6.2227,-2.8633,-0.24196,-0.41418E-02
     +,-7.8068,-4.0203,-0.10682,0.11396
     +,-6.6260,-3.1507,-0.29866,-0.76188E-02
     +,-7.5763,-3.9966,-0.14839,0.10560/
      DATA((CFORM(I,J),I=1,8),J=31,40)/-5.8965,-2.7383,-.22009,-.0028149
     +,-7.5281,-3.9941,-0.10906,0.12081
     +,-6.2790,-3.0188,-0.27697,-0.63842E-02
     +,-7.3337,-3.9547,-0.13178,0.11541
     +,-6.5270,-3.2157,-0.31779,-0.89844E-02
     +,-7.1437,-3.9160,-0.15503,0.10982
     +,-6.6564,-3.3380,-0.34420,-0.10706E-01
     +,-6.9226,-3.8688,-0.19301,0.99252E-01
     +,-6.6676,-3.3866,-0.35637,-0.11562E-01
     +,-6.7647,-3.8417,-0.20928,0.96358E-01
     +,-6.5973,-3.3839,-0.35856,-0.11806E-01
     +,-6.5615,-3.7910,-0.24140,0.86548E-01
     +,-5.5223,-2.7503,-0.23696,-0.43562E-02
     +,-6.6156,-3.8232,-0.17222,0.11431
     +,-5.7577,-2.9413,-0.27766,-0.69923E-02
     +,-6.4351,-3.7636,-0.19273,0.10630
     +,-5.8988,-3.0704,-0.30602,-0.88735E-02
     +,-6.2520,-3.7107,-0.21873,0.97517E-01
     +,-5.1690,-2.6301,-0.21923,-0.34573E-02
     +,-6.2183,-3.7177,-0.18979,0.11175/
      DATA((CFORM(I,J),I=1,8),J=41,50)/-5.3652,-2.7941,-.25462,-.0057986
     +,-6.0669,-3.6847,-0.20939,0.10725
     +,-5.5028,-2.9182,-0.28166,-0.75863E-02
     +,-5.9625,-3.6681,-0.21256,0.10888
     +,-4.4716,-2.2542,-0.14575,0.11394E-02
     +,-5.9717,-3.7006,-0.17526,0.12848
     +,-4.6959,-2.4391,-0.18590,-0.15318E-02
     +,-5.8101,-3.6454,-0.19615,0.12040
     +,-4.8697,-2.5886,-0.21853,-0.36987E-02
     +,-5.6609,-3.6010,-0.21568,0.11417
     +,-4.3929,-2.2914,-0.15753,0.22346E-03
     +,-5.6585,-3.6429,-0.19093,0.13204
     +,-4.5695,-2.4433,-0.19070,-0.19681E-02
     +,-5.5414,-3.6051,-0.19872,0.12936
     +,-4.7029,-2.5655,-0.21777,-0.37707E-02
     +,-5.4029,-3.5513,-0.21291,0.12265
     +,-4.2616,-2.2896,-0.16092,-0.80603E-04
     +,-5.3622,-3.5694,-0.20212,0.13395
     +,-4.4165,-2.4282,-0.19184,-0.21565E-02
     +,-5.2567,-3.5409,-0.20978,0.13282/
      DATA((CFORM(I,J),I=1,8),J=51,60)/-4.5344,-2.5405,-.21724,-.0038729
     +,-5.1491,-3.5054,-0.21718,0.13045
     +,-3.6372,-1.9343,-0.88690E-01,0.46020E-02
     +,-5.0258,-3.4548,-0.22839,0.12463
     +,-3.8210,-2.0961,-0.12529,0.21101E-02
     +,-4.8945,-3.3989,-0.24271,0.11716
     +,-3.9712,-2.2334,-0.15661,-0.34134E-04
     +,-4.7735,-3.3522,-0.25562,0.11148
     +,-3.1689,-1.6776,-0.36233E-01,0.80485E-02
     +,-4.8172,-3.4334,-0.22782,0.13781
     +,-3.3490,-1.8398,-0.73631E-01,0.54743E-02
     +,-4.6932,-3.3773,-0.24060,0.13057
     +,-3.5038,-1.9826,-0.10676,0.31787E-02
     +,-4.5891,-3.3400,-0.25016,0.12742
     +,-3.6192,-2.0937,-0.13237,0.14104E-02
     +,-4.5112,-3.3248,-0.25437,0.12929
     +,-3.6974,-2.1750,-0.15093,0.13588E-03
     +,-4.4412,-3.3123,-0.25609,0.13194
     +,-3.7627,-2.2475,-0.16786,-0.10371E-02
     +,-4.3611,-3.2863,-0.25915,0.13169/
      DATA((CFORM(I,J),I=1,8),J=61,70)/-3.2202,-1.8724,-.086015,.0044765
     +,-4.3280,-3.3034,-0.25324,0.14193
     +,-3.3101,-1.9643,-0.10751,0.29785E-02
     +,-4.2204,-3.2500,-0.26236,0.13536
     +,-3.3804,-2.0408,-0.12547,0.17255E-02
     +,-4.1144,-3.1979,-0.27167,0.12901
     +,-2.9387,-1.7293,-0.56192E-01,0.64683E-02
     +,-4.1523,-3.3027,-0.26089,0.15874
     +,-3.0175,-1.8125,-0.75694E-01,0.51021E-02
     +,-4.0626,-3.2616,-0.26653,0.15504
     +,-3.0862,-1.8882,-0.93679E-01,0.38370E-02
     +,-3.9705,-3.2160,-0.27238,0.15031
     +,-3.1456,-1.9572,-0.11034,0.26582E-02
     +,-3.8761,-3.1664,-0.27856,0.14462
     +,-3.1764,-2.0014,-0.12079,0.19291E-02
     +,-3.7797,-3.1138,-0.28517,0.13823
     +,-3.2001,-2.0409,-0.13038,0.12518E-02
     +,-3.6830,-3.0606,-0.29220,0.13166
     +,-2.3527,-1.3953,0.18353E-01,0.11661E-01
     +,-3.7196,-3.1764,-0.28985,0.16452/
      DATA((CFORM(I,J),I=1,8),J=71,80)/-2.4343,-1.4853,-.0039059,.010053
     +,-3.6407,-3.1393,-0.29399,0.16168
     +,-2.5051,-1.5660,-0.23942E-01,0.86019E-02
     +,-3.5604,-3.0986,-0.29802,0.15798
     +,-1.8482,-1.0335,0.10459,0.17905E-01
     +,-3.5085,-3.1017,-0.30378,0.16493
     +,-1.9235,-1.1237,0.81217E-01,0.16159E-01
     +,-3.4387,-3.0742,-0.30789,0.16440
     +,-1.9968,-1.2113,0.58623E-01,0.14477E-01
     +,-3.3686,-3.0445,-0.31168,0.16331
     +,-1.5319,-0.79915,0.16481,0.22511E-01
     +,-3.2798,-2.9781,-0.31121,0.15278
     +,-1.5451,-0.83937,0.15298,0.21567E-01
     +,-3.2138,-2.9536,-0.31574,0.15312
     +,-1.5881,-0.90618,0.13445,0.20123E-01
     +,-3.1480,-2.9280,-0.31999,0.15319
     +,-1.6449,-0.98427,0.11327,0.18495E-01
     +,-3.0827,-2.9016,-0.32395,0.15299
     +,-1.7060,-1.0648,0.91680E-01,0.16851E-01
     +,-3.0177,-2.8739,-0.32760,0.15248/
      DATA((CFORM(I,J),I=1,8),J=81,90)/-1.4063,-0.78702,.16611,.02263
     +,-2.9358,-2.8086,-0.32466,0.14168
     +,-1.3849,-0.79373,0.16298,0.22357E-01
     +,-2.8720,-2.7814,-0.32852,0.14138
     +,-1.4038,-0.84050,0.14911,0.21248E-01
     +,-2.8081,-2.7526,-0.33199,0.14064
     +,-1.3918,-0.84924,0.14659,0.21073E-01
     +,-2.7440,-2.7219,-0.33502,0.13940
     +,-1.3620,-0.84008,0.14882,0.21263E-01
     +,-2.6798,-2.6896,-0.33763,0.13770
     +,-1.3138,-0.81488,0.15492,0.21729E-01
     +,-2.6153,-2.6552,-0.33976,0.13541
     +,-1.2903,-0.81842,0.15271,0.21530E-01
     +,-2.5504,-2.6186,-0.34144,0.13254
     +,-1.2999,-0.85623,0.14107,0.20590E-01
     +,-2.5124,-2.6461,-0.35864,0.14864
     +,-1.3280,-0.91171,0.12477,0.19289E-01
     +,-2.4543,-2.6213,-0.36244,0.14915
     +,-1.3618,-0.97145,0.10751,0.17921E-01
     +,-2.3971,-2.5968,-0.36603,0.14969/
      DATA((CFORM(I,J),I=1,8),J=91,100)/-2.1137,-2.5390,-0.89964,-.12482
     +, 0.77611E-01,0.30619E-01,0.38767E-02,0.16722E-03
     +,-2.0552,-2.4989,-0.89176,-0.12773
     +, 0.76385E-01,0.30504E-01,0.38795E-02,0.16780E-03
     +,-2.0034,-2.4634,-0.88113,-0.12883
     +, 0.75109E-01,0.30234E-01,0.38560E-02,0.16706E-03
     +,-1.9472,-2.4095,-0.85679,-0.12888
     +,0.72058E-01,0.29358E-01,0.37583E-02,0.16315E-03
     +,-1.8812,-2.3376,-0.82622,-0.13040
     +,0.67863E-01,0.28260E-01,0.36427E-02,0.15873E-03
     +,-1.8109,-2.2711,-0.80769,-0.13494
     +,0.64860E-01,0.27749E-01,0.36090E-02,0.15806E-03
     +,-1.7501,-2.2381,-0.81389,-0.14124
     +,0.65086E-01,0.28325E-01,0.37071E-02,0.16301E-03
     +,-1.7117,-2.2507,-0.84168,-0.14592
     +,0.68718E-01,0.29785E-01,0.38979E-02,0.17149E-03
     +,-1.6921,-2.2819,-0.86677,-0.14607
     +,0.72800E-01,0.31032E-01,0.40423E-02,0.17744E-03
     +,-1.3289,-1.3553,-0.20094,-0.91459E-01
     +,-0.17322E-01,-0.97804E-03,0.,0./
*
C.    ------------------------------------------------------------------
C
      SIG = 0.
      IF(JRAYL.LE.0) GO TO 99
      ELOW2 = ELOW(IEKBIN)
      IF (Z.LT.1.0.OR.ELOW2.GT.0.001) GO TO 20
      ALOGQ2 = LOG(ELOW2*1000.)
      IF(IEKBIN.GT.1) THEN
        ELOW1 = ELOW(IEKBIN-1)
        ALOGQ1 = LOG(ELOW1*1000.)
      ELSE
        ELOW1 = 0.
        ALOGQ1 = 0.
      ENDIF
      IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
         IZ=INT(Z)
         JRAYL=LQ(JMA-13)
         SIG=EXP(((COHER(4,IZ) *ALOGQ2+
     +             COHER(3,IZ))*ALOGQ2+
     +             COHER(2,IZ))*ALOGQ2+
     +             COHER(1,IZ))*AVO*DENS/A
         IF(IEKBIN.NE.1) THEN
C
C*    Use one or two functions to fit form factors
            IF (ELIM(IZ).EQ.0.) THEN
               FUN1 = (EXP(((((((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))*ALOGQ1+
     +                    CFORM(4,IZ))*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                FUN2=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
            ELSE
                IF (ELOW1.LE.ELIM(IZ)) THEN
                    FUN1=(EXP(((CFORM(4,IZ)*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                ELSE
                    FUN1=(EXP(((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))**2)*2.*ELOW1
                ENDIF
               IF (ELOW2.LE.ELIM(IZ)) THEN
                    FUN2=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                ELSE
                    FUN2=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2.*ELOW2
                ENDIF
            ENDIF
 
            Q(JRAYL+NEK1+IEKBIN)=Q(JRAYL+NEK1+IEKBIN-1)+
     +      0.5*(FUN2+FUN1)*(ELOW2-ELOW1)
         ELSE
            IF (ELIM(IZ).EQ.0.) THEN
                 FUN1=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
            ELSE
               IF (ELOW2.LE.ELIM(IZ)) THEN
                    FUN1=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                ELSE
                    FUN1=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2.*ELOW2
                ENDIF
                Q(JRAYL+NEK1+1)=Q(JRAYL+NEK1+1)+0.5*FUN1*ELOW2
            ENDIF
         ENDIF
      ELSE
C
C             compound/mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         SIG=0.
         IF(IEKBIN.NE.1) THEN
            HINT=0.
         ELSE
            Q(JRAYL+NEK1+1)=0.
         ENDIF
         DO 10 I=1,NLM
            J=JMIXT+I
            AA=Q(J)
            ZZ=Q(J+NLM)
            IZ=INT(ZZ)
            WMAT=Q(J+2*NLM)
            S=EXP(((COHER(4,IZ) *ALOGQ2+
     +                   COHER(3,IZ))*ALOGQ2+
     +                   COHER(2,IZ))*ALOGQ2+
     +                   COHER(1,IZ))
            S=S*WMAT/AA
            SIG=SIG+AVO*DENS*S
            IF(IEKBIN.NE.1) THEN
C
C*    Use one or two functions to fit form factors
            IF (ELIM(IZ).EQ.0.) THEN
                FUN1=(EXP(((((((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))*ALOGQ1+
     +                    CFORM(4,IZ))*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                FUN2=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
            ELSE
                IF (ELOW1.LE.ELIM(IZ)) THEN
                    FUN1=(EXP(((CFORM(4,IZ)*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                ELSE
                    FUN1=(EXP(((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))**2)*2.*ELOW1
                ENDIF
               IF (ELOW2.LE.ELIM(IZ)) THEN
                    FUN2=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                ELSE
                    FUN2=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2*ELOW2
                ENDIF
            ENDIF
               HINT=HINT+WMAT*0.5*(FUN2+FUN1)*(ELOW2-ELOW1)
*
            ELSE
               IF (ELIM(IZ).EQ.0.) THEN
                   FUN1=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
               ELSE
                  IF (ELOW2.LE.ELIM(IZ)) THEN
                      FUN1=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                  ELSE
                      FUN1=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2.*ELOW2
                  ENDIF
               ENDIF
               Q(JRAYL+NEK1+1)=Q(JRAYL+NEK1+1)+WMAT*0.5*FUN1*ELOW2
            ENDIF
   10    CONTINUE
         IF(IEKBIN.NE.1)
     +   Q(JRAYL+NEK1+IEKBIN)=Q(JRAYL+NEK1+IEKBIN-1)+HINT
      ENDIF
C
   20 IF(SIG.GT.0.)THEN
         Q(JRAYL+IEKBIN)=1./SIG
      ELSE
         Q(JRAYL+IEKBIN)=BIG
         Q(JRAYL+NEK1+IEKBIN)=0.
      ENDIF
C
  99  CONTINUE
      END
+DECK,GSHLIN.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSHLIN
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize atomic shells' potentials                     *
C.    *                                                                *
C.    * Potentials according to Rev.Mod.Phys. vol. 39 nr. 1 125 (1967) *
C.    * Xe upadetd according to Grishin et al. NIM A309, 476 (1991)    *
C.    *                                                                *
C.    *    ==>Called by : GPHINI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
C  Shells
c  See alse Handbook of Phys. & Chemistry
c
      IMPLICIT NONE
+CDE,GCPMXZ.
+CDE,GCSHPT.
      INTEGER NS,N1,NP,I
      REAL TMP
      DIMENSION NS(MAXSHL),N1(MAXELZ),NP(MAXELZ)
      DIMENSION TMP(LENGTH)
      DATA NS / 1,3*5,3*17,2*21,35,2*33,
     +          2*41,2*58,3*49,2*73,3*82 /
      DATA N1(  1),NP(  1) /    1,    1 /
      DATA TMP(   1) /  13.59811 /
      DATA N1(  2),NP(  2) /    2,    1 /
      DATA TMP(   2) /  24.58678 /
      DATA N1(  3),NP(  3) /    3,    1 /
      DATA TMP(   3) /  54.75000 /
      DATA N1(  4),NP(  4) /    4,    1 /
      DATA TMP(   4) / 111.00000 /
      DATA N1(  5),NP(  5) /    5,    4 /
      DATA (TMP(I),I=  5,  8) /
     +      188.00,     12.58,      4.70,      4.70 /
      DATA N1(  6),NP(  6) /    9,    4 /
      DATA (TMP(I),I=  9, 12) /
     +      283.80,     17.56,      6.40,      6.40 /
      DATA N1(  7),NP(  7) /   13,    4 /
      DATA (TMP(I),I= 13, 16) /
     +      401.60,     23.10,      9.20,      9.20 /
      DATA N1(  8),NP(  8) /   17,    4 /
      DATA (TMP(I),I= 17, 20) /
     +      532.00,     23.70,      7.10,      7.10 /
      DATA N1(  9),NP(  9) /   21,    4 /
      DATA (TMP(I),I= 21, 24) /
     +      685.40,     31.00,      8.60,      8.60 /
      DATA N1( 10),NP( 10) /   25,    4 /
      DATA (TMP(I),I= 25, 28) /
     +      866.90,     45.00,     18.30,     18.30 /
      DATA N1( 11),NP( 11) /   29,    4 /
      DATA (TMP(I),I= 29, 32) /
     +     1072.10,     63.30,     31.10,     31.10 /
      DATA N1( 12),NP( 12) /   33,    4 /
      DATA (TMP(I),I= 33, 36) /
     +     1305.00,     89.40,     51.40,     51.40 /
      DATA N1( 13),NP( 13) /   37,    4 /
      DATA (TMP(I),I= 37, 40) /
     +     1559.60,    117.70,     73.10,     73.10 /
      DATA N1( 14),NP( 14) /   41,    4 /
      DATA (TMP(I),I= 41, 44) /
     +     1838.90,    148.70,     99.20,     99.20 /
      DATA N1( 15),NP( 15) /   45,    4 /
      DATA (TMP(I),I= 45, 48) /
     +     2145.50,    189.30,    132.20,    132.20 /
      DATA N1( 16),NP( 16) /   49,    4 /
      DATA (TMP(I),I= 49, 52) /
     +     2472.00,    229.20,    164.80,    164.80 /
      DATA N1( 17),NP( 17) /   53,    7 /
      DATA (TMP(I),I=  53,  59) /
     +     2822.40,    270.20,    201.60,    200.00
     + ,     17.50,      6.80,      6.80 /
      DATA N1( 18),NP( 18) /   60,    7 /
      DATA (TMP(I),I=  60,  66) /
     +     3202.90,    320.00,    247.30,    245.20
     + ,     25.30,     12.40,     12.40 /
      DATA N1( 19),NP( 19) /   67,    7 /
      DATA (TMP(I),I=  67,  73) /
     +     3607.40,    377.10,    296.30,    293.60
     + ,     33.90,     17.80,     17.80 /
      DATA N1( 20),NP( 20) /   74,    7 /
      DATA (TMP(I),I=  74,  80) /
     +     4038.10,    437.80,    350.00,    346.40
     + ,     43.70,     25.40,     25.40 /
      DATA N1( 21),NP( 21) /   81,    9 /
      DATA (TMP(I),I=  81,  89) /
     +     4492.80,    500.40,    406.70,    402.20
     + ,     53.80,     32.30,     32.30,      6.60,      6.60 /
      DATA N1( 22),NP( 22) /   90,    9 /
      DATA (TMP(I),I=  90,  98) /
     +     4966.40,    563.70,    461.50,    455.50
     + ,     60.30,     34.60,     34.60,      3.70,      3.70 /
      DATA N1( 23),NP( 23) /   99,    9 /
      DATA (TMP(I),I=  99, 107) /
     +     5465.10,    628.20,    520.50,    512.90
     + ,     66.50,     37.80,     37.80,      2.20,      2.20 /
      DATA N1( 24),NP( 24) /  108,    9 /
      DATA (TMP(I),I= 108, 116) /
     +     5989.20,    694.60,    583.70,    574.50
     + ,     74.10,     42.50,     42.50,      2.30,      2.30 /
      DATA N1( 25),NP( 25) /  117,    9 /
      DATA (TMP(I),I= 117, 125) /
     +     6539.00,    769.00,    651.40,    640.30
     + ,     83.90,     48.60,     48.60,      3.30,      3.30 /
      DATA N1( 26),NP( 26) /  126,    9 /
      DATA (TMP(I),I= 126, 134) /
     +     7112.00,    846.10,    721.10,    708.10
     + ,     92.90,     54.00,     54.00,      3.60,      3.60 /
      DATA N1( 27),NP( 27) /  135,    9 /
      DATA (TMP(I),I= 135, 143) /
     +     7708.90,    925.60,    793.60,    778.60
     + ,    100.70,     59.50,     59.50,      2.90,      2.90 /
      DATA N1( 28),NP( 28) /  144,    9 /
      DATA (TMP(I),I= 144, 152) /
     +     8332.80,   1008.10,    871.90,    854.70
     + ,    111.80,     68.10,     68.10,      3.60,      3.60 /
      DATA N1( 29),NP( 29) /  153,    9 /
      DATA (TMP(I),I= 153, 161) /
     +     8978.90,   1096.60,    951.00,    931.10
     + ,    119.80,     73.60,     73.60,      1.60,      1.60 /
      DATA N1( 30),NP( 30) /  162,    9 /
      DATA (TMP(I),I= 162, 170) /
     +     9658.60,   1193.60,   1042.80,   1019.70
     + ,    135.90,     86.60,     86.60,      8.10,      8.10 /
      DATA N1( 31),NP( 31) /  171,    9 /
      DATA (TMP(I),I= 171, 179) /
     +    10367.10,   1297.70,   1142.30,   1115.40
     + ,    158.10,    106.80,    102.90,     17.40,     17.40 /
      DATA N1( 32),NP( 32) /  180,    9 /
      DATA (TMP(I),I= 180, 188) /
     +    11103.10,   1414.30,   1247.80,   1216.70
     + ,    180.00,    127.90,    120.80,     28.70,     28.70 /
      DATA N1( 33),NP( 33) /  189,   12 /
      DATA (TMP(I),I= 189, 200) /
     +    11866.70,   1526.50,   1358.60,   1323.10
     + ,    203.50,    146.40,    140.50,     41.20
     + ,     41.20,      0.00,      2.50,      2.50 /
      DATA N1( 34),NP( 34) /  201,   12 /
      DATA (TMP(I),I= 201, 212) /
     +    12657.80,   1653.90,   1476.20,   1435.80
     + ,    231.50,    168.20,    161.90,     56.70
     + ,     56.70,      0.00,      5.60,      5.60 /
      DATA N1( 35),NP( 35) /  213,   12 /
      DATA (TMP(I),I= 213, 224) /
     +    13473.70,   1782.00,   1596.00,   1549.90
     + ,    256.50,    189.30,    181.50,     70.10
     + ,     69.00,     27.30,      5.20,      4.60 /
      DATA N1( 36),NP( 36) /  225,   12 /
      DATA (TMP(I),I= 225, 236) /
     +    14325.60,   1921.00,   1727.20,   1674.90
     + ,    292.80,    222.70,    213.80,     95.00
     + ,     93.80,     24.00,     10.60,     10.60 /
      DATA N1( 37),NP( 37) /  237,   12 /
      DATA (TMP(I),I= 237, 248) /
     +    15199.70,   2065.10,   1863.90,   1804.40
     + ,    322.10,    247.40,    238.50,    111.80
     + ,    110.30,     29.30,     14.80,     14.00 /
      DATA N1( 38),NP( 38) /  249,   12 /
      DATA (TMP(I),I= 249, 260) /
     +    16104.60,   2216.30,   2006.80,   1939.60
     + ,    357.50,    279.80,    269.10,    135.00
     + ,    133.10,     37.70,     19.90,     19.90 /
      DATA N1( 39),NP( 39) /  261,   12 /
      DATA (TMP(I),I= 261, 272) /
     +    17038.40,   2372.50,   2155.50,   2080.00
     + ,    393.60,    312.40,    300.30,    159.60
     + ,    157.40,     45.40,     25.60,     25.60 /
      DATA N1( 40),NP( 40) /  273,   12 /
      DATA (TMP(I),I= 273, 284) /
     +    17997.60,   2531.60,   2306.70,   2222.30
     + ,    430.30,    344.20,    350.50,    182.40
     + ,    180.00,     51.30,     28.70,     28.70 /
      DATA N1( 41),NP( 41) /  285,   14 /
      DATA (TMP(I),I= 285, 298) /
     +    18985.60,   2697.70,   2464.70,   2370.50
     + ,    468.40,    378.40,    383.00,    207.40
     + ,    204.60,     58.10,     33.90,     33.90
     + ,      3.20,      3.20 /
      DATA N1( 42),NP( 42) /  299,   14 /
      DATA (TMP(I),I= 299, 312) /
     +    19999.50,   2865.50,   2625.10,   2520.20
     + ,    504.60,    409.70,    392.30,    230.30
     + ,    227.00,     61.80,     34.80,     34.80
     + ,      1.80,      1.80 /
      DATA N1( 43),NP( 43) /  313,   12 /
      DATA (TMP(I),I= 313, 324) /
     +    21044.00,   3042.50,   2793.20,   2676.90
     + ,      0.00,    444.90,    425.00,    256.40
     + ,    252.90,      0.00,     38.90,     38.90 /
      DATA N1( 44),NP( 44) /  325,   14 /
      DATA (TMP(I),I= 325, 338) /
     +    22117.20,   3224.00,   2966.90,   2837.90
     + ,    585.00,    482.80,    460.60,    283.60
     + ,    279.40,     74.90,     43.10,     43.10
     + ,      2.00,      2.00 /
      DATA N1( 45),NP( 45) /  339,   14 /
      DATA (TMP(I),I= 339, 352) /
     +    23219.90,   3411.90,   3146.10,   3003.80
     + ,    627.10,    521.00,    496.20,    311.70
     + ,    307.00,     81.00,     47.90,     47.90
     + ,      2.50,      2.50 /
      DATA N1( 46),NP( 46) /  353,   14 /
      DATA (TMP(I),I= 353, 366) /
     +    24350.30,   3604.30,   3330.30,   3173.30
     + ,    669.90,    559.10,    531.50,    340.00
     + ,    334.70,     86.40,     51.10,     51.10
     + ,      1.50,      1.50 /
      DATA N1( 47),NP( 47) /  367,   14 /
      DATA (TMP(I),I= 367, 380) /
     +    25514.00,   3805.80,   3523.70,   3351.10
     + ,    717.50,    602.40,    571.40,    372.80
     + ,    366.70,     95.20,     62.60,     55.90
     + ,      3.30,      3.30 /
      DATA N1( 48),NP( 48) /  381,   14 /
      DATA (TMP(I),I= 381, 394) /
     +    26711.20,   4018.00,   3727.00,   3537.50
     + ,    770.20,    650.70,    616.50,    410.50
     + ,    403.70,    107.60,     66.90,     66.90
     + ,      9.30,      9.30 /
      DATA N1( 49),NP( 49) /  395,   19 /
      DATA (TMP(I),I= 395, 413) /
     +    27939.90,   4237.50,   3938.00,   3730.10
     + ,    825.60,    702.20,    664.30,    450.80
     + ,    443.10,    121.90,     77.40,     77.40
     + ,     16.20,     16.20,      0.00,      0.00
     + ,      0.10,      0.80,      0.80 /
      DATA N1( 50),NP( 50) /  414,   19 /
      DATA (TMP(I),I= 414, 432) /
     +    29200.10,   4464.70,   4156.10,   3928.80
     + ,    883.80,    756.40,    714.40,    493.30
     + ,    484.80,    136.50,     88.60,     88.60
     + ,     23.90,     23.90,      0.00,      0.00
     + ,      0.90,      1.10,      1.10 /
      DATA N1( 51),NP( 51) /  433,   19 /
      DATA (TMP(I),I= 433, 451) /
     +    30491.20,   4698.30,   4380.40,   4132.20
     + ,    943.70,    811.90,    765.60,    536.90
     + ,    527.50,    152.00,     98.40,     98.40
     + ,     31.40,     31.40,      0.00,      0.00
     + ,      6.70,      2.10,      2.10 /
      DATA N1( 52),NP( 52) /  452,   19 /
      DATA (TMP(I),I= 452, 470) /
     +    31813.80,   4939.20,   4612.00,   4341.40
     + ,   1006.00,    869.70,    818.70,    582.50
     + ,    572.10,    168.30,    110.20,    110.20
     + ,     39.80,     39.80,      0.00,      0.00
     + ,     11.60,      2.30,      2.30 /
      DATA N1( 53),NP( 53) /  471,   19 /
      DATA (TMP(I),I= 471, 489) /
     +    33169.40,   5188.10,   4852.10,   4557.10
     + ,   1072.10,    930.50,    874.60,    631.30
     + ,    619.40,    186.40,    122.70,    122.70
     + ,     49.60,     49.60,      0.00,      0.00
     + ,     13.60,      3.30,      3.30 /
      DATA N1( 54),NP( 54) /  490,   19 /
      DATA (TMP(I),I= 490, 508) /
     +    34561.40,   5452.80,   5103.70,   4782.20
     + ,   1145.70,    999.00,    937.00,    689.00
     + ,    672.30,    213.20,    157.00,    146.70
     + ,     69.50,     67.50,      0.00,      0.00
     + ,     23.39,     13.43,     12.13 /
      DATA N1( 55),NP( 55) /  509,   19 /
      DATA (TMP(I),I= 509, 527) /
     +    35984.60,   5714.30,   5359.40,   5011.90
     + ,   1217.10,   1065.00,    997.60,    739.50
     + ,    725.50,    230.80,    172.30,    161.60
     + ,     78.80,     76.50,      0.00,      0.00
     + ,     22.70,     13.10,     11.40 /
      DATA N1( 56),NP( 56) /  528,   19 /
      DATA (TMP(I),I= 528, 546) /
     +    37440.60,   5988.80,   5623.60,   5247.00
     + ,   1292.80,   1136.70,   1062.20,    796.10
     + ,    780.70,    253.00,    191.80,    179.70
     + ,     92.50,     89.90,      0.00,      0.00
     + ,     39.10,     16.60,     14.60 /
      DATA N1( 57),NP( 57) /  547,   19 /
      DATA (TMP(I),I= 547, 565) /
     +    38924.60,   6266.30,   5890.60,   5482.70
     + ,   1361.30,   1204.40,   1123.40,    848.50
     + ,    831.70,    270.40,    205.80,    191.40
     + ,     98.90,     98.90,      0.00,      0.00
     + ,     32.30,     14.40,     14.40 /
      DATA N1( 58),NP( 58) /  566,   19 /
      DATA (TMP(I),I= 566, 584) /
     +    40443.00,   6548.80,   6164.20,   5723.40
     + ,   1434.60,   1272.80,   1185.40,    901.30
     + ,    883.30,    289.60,    223.30,    207.20
     + ,    110.00,    110.00,      0.10,      0.10
     + ,     37.80,     19.80,     19.80 /
      DATA N1( 59),NP( 59) /  585,   19 /
      DATA (TMP(I),I= 585, 603) /
     +    41990.60,   6834.80,   6440.40,   5964.30
     + ,   1511.00,   1337.40,   1242.20,    951.10
     + ,    931.00,    304.50,    236.30,    217.60
     + ,    113.20,    113.20,      2.00,      2.00
     + ,     37.40,     22.30,     22.30 /
      DATA N1( 60),NP( 60) /  604,   19 /
      DATA (TMP(I),I= 604, 622) /
     +    43568.90,   7126.00,   6721.50,   6207.90
     + ,   1575.30,   1402.80,   1297.40,    999.90
     + ,    977.70,    315.20,    243.30,    224.60
     + ,    117.50,    117.50,      1.50,      1.50
     + ,     37.50,     21.20,     21.80 /
      DATA N1( 61),NP( 61) /  623,   14 /
      DATA (TMP(I),I= 623, 636) /
     +    45184.00,   7427.90,   7012.80,   6459.30
     + ,   1650.00,   1471.40,   1356.90,   1051.50
     + ,   1026.90,      0.00,    242.00,    242.00
     + ,    120.40,    120.40 /
      DATA N1( 62),NP( 62) /  637,   19 /
      DATA (TMP(I),I= 637, 655) /
     +    46834.20,   7736.80,   7311.80,   6716.20
     + ,   1722.80,   1540.70,   1419.80,   1106.00
     + ,   1080.20,    345.70,    265.60,    247.40
     + ,    129.00,    129.00,      5.50,      5.50
     + ,     37.40,     21.30,     21.30 /
      DATA N1( 63),NP( 63) /  656,   19 /
      DATA (TMP(I),I= 656, 674) /
     +    48519.00,   8052.00,   7617.10,   6976.90
     + ,   1800.00,   1613.90,   1480.60,   1160.60
     + ,   1130.90,    360.20,    283.90,    256.60
     + ,    133.20,    133.20,      0.00,      0.00
     + ,     31.80,     22.00,     22.00 /
      DATA N1( 64),NP( 64) /  675,   19 /
      DATA (TMP(I),I= 675, 693) /
     +    50239.10,   8375.60,   7930.30,   7242.80
     + ,   1880.80,   1688.30,   1544.00,   1217.20
     + ,   1185.20,    375.80,    288.50,    270.90
     + ,    140.50,    140.50,      0.10,      0.10
     + ,     36.10,     20.30,     20.30 /
      DATA N1( 65),NP( 65) /  694,   19 /
      DATA (TMP(I),I= 694, 712) /
     +    51995.70,   8708.00,   8251.60,   7514.00
     + ,   1967.50,   1767.70,   1611.30,   1275.00
     + ,   1241.20,    397.90,    310.20,    285.00
     + ,    147.00,    147.00,      2.60,      2.60
     + ,     39.00,     25.40,     25.40 /
      DATA N1( 66),NP( 66) /  713,   19 /
      DATA (TMP(I),I= 713, 731) /
     +    53788.50,   9045.80,   8580.60,   7790.10
     + ,   2046.80,   1841.80,   1675.60,   1332.50
     + ,   1294.90,    416.30,    331.80,    292.90
     + ,    154.20,    154.20,      4.20,      4.20
     + ,     62.90,     26.30,     26.30 /
      DATA N1( 67),NP( 67) /  732,   19 /
      DATA (TMP(I),I= 732, 750) /
     +    55617.70,   9394.20,   8917.80,   8071.10
     + ,   2128.30,   1922.80,   1741.20,   1391.50
     + ,   1351.40,    435.70,    343.50,    306.60
     + ,    161.00,    161.00,      3.70,      3.70
     + ,     51.20,     20.30,     20.30 /
      DATA N1( 68),NP( 68) /  751,   19 /
      DATA (TMP(I),I= 751, 769) /
     +    57485.50,   9751.30,   9264.30,   8357.90
     + ,   2206.50,   2005.80,   1811.80,   1453.30
     + ,   1409.30,    449.10,    366.20,    320.00
     + ,    176.70,    167.60,      4.30,      4.30
     + ,     59.80,     29.40,     29.40 /
      DATA N1( 69),NP( 69) /  770,   19 /
      DATA (TMP(I),I= 770, 788) /
     +    59389.60,  10115.70,   9616.90,   8648.00
     + ,   2306.80,   2089.80,   1884.50,   1514.60
     + ,   1467.70,    471.70,    385.90,    336.60
     + ,    179.60,    179.60,      5.30,      5.30
     + ,     53.20,     32.30,     32.30 /
      DATA N1( 70),NP( 70) /  789,   19 /
      DATA (TMP(I),I= 789, 807) /
     +    61332.30,  10486.40,   9978.20,   8943.60
     + ,   2398.10,   2173.00,   1949.80,   1576.30
     + ,   1527.80,    487.20,    396.70,    343.50
     + ,    198.10,    184.90,      6.30,      6.30
     + ,     54.10,     23.40,     23.40 /
      DATA N1( 71),NP( 71) /  808,   19 /
      DATA (TMP(I),I= 808, 826) /
     +    63313.80,  10870.40,  10348.60,   9244.10
     + ,   2491.20,   2263.50,   2023.60,   1639.40
     + ,   1588.50,    506.20,    410.10,    359.30
     + ,    204.80,    195.00,      6.90,      6.90
     + ,     56.80,     28.00,     28.00 /
      DATA N1( 72),NP( 72) /  827,   19 /
      DATA (TMP(I),I= 827, 845) /
     +    65350.80,  11270.70,  10739.40,   9560.70
     + ,   2600.90,   2365.40,   2107.60,   1716.40
     + ,   1661.70,    538.10,    437.00,    380.40
     + ,    223.80,    213.70,     17.10,     17.10
     + ,     64.90,     38.10,     30.60 /
      DATA N1( 73),NP( 73) /  846,   21 /
      DATA (TMP(I),I= 846, 866) /
     +    67416.40,  11681.50,  11136.10,   9881.10
     + ,   2708.00,   2468.70,   2194.00,   1793.20
     + ,   1735.10,    565.50,    464.80,    404.50
     + ,    241.30,    229.30,     25.00,     25.00
     + ,     71.10,     44.90,     36.40,      5.70,      5.70 /
      DATA N1( 74),NP( 74) /  867,   21 /
      DATA (TMP(I),I= 867, 887) /
     +    69525.00,  12099.80,  11544.00,  10206.80
     + ,   2819.60,   2574.90,   2281.00,   1871.60
     + ,   1809.20,    595.00,    491.60,    425.30
     + ,    258.80,    245.40,     36.50,     33.60
     + ,     77.10,     46.80,     35.60,      6.10,      6.10 /
      DATA N1( 75),NP( 75) /  888,   21 /
      DATA (TMP(I),I= 888, 908) /
     +    71676.40,  12526.70,  11958.70,  10535.30
     + ,   2931.70,   2681.60,   2367.30,   1948.90
     + ,   1882.90,    625.00,    517.90,    444.40
     + ,    273.70,    260.20,     40.60,     40.60
     + ,     82.80,     45.60,     34.60,      3.50,      3.50 /
      DATA N1( 76),NP( 76) /  909,   19 /
      DATA (TMP(I),I= 909, 927) /
     +    73870.80,  12968.00,  12385.00,  10870.90
     + ,   3048.50,   2792.20,   2457.20,   2030.80
     + ,   1960.10,    654.30,    546.50,    468.20
     + ,    289.40,    272.80,     46.30,     43.40
     + ,     83.70,     58.00,     45.40 /
      DATA N1( 77),NP( 77) /  928,   21 /
      DATA (TMP(I),I= 928, 948) /
     +    76111.00,  13418.50,  12824.10,  11215.20
     + ,   3173.70,   2908.70,   2550.70,   2116.10
     + ,   2040.40,    690.10,    577.10,    494.30
     + ,    311.40,    294.90,     63.40,     60.50
     + ,     95.20,     63.00,     50.50,      1.80,      1.80 /
      DATA N1( 78),NP( 78) /  949,   21 /
      DATA (TMP(I),I= 949, 969) /
     +    78394.80,  13879.90,  13272.60,  11563.70
     + ,   3296.00,   3026.50,   2645.40,   2201.90
     + ,   2121.60,    722.00,    609.20,    519.00
     + ,    330.80,    313.30,     74.30,     71.10
     + ,    101.70,     65.30,     51.70,      2.20,      2.20 /
      DATA N1( 79),NP( 79) /  970,   20 /
      DATA (TMP(I),I= 970, 989) /
     +    80724.90,  14352.80,  13733.60,  11918.70
     + ,   3424.90,   3147.80,   2743.00,   2291.10
     + ,   2205.70,    758.80,    643.70,    545.40
     + ,    352.00,    333.90,     86.40,     82.80
     + ,    107.80,     71.70,     53.70,      2.50 /
      DATA N1( 80),NP( 80) /  990,   21 /
      DATA (TMP(I),I= 990,1010) /
     +    83102.30,  14839.30,  14208.70,  12283.90
     + ,   3561.60,   3278.50,   2847.10,   2384.90
     + ,   2294.90,    800.30,    676.90,    571.00
     + ,    378.30,    359.80,    102.20,     98.50
     + ,    120.30,     80.50,     57.60,      6.40,      6.40 /
      DATA N1( 81),NP( 81) / 1011,   21 /
      DATA (TMP(I),I=1011,1031) /
     +    85530.40,  15346.70,  14697.90,  12657.50
     + ,   3704.10,   3425.70,   2956.60,   2485.10
     + ,   2389.30,    845.50,    721.30,    609.00
     + ,    406.60,    386.20,    122.80,    118.50
     + ,    136.30,     99.60,     75.40,     15.30,     13.10 /
      DATA N1( 82),NP( 82) / 1032,   24 /
      DATA (TMP(I),I=1032,1055) /
     +    88004.50,  15860.80,  15200.00,  13035.20
     + ,   3850.70,   3554.20,   3066.40,   2585.60
     + ,   2484.00,    893.60,    763.90,    644.50
     + ,    435.20,    412.90,    142.90,    138.10
     + ,    147.30,    104.80,     86.00,     21.80
     + ,     19.20,      3.10,      0.70,      0.70 /
      DATA N1( 83),NP( 83) / 1056,   24 /
      DATA (TMP(I),I=1056,1079) /
     +    90525.90,  16387.50,  15711.10,  13418.60
     + ,   3999.10,   3696.30,   3176.90,   2687.60
     + ,   2579.60,    938.20,    805.30,    678.90
     + ,    463.60,    440.00,    161.90,    157.40
     + ,    159.30,    116.80,     92.80,     26.50
     + ,     24.40,      0.00,      2.70,      2.70 /
      DATA N1( 84),NP( 84) / 1080,   21 /
      DATA (TMP(I),I=1080,1100) /
     +    93105.00,  16939.30,  16244.30,  13813.80
     + ,   4149.40,   3854.10,   3301.90,   2798.00
     + ,   2683.00,    995.30,    851.00,    705.00
     + ,    500.20,    473.40,      0.00,      0.00
     + ,      0.00,      0.00,      0.00,     31.40,     31.40 /
      DATA N1( 85),NP( 85) / 1101,   14 /
      DATA (TMP(I),I=1101,1114) /
     +    95729.90,  17493.00,  16784.70,  14213.50
     + ,   4317.00,   4008.00,   3426.00,   2908.70
     + ,   2786.70,   1042.00,    886.00,    740.00
     + ,    533.20,    506.00 /
      DATA N1( 86),NP( 86) / 1115,   14 /
      DATA (TMP(I),I=1115,1128) /
     +    98404.00,  18049.00,  17337.10,  14619.40
     + ,   4482.00,   4159.00,   3538.00,   3021.50
     + ,   2892.40,   1097.00,    929.00,    768.00
     + ,    566.60,    541.00 /
      DATA N1( 87),NP( 87) / 1129,   14 /
      DATA (TMP(I),I=1129,1142) /
     +   101137.00,  18639.00,  17906.50,  15031.20
     + ,   4652.00,   4327.00,   3663.00,   3136.20
     + ,   2999.90,   1153.00,    980.00,    810.00
     + ,    603.30,    577.00 /
      DATA N1( 88),NP( 88) / 1143,   24 /
      DATA (TMP(I),I=1143,1166) /
     +   103921.90,  19236.70,  18484.30,  15444.40
     + ,   4822.00,   4489.50,   3791.80,   3248.40
     + ,   3104.90,   1208.40,   1057.60,    879.10
     + ,    635.90,    602.70,    298.90,    298.90
     + ,    254.40,    200.40,    152.80,     67.20
     + ,     67.20,     43.50,     18.80,     18.80 /
      DATA N1( 89),NP( 89) / 1167,   14 /
      DATA (TMP(I),I=1167,1180) /
     +   106755.30,  19840.00,  19083.20,  15871.00
     + ,   5002.00,   4656.00,   3909.00,   3370.20
     + ,   3219.00,   1269.00,   1080.00,    890.00
     + ,    674.90,    644.00 /
      DATA N1( 90),NP( 90) / 1181,   24 /
      DATA (TMP(I),I=1181,1204) /
     +   109650.90,  20472.10,  19693.20,  16300.30
     + ,   5182.30,   4830.40,   4046.10,   3490.80
     + ,   3332.00,   1329.50,   1168.20,    967.30
     + ,    714.10,    676.40,    344.40,    335.20
     + ,    290.20,    229.40,    181.80,     94.30
     + ,     87.90,     59.50,     49.00,     43.00 /
      DATA N1( 91),NP( 91) / 1205,   21 /
      DATA (TMP(I),I=1205,1225) /
     +   112601.40,  21104.60,  20313.70,  16733.10
     + ,   5366.90,   5000.90,   4173.80,   3611.20
     + ,   3441.80,   1387.10,   1224.30,   1006.70
     + ,    743.40,    708.20,    371.20,    359.50
     + ,    309.60,    222.90,    222.90,     94.10,     94.10 /
      DATA N1( 92),NP( 92) / 1226,   24 /
      DATA (TMP(I),I=1226,1249) /
     +   115606.10,  21757.40,  20947.60,  17166.30
     + ,   5548.00,   5182.20,   4303.40,   3727.60
     + ,   3551.70,   1440.80,   1272.60,   1044.90
     + ,    780.40,    737.70,    391.30,    380.90
     + ,    323.70,    259.30,    195.10,    105.00
     + ,     96.30,     70.70,     42.30,     32.30 /
      DATA N1( 93),NP( 93) / 1250,   21 /
      DATA (TMP(I),I=1250,1270) /
     +   118678.00,  22426.80,  21600.50,  17610.00
     + ,   5723.20,   5366.20,   4434.70,   3850.30
     + ,   3665.80,   1500.70,   1327.70,   1086.80
     + ,    815.90,    770.30,    415.00,    404.40
     + ,      0.00,    283.40,    206.10,    109.30,    101.30 /
      DATA N1( 94),NP( 94) / 1271,   21 /
      DATA (TMP(I),I=1271,1291) /
     +   121818.00,  23097.20,  22266.20,  18056.80
     + ,   5932.90,   5541.20,   4556.60,   3972.60
     + ,   3778.10,   1558.60,   1372.10,   1114.80
     + ,    848.90,    801.40,    445.80,    432.40
     + ,    351.90,    274.10,    206.50,    116.00,    105.40 /
      DATA N1( 95),NP( 95) / 1292,   21 /
      DATA (TMP(I),I=1292,1312) /
     +   125027.00,  23772.90,  22944.00,  18504.10
     + ,   6120.50,   5710.20,   4667.00,   4092.10
     + ,   3886.90,   1617.10,   1411.80,   1135.70
     + ,    878.70,    827.60,      0.00,      0.00
     + ,      0.00,      0.00,      0.00,    115.80,    103.30 /
      DATA N1( 96),NP( 96) / 1313,   21 /
      DATA (TMP(I),I=1313,1333) /
     +   128220.00,  24460.00,  23779.00,  18930.00
     + ,   6288.00,   5895.00,   4797.00,   4227.00
     + ,   3971.00,   1643.00,   1440.00,   1154.00
     + ,      0.00,    853.00,      0.00,      0.00
     + ,    385.00,      0.00,      0.00,      0.00,    100.00 /
      DATA N1( 97),NP( 97) / 1334,   21 /
      DATA (TMP(I),I=1334,1354) /
     +   131590.00,  25275.00,  24385.00,  19452.00
     + ,   6556.00,   6147.00,   4977.00,   4366.00
     + ,   4132.00,   1755.00,   1554.00,   1235.00
     + ,      0.00,    877.00,      0.00,      0.00
     + ,    398.00,      0.00,      0.00,      0.00,    100.00 /
      DATA N1( 98),NP( 98) / 1355,   21 /
      DATA (TMP(I),I=1355,1375) /
     +   135960.00,  26110.00,  25250.00,  19930.00
     + ,   6754.00,   6359.00,   5109.00,   4497.00
     + ,   4253.00,   1799.00,   1616.00,   1279.00
     + ,      0.00,    902.00,      0.00,      0.00
     + ,    419.00,      0.00,      0.00,      0.00,    100.00 /
      DATA N1( 99),NP( 99) / 1376,   17 /
      DATA (TMP(I),I=1376,1392) /
     +   139490.00,  26900.00,  26020.00,  20410.00
     + ,   6977.00,   6574.00,   5252.00,   4630.00
     + ,   4374.00,   1868.00,   1680.00,   1321.00
     + ,      0.00,    927.00,      0.00,      0.00,    435.00 /
      DATA N1(100),NP(100) / 1393,   17 /
      DATA (TMP(I),I=1393,1409) /
     +   143090.00,  27700.00,  26810.00,  20900.00
     + ,   7205.00,   6793.00,   5397.00,   4766.00
     + ,   4498.00,   1937.00,   1747.00,   1366.00
     + ,      0.00,    952.00,      0.00,      0.00,    454.00 /
      DO 10 I = 1,LENGTH
         ESHELL(I) = TMP(I)
   10 CONTINUE
      DO 20 I = 1,MAXSHL
         NSHLST(I) = NS(I)
   20 CONTINUE
      DO 30 I = 1,MAXELZ
         N1ST(I) = N1(I)
         NSHLLS(I) = NP(I)
   30 CONTINUE
      END
+DECK,GSYNC.
*CMZ :  3.21/03 11/10/94  19.56.01  by  S.Giani
*-- Author :
      SUBROUTINE GSYNC
C
C.    ******************************************************************
C.    *                                                                *
C.    *   Simulation of synchrotron radiation for e- and e+.           *
C.    *                                                                *
C.    *   ==> Called by : GTELEC                                       *
C.    *       Authors   : Igor Gavrilenko                              *
C.    *                                                                *
C.    ******************************************************************
C
+SEQ,GCPHYS.
+SEQ,GCTRAK.
+SEQ,GCKINE.
+SEQ,GCKING.
+SEQ,GCTMED.
+SEQ,GCCUTS.
C...
      DIMENSION ETR(100),STR(100),VECTS(7),VECTN(7),FLD(3)
C...
      IF(ABS(CHARGE).NE.1..OR.STEP.LE.0.) GO TO 999
      GAMMA  = GETOT/AMASS
      IF(GAMMA.LE.1000.                 ) GO TO 999
      KCASE = NAMEC1(8)
      IF (IFIELD.EQ.3) THEN
          FLD(1) = 0.
          FLD(2) = 0.
          FLD(3) = FIELDM
      ELSE
          CALL GUFLD(VECT,FLD)
      END IF
      FLDS2  = FLD(1)**2+FLD(2)**2+FLD(3)**2
      IF(FLDS2.LE.1E-10) GO TO 999
      FLDT   = SQRT(FLDS2-
     +  (VECT(4)*FLD(1)+VECT(5)*FLD(2)+VECT(6)*FLD(3))**2)
C...
      CALL GSYNGE(GAMMA,AMASS,FLDT,STEP,NTR,ETR,STR)
      IF(NTR.EQ.0) GO TO 999
C...
      ELOSS          = 0.
C
C     When SYNC=1 the generation point of the photons is the current
C     particle point
C     When SYNC=3, the generation point of the photon is distributed
C     along the real trajectory of the particle (not along the step
C     taken) computed by GUSWIM.
      DO 10 N = 1,NTR
         IF (ISYNC.NE.2.AND.ETR(N).GT.CUTGAM) THEN
            NGKINE = NGKINE+1
            IF(NGKINE.GT.MXGKIN) GO TO 20
            IF (ISYNC.EQ.1) THEN
                GKIN(1,NGKINE) = ETR(N)*VECT(4)
                GKIN(2,NGKINE) = ETR(N)*VECT(5)
                GKIN(3,NGKINE) = ETR(N)*VECT(6)
                GKIN(4,NGKINE) = ETR(N)
                GKIN(5,NGKINE) = 1.
                GPOS(1,NGKINE) = VECT(1)
                GPOS(2,NGKINE) = VECT(2)
                GPOS(3,NGKINE) = VECT(3)
                TOFD (NGKINE) = 0.
            ELSE IF (ISYNC.EQ.3) THEN
                VECTS(1) = VECT(1)
                VECTS(2) = VECT(2)
                VECTS(3) = VECT(3)
                VECTS(4) = -VECT(4)
                VECTS(5) = -VECT(5)
                VECTS(6) = -VECT(6)
                VECTS(7) = VECT(7)
                CALL GUSWIM(1.,STR(N),VECTS,VECTN)
                GKIN(1,NGKINE) = -ETR(N)*VECTN(4)
                GKIN(2,NGKINE) = -ETR(N)*VECTN(5)
                GKIN(3,NGKINE) = -ETR(N)*VECTN(6)
                GKIN(4,NGKINE) = ETR(N)
                GKIN(5,NGKINE) = 1.
                GPOS(1,NGKINE) = VECTN(1)
                GPOS(2,NGKINE) = VECTN(2)
                GPOS(3,NGKINE) = VECTN(3)
                TOFD (NGKINE) = 0.
             END IF
         ELSE
             DESTEP = DESTEP +ETR(N)
         END IF
         ELOSS = ELOSS+ETR(N)
   10 CONTINUE
C
C..Update the energy of the primary particle
C
   20 GETOT = GETOT-ELOSS
      GEKIN = GEKIN-ELOSS
      VECT(7) = SQRT(GEKIN*(GEKIN+2.*AMASS))
      CALL GEKBIN
C...
 999  CONTINUE
      END
+DECK,GSYNGE.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSYNGE (GAMMA,AM,HKGAUS,STEP,NTR,ETR,STR)
C
C.    ******************************************************************
C.    *                                                                *
C.    *  Generation of synchrotron radiation photons:                  *
C.    *     o sample the number of generated photons from              *
C.    *       Poisson distribution                                     *
C.    *     o sample the energy of each photon from the                *
C.    *       tables below (these numbers can be computed by           *
C.    *       the routine GSYNIT)                                      *
C.    *       YT(I)  = photon energy/ critical photon energy (e/ec)    *
C.    *       FTI(I) = int from YT(I) to inf (20) of dN**2/dxde        *
C.    *                where dN**2/dxde = int from e/ec to inf of      *
C.    *                                   K_5/3(x) dx                  *
C.    *                                                                *
C.    *   GAMMA      - Lorentz factor,                                 *
C.    *   H          - transverse component of the magnetic field      *
C.    *                to particle direction,                          *
C.    *   STEP       - current step in magnetic field,                 *
C.    *   NTR        - number of the synchrotron photons,              *
C.    *   ETR(k)     - photon energy,                                  *
C.    *   STR(k)     - photon coordinate.                              *
C.    *                                                                *
C.    *   ==> Called by : GSYNC                                        *
C.    *       Authors   : Igor Gavrilenko                              *
C.    *                                                                *
C.    ******************************************************************
C
C
+SEQ,GCUNIT
+SELF,IF=NEVER.
      COMMON /SYNTAB / YT(54),FT(53),FTI(53)
+SELF.
C...
      DIMENSION ETR(100),STR(100),RNDM(200)
+SELF,IF=-NEVER.
      DIMENSION YT(54),FTI(53)
+SELF.
C...
      DATA FTI/0.9827082157, 0.9756910801, 0.9708271027, 0.9669673443,
     +        0.9637124538, 0.9608694911, 0.9583284855, 0.9560201764,
     +        0.9538975954, 0.9519274235, 0.9368366003, 0.9263846874,
     +        0.9180962443, 0.9111109376, 0.9050130844, 0.8995658755,
     +        0.8946199417, 0.8900741935, 0.8858568072, 0.8536163568,
     +        0.8313701749, 0.8137849569, 0.7990072370, 0.7861415148,
     +        0.7746775150, 0.7642934322, 0.7547715902, 0.7459571362,
     +        0.6792119741, 0.6339961290, 0.5988188982, 0.5696868896,
     +        0.5446703434, 0.5226698518, 0.5029919147, 0.4851673245,
     +        0.4688622653, 0.3516088724, 0.2802021503, 0.2298262119,
     +        0.1918447465, 0.1620831937, 0.1381656080, 0.1185975820,
     +        0.1023733467,     0.8878208697E-01, 0.2343492396E-01,
     +        0.7047536317E-02, 0.2237016102E-02, 0.7283322047E-03,
     +        0.2375631739E-03, 0.7417966117E-04, 0.1891316060E-04/
 
      DATA YT/1E-5,2E-5,3E-5,4E-5,5E-5,6E-5,7E-5,8E-5,9E-5,
     +        1E-4,2E-4,3E-4,4E-4,5E-4,6E-4,7E-4,8E-4,9E-4,
     +        1E-3,2E-3,3E-3,4E-3,5E-3,6E-3,7E-3,8E-3,9E-3,
     +        1E-2,2E-2,3E-2,4E-2,5E-2,6E-2,7E-2,8E-2,9E-2,
     +        .1,.2,.3,.4,.5,.6,.7,.8,.9,1.,2.,3.,4.,5.,6.,7.,8.,9./
C...
      NTR         = 0
      H = 0.1*HKGAUS
      IF(H.LE.0.) GO TO 999
C...
      RAD         = 333.33*AM*GAMMA/H
C...
      EC          = 2.96E-8*GAMMA**3/RAD
C...
      AN          = .01053*GAMMA/RAD*STEP
      CALL GPOISS(AN,N,1)
      N=MIN(N,100)
      IF(N.LE.0) GO TO 999
C...
      CALL GRNDM(RNDM,N*2)
      DO 40 I = 1,N
         K1 = 1
         K2 = 53
         R = RNDM(2*I-1)*(FTI(1)-FTI(53))+FTI(53)
C...
   10    K = (K1+K2)/2
         IF(R.NE.FTI(K)) GO TO 20
         E = YT(K)*EC
         GO TO 30
C...
   20    IF(R.GT.FTI(K)) THEN
            K2 = K
         ELSEIF(R.LT.FTI(K)) THEN
            K1 = K
         ENDIF
         IF(K2-K1.GT.1) GO TO 10
C...
         IF(YT(K2).LE.1.) THEN
            Y2 = LOG(YT(K2))
            Y1 = LOG(YT(K1))
            E = Y2+(R-FTI(K2))*(Y1-Y2)/(FTI(K1)-FTI(K2))
            E = EXP(E)*EC
         ELSE
            F2 = LOG(FTI(K2))
            F1 = LOG(FTI(K1))
            DR = LOG(R)
            E = YT(K2)+(DR-F2)*(YT(K1)-YT(K2))/(F1-F2)
            E = E*EC
         END IF
C...
   30    CONTINUE
C
         IF(E/EC.GT.20.) THEN
            WRITE(CHMAIL,'('' *** GSYNGE: Photons have e>20*ec, e= '',
     +      G10.4,'' keV, ec= '',G10.4,'' keV'')') E,EC
            CALL GMAIL(1,0)
            GO TO 40
         ENDIF
C...
         NTR = NTR+1
         ETR(NTR) = E*1.E-6
         STR(NTR) = STEP*RNDM(2*I)
   40 CONTINUE
C...
 999  CONTINUE
      END
+DECK,gsynit,IF=NEVER.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSYNIT
C
C  Preperation of synchrotron radiation tables.
C  This routine can be used to compute the YT and FTI used
C  in GSYNGE.
C  Author: Igor Gavrilenko
C
      COMMON /SYNTAB/ YT(54),FT(54),FTI(53)
      EXTERNAL BK53,BKS53
      DOUBLE PRECISION YM,YMA,EPS,XX
C...
      DATA EPS/.0001/
C...
      L = 0
      YS = .000001
      DO 20 I = 1,6
         YS = YS*10.
         DO 10 J = 1,9,1
            L = L+1
            YM = J*YS
            YT(L) = YM
            YMA = YM+YS
            IF(L.EQ.54) YMA = 20.
            FT(L) = DGAUSS(BK53,YM,YMA,EPS)
   10    CONTINUE
   20 CONTINUE
C...
      DO 30 I = 53,1,-1
         FT(I) = FT(I)+FT(I+1)
   30 CONTINUE
C...
      DO 40 I = 53,1,-1
         YM = YT(I)
         YMA = YT(I+1)
         IF(I.LT.53) FTI(I) = DGAUSS(BKS53,YM,YMA,EPS)+FTI(I+1)
         IF(I.EQ.53) FTI(I) = DGAUSS(BKS53,YM,YMA,EPS)
   40 CONTINUE
C...
      E N D
C-------------------------------------------------------
      DOUBLE PRECISION FUNCTION B K 5 3 (X)
C
      DOUBLE PRECISION X
C...
      BK53 = 4./(3.*X)*DBSKR3(X,2)+DBSKR3(X,1)
      RETURN
      E N D
C------------------------------------------------------
      DOUBLE PRECISION FUNCTION B K S 5 3 (X)
C
      COMMON /SYNTAB/ YT(54),FT(54),FTI(53)
      DOUBLE PRECISION X
C...
      IF(X.GT.YT(1)) GO TO 10
      BKS53 = FT(1)
      GO TO 60
C...
   10 IF(X.LT.YT(54)) GO TO 20
      BKS53 = 0.
      RETURN
C...
   20 K1 = 1
      K2 = 54
   30 K = (K1+K2)/2
      IF(X.GT.YT(K)) K1 = K
      IF(X.LT.YT(K)) K2 = K
      IF(X.NE.YT(K)) GO TO 40
      BKS53 = FT(K)
      GO TO 60
C...
   40 IF(K2-K1.GT.1) GO TO 30
      F1 = FT(K1)
      F2 = FT(K2)
      X1 = YT(K1)
      X2 = YT(K2)
C...
      IF(X.LE.1.) THEN
         X1 = LOG(X1)
         X2 = LOG(X2)
         B = F1+(F2-F1)/(X2-X1)*(LOG(X)-X1)
         GO TO 50
      ENDIF
C...
      IF(X.GT.1.) THEN
         F1 = LOG(F1)
         F2 = LOG(F2)
         B = F1+(F2-F1)/(X2-X1)*(X-X1)
         B = EXP(B)
      ENDIF
C...
   50 BKS53 = B
   60 BKS53 = .1909859*BKS53
      RETURN
      E N D
+DECK,GVAVIV.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      FUNCTION GVAVIV(RKAPPA,BETA2,RAN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *  GVAVIV                                                        *
C.    *  ------                                                        *
C.    *                                                                *
C.    *  Initializes the parameters for a Vavilov distribution         *
C.    *                                                                *
C.    *  BETA2 is the particle velocity squared                        *
C.    *  RKAPPA the usual straggling parameter                         *
C.    *                                                                *
C.    *  This routine has been extracted from a proposed CERNLIB       *
C.    *  set of routines (VAVCOE,VAVFSM).                              *
C.    *  The authors of these routines have submitted an article       *
C.    *  to NIM:                                                       *
C.    *                                                                *
C.    *    Alberto Rotondi, Paolo Montagna                             *
C.    *    Fast calculation of Vavilov distribution NIMB 1990          *
C.    *                                                                *
C.    *       Author    K.S.Koelbig     ********                       *
C.    *                                                                *
C.    *   ==> Called by : GLANDO                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION AC(0:12),HC(0:8),H(9)
 
      PARAMETER
     1(BKMNX1 = 0.02, BKMNY1 = 0.05, BKMNX2 = 0.12, BKMNY2 = 0.05,
     2 BKMNX3 = 0.22, BKMNY3 = 0.05, BKMXX1 = 0.1 , BKMXY1 = 1   ,
     3 BKMXX2 = 0.2 , BKMXY2 = 1   , BKMXX3 = 0.3 , BKMXY3 = 1   )
      PARAMETER
     1(FBKX1 = 2/(BKMXX1-BKMNX1), FBKX2 = 2/(BKMXX2-BKMNX2),
     2 FBKX3 = 2/(BKMXX3-BKMNX3), FBKY1 = 2/(BKMXY1-BKMNY1),
     3 FBKY2 = 2/(BKMXY2-BKMNY2), FBKY3 = 2/(BKMXY3-BKMNY3))
 
      DIMENSION EDGEC(2:7),FNINV(5),DRK(5),DSIGM(5),ALFA(2:5)
      DIMENSION U1(13),U2(13),U3(13),U4(12),U5(13),U6(13),U7( 8),U8(13)
      DIMENSION V1(12),V2(12),V3(13),V4(12),V5(13),V6(13),V7(11),V8(11)
      DIMENSION W1(13),W2(11),W3(13),W4(13),W5(13),W6(13),       W8( 8)
 
      DATA FNINV /1, 0.5, 0.33333333, 0.25, 0.2/
 
      DATA (EDGEC(J),J=2,7)
     1/ 0.16666667E+0, 0.41666667E-1, 0.83333333E-2,
     2  0.13888889E-1, 0.69444444E-2, 0.77160493E-3/
 
      DATA (U1(K),K=1,13)
     1/ 0.25850868E+0,  0.32477982E-1, -0.59020496E-2,
     2  0.            , 0.24880692E-1,  0.47404356E-2,
     3 -0.74445130E-3,  0.73225731E-2,  0.           ,
     4  0.11668284E-2,  0.           , -0.15727318E-2,-0.11210142E-2/
 
      DATA (U2(K),K=1,13)
     1/ 0.43142611E+0,  0.40797543E-1, -0.91490215E-2,
     2  0.           ,  0.42127077E-1,  0.73167928E-2,
     3 -0.14026047E-2,  0.16195241E-1,  0.24714789E-2,
     4  0.20751278E-2,  0.           , -0.25141668E-2,-0.14064022E-2/
 
      DATA (U3(K),K=1,13)
     1/ 0.25225955E+0,  0.64820468E-1, -0.23615759E-1,
     2  0.           ,  0.23834176E-1,  0.21624675E-2,
     3 -0.26865597E-2, -0.54891384E-2,  0.39800522E-2,
     4  0.48447456E-2, -0.89439554E-2, -0.62756944E-2,-0.24655436E-2/
 
      DATA (U4(K),K=1,12)
     1/ 0.12593231E+1, -0.20374501E+0,  0.95055662E-1,
     2 -0.20771531E-1, -0.46865180E-1, -0.77222986E-2,
     3  0.32241039E-2,  0.89882920E-2, -0.67167236E-2,
     4 -0.13049241E-1,  0.18786468E-1,  0.14484097E-1/
 
      DATA (U5(K),K=1,13)
     1/-0.24864376E-1, -0.10368495E-2,  0.14330117E-2,
     2  0.20052730E-3,  0.18751903E-2,  0.12668869E-2,
     3  0.48736023E-3,  0.34850854E-2,  0.           ,
     4 -0.36597173E-3,  0.19372124E-2,  0.70761825E-3, 0.46898375E-3/
 
      DATA (U6(K),K=1,13)
     1/ 0.35855696E-1, -0.27542114E-1,  0.12631023E-1,
     2 -0.30188807E-2, -0.84479939E-3,  0.           ,
     3  0.45675843E-3, -0.69836141E-2,  0.39876546E-2,
     4 -0.36055679E-2,  0.           ,  0.15298434E-2, 0.19247256E-2/
 
      DATA (U7(K),K=1,8)
     1/ 0.10234691E+2, -0.35619655E+1,  0.69387764E+0,
     2 -0.14047599E+0, -0.19952390E+1, -0.45679694E+0,
     3  0.           ,  0.50505298E+0/
 
      DATA (U8(K),K=1,13)
     1/ 0.21487518E+2, -0.11825253E+2,  0.43133087E+1,
     2 -0.14500543E+1, -0.34343169E+1, -0.11063164E+1,
     3 -0.21000819E+0,  0.17891643E+1, -0.89601916E+0,
     4  0.39120793E+0,  0.73410606E+0,  0.           ,-0.32454506E+0/
 
      DATA (V1(K),K=1,12)
     1/ 0.27827257E+0, -0.14227603E-2,  0.24848327E-2,
     2  0.           ,  0.45091424E-1,  0.80559636E-2,
     3 -0.38974523E-2,  0.           , -0.30634124E-2,
     4  0.75633702E-3,  0.54730726E-2,  0.19792507E-2/
 
      DATA (V2(K),K=1,12)
     1/ 0.41421789E+0, -0.30061649E-1,  0.52249697E-2,
     2  0.           ,  0.12693873E+0,  0.22999801E-1,
     3 -0.86792801E-2,  0.31875584E-1, -0.61757928E-2,
     4  0.           ,  0.19716857E-1,  0.32596742E-2/
 
      DATA (V3(K),K=1,13)
     1/ 0.20191056E+0, -0.46831422E-1,  0.96777473E-2,
     2 -0.17995317E-2,  0.53921588E-1,  0.35068740E-2,
     3 -0.12621494E-1, -0.54996531E-2, -0.90029985E-2,
     4  0.34958743E-2,  0.18513506E-1,  0.68332334E-2,-0.12940502E-2/
 
      DATA (V4(K),K=1,12)
     1/ 0.13206081E+1,  0.10036618E+0, -0.22015201E-1,
     2  0.61667091E-2, -0.14986093E+0, -0.12720568E-1,
     3  0.24972042E-1, -0.97751962E-2,  0.26087455E-1,
     4 -0.11399062E-1, -0.48282515E-1, -0.98552378E-2/
 
      DATA (V5(K),K=1,13)
     1/ 0.16435243E-1,  0.36051400E-1,  0.23036520E-2,
     2 -0.61666343E-3, -0.10775802E-1,  0.51476061E-2,
     3  0.56856517E-2, -0.13438433E-1,  0.           ,
     4  0.           , -0.25421507E-2,  0.20169108E-2,-0.15144931E-2/
 
      DATA (V6(K),K=1,13)
     1/ 0.33432405E-1,  0.60583916E-2, -0.23381379E-2,
     2  0.83846081E-3, -0.13346861E-1, -0.17402116E-2,
     3  0.21052496E-2,  0.15528195E-2,  0.21900670E-2,
     4 -0.13202847E-2, -0.45124157E-2, -0.15629454E-2, 0.22499176E-3/
 
      DATA (V7(K),K=1,11)
     1/ 0.54529572E+1, -0.90906096E+0,  0.86122438E-1,
     2  0.           , -0.12218009E+1, -0.32324120E+0,
     3 -0.27373591E-1,  0.12173464E+0,  0.           ,
     4  0.           ,  0.40917471E-1/
 
      DATA (V8(K),K=1,11)
     1/ 0.93841352E+1, -0.16276904E+1,  0.16571423E+0,
     2  0.           , -0.18160479E+1, -0.50919193E+0,
     3 -0.51384654E-1,  0.21413992E+0,  0.           ,
     4  0.           ,  0.66596366E-1/
 
      DATA (W1(K),K=1,13)
     1/ 0.29712951E+0,  0.97572934E-2,  0.           ,
     2 -0.15291686E-2,  0.35707399E-1,  0.96221631E-2,
     3 -0.18402821E-2, -0.49821585E-2,  0.18831112E-2,
     4  0.43541673E-2,  0.20301312E-2, -0.18723311E-2,-0.73403108E-3/
 
      DATA (W2(K),K=1,11)
     1/ 0.40882635E+0,  0.14474912E-1,  0.25023704E-2,
     2 -0.37707379E-2,  0.18719727E+0,  0.56954987E-1,
     3  0.           ,  0.23020158E-1,  0.50574313E-2,
     4  0.94550140E-2,  0.19300232E-1/
 
      DATA (W3(K),K=1,13)
     1/ 0.16861629E+0,  0.           ,  0.36317285E-2,
     2 -0.43657818E-2,  0.30144338E-1,  0.13891826E-1,
     3 -0.58030495E-2, -0.38717547E-2,  0.85359607E-2,
     4  0.14507659E-1,  0.82387775E-2, -0.10116105E-1,-0.55135670E-2/
 
      DATA (W4(K),K=1,13)
     1/ 0.13493891E+1, -0.26863185E-2, -0.35216040E-2,
     2  0.24434909E-1, -0.83447911E-1, -0.48061360E-1,
     3  0.76473951E-2,  0.24494430E-1, -0.16209200E-1,
     4 -0.37768479E-1, -0.47890063E-1,  0.17778596E-1, 0.13179324E-1/
 
      DATA (W5(K),K=1,13)
     1/ 0.10264945E+0,  0.32738857E-1,  0.           ,
     2  0.43608779E-2, -0.43097757E-1, -0.22647176E-2,
     3  0.94531290E-2, -0.12442571E-1, -0.32283517E-2,
     4 -0.75640352E-2, -0.88293329E-2,  0.52537299E-2, 0.13340546E-2/
 
      DATA (W6(K),K=1,13)
     1/ 0.29568177E-1, -0.16300060E-2, -0.21119745E-3,
     2  0.23599053E-2, -0.48515387E-2, -0.40797531E-2,
     3  0.40403265E-3,  0.18200105E-2, -0.14346306E-2,
     4 -0.39165276E-2, -0.37432073E-2,  0.19950380E-2, 0.12222675E-2/
 
      DATA (W8(K),K=1,8)
     1/ 0.66184645E+1, -0.73866379E+0,  0.44693973E-1,
     2  0.           , -0.14540925E+1, -0.39529833E+0,
     3 -0.44293243E-1,  0.88741049E-1/
 
      GVAVIV=0
      IF(RKAPPA .LT. 0.01 .OR. RKAPPA .GT. 12) RETURN
      IF(RKAPPA .GE. 0.29) THEN
       ITYPE=1
       NPT=100
       WK=1/SQRT(RKAPPA)
       AC(0)=(-0.032227*BETA2-0.074275)*RKAPPA+
     1   (0.24533*BETA2+0.070152)*WK+(-0.55610*BETA2-3.1579)
       AC(8)=(-0.013483*BETA2-0.048801)*RKAPPA+
     1   (-1.6921*BETA2+8.3656)*WK+(-0.73275*BETA2-3.5226)
       DRK(1)=WK**2
       DSIGM(1)=SQRT(RKAPPA/(1-0.5*BETA2))
       DO 1 J = 1,4
       DRK(J+1)=DRK(1)*DRK(J)
       DSIGM(J+1)=DSIGM(1)*DSIGM(J)
    1  ALFA(J+1)=(FNINV(J)-BETA2*FNINV(J+1))*DRK(J)
 
       HC(0)=LOG(RKAPPA)+BETA2+0.42278434
       HC(1)=DSIGM(1)
       HC(2)=ALFA(3)*DSIGM(3)
       HC(3)=(3*ALFA(2)**2+ALFA(4))*DSIGM(4)-3
       HC(4)=(10*ALFA(2)*ALFA(3)+ALFA(5))*DSIGM(5)-10*HC(2)
       HC(5)=HC(2)**2
       HC(6)=HC(2)*HC(3)
       HC(7)=HC(2)*HC(5)
       DO 2 J = 2,7
    2  HC(J)=EDGEC(J)*HC(J)
       HC(8)=0.39894228*HC(1)
      ELSEIF(RKAPPA .GE. 0.22) THEN
       ITYPE=2
       NPT=150
       X=1+(RKAPPA-BKMXX3)*FBKX3
       Y=1+(SQRT(BETA2)-BKMXY3)*FBKY3
       XX=2*X
       YY=2*Y
       X2=XX*X-1
       X3=XX*X2-X
       Y2=YY*Y-1
       Y3=YY*Y2-Y
       XY=X*Y
       P2=X2*Y
       P3=X3*Y
       Q2=Y2*X
       Q3=Y3*X
       PQ=X2*Y2
       AC(1)=W1(1)+W1(2)*X+W1(4)*X3+W1(5)*Y+W1(6)*Y2+W1(7)*Y3+
     1  W1(8)*XY+W1(9)*P2+W1(10)*P3+W1(11)*Q2+W1(12)*Q3+W1(13)*PQ
       AC(2)=W2(1)+W2(2)*X+W2(3)*X2+W2(4)*X3+W2(5)*Y+W2(6)*Y2+
     1  W2(8)*XY+W2(9)*P2+W2(10)*P3+W2(11)*Q2
       AC(3)=W3(1)+W3(3)*X2+W3(4)*X3+W3(5)*Y+W3(6)*Y2+W3(7)*Y3+
     1  W3(8)*XY+W3(9)*P2+W3(10)*P3+W3(11)*Q2+W3(12)*Q3+W3(13)*PQ
       AC(4)=W4(1)+W4(2)*X+W4(3)*X2+W4(4)*X3+W4(5)*Y+W4(6)*Y2+W4(7)*Y3+
     1  W4(8)*XY+W4(9)*P2+W4(10)*P3+W4(11)*Q2+W4(12)*Q3+W4(13)*PQ
       AC(5)=W5(1)+W5(2)*X+W5(4)*X3+W5(5)*Y+W5(6)*Y2+W5(7)*Y3+
     1  W5(8)*XY+W5(9)*P2+W5(10)*P3+W5(11)*Q2+W5(12)*Q3+W5(13)*PQ
       AC(6)=W6(1)+W6(2)*X+W6(3)*X2+W6(4)*X3+W6(5)*Y+W6(6)*Y2+W6(7)*Y3+
     1  W6(8)*XY+W6(9)*P2+W6(10)*P3+W6(11)*Q2+W6(12)*Q3+W6(13)*PQ
       AC(8)=W8(1)+W8(2)*X+W8(3)*X2+W8(5)*Y+W8(6)*Y2+W8(7)*Y3+W8(8)*XY
       AC(0)=-3.05
      ELSEIF(RKAPPA .GE. 0.12) THEN
       ITYPE=3
       NPT=200
       X=1+(RKAPPA-BKMXX2)*FBKX2
       Y=1+(SQRT(BETA2)-BKMXY2)*FBKY2
       XX=2*X
       YY=2*Y
       X2=XX*X-1
       X3=XX*X2-X
       Y2=YY*Y-1
       Y3=YY*Y2-Y
       XY=X*Y
       P2=X2*Y
       P3=X3*Y
       Q2=Y2*X
       Q3=Y3*X
       PQ=X2*Y2
       AC(1)=V1(1)+V1(2)*X+V1(3)*X2+V1(5)*Y+V1(6)*Y2+V1(7)*Y3+
     1  V1(9)*P2+V1(10)*P3+V1(11)*Q2+V1(12)*Q3
       AC(2)=V2(1)+V2(2)*X+V2(3)*X2+V2(5)*Y+V2(6)*Y2+V2(7)*Y3+
     1  V2(8)*XY+V2(9)*P2+V2(11)*Q2+V2(12)*Q3
       AC(3)=V3(1)+V3(2)*X+V3(3)*X2+V3(4)*X3+V3(5)*Y+V3(6)*Y2+V3(7)*Y3+
     1  V3(8)*XY+V3(9)*P2+V3(10)*P3+V3(11)*Q2+V3(12)*Q3+V3(13)*PQ
       AC(4)=V4(1)+V4(2)*X+V4(3)*X2+V4(4)*X3+V4(5)*Y+V4(6)*Y2+V4(7)*Y3+
     1  V4(8)*XY+V4(9)*P2+V4(10)*P3+V4(11)*Q2+V4(12)*Q3
       AC(5)=V5(1)+V5(2)*X+V5(3)*X2+V5(4)*X3+V5(5)*Y+V5(6)*Y2+V5(7)*Y3+
     1  V5(8)*XY+V5(11)*Q2+V5(12)*Q3+V5(13)*PQ
       AC(6)=V6(1)+V6(2)*X+V6(3)*X2+V6(4)*X3+V6(5)*Y+V6(6)*Y2+V6(7)*Y3+
     1  V6(8)*XY+V6(9)*P2+V6(10)*P3+V6(11)*Q2+V6(12)*Q3+V6(13)*PQ
       AC(7)=V7(1)+V7(2)*X+V7(3)*X2+V7(5)*Y+V7(6)*Y2+V7(7)*Y3+
     1  V7(8)*XY+V7(11)*Q2
       AC(8)=V8(1)+V8(2)*X+V8(3)*X2+V8(5)*Y+V8(6)*Y2+V8(7)*Y3+
     1  V8(8)*XY+V8(11)*Q2
       AC(0)=-3.04
      ELSE
       ITYPE=4
       IF(RKAPPA .GE. 0.02) ITYPE=3
       NPT=200
       X=1+(RKAPPA-BKMXX1)*FBKX1
       Y=1+(SQRT(BETA2)-BKMXY1)*FBKY1
       XX=2*X
       YY=2*Y
       X2=XX*X-1
       X3=XX*X2-X
       Y2=YY*Y-1
       Y3=YY*Y2-Y
       XY=X*Y
       P2=X2*Y
       P3=X3*Y
       Q2=Y2*X
       Q3=Y3*X
       PQ=X2*Y2
       IF(ITYPE .EQ. 4) GO TO 4
       AC(1)=U1(1)+U1(2)*X+U1(3)*X2+U1(5)*Y+U1(6)*Y2+U1(7)*Y3+
     1  U1(8)*XY+U1(10)*P3+U1(12)*Q3+U1(13)*PQ
       AC(2)=U2(1)+U2(2)*X+U2(3)*X2+U2(5)*Y+U2(6)*Y2+U2(7)*Y3+
     1  U2(8)*XY+U2(9)*P2+U2(10)*P3+U2(12)*Q3+U2(13)*PQ
       AC(3)=U3(1)+U3(2)*X+U3(3)*X2+U3(5)*Y+U3(6)*Y2+U3(7)*Y3+
     1  U3(8)*XY+U3(9)*P2+U3(10)*P3+U3(11)*Q2+U3(12)*Q3+U3(13)*PQ
       AC(4)=U4(1)+U4(2)*X+U4(3)*X2+U4(4)*X3+U4(5)*Y+U4(6)*Y2+U4(7)*Y3+
     1  U4(8)*XY+U4(9)*P2+U4(10)*P3+U4(11)*Q2+U4(12)*Q3
       AC(5)=U5(1)+U5(2)*X+U5(3)*X2+U5(4)*X3+U5(5)*Y+U5(6)*Y2+U5(7)*Y3+
     1  U5(8)*XY+U5(10)*P3+U5(11)*Q2+U5(12)*Q3+U5(13)*PQ
       AC(6)=U6(1)+U6(2)*X+U6(3)*X2+U6(4)*X3+U6(5)*Y+U6(7)*Y3+
     1  U6(8)*XY+U6(9)*P2+U6(10)*P3+U6(12)*Q3+U6(13)*PQ
    4  AC(7)=U7(1)+U7(2)*X+U7(3)*X2+U7(4)*X3+U7(5)*Y+U7(6)*Y2+U7(8)*XY
       AC(8)=U8(1)+U8(2)*X+U8(3)*X2+U8(4)*X3+U8(5)*Y+U8(6)*Y2+U8(7)*Y3+
     1  U8(8)*XY+U8(9)*P2+U8(10)*P3+U8(11)*Q2+U8(13)*PQ
       AC(0)=-3.03
      ENDIF
      AC(9)=(AC(8)-AC(0))/NPT
      IF(ITYPE .EQ. 3) THEN
       X=(AC(7)-AC(8))/(AC(7)*AC(8))
       Y=1/LOG(AC(8)/AC(7))
       P2=AC(7)**2
       AC(11)=P2*(AC(1)*EXP(-AC(2)*(AC(7)+AC(5)*P2)-
     1            AC(3)*EXP(-AC(4)*(AC(7)+AC(6)*P2)))-0.045*Y/AC(7))/
     2            (1+X*Y*AC(7))
       AC(12)=(0.045+X*AC(11))*Y
      ENDIF
      IF(ITYPE .EQ. 4) AC(10)=0.995/GLANDS(AC(8))
 
      T=2*RAN/AC(9)
      RLAM=AC(0)
      FL=0
      S=0
      DO 21 N = 1,NPT
      RLAM=RLAM+AC(9)
      IF(ITYPE .EQ. 1) THEN
       FN=1
       X=(RLAM+HC(0))*HC(1)
       H(1)=X
       H(2)=X**2-1
       DO 31 K = 2,8
       FN=FN+1
   31  H(K+1)=X*H(K)-FN*H(K-1)
       Y=1+HC(7)*H(9)
       DO 32 K = 2,6
   32  Y=Y+HC(K)*H(K+1)
       FU=HC(8)*EXP(-0.5*X**2)*MAX(Y,0.)
      ELSEIF(ITYPE .EQ. 2) THEN
       X=RLAM**2
       FU=AC(1)*EXP(-AC(2)*(RLAM+AC(5)*X)-
     1    AC(3)*EXP(-AC(4)*(RLAM+AC(6)*X)))
      ELSEIF(ITYPE .EQ. 3) THEN
       IF(RLAM .LT. AC(7)) THEN
        X=RLAM**2
        FU=AC(1)*EXP(-AC(2)*(RLAM+AC(5)*X)-
     1     AC(3)*EXP(-AC(4)*(RLAM+AC(6)*X)))
       ELSE
        X=1/RLAM
        FU=(AC(11)*X+AC(12))*X
       ENDIF
      ELSE
       FU=AC(10)*GLANDE(RLAM)
      ENDIF
      S=S+FL+FU
      IF(S .GT. T) GO TO 22
   21 FL=FU
 
   22 S0=S-FL-FU
      GVAVIV=RLAM-AC(9)
      IF(S .GT. S0) GVAVIV=GVAVIV+AC(9)*(T-S0)/(S-S0)
      RETURN
      END
+DECK,gvrot.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GVROT(DCOSIN,PART)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Rotates vector from one reference system into another         *
C.    *  defined by the direction cosines contained in the vector      *
C.    *  DCOSIN. The input vector PART is overwritten.                 *
C.    *                                                                *
C.    *    ==>Called by :                                              *
C.    *       Author    F.Carminati **********                         *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION PART(*),DCOSIN(*)
+SELF,IF=-SINGLE
      DOUBLE PRECISION DUX,DUY,DUZ,SINTH2,ONE,COSTH,SINTH,COSPH,SINPH
      DOUBLE PRECISION DNORM
+SELF
      LOGICAL ROTATE
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      DUX      = DCOSIN(1)
      DUY      = DCOSIN(2)
      DUZ      = DCOSIN(3)
      ROTATE   = .TRUE.
      IF(ABS(DUZ).GE.0.85) THEN
         SINTH2=DUX**2+DUY**2
         IF(SINTH2.GT.0.) THEN
            COSTH  = SIGN(ONE,DUZ)*SQRT(ONE-SINTH2)
            SINTH  = SQRT(SINTH2)
            COSPH  = DUX/SINTH
            SINPH  = DUY/SINTH
         ELSEIF(DUZ.GT.0.)THEN
            ROTATE = .FALSE.
         ELSE
            COSTH = -1.
            SINTH =  0.
            COSPH =  1.
            SINPH =  0.
         ENDIF
      ELSE
         COSTH  = DUZ
         SINTH  = SQRT((ONE+DUZ)*(ONE-DUZ))
         DNORM  = ONE/SQRT(DUX**2+DUY**2)
         COSPH  = DUX*DNORM
         SINPH  = DUY*DNORM
      ENDIF
*
      IF(ROTATE) THEN
         P1=PART(1)
         P2=PART(2)
         P3=PART(3)
         PART(1)= P1*COSTH*COSPH - P2*SINPH + P3*SINTH*COSPH
         PART(2)= P1*COSTH*SINPH + P2*COSPH + P3*SINTH*SINPH
         PART(3)=-P1*SINTH                  + P3*COSTH
      ENDIF
C
      END
+DECK,GHSIGM
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      FUNCTION GHSIGM(P,IPART,A)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Returns absorption cross-section in millibarns               *
C.    *   for a particle with                                          *
C.    *                momentum P (GEV/C)                              *
C.    *                GEANT type IPART                                *
C.    *      on a nucleus of atomic number A                           *
C.    *                                                                *
C.    *    ==>Called by : GPHADR                                       *
C.    *       Author    R.Barlow  *********                            *
C.    *       Modified to deal with K0 and extend to 41 particle       *
C.    *                types by John Allison, 31/1/84. *               *
C.    *                                                                *
C.    ******************************************************************
C.
C              The array NTYPE maps the GEANT particle type (IPART)
C              onto GHSIG's internal particle type.  Simple assumptions
C              are made for highly flavoured particles.  The K0 is
C              given a non-existent internal type 6 which causes the
C              mean of the K+ and K- cross sections to be calculated.
C
      DIMENSION NTYPE(41)
      DATA NTYPE/6*0,3*5,6,3,4,2*1,2,6,
     +  8*1,8*2,2*0,4,3,2*6,2*3,1/
C.
C.    ------------------------------------------------------------------
C.
      GHSIGM = 1.E-20
      IF (IPART .GT. 41) RETURN
      ITYPE  = NTYPE(IPART)
      IF (ITYPE .EQ. 0) RETURN
C
      IF (ITYPE .NE. 6)THEN
         GHSIGM = GHSIG(P, ITYPE, A)
      ELSE
         GHSIGM = 0.5 * (GHSIG(P, 3, A) + GHSIG(P, 4, A))
      ENDIF
C
      END
+DECK,GHSIG
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      FUNCTION GHSIG(P,ITYPE,A)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Returns absorption cross-section in millibarns               *
C.    *   for a particle with                                          *
C.    *                momentum P (GEV/C)                              *
C.    *                type ITYPE                                      *
C.    *      on a nucleus of atomic number A                           *
C.    *                                                                *
C.    *    ==>Called by : GHSIGM                                       *
C.    *       Author    R.Barlow  *********                            *
C.    *                                                                *
C.    ******************************************************************
C
C              The internal particle types are as follows...
C                1 proton
C                2 antiproton
C                3 K+
C                4 K-
C                5 pion
C
      DIMENSION SIGB(100),ALPHA(100),SIG(162,5)
      DIMENSION SIGPR(162,1),SIGPB(162,1),SIGKP(162,1),SIGKM(162,1)
      DIMENSION SIGPI(162,1)
      EQUIVALENCE (SIGPR(1,1),SIG(1,1)),(SIGPB(1,1),SIG(1,2))
      EQUIVALENCE (SIGKP(1,1),SIG(1,3)),(SIGKM(1,1),SIG(1,4))
      EQUIVALENCE (SIGPI(1,1),SIG(1,5))
C
           DATA ALPHA/
     +  0.9826,0.9659,0.9500,0.9348,0.9203,0.9064,0.8932,0.8807,0.8687,
     +  0.8574,0.8466,0.8363,0.8265,0.8172,0.8084,0.8000,0.7921,0.7845,
     +  0.7773,0.7705,0.7640,0.7579,0.7520,0.7464,0.7411,0.7361,0.7313,
     +  0.7267,0.7224,0.7182,0.7142,0.7105,0.7069,0.7034,0.7001,0.6970,
     +  0.6939,0.6911,0.6883,0.6856,0.6831,0.6807,0.6783,0.6761,0.6739,
     +  0.6718,0.6698,0.6679,0.6660,0.6642,0.6625,0.6609,0.6592,0.6577,
     +  0.6562,0.6547,0.6533,0.6519,0.6506,0.6493,0.6481,0.6469,0.6457,
     +  0.6446,0.6435,0.6424,0.6413,0.6403,0.6393,0.6384,0.6374,0.6365,
     +  0.6356,0.6347,0.6339,0.6330,0.6322,0.6314,0.6307,0.6299,0.6292,
     +  0.6284,0.6277,0.6270,0.6263,0.6257,0.6250,0.6244,0.6237,0.6231,
     +  0.6225,0.6219,0.6213,0.6208,0.6202,0.6197,0.6191,0.6186,0.6181,
     +  0.6175/
           DATA SIGB/
     +    1.02,  2.10,  3.21,  4.36,  5.54,  6.75,  7.99,  9.24, 10.51,
     +   11.79, 13.08, 14.37, 15.66, 16.95, 18.22, 19.49, 20.75, 21.99,
     +   23.22, 24.43, 25.62, 26.79, 27.93, 29.06, 30.16, 31.24, 32.30,
     +   33.33, 34.34, 35.32, 36.29, 37.22, 38.14, 39.03, 39.91, 40.75,
     +   41.58, 42.39, 43.18, 43.95, 44.70, 45.43, 46.14, 46.83, 47.51,
     +   48.17, 48.82, 49.45, 50.06, 50.66, 51.25, 51.83, 52.39, 52.93,
     +   53.47, 53.99, 54.51, 55.01, 55.50, 55.98, 56.45, 56.92, 57.37,
     +   57.81, 58.25, 58.68, 59.10, 59.51, 59.91, 60.31, 60.70, 61.08,
     +   61.46, 61.83, 62.19, 62.55, 62.90, 63.25, 63.59, 63.93, 64.26,
     +   64.58, 64.90, 65.22, 65.53, 65.84, 66.14, 66.44, 66.74, 67.03,
     +   67.31, 67.60, 67.88, 68.15, 68.42, 68.69, 68.96, 69.22, 69.48,
     +   69.74/
       DATA SIGPR /
     +  79.01, 76.05, 73.81, 71.75, 69.67, 66.70, 64.89, 63.09, 60.58,
     +  58.99, 57.49, 56.09, 54.02, 52.75, 51.54, 50.39, 48.78, 47.79,
     +  46.86, 45.99, 44.73, 43.97, 43.25, 42.59, 41.59, 40.99, 40.41,
     +  39.85, 38.88, 38.26, 37.67, 37.06, 36.31, 35.82, 35.37, 35.00,
     +  34.40, 34.03, 33.71, 33.45, 33.00, 32.72, 32.50, 32.31, 32.01,
     +  31.84, 31.69, 31.56, 31.38, 31.29, 31.17, 31.09, 31.17, 31.34,
     +  31.61, 31.87, 32.62, 33.16, 33.84, 34.62, 35.85, 36.67, 37.51,
     +  38.72, 39.52, 40.29, 41.00, 41.97, 42.54, 43.01, 43.38, 43.82,
     +  44.01, 44.14, 44.24, 44.34, 44.38, 44.40, 44.40, 44.36, 44.33,
     +  44.28, 44.21, 44.07, 43.96, 43.84, 43.71, 43.48, 43.33, 43.17,
     +  43.02, 42.79, 42.64, 42.49, 42.36, 42.16, 42.05, 41.94, 41.85,
     +  41.71, 41.63, 41.54, 41.46, 41.35, 41.27, 41.20, 41.13, 41.02,
     +  40.95, 40.88, 40.81, 40.72, 40.66, 40.61, 40.57, 40.49, 40.44,
     +  40.37, 40.30, 40.19, 40.11, 40.04, 39.92, 39.84, 39.76, 39.69,
     +  39.57, 39.51, 39.45, 39.40, 39.32, 39.26, 39.21, 39.16, 39.09,
     +  39.05, 39.01, 38.98, 38.93, 38.90, 38.88, 38.85, 38.82, 38.81,
     +  38.79, 38.77, 38.75, 38.73, 38.72, 38.70, 38.68, 38.66, 38.65,
     +  38.64, 38.62, 38.60, 38.59, 38.57, 38.55, 38.53, 38.51, 38.49/
       DATA SIGPB /
     + 505.81,485.41,470.03,455.70,441.22,420.60,407.94,395.19,377.36,
     + 366.03,355.16,345.07,329.94,320.60,311.79,303.19,291.17,283.77,
     + 276.68,270.09,260.15,254.24,248.43,243.19,234.87,229.91,225.10,
     + 220.26,213.46,209.12,204.98,200.98,195.36,191.56,187.98,184.49,
     + 179.41,176.04,172.86,169.81,165.19,162.28,159.35,156.55,152.41,
     + 149.95,147.59,145.11,141.66,139.59,137.45,135.41,132.43,130.53,
     + 128.59,126.81,124.18,122.54,120.90,119.34,117.13,115.67,114.22,
     + 112.04,110.54,109.13,107.70,105.63,104.23,102.97,101.64, 99.62,
     +  98.30, 96.99, 95.81, 93.97, 92.88, 91.80, 90.69, 89.03, 87.97,
     +  86.92, 85.89, 84.36, 83.38, 82.39, 81.40, 79.89, 78.92, 77.95,
     +  76.96, 75.50, 74.59, 73.68, 72.81, 71.51, 70.73, 69.95, 69.19,
     +  68.07, 67.39, 66.71, 66.04, 65.13, 64.54, 63.99, 63.42, 62.55,
     +  62.05, 61.52, 61.02, 60.23, 59.74, 59.27, 58.79, 58.07, 57.64,
     +  57.20, 56.77, 56.10, 55.66, 55.23, 54.41, 53.90, 53.42, 52.94,
     +  52.20, 51.73, 51.30, 50.85, 50.20, 49.79, 49.47, 49.16, 48.72,
     +  48.46, 48.15, 47.84, 47.42, 47.17, 46.92, 46.68, 46.31, 46.12,
     +  45.90, 45.70, 45.42, 45.28, 45.13, 44.99, 44.80, 44.68, 44.58,
     +  44.48, 44.35, 44.28, 44.21, 44.15, 44.06, 44.00, 43.95, 43.90/
       DATA SIGKP /
     +   9.05,  8.86,  8.71,  8.58,  8.45,  8.28,  8.19,  8.11,  8.02,
     +   7.97,  7.94,  7.92,  7.90,  7.91,  7.92,  7.95,  8.01,  8.05,
     +   8.10,  8.17,  8.28,  8.37,  8.47,  8.56,  8.74,  8.86,  8.98,
     +   9.13,  9.35,  9.51,  9.66,  9.83, 10.10, 10.27, 10.45, 10.63,
     +  10.89, 11.07, 11.24, 11.40, 11.65, 11.81, 11.96, 12.12, 12.37,
     +  12.54, 12.71, 12.87, 13.19, 13.43, 13.70, 13.99, 14.49, 14.87,
     +  15.28, 15.71, 16.37, 16.79, 17.19, 17.57, 18.05, 18.30, 18.49,
     +  18.68, 18.74, 18.76, 18.75, 18.69, 18.63, 18.57, 18.50, 18.39,
     +  18.34, 18.29, 18.25, 18.18, 18.14, 18.09, 18.05, 17.98, 17.92,
     +  17.87, 17.81, 17.72, 17.66, 17.62, 17.59, 17.55, 17.52, 17.49,
     +  17.46, 17.44, 17.43, 17.42, 17.41, 17.41, 17.40, 17.40, 17.40,
     +  17.40, 17.40, 17.40, 17.40, 17.41, 17.41, 17.42, 17.42, 17.43,
     +  17.43, 17.44, 17.44, 17.45, 17.45, 17.46, 17.47, 17.48, 17.48,
     +  17.48, 17.49, 17.49, 17.50, 17.50, 17.50, 17.49, 17.49, 17.49,
     +  17.49, 17.50, 17.50, 17.50, 17.51, 17.52, 17.54, 17.55, 17.58,
     +  17.60, 17.62, 17.63, 17.66, 17.68, 17.70, 17.73, 17.76, 17.79,
     +  17.81, 17.83, 17.87, 17.90, 17.92, 17.95, 17.99, 18.01, 18.03,
     +  18.06, 18.10, 18.13, 18.16, 18.19, 18.23, 18.26, 18.29, 18.33/
       DATA SIGKM /
     +  76.56, 74.23, 72.44, 70.86, 69.28, 66.99, 65.66, 64.35, 62.47,
     +  61.33, 60.23, 59.18, 57.65, 56.68, 55.73, 54.78, 53.21, 52.17,
     +  51.31, 50.48, 49.27, 48.55, 47.89, 47.30, 46.48, 45.91, 45.31,
     +  44.74, 43.78, 43.13, 42.48, 41.77, 40.57, 39.85, 39.01, 38.22,
     +  37.05, 36.34, 35.66, 35.01, 34.23, 33.98, 33.73, 33.53, 33.26,
     +  33.24, 33.41, 33.68, 34.13, 34.53, 34.94, 35.52, 36.37, 37.02,
     +  37.58, 38.00, 38.11, 37.88, 37.44, 36.88, 35.77, 35.12, 34.34,
     +  33.26, 32.60, 31.91, 31.29, 30.54, 30.13, 29.77, 29.45, 29.03,
     +  28.80, 28.58, 28.35, 27.97, 27.70, 27.40, 27.10, 26.70, 26.48,
     +  26.29, 26.07, 25.73, 25.52, 25.31, 25.13, 24.86, 24.72, 24.57,
     +  24.42, 24.17, 24.01, 23.89, 23.77, 23.60, 23.49, 23.38, 23.29,
     +  23.14, 23.05, 22.97, 22.90, 22.79, 22.71, 22.64, 22.56, 22.45,
     +  22.37, 22.28, 22.20, 22.07, 21.99, 21.91, 21.82, 21.69, 21.61,
     +  21.53, 21.45, 21.34, 21.27, 21.20, 21.11, 21.06, 21.00, 20.95,
     +  20.87, 20.83, 20.80, 20.77, 20.71, 20.68, 20.65, 20.62, 20.57,
     +  20.54, 20.52, 20.50, 20.46, 20.43, 20.40, 20.38, 20.35, 20.32,
     +  20.30, 20.28, 20.25, 20.24, 20.23, 20.21, 20.20, 20.20, 20.19,
     +  20.19, 20.18, 20.18, 20.18, 20.17, 20.16, 20.15, 20.14, 20.12/
       DATA SIGPI /
     +   5.02,  5.69,  6.20,  6.81,  7.56,  9.29, 10.54, 12.24, 15.11,
     +  17.54, 20.45, 23.24, 28.67, 32.75, 37.60, 42.78, 52.32, 59.55,
     +  67.49, 75.47, 87.11, 94.75,101.54,106.41,111.56,113.00,112.73,
     + 110.52,105.96,101.22, 95.06, 88.38, 77.77, 70.51, 63.86, 57.83,
     +  49.65, 45.30, 41.45, 38.23, 34.33, 32.40, 30.86, 29.68, 28.76,
     +  28.61, 28.53, 28.41, 28.04, 27.81, 27.89, 28.24, 29.65, 31.04,
     +  32.53, 33.91, 34.81, 34.92, 35.12, 35.32, 35.83, 36.30, 36.71,
     +  36.93, 36.79, 36.49, 36.18, 35.80, 35.59, 35.35, 35.12, 34.65,
     +  34.26, 33.85, 33.46, 32.97, 32.75, 32.61, 32.51, 32.37, 32.25,
     +  32.12, 31.96, 31.67, 31.47, 31.25, 31.02, 30.67, 30.44, 30.21,
     +  29.98, 29.65, 29.44, 29.23, 29.03, 28.72, 28.52, 28.33, 28.14,
     +  27.85, 27.66, 27.47, 27.30, 27.04, 26.90, 26.76, 26.65, 26.51,
     +  26.43, 26.35, 26.28, 26.19, 26.13, 26.07, 26.02, 25.92, 25.85,
     +  25.78, 25.70, 25.58, 25.51, 25.43, 25.32, 25.25, 25.18, 25.11,
     +  25.01, 24.94, 24.87, 24.81, 24.72, 24.65, 24.59, 24.54, 24.46,
     +  24.41, 24.36, 24.32, 24.25, 24.21, 24.18, 24.14, 24.09, 24.06,
     +  24.03, 24.00, 23.96, 23.93, 23.91, 23.88, 23.84, 23.82, 23.80,
     +  23.78, 23.76, 23.74, 23.73, 23.73, 23.72, 23.72, 23.72, 23.73/
C
C             25.49675=1./LOG(1.04)
C
      X      = 25.49675 * LOG(P * 10.)
      N      = X
      DIFF   = X - N
      N      = N + 1
      IF (N .LE. 0) N = 1
      IF (N .GT. 162) N = 162
C
C             Interpolate in SIG tables.
C
      S      = SIG(N,ITYPE)
      IF (N.EQ.1 .OR. N.EQ.162) GO TO 50
      S = S + DIFF * (SIG(N + 1,ITYPE) - S)
  50  CONTINUE
C
C             NOW FIND ABUL-MAGD PARAMETERS
C
      IS     = S
      IF (IS.LE.0) IS = 1
      IF (IS.GE.100) IS = 99
      SB     = SIGB(IS) + (S - IS) * (SIGB(IS + 1) - SIGB(IS))
      AL     = ALPHA(IS) + (S - IS) * (ALPHA(IS + 1) - ALPHA(IS))
      GHSIG  = SB*A**AL
      END
+PATCH,GTRAK
+DECK,DOCGTRAK,IF=DOC
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                Introduction to the Tracking package                  *
*                ------------------------------------                  *
*                                                                      *
*                                                                      *
*  THE TRACKING PACKAGE                                                *
*                                                                      *
*  In  the context  of  simulation programs,  'tracking' a  particle   *
* through matter consists of predicting the spatial coordinates of a   *
* set of  points which  define the trajectory  and of  computing the   *
* components  of  the  momentum  at each  point.   This  is  usually   *
* achieved by integrating the  'equations of motion' over successive   *
* steps and applying  corrections when necessary to  account for the   *
* perturbations introduced by the interactions with matter.            *
*  The tracking package contains mainly a subprogram which controls,   *
* and effectively  performs, the transport  of all particles  in the   *
* current  event and  of  the secondary  products  which they  might   *
* possibly generate,  plus some  tools for  storing the  space point   *
* coordinates computed along the corresponding trajectories.           *
*                                                                      *
* THE STEP SIZE                                                        *
*                                                                      *
*  When tracking particles through a complex medium structure one of   *
* the critical tasks is the estimation  'a priori' of the step size.   *
* This is performed automatically by the program.                      *
*  For a particle with given  energy the step size depends primarily   *
* on the properties  of the particle (mass,  charge, lifetime, etc.)   *
* and of  the current medium in  which the particle is  moving.  The   *
* dependence may come either  from (quasi)continuous processes which   *
* usually  impose a  limit to  the interval  of integration  (energy   *
* loss, multiple scattering or bending  in magnetic field) or to the   *
* occurence of  a discrete process which  introduces a discontinuity   *
* in   the   trajectory    (decay,   electromagnetic   or   hadronic   *
* interaction).   In addition  to these  physical effects  there are   *
* constraints of a geometrical nature, the step being limited by the   *
* path length to the medium boundary.                                  *
*  In  practice,  the step  size  depends  ultimately  on a  set  of   *
* tolerances and cuts which should be  optimized by the user for the   *
* given application, such as:                                          *
*                                                                      *
* - the maximum bending angle due to magnetic field permitted in one   *
*   step,                                                              *
* - the maximum fractional energy loss in one step,                    *
* - the  maximum  step size  permitted  by  the multiple  scattering   *
*   theory used                                                        *
* - the accuracy for crossing medium boundaries and                    *
* - the absolute maximum step allowed                                  *
*                                                                      *
*  The limitations imposed  by the first three  processes could lead   *
* to extremely small steps for low energy particles.  To avoid this,   *
* in  GEANT has  been introduced  a minimum  step due  to continuous   *
* processes.   This represent  a lower  bound for  the maximum  step   *
* which is very important for keeping  the time taken to develop and   *
* follow a shower within reasonable limits.                            *
*                                                                      *
*  These  quantities are  part of  the so  called 'tracking  medium'   *
* parameters.  They  are usually calculated automatically  by GEANT,   *
* but may be provided by the user to be stored in the data structure   *
* JTMED, through the  routine GSTMED [CONS].  Usually,  this is done   *
* together with the initialisation  of the geometrical setup.  Users   *
* are  suggested   to  begin  their  simulations   with  the  values   *
* calculated by GEANT.   The optimisation is by no  means trivial as   *
* the economy of  computing time should not lead  to an unacceptable   *
* loss of accuracy.                                                    *
*  Other  general information  required for  the computation  of the   *
* step size is expected to be available in the data structures JPART   *
* and  JMATE,  for  the  properties  of the  particles  and  of  the   *
* materials,  and in  the  data structure  JVOLUM,  for the  current   *
* medium and its geometrical  boundaries.  The communication between   *
* the tracking package and the  structure JVOLUM is achieved through   *
* the  basic subroutines  of the  geometry package  GMEDIA (GTMEDI),   *
* GNEXT (GTNEXT) and GINVOL [GEOM,GTRAK]                               *
*  Some additional information is computed  at tracking time such as   *
* the probability  of occurence of an  interaction.  For convenience   *
* every particle is assigned a 'tracking  type', 1 for the gammas, 2   *
* for the  electrons and positrons,  3 for the neutral  hadrons (and   *
* neutrinos!), 4 for the charged hadrons and 5 for the muons.  Which   *
* physics processes  have potentially to  be considered for  a given   *
* particle depends on its tracking type.  For the hadrons it depends   *
* also, through  the subroutine GUPHAD, on  which hadronic processes   *
* have been selected (GHEISHA is the default) [PHYS 001].              *
*                                                                      *
* THE SUBROUTINES GTREVE and  GTRACK                                   *
*                                                                      *
*  At  event level  the  tracking is  controlled  by the  subroutine   *
* GTREVE called by  the subroutine GUTREV where the user  is free to   *
* take any other action.  GTREVE  loops over all vertices and stores   *
* all tracks  from the current vertex  in the stack JSTAK,  then for   *
* each  one  in  turn,  calls  GLTRAC to  prepare  the  commons  for   *
* tracking,  and starts  tracking through  a call  to GUTRAK,  which   *
* calls GTRACK.                                                        *
*  The subroutine GTRACK  tracks the particle up to the  end : stop,   *
* decay, interaction  or escape.   During this  phase it  may happen   *
* that secondary products  are generated and stored by  the user, as   *
* explained  below, in  the stack, and if  wanted, in  the permanent   *
* structure JKINE.                                                     *
*  The subroutine GTRACK loops over  all geometrical volumes seen by   *
* the  current  track,  first identifying,  through  the  subroutine   *
* GTMEDI, the new volume which  the particle has reached and storing   *
* the corresponding  material and  tracking medium constants  in the   *
* common blocks /GCMATE/ and /GCTMED/; the tracking is controlled by   *
* the  type-dependent  routines  GTELEC,GTGAMA,GTHADR,GTMUON,GTNEUT.   *
* These compute  the physical step  size according to  the activated   *
* physics processes, and compute the geometrical limit for the step,   *
* only when  necessary, through  GTNEXT, and propagate  the particle   *
* over the computed step.                                              *
*                                                                      *
* MAGNETIC FIELD ROUTINES                                              *
*                                                                      *
*  As mentioned before,  the effective propagation of the particles is *
* controlled by the routines GTGAMA, GTELEC, etc., which call GUSWIM.  *
* Depending on the  value chosen by the user for  the tracking medium  *
* parameter IFIELD the routine GUSWIM calls either                     *
*                                                                      *
* GRKUTA    for inhomogeneous fields, IFIELD=1                         *
* GHELIX    for quasi-homogeneous fields tilted w.r.t. the reference   *
*           frame, IFIELD=2, or                                        *
* GHELX3    for one-component fields along the z axis, IFIELD=3        *
*                                                                      *
*  GRKUTA and  GHELIX call the  default user subroutine  GUFLD where   *
* the  components of  the field  at  the given  point are  computed.   *
* GHELX3  takes  the value  of  the  field  in the  tracking  medium   *
* parameter FIELDM.                                                    *
*                                                                      *
* INFORMATION AVAILABLE AT TRACKING TIME, AND THE SUBROUTINE GUSTEP    *
*                                                                      *
*  At any  moment the  current track parameters  are available  in the *
* common block  /GCTRAK/ as well  as all  variables which have  to be  *
* preserved by  the tracking  routines for  the control  of the  step  *
* size.  In  addition a  few flags  and variables  are stored  in the  *
* common block /GCTRAK/ to record the history of the current step:     *
*                                                                      *
* INWVOL    is initialized  to 1 when  entering a new volume,  it is   *
*           set to  0 for all steps  inside the volume, to  2 if the   *
*           particle has reached  the volume boundary and  to 3 when   *
*           the particle is leaving the experimental setup.            *
* ISTOP     is initialized to 0 and set  to 1 if the particle looses   *
*           its identity or to 2 if it stops.                          *
*                                                                      *
*  The effect  which is responsible  for the limitation of  the step   *
* size as well as the corrective  effects which have been applied at   *
* the end of the step, if any,  are recorded in the first NMEC words   *
* of the mechanism vector LMEC and this is most useful to understand   *
* and debug the program.                                               *
*  The  total energy  loss for  the current  step is  stored in  the   *
* variable DESTEP, and the continuous energy loss in DESTEL.           *
*  This information  is necessary  for the user  to take  the proper   *
* actions in the subroutine GUSTEP which  is called by GTRACK at the   *
* end of every step.                                                   *
*  In addition, the  number NGKINE of secondary  products which have   *
* possibly been  generated and  their characteristics are  stored in   *
* the common  block /GCKING/ together with  an identification (array   *
* LMEC)  of   which  process  is  responsible.    Depending  on  the   *
* application  and on  the particle  type,  the user  may decide  in   *
* GUSTEP through the routine GSKING,                                   *
*                                                                      *
* - to discard the newly produced secondaries                          *
* - to  enter them  in  the  temporary JSTAK  data  structure to  be   *
*   tracked                                                            *
* - to  store them  in  the  permanent JKINE  data  structure to  be   *
*   tracked                                                            *
*                                                                      *
* CONNECTION WITH THE DETECTOR RESPONSE PACKAGE                        *
*                                                                      *
*  The loop over the volumes in  GTRACK makes the interface with the   *
* detector response  package simple [HITS].  By  construction of the   *
* geometrical setup  there is  a correspondance between  the volumes   *
* seen by  the particle and  the components of the  detectors.  When   *
* entering a new volume (in GTRACK) the subroutine GFINDS is called.   *
* If  the volume  has  been  declared by  the  user  as a  sensitive   *
* detector   through  appropriate   calls  to   GSDET  and   if  the   *
* corresponding tracking  medium constant ISVOL is  non zero, GFINDS   *
* returns in the  common block /GCSETS/ the  information to identify   *
* uniquely the detector component.  This  enables the user in GUSTEP   *
* to  record the  hits  properly  as well  as  the energy  deposited   *
* [HITS].                                                              *
*                                                                      *
* CONNECTION WITH THE DRAWING PACKAGE                                  *
*                                                                      *
*  The coordinates of the space points generated during the tracking   *
* are  available at  each step  in  the common  block /GCTRAK/.   In   *
* GUSTEP the user can store them in the structure JXYZ with the help   *
* of the subroutine  GSXYZ.  This information can be  used later for   *
* debug (subroutine  GPCXYZ) or for the  graphical representation of   *
* the trajectories [DRAW].                                             *
*                                                                      *
************************************************************************
+DECK,GARNDM
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      FUNCTION GARNDM(DUMMY)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       GARNDM = -LOG(RNDM(DUMMY))                               *
C.    *                                                                *
C.    *    ==>Called by : GBREME,GBREMM,GCOMP,GDRAY,GHADRO,GHEISH,     *
C.    *                   GLANDO,GPAIRG,GPAIRM,GRAYL,GLTRAC            *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION RNDM(1)
C.
C.    ------------------------------------------------------------------
C.
      CALL GRNDM(RNDM,1)
      GARNDM=-LOG(RNDM(1))
      END
+DECK,GDEBUG.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GDEBUG
*
************************************************************************
*             Standard GEANT debug                                     *
*                                                                      *
*          ==>Called by : <USER>,GUSTEP                                *
*             Author    R.Brun  *********                              *
************************************************************************
*
+SEQ,GCFLAG,GCKINE,GCTRAK.
*
*             Debug/plot event
      IF(IDEBUG.NE.0) THEN
        IF((ISWIT(2).EQ.1).OR.(ISWIT(3).EQ.1)
     +                    .OR.(ISWIT(2).EQ.4)) CALL GSXYZ
        IF (ISWIT(2).EQ.2) CALL GPCXYZ
        IF (ISWIT(1).EQ.2) CALL GPGKIN
        IF (ISWIT(2).EQ.3) THEN
           IF(ISWIT(4).EQ.3.AND.CHARGE.EQ.0.)RETURN
           CALL GDCXYZ
           CALL IGSA(0)
        ELSEIF(ISWIT(2).EQ.4) THEN
           IF(ISTOP.NE.0) CALL GDTRAK(' ')
        ENDIF
      ENDIF
      END
 
+DECK,GEKBIN
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GEKBIN
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to find bin number in kinetic energy table       *
C.    *       stored in ELOW(NEKBIN)                                   *
C.    *                                                                *
C.    *    ==>Called by : GBREME,GBREMM,GCOMP,GDRAY,GHEISH,GPAIRM,     *
C.    *                   GLTRAC,GTELEC,GTHADR,GTMUON                  *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCTRAK
+SEQ,GCMULO
+SEQ,GCKINE
+SEQ,GCONSP
C.
C.    ------------------------------------------------------------------
C.
      EK=GEKIN
      IF (ITRTYP.EQ.4.OR.ITRTYP.EQ.8) EK=GEKIN*PMASS/AMASS
      IF (EK.LT.ELOW(1)) THEN
         IEKBIN=1
         GEKRAT=0.
      ELSEIF (EK.GE.ELOW(NEK1)) THEN
         IEKBIN=NEKBIN
         GEKRAT=1.
      ELSE
         IEKBIN=GEKA*LOG10(EK) + GEKB
         GEKRAT=(EK-ELOW(IEKBIN))/(ELOW(IEKBIN+1)-ELOW(IEKBIN))
         GEKRAT=MIN(1.,MAX(GEKRAT,0.))
      ENDIF
C
      END
+DECK,GFINDS
*CMZ :  3.21/02 06/07/94  18.26.03  by  S.Giani
*-- Author :
      SUBROUTINE GFINDS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Returns the set/volume parameters corresponding to       *
C.    *       the current space point in /GCTRAK/                      *
C.    *       and fill common /GCSETS/                                 *
C.    *                                                                *
C.    *       IHSET  user set identifier                               *
C.    *       IHDET  user detector identifier                          *
C.    *       ISET set number in JSET                                  *
C.    *       IDET   detector number in JS=LQ(JSET-ISET)               *
C.    *       IDTYPE detector type (1,2)                               *
C.    *       NUMBV  detector volume numbers (array of length NVNAME)  *
C.    *       NVNAME number of volume levels                           *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *       Author    R.Brun  *********                              *
C.    *       Modified  V.Perev                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCSETS
+SEQ,GCVOLU
+SEQ,GCTMED
+SELF,IF=DEBUG
      INTEGER        LNAM(15), LNUM(15)
+SELF
      JATTF(JV) = JV + Q(JV+5) + 6
C.
C.    ------------------------------------------------------------------
C.
*
+SELF, IF=DEBUG.
      WRITE(CHMAIL,1000)NLEVEL
      CALL GMAIL (0, 0)
      DO 5 I    = 1,NLEVEL
        WRITE(CHMAIL,1001)NAMES(I),NUMBER(I),LVOLUM(I),LINDEX(I)
        CALL GMAIL (0, 0)
        WRITE(CHMAIL,1002)(GTRAN(J,I),J = 1,3),(GRMAT(J,I),J=1,10)
        CALL GMAIL (0, 0)
    5   CONTINUE
 1000 FORMAT (' DEBUG : GFINDS =',I3)
 1001 FORMAT (5(1X,A4,3I3))
 1002 FORMAT (1X,13F9.4)
      NLEV = NLEVEL
      CALL UCOPY (NAMES (1),LNAM(1),NLEV)
      CALL UCOPY (NUMBER(1),LNUM(1),NLEV)
      NLEVEL    = 0
      CALL GLVOLU (NLEV, LNAM, LNUM, IER)
      IF (IER.NE.0)             STOP
+SELF.
*
      IHSET = 0
      IHDET = 0
      ISET  = 0
      IDET  = 0
      IDTYPE = 0
      NVNAME = 0
*
      DO 10 NLEV = NLEVEL,1,-1
         JVO = LQ(JVOLUM-LVOLUM(NLEV))
         JAT = JATTF(JVO)
         IDET = Q(JAT+8)
         IF(IDET.NE.0) THEN
            NL = NLEV
            GO TO 15
         ENDIF
  10  CONTINUE
      GOTO 99
  15  ISET   = Q(JAT+7)
      IDTYPE = Q(JAT+9)
      IHSET  = IQ(JSET+ISET)
      JS     = LQ(JSET-ISET)
      IHDET  = IQ(JS+IDET)
      JD     = LQ(JS-IDET)
      NVNAME = IQ(JD+2)
      DO 40 I=1,NVNAME
            NAME=IQ(JD+2*I+9)
            NUMBV(I)=0
            DO 30 J=1,NLEVEL
               IF(NAMES(J).EQ.NAME)THEN
                  NUMBV(I)=NUMBER(J)
                  GO TO 40
               ENDIF
  30        CONTINUE
  40  CONTINUE
C
   99 CONTINUE
      END
+DECK,GFTRAC.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GFTRAC
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GFTRAC                                                 *
C.    *                                                                *
C.    *   Selects next track segment to be processed and extracts from *
C.    *    the stack JTRACK the relevant information to reload commons *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
*
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+SEQ,GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCVOLU.
+CDE, GCPOLY.
+SEQ,GCJUMP, IF=USRJMP
      REAL      XC(3), XT(3), X0(3)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      SAVE MANY
      DATA  MANY / 0/
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.    ------------------------------------------------------------------
*
* *** Process next track in 'IN current VOlume' chain, if any
*
      IF (NJTMAX.LT.0) THEN
*
*  **   Reactivate parallel tracking if enough space available
*
         IF (NALIVE.LE.NJTMIN) NJTMAX = -NJTMAX
*
*  **   Update common /GCVOLU/ and structure JGPAR if necessary
*
         NLEVEL = NLVSAV
         ISKP   = 1
         DO 9 ILEV = 2,NLDOWN
            IF (ISKP.NE.0) THEN
               IF (LINDEX(ILEV).EQ.LINSAV(ILEV)) GO TO 9
               ISKP = 0
            ENDIF
            JSKLD = LQ(JSKLT-ILEV)
            JSKD  = LQ(JSKLD-LINSAV(ILEV))
            IVO   = IQ(JSKD+2)
            LQ(JGPAR-ILEV) = LQ(JSKD-1)
            IQ(JGPAR+ILEV) = IQ(JSKD+1)
            LVOLUM(ILEV)   = IVO
            NAMES(ILEV)    = IQ(JVOLUM+IVO)
            LINDEX(ILEV)   = LINSAV(ILEV)
            LINMX(ILEV)    = LMXSAV(ILEV)
            JVOM = LQ(JVOLUM-LVOLUM(ILEV-1))
            IF (Q(JVOM+3).GT.0.) THEN
               JIN = LQ(JVOM-LINDEX(ILEV))
               NUMBER(ILEV) = Q(JIN+3)
               GONLY(ILEV)  = Q(JIN+8)
            ELSE
               NUMBER(ILEV) = LINDEX(ILEV)
               GONLY(ILEV)  = GONLY(ILEV-1)
            ENDIF
            IF (LQ(LQ(JVOLUM-IVO)).EQ.0) THEN
               NLDEV(ILEV) = NLDEV(ILEV-1)
            ELSE
               NLDEV(ILEV) = ILEV
            ENDIF
            GTRAN(1,ILEV) = Q(JSKD+3)
            GTRAN(2,ILEV) = Q(JSKD+4)
            GTRAN(3,ILEV) = Q(JSKD+5)
            DO 8 I = 1, 10, 2
               GRMAT(I,ILEV) = Q(JSKD+5+I)
               GRMAT(I+1,ILEV) = Q(JSKD+6+I)
    8       CONTINUE
    9    CONTINUE
* **
         IF (NJINVO.NE.0) GO TO 800
         IFUPD = 0
      ELSE
         IF (NJINVO.NE.0) GO TO 800
         IFUPD = 1
      ENDIF
*
* *** 'IN current VOlume' chain is empty, refill from JSKLT structure
*     Scan brother chains, starting from current one when going up in
*     the skeleton structure
*
   10 INSK  = 1
*
   11 NLEVEL = NLDOWN
      JSKLD  = LQ(JSKLT-NLEVEL)
      NINSK  = LINMX(NLEVEL)
      IDO    = 1
*
   20 IF (IQ(JSKLD+INSK).EQ.0) GO TO 589
      JSKD = LQ(JSKLD-INSK)
      IVO  = IQ(JSKD+2)
      IF (IFUPD.NE.0.AND.NLEVEL.GT.1) THEN
*
*  **   Update common /GCVOLU/ for level NLEVEL
*
         LQ(JGPAR-NLEVEL) = LQ(JSKD-1)
         IQ(JGPAR+NLEVEL) = IQ(JSKD+1)
         LVOLUM(NLEVEL)   = IVO
         NAMES(NLEVEL)    = IQ(JVOLUM+IVO)
         LINDEX(NLEVEL)   = INSK
         JVOM = LQ(JVOLUM-LVOLUM(NLEVEL-1))
         IF (Q(JVOM+3).GT.0.) THEN
            JIN = LQ(JVOM-INSK)
            NUMBER(NLEVEL) = Q(JIN+3)
            GONLY(NLEVEL)  = Q(JIN+8)
         ELSE
            NUMBER(NLEVEL) = INSK
            GONLY(NLEVEL)  = GONLY(NLEVEL-1)
         ENDIF
         IF (LQ(LQ(JVOLUM-IVO)).EQ.0) THEN
            NLDEV(NLEVEL) = NLDEV(NLEVEL-1)
         ELSE
            NLDEV(NLEVEL) = NLEVEL
         ENDIF
         GTRAN(1,NLEVEL) = Q(JSKD+3)
         GTRAN(2,NLEVEL) = Q(JSKD+4)
         GTRAN(3,NLEVEL) = Q(JSKD+5)
         DO 29 I = 1, 10, 2
            GRMAT(I,NLEVEL) = Q(JSKD+5+I)
            GRMAT(I+1,NLEVEL) = Q(JSKD+6+I)
   29    CONTINUE
      ENDIF
*
      JVO  = LQ(JVOLUM-IVO)
      IF (Q(JVO+3).EQ.0.) GO TO 600
      NIN = Q(JVO+3)
*
*  ** Sort-out unsorted-out elements in first non-empty brother chain
*
      LPREV = JSKLD +INSK
      NCUR  = IQ(LPREV)
   50 LCUR = JTRACK +(NCUR-1)*NWTRAC
      IF (IQ(LCUR+2).NE.0) GO TO 600
      NSTO = IQ(LCUR+1)
*
      IPCUR = LCUR +NWINT
C*****  Code Expanded From Routine:  GTRNSF
C
      IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = Q(1+IPCUR) - GTRAN(1,NLEVEL)
         XC(2) = Q(2+IPCUR) - GTRAN(2,NLEVEL)
         XC(3) = Q(3+IPCUR) - GTRAN(3,NLEVEL)
*
      ELSE
         XL11X = Q(1+IPCUR) - GTRAN(1,NLEVEL)
         XL21X = Q(2+IPCUR) - GTRAN(2,NLEVEL)
         XL31X = Q(3+IPCUR) - GTRAN(3,NLEVEL)
         XC(1) = XL11X*GRMAT(1,NLEVEL) + XL21X*GRMAT(2,NLEVEL) + XL31X*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL11X*GRMAT(4,NLEVEL) + XL21X*GRMAT(5,NLEVEL) + XL31X*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL11X*GRMAT(7,NLEVEL) + XL21X*GRMAT(8,NLEVEL) + XL31X*
     1      GRMAT(9,NLEVEL)
 
      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      IF (NIN.LT.0) GO TO 200
*
*   *   Case with contents defined by Position
*
      JNEAR = LQ(JVO-NIN-1)
      INFROM = IQ(LCUR+11)
      IF (INFROM.GT.0) THEN
         JIN   = LQ(JVO-INFROM)
         IF (LQ(JIN-1).NE.0) JNEAR = LQ(JIN-1)
      ENDIF
      IF (IQ(JNEAR+2).EQ.0) GO TO 300
      ISEARC = Q(JVO+1)
      IF (ISEARC.LT.0) THEN
*
*       Prepare access list when contents have been ordered by GSORD
*
         JSB = LQ(LQ(JVO-NIN-1))
         IAX = Q(JSB+1)
         NSB = Q(JSB+2)
         IF (IAX.LE.3) THEN
            IDIV = LOCATF (Q(JSB+3), NSB, XC(IAX))
         ELSE
            CALL GFCOOR (XC, IAX, CX)
            IDIV = LOCATF (Q(JSB+3), NSB, CX)
         ENDIF
         IF (IDIV.LT.0) IDIV = -IDIV
         IF (IDIV.EQ.0) THEN
            IF (IAX.NE.6) GO TO 300
            IDIV = NSB
         ELSE IF (IDIV.EQ.NSB) THEN
            IF (IAX.NE.6) GO TO 300
         ENDIF
         JSC0 = LQ(JVO-NIN-2)
         NCONT = IQ(JSC0+IDIV)
         IF (NCONT.LE.0) GO TO 300
         JSCV = LQ(JSC0-IDIV)
         ICONT = 1
         GO TO 120
      ELSE
         IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
            CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=USRJMP
            CALL JUMPT4(JUNEAR, ISEARC, 1, XC, JNEAR)
+SELF
            IF (IQ(JNEAR+1).EQ.0) GO TO 300
         ENDIF
         JNEAR  = JNEAR +1
         NNEAR  = IQ(JNEAR)
         INEAR  = 1
      ENDIF
*
  110 IN = IQ(JNEAR+INEAR)
      IF (IN.GT.0) GO TO 150
      GO TO 190
*
  120 IN = IQ(JSCV+ICONT)
*
*     For each selected content in turn, check if point is in
*
  150 JIN  = LQ(JVO-IN)
      IVOT = Q(JIN+2)
      JVOT = LQ(JVOLUM-IVOT)
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR +5
         NPAR = IQ(JPAR)
         GO TO 175
      ENDIF
*      (normal case)
      NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
*
  175 IROTT  = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
      IF (IROTT.EQ.0) THEN
         XT(1) = XC(1) - Q(JIN+5)
         XT(2) = XC(2) - Q(JIN+6)
         XT(3) = XC(3) - Q(JIN+7)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
      ENDIF
C*****  Code Expanded From Routine:  GITRAN
      CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
      IF (IYES.NE.0) THEN
*
*       Volume found at deeper level
*
         NLDOWN = NLEVEL +1
         LINMX(NLDOWN) = NIN
         JSKL = LQ(JSKLT-NLDOWN)
*
*       Clear skeleton at lowest level if necessary
*
         JOFF = JSKL +IQ(JSKL-3)
         DO 184 ILEV = 1,NLEVEL
            IF (IQ(JOFF+ILEV).EQ.LINDEX(ILEV)) GO TO 184
            DO 182 I = ILEV,NLEVEL
               IQ(JOFF+I) = LINDEX(I)
  182       CONTINUE
            DO 183 I = 1,NIN
               JSK = LQ(JSKL-I)
               IQ(JSK+1) = 0
  183       CONTINUE
            GO TO 185
  184    CONTINUE
*
*       Prepare skeleton for level down if not yet done
*
  185    JSK  = LQ(JSKL-IN)
         IF (IQ(JSK+1).EQ.0) THEN
            LQ(JSK-1) = JPAR
            IQ(JSK+1) = NPAR
            IQ(JSK+2) = IVOT
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL),
     +                   Q(JIN+5), IROTT, Q(JSK+3), Q(JSK+6))
         ENDIF
         GO TO 500
*
      ENDIF
*
  190 IF (ISEARC.LT.0) THEN
         IF (ICONT.EQ.NCONT) GO TO 300
         ICONT = ICONT +1
         GO TO 120
      ELSE
         IF (INEAR.EQ.NNEAR) GO TO 300
         INEAR = INEAR +1
         GO TO 110
      ENDIF
*
*   *   Case with contents defined by division
*
  200 JDIV  = LQ(JVO-1)
      ISH   = Q(JVO+2)
      IAXIS = Q(JDIV+1)
      IVOT  = Q(JDIV+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPAR = 0
      ELSE
*       (case with structure JVOLUM locally developped)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 250
         DO 249 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPAR+1).EQ.0) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
               IF (JPAR.EQ.0) GO TO 250
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV  = IQ(JPAR+1)
               ORIG  =  Q(JPAR+2)
               SDIV  =  Q(JPAR+3)
            ENDIF
  249    CONTINUE
         GO TO 260
      ENDIF
*      (normal case)
  250 NDIV  = Q(JDIV+3)
      ORIG  = Q(JDIV+4)
      SDIV  = Q(JDIV+5)
*
  260 IDT = IDTYP(IAXIS,ISH)
      IF (IDT.EQ.1) THEN
*
*      Division along X, Y or Z axis
*
         XTT = XC(IAXIS)
         IF (ISH.EQ.10) THEN
            IF (IAXIS.NE.3) THEN
               XTT = XTT - Q(LQ(JGPAR-NLEVEL)+IAXIS+4) * XC(3)
               IF (IAXIS.EQ.1) THEN
                  YT  = XC(2) - Q(LQ(JGPAR-NLEVEL)+6) * XC(3)
                  XTT = XTT - Q(LQ(JGPAR-NLEVEL)+4) * YT
               ENDIF
            ENDIF
         ENDIF
         IN = (XTT -ORIG)/SDIV +1
      ELSE IF (IDT.EQ.2) THEN
*
*       Division along R axis
*
         R = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R = SQRT (R)
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IN = (R - ORIG) / SDIV + 1
         ELSE IF (ISH.EQ.7.OR.ISH.EQ.8) THEN
            IPAR = LQ(JGPAR-NLEVEL)
            DR   = 0.5 * (Q(IPAR+4) - Q(IPAR+2)) / Q(IPAR+1)
            RMN  = 0.5 * (Q(IPAR+4) + Q(IPAR+2)) + DR * XC(3)
            DR   = 0.5 * (Q(IPAR+5) - Q(IPAR+3)) / Q(IPAR+1)
            RMX  = 0.5 * (Q(IPAR+5) + Q(IPAR+3)) + DR * XC(3)
            STP  = (RMX - RMN) / NDIV
            IN   = (R - RMN) / STP + 1
         ELSE
            IPAR = LQ(JGPAR-NLEVEL)
            IF (ISH.EQ.12) THEN
               IPT = IPAR + 1
            ELSE
               IPT = IPAR + 2
            ENDIF
            IF (IZSEC.GT.0) THEN
               IPT = IPT + 3 * IZSEC
            ELSE
               NZ  = Q(IPT+2)
               DO 261 IZ = 1, NZ-1
                  IF((XC(3)-Q(IPT+3*IZ))*(XC(3)-Q(IPT+3*IZ+3)).LE.0.)
     +            THEN
                     IZSEC = IZ
                     IPT   = IPT + 3 * IZSEC
                     GO TO 262
                  ENDIF
  261          CONTINUE
               IN  = 0
               GO TO 265
            ENDIF
  262       POR1 = (Q(IPT+3) - XC(3)) / (Q(IPT+3) - Q(IPT))
            POR2 = (XC(3) - Q(IPT)) / (Q(IPT+3) - Q(IPT))
            RMN  = Q(IPT+1) * POR1 + Q(IPT+4) * POR2
            RMX  = Q(IPT+2) * POR1 + Q(IPT+5) * POR2
            IF (ISH.EQ.11) THEN
               NPDV = Q(IPAR+3)
               DPH  = Q(IPAR+2) / NPDV
               IF (IPSEC.LE.0) THEN
                  IF (XC(1).NE.0..OR.XC(2).NE.0.) THEN
                     PHI  = RADDEG * ATAN2 (XC(2), XC(1))
                  ELSE
                     PHI  = 0.0
                  ENDIF
                  PH0  = MOD (PHI-Q(IPAR+1)+360., 360.)
                  IPSEC= PH0/DPH + 1
               ENDIF
               PH   = DEGRAD * (Q(IPAR+1) + (IPSEC - 0.5) * DPH)
               R    = XC(1) * COS(PH) + XC(2) * SIN(PH)
            ENDIF
            STP = (RMX - RMN) / NDIV
            IN  = (R - RMN) / STP + 1
         ENDIF
      ELSE IF (IDT.EQ.3) THEN
*
*       Division along Phi axis
*
         IF (XC(1).NE.0..OR.XC(2).NE.0.) THEN
            PHI = RADDEG * ATAN2 (XC(2), XC(1))
         ELSE
            PHI = 0.
         ENDIF
         IN  = MOD (PHI-ORIG+360., 360.) / SDIV + 1
      ELSE IF (IDT.EQ.4) THEN
*
*       Division along Theta axis
*
         IF (XC(3).NE.0.0) THEN
            RXY  = SQRT (XC(1)**2 + XC(2)**2)
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0)  THET = THET + 180.0
         ELSE
            THET = 90.0
         ENDIF
         IN   = (THET - ORIG) / SDIV + 1
      ENDIF
*
  265 IF (IN.GT.NDIV) IN = 0
      IF (IN.LE.0) GO TO 300
*
      IF (JPAR.NE.0) THEN
         IF (IQ(JPAR-3).GT.1) THEN
            JPAR = LQ(JPAR-IN)
         ELSE
            JPAR = LQ(JPAR-1)
         ENDIF
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
      ELSE
         NPAR = Q(JVOT+5)
         JPAR = JVOT + 6
      ENDIF
*
*      Volume found at deeper level
*
      NLDOWN = NLEVEL +1
      LINMX(NLDOWN) = NDIV
      JSKL = LQ(JSKLT-NLDOWN)
*
*      Clear skeleton at lowest level if necessary
*
      JOFF = JSKL +IQ(JSKL-3)
      DO 269 ILEV = 1,NLEVEL
         IF (IQ(JOFF+ILEV).EQ.LINDEX(ILEV)) GO TO 269
         DO 267 I = ILEV,NLEVEL
            IQ(JOFF+I) = LINDEX(I)
  267    CONTINUE
         DO 268 I = 1,NDIV
            JSK = LQ(JSKL-I)
            IQ(JSK+1) = 0
  268    CONTINUE
         GO TO 270
  269 CONTINUE
*
*       Prepare skeleton at level down if not yet done
*
  270 JSK  = LQ(JSKL-IN)
      IF (IQ(JSK+1).EQ.0) THEN
         LQ(JSK-1) = JPAR
         IQ(JSK+1) = NPAR
         IQ(JSK+2) = IVOT
*
         IF (IDT.EQ.1) THEN
            X0(1) = 0.0
            X0(2) = 0.0
            X0(3) = 0.0
            X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
            IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
               CALL GCENT (IAXIS, X0)
            ENDIF
            IF (GRMAT(10,NLEVEL).EQ.0.0) THEN
               Q(JSK+3) = GTRAN(1,NLEVEL) + X0(1)
               Q(JSK+4) = GTRAN(2,NLEVEL) + X0(2)
               Q(JSK+5) = GTRAN(3,NLEVEL) + X0(3)
               DO 278 I = 1, 10, 2
                  Q(JSK+5+I) = GRMAT(I,NLEVEL)
                  Q(JSK+6+I) = GRMAT(I+1,NLEVEL)
  278          CONTINUE
            ELSE
               CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), X0, 0,
     +                      Q(JSK+3), Q(JSK+6))
            ENDIF
*
         ELSE IF (IDT.EQ.3.OR.IDT.EQ.4) THEN
            IF (IDT.EQ.3) THEN
               PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
               CPHR = COS (PH0)
               SPHR = SIN (PH0)
            ELSE
               PH0  = 0.0
               CPHR = 1.0
               SPHR = 0.0
            ENDIF
            DO 279 I = 1, 3
               Q(JSK+2+I) = GTRAN(I,NLEVEL)
               Q(JSK+5+I) = GRMAT(I,NLEVEL)*CPHR +GRMAT(I+3,NLEVEL)*SPHR
               Q(JSK+8+I) = GRMAT(I+3,NLEVEL)*CPHR -GRMAT(I,NLEVEL)*SPHR
               Q(JSK+11+I)= GRMAT(I+6,NLEVEL)
  279       CONTINUE
            IF (PH0.EQ.0.0.AND.GRMAT(10,NLEVEL).EQ.0.0) THEN
               Q(JSK+15) = 0.0
            ELSE
               Q(JSK+15) = 1.0
            ENDIF
            IF (ISH.EQ.11) IPSEC = 1
*
         ELSE
            Q(JSK+3) = GTRAN(1,NLEVEL)
            Q(JSK+4) = GTRAN(2,NLEVEL)
            Q(JSK+5) = GTRAN(3,NLEVEL)
            DO 281 I = 1, 10, 2
               Q(JSK+5+I) = GRMAT(I,NLEVEL)
               Q(JSK+6+I) = GRMAT(I+1,NLEVEL)
  281       CONTINUE
         ENDIF
*
      ENDIF
      GO TO 500
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
         IF (MANY.EQ.0) THEN
            WRITE (CHMAIL, 1001)
            CALL GMAIL (0 ,0)
            MANY = 1
         ENDIF
      ENDIF
*
      IQ(LCUR+2) = 1
      LPREV = LCUR +1
      GO TO 510
*
*       Move track down in skeleton
*
  500 IQ(LPREV)   = NSTO
      IQ(LCUR+1)  = IQ(JSKL+IN)
*      (reset INFROM to 0)
      IQ(LCUR+11) = 0
      IQ(JSKL+IN) = NCUR
*
  510 IF (NSTO.EQ.0) THEN
         GO TO 600
      ELSE
         NCUR = NSTO
         GO TO 50
      ENDIF
*
  589 IF (IDO.LT.NINSK) THEN
         IDO  = IDO +1
         INSK = INSK +1
         IF (INSK.GT.NINSK) INSK = 1
         IFUPD = 1
         GO TO 20
      ENDIF
*
*  **  No more elements at lowest level, go one level up in skeleton
*
      NLDOWN = NLDOWN -1
      INSK   = LINDEX(NLDOWN)
      IFUPD  = 0
      GO TO 11
*
  600 IF (NLDOWN.GT.NLEVEL) THEN
         IFUPD = 1
         GO TO 10
      ENDIF
*
*  **  Prepare 'IN current VOlume' chain
*
      NJINVO = IQ(JSKLD+INSK)
      IQ(JSKLD+INSK) = 0
*
      IF (NJTMAX.LT.0) THEN
*       (save status of skeleton for later reactivation of // tracking)
         DO 609 I = 2,NLEVEL
            LINSAV(I) = LINDEX(I)
            LMXSAV(I) = LINMX(I)
  609    CONTINUE
      ENDIF
*
* *** Fetch information for next track segment to be processed
*
  800 NCUR   = NJINVO
      LCUR   = JTRACK +(NCUR-1)*NWTRAC
      NJINVO = IQ(LCUR+1)
      NTMULT = IQ(LCUR+3)
      ITRA   = IQ(LCUR+4)
      ISTAK  = IQ(LCUR+5)
      IPART  = IQ(LCUR+6)
      NSTEP  = IQ(LCUR+7)
*free IDECAD = IQ(LCUR+8)
      IEKBIN = IQ(LCUR+9)
      ISTORY = IQ(LCUR+10)
      INFROM = IQ(LCUR+11)
*
      IF (IPART.NE.IPAOLD) THEN
         JPA = LQ(JPART-IPART)
         DO 819 I = 1,5
            NAPART(I) = IQ(JPA+I)
  819    CONTINUE
         ITRTYP = Q(JPA+6)
         AMASS  = Q(JPA+7)
         CHARGE = Q(JPA+8)
         TLIFE  = Q(JPA+9)
         IPAOLD = IPART
         IUPD   = 0
      ENDIF
*
      IPCUR = LCUR +NWINT
      DO 829 I = 1,7
         VECT(I) = Q(IPCUR+I)
  829 CONTINUE
      GEKIN  = Q(IPCUR+8)
      SLENG  = Q(IPCUR+9)
      GEKRAT = Q(IPCUR+10)
      TOFG   = Q(IPCUR+11)
      UPWGHT = Q(IPCUR+12)
*
      GETOT  = GEKIN +AMASS
      SAFETY = 0.
*
      IPCUR = IPCUR +NWREAL
      IF (ITRTYP.EQ.1) THEN
*      Photons
         ZINTPA = Q(IPCUR+1)
         ZINTCO = Q(IPCUR+2)
         ZINTPH = Q(IPCUR+3)
         ZINTPF = Q(IPCUR+4)
         ZINTRA = Q(IPCUR+5)
      ELSE IF (ITRTYP.EQ.2) THEN
*     Electrons
         ZINTBR = Q(IPCUR+1)
         ZINTDR = Q(IPCUR+2)
         ZINTAN = Q(IPCUR+3)
      ELSE IF (ITRTYP.EQ.3) THEN
*     Neutral hadrons
         SUMLIF = Q(IPCUR+1)
         ZINTHA = Q(IPCUR+2)
      ELSE IF (ITRTYP.EQ.4) THEN
*     Charged hadrons
         SUMLIF = Q(IPCUR+1)
         ZINTHA = Q(IPCUR+2)
         ZINTDR = Q(IPCUR+3)
      ELSE IF (ITRTYP.EQ.5) THEN
*     Muons
         SUMLIF = Q(IPCUR+1)
         ZINTBR = Q(IPCUR+2)
         ZINTPA = Q(IPCUR+3)
         ZINTDR = Q(IPCUR+4)
         ZINTMU = Q(IPCUR+5)
      ELSE IF (ITRTYP.EQ.7) THEN
*     Cerenkov photons
         ZINTLA = Q(IPCUR+1)
      ELSE IF (ITRTYP.EQ.8) THEN
*     Ions
         ZINTHA = Q(IPCUR+1)
         ZINTDR = Q(IPCUR+2)
      ENDIF
*
*   *  Reset NUMED
*
      JVO   = LQ(JVOLUM-LVOLUM(NLEVEL))
      NUMED = Q(JVO+4)
*
*     Link selected track segment area to 'garbaged' chain
*
      IQ(LCUR+1) = NJGARB
      NJGARB     = NCUR
*
*     Save skeleton status when parallel tracking is frozen
*
      IF (NJTMAX.LT.0) THEN
         NLVSAV = NLEVEL
         DO 889 ILEV = 2,NLDOWN
            LINSAV(ILEV) = LINDEX(ILEV)
            LMXSAV(ILEV) = LINMX(ILEV)
  889    CONTINUE
      ENDIF
*
 1001 FORMAT (' GFTRAC : Simple NOT-ONLY configuration assumed. OK?')
*                                                             END GFTRAC
      END
+DECK,GGCKOV.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GGCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine is called for each tracking step of a charged   *
C.    *   particle in a radiator. A Poisson-distributed number of      *
C.    *   photons is generated according to the Cherenkov formula,     *
C.    *   distributed evenly along the track segment and uniformly     *
C.    *   azimuth w.r.t. the particle direction. The parameters are    *
C.    *   then transformed into the Master Reference System, and they  *
C.    *   are added to the particle stack.                             *
C.    *                                                                *
C.    *   ==>Called by : GTMUON, GTHADR, GTELEC                        *
C.    *      Authors     R.Jones, F.Carminati ********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCTMED.
+SEQ,GCUNIT.
+SEQ,GCTRAK.
+SEQ,GCKINE.
+SEQ,GCKING.
+SEQ,GCONSP.
*
      REAL RPHOT(3)
      LOGICAL ROTATE
      PARAMETER (RFACT=369.81E9)
*
*   ------------------------------------------------------------------
*
* *** See whether we generate at least one photon
*
C     THRIND = GETOT/VECT(7)
C     IF(Q(JINDEX+NPCKOV).LT.THRIND) THEN
C        GO TO 999
C     ELSEIF(Q(JINDEX+1).GE.THRIND) THEN
C        PMIN  = Q(JTCKOV+2)
C        DP    = Q(JTCKOV+NPCKOV+1)-PMIN
C        GE    = Q(JCURIN+NPCKOV)
C        JMIN  = 1
C     ELSE
C        JMIN = 1
C        JMAX = NPCKOV
C  10    JMED = (JMIN+JMAX)/2
C        IF(Q(JINDEX+JMED).LT.THRIND) THEN
C           JMIN = JMED
C        ELSE
C           JMAX = JMED
C        ENDIF
C        IF(JMAX-JMIN.GT.1) GO TO 10
C        RATIO =
C    +   (THRIND-Q(JINDEX+JMIN))/(Q(JINDEX+JMIN+1)-Q(JINDEX+JMIN))
C        RATI1 = 1.-RATIO
C        PMIN  = Q(JTCKOV+JMIN+1)*RATI1+Q(JTCKOV+JMIN+2)*RATIO
C        DP    = Q(JTCKOV+NPCKOV+1)-PMIN
C        GEMIN = Q(JCURIN+JMIN)*RATI1+Q(JCURIN+JMIN+1)*RATIO
C        GE    = Q(JCURIN+NPCKOV)-GEMIN
C     ENDIF
C     DNDL = RFACT*(CHARGE**2)*(DP-GE*THRIND**2)
      IF(ITRTYP.NE.4.AND.ITRTYP.NE.8) CALL GNCKOV
      CALL GPOISS(DNDL*STEP,NGPHOT,1)
      IF(NGPHOT.EQ.0) THEN
         GO TO 999
      ELSEIF(NGPHOT.GT.MXPHOT) THEN
         WRITE(CHMAIL,10000) NGPHOT-MXPHOT
10000   FORMAT(' **** GGCKOV Overflow in the photon stack, ',I10,
     +         ' photons are lost')
         CALL GMAIL(0,0)
         NGPHOT = MXPHOT
      ENDIF
*
* ***  Set up rotation to Particle frame
*
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
*
* ***  Distribute the photons in origin, direction, momentum
      COSMX  = THRIND/Q(JINDEX+NPCKOV)
      SINMX2 = (1.-COSMX)*(1.+COSMX)
      DO 40 J=1,NGPHOT
         CALL GRNDM(RPHOT, 1)
         IF(IGNEXT.NE.0) THEN
            DS=(STEP-PREC)*RPHOT(1)+PREC
         ELSE
            DS = STEP*RPHOT(1)
         ENDIF
         XPHOT(1,J) = VECT(1)-VECT(4)*DS
         XPHOT(2,J) = VECT(2)-VECT(5)*DS
         XPHOT(3,J) = VECT(3)-VECT(6)*DS
         XPHOT(11,J)= TOFG+(STEP-DS)*GETOT/(VECT(7)*CLIGHT)
*
* *** Sample the momentum of the photon
   20    CALL GRNDM(RPHOT, 3)
         PPHOT=PMIN+RPHOT(1)*DP
*
* *** Find in which bin we are
         KMIN = JMIN
         KMAX = NPCKOV
   30    KMED = (KMIN+KMAX)/2
         IF(Q(JTCKOV+1+KMED).LT.PPHOT) THEN
            KMIN = KMED
         ELSE
            KMAX = KMED
         ENDIF
         IF(KMAX-KMIN.GT.1) GOTO 30
         RATIO = (PPHOT-Q(JTCKOV+1+KMIN))/
     +           (Q(JTCKOV+KMIN+2)-Q(JTCKOV+1+KMIN))
         RATI1  = (1.-RATIO)
*
* *** Find the density function value corresponding to the
* *** momentum sampled
         RINDEX = Q(JINDEX+KMIN)*RATI1+Q(JINDEX+KMIN+1)*RATIO
         COST   = THRIND/RINDEX
         SINT2  = (1.-COST)*(1.+COST)
*
* *** Perform hit-and-miss
         IF(RPHOT(2)*SINMX2.GT.SINT2) GO TO 20
         SINT = SQRT(SINT2)
         PHI  = TWOPI*RPHOT(3)
         SINP = SIN(PHI)
         COSP = COS(PHI)
         XPHOT(4,J) = SINT*COSP
         XPHOT(5,J) = SINT*SINP
         XPHOT(6,J) = COST
         XPHOT(7,J) = PPHOT
         XPHOT(8,J) = COST*COSP
         XPHOT(9,J) = COST*SINP
         XPHOT(10,J) = -SINT
*
         IF(ROTATE) THEN
            CALL GDROT(XPHOT(8,J),COSTH,SINTH,COSPH,SINPH)
            CALL GDROT(XPHOT(4,J),COSTH,SINTH,COSPH,SINPH)
         ENDIF
   40 CONTINUE
  999 CONTINUE
      END
+DECK,GHELIX
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GHELIX (CHARGE, STEP, VECT, VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Performs the tracking of one step in a magnetic field         *
C.    *  The trajectory is assumed to be a helix in a constant field   *
C.    *  taken at the mid point of the step.                           *
C.    *  Parameters:                                                   *
C.    *   input                                                        *
C.    *     STEP =arc length of the step asked                         *
C.    *     VECT =input vector (position,direction cos and momentum)   *
C.    *     CHARGE=  electric charge of the particle                   *
C.    *   output                                                       *
C.    *     VOUT = same as VECT after completion of the step           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSWIM                               *
C.    *       Author    M.Hansroul  *********                          *
C.    *       Modified  S.Egli, S.V.Levonian                           *
C.    *       Modified  V.Perevoztchikov
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION      VECT(7),VOUT(7)
      DIMENSION      XYZ(3),H(4),HXP(3)
      PARAMETER      (IX=1,IY=2,IZ=3,IPX=4,IPY=5,IPZ=6,IPP=7)
      PARAMETER      (SIXTH = 1./6.)
      PARAMETER      (EC=2.9979251E-4)
C.
C.    ------------------------------------------------------------------
C.
C       units are kgauss,centimeters,gev/c
C
      VOUT(IPP) = VECT(IPP)
      IF (CHARGE.EQ.0.)         GO TO 10
      XYZ(1)    = VECT(IX) + 0.5 * STEP * VECT(IPX)
      XYZ(2)    = VECT(IY) + 0.5 * STEP * VECT(IPY)
      XYZ(3)    = VECT(IZ) + 0.5 * STEP * VECT(IPZ)
C
      CALL GUFLD (XYZ, H)
 
      H2XY = H(1)**2 + H(2)**2
      H(4) = H(3)**2 + H2XY
      IF (H(4).LE.1.E-12)       GO TO 10
      IF (H2XY.LE.1.E-12*H(4))  THEN
         CALL GHELX3 (CHARGE*H(3), STEP, VECT, VOUT)
         GO TO 999
      ENDIF
      H(4) = SQRT(H(4))
      H(1) = H(1)/H(4)
      H(2) = H(2)/H(4)
      H(3) = H(3)/H(4)
      H(4) = H(4)*EC
*
      HXP(1) = H(2)*VECT(IPZ) - H(3)*VECT(IPY)
      HXP(2) = H(3)*VECT(IPX) - H(1)*VECT(IPZ)
      HXP(3) = H(1)*VECT(IPY) - H(2)*VECT(IPX)
 
      HP = H(1)*VECT(IPX) + H(2)*VECT(IPY) + H(3)*VECT(IPZ)
*
      RHO = -CHARGE*H(4)/VECT(IPP)
      TET = RHO * STEP
      IF (ABS(TET).GT.0.15)     THEN
         SINT = SIN(TET)
         SINTT = (SINT/TET)
         TSINT = (TET-SINT)/TET
         COS1T = 2.*(SIN(0.5*TET))**2/TET
      ELSE
         TSINT = SIXTH*TET**2
         SINTT = (1. - TSINT)
         SINT = TET*SINTT
         COS1T = 0.5*TET
      ENDIF
*
      F1 = STEP * SINTT
      F2 = STEP * COS1T
      F3 = STEP * TSINT * HP
      F4 = -TET*COS1T
      F5 = SINT
      F6 = TET * COS1T * HP
 
      VOUT(IX) = VECT(IX) + (F1*VECT(IPX) + F2*HXP(1) + F3*H(1))
      VOUT(IY) = VECT(IY) + (F1*VECT(IPY) + F2*HXP(2) + F3*H(2))
      VOUT(IZ) = VECT(IZ) + (F1*VECT(IPZ) + F2*HXP(3) + F3*H(3))
 
      VOUT(IPX) = VECT(IPX) + (F4*VECT(IPX) + F5*HXP(1) + F6*H(1))
      VOUT(IPY) = VECT(IPY) + (F4*VECT(IPY) + F5*HXP(2) + F6*H(2))
      VOUT(IPZ) = VECT(IPZ) + (F4*VECT(IPZ) + F5*HXP(3) + F6*H(3))
 
      GO TO 999
 
   10 CONTINUE
      DO 20 I   = 1,3
         VOUT(I) = VECT(I) + STEP * VECT(I+3)
         VOUT(I+3) = VECT(I+3)
   20 CONTINUE
C
  999 CONTINUE
      END
+DECK,GHELX3
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GHELX3 (FIELD, STEP, VECT, VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Tracking routine in a constant field oriented            *
C.    *       along axis 3                                             *
C.    *       Tracking is performed with a conventional                *
C.    *       helix step method                                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSWIM                               *
C.    *       Authors    R.Brun, M.Hansroul  *********                 *
C     *       Rewritten  V.Perevoztchikov
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION      VECT(7),VOUT(7),HXP(3)
      PARAMETER      (IX=1,IY=2,IZ=3,IPX=4,IPY=5,IPZ=6,IPP=7)
      PARAMETER      (SIXTH = 1./6.)
      PARAMETER      (EC=2.9979251E-4)
C.
C.    ------------------------------------------------------------------
C.
C       units are kgauss,centimeters,gev/c
C
      VOUT(IPP) = VECT(IPP)
      H4 = FIELD * EC
*
      HXP(1) = - VECT(IPY)
      HXP(2) = + VECT(IPX)
 
      HP = VECT(IPZ)
*
      RHO = -H4/VECT(IPP)
      TET = RHO * STEP
      IF (ABS(TET).GT.0.15)     THEN
         SINT = SIN(TET)
         SINTT = (SINT/TET)
         TSINT = (TET-SINT)/TET
         COS1T = 2.*(SIN(0.5*TET))**2/TET
      ELSE
         TSINT = SIXTH*TET**2
         SINTT = (1. - TSINT)
         SINT = TET*SINTT
         COS1T = 0.5*TET
      ENDIF
*
      F1 = STEP * SINTT
      F2 = STEP * COS1T
      F3 = STEP * TSINT * HP
      F4 = -TET*COS1T
      F5 = SINT
      F6 = TET * COS1T * HP
 
      VOUT(IX) = VECT(IX) + (F1*VECT(IPX) + F2*HXP(1))
      VOUT(IY) = VECT(IY) + (F1*VECT(IPY) + F2*HXP(2))
      VOUT(IZ) = VECT(IZ) + (F1*VECT(IPZ) + F3)
 
      VOUT(IPX) = VECT(IPX) + (F4*VECT(IPX) + F5*HXP(1))
      VOUT(IPY) = VECT(IPY) + (F4*VECT(IPY) + F5*HXP(2))
      VOUT(IPZ) = VECT(IPZ) + (F4*VECT(IPZ) + F6)
 
C
  999 CONTINUE
      END
+DECK,GINVOL,IF=-OLD.
*CMZ :  3.21/02 03/07/94  17.14.15  by  S.Giani
*-- Author :
      SUBROUTINE GINVOL (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
C.
      DIMENSION  X(*)
      REAL       XC(6), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
         ingt=0
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480
 
  450 ISAME = 0
 
  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+DECK, GLSKLT.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GLSKLT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GLSKLT                                                *
C.    *                                                                *
C.    *   Prepares the Skeleton banks for parallel tracking            *
C.    *   Also lifts the stack bank JTRACK                             *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSTAK.
+CDE, GCTRAK.
+CDE, GCVOLU.
C.
      COMMON /GCSKLT/ LOCAL(2), JSK, JSKL, JVOLX
      CHARACTER*12    CFORM
C.
C.    ------------------------------------------------------------------
*
      IF (JSKLT.EQ.0) THEN
*
*  **    Initialize a temporary link area
*
         CALL MZLINT (IXSTOR, '/GCSKLT/', LOCAL, JSK, JVOLX)
         CALL MZFORM ('SKIN', '2I -F', IOSKIN)
         JVOLX = LQ(JVOLUM)
         NLVT  = IQ(JVOLX-1)
*
*  **    Lift the top level bank
*
         CALL MZBOOK (IXCONS, JSKLT, JSKLT, 1, 'SKLT', NLVT, NLVT, 0,
     +                2, 0)
         CALL MZBOOK (IXCONS, JSKL, JSKLT, -1, 'SKLV', 1, 1, 1, 2, 0)
         CALL MZBOOK (IXCONS, JSK, JSKL, -1, 'SKIN', 1, 0, 2, 2, -1)
         JVO  = LQ(JVOLUM-1)
         LQ(JSK-1) = JVO + 6
         IQ(JSK+1) = Q(JVO+5)
         IQ(JSK+2) = 1
*
*  **    Loop over the remaining levels
*
         DO 15 ILEV = 2, NLVT
            NINSK = IQ(JVOLX+ILEV)
            ND    = NINSK + ILEV - 1
            CALL MZBOOK (IXCONS, JSKL, JSKLT,-ILEV,'SKLV', NINSK, NINSK,
     +                   ND, 2, 0)
            DO 10 IN = 1, NINSK
               CALL MZBOOK (IXCONS, JSK, JSKL, -IN, 'SKIN', 1, 0, 15,
     +                      IOSKIN, 1)
   10       CONTINUE
   15    CONTINUE
*
*  **    Now create the Stack bank JTRACK
*
         NWR    = NWTRAC - NWINT
         WRITE (CFORM, 1001) NWINT, NWR
         CALL MZFORM ('TRAC', CFORM, IOTRAC)
         ND     = NWTRAC * NJTMAX
         CALL MZBOOK (IXCONS, JTRACK, JTRACK, 1, 'TRAC', 0, 0, ND,
     +                IOTRAC, -1)
*
         LOCAL(1) = 0
*
      ELSE
*
*  **    Clear the pointers in the skeleton
*
         DO 25 ILEV = 1, NLEVMX
            JSKL = LQ(JSKLT-ILEV)
            DO 20 I = 1, IQ(JSKL-3)
               IQ(JSKL+I) = 0
   20       CONTINUE
   25    CONTINUE
      ENDIF
*
* *** Fill up the skeleton upto NLEVEL
*
      IF (NLEVEL.GT.1) THEN
         DO 60 ILEV = 2, NLEVEL
            JSKL  = LQ(JSKLT-ILEV)
            NINSK = LINMX(ILEV)
            JOFF  = JSKL + IQ(JSKL-3)
            DO 40 IL = 1, ILEV-1
               IF (IQ(JOFF+IL).EQ.LINDEX(IL)) GO TO 40
               DO 30 I = IL, ILEV-1
                  IQ(JOFF+I) = LINDEX(I)
   30          CONTINUE
               DO 35 I = 1, NINSK
                 JSK  = LQ(JSKL-I)
                 IQ(JSK+1) = 0
   35          CONTINUE
               GO TO 45
   40       CONTINUE
   45       JSK  = LQ(JSKL-LINDEX(ILEV))
            IF (IQ(JSK+1).LE.0) THEN
               LQ(JSK-1) = LQ(JGPAR-ILEV)
               IQ(JSK+1) = IQ(JGPAR+ILEV)
               IQ(JSK+2) = LVOLUM(ILEV)
               DO 50 I = 1, 3
                  Q(JSK+2+I) = GTRAN(I,ILEV)
   50          CONTINUE
               DO 55 I = 1, 10
                  Q(JSK+5+I) = GRMAT(I,ILEV)
   55          CONTINUE
            ENDIF
   60    CONTINUE
      ENDIF
*
* *** Initialize pointers
*
      NJFREE = 1
      NJGARB = 0
      NJINVO = 0
      NLDOWN = 1
*
 1001 FORMAT ('/ ',I3,'I ',I3,'F ')
*                                                             END GLSKLT
      END
+DECK,GLTRAC.
*CMZ :  3.21/03 06/10/94  16.34.43  by  S.Giani
*-- Author :
      SUBROUTINE GLTRAC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GLTRAC                                                *
C.    *                                                                *
C.    *   Extracts next track from stack JSTAK and prepares commons    *
C.    *    /GCTRAK/, /GCKINE/ and /GCVOLU/                             *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
      DIMENSION RNDM(5)
+SELF,IF=-SINGLE.
      DOUBLE PRECISION P2,GETOTD,GEKIND
      DOUBLE PRECISION PXD,PYD,PZD,ONE,HNORM,DAMASS,PP
+SELF.
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
*
* *** Extract next track from stack JSTAK
*
      IF(ISTORD.EQ.1) THEN
*
* *** User ordering of tracks if requested
         CALL GSTORD
      ENDIF
      ISTAK = IQ(JSTAK+1)
      IQ(JSTAK+1) = ISTAK -1
      JST = JSTAK +NWSTAK*IQ(JSTAK+1) +3
      ITRA   = IQ(JST+1)
      IF (ITRA.LT.0) THEN
         ITRA = -ITRA
      ELSE
*
*        This is a new track. We set to zero the stack number and
*        update the vertex number
         ISTAK = 0
         JK=LQ(JKINE-ITRA)
         IVERT=Q(JK+6)
      ENDIF
      IPART  = IQ(JST+2)
      DO 60 I = 1,3
         VERT(I) = Q(JST+3+I)
        PVERT(I) = Q(JST+6+I)
   60 CONTINUE
      TOFG   = Q(JST+10)
      SAFETY = Q(JST+11)
      UPWGHT = Q(JST+12)
*
* *** Prepare tracking parameters
*
      VECT(1) = VERT(1)
      VECT(2) = VERT(2)
      VECT(3) = VERT(3)
      PXD = PVERT(1)
      PYD = PVERT(2)
      PZD = PVERT(3)
      P2 = PXD**2+PYD**2+PZD**2
      IF(P2.GT.0.) THEN
         PP    = SQRT(P2)
         HNORM = ONE/PP
         VECT(4) = PVERT(1)*HNORM
         VECT(5) = PVERT(2)*HNORM
         VECT(6) = PVERT(3)*HNORM
         VECT(7) = PP
      ELSE
         VECT(4) = 0.
         VECT(5) = 0.
         VECT(6) = 1.
         VECT(7) = 0.
      ENDIF
*
*  ** Reload Particle characteristics, if needed
*
      IF (IPART.NE.IPAOLD) THEN
         JPA = LQ(JPART-IPART)
         DO 90 I = 1,5
            NAPART(I) = IQ(JPA+I)
   90    CONTINUE
         ITRTYP = Q(JPA+6)
         AMASS  = Q(JPA+7)
         CHARGE = Q(JPA+8)
         TLIFE  = Q(JPA+9)
         IUPD   = 0
         IPAOLD = IPART
      ENDIF
*
      DAMASS = AMASS
      GETOTD = SQRT(P2+DAMASS**2)
      GEKIND = GETOTD - DAMASS
      GETOT  = GETOTD
      GEKIN  = GEKIND
*
      IF (ITRTYP.EQ.7) THEN
*
* *** Cerenkov photon. Retrieve polarisation
         JPO = LQ(JSTAK-1)+(ISTAK-1)*3
         POLAR(1) = Q(JPO+1)
         POLAR(2) = Q(JPO+2)
         POLAR(3) = Q(JPO+3)
      ELSE
         CALL GEKBIN
      ENDIF
*
      SLENG  = 0.
      NSTEP  = 0
      NTMSTO = NTMSTO +1
      NTMULT = NTMSTO
      ISTORY = 0
*
*  ** Initialize interaction probabilities
*
      IF (ITRTYP.EQ.1) THEN
*      Gammas
         CALL GRNDM(RNDM,5)
         ZINTPA = -LOG(RNDM(1))
         ZINTCO = -LOG(RNDM(2))
         ZINTPH = -LOG(RNDM(3))
         ZINTPF = -LOG(RNDM(4))
         ZINTRA = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.2) THEN
*       Electrons
         CALL GRNDM(RNDM,3)
         ZINTBR = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
         ZINTAN = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.3) THEN
*       Neutral hadrons
         CALL GRNDM(RNDM,2)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
      ELSE IF (ITRTYP.EQ.4) THEN
*       Charged hadrons
         CALL GRNDM(RNDM,3)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
         ZINTDR = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.5) THEN
*       Muons
         CALL GRNDM(RNDM,5)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTBR = -LOG(RNDM(2))
         ZINTPA = -LOG(RNDM(3))
         ZINTDR = -LOG(RNDM(4))
         ZINTMU = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.7) THEN
*       Cerenkov photons
         CALL GRNDM(RNDM,1)
         ZINTLA = -LOG(RNDM(1))
      ELSE IF (ITRTYP.EQ.8) THEN
*       Ions
         CALL GRNDM(RNDM,2)
         ZINTHA = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
      ENDIF
*
*   * Prepare common /GCVOLU/ and structure JGPAR, if needed
*
      IF (NJTMAX.LE.0) THEN
        NLEVEL=0
        CALL GMEDIA (VECT, NUMED)
      ENDIF
      INFROM = 0
*                                                             END GLTRAC
      END
 
+DECK,GNCKOV.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GNCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine calculates the number of Cerenkov photons       *
C.    *   produced per centimeter in the current medium.               *
C.    *                                                                *
C.    *   ==>Called by : GRANGI                                        *
C.    *      Authors     R.Jones, F.Carminati ********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCTMED.
+SEQ,GCUNIT.
+SEQ,GCTRAK.
+SEQ,GCKINE.
+SEQ,GCONSP.
*
      PARAMETER (RFACT=369.81E9)
*
*   ------------------------------------------------------------------
*
* *** See whether we generate at least one photon
*
      THRIND = GETOT/VECT(7)
      IF(Q(JINDEX+NPCKOV).LT.THRIND) THEN
         DP   = 0.
         GE   = 0.
      ELSEIF(Q(JINDEX+1).GE.THRIND) THEN
         PMIN = Q(JTCKOV+2)
         DP   = Q(JTCKOV+NPCKOV+1)-PMIN
         GE   = Q(JCURIN+NPCKOV)
         JMIN = 1
      ELSE
         JMIN = 1
         JMAX = NPCKOV
   10    JMED = (JMIN+JMAX)/2
         IF(Q(JINDEX+JMED).LT.THRIND) THEN
            JMIN = JMED
         ELSE
            JMAX = JMED
         ENDIF
         IF(JMAX-JMIN.GT.1) GO TO 10
         RATIO =
     +   (THRIND-Q(JINDEX+JMIN))/(Q(JINDEX+JMIN+1)-Q(JINDEX+JMIN))
         RATI1 = 1.-RATIO
         PMIN  = Q(JTCKOV+JMIN+1)*RATI1+Q(JTCKOV+JMIN+2)*RATIO
         DP    = Q(JTCKOV+NPCKOV+1)-PMIN
         GEMIN = Q(JCURIN+JMIN)*RATI1+Q(JCURIN+JMIN+1)*RATIO
         GE    = Q(JCURIN+NPCKOV)-GEMIN
      ENDIF
      DNDL = RFACT*(CHARGE**2)*(DP-GE*THRIND**2)
 999  CONTINUE
      END
+DECK,GPCXYZ
*CMZ :  3.21/03 11/10/94  13.43.45  by  S.Ravndal
*-- Author :
      SUBROUTINE GPCXYZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        Print track and volume parameters at current point      *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCVOLU
+SEQ,GCTRAK
+SEQ,GCNUM
+SEQ,GCUNIT
      DIMENSION MECNAM(20)
      CHARACTER*4 KUN1,KUN2
      SAVE IEVOLD,NTMOLD
      DATA IEVOLD,NTMOLD/-1,-1/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFINIT(9).EQ.0)THEN
         IFINIT(9)=1
         IEVOLD=-1
         NTMOLD=-1
      ENDIF
C
      NM=NMEC
      IF(NM.EQ.0)THEN
         MECNAM(1)=NAMEC(29)
         NM=1
      ELSE
         DO 10 I=1,NMEC
            MEC=LMEC(I)
            IF(MEC.LE.MAXMEC) THEN
               MECNAM(I)=NAMEC(MEC)
            ELSEIF(MEC-100.LE.MAXME1.AND.MEC-100.GT.0) THEN
               MECNAM(I)=NAMEC1(MEC-100)
            ENDIF
  10     CONTINUE
      ENDIF
C
      IF(IEVENT.EQ.IEVOLD.AND.NTMULT.EQ.NTMOLD)GO TO 20
C
C
      TOFGN=TOFG*1.E+9
      WRITE(CHMAIL,1000)ITRA,ISTAK,NTMULT,(NAPART(I),I=1,5),TOFGN
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1100)
      CALL GMAIL(0,0)
      IEVOLD=IEVENT
      NTMOLD=NTMULT
C
  20  R=SQRT(VECT(1)**2+VECT(2)**2)
      CALL GEVKEV(DESTEP,DESU,KUN1)
      CALL GEVKEV(GEKIN ,GEKU,KUN2)
      NS = 1
      NW = MIN(NS+5,NM)
      WRITE(CHMAIL,2000)(VECT(I),I=1,3),R,NAMES(NLEVEL),NUMBER(NLEVEL)
     +      ,SLENG,STEP,DESU,KUN1,GEKU,KUN2,(MECNAM(I),I=NS,NW)
  30  CALL GMAIL(0,0)
      IF(NM.GT.NW) THEN
         NS = NW + 1
         NW = MIN(NS+5,NM)
         WRITE(CHMAIL,3000) (MECNAM(I),I=NS,NW)
         GOTO 30
      ENDIF
C
 1000 FORMAT(' =====> TRACK ',I4,' STACK NR',I4,' NTMULT=',I5,5X,
     +5A4,5X,'TOFG =',F10.3,' NS')
 1100 FORMAT('       X           Y           Z           R   ',
     +'    NAME  NUMBER',
     +'   SLENG      STEP      DESTEP     GEKIN    MECHANISMS')
 2000 FORMAT(1X,4F12.4,2X,A4,2X,I4,2X,2F10.4,F7.1,A4,F9.3,A4,2X,
     +          6(A4,1X))
 3000 FORMAT(101X,6(A4,1X))
C
      END
+DECK,GPGKIN.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GPGKIN
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        Print kinematics of secondary tracks at the current     *
C.    *        interaction point.                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>,GUSTEP,GDEBUG                         *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCKING
+SEQ,GCUNIT
      CHARACTER*4 UNITK,UNITE,UNITSK,UNITSE
C.
C.    ------------------------------------------------------------------
C.
      SEK=0.
      SET=0.
      DO 10 I=1,NGKINE
         ITY=GKIN(5,I)
         ET=GKIN(4,I)
         TOFDN=TOFD(I)*1.E+9
         JP=LQ(JPART-ITY)
         EK=ET-Q(JP+7)
         SEK=SEK+EK
         SET=SET+ET
         CALL GEVKEV(EK,EKU,UNITK)
         CALL GEVKEV(ET,ETU,UNITE)
         IF(I.LT.NGKINE)THEN
            WRITE(CHMAIL,1000)I,(IQ(JP+J),J=1,4),EKU,UNITK,ETU,UNITE
     +                         ,TOFDN
         ELSE
            CALL GEVKEV(SEK,SEKU,UNITSK)
            CALL GEVKEV(SET,SETU,UNITSE)
            WRITE(CHMAIL,2000)I,(IQ(JP+J),J=1,4),EKU,UNITK,ETU,UNITE
     +                         ,TOFDN,SEKU,UNITSK,SETU,UNITSE
         ENDIF
         CALL GMAIL(0,0)
  10  CONTINUE
*
 1000 FORMAT(4X,'===>',I3,1X,4A4,' EK=',F7.3,A,' ET=',F7.3,A,
     +       ' TOFD=',F10.3,' ns')
 2000 FORMAT(4X,'===>',I3,1X,4A4,' EK=',F7.3,A,' ET=',F7.3,A,
     +       ' TOFD=',F10.3,' ns   SEK=',F7.3,A,' SET=',F7.3,A)
      END
+DECK,GPJXYZ
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GPJXYZ(IT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints JXYZ bank for track number IT                     *
C.    *       If IT=0 Prints all track banks                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCUNIT
C.
C.    ------------------------------------------------------------------
C.
      I1=1
      I2=NTRACK
      IF(IT.NE.0)I1=IT
      IF(IT.NE.0)I2=IT
      IF(I2.GT.NTRACK)GO TO 99
      IF(I1.LT.1)GO TO 99
      IF(JKINE.LE.0)GO TO 99
      IF(JXYZ.LE.0)GO TO 99
C
      DO 90 I=I1,I2
         JK=LQ(JKINE-I)
         IF(JK.NE.0)THEN
            IPART=Q(JK+5)
            JPA=LQ(JPART-IPART)
            WRITE(CHMAIL,1000)I,(IQ(JPA+L),L=1,4)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,1100)
            CALL GMAIL(0,0)
C
            JX=LQ(JXYZ-I)
            IPOINT=JX+3
            IP=0
  10        NPOINT=Q(IPOINT)
            IF(NPOINT.GT.0)THEN
               IPT=Q(IPOINT+1)
               DO 20 K=1,NPOINT
                  KP=IPOINT+3*K-2
                  IP=IP+1
                  WRITE(CHMAIL,2000)IP,IPT,(Q(KP+L),L=1,3)
                  CALL GMAIL(0,0)
  20           CONTINUE
C
               IPOINT=IPOINT+3.*Q(IPOINT)+2.
               GO TO 10
            ENDIF
         ENDIF
  90  CONTINUE
C
 1000 FORMAT(3X,'JXYZ',3X,'TRACK NUMBER',I5,2X,4A4)
 1100 FORMAT(6X,'POINT',6X,'PART',6X,'X',10X,'Y',10X,'Z')
 2000 FORMAT(4X,I6,6X,I4,2X,F10.4,1X,F10.4,1X,F10.4)
C
  99  RETURN
      END
+DECK,GRANOR.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GRANOR(A,B)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To generate 2 numbers A and B following a NORMAL         *
C.    *       distribution (mean=0 sigma=1.)                           *
C.    *         Copy of the CERN Library routine RANNOR                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, many GEANT routines                  *
C.    *       Author    F.Carminati *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION RNDM(2)
*
      CALL GRNDM(RNDM,2)
      Y=RNDM(1)
      Z=RNDM(2)
      X=6.283185*Z
      A1=SQRT (-2.0*LOG(Y))
      A=A1*SIN (X)
      B=A1*COS (X)
      RETURN
      END
 
+DECK,GRKUTA
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GRKUTA (CHARGE,STEP,VECT,VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Runge-Kutta method for tracking a particle through a magnetic *
C.    *  field. Uses Nystroem algorithm (See Handbook Nat. Bur. of     *
C.    *  Standards, procedure 25.5.20)                                 *
C.    *                                                                *
C.    *  Input parameters                                              *
C.    *       CHARGE    Particle charge                                *
C.    *       STEP      Step size                                      *
C.    *       VECT      Initial co-ords,direction cosines,momentum     *
C.    *  Output parameters                                             *
C.    *       VOUT      Output co-ords,direction cosines,momentum      *
C.    *  User routine called                                           *
C.    *       CALL GUFLD(X,F)                                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSWIM                               *
C.    *       Authors    R.Brun, M.Hansroul  *********                 *
C.    *                  V.Perevoztchikov (CUT STEP implementation)    *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
+SELF
      REAL CHARGE, STEP, VECT(*), VOUT(*), F(4)
      REAL XYZT(3), XYZ(3), X, Y, Z, XT, YT, ZT
      DIMENSION SECXS(4),SECYS(4),SECZS(4),HXP(3)
      EQUIVALENCE (X,XYZ(1)),(Y,XYZ(2)),(Z,XYZ(3)),
     +            (XT,XYZT(1)),(YT,XYZT(2)),(ZT,XYZT(3))
*
      PARAMETER (MAXIT = 1992, MAXCUT = 11)
      PARAMETER (EC=2.9979251D-4,DLT=1D-4,DLT32=DLT/32)
      PARAMETER (ZERO=0, ONE=1, TWO=2, THREE=3)
      PARAMETER (THIRD=ONE/THREE, HALF=ONE/TWO)
      PARAMETER (PISQUA=.986960440109D+01)
      PARAMETER      (IX=1,IY=2,IZ=3,IPX=4,IPY=5,IPZ=6)
*.
*.    ------------------------------------------------------------------
*.
*             This constant is for units CM,GEV/C and KGAUSS
*
      ITER = 0
      NCUT = 0
      DO 10 J=1,7
         VOUT(J)=VECT(J)
   10 CONTINUE
      PINV   = EC * CHARGE / VECT(7)
      TL = 0.
      H      = STEP
*
*
   20 REST  = STEP-TL
      IF (ABS(H).GT.ABS(REST)) H = REST
      CALL GUFLD(VOUT,F)
*
*             Start of integration
*
      X      = VOUT(1)
      Y      = VOUT(2)
      Z      = VOUT(3)
      A      = VOUT(4)
      B      = VOUT(5)
      C      = VOUT(6)
*
      H2     = HALF * H
      H4     = HALF * H2
      PH     = PINV * H
      PH2    = HALF * PH
      SECXS(1) = (B * F(3) - C * F(2)) * PH2
      SECYS(1) = (C * F(1) - A * F(3)) * PH2
      SECZS(1) = (A * F(2) - B * F(1)) * PH2
      ANG2 = (SECXS(1)**2 + SECYS(1)**2 + SECZS(1)**2)
      IF (ANG2.GT.PISQUA) GO TO 40
      DXT    = H2 * A + H4 * SECXS(1)
      DYT    = H2 * B + H4 * SECYS(1)
      DZT    = H2 * C + H4 * SECZS(1)
      XT     = X + DXT
      YT     = Y + DYT
      ZT     = Z + DZT
*
*              Second intermediate point
*
      EST = ABS(DXT)+ABS(DYT)+ABS(DZT)
      IF (EST.GT.H) GO TO 30
 
      CALL GUFLD(XYZT,F)
      AT     = A + SECXS(1)
      BT     = B + SECYS(1)
      CT     = C + SECZS(1)
*
      SECXS(2) = (BT * F(3) - CT * F(2)) * PH2
      SECYS(2) = (CT * F(1) - AT * F(3)) * PH2
      SECZS(2) = (AT * F(2) - BT * F(1)) * PH2
      AT     = A + SECXS(2)
      BT     = B + SECYS(2)
      CT     = C + SECZS(2)
      SECXS(3) = (BT * F(3) - CT * F(2)) * PH2
      SECYS(3) = (CT * F(1) - AT * F(3)) * PH2
      SECZS(3) = (AT * F(2) - BT * F(1)) * PH2
      DXT    = H * (A + SECXS(3))
      DYT    = H * (B + SECYS(3))
      DZT    = H * (C + SECZS(3))
      XT     = X + DXT
      YT     = Y + DYT
      ZT     = Z + DZT
      AT     = A + TWO*SECXS(3)
      BT     = B + TWO*SECYS(3)
      CT     = C + TWO*SECZS(3)
*
      EST = ABS(DXT)+ABS(DYT)+ABS(DZT)
      IF (EST.GT.2.*ABS(H)) GO TO 30
 
      CALL GUFLD(XYZT,F)
*
      Z      = Z + (C + (SECZS(1) + SECZS(2) + SECZS(3)) * THIRD) * H
      Y      = Y + (B + (SECYS(1) + SECYS(2) + SECYS(3)) * THIRD) * H
      X      = X + (A + (SECXS(1) + SECXS(2) + SECXS(3)) * THIRD) * H
*
      SECXS(4) = (BT*F(3) - CT*F(2))* PH2
      SECYS(4) = (CT*F(1) - AT*F(3))* PH2
      SECZS(4) = (AT*F(2) - BT*F(1))* PH2
      A      = A+(SECXS(1)+SECXS(4)+TWO * (SECXS(2)+SECXS(3))) * THIRD
      B      = B+(SECYS(1)+SECYS(4)+TWO * (SECYS(2)+SECYS(3))) * THIRD
      C      = C+(SECZS(1)+SECZS(4)+TWO * (SECZS(2)+SECZS(3))) * THIRD
*
      EST    = ABS(SECXS(1)+SECXS(4) - (SECXS(2)+SECXS(3)))
     ++        ABS(SECYS(1)+SECYS(4) - (SECYS(2)+SECYS(3)))
     ++        ABS(SECZS(1)+SECZS(4) - (SECZS(2)+SECZS(3)))
*
      IF (EST.GT.DLT .AND. ABS(H).GT.1.E-4) GO TO 30
      ITER = ITER + 1
      NCUT = 0
*               If too many iterations, go to HELIX
      IF (ITER.GT.MAXIT) GO TO 40
*
      TL = TL + H
      IF (EST.LT.(DLT32)) THEN
         H = H*TWO
      ENDIF
      CBA    = ONE/ SQRT(A*A + B*B + C*C)
      VOUT(1) = X
      VOUT(2) = Y
      VOUT(3) = Z
      VOUT(4) = CBA*A
      VOUT(5) = CBA*B
      VOUT(6) = CBA*C
      REST = STEP - TL
      IF (STEP.LT.0.) REST = -REST
      IF (REST .GT. 1.E-5*ABS(STEP)) GO TO 20
*
      GO TO 999
*
**              CUT STEP
   30 NCUT = NCUT + 1
*               If too many cuts , go to HELIX
      IF (NCUT.GT.MAXCUT)       GO TO 40
      H = H*HALF
      GO TO 20
*
**              ANGLE TOO BIG, USE HELIX
   40 F1  = F(1)
      F2  = F(2)
      F3  = F(3)
      F4  = SQRT(F1**2+F2**2+F3**2)
      RHO = -F4*PINV
      TET = RHO * STEP
      IF(TET.NE.0.) THEN
         HNORM = ONE/F4
         F1 = F1*HNORM
         F2 = F2*HNORM
         F3 = F3*HNORM
*
         HXP(1) = F2*VECT(IPZ) - F3*VECT(IPY)
         HXP(2) = F3*VECT(IPX) - F1*VECT(IPZ)
         HXP(3) = F1*VECT(IPY) - F2*VECT(IPX)
 
         HP = F1*VECT(IPX) + F2*VECT(IPY) + F3*VECT(IPZ)
*
         RHO1 = ONE/RHO
         SINT = SIN(TET)
         COST = TWO*SIN(HALF*TET)**2
*
         G1 = SINT*RHO1
         G2 = COST*RHO1
         G3 = (TET-SINT) * HP*RHO1
         G4 = -COST
         G5 = SINT
         G6 = COST * HP
 
         VOUT(IX) = VECT(IX) + (G1*VECT(IPX) + G2*HXP(1) + G3*F1)
         VOUT(IY) = VECT(IY) + (G1*VECT(IPY) + G2*HXP(2) + G3*F2)
         VOUT(IZ) = VECT(IZ) + (G1*VECT(IPZ) + G2*HXP(3) + G3*F3)
 
         VOUT(IPX) = VECT(IPX) + (G4*VECT(IPX) + G5*HXP(1) + G6*F1)
         VOUT(IPY) = VECT(IPY) + (G4*VECT(IPY) + G5*HXP(2) + G6*F2)
         VOUT(IPZ) = VECT(IPZ) + (G4*VECT(IPZ) + G5*HXP(3) + G6*F3)
*
      ELSE
         VOUT(IX) = VECT(IX) + STEP*VECT(IPX)
         VOUT(IY) = VECT(IY) + STEP*VECT(IPY)
         VOUT(IZ) = VECT(IZ) + STEP*VECT(IPZ)
*
      ENDIF
*
  999 CONTINUE
      END
+DECK,GRNDM.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GRNDM(RVEC,LEN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To generate a vector RVECV of LEN random numbers         *
C.    *         Copy of the CERN Library routine RANECU                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, many GEANT routines                  *
C.    *       Author    F.Carminati *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF,IF=CRAY
CDIR$ STACK
+SELF
      DIMENSION RVEC(*)
+SELF,IF=CRAY
      REAL ISEED, ISEED1, ISEED2, K, C1, C2, IZ
+SELF,IF=IBMALL,IBMRT,APO10K,HPUX, MSDOS,WINNT.
      DOUBLE PRECISION ISEED, ISEED1, ISEED2, K, C1, C2, IZ
+SELF,IF=IBMALL,IBMRT,CRAY,APO10K,HPUX,MSDOS,WINNT.
      PARAMETER (C1=1./53668.,C2=1./52774.)
+SELF
      PARAMETER  (MAXSEQ=215)
      COMMON / GCRNDM / JSEQ(2), ISEED(2,MAXSEQ)
C
      ISEQ   = JSEQ(1)
      ISEED1 = ISEED(1,ISEQ)
      ISEED2 = ISEED(2,ISEQ)
      DO 100 I= 1, LEN
+SELF,IF=APOLLO,VAX,SUN,SGI,DECS,CONVEX,IPSC.
        K = ISEED1/53668
+SELF,IF=IBMALL,IBMRT,CRAY,APO10K,HPUX,MSDOS,WINNT.
        K = INT(ISEED1*C1)
+SELF
        ISEED1 = 40014*(ISEED1 - K*53668) - K*12211
        IF (ISEED1 .LT. 0) ISEED1=ISEED1+2147483563
C
+SELF,IF=APOLLO,VAX,SUN,SGI,DECS,CONVEX,IPSC.
        K = ISEED2/52774
+SELF,IF=IBMALL,IBMRT,CRAY,APO10K,HPUX, MSDOS, WINNT.
        K = INT(ISEED2*C2)
+SELF
        ISEED2 = 40692*(ISEED2 - K*52774) - K* 3791
        IF (ISEED2 .LT. 0) ISEED2=ISEED2+2147483399
C
        IZ = ISEED1 - ISEED2
        IF (IZ .LE. 0)  IZ = IZ + 2147483562
C
        RVEC(I) = IZ * 4.6566128E-10
  100 CONTINUE
      ISEED(1,ISEQ) = ISEED1
      ISEED(2,ISEQ) = ISEED2
      END
+DECK,GRNDMQ.
*CMZ :  3.21/03 06/10/94  14.09.09  by  S.Ravndal
*-- Author :
      SUBROUTINE GRNDMQ(IS1,IS2,ISEQ,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To set/retrieve the seed of the random number generator  *
C.    *        Copy of the CERN Library routine RECUSQ                 *
C.    *        Each sequence has a period of 10**9 numbers             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, many GEANT routines                  *
C.    *       Author    R.Brun, F.Carminati  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
      CHARACTER*(*) CHOPT
      CHARACTER*12  CCHOPT
+SELF,IF=CRAY
      REAL ISEED
+SELF,IF=IBMALL,IBMRT,APO10K,HPUX,MSDOS,WINNT.
      DOUBLE PRECISION ISEED
+SELF
      PARAMETER  (MAXSEQ=215)
      COMMON / GCRNDM / JSEQ(2), ISEED(2,MAXSEQ)
      DIMENSION  LSEQS(2,MAXSEQ)
      DATA LSEQS(1,  1),LSEQS(2,  1 )/      9876,     54321/
      DATA LSEQS(1,  2),LSEQS(2,  2 )/1299961164, 253987020/
      DATA LSEQS(1,  3),LSEQS(2,  3 )/ 669708517,2079157264/
      DATA LSEQS(1,  4),LSEQS(2,  4 )/ 190904760, 417696270/
      DATA LSEQS(1,  5),LSEQS(2,  5 )/1289741558,1376336092/
      DATA LSEQS(1,  6),LSEQS(2,  6 )/1803730167, 324952955/
      DATA LSEQS(1,  7),LSEQS(2,  7 )/ 489854550, 582847132/
      DATA LSEQS(1,  8),LSEQS(2,  8 )/1348037628,1661577989/
      DATA LSEQS(1,  9),LSEQS(2,  9 )/ 350557787,1155446919/
      DATA LSEQS(1, 10),LSEQS(2, 10 )/ 591502945, 634133404/
      DATA LSEQS(1, 11),LSEQS(2, 11 )/1901084678, 862916278/
      DATA LSEQS(1, 12),LSEQS(2, 12 )/1988640932,1785523494/
      DATA LSEQS(1, 13),LSEQS(2, 13 )/1873836227, 508007031/
      DATA LSEQS(1, 14),LSEQS(2, 14 )/1146416592, 967585720/
      DATA LSEQS(1, 15),LSEQS(2, 15 )/1837193353,1522927634/
      DATA LSEQS(1, 16),LSEQS(2, 16 )/  38219936, 921609208/
      DATA LSEQS(1, 17),LSEQS(2, 17 )/ 349152748, 112892610/
      DATA LSEQS(1, 18),LSEQS(2, 18 )/ 744459040,1735807920/
      DATA LSEQS(1, 19),LSEQS(2, 19 )/1983990104, 728277902/
      DATA LSEQS(1, 20),LSEQS(2, 20 )/ 309164507,2126677523/
      DATA LSEQS(1, 21),LSEQS(2, 21 )/ 362993787,1897782044/
      DATA LSEQS(1, 22),LSEQS(2, 22 )/ 556776976, 462072869/
      DATA LSEQS(1, 23),LSEQS(2, 23 )/1584900822,2019394912/
      DATA LSEQS(1, 24),LSEQS(2, 24 )/1249892722, 791083656/
      DATA LSEQS(1, 25),LSEQS(2, 25 )/1686600998,1983731097/
      DATA LSEQS(1, 26),LSEQS(2, 26 )/1127381380, 198976625/
      DATA LSEQS(1, 27),LSEQS(2, 27 )/1999420861,1810452455/
      DATA LSEQS(1, 28),LSEQS(2, 28 )/1972906041, 664182577/
      DATA LSEQS(1, 29),LSEQS(2, 29 )/  84636481,1291886301/
      DATA LSEQS(1, 30),LSEQS(2, 30 )/1186362995, 954388413/
      DATA LSEQS(1, 31),LSEQS(2, 31 )/2141621785,  61738584/
      DATA LSEQS(1, 32),LSEQS(2, 32 )/1969581251,1557880415/
      DATA LSEQS(1, 33),LSEQS(2, 33 )/1150606439, 136325185/
      DATA LSEQS(1, 34),LSEQS(2, 34 )/  95187861,1592224108/
      DATA LSEQS(1, 35),LSEQS(2, 35 )/ 940517655,1629971798/
      DATA LSEQS(1, 36),LSEQS(2, 36 )/ 215350428, 922659102/
      DATA LSEQS(1, 37),LSEQS(2, 37 )/ 786161212,1121345074/
      DATA LSEQS(1, 38),LSEQS(2, 38 )/1450830056,1922787776/
      DATA LSEQS(1, 39),LSEQS(2, 39 )/1696578057,2025150487/
      DATA LSEQS(1, 40),LSEQS(2, 40 )/1803414346,1851324780/
      DATA LSEQS(1, 41),LSEQS(2, 41 )/1017898585,1452594263/
      DATA LSEQS(1, 42),LSEQS(2, 42 )/1184497978,  82122239/
      DATA LSEQS(1, 43),LSEQS(2, 43 )/ 633338765,1829684974/
      DATA LSEQS(1, 44),LSEQS(2, 44 )/ 430889421, 230039326/
      DATA LSEQS(1, 45),LSEQS(2, 45 )/ 492544653,  76320266/
      DATA LSEQS(1, 46),LSEQS(2, 46 )/ 389386975,1314148944/
      DATA LSEQS(1, 47),LSEQS(2, 47 )/1720322786, 709120323/
      DATA LSEQS(1, 48),LSEQS(2, 48 )/1868768216,1992898523/
      DATA LSEQS(1, 49),LSEQS(2, 49 )/ 443210610, 811117710/
      DATA LSEQS(1, 50),LSEQS(2, 50 )/1191938868,1548484733/
      DATA LSEQS(1, 51),LSEQS(2, 51 )/ 616890172, 159787986/
      DATA LSEQS(1, 52),LSEQS(2, 52 )/ 935835339,1231440405/
      DATA LSEQS(1, 53),LSEQS(2, 53 )/1058009367,1527613300/
      DATA LSEQS(1, 54),LSEQS(2, 54 )/1463148129,1970575097/
      DATA LSEQS(1, 55),LSEQS(2, 55 )/1795336935, 434768675/
      DATA LSEQS(1, 56),LSEQS(2, 56 )/ 274019517, 605098487/
      DATA LSEQS(1, 57),LSEQS(2, 57 )/ 483689317, 217146977/
      DATA LSEQS(1, 58),LSEQS(2, 58 )/2070804364, 340596558/
      DATA LSEQS(1, 59),LSEQS(2, 59 )/ 930226308,1602100969/
      DATA LSEQS(1, 60),LSEQS(2, 60 )/ 989324440, 801809442/
      DATA LSEQS(1, 61),LSEQS(2, 61 )/ 410606853,1893139948/
      DATA LSEQS(1, 62),LSEQS(2, 62 )/1583588576,1219225407/
      DATA LSEQS(1, 63),LSEQS(2, 63 )/2102034391,1394921405/
      DATA LSEQS(1, 64),LSEQS(2, 64 )/2005037790,2031006861/
      DATA LSEQS(1, 65),LSEQS(2, 65 )/1244218766, 923231061/
      DATA LSEQS(1, 66),LSEQS(2, 66 )/  49312790, 775496649/
      DATA LSEQS(1, 67),LSEQS(2, 67 )/ 721012176, 321339902/
      DATA LSEQS(1, 68),LSEQS(2, 68 )/1719909107,1865748178/
      DATA LSEQS(1, 69),LSEQS(2, 69 )/1156177430,1257110891/
      DATA LSEQS(1, 70),LSEQS(2, 70 )/ 307561322,1918244397/
      DATA LSEQS(1, 71),LSEQS(2, 71 )/ 906041433, 360476981/
      DATA LSEQS(1, 72),LSEQS(2, 72 )/1591375755, 268492659/
      DATA LSEQS(1, 73),LSEQS(2, 73 )/ 461522398, 227343256/
      DATA LSEQS(1, 74),LSEQS(2, 74 )/2145930725,2020665454/
      DATA LSEQS(1, 75),LSEQS(2, 75 )/1938419274,1331283701/
      DATA LSEQS(1, 76),LSEQS(2, 76 )/ 174405412, 524140103/
      DATA LSEQS(1, 77),LSEQS(2, 77 )/ 494343653,  18063908/
      DATA LSEQS(1, 78),LSEQS(2, 78 )/1025534808, 181709577/
      DATA LSEQS(1, 79),LSEQS(2, 79 )/2048959776,1913665637/
      DATA LSEQS(1, 80),LSEQS(2, 80 )/ 950636517, 794796256/
      DATA LSEQS(1, 81),LSEQS(2, 81 )/1828843197,1335757744/
      DATA LSEQS(1, 82),LSEQS(2, 82 )/ 211109723, 983900607/
      DATA LSEQS(1, 83),LSEQS(2, 83 )/ 825474095,1046009991/
      DATA LSEQS(1, 84),LSEQS(2, 84 )/ 374915657, 381856628/
      DATA LSEQS(1, 85),LSEQS(2, 85 )/1241296328, 698149463/
      DATA LSEQS(1, 86),LSEQS(2, 86 )/1260624655,1024538273/
      DATA LSEQS(1, 87),LSEQS(2, 87 )/ 900676210,1628865823/
      DATA LSEQS(1, 88),LSEQS(2, 88 )/ 697951025, 500570753/
      DATA LSEQS(1, 89),LSEQS(2, 89 )/1007920268,1708398558/
      DATA LSEQS(1, 90),LSEQS(2, 90 )/ 264596520, 624727803/
      DATA LSEQS(1, 91),LSEQS(2, 91 )/1977924811, 674673241/
      DATA LSEQS(1, 92),LSEQS(2, 92 )/1440257718, 271184151/
      DATA LSEQS(1, 93),LSEQS(2, 93 )/1928778847, 993535203/
      DATA LSEQS(1, 94),LSEQS(2, 94 )/1307807366,1801502463/
      DATA LSEQS(1, 95),LSEQS(2, 95 )/1498732610, 300876954/
      DATA LSEQS(1, 96),LSEQS(2, 96 )/1617712402,1574250679/
      DATA LSEQS(1, 97),LSEQS(2, 97 )/1261800762,1556667280/
      DATA LSEQS(1, 98),LSEQS(2, 98 )/ 949929273, 560721070/
      DATA LSEQS(1, 99),LSEQS(2, 99 )/1766170474,1953522912/
      DATA LSEQS(1,100),LSEQS(2,100 )/1849939248,  19435166/
      DATA LSEQS(1,101),LSEQS(2,101 )/ 887262858,1219627824/
      DATA LSEQS(1,102),LSEQS(2,102 )/ 483086133, 603728993/
      DATA LSEQS(1,103),LSEQS(2,103 )/1330541052,1582596025/
      DATA LSEQS(1,104),LSEQS(2,104 )/1850591475, 723593133/
      DATA LSEQS(1,105),LSEQS(2,105 )/1431775678,1558439000/
      DATA LSEQS(1,106),LSEQS(2,106 )/ 922493739,1356554404/
      DATA LSEQS(1,107),LSEQS(2,107 )/1058517206, 948567762/
      DATA LSEQS(1,108),LSEQS(2,108 )/ 709067283,1350890215/
      DATA LSEQS(1,109),LSEQS(2,109 )/1044787723,2144304941/
      DATA LSEQS(1,110),LSEQS(2,110 )/ 999707003, 513837520/
      DATA LSEQS(1,111),LSEQS(2,111 )/2140038663,1850568788/
      DATA LSEQS(1,112),LSEQS(2,112 )/1803100150, 127574047/
      DATA LSEQS(1,113),LSEQS(2,113 )/ 867445693,1149173981/
      DATA LSEQS(1,114),LSEQS(2,114 )/ 408583729, 914837991/
      DATA LSEQS(1,115),LSEQS(2,115 )/1166715497, 602315845/
      DATA LSEQS(1,116),LSEQS(2,116 )/ 430738528,1743308384/
      DATA LSEQS(1,117),LSEQS(2,117 )/1388022681,1760110496/
      DATA LSEQS(1,118),LSEQS(2,118 )/1664028066, 654300326/
      DATA LSEQS(1,119),LSEQS(2,119 )/1767741172,1338181197/
      DATA LSEQS(1,120),LSEQS(2,120 )/1625723550,1742482745/
      DATA LSEQS(1,121),LSEQS(2,121 )/ 464486085,1507852127/
      DATA LSEQS(1,122),LSEQS(2,122 )/ 754082421,1187454014/
      DATA LSEQS(1,123),LSEQS(2,123 )/1315342834, 425995190/
      DATA LSEQS(1,124),LSEQS(2,124 )/ 960416608,2004255418/
      DATA LSEQS(1,125),LSEQS(2,125 )/1262630671, 671761697/
      DATA LSEQS(1,126),LSEQS(2,126 )/  59809238, 103525918/
      DATA LSEQS(1,127),LSEQS(2,127 )/1205644919,2107823293/
      DATA LSEQS(1,128),LSEQS(2,128 )/1615183160,1152411412/
      DATA LSEQS(1,129),LSEQS(2,129 )/1024474681,2118672937/
      DATA LSEQS(1,130),LSEQS(2,130 )/1703877649,1235091369/
      DATA LSEQS(1,131),LSEQS(2,131 )/1821417852,1098463802/
      DATA LSEQS(1,132),LSEQS(2,132 )/1738806466,1529062843/
      DATA LSEQS(1,133),LSEQS(2,133 )/ 620780646,1654833544/
      DATA LSEQS(1,134),LSEQS(2,134 )/1070174101, 795158254/
      DATA LSEQS(1,135),LSEQS(2,135 )/ 658537995,1693620426/
      DATA LSEQS(1,136),LSEQS(2,136 )/2055317555, 508053916/
      DATA LSEQS(1,137),LSEQS(2,137 )/1647371686,1282395762/
      DATA LSEQS(1,138),LSEQS(2,138 )/  29067379, 409683067/
      DATA LSEQS(1,139),LSEQS(2,139 )/1763495989,1917939635/
      DATA LSEQS(1,140),LSEQS(2,140 )/1602690753, 810926582/
      DATA LSEQS(1,141),LSEQS(2,141 )/ 885787576, 513818500/
      DATA LSEQS(1,142),LSEQS(2,142 )/1853512561,1195205756/
      DATA LSEQS(1,143),LSEQS(2,143 )/1798585498,1970460256/
      DATA LSEQS(1,144),LSEQS(2,144 )/1819261032,1306536501/
      DATA LSEQS(1,145),LSEQS(2,145 )/1133245275,     37901/
      DATA LSEQS(1,146),LSEQS(2,146 )/ 689459799,1334389069/
      DATA LSEQS(1,147),LSEQS(2,147 )/1730609912,1854586207/
      DATA LSEQS(1,148),LSEQS(2,148 )/1556832175,1228729041/
      DATA LSEQS(1,149),LSEQS(2,149 )/ 251375753, 683687209/
      DATA LSEQS(1,150),LSEQS(2,150 )/2083946182,1763106152/
      DATA LSEQS(1,151),LSEQS(2,151 )/2142981854,1365385561/
      DATA LSEQS(1,152),LSEQS(2,152 )/ 763711891,1735754548/
      DATA LSEQS(1,153),LSEQS(2,153 )/1581256466, 173689858/
      DATA LSEQS(1,154),LSEQS(2,154 )/2121337132,1247108250/
      DATA LSEQS(1,155),LSEQS(2,155 )/1004003636, 891894307/
      DATA LSEQS(1,156),LSEQS(2,156 )/ 569816524, 358675254/
      DATA LSEQS(1,157),LSEQS(2,157 )/ 626626425, 116062841/
      DATA LSEQS(1,158),LSEQS(2,158 )/ 632086003, 861268491/
      DATA LSEQS(1,159),LSEQS(2,159 )/1008211580, 779404957/
      DATA LSEQS(1,160),LSEQS(2,160 )/1134217766,1766838261/
      DATA LSEQS(1,161),LSEQS(2,161 )/1423829292,1706666192/
      DATA LSEQS(1,162),LSEQS(2,162 )/ 942037869,1549358884/
      DATA LSEQS(1,163),LSEQS(2,163 )/1959429535, 480779114/
      DATA LSEQS(1,164),LSEQS(2,164 )/ 778311037,1940360875/
      DATA LSEQS(1,165),LSEQS(2,165 )/1531372185,2009078158/
      DATA LSEQS(1,166),LSEQS(2,166 )/ 241935492,1050047003/
      DATA LSEQS(1,167),LSEQS(2,167 )/ 272453504,1870883868/
      DATA LSEQS(1,168),LSEQS(2,168 )/ 390441332,1057903098/
      DATA LSEQS(1,169),LSEQS(2,169 )/1230238834,1548117688/
      DATA LSEQS(1,170),LSEQS(2,170 )/1242956379,1217296445/
      DATA LSEQS(1,171),LSEQS(2,171 )/ 515648357,1675011378/
      DATA LSEQS(1,172),LSEQS(2,172 )/ 364477932, 355212934/
      DATA LSEQS(1,173),LSEQS(2,173 )/2096008713,1570161804/
      DATA LSEQS(1,174),LSEQS(2,174 )/1409752526, 214033983/
      DATA LSEQS(1,175),LSEQS(2,175 )/1288158292,1760636178/
      DATA LSEQS(1,176),LSEQS(2,176 )/ 407562666,1265144848/
      DATA LSEQS(1,177),LSEQS(2,177 )/1071056491,1582316946/
      DATA LSEQS(1,178),LSEQS(2,178 )/1014143949, 911406955/
      DATA LSEQS(1,179),LSEQS(2,179 )/ 203080461, 809380052/
      DATA LSEQS(1,180),LSEQS(2,180 )/ 125647866,1705464126/
      DATA LSEQS(1,181),LSEQS(2,181 )/2015685843, 599230667/
      DATA LSEQS(1,182),LSEQS(2,182 )/1425476020, 668203729/
      DATA LSEQS(1,183),LSEQS(2,183 )/1673735652, 567931803/
      DATA LSEQS(1,184),LSEQS(2,184 )/1714199325, 181737617/
      DATA LSEQS(1,185),LSEQS(2,185 )/1389137652, 678147926/
      DATA LSEQS(1,186),LSEQS(2,186 )/ 288547803, 435433694/
      DATA LSEQS(1,187),LSEQS(2,187 )/ 200159281, 654399753/
      DATA LSEQS(1,188),LSEQS(2,188 )/1580828223,1298308945/
      DATA LSEQS(1,189),LSEQS(2,189 )/1832286107, 169991953/
      DATA LSEQS(1,190),LSEQS(2,190 )/ 182557704,1046541065/
      DATA LSEQS(1,191),LSEQS(2,191 )/1688025575,1248944426/
      DATA LSEQS(1,192),LSEQS(2,192 )/1508287706,1220577001/
      DATA LSEQS(1,193),LSEQS(2,193 )/  36721212,1377275347/
      DATA LSEQS(1,194),LSEQS(2,194 )/1968679856,1675229747/
      DATA LSEQS(1,195),LSEQS(2,195 )/ 279109231,1835333261/
      DATA LSEQS(1,196),LSEQS(2,196 )/1358617667,1416978076/
      DATA LSEQS(1,197),LSEQS(2,197 )/ 740626186,2103913602/
      DATA LSEQS(1,198),LSEQS(2,198 )/1882655908, 251341858/
      DATA LSEQS(1,199),LSEQS(2,199 )/ 648016670,1459615287/
      DATA LSEQS(1,200),LSEQS(2,200 )/ 780255321, 154906988/
      DATA LSEQS(1,201),LSEQS(2,201 )/ 857296483, 203375965/
      DATA LSEQS(1,202),LSEQS(2,202 )/1631676846, 681204578/
      DATA LSEQS(1,203),LSEQS(2,203 )/1906971307,1623728832/
      DATA LSEQS(1,204),LSEQS(2,204 )/1541899600,1168449797/
      DATA LSEQS(1,205),LSEQS(2,205 )/1267051693,1020078717/
      DATA LSEQS(1,206),LSEQS(2,206 )/1998673940,1298394942/
      DATA LSEQS(1,207),LSEQS(2,207 )/1914117058,1381290704/
      DATA LSEQS(1,208),LSEQS(2,208 )/ 426068513,1381618498/
      DATA LSEQS(1,209),LSEQS(2,209 )/ 139365577,1598767734/
      DATA LSEQS(1,210),LSEQS(2,210 )/2129910384, 952266588/
      DATA LSEQS(1,211),LSEQS(2,211 )/ 661788054,  19661356/
      DATA LSEQS(1,212),LSEQS(2,212 )/1104640222, 240506063/
      DATA LSEQS(1,213),LSEQS(2,213 )/ 356133630,1676634527/
      DATA LSEQS(1,214),LSEQS(2,214 )/ 242242374,1863206182/
      DATA LSEQS(1,215),LSEQS(2,215 )/ 957935844,1490681416/
C
      CCHOPT = CHOPT
      IF(CCHOPT.EQ.' ') THEN
        IF(ISEQ.GT.215.OR.ISEQ.LT.1) THEN
            ISEED(1,1) = LSEQS(1,1)
            ISEED(2,1) = LSEQS(2,1)
            JSEQ(1)    = 1
        ELSE
            ISEED(1,1) = LSEQS(1,ISEQ)
            ISEED(2,1) = LSEQS(2,ISEQ)
            JSEQ(1)    = ISEQ
        END IF
        GO TO 999
      END IF
      IF(INDEX(CHOPT,'S').NE.0) THEN
        IF(ISEQ.GT.0) JSEQ(1) = ISEQ
        IF(IS1.GT.0.AND.IS2.GT.0) THEN
          ISEED(1,JSEQ(1)) = IS1
          ISEED(2,JSEQ(1)) = IS2
        END IF
        IF(INDEX(CHOPT,'H').NE.0) THEN
          IQ(JHEAD+3) = IS1
          IQ(JHEAD+4) = IS2
        END IF
      END IF
      IF(INDEX(CHOPT,'G').NE.0) THEN
        IF(ISEQ.LE.0)THEN
           KSEQ = JSEQ(1)
        ELSE
           KSEQ = ISEQ
        ENDIF
        IS1 = ISEED(1,KSEQ)
        IS2 = ISEED(2,KSEQ)
      END IF
      IF(INDEX(CHOPT,'Q').NE.0) THEN
        IF(ISEQ.GE.1.AND.ISEQ.LE.MAXSEQ) THEN
          IS1 = LSEQS(1,ISEQ)
          IS2 = LSEQS(2,ISEQ)
        ELSE
          IS1 = 0
          IS2 = 0
        END IF
      END IF
C
 999  CONTINUE
      END
+DECK, GSKING.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSKING (IGK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GSKING (IGK)                                          *
C.    *                                                                *
C.    *   Stores in stack JSTAK either the IGKth track of /GCKING/,    *
C.    *    or the NGKINE tracks when IGK is 0.                         *
C.    *                                                                *
C.    *   Called by : 'User'                                           *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCNUM.
+CDE, GCTRAK.
C.
      COMMON/VTXKIN/NVTX,ITR
      REAL PSTO(3), VSTO(3)
C.
C.    ------------------------------------------------------------------
*
      IF (NGKINE.LE.0) GO TO 999
      IF (IGK.EQ.0) THEN
         N1 = 1
         N2 = NGKINE
      ELSE
         IF (IGK.LT.0.OR.IGK.GT.NGKINE) THEN
            WRITE(CHMAIL,10000) IGK, NGKINE
10000 FORMAT(' GSKING - Abnormal request ',I4,1X,I4)
            CALL GMAIL(0,0)
            GO TO 999
         ENDIF
         N1 = IGK
         N2 = IGK
      ENDIF
*
* *** Save original information from /GCKINE/ and /GCTRAK/
*
      IPASTO = IPART
      TOFSTO = TOFG
      DO 10 I = 1,3
         VSTO(I) = VERT(I)
         PSTO(I) = PVERT(I)
   10 CONTINUE
*
* *** Store required tracks in stack JSTAK
*
      IVSTO = 0
      DO 30 N = N1,N2
         IF (IFLGK(N).LT.0) GO TO 30
         TOFG  = TOFSTO +TOFD(N)
         IPART = GKIN(5,N)
         DO 20 I = 1,3
            VERT(I)  = GPOS(I,N)
            PVERT(I) = GKIN(I,N)
   20    CONTINUE
         IF (IFLGK(N).EQ.1) THEN
            IF (IVSTO.EQ.0) THEN
               IVSTO = 1
               IFLAG = 1
            ELSE
               IFLAG = -NVERTX
            ENDIF
         ELSE
            IFLAG = -IFLGK(N)
         ENDIF
         CALL GSSTAK (IFLAG)
         IF (IFLAG.NE.0) THEN
            IFLGK(N) = ITR
            IFLGK(NGKINE+1) = NVTX
         ENDIF
   30 CONTINUE
*
* *** Restore original information in /GCKINE/ and /GCTRAK/
*
      IPART = IPASTO
      TOFG  = TOFSTO
      DO 40 I = 1,3
         VERT(I)  = VSTO(I)
         PVERT(I) = PSTO(I)
   40 CONTINUE
*                                                             END GSKING
  999 CONTINUE
      END
+DECK,GSKPHO.
*CMZ :  3.21/02 03/07/94  19.07.28  by  S.Giani
*-- Author :
      SUBROUTINE GSKPHO (IGK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *   Stores in stack JSTAK either the IGKth Cherenkov photon of   *
C.    *   /GCKIN2/, or the NPHOT tracks when IGK is 0.                 *
C.    *                                                                *
C.    *   Called by : 'User'                                           *
C.    *   Authors   : F.Carminati                                      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCKING.
+SEQ,GCNUM.
+SEQ,GCUNIT.
+SEQ,GCTRAK.
+SEQ,GCMZFO.
+SEQ,GCSTAK.
+SEQ,GCKINE.
*
      PARAMETER (NWPOLA=3)
C.
C.    ------------------------------------------------------------------
C.
*
* *** Make sure the request is reasonable
      IF (NGPHOT.LE.0) GO TO 999
      IF (IGK.EQ.0) THEN
         N1 = 1
         N2 = NGPHOT
      ELSE
         IF (IGK.LT.0.OR.IGK.GT.NGPHOT) THEN
            WRITE(CHMAIL,10000) IGK, NGPHOT
10000 FORMAT(' **** GSKPHO: ',I6,'th photon requested, ',
     + I6,' in stack')
            CALL GMAIL(0,0)
            GO TO 999
         ENDIF
         N1 = IGK
         N2 = IGK
      ENDIF
*
* *** Store photons in stack JSTAK
*
* *** Check that the bank is there and big enough
      IF (JSTAK.EQ.0) THEN
         NDBOOK = NTSTKP*NWSTAK +3
         NDPUSH = NTSTKS*NWSTAK
         CALL MZBOOK (IXCONS,JSTAK,JSTAK,1,'STAK', 1,1,NDBOOK, IOSTAK,3)
         IQ(JSTAK+2) = NTSTKP
      ENDIF
      IF(IQ(JSTAK-2).EQ.0) THEN
         CALL MZPUSH(IXCONS,JSTAK,1,0,'I')
      ENDIF
      IF(LQ(JSTAK-1).EQ.0) THEN
         CALL MZBOOK(IXCONS,JPOLAR,JSTAK,-1,'POLA',0,0,
     +               NTSTKP*NWPOLA,3,-1)
      ENDIF
      MISSNG=IQ(JSTAK+1)+N2-N1+1-IQ(JSTAK+2)
      IF (MISSNG.GT.0) THEN
         CALL MZPUSH (IXCONS, JSTAK, 0, MISSNG*NWSTAK+NDPUSH, 'I')
         IQ(JSTAK+2) = IQ(JSTAK+2) +NTSTKS+MISSNG
      ENDIF
      MSSPOL = IQ(JSTAK+1)+N2-N1+1-IQ(JPOLAR-1)/3
      IF(MSSPOL.GT.0) THEN
         CALL MZPUSH (IXCONS,JPOLAR,0,(NTSTKS+MSSPOL)*NWPOLA, 'I')
      ENDIF
*
* *** Now we can go
      DO 20  NN=N1,N2
         JST = JSTAK  +IQ(JSTAK+1)*NWSTAK +3
         JPO = JPOLAR +IQ(JSTAK+1)*NWPOLA
         IQ(JSTAK+1) = IQ(JSTAK+1) +1
         IF (IQ(JSTAK+3).EQ.0) IQ(JSTAK+3) = IQ(JSTAK+1)
         IF (IQ(JSTAK+1).GT.NSTMAX) NSTMAX = IQ(JSTAK+1)
*
         IQ(JST+1) = -ITRA
         IQ(JST+2) = 50
         IQ(JST+3) = 0
         DO 10 I = 1,3
            Q(JST+3+I) = XPHOT(I  ,NN)
            Q(JST+6+I) = XPHOT(I+3,NN)*XPHOT(7,NN)
            Q(JPO+  I) = XPHOT(I+7,NN)
   10    CONTINUE
         Q(JST+10) = XPHOT(11,NN)
         Q(JST+11) = SAFETY
         Q(JST+12) = UPWGHT
*
         NALIVE = NALIVE +1
   20 CONTINUE
*                                                             END GSKPHO
  999 CONTINUE
      END
+DECK,GSSTAK.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSSTAK (IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GSSTAK (IFLAG)                                        *
C.    *                                                                *
C.    *   Stores in auxiliary stack JSTAK the particle currently       *
C.    *    described in common /GCKINE/.                               *
C.    *                                                                *
C.    *   On request, creates also an entry in structure JKINE :       *
C.    *    IFLAG =                                                     *
C.    *     0 : No entry in JKINE structure required (user)            *
C.    *     1 : New entry in JVERTX / JKINE structures required (user) *
C.    *    <0 : New entry in JKINE structure at vertex -IFLAG (user)   *
C.    *     2 : Entry in JKINE structure exists already (from GTREVE)  *
C.    *                                                                *
C.    *   Called by : GSKING, GTREVE                                   *
C.    *   Author    : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCJLOC.
+CDE, GCMZFO.
+CDE, GCNUM.
+CDE, GCSTAK.
+CDE, GCTRAK.
+CDE, GCJUMP, IF=USRJMP
*
      COMMON/VTXKIN/NVTX,ITR
      DIMENSION UBUF(1)
      DATA UBUF/0./
C.
C.    ------------------------------------------------------------------
*
      IF (IPART.LE.0.OR.IPART.GT.NPART) THEN
         PRINT *, ' GSSTAK - Unknown particle code, skip track ', IPART
         GO TO 999
      ENDIF
*
* *** Give control to user for track selection
*
+SELF,IF=-USRJMP.
      CALL GUSKIP(ISKIP)
+SELF,IF= USRJMP.
      CALL JUMPT1(JUSKIP,ISKIP)
+SELF.
      IF (ISKIP.NE.0) GO TO 999
*
* *** Check if an entry in JKINE structure is required
*
      IF (IFLAG.EQ.1) THEN
         CALL GSVERT (VERT, ITRA, 0, UBUF, 0, NVTX)
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE IF (IFLAG.LT.0) THEN
         NVTX = -IFLAG
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE
         IF (IFLAG.EQ.0) THEN
*          Store -ITRA in stack for a track without entry in JKINE
            ITR = -ITRA
         ELSE
            ITR = ITRA
         ENDIF
      ENDIF
*
* *** Store information in stack
*
      IF (JSTAK.EQ.0) THEN
         NDBOOK = NTSTKP*NWSTAK +3
         NDPUSH = NTSTKS*NWSTAK
         CALL MZBOOK (IXCONS,JSTAK,JSTAK,1,'STAK', 0,0,NDBOOK, IOSTAK,3)
         IQ(JSTAK+2) = NTSTKP
      ELSE IF (IQ(JSTAK+1).EQ.IQ(JSTAK+2)) THEN
         CALL MZPUSH (IXCONS, JSTAK, 0, NDPUSH, 'I')
         IQ(JSTAK+2) = IQ(JSTAK+2) +NTSTKS
      ENDIF
*
      JST = JSTAK +IQ(JSTAK+1)*NWSTAK +3
      IQ(JSTAK+1) = IQ(JSTAK+1) +1
      IF (IQ(JSTAK+3).EQ.0) IQ(JSTAK+3) = IQ(JSTAK+1)
      IF (IQ(JSTAK+1).GT.NSTMAX)  NSTMAX = IQ(JSTAK+1)
*
      IQ(JST+1)   = ITR
      IQ(JST+2)   = IPART
      IQ(JST+3)   = 0
      DO 90 I = 1,3
         Q(JST+3+I) = VERT(I)
         Q(JST+6+I) = PVERT(I)
   90 CONTINUE
      Q(JST+10) = TOFG
      Q(JST+11) = SAFETY
      Q(JST+12) = UPWGHT
*
      NALIVE = NALIVE +1
*                                                             END GSSTAK
  999 CONTINUE
      END
+DECK,GSTORD.
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSTORD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Orders the particles in the stack in ascending order by      *
C.    *   the user word.                                               *
C.    *                                                                *
C.    *   Called by : GLTRAC                                           *
C.    *   Authors   : F.Carminati                                      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCSTAK.
+SEQ,GCTRAK
+SEQ,GCNUM
      PARAMETER (NWPOLA=3,ISTPOS=12)
*
* ----------------------------------------------------------------------
*
      JSTPOS = JSTAK+3+ISTPOS
      VALMAX = Q(JSTPOS)
      INDMAX = 1
      NPSTAK = IQ(JSTAK+1)
      DO 10 J=2,IQ(JSTAK+1)
         JSTPOS = JSTPOS+NWSTAK
         VALTST = Q(JSTPOS)
         IF(VALTST.GT.VALMAX) THEN
            VALMAX = VALTST
            INDMAX = J
         ENDIF
   10 CONTINUE
      IF(INDMAX.NE.NPSTAK) THEN
         JSMOVE = JSTAK+3+(INDMAX-1)*NWSTAK
         JSLAST = JSTAK+3+(NPSTAK-1)*NWSTAK
         DO 20 J=1,NWSTAK
            TEMP = Q(JSMOVE+J)
            Q(JSMOVE+J) = Q(JSLAST+J)
            Q(JSLAST+J) = TEMP
   20    CONTINUE
         IF(JPOLAR.NE.0) THEN
            JPMOVE = JPOLAR+(INDMAX-1)*NWPOLA
            JPLAST = JPOLAR+(NPSTAK-1)*NWPOLA
            DO 30 J=1,NWPOLA
               TEMP = Q(JPMOVE+J)
               Q(JPMOVE+J) = Q(JPLAST+J)
               Q(JPLAST+J) = TEMP
   30       CONTINUE
        ENDIF
      ENDIF
      END
+DECK, GSTRAC.
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GSTRAC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       SUBR. GSTRAC                                             *
C.    *                                                                *
C.    *  Stores in stack JTRACK the information for current track      *
C.    *   segment at exit of current Volume/Medium.                    *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCVOLU.
      REAL      XC(3)
C.
C.    ------------------------------------------------------------------
*
* *** Find where in the tracking skeleton to enter the current track
*
      IF (NLEVIN.EQ.NLEVEL) THEN
*       (case when GINVOL has not been called)
         JVO = LQ(JVOLUM-LVOLUM(NLEVIN))
         IF (INGOTO.GT.0) THEN
*
*  **      Point is in content predicted by GTNEXT, go one level down
*
            NLEVIN = NLEVIN +1
            INFROM = 0
            JIN    = LQ(JVO-INGOTO)
            IVOT   = Q(JIN+2)
            LVOLUM(NLEVIN) = IVOT
            LINDEX(NLEVIN) = INGOTO
            LINMX (NLEVIN) = Q(JVO+3)
*
*  **      Prepare the translation and rotation matrices if necessary
*
            JSKL = LQ(JSKLT-NLEVIN)
            IF (NLEVIN.GT.2) THEN
               IOFF = IQ(JSKL-3)
               DO 29 ILEV = 1, NLEVEL
                  IF (IQ(JSKL+IOFF+ILEV).NE.LINDEX(ILEV)) GO TO 30
   29          CONTINUE
            ENDIF
            JSK  = LQ(JSKL-INGOTO)
            IF (IQ(JSK+1).GT.0) GO TO 100
   30       IROTT = Q(JIN+4)
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            GO TO 100
         ELSE
*
*  **      otherwise, go one level up
*
            NLEVIN = NLEVIN -1
*
         ENDIF
*
      ELSE IF (NLEVIN.GT.NLEVEL) THEN
         INFROM = 0
         GO TO 100
*
      ELSE IF (NLEVIN.LT.0) THEN
*       (case when entering a dominant overlaping volume)
         NLEVIN = -NLEVIN
         INFROM = LINDEX(NLEVIN+1)
         GO TO 100
      ENDIF
*
*  **  Track has left current volume, check levels up
*
   80 IF (NLEVIN.EQ.0) GO TO 999
*
      IF (GRMAT(10,NLEVIN).EQ.0.) THEN
         DO 88 I = 1,3
            XC(I) = VECT(I) -GTRAN(I,NLEVIN)
   88    CONTINUE
      ELSE
C       (later, code in line)
         CALL GTRNSF (VECT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN), XC)
      ENDIF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVIN))
      JPAR = LQ(JGPAR-NLEVIN)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.NE.0) THEN
         INFROM = LINDEX(NLEVIN+1)
      ELSE
         NLEVIN = NLEVIN -1
         GO TO 80
      ENDIF
*
* *** Allocate last 'garbaged' area if any, otherwise first 'free' one
*
  100 IF (NJGARB.NE.0) THEN
         NCUR   = NJGARB
         LCUR   = JTRACK +(NCUR-1)*NWTRAC
         NJGARB = IQ(LCUR+1)
      ELSE
         NCUR   = NJFREE
         LCUR   = JTRACK +(NCUR-1)*NWTRAC
         NJFREE = NCUR +1
      ENDIF
*
* *** Link allocated area to relevant chain in JSKLT structure
*
      JSKL = LQ(JSKLT-NLEVIN)
      IQ(LCUR+1) = IQ(JSKL+LINDEX(NLEVIN))
      IQ(JSKL+LINDEX(NLEVIN)) = NCUR
*
* *** Store information for current track segment in stack JTRACK
*
      IQ(LCUR+2) = 0
      IQ(LCUR+3) = NTMULT
      IQ(LCUR+4) = ITRA
      IQ(LCUR+5) = ISTAK
      IQ(LCUR+6) = IPART
      IQ(LCUR+7) = NSTEP
*free IQ(LCUR+8) = IDECAD
      IQ(LCUR+9) = IEKBIN
      IQ(LCUR+10)= ISTORY
      IQ(LCUR+11)= INFROM
*
      IPCUR = LCUR +NWINT
      DO 109 I = 1,7
         Q(IPCUR+I)  = VECT(I)
  109 CONTINUE
      Q(IPCUR+8)  = GEKIN
      Q(IPCUR+9)  = SLENG
      Q(IPCUR+10) = GEKRAT
      Q(IPCUR+11) = TOFG
      Q(IPCUR+12) = UPWGHT
*
      IPCUR = IPCUR +NWREAL
      IF (ITRTYP.EQ.1) THEN
*     Photons
         Q(IPCUR+1) = ZINTPA
         Q(IPCUR+2) = ZINTCO
         Q(IPCUR+3) = ZINTPH
         Q(IPCUR+4) = ZINTPF
         Q(IPCUR+5) = ZINTRA
      ELSE IF (ITRTYP.EQ.2) THEN
*     Electrons
         Q(IPCUR+1) = ZINTBR
         Q(IPCUR+2) = ZINTDR
         Q(IPCUR+3) = ZINTAN
      ELSE IF (ITRTYP.EQ.3) THEN
*     Neutral hadrons
         Q(IPCUR+1) = SUMLIF
         Q(IPCUR+2) = ZINTHA
      ELSE IF (ITRTYP.EQ.4) THEN
*     Charged hadrons
         Q(IPCUR+1) = SUMLIF
         Q(IPCUR+2) = ZINTHA
         Q(IPCUR+3) = ZINTDR
      ELSE IF (ITRTYP.EQ.5) THEN
*     Muons
         Q(IPCUR+1) = SUMLIF
         Q(IPCUR+2) = ZINTBR
         Q(IPCUR+3) = ZINTPA
         Q(IPCUR+4) = ZINTDR
         Q(IPCUR+5) = ZINTMU
      ELSE IF (ITRTYP.EQ.7) THEN
*     Cerenkov photons
         Q(IPCUR+1) = ZINTLA
      ELSE IF (ITRTYP.EQ.7) THEN
*     Ions
         Q(IPCUR+1) = ZINTHA
         Q(IPCUR+1) = ZINTDR
      ENDIF
*
* *** Take care of the skeleton
*
      IF (NLEVIN.GT.NLDOWN) THEN
         NLDOWN = NLEVIN
         JSKL   = LQ(JSKLT-NLDOWN)
*
*  **    Clear skeleton at lowest level if necessary
*
         JOFF   = JSKL + IQ(JSKL-3)
         DO 229 ILEV = 1, NLDOWN-1
            IF (IQ(JOFF+ILEV).EQ.LINDEX(ILEV)) GO TO 229
            NINSK = LINMX(NLDOWN)
            DO 209 IN = 1, NINSK
               JSK  = LQ(JSKL-IN)
               IQ(JSK+1) = 0
  209       CONTINUE
            DO 219 I = ILEV, NLDOWN-1
               IQ(JOFF+I) = LINDEX(I)
  219       CONTINUE
            GO TO 230
  229    CONTINUE
      ENDIF
*
*  ** Fill up the skeleton at NLDOWN
*
  230 IF (NLEVIN.GT.NLEVEL) THEN
         JSKL = LQ(JSKLT-NLDOWN)
         JSK  = LQ(JSKL-LINDEX(NLDOWN))
         IF (IQ(JSK+1).LE.0) THEN
            LQ(JSK-1) = LQ(JGPAR-NLDOWN)
            IQ(JSK+1) = IQ(JGPAR+NLDOWN)
            IQ(JSK+2) = LVOLUM(NLDOWN)
            DO 239 I = 1, 3
               Q(JSK+2+I) = GTRAN(I,NLDOWN)
  239       CONTINUE
            DO 249 I = 1, 10
               Q(JSK+5+I) = GRMAT(I,NLDOWN)
  249       CONTINUE
         ENDIF
*
      ENDIF
*
* *** Update NALIVE and test if tracking stack is full
*
      NALIVE = NALIVE + 1
      IF (NALIVE-IQ(JSTAK+1).GE.NJTMAX) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         NJTMAX = -NJTMAX
         NLVSAV = NLEVEL
         DO 309 I = 2,NLDOWN
            LINSAV(I) = LINDEX(I)
            LMXSAV(I) = LINMX(I)
  309    CONTINUE
      ENDIF
*
 1001 FORMAT (' GSTRAC : Stack JTRACK full. Inhibit parallel tracking')
*                                                             END GSTRAC
  999 CONTINUE
      END
 
+DECK,GSXYZ
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GSXYZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store space point VECT in banks JXYZ                     *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    R.Brun, F.Carena  *********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCTRAK
+SEQ,GCPUSH
+SEQ,GCKINE
C.
C.    ------------------------------------------------------------------
C.
      IF(JXYZ.EQ.0)THEN
C
C               Create mother bank JXYZ
C
         CALL MZBOOK(IXDIV,JXYZ,JXYZ,1,'JXYZ',NCKINE,NCKINE,0,3,0)
         IQ(JXYZ-5)=0
      ENDIF
C
      NXYZ=IQ(JXYZ-2)
      IF(ITRA.GT.NXYZ)THEN
         NPUSH=MAX(10,ITRA-NXYZ)
         CALL MZPUSH(IXDIV,JXYZ,NPUSH,0,'I')
      ENDIF
C
C              Create bank to store points for primary track ITRA
C
      JX=LQ(JXYZ-ITRA)
      IF(JX.EQ.0)THEN
         CALL MZBOOK(IXDIV,JX,JXYZ,-ITRA,'JXYZ',0,0,NCJXYZ,3,0)
         Q(JX+1)=NCJXYZ-2.
         Q(JX+2)=3.
         IQ(JX)=NTMULT
C
C              Check if there is enough space to store current point
C
      ELSE
         NFREE=Q(JX+1)
         IF(NFREE.LE.6)THEN
            CALL MZPUSH(IXDIV,JX,0,NPJXYZ,'I')
            JX=LQ(JXYZ-ITRA)
            Q(JX+1)=Q(JX+1)+NPJXYZ
         ENDIF
C
         IF(NTMULT.NE.IQ(JX))THEN
            IQ(JX)=NTMULT
            IPOINT=JX+Q(JX+2)
            IF(Q(IPOINT).NE.0.) THEN
               Q(JX+2)=Q(JX+2)+3.*Q(IPOINT)+2.
               Q(JX+1)=Q(JX+1)-2.
            ENDIF
         ENDIF
      ENDIF
C
      IPOINT=JX+Q(JX+2)
      JP=IPOINT+3.*Q(IPOINT)+1.
      Q(IPOINT)=Q(IPOINT)+1.
      Q(IPOINT+1)=IPART
      DO 10 I=1,3
  10  Q(JP+I)=VECT(I)
      Q(JX+1)=Q(JX+1)-3.
C
      END
+DECK, GTCKOV
*CMZ :  3.21/02 03/07/94  18.18.51  by  S.Giani
*-- Author :
      SUBROUTINE GTCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine is called to follow the Cherenkov photons       *
C.    *   created during the tracking of charged particles and         *
C.    *   simulate the relevant processes along the way, until either  *
C.    *   the photon is absorbed or exits the detector. Processes      *
C.    *   currently simulated are absorption in-flight, and reflection *
C.    *   /transmission/absorption at a medium boundary. There are two *
C.    *   boundary types: dielectric-metal and dielectric-dielectric.  *
C.    *   For each of these there is a continuum of reflectivity       *
C.    *   and of surface quality from mirror finish to matte. The      *
C.    *   surface model is contained in routine GHSURF.                *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors    F.Carminati, R.Jones ************              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU
+CDE, GCNUM
+CDE, GCVOL1
+CDE, GCUNIT
 
+SELF, IF=-OLD
+SEQ, GCVDMA.
+SELF
*
* ** The following common is in GTMEDI. LSAMVL is set to true if
* ** we did not change volume yet
*
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      DIMENSION R(3),D(3),U(3),QQ(3),vin(3)
      LOGICAL LOLDTR
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
      PARAMETER (MXPUSH=10)
      SAVE RIN1,EFFIC
C.
C.    ------------------------------------------------------------------
*
* *** Update local pointers if medium has changed
*
      LOLDTR=.FALSE.
      IF(IUPD.EQ.0)THEN
         IUPD  = 1
         JTCKOV = LQ(JTM-3)
         IF(JTCKOV.EQ.0) THEN
*
* *** This Cerenkov photon has crossed into a black medium.
* *** Just absorb it.
            IPROC = 101
            STEP  = 0.
            SLABS = 0.
            ISTOP = 2
            DESTEP = 0.
            GOTO 110
         ENDIF
         NPCKOV = Q(JTCKOV+1)
         JABSCO = LQ(JTCKOV-1)
         JEFFIC = LQ(JTCKOV-2)
         JINDEX = LQ(JTCKOV-3)
         JPOLAR = LQ(JSTAK-1)
         RIN1 = 0.
      ENDIF
      IF(SLENG.LE.0.) THEN
*
* *** Calculate GEKRAT for the particle
         IF(VECT(7).GE.Q(JTCKOV+NPCKOV+1)) THEN
            GEKRAT=1.
            IEKBIN=NPCKOV-1
         ELSEIF(VECT(7).LT.Q(JTCKOV+2)) THEN
*
* *** Particle below energy threshold ?  Short circuit
* *** This should never happen because the photons are generated
* *** only above threshold
*
*            GEKIN = 0.
*            GETOT = 0.
*            VECT(7)= 0.
*            ISTOP = 2
*            NMEC = 1
*            LMEC(1)= 30
*            GO TO 110
 
            GEKRAT=0.
            IEKBIN=1
         ELSE
            JMIN = 1
            JMAX = NPCKOV
   10       JMED = (JMIN+JMAX)/2
            IF(Q(JTCKOV+JMED+1).LT.VECT(7)) THEN
               JMIN = JMED
            ELSE
               JMAX = JMED
            ENDIF
            IF(JMAX-JMIN.GT.1) GO TO 10
            IEKBIN = JMIN
            GEKRAT = (VECT(7) - Q(JTCKOV+IEKBIN+1))/
     +      (Q(JTCKOV+IEKBIN+2)-Q(JTCKOV+IEKBIN+1))
         ENDIF
         GEKRT1=1.-GEKRAT
         RIN1=Q(JINDEX+IEKBIN)*GEKRT1+Q(JINDEX+IEKBIN+1)*GEKRAT
         EFFIC=Q(JEFFIC+IEKBIN)*GEKRT1+Q(JEFFIC+IEKBIN+1)*GEKRAT
         STEPLA=Q(JABSCO+IEKBIN)*GEKRT1+Q(JABSCO+IEKBIN+1)*GEKRAT
      ENDIF
*
* *** Compute current step size
*
      IPROC  = 103
      STEP   = STEMAX
*
*  **   Step limitation due to in flight absorbtion ?
*
      IF (ILABS.GT.0) THEN
         SLABS  = STEPLA*ZINTLA
         IF (SLABS.LT.STEP) THEN
            STEP  = SLABS
            IPROC = 101
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      STEPT=0.
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
*
* **    We are going to cross a boundary, so we need to simulate
* **    boundary effects and to know what is on the other side.
* **    For the moment save the current vector in the geometry tree.
*
+SELF, IF=-OLD
         if(mycoun.gt.1.and.nfmany.gt.0)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF
            NLEVL1 = NLEVEL
            DO 20   I=1,NLEVEL
               NAMES1(I) = NAMES(I)
               NUMBR1(I) = NUMBER(I)
               LVOLU1(I) = LVOLUM(I)
   20       CONTINUE
*
* *** This is different from the other tracking routines.
* *** We get to the boundary and then we just jump over it
* *** So, linear transport till we are very near the boundary
*
+SELF,IF=-IBM
            STEP = MAX(SNEXT-PREC,0.)
+SELF,IF=IBM
            STEP = MAX(SNEXT-2.*PREC,0.)
+SELF
            IF(STEP.GT.0.) THEN
               DO 30 I=1,3
                  VECT(I)=VECT(I)+STEP*VECT(I+3)
   30          CONTINUE
            ENDIF
            STEPT=STEP
+SELF,IF=-IBM
            STEP  = SNEXT - STEP + PREC
+SELF,IF=IBM
            STEP  = SNEXT - STEP + 2.*PREC
+SELF
            IPROC = 0
            INWVOL= 2
            NMEC =  1
            LMEC(1)=1
         ENDIF
*
*        Update SAFETY in stack companions, if any
*        This may well not work.
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 40 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   40       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      VIN(1) = VECT(1)
      VIN(2) = VECT(2)
      VIN(3) = VECT(3)
      IF (INWVOL.EQ.2) THEN
         NBPUSH = 0
   50    DO 60 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTCKOV: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
               ENDIF
            ENDIF
            VOUT(I) = VECTMP
   60    CONTINUE
         NUMED1=NUMED
         CALL GTMEDI(VOUT,NUMED2)
         LOLDTR=.TRUE.
         IF(NUMED2.LE.0) THEN
            VECT(1) = VOUT(1)
            VECT(2) = VOUT(2)
            VECT(3) = VOUT(3)
            GO TO 110
         ENDIF
         JVO=LQ(JVOLUM-LVOLUM(NLEVEL))
         IF(LSAMVL.AND.Q(JVO+2).NE.12.) THEN
*
* *** In spite of our efforts we have not crossed the boundary
* *** we increase the step size and try again
*
            NBPUSH = NBPUSH + 1
            IF (NBPUSH.LE.MXPUSH) THEN
              STEP = STEP + NBPUSH*PREC
              GOTO 50
            ELSE
              INWVOL = 0
            ENDIF
 
         ENDIF
         IF(NUMED1.EQ.NUMED2) THEN
*
* *** If we are in the same medium, nothing needs to be done!
*
            VECT(1)=VOUT(1)
            VECT(2)=VOUT(2)
            VECT(3)=VOUT(3)
            IPROC=0
         ELSE
            JTM2 = LQ(JTMED-NUMED2)
            IF(IQ(JTM2-2).GE.3) THEN
               JTCKV2 = LQ(JTM2-3)
            ELSE
               JTCKV2 = 0
            ENDIF
            IF(JTCKV2.GT.0) THEN
               NPCKV2 = Q(JTCKV2+1)
               JABSC2 = LQ(JTCKV2-1)
               JEFFI2 = LQ(JTCKV2-2)
               JINDX2 = LQ(JTCKV2-3)
               IF(VECT(7).GE.Q(JTCKV2+NPCKV2+1)) THEN
                  GEKRT2=1.
                  IEKBI2=NPCKV2-1
               ELSEIF(VECT(7).LT.Q(JTCKV2+2)) THEN
                  GEKRT2=0.
                  IEKBI2=1
               ELSE
                  JMIN = 1
                  JMAX = NPCKV2
   64             JMED = (JMIN+JMAX)/2
                  IF(Q(JTCKV2+JMED+1).LT.VECT(7)) THEN
                     JMIN = JMED
                  ELSE
                     JMAX = JMED
                  ENDIF
                  IF(JMAX-JMIN.GT.1) GO TO 64
                  IEKBI2 = JMIN
                  GEKRT2 = (VECT(7) - Q(JTCKV2+IEKBI2+1))/
     +            (Q(JTCKV2+IEKBI2+2)-Q(JTCKV2+IEKBI2+1))
               ENDIF
               GEKRT1=1.-GEKRT2
               ABSCO2=Q(JABSC2+IEKBI2)*GEKRT1+Q(JABSC2+IEKBI2+1)*GEKRT2
               EFFIC2=Q(JEFFI2+IEKBI2)*GEKRT1+Q(JEFFI2+IEKBI2+1)*GEKRT2
               IF(JINDX2.GT.0) THEN
                 RIN2=Q(JINDX2+IEKBI2)*GEKRT1+Q(JINDX2+IEKBI2+1)*GEKRT2
               ELSE
                 RIN2=0.
               ENDIF
               IPROC = 102
            ELSE
               ISTOP=2
               DESTEP=0
               NMEC = NMEC+1
               LMEC(NMEC)=30
               VECT(1)=VOUT(1)
               VECT(2)=VOUT(2)
               VECT(3)=VOUT(3)
               GOTO 110
            ENDIF
         ENDIF
      ELSE
         DO 70 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   70    CONTINUE
      ENDIF
*
      STEP = STEPT + STEP
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      TOFG = TOFG +STEP*RIN1/CLIGHT
*
* *** Update interaction probabilities
*
      IF (ILABS.GT.0)    ZINTLA = ZINTLA -STEP/STEPLA
*
      IF (IPROC.EQ.0) GO TO 110
      NMEC = NMEC+1
      LMEC(NMEC) = IPROC
*
*  ** Absorbtion in flight ?
*
      IF (IPROC.EQ.101) THEN
         ISTOP=2
         CALL GRNDM(RNDM,1)
         IF(RNDM.LT.EFFIC) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
            DESTEP=VECT(7)
         ELSE
            DESTEP=0.
         ENDIF
*
*  ** Boundary action?
*
      ELSE IF (IPROC.EQ.102) THEN
         IF(JINDX2.EQ.0) THEN
*
* *** Case dielectric -> metal
*
            CALL GRNDM(RNDM,1)
            IF(RNDM.LT.ABSCO2) THEN
*
* *** Photon is absorbed in the next medium
*
               NMEC=NMEC+1
               LMEC(NMEC)=101
               ISTOP = 2
               CALL GRNDM(RNDM,1)
               IF(RNDM.LT.EFFIC2) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
                  DESTEP=VECT(7)
               ELSE
                  DESTEP = 0.
               END IF
               VECT(1) = VOUT(1)
               VECT(2) = VOUT(2)
               VECT(3) = VOUT(3)
               GOTO 110
            ELSE
*
* *** Photon is reflected (no polarization effects)
*
               CALL GLISUR(VECT,VOUT,NUMED1,NUMED2,U,PDOTU,IERR)
               IF (IERR.NE.0) THEN
                  WRITE(CHMAIL,10200) IERR
                  CALL GMAIL(0,0)
                  GO TO 110
               END IF
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   80          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 80
                  ENDIF
               ENDIF
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
               EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL  = 0
            ENDIF
         ELSE
*
*  case dielectric-dielectric:
*
            CALL GLISUR(VECT,VOUT,NUMED1,NUMED2,U,PDOTU,IERR)
            IF (IERR.NE.0) THEN
               WRITE(CHMAIL,10200) IERR
               CALL GMAIL(0,0)
               GO TO 110
            END IF
            EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
            COST1 = -PDOTU
            IF (ABS(COST1).LT.1.) THEN
               SINT1 = SQRT((1-COST1)*(1+COST1))
               SINT2 = SINT1*RIN1/RIN2
            ELSE
               SINT1 = 0.0
               SINT2 = 0.0
            END IF
            IF (SINT2.GE.1) THEN
*
* ***  Simulate total internal reflection
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   90          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 90
                  ENDIF
               ENDIF
*
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL = 0
            ELSE
*
* ***  Calculate amplitude for transmission (Q = P x U)
*
               COST2 = SIGN(1.0,COST1)*SQRT((1-SINT2)*(1+SINT2))
               IF (SINT1.GT.1.E-4) THEN
                  QQ(1) = VECT(5)*U(3) - VECT(6)*U(2)
                  QQ(2) = VECT(6)*U(1) - VECT(4)*U(3)
                  QQ(3) = VECT(4)*U(2) - VECT(5)*U(1)
                  EPERP1 = (POLAR(1)*QQ(1) + POLAR(2)*QQ(2) + POLAR(3)*
     +            QQ(3))
                  ENORM  = SQRT(EPERP1**2+EDOTU**2)
                  EPERP1 = EPERP1/ENORM
                  EPARL1 = EDOTU/ENORM
               ELSE
                  QQ(1) = POLAR(1)
                  QQ(2) = POLAR(2)
                  QQ(3) = POLAR(3)
*
*     Here we follow Jackson's conventions and we set the parallel
*     component = 1 in case of a ray perpendicular to the surface
                  EPERP1 = 0.
                  EPARL1 = 1.
               END IF
               IF(COST1.NE.0.) THEN
                  S1 = RIN1*COST1
                  EPERP2 = 2*S1*EPERP1/(RIN1*COST1+RIN2*COST2)
                  EPARL2 = 2*S1*EPARL1/(RIN2*COST1+RIN1*COST2)
                  E2 = EPERP2**2 + EPARL2**2
                  S2 = RIN2*COST2*E2
                  TCOEF = S2/S1
               ELSE
                  TCOEF = 0.
               ENDIF
               CALL GRNDM(RNDM,1)
               IF (RNDM.GT.TCOEF) THEN
*
* *** Simulate reflection
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=106
*
* *** Restore old volume tree, the photon does not cross the boundary
*
*                 CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
                  CALL GTMEDI(VIN,N)
                  LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
                  NBPUSH = 0
  100             NBPUSH = NBPUSH+1
                  IF(NBPUSH.GT.MXPUSH) THEN
                     WRITE(CHMAIL,10300) NTMULT,NSTEP
                     CALL GMAIL(0,0)
                     ISTOP=1
                     GOTO 110
                  ELSE
                     CALL GINVOL(VECT,ISAME)
                     IF(ISAME.EQ.0) THEN
                        PRECN = NBPUSH*PREC
                        VECT(1) = VECT(1) - PRECN*VECT(4)
                        VECT(2) = VECT(2) - PRECN*VECT(5)
                        VECT(3) = VECT(3) - PRECN*VECT(6)
                        GO TO 100
                     ENDIF
                  ENDIF
*
                  VECT(4) = VECT(4) - 2*PDOTU*U(1)
                  VECT(5) = VECT(5) - 2*PDOTU*U(2)
                  VECT(6) = VECT(6) - 2*PDOTU*U(3)
                  IF(SINT1.GT.1E-4) THEN
                     EPARL2 = RIN2*EPARL2/RIN1-EPARL1
                     EPERP2 = EPERP2-EPERP1
                     E2 = EPERP2**2 + EPARL2**2
                     R(1) = U(1) + PDOTU*VECT(4)
                     R(2) = U(2) + PDOTU*VECT(5)
                     R(3) = U(3) + PDOTU*VECT(6)
                     EABS = SQRT(E2)*SINT1
                     CPARL = EPARL2/EABS
                     CPERP = EPERP2/EABS
                     POLAR(1) = CPARL*R(1) - CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) - CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) - CPERP*QQ(3)
                  ELSEIF(RIN2.GT.RIN1) THEN
*
* *** Case of ray perpendicular to the surface. No change or
* *** an inversion of phase.
                     POLAR(1) = -POLAR(1)
                     POLAR(2) = -POLAR(2)
                     POLAR(3) = -POLAR(3)
                  ENDIF
                  INWVOL = 0
               ELSE
*
* *** Simulate transmission/refraction
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=107
                  VECT(1) = VOUT(1)
                  VECT(2) = VOUT(2)
                  VECT(3) = VOUT(3)
                  GEKRAT = GEKRT2
                  IEKBIN = IEKBI2
                  STEPLA = ABSCO2
                  EFFIC = EFFIC2
                  RIN1 = RIN2
                  IF(SINT1.GT.1E-4) THEN
                     ALPHA = COST1-COST2*(RIN2/RIN1)
                     D(1) = VECT(4) + ALPHA*U(1)
                     D(2) = VECT(5) + ALPHA*U(2)
                     D(3) = VECT(6) + ALPHA*U(3)
                     DABS = SQRT(D(1)**2+D(2)**2+D(3)**2)
                     VECT(4) = D(1)/DABS
                     VECT(5) = D(2)/DABS
                     VECT(6) = D(3)/DABS
                     PDOTU = -COST2
                     R(1) = U(1) - PDOTU*VECT(4)
                     R(2) = U(2) - PDOTU*VECT(5)
                     R(3) = U(3) - PDOTU*VECT(6)
                     EABS = SQRT(E2)
                     CPARL = EPARL2/(EABS*SINT2)
                     CPERP = EPERP2/(EABS*SINT1)
                     POLAR(1) = CPARL*R(1) + CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) + CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) + CPERP*QQ(3)
                  ENDIF
               END IF
            END IF
         END IF
      ENDIF
*                                                             END GTCKOV
  110 IF(LOLDTR) CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
10200  FORMAT(' **** GTCKOV: error from GLISUR = ',I10)
10300  FORMAT(' **** GTCKOV: unable to reflect at NTMULT = ',
     +        I8,' step No. ',I8,' photon abandoned!')
      END
+DECK, GTELEC.
*CMZ :  3.21/03 11/10/94  18.39.19  by  S.Giani
*-- Author :
      SUBROUTINE GTELEC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Electron type track. Computes step size and propagates       *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   ==> Called by : GTRACK                                       *
C.    *       Authors    R.Brun, F.Bruyant, M.Maire L.Urban ********   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCMATE.
+CDE, GCMULO.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCKING.
+SEQ, GCJUMP, IF=USRJMP
 
+SELF, IF=-OLD
+CDE, GCVOLU.
+SEQ, GCVDMA.
+SELF
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION DEMEAN,STOPRG,STOPMX,STOPC
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,ZERO
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
      PARAMETER (ONE=1,ZERO=0)
      REAL VNEXT(6)
      SAVE IKCUT,STOPC
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTELE) GO TO 100
*
* *** Update local pointers if medium or particle code has changed
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JMULOF= LQ(JTM-1)
         IF (CHARGE.LT.0.) THEN
            JBREM = LQ(JMA-9)
            JLOSS = LQ(JMA-1)
            JDRAY = LQ(JMA-11)
            JRANG = LQ(JMA-15)
            JCOEF = LQ(JMA-17)
         ELSE
            JBREM = LQ(JMA-9)  +NEK1
            JLOSS = LQ(JMA-1)  +NEK1
            JDRAY = LQ(JMA-11) +NEK1
            JRANG = LQ(JMA-15) +NEK1
            JCOEF = LQ(JMA-17) +3*NEK1
            JANNI = LQ(JMA-7)
         ENDIF
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
         OMCMOL = Q(JPROB+21)
         CHCMOL = Q(JPROB+25)
         IKCUT  = Q(JMULOF+NEK1+1)
         STOPC  = Q(JMULOF+NEK1+2)
         IF(ISTRA.GT.0) THEN
            JTSTRA = LQ(JMA-19)
            JTSTCO = LQ(JTSTRA-1)
            JTSTEN = LQ(JTSTRA-2)
+SELF,IF=ASHO
            IF(ISTRA.EQ.2) THEN
               JTASHO = LQ(JMA-20)
            ENDIF
+SELF
         ENDIF
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
*
*  **   Step limitation due to bremsstrahlung ?
*
      IF (IBREM.GT.0) THEN
         STEPBR = GEKRT1*Q(JBREM+IEKBIN) +GEKRAT*Q(JBREM+IEKBIN+1)
         SBREM  = STEPBR*ZINTBR
         IF (SBREM.LT.STEP) THEN
            STEP  = SBREM
            IPROC = 9
         ENDIF
      ENDIF
*
*  **   Step limitation due to delta-ray production ?
*
      IF (IDRAY.GT.0) THEN
         STEPDR = GEKRT1*Q(JDRAY+IEKBIN) +GEKRAT*Q(JDRAY+IEKBIN+1)
         SDRAY  = STEPDR*ZINTDR
         IF (SDRAY.LT.STEP) THEN
            STEP  = SDRAY
            IPROC = 10
         ENDIF
      ENDIF
*
*  **   Step limitation due to annihilation ?
*
      IF (CHARGE.GT.0.) THEN
         IF (IANNI.GT.0) THEN
            STEPAN = GEKRT1*Q(JANNI+IEKBIN) +GEKRAT*Q(JANNI+IEKBIN+1)
            SANNI  = STEPAN*ZINTAN
            IF (SANNI.LT.STEP) THEN
               STEP  = SANNI
               IPROC = 11
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP = 0.
         GO TO 90
      ENDIF
*
*  **   Step limitation due to energy-loss,multiple scattering
*             or magnetic field ?
*
      IF (JMULOF.NE.0) THEN
         SMULOF  = GEKRT1*Q(JMULOF+IEKBIN) +GEKRAT*Q(JMULOF+IEKBIN+1)
         IF (SMULOF.LT.STEP) THEN
            STEP  = SMULOF
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
* *** Linear transport when no field or very short step
*
         IF (IGNEXT.NE.0) THEN
*
* *** Particle is supposed to cross the boundary during step
*
            DO 20 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTELEC: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   20       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 30 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30       CONTINUE
         ENDIF
      ELSE
*
* *** otherwise, swim particle in magnetic field
*
+SELF, IF=-OLD
         if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP
   40    CALL GUSWIM (CHARGE, STEP, VECT, VOUT)
+SELF, IF=USRJMP
   40    CALL JUMPT4(JUSWIM,CHARGE, STEP, VECT, VOUT)
+SELF
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 50 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   50          CONTINUE
               DO 60 I = 1,3
                  IF (ABS(VOUT(I)-VNEXT(I)).GT.EPSIL) GO TO 70
   60          CONTINUE
               INEAR = 1
            ENDIF
*
   70       CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0) THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 40
               ENDIF
            ENDIF
         ENDIF
*
*
         DO 80 I = 1,6
            VECT(I) = VOUT(I)
   80    CONTINUE
*
      ENDIF
*
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
*  **  Apply synchrotron radiation if required
*
      IF(ISYNC*IFIELD.NE.0) THEN
         CALL GSYNC
         NMEC = NMEC+1
         LMEC(NMEC) = 108
      ENDIF
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         IF(NGPHOT.NE.0) THEN
            NMEC = NMEC+1
            LMEC(NMEC)=105
         ENDIF
      ENDIF
*
* *** Apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         IF(GEKRAT.LT.0.7) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0.) THEN
            STOPMX = -XCOEF2+SIGN(ONE,XCOEF1)*SQRT(XCOEF2**2 - (XCOEF3-
     +      GEKIN/XCOEF1))
         ELSE
            STOPMX = - (XCOEF3-GEKIN)/XCOEF2
         ENDIF
*
*        STOP electron/positron if range < safety AND no brems
*
         IF(STOPMX.LE.SAFETY) THEN
           IF(SBREM.GT.STOPMX) THEN
*          + condition in case of Cherenkov generation:
*          STOP if E/p >refractive index (i.e. e+/e- is below threshold)
             IF(IMCKOV.EQ.1) THEN
               THRIND=GETOT/VECT(7)
               IF(THRIND.GT.Q(JINDEX+1)) GOTO 100
             ELSE
               GOTO 100
             ENDIF
           ENDIF
         ENDIF
         STOPRG = STOPMX - STEP
         IF (STOPRG.LT.STOPC) THEN
            STEP = MAX(STOPMX - STOPC,ZERO)
            GO TO 100
         ENDIF
*
         LMEC(NMEC) = 3
         IF(XCOEF1.NE.0.) THEN
            DEMEAN=GEKIN-XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            DEMEAN=GEKIN-XCOEF2*STOPRG-XCOEF3
         ENDIF
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +     *STEP
         ENDIF
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
            DEMS = DEMEAN
            CALL GFLUCT (DEMS,DESTEP)
         ENDIF
         DESTEP=MAX(DESTEP,0.)
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTELE)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
      ENDIF
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 2
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      TOFG = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IBREM.GT.0)    ZINTBR = ZINTBR -STEP/STEPBR
      IF (IDRAY.GT.0)    ZINTDR = ZINTDR -STEP/STEPDR
      IF (CHARGE.GT.0.) THEN
         IF (IANNI.GT.0) ZINTAN = ZINTAN -STEP/STEPAN
      ENDIF
*
* *** Apply the selected process if any
*
   90 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Bremsstrahlung ?
*
      IF (IPROC.EQ.9) THEN
         CALL GBREME
*
*  **   Delta ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
*
       IF((IPART.EQ.2).OR.((IPART.EQ.3).AND.(GEKIN.GT.2.*DCUTE))) THEN
         CALL GDRAY
       ELSE
         GOTO 100
       ENDIF
*
*  **   Positron annihilation ?
*
      ELSE IF (IPROC.EQ.11) THEN
         CALL GANNI
 
      ENDIF
      GO TO 999
*
* *** Special treatment for overstopped tracks
*
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      NMEC   = NMEC +1
      LMEC(NMEC) = 30
      IF ((CHARGE.LT.0.).OR.(IANNI.EQ.0)) THEN
         ISTOP = 2
      ELSE
         NMEC = NMEC +1
         LMEC(NMEC) = 11
         CALL GANNIR
      ENDIF
  999 IF(NGPHOT.GT.0) THEN
         IF(ITCKOV.EQ.2.AND.ISTOP.EQ.0) THEN
*
*  The electron has produced Cerenkov photons and it is still alive
*  we put it in the stack and we let the photons to be tracked
            NGKINE = NGKINE+1
            GKIN(1,NGKINE) = VECT(4)*VECT(7)
            GKIN(2,NGKINE) = VECT(5)*VECT(7)
            GKIN(3,NGKINE) = VECT(6)*VECT(7)
            GKIN(4,NGKINE) = GETOT
            GKIN(5,NGKINE) = IPART
            TOFD(NGKINE) = 0.
            ISTOP = 1
c----put position as well
            GPOS(1,NGKINE)=VECT(1)
            GPOS(2,NGKINE)=VECT(2)
            GPOS(3,NGKINE)=VECT(3)
         ENDIF
      ENDIF
      END
+DECK, GTGAMA
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTGAMA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Photon track. Computes step size and propagates particle     *
C.    *    through step.                                               *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors    R.Brun, F.Bruyant L.Urban ********             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+SEQ,GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCMULO.
+CDE, GCTRAK.
+CDE, GCUNIT, IF=DEBUG.
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,ZERO
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
      PARAMETER (ONE=1,ZERO=0)
      PARAMETER (EPCUT=1.022E-3)
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ?  Short circuit
*
*
      IF (GEKIN.LE.CUTGAM) GOTO 998
*
* *** Update local pointers if medium has changed
*
      IF(IUPD.EQ.0)THEN
         IUPD  = 1
         JPHOT = LQ(JMA-6)
         JCOMP = LQ(JMA-8)
         JPAIR = LQ(JMA-10)
         JPFIS = LQ(JMA-12)
         JRAYL = LQ(JMA-13)
      ENDIF
*
* *** Compute current step size
*
      IPROC  = 103
      STEP   = STEMAX
      GEKRT1 = 1 .-GEKRAT
*
*  **   Step limitation due to pair production ?
*
      IF (GETOT.GT.EPCUT) THEN
         IF (IPAIR.GT.0) THEN
            STEPPA = GEKRT1*Q(JPAIR+IEKBIN) +GEKRAT*Q(JPAIR+IEKBIN+1)
            SPAIR  = STEPPA*ZINTPA
            IF (SPAIR.LT.STEP) THEN
               STEP  = SPAIR
               IPROC = 6
            ENDIF
         ENDIF
      ENDIF
*
*  **   Step limitation due to Compton scattering ?
*
      IF (ICOMP.GT.0) THEN
         STEPCO = GEKRT1*Q(JCOMP+IEKBIN) +GEKRAT*Q(JCOMP+IEKBIN+1)
         SCOMP  = STEPCO*ZINTCO
         IF (SCOMP.LT.STEP) THEN
            STEP  = SCOMP
            IPROC = 7
         ENDIF
      ENDIF
*
*  **   Step limitation due to photo-electric effect ?
*
      IF (GEKIN.LT.0.4) THEN
         IF (IPHOT.GT.0) THEN
            STEPPH = GEKRT1*Q(JPHOT+IEKBIN) +GEKRAT*Q(JPHOT+IEKBIN+1)
            SPHOT  = STEPPH*ZINTPH
            IF (SPHOT.LT.STEP) THEN
               STEP  = SPHOT
               IPROC = 8
            ENDIF
         ENDIF
      ENDIF
*
*  **   Step limitation due to photo-fission ?
*
      IF (JPFIS.GT.0) THEN
         STEPPF = GEKRT1*Q(JPFIS+IEKBIN) +GEKRAT*Q(JPFIS+IEKBIN+1)
         SPFIS  = STEPPF*ZINTPF
         IF (SPFIS.LT.STEP) THEN
            STEP  = SPFIS
            IPROC = 23
         ENDIF
      ENDIF
*
*  **   Step limitation due to Rayleigh scattering ?
*
      IF (IRAYL.GT.0) THEN
         IF (GEKIN.LT.0.01) THEN
            STEPRA = GEKRT1*Q(JRAYL+IEKBIN) +GEKRAT*Q(JRAYL+IEKBIN+1)
            SRAYL  = STEPRA*ZINTRA
            IF (SRAYL.LT.STEP) THEN
               STEP  = SRAYL
               IPROC = 25
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            INWVOL= 2
            IPROC = 0
            NMEC =  1
            LMEC(1)=1
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      IF (INWVOL.EQ.2) THEN
         DO 20 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTGAMA: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
               ENDIF
            ENDIF
            VECT(I) = VECTMP
   20    CONTINUE
      ELSE
         DO 30 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30    CONTINUE
      ENDIF
*
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      TOFG = TOFG +STEP/CLIGHT
*
* *** Update interaction probabilities
*
      IF (GETOT.GT.EPCUT) THEN
         IF (IPAIR.GT.0) ZINTPA = ZINTPA -STEP/STEPPA
      ENDIF
      IF (ICOMP.GT.0)    ZINTCO = ZINTCO -STEP/STEPCO
      IF (GEKIN.LT.0.4) THEN
         IF (IPHOT.GT.0) ZINTPH = ZINTPH -STEP/STEPPH
      ENDIF
      IF (JPFIS.GT.0)    ZINTPF = ZINTPF -STEP/STEPPF
      IF (IRAYL.GT.0) THEN
         IF (GEKIN.LT.0.01) ZINTRA = ZINTRA -STEP/STEPRA
      ENDIF
*
      IF (IPROC.EQ.0) GO TO 999
      NMEC = 1
      LMEC(1) = IPROC
*
*  ** Pair production ?
*
      IF (IPROC.EQ.6) THEN
         CALL GPAIRG
*
*  ** Compton scattering ?
*
      ELSE IF (IPROC.EQ.7) THEN
         CALL GCOMP
*
*  ** Photo-electric effect ?
*
      ELSE IF (IPROC.EQ.8) THEN
*       Calculate range of the photoelectron ( with kin. energy Ephot)
*
        IF(GEKIN.LE.0.001)  THEN
            JCOEF = LQ(JMA-17)
         IF(GEKRAT.LT.0.7) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0.) THEN
            STOPMX = -XCOEF2+SIGN(ONE,XCOEF1)*SQRT(XCOEF2**2 - (XCOEF3-
     +      GEKIN/XCOEF1))
         ELSE
            STOPMX = - (XCOEF3-GEKIN)/XCOEF2
         ENDIF
*
*        DO NOT call GPHOT if this (overestimated) range is smaller
*                than SAFETY
*
         IF (STOPMX.LE.SAFETY) GOTO 998
        ENDIF
 
         CALL GPHOT
*
*  ** Rayleigh effect ?
*
      ELSE IF (IPROC.EQ.25) THEN
         CALL GRAYL
*
*  ** Photo-fission ?
*
      ELSE IF (IPROC.EQ.23) THEN
         CALL GPFIS
*
      ENDIF
*
         GOTO 999
998      DESTEP = GEKIN
         GEKIN  = 0.
         GETOT  = 0.
         VECT(7)= 0.
         ISTOP  = 2
         NMEC   = 1
         LMEC(1)= 30
  999 CONTINUE
      END
+DECK, GTHADR
*CMZ :  3.21/02 03/07/94  17.57.24  by  S.Giani
*-- Author :
      SUBROUTINE GTHADR
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Charged hadron type track. Computes step size and propagates *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *       Authors    R.Brun, F.Bruyant, M.Maire ********           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCMULO.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+SEQ, GCJUMP, IF=USRJMP
 
+SELF, IF=-OLD
+CDE, GCVOLU.
+SEQ, GCVDMA.
+SELF
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION GKR,DEMEAN,STOPP,STOPMX,STOPRG,STOPC,EKIPR
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,YCOEF1,YCOEF2,YCOEF3
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (THRESH=0.7,ONE=1)
      REAL VNEXT(6)
      SAVE CFLD,CHARG2,RMASS,CUTPRO,IKCUT,STOPC
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTHAD) GO TO 100
*
* *** Update local pointers if medium has changed
*
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JLOSS = LQ(JMA-3)
         JRANG = LQ(JMA-16) + NEK1
         JCOEF = LQ(JMA-18) + 3*NEK1
         CHARG2 = CHARGE*CHARGE
         RMASS  = PMASS/AMASS
         OMCMOL = Q(JPROB+21)*CHARG2
         CHCMOL = Q(JPROB+25)*ABS(CHARGE)
         CUTPRO = MAX(CUTHAD*RMASS,ELOW(1))
         IKCUT = GEKA*LOG10(CUTPRO) + GEKB
         GKR   = (CUTPRO - ELOW(IKCUT))/(ELOW(IKCUT+1) - ELOW(IKCUT))
         STOPC = (1.-GKR)*Q(JRANG+IKCUT) + GKR*Q(JRANG+IKCUT+1)
         IF (FIELDM.NE.0.) THEN
            CFLD = 3333.*DEGRAD*TMAXFD/ABS(FIELDM*CHARGE)
         ELSE
            CFLD = BIG
         ENDIF
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
         IF(ISTRA.GT.0) THEN
            JTSTRA = LQ(JMA-19)
            JTSTCO = LQ(JTSTRA-1)
            JTSTEN = LQ(JTSTRA-2)
+SELF,IF=ASHO
            IF(ISTRA.EQ.2) THEN
               JTASHO = LQ(JMA-20)
            ENDIF
+SELF
         ENDIF
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
*
*  **   Step limitation due to hadron interaction ?
*
      IF (IHADR.GT.0) THEN
+SELF, IF=-USRJMP
         CALL GUPHAD
+SELF, IF=USRJMP
         CALL JUMPT0(JUPHAD)
+SELF
         IF (SHADR.LT.STEP) THEN
            IF (SHADR.LE.0.) SHADR = PREC
            STEP  = SHADR
            IPROC = 12
         ENDIF
      ENDIF
*
*  **   Step limitation due to decay ?
*
      IF (IDCAY.GT.0) THEN
         SDCAY = SUMLIF*VECT(7)/AMASS
         IF (SDCAY.LT.STEP) THEN
            STEP  = SDCAY
            IPROC = 5
         ENDIF
      ENDIF
*
*  ** Step limitation due to delta-ray production ?
*       (Cannot be tabulated easily because dependent on AMASS)
*
      IF (IDRAY.GT.0) THEN
         STEPDR = BIG
         IF (GEKIN.GT.DCUTM) THEN
            GAMASS = GETOT +AMASS
            TMAX   = EMASS*GEKIN*GAMASS/(0.5*AMASS*AMASS+EMASS*GETOT)
            IF (TMAX.GT.DCUTM) THEN
               BET2 = GEKIN*GAMASS/(GETOT*GETOT)
               Y    = DCUTM/TMAX
               SIG  = (1.-Y+BET2*Y*LOG(Y))/DCUTM
*              extra term for spin 1/2
               IF (AMASS.GT.0.9) SIG=SIG+0.5*(TMAX-DCUTM)/(GETOT*GETOT)
               SIG = SIG*Q(JPROB+17)*CHARG2*EMASS/BET2
*
               IF (SIG.GT.0.) THEN
                  STEPDR = 1./SIG
                  SDRAY  = STEPDR*ZINTDR
                  IF (SDRAY.LE.STEP) THEN
                     STEP  = SDRAY
                     IPROC = 10
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP  = 0.
         GO TO 110
      ENDIF
*
*  **   Step limitation due to energy loss (stopping range) ?
*
      IF (ILOSL.GT.0) THEN
         IF(GEKRAT.LT.THRESH) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0) THEN
            STOPP = -XCOEF2+SIGN(ONE,XCOEF1)* SQRT(XCOEF2
     +      **2 -(XCOEF3-GEKIN*RMASS/XCOEF1))
         ELSE
            STOPP = - (XCOEF3-GEKIN*RMASS)/XCOEF2
         ENDIF
         STOPMX = (STOPP - STOPC)/(RMASS*CHARG2)
         IF (STOPMX.LT.MIN(STEP,STMIN)) THEN
            STEP = STOPMX
            IPROC = 0
            IF(STEP.LE.0.)THEN
               GO TO 100
            ENDIF
            GO TO 10
         ENDIF
         EKF = (1. - DEEMAX)*GEKIN*RMASS
         IF (EKF.LT.ELOW(1)) THEN
            EKF = ELOW(1)
         ELSEIF (EKF.GE.ELOW(NEK1)) THEN
            EKF = ELOW(NEK1)*0.99
         ENDIF
         IKF=GEKA*LOG10(EKF)+GEKB
         GKR=(EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
         IF(GKR.LT.THRESH) THEN
            IK1 = MAX(IKF-1,1)
         ELSE
            IK1 = MIN(IKF,NEKBIN-1)
         ENDIF
         IK1 = 3*(IK1-1)+1
         YCOEF1=Q(JCOEF+IK1)
         YCOEF2=Q(JCOEF+IK1+1)
         YCOEF3=Q(JCOEF+IK1+2)
         IF(YCOEF1.NE.0.) THEN
            SLOSP = -YCOEF2+SIGN(ONE,YCOEF1)*SQRT(YCOEF2**2- (YCOEF3-
     +      EKF/YCOEF1))
         ELSE
            SLOSP = - (YCOEF3-EKF)/YCOEF2
         ENDIF
         SLOSP = STOPP - SLOSP
         SLOSS = MAX(STMIN, SLOSP/(RMASS*CHARG2) )
         IF (SLOSS.LT.STEP) THEN
            STEP = SLOSS
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to bending in magnetic field ?
*
      IF (IFIELD.NE.0) THEN
         SFIELD = CFLD*VECT(7)
         SFIELD=MAX(SFIELD, STMIN)
         IF (SFIELD.LT.STEP) THEN
            STEP  = SFIELD
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to multiple scattering ?
*
      IF (IMULL.GT.0) THEN
         SMULS=MIN(2232.*RADL*((VECT(7)**2)/(GETOT*CHARGE))**2,10.*RADL)
         SMULS  = MAX(STMIN, SMULS )
         IF (SMULS.LT.STEP) THEN
            STEP  = SMULS
            IPROC = 0
         ENDIF
      ENDIF
*
   10 CONTINUE
*
*  **   Step limitation due to Cerenkov production ?
*
      IF (IMCKOV.GT.0) THEN
         CALL GNCKOV
         STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         SMULS  = MAX(STMIN, STCKOV)
         IF (SMULS.LT.STEP) THEN
            STEP  = STCKOV
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 20 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   20       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport when no field or very short step
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
         IF (IGNEXT.NE.0) THEN
            DO 30 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTHADR: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   30       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 40 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   40       CONTINUE
         ENDIF
      ELSE
*
* ***   otherwise, swim particle in magnetic field
*
+SELF, IF=-OLD
         if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP
   50    CALL GUSWIM (CHARGE, STEP, VECT, VOUT)
+SELF, IF=USRJMP
   50    CALL JUMPT4(JUSWIM, CHARGE, STEP, VECT, VOUT)
+SELF
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 60 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   60          CONTINUE
               DO 70 I = 1,3
                  IF (ABS(VOUT(I)-VNEXT(I)).GT.EPSIL) GO TO 80
   70          CONTINUE
               INEAR = 1
            ENDIF
*
   80       CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0)THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 50
               ENDIF
            ENDIF
         ENDIF
*
         DO 90 I = 1,6
            VECT(I) = VOUT(I)
   90    CONTINUE
*
      ENDIF
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*CHARG2*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         IF(NGPHOT.NE.0) THEN
            NMEC=NMEC+1
            LMEC(NMEC)=105
         ENDIF
      ENDIF
*
* *** apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 3
         STOPRG = STOPP - STEP*RMASS*CHARG2
         IF (STOPRG.LE.STOPC) THEN
            STEP = STOPMX
            GO TO 100
         ENDIF
         IF(XCOEF1.NE.0.) THEN
            EKIPR = XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            EKIPR = XCOEF2*STOPRG+XCOEF3
         ENDIF
         DEMEAN=GEKIN - EKIPR/RMASS
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +      *STEP*CHARG2
         ENDIF
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
            DEMS   = DEMEAN/CHARG2
            CALL GFLUCT(DEMS,DESTEP)
            DESTEP = DESTEP*CHARG2
         ENDIF
         DESTEP=MAX(DESTEP,0.)
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTHAD)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
      ENDIF
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 2
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG   = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IHADR.GT.0) ZINTHA = ZINTHA*(1.-STEP/SHADR)
      IF (IDRAY.GT.0) ZINTDR = ZINTDR -STEP/STEPDR
*
      GO TO 110
*
*  **   Special treatment for overstopped tracks
*
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GAMMA  = GETOT/AMASS
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      ISTOP  = 2
      NMEC = NMEC + 1
      LMEC(NMEC) = 30
      IF (IHADR.EQ.0) THEN
         IF (IDCAY.NE.0) THEN
            TOFG = TOFG +0.5*(1+GAMMA)*SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               ISTOP = 4
               NMEC = NMEC + 1
               LMEC(NMEC) = 22
               NGKINE = 0
            ELSE
               NMEC = NMEC + 1
               LMEC(NMEC) = 5
               ISTOP =1
               CALL GDECAY
            ENDIF
         ENDIF
         GO TO 999
      ENDIF
      IPROC = 12
*
* *** apply slected process if any
*
  110 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Hadron interaction ?
*
      IF (IPROC.EQ.12) THEN
+SELF, IF=-USRJMP
         CALL GUHADR
+SELF, IF=USRJMP
         CALL JUMPT0(JUHADR)
+SELF
*   *   Check time cut-off for decays at rest
         IF (LMEC(NMEC).EQ.5) THEN
            TOFG   = TOFG +SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               NGKINE = 0
               ISTOP  = 4
               LMEC(NMEC) = 22
            ENDIF
         ENDIF
*
*  **   Decay ?
*
      ELSE IF (IPROC.EQ.5) THEN
         ISTOP = 1
         CALL GDECAY
*
*  **   Delta-ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
         CALL GDRAY
      ENDIF
  999 IF(NGPHOT.GT.0) THEN
         IF(ITCKOV.EQ.2.AND.ISTOP.EQ.0) THEN
*
*  The hadron has produced Cerenkov photons and it is still alive
*  we put it in the stack and we let the photons to be tracked
            NGKINE = NGKINE+1
            GKIN(1,NGKINE) = VECT(4)*VECT(7)
            GKIN(2,NGKINE) = VECT(5)*VECT(7)
            GKIN(3,NGKINE) = VECT(6)*VECT(7)
            GKIN(4,NGKINE) = GETOT
            GKIN(5,NGKINE) = IPART
            TOFD(NGKINE) = 0.
            ISTOP = 1
c----put position as well
            GPOS(1,NGKINE)=VECT(1)
            GPOS(2,NGKINE)=VECT(2)
            GPOS(3,NGKINE)=VECT(3)
         ENDIF
      ENDIF
      END
+DECK,gthion.
*CMZ :  3.21/02 03/07/94  17.58.49  by  S.Giani
*-- Author :
      SUBROUTINE GTHION
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Heavy  ion  type track. Computes step size and propagates    *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   The ionisation energy loss is calculated here (mean +        *
C.    *       fluctuations)                                            *
C.    *   The fluctuations are the same for ILOSS=1,2,3 and            *
C.    *       there is no fluctuation for ILOSS=4.                     *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *       Authors    R.Brun, F.Bruyant, M.Maire, L.Urban ***       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCMULO.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+SEQ, GCJUMP, IF=USRJMP
 
+SELF, IF=-OLD
+CDE, GCVOLU.
+SEQ, GCVDMA.
+SELF
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION GKR,DEMEAN,STOPP,STOPMX,STOPRG,STOPC,EKIPR
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,YCOEF1,YCOEF2,YCOEF3
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (THRESH=0.7,ONE=1)
      PARAMETER (TWOTHR=2*ONE/3,AMU=0.9314943)
      PARAMETER (DME=7.84572E-8,CNORM=2.5)
      REAL VNEXT(6)
      DIMENSION RNDM(2)
      SAVE RMASS,CUTPRO,IKCUT,STOPC,FACFLU,CHAR23
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTHAD) GO TO 100
*
* *** Update local pointers if medium has changed
*
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JLOSS = LQ(JMA-3)
         JRANG = LQ(JMA-16) + NEK1
         JCOEF = LQ(JMA-18) + 3*NEK1
         RMASS  = PMASS/AMASS
         CUTPRO = MAX(CUTHAD*RMASS,ELOW(1))
         IKCUT = GEKA*LOG10(CUTPRO) + GEKB
         GKR   = (CUTPRO - ELOW(IKCUT))/(ELOW(IKCUT+1) - ELOW(IKCUT))
         STOPC = (1.-GKR)*Q(JRANG+IKCUT) + GKR*Q(JRANG+IKCUT+1)
         FACFLU = DME*Z*DENS/A
         CHAR23 = ONE/CHARGE**TWOTHR
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
      ENDIF
*
* *** Compute energy dependent parameters
*
      GAMASS=GETOT+AMASS
      BET2=GEKIN*GAMASS/(GETOT*GETOT)
      BET=SQRT(BET2)
      W1=1.034-0.1777*EXP(-0.08114*CHARGE)
      W2=BET*CHAR23
      W3=121.4139*W2+0.0378*SIN(190.7165*W2)
      CHARG1=CHARGE*(1.-W1*EXP(-W3))
*
*              the effective charge  CHARG1
*            can be negative only for very low energy and
*     for CHARGE > 20 ( very low energy : T/A < 20 keV/nucleon)
*              in this case short circuit
*
      IF(CHARG1.LT.0.) GOTO 100
      CHARG2=CHARG1**2
*
      OMCMOL=Q(JPROB+21)*CHARG2
      CHCMOL=Q(JPROB+25)*ABS(CHARG1)
      IF(FIELDM.NE.0.) THEN
         CFLD=3333.*DEGRAD*TMAXFD/ABS(FIELDM*CHARG1)
      ELSE
         CFLD=BIG
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
*
*  **   Step limitation due to hadron interaction ?
*
      IF (IHADR.GT.0) THEN
+SELF, IF=-USRJMP
         CALL GUPHAD
+SELF, IF=USRJMP
         CALL JUMPT0(JUPHAD)
+SELF
         IF (SHADR.LT.STEP) THEN
            IF (SHADR.LE.0.) SHADR = PREC
            STEP  = SHADR
            IPROC = 12
         ENDIF
      ENDIF
*
*  ** Step limitation due to delta-ray production ?
*       (Cannot be tabulated easily because dependent on AMASS)
*
      IF (IDRAY.GT.0) THEN
         STEPDR = BIG
         IF (GEKIN.GT.DCUTM) THEN
            TMAX   = EMASS*GEKIN*GAMASS/(0.5*AMASS*AMASS+EMASS*GETOT)
            IF (TMAX.GT.DCUTM) THEN
               Y    = DCUTM/TMAX
               SIG  = (1.-Y+BET2*Y*LOG(Y))/DCUTM
*              extra term for spin 1/2
               IF (AMASS.GT.0.9) SIG=SIG+0.5*(TMAX-DCUTM)/(GETOT*GETOT)
               SIG = SIG*Q(JPROB+17)*CHARG2*EMASS/BET2
*
               IF (SIG.GT.0.) THEN
                  STEPDR = 1./SIG
                  SDRAY  = STEPDR*ZINTDR
                  IF (SDRAY.LE.STEP) THEN
                     STEP  = SDRAY
                     IPROC = 10
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP  = 0.
         GO TO 110
      ENDIF
*
*  **   Step limitation due to energy loss (stopping range) ?
*
      IF (ILOSL.GT.0) THEN
         IF(GEKRAT.LT.THRESH) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0) THEN
            STOPP = -XCOEF2+SIGN(ONE,XCOEF1)* SQRT(XCOEF2
     +      **2 -(XCOEF3-GEKIN*RMASS/XCOEF1))
         ELSE
            STOPP = - (XCOEF3-GEKIN*RMASS)/XCOEF2
         ENDIF
         STOPMX = (STOPP - STOPC)/(RMASS*CHARG2)
         IF (STOPMX.LT.MIN(STEP,STMIN)) THEN
            STEP = STOPMX
            IPROC = 0
            IF(STEP.LE.0.)THEN
               GO TO 100
            ENDIF
            GO TO 10
         ENDIF
         EKF = (1. - DEEMAX)*GEKIN*RMASS
         IF (EKF.LT.ELOW(1)) THEN
            EKF = ELOW(1)
         ELSEIF (EKF.GE.ELOW(NEK1)) THEN
            EKF = ELOW(NEK1)*0.99
         ENDIF
         IKF=GEKA*LOG10(EKF)+GEKB
         GKR=(EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
         IF(GKR.LT.THRESH) THEN
            IK1 = MAX(IKF-1,1)
         ELSE
            IK1 = MIN(IKF,NEKBIN-1)
         ENDIF
         IK1 = 3*(IK1-1)+1
         YCOEF1=Q(JCOEF+IK1)
         YCOEF2=Q(JCOEF+IK1+1)
         YCOEF3=Q(JCOEF+IK1+2)
         IF(YCOEF1.NE.0.) THEN
            SLOSP = -YCOEF2+SIGN(ONE,YCOEF1)*SQRT(YCOEF2**2- (YCOEF3-
     +      EKF/YCOEF1))
         ELSE
            SLOSP = - (YCOEF3-EKF)/YCOEF2
         ENDIF
         SLOSP = STOPP - SLOSP
         SLOSS = MAX(STMIN, SLOSP/(RMASS*CHARG2) )
         IF (SLOSS.LT.STEP) THEN
            STEP = SLOSS
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to energy loss in magnetic field ?
*
      IF (IFIELD.NE.0) THEN
         SFIELD = CFLD*VECT(7)
         SFIELD=MAX(SFIELD, STMIN)
         IF (SFIELD.LT.STEP) THEN
            STEP  = SFIELD
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to multiple scattering ?
*
      IF (IMULL.GT.0) THEN
         SMULS=MIN(2232.*RADL*((VECT(7)**2)/(GETOT*CHARG1))**2,10.*RADL)
         SMULS  = MAX(STMIN, SMULS )
         IF (SMULS.LT.STEP) THEN
            STEP  = SMULS
            IPROC = 0
         ENDIF
      ENDIF
*
   10 CONTINUE
*
*  **   Step limitation due to Cerenkov production ?
*
      IF (IMCKOV.GT.0) THEN
         CALL GNCKOV
         STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         SMULS  = MAX(STMIN, STCKOV)
         IF (SMULS.LT.STEP) THEN
            STEP  = STCKOV
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 20 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   20       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport when no field or very short step
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
         IF (IGNEXT.NE.0) THEN
            DO 30 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTHION: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   30       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 40 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   40       CONTINUE
         ENDIF
      ELSE
*
* ***   otherwise, swim particle in magnetic field
*
+SELF, IF=-OLD
         if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP
   50    CALL GUSWIM (CHARG1, STEP, VECT, VOUT)
+SELF, IF=USRJMP
   50    CALL JUMPT4(JUSWIM, CHARG1, STEP, VECT, VOUT)
+SELF
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 60 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   60          CONTINUE
               DO 70 I = 1,3
                  IF (ABS(VOUT(I)-VNEXT(I)).GT.EPSIL) GO TO 80
   70          CONTINUE
               INEAR = 1
            ENDIF
*
   80       CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0)THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 50
               ENDIF
            ENDIF
         ENDIF
*
         DO 90 I = 1,6
            VECT(I) = VOUT(I)
   90    CONTINUE
*
      ENDIF
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*CHARG2*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         NMEC=NMEC+1
         LMEC(NMEC)=105
      ENDIF
*
* *** apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 3
         STOPRG = STOPP - STEP*RMASS*CHARG2
         IF (STOPRG.LE.STOPC) THEN
            STEP = STOPMX
            GO TO 100
         ENDIF
         IF(XCOEF1.NE.0.) THEN
            EKIPR = XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            EKIPR = XCOEF2*STOPRG+XCOEF3
         ENDIF
         DEMEAN=GEKIN - EKIPR/RMASS
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +             *STEP*CHARG2
         ENDIF
*
*        fluctuations : differ from that of 'ordinary' hadrons
*
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
*
*     Charge exchange fluctuations + Gaussian 'Landau' fluctuations
*           (it is the same for ILOSS=1,2,3 !)
*
            SIGMA2=CNORM*CHARG1*(1.-CHARG1/CHARGE)
*
            TA = RMASS*GEKIN
            TAM=TA/AMU
            SIGMA2=SIGMA2+2.+TAM*(2.+TAM)
*
            SIGMA2=FACFLU*CHARG2*STEP*SIGMA2
            SIGMA=SQRT(SIGMA2)
*
*     Check if we are in 'Gaussian' regime ...
*
            CAPPA=(1.+TAM)/(TAM*(2.+TAM)*EMASS)
            CAPPA=0.5*CAPPA**2*FACFLU*CHARG2*STEP
*
*     ... if not , correct SIGMA !
 
            IF(CAPPA.LT.10.) THEN
               SIGMA=SIGMA/(0.97+0.03*SQRT(10./CAPPA))
            ENDIF
*
            CALL GRNDM(RNDM,2)
            DEFLUC=SIGMA*SIN(TWOPI*RNDM(1))*SQRT(-2.*LOG(RNDM(2)))
            DESTEP=DEMEAN+DEFLUC
         ENDIF
*
*     protection against negative destep
*
         IF(DESTEP.LT.0.) DESTEP=DEMEAN
*                          IF (DESTEP.LT.0.) DESTEP = 0.
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTHAD)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
      ENDIF
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 2
*      check charge dependence ...........!!!!!!!  (later..)
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG   = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IHADR.GT.0) ZINTHA = ZINTHA*(1.-STEP/SHADR)
      IF (IDRAY.GT.0) ZINTDR = ZINTDR -STEP/STEPDR
*
      GO TO 110
*
*  **   Special treatment for overstopped tracks
*
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      ISTOP  = 2
      NMEC = NMEC + 1
      LMEC(NMEC) = 30
      IF (IHADR.EQ.0) GO TO 999
      IPROC = 12
*
* *** apply slected process if any
*
  110 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Hadron interaction ?
*
      IF (IPROC.EQ.12) THEN
+SELF, IF=-USRJMP
         CALL GUHADR
+SELF, IF=USRJMP
         CALL JUMPT0(JUHADR)
+SELF
*   *   Check time cut-off for decays at rest
         IF (LMEC(NMEC).EQ.5) THEN
            TOFG   = TOFG +SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               NGKINE = 0
               ISTOP  = 4
               LMEC(NMEC) = 22
            ENDIF
         ENDIF
*
*  **   Delta-ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
         CALL GDRAY
      ENDIF
  999 CONTINUE
      END
+DECK,GTMEDI,IF=-OLD.
*CMZ :  3.21/02 29/03/94  15.22.08  by  S.Giani
*-- Author :
      SUBROUTINE GTMEDI (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Note : For INWVOL = 2, INFROM set to a positive number is    *
C.    *      interpreted by GTMEDI as the number IN of the content     *
C.    *      just left by the current track within the mother volume   *
C.    *      where the point X is assumed to be.                       *
C.    *                                                                *
C.    *   Note : INFROM is set correctly by this routine but it is     *
C.    *      used on entrance only in the case GSNEXT has been called  *
C.    *      by the user. In other words the value of INFROM received  *
C.    *      on entrance is not considered necessarily valid. This     *
C.    *      assumption has been made for safety. A wrong value of     *
C.    *      INFROM can cause wrong tracking.                          *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *               S.Giani.                                         *
C.    *                                                                *
C.    *   Modified by S.Giani (1993) to perform the search according   *
C.    *    to the new 'virtual divisions' algorithm and to build the   *
C.    *    stack of the 'possible overlapping volumes' in the case of  *
C.    *    MANY volumes. Any kind of boolean operation is now possible.*
C.    *    Divisions along arbitrary axis are now possible.            *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCFLAG.
+SEQ, GCKINE.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
+SEQ, GCVDMA.
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
C.
      CHARACTER*4 NAME
      DIMENSION  X(*)
      REAL       XC(6), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
      nvmany=0
      nfmany=0
      new2fl=0
      neufla=0
      if(raytra.eq.1.)then
        JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
        if(ingoto.eq.-1.and.q(jvo+3).lt.0)then
          neufla=1
        elseif(ingoto.eq.0)then
              call ggperp(x,veccos,ierr)
              veccos(1)=-veccos(1)
              veccos(2)=-veccos(2)
              veccos(3)=-veccos(3)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
        endif
      endif
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
* *** Check if point is in current volume
*
      INFR = 0
      INGT = 0
      JVIN = 0
*
* *** LSAMVL is a logical variable that indicates whether we are still
* *** in the current volume or not. It is used in GTRACK to detect
* *** precision problems.
      LSAMVL = .TRUE.
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
 
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 189
      endif
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            LSAMVL = .FALSE.
            NL1 = NLEVEL +1
            LVOLUM(NL1) = IVOT
            NAMES(NL1)  = IQ(JVOLUM+IVOT)
            NUMBER(NL1) = Q(JIN+3)
            LINDEX(NL1) = INGOTO
            LINMX(NL1)  = Q(JVO+3)
            GONLY(NL1)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NL1) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NL1) = NL1
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NL1), GRMAT(1,NL1))
            NLEVEL = NL1
            XC(1) = XT(1)
            XC(2) = XT(2)
            XC(3) = XT(3)
            JVO = JVOT
            INFROM = 0
            if(raytra.eq.1.)then
              call ggperp(x,veccos,ierr)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
            endif
            GO TO 190
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
 189  JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         LSAMVL = .FALSE.
         INGOTO = 0
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
               INFROM=LINDEX(NLEVEL+1)
            ELSE
               INFROM=0
            ENDIF
            INFR = INFROM
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ELSE
*
*   *      Point in current volume but not in INGOTO. We block the
*   *      corresponding volume
*
         IF (INGOTO.GT.0) THEN
            INGT = INGOTO
            JIN = LQ(JVO-INGOTO)
            IQ(JIN) = IBSET(IQ(JIN),4)
         ENDIF
      ENDIF
*
*   *      Found a volume up the tree which contains our point. We block
*   *      the branch we came up from.
*
      IF(INFR.GT.0) THEN
         JIN=LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
*
*  **   Point is in current volume
*
  190 INGOTO = 0
      NLMIN = NLEVEL
      IF (INWVOL.NE.2) INFROM = 0
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            if(raytra.eq.1..and.neufla.eq.1)then
              neufla=0
              call ggperp(x,veccos,ierr)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
            endif
            INFROM = 0
            INFR   = 0
            INGT   = 0
            LSAMVL = .FALSE.
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  new2fl=0
                  IF (GONLY(NLEVEL).NE.0.) THEN
                    NLMANY = 0
                    nvmany = 0
                    nfmany = 0
                  ENDIF
                  INFROM = 0
                  INGT   = 0
                  INFR   = 0
                  LSAMVL = .FALSE.
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INFR = 0
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INGT = 0
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
            nfmany=nvmany+1
         ENDIF
         if(new2fl.eq.0)then
            nvmany=nvmany+1
            manyle(nvmany)=nlevel
            do 401 i = 1,nlevel
              manyna(nvmany,i)=names(i)
              manynu(nvmany,i)=number(i)
 401        continue
         endif
*
*   *   Go up the tree up to a volume with positioned contents
*
         new2fl=-1
  310    INFROM = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         INFR = INFROM
         JIN = LQ(JVO-INFROM)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      if(nlmany.eq.0)then
        nvmany=0
        nfmany=0
      endif
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GTMEDI
  999 IF(JGSTAT.NE.0) CALL GFSTAT(4)
      END
+DECK, GTMUON
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTMUON
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Muon track. Computes step size and propagates particle       *
C.    *    through step.                                               *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors     R.Brun, F.Bruyant, M.Maire ********           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCMATE.
+CDE, GCMULO.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCKING.
+SEQ, GCJUMP, IF=USRJMP
 
+SELF, IF=-OLD
+CDE, GCVOLU.
+SEQ, GCVDMA.
+SELF
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION DEMEAN,STOPRG,STOPMX,STOPC
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
      PARAMETER (ONE=1)
      REAL VNEXT(6)
      SAVE IKCUT,STOPC
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTMUO) GO TO 100
*
* *** Update local pointers if medium has changed
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JLOSS = LQ(JMA-2)
         JBREM = LQ(JMA-9)
         JPAIR = LQ(JMA-10)
         JDRAY = LQ(JMA-11)
         JMUNU = LQ(JMA-14)
         JRANG = LQ(JMA-16)
         JCOEF = LQ(JMA-18)
         JMULOF= LQ(JTM-2)
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
         OMCMOL= Q(JPROB+21)
         CHCMOL= Q(JPROB+25)
         IKCUT = Q(JMULOF+NEK1+1)
         STOPC = Q(JMULOF+NEK1+2)
         IF(ISTRA.GT.0) THEN
            JTSTRA = LQ(JMA-19)
            JTSTCO = LQ(JTSTRA-1)
            JTSTEN = LQ(JTSTRA-2)
+SELF,IF=ASHO
            IF(ISTRA.EQ.2) THEN
               JTASHO = LQ(JMA-20)
            ENDIF
+SELF
         ENDIF
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
      IEK1   = IEKBIN+NEK1
      IEK2   = IEKBIN+2*NEK1
*
*  **   Step limitation due to bremsstrahlung ?
*
      IF (IBREM.GT.0) THEN
         STEPBR = GEKRT1*Q(JBREM+IEK2) +GEKRAT*Q(JBREM+IEK2+1)
         SBREM  = STEPBR*ZINTBR
         IF (SBREM.LT.STEP) THEN
            STEP  = SBREM
            IPROC = 9
         ENDIF
      ENDIF
*
*  **   Step limitation due to pair production ?
*
      IF (IPAIR.GT.0) THEN
         STEPPA = GEKRT1*Q(JPAIR+IEK1) +GEKRAT*Q(JPAIR+IEK1+1)
         SPAIR  = STEPPA*ZINTPA
         IF (SPAIR.LT.STEP) THEN
            STEP  = SPAIR
            IPROC = 6
         ENDIF
      ENDIF
*
*  **   Step limitation due to decay ?
*
      IF (IDCAY.NE.0) THEN
         SDCAY = SUMLIF*VECT(7)/AMASS
         IF (SDCAY.LT.STEP) THEN
            STEP  = SDCAY
            IPROC = 5
         ENDIF
      ENDIF
*
*  **   Step limitation due to delta-ray ?
*
      IF (IDRAY.GT.0) THEN
         STEPDR = GEKRT1*Q(JDRAY+IEK2) +GEKRAT*Q(JDRAY+IEK2+1)
         SDRAY  = STEPDR*ZINTDR
         IF (SDRAY.LT.STEP) THEN
            STEP  = SDRAY
            IPROC = 10
         ENDIF
      ENDIF
*
*  **   Step limitation due to nuclear interaction ?
*
      IF (IMUNU.GT.0) THEN
         IF(GEKIN.GE.5.)THEN
            STEPMU = GEKRT1*Q(JMUNU+IEKBIN) +GEKRAT*Q(JMUNU+IEKBIN+1)
            SMUNU = STEPMU*ZINTMU
            IF (SMUNU.LT.STEP) THEN
               STEP  = SMUNU
               IPROC = 21
            ENDIF
         ELSE
            STEPMU = BIG
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP = 0.
         GO TO 90
      ENDIF
*
*  **   Step limitation due to energy-loss,multiple scattering
*             or magnetic field ?
*
      IF (JMULOF.NE.0) THEN
         SMULOF  = GEKRT1*Q(JMULOF+IEKBIN) +GEKRAT*Q(JMULOF+IEKBIN+1)
         IF (SMULOF.LT.STEP) THEN
            STEP  = SMULOF
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP  = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport when no field or very short step
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
         IF (IGNEXT.NE.0) THEN
            DO 20 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTMUON: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   20       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 30 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30       CONTINUE
         ENDIF
      ELSE
*
* ***   otherwise, swim particle in magnetic field
*
+SELF, IF=-OLD
         if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP
   40    CALL GUSWIM (CHARGE, STEP, VECT, VOUT)
+SELF, IF=USRJMP
   40    CALL JUMPT4(JUSWIM, CHARGE, STEP, VECT, VOUT)
+SELF
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 50 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   50          CONTINUE
               DO 60 I = 1,3
                  IF (ABS(VOUT(I)-VNEXT(I)).GT.EPSIL) GO TO 70
   60          CONTINUE
               INEAR = 1
            ENDIF
*
   70       CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0)THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 40
               ENDIF
            ENDIF
         ENDIF
*
         DO 80 I = 1,6
            VECT(I) = VOUT(I)
   80    CONTINUE
*
      ENDIF
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         IF(NGPHOT.NE.0) THEN
            NMEC=NMEC+1
            LMEC(NMEC)=105
         ENDIF
      ENDIF
*
* *** apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 3
         IF(GEKRAT.LT.0.7) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0.) THEN
            STOPMX = -XCOEF2+SIGN(ONE,XCOEF1)*SQRT(XCOEF2**2 - (XCOEF3-
     +      GEKIN/XCOEF1))
         ELSE
            STOPMX = - (XCOEF3-GEKIN)/XCOEF2
         ENDIF
         STOPRG = STOPMX - STEP
         IF (STOPRG.LT.STOPC) THEN
            STEP = STOPMX - STOPC
            GO TO 100
         ENDIF
*
         IF(XCOEF1.NE.0.) THEN
            DEMEAN=GEKIN-XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            DEMEAN=GEKIN-XCOEF2*STOPRG-XCOEF3
         ENDIF
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +      *STEP
         ENDIF
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
            DEMS = DEMEAN
            CALL GFLUCT(DEMS,DESTEP)
         ENDIF
         IF (DESTEP.LT.0.) DESTEP = 0.
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTMUO)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
      ENDIF
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC   = NMEC +1
         LMEC(NMEC) = 2
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IBREM.GT.0) ZINTBR = ZINTBR -STEP/STEPBR
      IF (IPAIR.GT.0) ZINTPA = ZINTPA -STEP/STEPPA
      IF (IDRAY.GT.0) ZINTDR = ZINTDR -STEP/STEPDR
      IF (IMUNU.GT.0) ZINTMU = ZINTMU -STEP/STEPMU
*
* ***   otherwise, apply the selected process if any
*
   90 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Bremsstrahlung ?
*
      IF (IPROC.EQ.9) THEN
         CALL GBREMM
*
*  **   Pair production ?
*
      ELSE IF (IPROC.EQ.6) THEN
         CALL GPAIRM
*
*  **   Decay ?
*
      ELSE IF (IPROC.EQ.5) THEN
         ISTOP = 1
         CALL GDECAY
*
*  **   Delta-ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
         CALL GDRAY
*
*  **   Nuclear interaction ?
*
      ELSE IF (IPROC.EQ.21) THEN
         CALL GMUNU
      ENDIF
      GO TO 999
*
* *** Special treatment for overstopped tracks
*
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      NMEC   = NMEC +1
      LMEC(NMEC) = 30
      IF (IDCAY.EQ.0) THEN
         ISTOP = 2
      ELSE
         NMEC   = NMEC +1
         TOFG   = TOFG +SUMLIF/CLIGHT
         SUMLIF = 0.
         IF (TOFG.GE.TOFMAX) THEN
            ISTOP = 4
            LMEC(NMEC) = 22
            GO TO 999
         ENDIF
         LMEC(NMEC) = 5
         ISTOP = 1
         CALL GDECAY
      ENDIF
  999 IF(NGPHOT.GT.0) THEN
         IF(ITCKOV.EQ.2.AND.ISTOP.EQ.0) THEN
*
*  The muon has produced Cerenkov photons and it is still alive
*  we put it in the stack and we let the photons to be tracked
            NGKINE = NGKINE+1
            GKIN(1,NGKINE) = VECT(4)*VECT(7)
            GKIN(2,NGKINE) = VECT(5)*VECT(7)
            GKIN(3,NGKINE) = VECT(6)*VECT(7)
            GKIN(4,NGKINE) = GETOT
            GKIN(5,NGKINE) = IPART
            TOFD(NGKINE) = 0.
            ISTOP = 1
c----put position as well
            GPOS(1,NGKINE)=VECT(1)
            GPOS(2,NGKINE)=VECT(2)
            GPOS(3,NGKINE)=VECT(3)
         ENDIF
      ENDIF
      END
+DECK, GTNEUT
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTNEUT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Neutral hadron type track. Computes step size and propagates *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors     R.Brun, F.Bruyant  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCKINE.
+CDE, GCKING.
+SEQ,GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCUNIT, IF=DEBUG
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? Special treatment
*
      IF (GEKIN.LE.CUTNEU) THEN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7)= 0.
         ISTOP  = 2
         NMEC = NMEC + 1
         LMEC(NMEC) = 30
         IF (IHADR.EQ.0.AND.AMASS.GT.0.) THEN
            IF (IDCAY.NE.0) THEN
               GAMMA  = GETOT/AMASS
               TOFG = TOFG +GAMMA*SUMLIF/CLIGHT
               SUMLIF = 0.
               IF (TOFG.GE.TOFMAX) THEN
                  ISTOP = 4
                  NMEC = NMEC + 1
                  LMEC(NMEC) = 22
                  NGKINE = 0
               ELSE
                  NMEC = NMEC + 1
                  LMEC(NMEC) = 5
                  ISTOP =1
                  CALL GDECAY
               ENDIF
            ENDIF
            GO TO 999
         ENDIF
         IPROC = 12
         GO TO 40
      ENDIF
*
* *** Compute step size
*
      IPROC  = 103
      STEP   = STEMAX
*
*  **   Step limitation due to hadron interaction ?
*
      IF (IHADR.GT.0) THEN
+SELF, IF=-USRJMP
         CALL GUPHAD
+SELF, IF=USRJMP
         CALL JUMPT0(JUPHAD)
+SELF
         IF (SHADR.LT.STEP) THEN
            IF (SHADR.LE.0.) SHADR = PREC
            STEP  = SHADR
            IPROC = 12
         ENDIF
      ENDIF
*
*  **   Step limitation due to decay ?
*
      IF ((IDCAY.NE.0).AND.(AMASS.GT.0.)) THEN
         SDCAY = SUMLIF*VECT(7)/AMASS
         IF (SDCAY.LT.STEP) THEN
            STEP  = SDCAY
            IPROC = 5
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP = SNEXT + PREC
            IPROC = 0
            INWVOL = 2
            NMEC = NMEC + 1
            LMEC(NMEC)  = 1
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      IF (INWVOL.EQ.2) THEN
         DO 20 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTNEUT: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
               ENDIF
            ENDIF
            VECT(I) = VECTMP
   20    CONTINUE
      ELSE
         DO 30 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30    CONTINUE
      ENDIF
*
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IHADR.GT.0) ZINTHA = ZINTHA*(1.-STEP/SHADR)
*
* *** apply the selected process if any
*
   40 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Hadron interaction ?
*
      IF (IPROC.EQ.12) THEN
+SELF, IF=-USRJMP
         CALL GUHADR
+SELF, IF=USRJMP
         CALL JUMPT0(JUHADR)
+SELF
*          Check time cut-off for decays at rest
         IF (LMEC(NMEC).EQ.5) THEN
            TOFG   = TOFG +SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               ISTOP = 4
               LMEC(NMEC) = 22
               NGKINE = 0
            ENDIF
         ENDIF
*
*  **   Decay ?
*
      ELSE IF (IPROC.EQ.5) THEN
         ISTOP = 1
         CALL GDECAY
      ENDIF
*                                                             END GTNEUT
  999 CONTINUE
      END
+DECK,GTNEXT,IF=-OLD.
*CMZ :  3.21/03 06/10/94  18.15.39  by  S.Giani
*-- Author :
      SUBROUTINE GTNEXT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *                                                                *
C.    *   Author   : S.Giani (1993)                                    *
C.    *                                                                *
C.    *   This routine is now based on the new 'virtual divisions'     *
C.    *    algorithm to speed up the tracking.                         *
C.    *   The tracking for MANY volumes is not anymore based on a step *
C.    *    search: it is now based on a search through the list of     *
C.    *    'possible overlapping volumes' built by GTMEDI.             *
C.    *    Boolean operations and divisions along arbitrary axis are   *
C.    *     now supported.                                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+SEQ, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SEQ,GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
+SEQ, GCVDMA.
      DIMENSION NUMTMP(15),NAMTMP(15)
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      CHARACTER*4 NAME
      dimension iarrin(500),cxm(3),xxm(6)
      REAL      X0(6), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      mycoun=0
      myinfr=0
      newfl=0
      manyfl=0
      tsafet=big
      tsnext=big
401   IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      sneold=SNEXT
      nnn=0
      nflag=0
      mmm=0
      snxtot=0.
 111  if(nin.gt.1)then
        if(nnn.gt.0)goto 112
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.eq.4)then
         do 1 i=1,6
          xxm(i)=xc(i)
 1       continue
        endif
        divthi=(chmoth-clmoth)/ndivto
        if(iaxis.le.3)then
          cx=xc(iaxis)
          if(xc(iaxis+3).ge.0.)then
            inc=1
          else
            inc=-1
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.4)then
            dr= xc(1)*xc(4)+xc(2)*xc(5)
*            if(dr.eq.0.)print *,'dr.eq.0.'
            if(dr.ge.0.)then
              inc=1
            else
              inc=-1
            endif
          elseif(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
            dfi=xc(1)*xc(5)-xc(2)*xc(4)
            if(dfi.ge.0)then
              inc=1
            else
              inc=-1
            endif
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
 112    iofset=iq(jvdiv+ivdiv)
        jcont2=jvdiv+iofset+1
        ncont=iq(jcont2)
        if(ncont.eq.0)then
          idmi=iq(jcont2+1)
          idma=iq(jcont2+2)
          llflag=0
        elseif(ncont.eq.1)then
          idmi=iq(jcont2+2)
          idma=iq(jcont2+3)
          in=iq(jcont2+1)
        else
          idmi=iq(jcont2+ncont+1)
          idma=iq(jcont2+ncont+2)
          iii=1
          in=iq(jcont2+iii)
        endif
        if(nnn.eq.0)then
         cxold=cx
         if(inc.gt.0)then
          cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
          if(iaxis.ne.6)then
           safety=min(safety,(cxold-cmin))
          else
           safefi=min(90.,(cxold-cmin))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         else
          cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
          if(iaxis.ne.6)then
           safety=min(safety,(cmax-cxold))
          else
           safefi=min(90.,(cmax-cxold))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         endif
        endif
        if(ncont.eq.0)goto 181
      elseif(nin.eq.1)then
        in=1
      endif
*
  150 if(nin.gt.1.and.ncont.gt.1)then
        in=iq(jcont2+iii)
      endif
      if(nin.gt.0)then
*        if(infrom.gt.0.and.myinfr.eq.0.and.newfl.eq.0)then
*          if(in.eq.infrom)goto 171
*        endif
        jin=lq(jvo-in)
        if(.NOT.BTEST(iq(jin),4))then
        else
          goto 171
        endif
      endif
      if(nin.gt.1)then
        llflag=0
        if(mmm.le.500)then
         do 151 ll=1,mmm
          if(iarrin(ll).eq.in)then
            llflag=1
            goto 171
          endif
 151     continue
        endif
        if(llflag.eq.0)then
          mmm=mmm+1
          if(mmm.le.500)then
            iarrin(mmm)=in
          endif
        endif
      endif
      IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 179
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
 179  if((nin.eq.1).or.(nin.gt.1.and.llflag.eq.0))then
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
      ENDIF
      endif
 171  if(nin.eq.1)then
        goto 300
      elseif(nin.ge.1.and.ncont.gt.1)then
           iii=iii+1
           if(iii.le.ncont)goto 150
      endif
*
*   *         Compute distance to boundary of current volume
*
 181  if(nnn.eq.0)then
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               safe=max(safe,0.)
               if(snxt.le.-prec)snxt=big1
               snxt=max(snxt,0.)
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
      endif
      if(iaxis.eq.4)then
       if(idma.eq.ndivto.and.inc.gt.0)goto 400
        cxm(1)=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
        if(idmi.eq.idma)then
          cxm(2)=cxm(1)+divthi
        else
          cxm(2)=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
        endif
        cxm(3)=20000.
        call gntube(xxm,cxm,3,1,SNEXT,snxnew,safe)
        snxnew=snxnew+.004
        snxtot=snxtot+snxnew
        if(snxtot.lt.SNEXT)then
          xxm(1)=xxm(1)+snxnew*xxm(4)
          xxm(2)=xxm(2)+snxnew*xxm(5)
          xxm(3)=xxm(3)+snxnew*xxm(6)
          call gfcoor(xxm,iaxis,cxnew)
          xevdiv=((cxnew-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xevdiv
          dr= xxm(1)*xxm(4)+xxm(2)*xxm(5)
*          if(dr.eq.0.)print *,'dr.eq.0.'
          if(dr.ge.0.)then
              inc=1
          else
              inc=-1
          endif
          if((xevdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
              ivdiv=1
          elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
          endif
          nnn=nnn+1
          goto 111
        else
          if(inc.gt.0)then
           cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
           safety=min(safety,(cmax-cxold))
          else
           cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
           safety=min(safety,(cxold-cmin))
          endif
          goto 400
        endif
      endif
          if(nnn.ne.0.and.SNEXT.eq.sneold)goto 199
               x0(1) = xc(1) + SNEXT*xc(4)
               x0(2) = xc(2) + SNEXT*xc(5)
               x0(3) = xc(3) + SNEXT*xc(6)
               x0(4) = xc(4)
               x0(5) = xc(5)
               x0(6) = xc(6)
          if(iaxis.le.3)then
            cx=x0(iaxis)
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          else
            call gfcoor(x0,iaxis,cx)
            if(iaxis.eq.6)then
             if((cx-clmoth).lt.-1.)then
              cx=cx+360.
             elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
             endif
             if(cx.gt.chmoth)then
              cx=chmoth
             elseif(cx.lt.clmoth)then
              cx=clmoth
             endif
            endif
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          endif
 199      if(ievdiv.ge.idmi.and.ievdiv.le.idma)then
            if(inc.gt.0)then
             cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
             if(iaxis.ne.6)then
              safety=min(safety,(cmax-cxold))
             else
              safefi=min(90.,(cmax-cxold))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            else
             cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
             if(iaxis.ne.6)then
              safety=min(safety,(cxold-cmin))
             else
              safefi=min(90.,(cxold-cmin))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            endif
            goto 400
          endif
          if(iaxis.eq.6.or.iaxis.le.3)then
           if(ievdiv.lt.idmi.and.inc.gt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idmi=',idmi,' inc.gt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safety=min(safety,abs(cmax-cxold))
             elseif(iaxis.eq.6)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safefi=min(90.,(cmax-cxold))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           elseif(ievdiv.gt.idma.and.inc.lt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idma=',idma,' inc.lt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safety=min(safety,abs(cxold-cmin))
             elseif(iaxis.eq.6)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safefi=min(90.,(cxold-cmin))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           endif
          endif
          nnn=nnn+1
          sneold=SNEXT
          if(inc.gt.0)then
            if(iaxis.eq.6)then
             if(idma.eq.ndivto.and.(chmoth-clmoth).eq.360.)then
               ivdiv=1
             else
               ivdiv=idma+1
             endif
            else
             ivdiv=idma+1
            endif
          else
            if(iaxis.eq.6)then
             if(idmi.eq.1.and.(chmoth-clmoth).eq.360.)then
               ivdiv=ndivto
             else
               ivdiv=idmi-1
             endif
            else
             ivdiv=idmi-1
            endif
          endif
          goto 111
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         if(raytra.eq.1.)ingoto=-1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      if(nin.eq.1.and.ignext.ne.0)then
        if(q(jin+8).eq.0.)iact=1
      endif
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
 400  if(iswit(9).eq.123456789.and.Q(JVO+3).gt.1.)then
        print *,'n. of checked objects = ',mmm
      endif
      if(myinfr.gt.0)then
        jin=lq(jvo-myinfr)
        iq(jin)=ibclr(iq(jin),4)
        myinfr=0
      endif
      if(gonly(nlevel).eq.0..or.nvmany.ne.0) THEN
         if(safety.lt.tsafet)tsafet=safety
         if(snext.lt.tsnext)then
          mycoun=mycoun+1
          tsnext=snext
          tignex=ignext
          tingot=ingoto
          call gscvol
          if(ingoto.gt.0)then
            iq(jgpar2+nlevel+1)=iq(jgpar+nlevel+1)
            lq(jgpar2-nlevel-1)=lq(jgpar-nlevel-1)
          endif
         endif
         if(gonly(nlevel).eq.0.)then
 404       continue
           if(gonly(nlevel-1).eq.0..or.newfl.eq.0)then
             if(gonly(nlevel-1).ne.0.)newfl=1
             nlevel=nlevel-1
             jvo=lq(jvolum-lvolum(nlevel))
             nin=q(jvo+3)
             if(nin.lt.0)goto 404
             myinfr=lindex(nlevel+1)
             jin=lq(jvo-myinfr)
             iq(jin)=ibset(iq(jin),4)
             ignext=0
             goto 401
           endif
         endif
 403   continue
       if(manyfl.lt.nvmany)then
         manyfl=manyfl+1
         if(manyfl.eq.nfmany)goto 403
         levtmp=manyle(manyfl)
         do 402 i=1,levtmp
          namtmp(i)=manyna(manyfl,i)
          numtmp(i)=manynu(manyfl,i)
 402     continue
         call glvolu(levtmp,namtmp,numtmp,ier)
         if(ier.ne.0)print *,'Fatal error in GLVOLU'
         ignext=0
         goto 401
       endif
       if(tsafet.le.safety)safety=tsafet
       if(tsnext.le.snext)then
         snext=tsnext
         ignext=tignex
         ingoto=tingot
         call gfcvol
         nlevin=nlevel
         if(ingoto.gt.0)then
          iq(jgpar+nlevel+1)=iq(jgpar2+nlevel+1)
          lq(jgpar-nlevel-1)=lq(jgpar2-nlevel-1)
         endif
       endif
      endif
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNEXT.EQ.BIG1) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
+DECK,GTNINO.
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTNINO
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Tracking routine for "GEANTINO" type tracks              *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *       Author    R.Brun, F.Bruyant                              *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT, IF=DEBUG.
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
C.
C.    ------------------------------------------------------------------
C.
      STEP = STEMAX
      IPROC = 103
      CALL GTNEXT
      IF (IGNEXT.NE.0) THEN
         STEP = SNEXT + PREC
         IPROC=0
         INWVOL= 2
         NMEC =  1
         LMEC(1)=1
*
* *** Linear transport
*
         DO 10 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
*                 IF(NMEC.GT.0) THEN
*                    IF(LMEC(NMEC).EQ.32) NMEC=NMEC-1
*                 ENDIF
*                 NMEC=NMEC+1
*                 LMEC(NMEC)=32
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTNINO: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
               ENDIF
            ENDIF
            VECT(I) = VECTMP
   10    CONTINUE
      ELSE
         DO 20 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   20    CONTINUE
      ENDIF
      SLENG = SLENG +STEP
      IF(IPROC.NE.0) THEN
         NMEC=NMEC+1
         LMEC(NMEC)=IPROC
      ENDIF
      END
+DECK, GTRACK.
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTRACK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Controls tracking of current particle,                   *
C.    *        up to end of track for sequential tracking mode, or     *
C.    *        through current volume for parallel tracking mode.      *
C.    *                                                                *
C.    *    ==>Called by : GUTRAK                                       *
C.    *       Authors   : R.Brun, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCPHYS.
+CDE, GCPARM.
+CDE, GCSETS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCNUM.
+SEQ,GCJUMP, IF=USRJMP
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      DIMENSION CUTS(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      SAVE PRECOR
+SELF,IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF,IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
C.
C.    ------------------------------------------------------------------
      ISTOP = 0
      EPSCUR = EPSMAC
      NSTOUT = 0
      INWOLD = 0
      LSAMVL = .FALSE.
*
* *** Check validity of tracking medium and material parameters
*
   10 IF (NUMED.NE.NUMOLD) THEN
         NUMOLD = NUMED
         IUPD   = 0
         JTM    = LQ(JTMED- NUMED)
         DO 20 I = 1,5
            NATMED(I) = IQ(JTM+I)
   20    CONTINUE
         NMAT     = Q(JTM + 6)
         ISVOL    = Q(JTM + 7)
         IFIELD   = Q(JTM + 8)
         FIELDM   = Q(JTM + 9)
         TMAXFD   = Q(JTM + 10)
         STEMAX   = Q(JTM + 11)
         DEEMAX   = Q(JTM + 12)
         EPSIL    = Q(JTM + 13)
         STMIN    = Q(JTM + 14)
         PRECOR   = MIN(0.1*EPSIL, 0.0010)
         IF (LQ(JTM).EQ.0) THEN
            IF (ISTPAR.NE.0) THEN
               DO 30 I = 1,10
                  CUTS(I) = Q(JTMED+I)
   30          CONTINUE
               DO 40 I = 1,13
                  MECA(1,I) = Q(JTMED+10+I)
   40          CONTINUE
               ILABS = Q(JTMED+10+21)
               ISYNC = Q(JTMED+10+22)
               ISTRA = Q(JTMED+10+23)
               ISTPAR = 0
            ENDIF
         ELSE
            JTMN = LQ(JTM)
            DO 50 I = 1,10
               CUTS(I) = Q(JTMN+I)
   50       CONTINUE
            DO 60 I = 1,13
               MECA(1,I) = Q(JTMN+10+I)
   60       CONTINUE
            ILABS = Q(JTMN+10+21)
            ISYNC = Q(JTMN+10+22)
            ISTRA = Q(JTMN+10+23)
            ISTPAR = 1
         ENDIF
*
         JMA   = LQ(JMATE-NMAT)
         JPROB = LQ(JMA-4)
         JMIXT = LQ(JMA-5)
         DO 70 I = 1,5
            NAMATE(I) = IQ(JMA+I)
   70    CONTINUE
         A    = Q(JMA +6)
         Z    = Q(JMA +7)
         DENS = Q(JMA +8)
         RADL = Q(JMA +9)
         ABSL = Q(JMA +10)
         IF(IQ(JTM-2).GE.3.AND.LQ(JTM-3).NE.0.AND.ITCKOV.NE.0.AND.
     +      LQ(LQ(JTM-3)-3).NE.0.AND.Z.GE.1.) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag.
*
            IMCKOV = 1
         ELSE
            IMCKOV = 0
         ENDIF
*
*
*  **   Update precomputed quantities
*
         IMULL = IMULS
         IF (ILOSS.LE.0) THEN
            DEEMAX = 0.
            ILOSL = 0
         ELSEIF (DEEMAX.GT.0.) THEN
            ILOSL = ILOSS
         ELSE
            ILOSL = 0
         ENDIF
      ENDIF
*
      IF(LSAMVL) THEN
*
*       If now the particle is entering in the same volume where
*       it was exiting from last step, and if it has done this for
*       more than 5 times, we decrease the precision of tracking
         NSTOUT=NSTOUT+1
         IF(MOD(NSTOUT,5).EQ.0) THEN
            EPSCUR=NSTOUT*EPSMAC
*            WRITE(CHMAIL,10000)ITRA,ISTAK,NTMULT,NAPART
*10000          FORMAT(' *** GTRACK *** Boundary loop: track ',
*     +         I4,' stack ',I4,' NTMULT ',I5,1X,5A4)
*            CALL GMAIL(1,0)
*            WRITE (CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
*            CALL GMAIL(0,0)
*            WRITE(CHMAIL,10100) EPSCUR
*10100          FORMAT('                Precision now set to ',G10.3)
*            CALL GMAIL(0,1)
         ENDIF
      ELSE
         NSTOUT = 0
         EPSCUR = EPSMAC
      ENDIF
*
      INWVOL = 1
*
* *** Compute SET and DET number if volume is sensitive
*
      IF (JSET.GT.0) THEN
         IF(ISVOL.GT.0) THEN
            CALL GFINDS
         ELSE
            IHSET = 0
            IHDET = 0
            ISET = 0
            IDET = 0
            IDTYPE = 0
            NVNAME = 0
         ENDIF
      ENDIF
*
*    Clear step dependent variables
*
   80 NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NGPHOT = 0.
      IGNEXT = 0
      INWOLD = INWVOL
      PREC   = MAX(PRECOR,MAX(ABS(VECT(1)),ABS(VECT(2)),
     +                        ABS(VECT(3)),SLENG)*EPSCUR)
*
*     Give control to user at entrance of volume (INWVOL=1)
*
      IF (INWVOL.EQ.1) THEN
+SELF, IF=-USRJMP
         CALL GUSTEP
+SELF, IF=USRJMP
         CALL JUMPT0(JUSTEP)
+SELF
         IF (ISTOP.NE.0) GO TO 999
         INWVOL = 0
      ENDIF
*
* *** Propagate particle up to next volume boundary or end of track
*
      INGOTO = 0
      NLEVIN = NLEVEL
      IF (IPARAM.NE.0) THEN
         IF (GEKIN.LE.PACUTS(ITRTYP)) THEN
            NMEC = NMEC+1
            LMEC(NMEC) = 26
            ISTOP = 2
+SELF, IF=-USRJMP
            CALL GUPARA
+SELF, IF=USRJMP
            CALL JUMPT0(JUPARA)
+SELF
            GO TO 90
         ENDIF
      ENDIF
      IF      (ITRTYP.EQ.1) THEN
         CALL GTGAMA
      ELSE IF (ITRTYP.EQ.2) THEN
         CALL GTELEC
      ELSE IF (ITRTYP.EQ.3) THEN
         CALL GTNEUT
      ELSE IF (ITRTYP.EQ.4) THEN
         CALL GTHADR
      ELSE IF (ITRTYP.EQ.5) THEN
         CALL GTMUON
      ELSE IF (ITRTYP.EQ.6) THEN
         CALL GTNINO
      ELSE IF (ITRTYP.EQ.7) THEN
         CALL GTCKOV
      ELSE IF (ITRTYP.EQ.8) THEN
         CALL GTHION
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(10+ITRTYP)
      STLOSS=STEP
*
*     Check for possible endless loop
*
   90 NSTEP = NSTEP +1
      IF (NSTEP.GT.MAXNST) THEN
         IF (ISTOP.EQ.0) THEN
            ISTOP = 99
            NMEC  = NMEC +1
            LMEC(NMEC) = 30
            WRITE(CHMAIL,10200) MAXNST
            CALL GMAIL(1,0)
            WRITE(CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10300)ITRA,ISTAK,NTMULT,(NAPART(I),I=1,5),
     +      TOFG*1.E9
            CALL GMAIL(0,1)
10200       FORMAT(' *** GTRACK *** More than ',I6,
     +             ' steps, tracking abandoned!')
10250       FORMAT('                IEVENT=',I7,' IDEVT=',I7,
     +             ' Random Seeds = ',I10,2X,I10)
10300       FORMAT('                Track ',I5,' stack ',I5,' NTMULT ',
     +             I5,1X,5A4,1X,'Time of flight ',F10.3,' ns')
         ENDIF
      ENDIF
*
* *** Give control to user at end of each tracking step
*
      SAFETY = SAFETY -STEP
+SELF, IF=-USRJMP
      CALL GUSTEP
+SELF, IF=USRJMP
      CALL JUMPT0(JUSTEP)
+SELF
*
      IF (ISTOP.NE.0) GO TO 999
*
*      Renormalize direction cosines
*
      PMOM = SQRT(VECT(4)**2+VECT(5)**2+VECT(6)**2)
      IF(PMOM.GT.0.) THEN
         CMOD = 1./PMOM
         VECT(4) = VECT(4)*CMOD
         VECT(5) = VECT(5)*CMOD
         VECT(6) = VECT(6)*CMOD
      ENDIF
*
      IF (INWVOL.EQ.0) GO TO 80
*
      IF (NJTMAX.GT.0) THEN
         CALL GSTRAC
         IF (NLEVIN.EQ.0) GO TO 100
         GO TO 999
      ELSE
         IF (NLEVIN.GE.NLEVEL) THEN
            INFROM = 0
         ELSE
            IF (NLEVIN.EQ.0) GO TO 100
            INFROM = LINDEX(NLEVIN+1)
         ENDIF
         IF (NLEVIN.NE.NLEVEL) INGOTO = 0
         NLEVEL = NLEVIN
*
         CALL GTMEDI (VECT, NUMED)
         IF (NUMED.NE.0) THEN
            SAFETY = 0.
            GO TO 10
         ENDIF
      ENDIF
*
*     Track outside setup, give control to user (INWVOL=3)
*
  100 INWVOL = 3
      ISTOP  = 1
      ISET   = 0
      IDET   = 0
      NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NLCUR  = NLEVEL
      NLEVEL = 1
+SELF, IF=-USRJMP
      CALL GUSTEP
+SELF, IF=USRJMP
      CALL JUMPT0(JUSTEP)
+SELF
      NLEVEL = NLCUR
*                                                             END GTRACK
  999 CONTINUE
      END
+DECK,GTREVE.
*CMZ :  3.21/03 07/10/94  18.07.13  by  S.Giani
*-- Author :
      SUBROUTINE GTREVE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GTREVE                                                *
C.    *                                                                *
C.    *   Controls tracking of all particles belonging to the current  *
C.    *    event.                                                      *
C.    *                                                                *
C.    *   Called by : GUTREV, called by GTRIG                          *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCNUM.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+SEQ,GCJUMP, IF=USRJMP
+SEQ, GCVDMA.
      REAL UBUF(2)
      EQUIVALENCE (UBUF(1),WS(1))
      LOGICAL   BTEST
C.
C.    ------------------------------------------------------------------
      NTMSTO = 0
      NSTMAX = 0
      NALIVE = 0
*
      NV = NVERTX
      DO 290 IV = 1,NV
*
* ***   For each vertex in turn ..
*
         JV = LQ(JVERTX-IV)
         NT = Q(JV+7)
         IF (NT.LE.0) GO TO 290
         TOFG   = Q(JV+4)
         SAFETY = 0.
         IF (NJTMAX.GT.0) THEN
            CALL GMEDIA (Q(JV+1), NUMED)
            IF (NUMED.EQ.0) THEN
               WRITE (CHMAIL, 1001) (Q(JV+I), I=1,3)
               CALL GMAIL (0, 0)
               GO TO 290
            ENDIF
            CALL GLSKLT
         ENDIF
*
*  **   Loop over tracks attached to current vertex
*
         DO 190 IT = 1,NT
            JV   = LQ(JVERTX-IV)
            ITRA = Q(JV+7+IT)
            IF (BTEST(IQ(LQ(JKINE-ITRA)),0)) GO TO 190
            CALL GFKINE (ITRA, VERT, PVERT, IPART, IVERT, UBUF, NWBUF)
            IF (IVERT.NE.IV) THEN
               WRITE (CHMAIL, 1002) IV, IVERT
               CALL GMAIL (0, 0)
               GO TO 999
            ENDIF
*
*   *      Store current track parameters in stack JSTAK
*
            CALL GSSTAK (2)
  190    CONTINUE
*
*  **   Start tracking phase
*
  210    IF (NALIVE.NE.0) THEN
            NALIVE = NALIVE -1
*
*   *      Pick-up next track in stack JSTAK, if any
*
            IF (IQ(JSTAK+1).GT.0) THEN
*
*   *         Initialize tracking parameters
*
               CALL GLTRAC
               IF (NUMED.EQ.0) GO TO 210
            ELSE
*
*   *         otherwise, select next track segment from stack JTRACK
*
               CALL GFTRAC
*
            ENDIF
*
*   *       Resume tracking
*
            IF(RAYTRA.EQ.1.)THEN
+SELF,IF=HIGZ
              CALL GDRACK
+SELF
            ELSE
+SELF, IF=-USRJMP
              CALL GUTRAK
+SELF, IF=USRJMP
              CALL JUMPT0(JUTRAK)
+SELF
            ENDIF
            IF (IEOTRI.NE.0) GO TO 999
            GO TO 210
         ENDIF
*
  290 CONTINUE
*
 1001 FORMAT (' GTREVE : Vertex outside setup, XYZ=',3G12.4)
 1002 FORMAT (' GTREVE : Abnormal track/vertex connection',2I8)
*                                                             END GTREVE
  999 CONTINUE
      END
 
+DECK,GTMED2,IF=OLD.
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTMEDI (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Note : For INWVOL = 2, INFROM set to a positive number is    *
C.    *      interpreted by GTMEDI as the number IN of the content     *
C.    *      just left by the current track within the mother volume   *
C.    *      where the point X is assumed to be.                       *
C.    *                                                                *
C.    *   Note : INFROM is set correctly by this routine but it is     *
C.    *      used on entrance only in the case GSNEXT has been called  *
C.    *      by the user. In other words the value of INFROM received  *
C.    *      on entrance is not considered necessarily valid. This     *
C.    *      assumption has been made for safety. A wrong value of     *
C.    *      INFROM can cause wrong tracking.                          *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
C.
      DIMENSION  X(*)
      REAL       XC(3), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
* *** Check if point is in current volume
*
      INFR = 0
      INGT = 0
      JVIN = 0
*
* *** LSAMVL is a logical variable that indicates whether we are still
* *** in the current volume or not. It is used in GTRACK to detect
* *** precision problems.
      LSAMVL = .TRUE.
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
 
      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            LSAMVL = .FALSE.
            NL1 = NLEVEL +1
            LVOLUM(NL1) = IVOT
            NAMES(NL1)  = IQ(JVOLUM+IVOT)
            NUMBER(NL1) = Q(JIN+3)
            LINDEX(NL1) = INGOTO
            LINMX(NL1)  = Q(JVO+3)
            GONLY(NL1)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NL1) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NL1) = NL1
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NL1), GRMAT(1,NL1))
            NLEVEL = NL1
            XC(1) = XT(1)
            XC(2) = XT(2)
            XC(3) = XT(3)
            JVO = JVOT
            INFROM = 0
            GO TO 190
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         LSAMVL = .FALSE.
         INGOTO = 0
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
               INFROM=LINDEX(NLEVEL+1)
            ELSE
               INFROM=0
            ENDIF
            INFR = INFROM
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ELSE
*
*   *      Point in current volume but not in INGOTO. We block the
*   *      corresponding volume
*
         IF (INGOTO.GT.0) THEN
            INGT = INGOTO
            JIN = LQ(JVO-INGOTO)
            IQ(JIN) = IBSET(IQ(JIN),4)
         ENDIF
      ENDIF
*
*   *      Found a volume up the tree which contains our point. We block
*   *      the branch we came up from.
*
      IF(INFR.GT.0) THEN
         JIN=LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
*
*  **   Point is in current volume
*
  190 INGOTO = 0
      NLMIN = NLEVEL
      IF (INWVOL.NE.2) INFROM = 0
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            INFROM = 0
            INFR   = 0
            INGT   = 0
            LSAMVL = .FALSE.
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               CX   = XC(IAX)
            ELSE
               CALL GFCOOR (XC, IAX, CX)
            ENDIF
            IDIV = ABS(LOCATF (Q(JSB+3), NSB, CX))
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=USRJMP
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF
            ELSEIF (INFROM.GT.0) THEN
               JNUP = LQ(LQ(JVO-INFROM)-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF (GONLY(NLEVEL).NE.0.) NLMANY = 0
                  INFROM = 0
                  INGT   = 0
                  INFR   = 0
                  LSAMVL = .FALSE.
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INFR = 0
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INGT = 0
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFROM = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         INFR = INFROM
         JIN = LQ(JVO-INFROM)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GTMEDI
  999 IF(JGSTAT.NE.0) CALL GFSTAT(4)
      END
+DECK,GINVO2,IF=OLD.
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GINVOL (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
C.
      DIMENSION  X(*)
      REAL       XC(3), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               IDIV = LOCATF (Q(JSB+3), NSB, XC(IAX))
            ELSE
               CALL GFCOOR (XC, IAX, CX)
               IDIV = LOCATF (Q(JSB+3), NSB, CX)
            ENDIF
            IF (IDIV.LT.0) IDIV = -IDIV
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=USRJMP
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF
            ELSEIF (INFR.GT.0) THEN
               JNUP = LQ(LQ(JVO-INFR)-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480
 
  450 ISAME = 0
 
  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+DECK,GTNEX2,IF=OLD.
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTNEXT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+SEQ, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SEQ,GCJUMP, IF=USRJMP
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      REAL      X0(3), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      ISEARC = Q(JVO+1)
      IF (ISEARC.GE.-1) GO TO 120
*
*  ** Contents are ordered by (dynamic) GSORD, select neighbours
*
      JSB = LQ(LQ(JVO-NIN-1))
      IAX = Q(JSB+1)
      NSB = Q(JSB+2)
      IF (IAX.LE.3) THEN
         CX  = XC(IAX)
         INC = SIGN(1., XC(IAX+3))
      ELSE
         CALL GFCOOR (XC, IAX, CX)
         IF (IAX.LE.5) THEN
            DR = XC(1)*XC(4) +XC(2)*XC(5)
            IF (IAX.EQ.5) DR = DR +XC(3)*XC(6)
            INC = SIGN(1., DR)
         ELSE IF (IAX.EQ.6) THEN
            INC = SIGN(1., XC(1)*XC(5)-XC(2)*XC(4))
         ELSE
            INC = SIGN(1., XC(3)*(XC(1)*XC(4)+XC(2)*XC(5))
     +                    -XC(6)*(XC(1)*XC(1)+XC(2)*XC(2)))
         ENDIF
      ENDIF
      IDIV = LOCATF (Q(JSB+3), NSB, CX)
      IF (IDIV.LT.0) IDIV = -IDIV
      IF (IAX.NE.6) THEN
         IF (IDIV.EQ.0) THEN
            IF (INC.LT.0.AND.IAX.LE.3) THEN
               SAFETY = Q(JSB+3) -CX
               GO TO 300
            ENDIF
            IDIV = 1
         ELSE IF (IDIV.EQ.NSB) THEN
            IF (INC.GT.0.AND.IAX.NE.7) THEN
               SAFETY = CX -Q(JSB+2+NSB)
               GO TO 300
            ENDIF
            IDIV = NSB -1
         ELSE
            IF (IAX.NE.7) THEN
               IF (INC.GT.0) THEN
                  SAFETY = CX -Q(JSB+2+IDIV)
               ELSE
                  SAFETY = Q(JSB+3+IDIV) -CX
               ENDIF
            ELSE
               SAFETY = 0.
            ENDIF
         ENDIF
      ELSE IF (IAX.EQ.6) THEN
         IF (IDIV.EQ.0) IDIV = NSB
         SAFETY = 0.
      ENDIF
*
      IDIVL = 0
      IDIVB = 0
      JSC0  = LQ(JVO-NIN-2)
  110 NCONT = IQ(JSC0+IDIV)
*
*  ** Loop over (selected) contents
*
      IF (NCONT.EQ.0) THEN
         IF (IDIV.EQ.IDIVL) GO TO 400
         IDIV = IDIV +INC
         IF (IAX.NE.6) GOTO 110
*      (following statement for IAX=6, when division NSB is empty)
         IF (IDIV.GT.NSB) IDIV = 1
         IF (IDIV.EQ.0) IDIV = NSB
         GO TO 110
      ELSE
         ICONT = 1
         JSCV = LQ(JSC0-IDIV)
         GO TO 140
      ENDIF
*
  120 JNEAR = LQ(JVO-NIN-1)
      IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
         CALL GUNEAR (ISEARC, 2, XC, JNEAR)
+SELF, IF=USRJMP
         CALL JUMPT4(JUNEAR, ISEARC, 2, XC, JNEAR)
+SELF
         IF (IQ(JNEAR+1).EQ.0) GO TO 300
      ELSE
         IF (INFROM.GT.0) THEN
            JIN = LQ(JVO-INFROM)
            IF (LQ(JIN-1).NE.0) THEN
               JNE = LQ(JIN-1)
               IF (IQ(JNE+1).GT.1.OR.IQ(JNE+2).NE.0) JNEAR = JNE
            ENDIF
         ENDIF
      ENDIF
      JNEAR = JNEAR +1
      NNEAR = IQ(JNEAR)
      IF (IQ(JNEAR+1).NE.0) THEN
         INEAR = 1
      ELSE
         INEAR = 2
      ENDIF
*
  130 IN = IQ(JNEAR+INEAR)
      GO TO 150
*
  140 IN = IQ(JSCV+ICONT)
*
  150 IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 180
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
         IF (ISEARC.EQ.-2) THEN
            IF (MOD(IQ(JSC0),2).NE.0) THEN
               IDIVB = IDIV
            ELSE
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVB = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVB = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVB.LT.0) IDIVB = -IDIVB
               IF (IDIVB.EQ.0) THEN
                  IF (IAX.EQ.6) THEN
                     IDIVB = NSB
                  ELSE
                     IDIVB = 1
                  ENDIF
               ELSE IF (IDIVB.EQ.NSB) THEN
                  IF (IAX.NE.6) IDIVB = NSB - 1
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (ISEARC.EQ.-2) THEN
         IF (ICONT.EQ.NCONT) THEN
            IF (IDIVL.EQ.0) THEN
               IF (IDIVB.NE.0) THEN
                  IF (IDIV.EQ.IDIVB) GO TO 300
                  IF (.NOT.BTEST(IQ(JVO),2)) THEN
                     IDIVL = IDIVB
                     GO TO 193
                  ENDIF
               ENDIF
*
*   *         Compute distance to boundary of current volume
*
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
*
*   *         Check wether other pseudo-divisions have to be scanned
*
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVL = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVL = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVL.LT.0) IDIVL = -IDIVL
               IF (IDIVL.EQ.0) THEN
                  IF(IAX.EQ.6)THEN
                     IDIVL=NSB
                  ELSE
                     IDIVL=1
                  ENDIF
               ELSEIF (IDIVL.EQ.NSB)THEN
                  IF(IAX.NE.6)IDIVL=NSB-1
               ENDIF
            ELSE
               IF (IDIV.EQ.IDIVB)   GO TO 400
            ENDIF
  193       IF ((IDIV-IDIVL)*INC.GE.0) GO TO 400
            IDIV = IDIV +INC
            GO TO 110
         ELSE
            ICONT = ICONT +1
            GO TO 140
         ENDIF
      ELSE
         IF (INEAR.EQ.NNEAR) GO TO 300
         INEAR = INEAR +1
         GO TO 130
      ENDIF
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
  400 IF (GONLY(NLEVEL).EQ.0.) THEN
*
* ***   Case of a 'NOT ONLY' volume -> step search
*
         SAFETY = 0.
         EPSI2  = 0.5*EPSIL
         ST     = SNEXT -EPSI2
         IF (ST.LE.0) GO TO 900
         EPSI3  = 10.*EPSIL
         IF (ST.LE.EPSI3) THEN
            NN = 1
         ELSE
            NN = ST/EPSI3 +1
            ST = ST/NN
         ENDIF
*
         NBIN = 0
         SN   = 0.
  420    SN   = SN +ST
         XT(1) = VECT(1) + SN*VECT(4)
         XT(2) = VECT(2) + SN*VECT(5)
         XT(3) = VECT(3) + SN*VECT(6)
*
         INGOTO = 0
         CALL GINVOL (XT, ISAME)
         IF (ISAME.EQ.0) THEN
            IF (ST.LE.EPSI2) GO TO 490
            SN   = SN -ST
            ST   = 0.5*ST
            NBIN = 1
            GO TO 420
         ENDIF
*
         IF (NBIN.NE.0) THEN
            IF (ST.LT.EPSI2) THEN
               ST = EPSI2
            ELSE
               ST = 0.5*ST
            ENDIF
            GO TO 420
         ENDIF
         NN = NN -1
         IF (NN.GT.0) GO TO 420
         GO TO 495
*
  490    IF (SN.LT.SNEXT) THEN
            INGOTO = -1
            SNEXT  = SN
            IGNEXT = 1
            GO TO 900
         ENDIF
*
  495    NLEVIN = NLEVEL
      ENDIF
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNEXT.LT.0.) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
+PATCH,GSTRAG.
+DECK,GASHO,IF=ASHO.
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GASHO(P,XXMASS,GSTEP,DE)
+SEQ,GCBANK
+SEQ,GCJLOC
+SEQ,GCCUTS.
+SEQ,GCMATE.
+SEQ,GCASHO.
C-----------------------------------------------------------------------
C      ASHO model for energy loss straggling
C      The main subprograms are:
C      - MIXMGO - prepares the parameters of a mixture
C          or compound used (called from GIASHO);
C      - GOSCMG - prepares the parameters of the oscillators;
C      - GDIFMG - calculates the differential spectrum of the
C          energy loss;
C      The main initial data bank is in COMMON block GCASHO contai-
C      ning the parameters of a number of elements.
C-----------------------------------------------------------------------
C      Update history: 16-8-93
C
C-----------------------------------------------------------------------
C      The main initial common block and its components.
C      NELM - number of basic elements;
C      ZELM - atomic numbers of the elements;
C      AELM - atomic weights of the elements;
C      DELM - densities of the elements (g/cm3);
C      E0ELM - ionization potentials of the elements (keV);
C      NSELM - numbers of the electron shells in the atoms;
C      ZSELM - numbers of electrons in each of the shells;
C      ESELM - binding energies of the shell electrons (keV).
C       This information may be included in JMATE by GSMATE or GMATE.
C      *)   The density values for gases are given at
C           0 C 1 atm. Those for solids are not precise and
C           should be substituted for particular
C           samples used.
C      **)  The current number of the elements used is equal to 16.
C      ***) To change the energy scale from keV to GeV, as it is
C           used in GEANT, it is needed to add 1.E-6 to E0ELM, ESELM,
C           PLASM, TRNSMA, 6. (in RESMGO), SL (in REAMGO), SL (in
C           SLDMGO) and extract 1.E-6 in DE (in DELMGO).
C-----------------------------------------------------------------------
C      GCASHO contains also the kinematical parame-
C      ters as well as some thermodynamical ones:
C      PLIN (P/mc), PLOG (log10(PLIN)), BE2 (velocity/c squared),
C      the path length STEP of the particle,
C      and the medium plasma energy
C      PLASM. TRNSMA is the maximum transferable energy (now
C      it is set to correspond to TCUT in GEANT !).
C      In GEANT the initial parameters are P, E, XMASS, STEP
C      and DENSIT.
C-----------------------------------------------------------------------
C      In addition, it contains the parameters of the oscillators:
C      - BOSC is the array of "ksi/I",
C      - AOSC is the array of "lnA",
C      - NOSC is the number of the oscillators,
C      - EOSC is the array of the oscillator energies,
C      - IOSC is the upper array in integers,
C      - ZOSC is the array of the oscillator weights,
C      - EMEAN is the mean energy loss.
C-----------------------------------------------------------------------
C      Finally, GCASHO contains the parameters of the energy loss
C      distribution:
C      - CMGO is the differential or integral distribution coeff.,
C      - NMGO is the number of bins,
C      - NMGOMA is the maximum of possible NMGO,
C      - EMGO is the energy corresponding to one bin,
C      - EMGOMI is the energy corresponding to 0th bin.
C-----------------------------------------------------------------------
      PARAMETER (DNMGOM=2000)
C-----------------------------------------------------------------------
      JASHO = LQ(JMA-20)
      NSMED = Q(JASHO+1)
      ZMED  = Q(JASHO+2)
      AMED  = Q(JASHO+3)
      ALFA  = Q(JASHO+4)
      E0MED = Q(JASHO+5)
      DO 10 KMED=1,NSMED
         ZSMED(KMED) = Q(JASHO+5+KMED)
         ESMED(KMED) = Q(JASHO+5+NSMED+KMED)
   10 CONTINUE
      PLASM = 0.028817*SQRT((ZMED/AMED)*DENS)
      STEP  = GSTEP
      NMGOMA = DNMGOM
C-----------------------------------------------------------------------
C      In GEANT the initial kinematic parameters : P, E, XMASS.
C      The following gets the kinematic parameters of the particle:
C      PLIN (P/mc), PLOG (lg(PLIN)), BE2 (velocity/c squared) and
C      its path length STEP.
C-----------------------------------------------------------------------
      PLIN = P/XXMASS
      PLOG = LOG10(PLIN)
      BE2 = PLIN**2/(1.+PLIN**2)
C-----------------------------------------------------------------------
C      Now we set TRNSMA to correspond to TCUT in GEANT.
C-----------------------------------------------------------------------
      TRNSMA = DCUTE*1E6
C-----------------------------------------------------------------------
C      Here is the calculation of the parameters of the oscillators
C-----------------------------------------------------------------------
      CALL GOSCMG
C-----------------------------------------------------------------------
C      Here is the calculation of the diffrential distribution
C-----------------------------------------------------------------------
      CALL GDIFMG(DE)
      DE = 1E-6*DE
C-----------------------------------------------------------------------
      END
+DECK,GDIFMG,IF=ASHO.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GDIFMG(DEL)
 
+SEQ,GCCUTS.
+SEQ,GCASHO.
C-----------------------------------------------------------------------
C      This program calculates the final distribution coef-
C      ficients until the integral S is more or equal to L2.
C      In case of S < L2 or miscalculations due to FORTRAN
C      limits DONE = FALSE.
C-----------------------------------------------------------------------
C      Update history: 10-08-93
C
C-----------------------------------------------------------------------
      REAL BN(50),BNA(50),L2
      INTEGER FLMAX
      PARAMETER (DL2=.1)
      DATA CORMAX/80./
C-----------------------------------------------------------------------
C      Initialization steps
C-----------------------------------------------------------------------
      XX = 0.
      Z = 1.
      DO 10 K=1,NOSC
         BN(K) = BOSC(K)*IOSC(K)
         BNA(K) = BN(K)*(AOSC(K) - 1.)
         XX = XX + AOSC(K)*BOSC(K)
   10 CONTINUE
C
      FLMAX = 0
      CORR = CORMAX - XX
      CMGO(1) = EXP(-CORMAX)
      CMGO(2) = CMGO(1)*BNA(1)
      Z = Z-(CMGO(1)+CMGO(2))*EXP(CORR)
C-----------------------------------------------------------------------
C      Calculation of the current Ci
C-----------------------------------------------------------------------
      CALL GRNDM(RNDM,1)
 
      L2 = DL2
      IF (RNDM.GE.L2) THEN
         L2 = RNDM
         FLMAX = 1
      ENDIF
      DO 40 NMGO=3,NMGOMA
         CMGO(NMGO) = CMGO(NMGO - 1)*BNA(1)
         DO 30 J = 1,NMGO - 2
            M = NMGO - 1 - J
            X = BOSC(1)/J
            DO 20 K=2,NOSC
               IF(MOD(J+1,IOSC(K)).EQ.0) THEN
                  L = (J+1)/IOSC(K)
                  IF(L.EQ.1) THEN
                     X = X + BNA(K)
                  ELSE
                     X = X + BN(K)/(L-1)
                  ENDIF
               ENDIF
   20       CONTINUE
            CMGO(NMGO) = CMGO(NMGO) + X*CMGO(M)
   30    CONTINUE
         CMGO(NMGO) = CMGO(NMGO)/(NMGO-1)
         Z = Z - CMGO(NMGO)*EXP(CORR)
         IF (Z.LE.L2) GOTO 50
   40 CONTINUE
 
   50 IF (FLMAX.EQ.1) THEN
         DEL = (NMGO-1)*EOSC(1)
      ELSE
         DEL = (NMGO-1)*EOSC(1)*L2/RNDM
      ENDIF
      IF (DEL.GE.DCUTE*1E6) DEL = DCUTE*1E6
 
      END
+DECK,GIASHO,IF=ASHO.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GIASHO
+SEQ,GCBANK
+SEQ,GCMATE
      DIMENSION E0ELM(100),NSELM(100)
      DIMENSION ZSELM(7,100),ESELM(7,100)
      DATA E0ELM /
     + 0.0204,0.0385,3*0.,0.0738,0.0978,0.1157,0.1248,0.1338,
     + 3*0.,0.1745,0.1791,2*0.,0.1816,12*0.,0.3018,0.2806,
     + 0.2906,2*0.,0.3408,12*0.,0.4823,4*0.,0.5088,46*0. /
      DATA NSELM /
     + 1,1,3*0,2,2,2,2,2,3*0,3,3,2*0,3,12*0,4,4,4,2*0,4,12*0,
     + 5,4*0,5,46*0/
      DATA ZSELM /
     + 1.,0.,0.,0.,0.,0.,0.,2.,0.,0.,0.,0.,0.,0.,21*0.,
     + 4.,2.,0.,0.,0.,0.,0.,5.,2.,0.,0.,0.,0.,0.,
     + 6.,2.,0.,0.,0.,0.,0.,7.,2.,0.,0.,0.,0.,0.,
     + 8.,2.,0.,0.,0.,0.,0.,21*0.,
     + 4.,8.,2.,0.,0.,0.,0.,5.,8.,2.,0.,0.,0.,0.,14*0.,
     + 8.,8.,2.,0.,0.,0.,0.,84*0.,
     + 3.,18.,8.,2.,0.,0.,0.,4.,18.,8.,2.,0.,0.,0.,
     + 5.,18.,8.,2.,0.,0.,0.,14*0.,
     + 8.,18.,8.,2.,0.,0.,0.,84*0.,
     + 5.,18.,16.,8.,2.,0.,0.,28*0.,
     + 8.,18.,18.,8.,2.,0.,0.,322*0./
*23456789_123456789_123456789_123456789_123456789_123456789_123456789_12
      DATA ESELM / 0.01360,0.,0.,0.,0.,0.,0.,0.02459,0.,0.,0.,0.,0.,0.,
     +21*0., 0.01367,0.288,0.,0.,0.,0.,0.,0.01662,0.4030,0.,0.,0.,0.,
     +0., 0.01742,0.5380,0.,0.,0.,0.,0.,0.02174,0.6940,0.,0.,0.,0.,0.,
     +0.02643,0.8701,0.,0.,0.,0.,0.,21*0., .01047,.1147,1.844,0.,0.,0.,
     +0.,.01247,.1467,2.148,0.,0.,0.,0., 14*0.,0.01845,0.2666,3.206,0.,
     +0.,0.,0.,84*0., 0.00899,0.04480,1.169,10.37,0.,0.,0., 0.01063,
     +0.06190,1.274,11.11,0.,0.,0., 0.01291,0.07953,1.384,11.87,0.,0.,
     +0.,14*0., 0.01676,0.1412,1.750,14.33,0.,0.,0.,84*0., 0.00720,
     +0.04012,0.5682,3.908,27.93,0.,0.,28*0., 0.01466,0.1006,0.8097,
     +5.030,34.570,0.,0.,322*0./
*
*-----------------------------------------------------------------------
*
      DIMENSION ZSMED(50),ESMED(50)
C-----------------------------------------------------------------------
C
      JMA   = LQ(JMATE-NMAT)
      JMIXT = LQ(JMA-5)
      NCOMP = ABS(Q(JMA+11))
      AMED = 0.
      ZMED = 0.
      E0CAL = 0.   !Sum of Z(i)*log(I(i))
      E0MED = 0.
      NSMED = 0
 
      DO 20 I = 1,NCOMP
         IF(NCOMP.GT.1) THEN
            IZ = Q(JMIXT+NCOMP+I)+0.5
            WEIGHT = Q(JMIXT+2*NCOMP+I)/Q(JMIXT+I)
            E0MED = E0MED + Q(JMIXT+NCOMP+I)*WEIGHT*LOG(E0ELM(IZ))
            ZMED = ZMED + Q(JMIXT+NCOMP+I)*WEIGHT
            AMED = AMED + Q(JMIXT+I)*WEIGHT
         ELSE
            IZ = Z+0.5
            E0MED = E0ELM(IZ)
            ZMED = Z
            AMED = A
         ENDIF
         DO 10 J = 1,NSELM(IZ)
            NSMED = NSMED + 1
            IF(NCOMP.GT.1) THEN
               ZSMED(NSMED) = ZSELM(J,IZ)*WEIGHT
            ELSE
               ZSMED(NSMED) = ZSELM(J,IZ)
            ENDIF
            ESMED(NSMED) = ESELM(J,IZ)
            E0CAL = E0CAL + ZSMED(NSMED)*LOG(ESELM(J,IZ))
   10    CONTINUE
   20 CONTINUE
      IF (NCOMP.GT.1) E0MED = EXP(E0MED/ZMED)
      E0CAL = EXP(E0CAL/ZMED)
      ALFA = E0MED/E0CAL
C-----------------------------------------------------------------------
C      The following sets ZSMED and ESMED in the order of increase
C      of ESMED.
C-----------------------------------------------------------------------
      DO 40 I = 1,NSMED - 1
         IMIN = I
         EMIN = ESMED(I)
         DO 30 J = I + 1,NSMED
            IF (EMIN.LE.ESMED(J)) GOTO 30
            EMIN = ESMED(J)
            IMIN = J
   30    CONTINUE
         IF (I.EQ.IMIN) GOTO 40
         X = ESMED(I)
         Y = ZSMED(I)
         ESMED(I) = ESMED(IMIN)
         ZSMED(I) = ZSMED(IMIN)
         ESMED(IMIN) = X
         ZSMED(IMIN) = Y
   40 CONTINUE
C-----------------------------------------------------------------------
C      The following combines the first smallest oscillators whose
C      integer relative potentials are equal to 1.
C-----------------------------------------------------------------------
      ZMIN = 0.
      EMIN = 0.
      IMIN = 1
      DO 50 I = 1,NSMED
         J = ESMED(I)/ESMED(1) + 0.5
         IF (J.GT.1) GOTO 60
         ZMIN = ZMIN + ZSMED(I)
         EMIN = EMIN + ZSMED(I)*LOG(ESMED(I))
         IMIN = I
   50 CONTINUE
   60 ESMED(1) = EXP(EMIN/ZMIN)
      ZSMED(1)        = ZMIN
      DO 70 I = IMIN + 1,NSMED
         ZSMED(I - IMIN + 1) = ZSMED(I)
         ESMED(I - IMIN + 1) = ESMED(I)
   70 CONTINUE
      NSMED = NSMED - IMIN + 1
      JASHO = LQ(JMA-20)
*
* *** Store parameters of ASHO in material bank 20
      Q(JASHO+1) = NSMED
      Q(JASHO+2) = ZMED
      Q(JASHO+3) = AMED
      Q(JASHO+4) = ALFA
      Q(JASHO+5) = E0MED
      DO 80 KMED=1,NSMED
         Q(JASHO+5+KMED) = ZSMED(KMED)
         Q(JASHO+5+NSMED+KMED) = ESMED(KMED)
   80 CONTINUE
      NLEFT = 2*NSMED - 100
      CALL MZPUSH(IXCONS,JASHO,0,NLEFT,'I')
      END
+DECK,GKOKRI.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GKOKRI(E,EMINEV,EMAXEV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Input energy in eV, Sandia tables in keV                   *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCONSP.
+SEQ,GCMATE.
+SEQ,GC10EV.
+SELF,IF=-SINGLE
      DOUBLE PRECISION EINV,ECUR,ONE,RES,ZERO,EBEG,EEND
      DOUBLE PRECISION ALPH,BETA,GAMM,E1,E2,GPSCIN,POLE
      DOUBLE PRECISION EMAX,EMIN,REST
+SELF
      PARAMETER (ONE=1,ZERO=0)
C.
C.    ------------------------------------------------------------------
C.
      REST   = ZERO
      EMAX   = EMAXEV*1E-3
      EMIN   = EMINEV*1E-3
      ECUR   = E*1E-3
      EINV   = ONE/ECUR
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      NZ     = Q(JPHXS+1)
      JWEIGH = JPHXS+1+2*NZ
      DO 30 JZ=1,NZ
         RES    = ZERO
         EBEG   = EMIN
         WEIGHT = Q(JWEIGH+JZ)
         JPHFN  = LQ(JPHXS-JZ)
         IPOINT = JPHFN+1
         IMAX   = Q(IPOINT)
         IPOINT = IPOINT-4
         DO 10 I = 1,IMAX
            IPOINT = IPOINT+5
            EEND   = Q(IPOINT)
            IF(EEND.GT.EMIN) THEN
               E1     = MAX(EBEG,EMIN)
               E2     = MIN(EEND,EMAX)
               J      = IPOINT+1
               IF(ECUR.LE.E2.AND.ECUR.GE.E1) THEN
*
* *** The pole of the integration is in this interval
                  EPS1 = (ECUR-EBEG)/ECUR
                  EPS2 = (EEND-ECUR)/EEND
                  IF(EPS1.LT.EPS2) THEN
*
* *** First the pole and then a simple integration
                     ALPH = ONE-EPS1
                     E1 = ECUR/ALPH
                     E2 = EEND
                  ELSE
*
* *** First a simple integration and then the pole
                     ALPH = ONE-EPS2
                     E1 = EBEG
                     E2 = ECUR*ALPH
                  ENDIF
                  BETA = -LOG(ALPH)
                  GAMM = ONE/ALPH
                  POLE = EINV*(Q(J)*BETA+EINV*( Q(J+1)*(GAMM-ALPH)+
     +            EINV*( Q(J+2)*(0.5*GAMM**2+BETA-0.5*ALPH**2)+EINV*
     +            Q(J+3)*(GAMM**3/3+GAMM-ALPH-ALPH**3/3))))
                  RES = RES - POLE
               ENDIF
*
* *** This is a normal integration
               RES = RES + GPSCIN(E1,E2,ECUR,Q(J))
            ENDIF
            EBEG = EEND
            IF(EBEG.GE.EMAX) GO TO 20
   10    CONTINUE
   20    REST = REST+WEIGHT*RES
   30 CONTINUE
C RES value is in cm**2/(g keV)
      GKOKRI = REST*1E-6*A/AVO
C Now in Megabarns/eV
C
      END
+DECK,GOSCIN.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GOSCIN(EIN1EV,EIN2EV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Input energy in eV, Sandia tables in keV                   *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCONSP.
+SEQ,GCMATE.
+SEQ,GC10EV.
+SELF,IF=-SINGLE
      DOUBLE PRECISION ONE,RES,ZERO,EIN1,EIN2,REST,EBEG,EEND
      DOUBLE PRECISION E1IN,E2IN,TWO,THREE,C1,C2,C3,C4
+SELF
      PARAMETER (ZERO=0,ONE=1,TWO=2,THREE=3)
C.
C.    ------------------------------------------------------------------
C.
      REST   = ZERO
      EIN1   = EIN1EV*1E-3
      EIN2   = EIN2EV*1E-3
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      NZ     = Q(JPHXS+1)
      JWEIGH = JPHXS+1+2*NZ
      DO 30 JZ=1,NZ
         RES    = ZERO
         EBEG   = TENEV
         WEIGHT = Q(JWEIGH+JZ)
         JPHFN  = LQ(JPHXS-JZ)
         IPOINT = JPHFN+1
         IMAX   = Q(IPOINT)
         IPOINT = IPOINT-4
         DO 10 I = 1,IMAX
            IPOINT = IPOINT+5
            EEND   = Q(IPOINT)
            IF(EIN2.GT.EBEG.AND.EIN1.LT.EEND) THEN
               E1IN  = ONE/MAX(EBEG,EIN1)
               E2IN  = ONE/MIN(EEND,EIN2)
               J     = IPOINT+1
               C1    = -Q(J  )
               C2    = -Q(J+1)
               C3    = -Q(J+2)/TWO
               C4    = -Q(J+3)/THREE
               RES   = RES
     +         +C1*LOG(E2IN)+E2IN*(C2+E2IN*(C3+E2IN*C4))
     +         -C1*LOG(E1IN)-E1IN*(C2+E1IN*(C3+E1IN*C4))
            ENDIF
            EBEG = EEND
   10    CONTINUE
   20    REST = REST+WEIGHT*RES
   30 CONTINUE
C RES value is in cm**2/(g keV)
      GOSCIN = REST*1E-3*A/AVO
C Now in Megabarns/eV
C
      END
+DECK,GOSCMG,IF=ASHO.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
C
      SUBROUTINE GOSCMG
 
+SEQ,GCMATE.
+SEQ,GCASHO
C-----------------------------------------------------------------------
C      This program calculates the parameters of the oscillators.
C      The input data are in the GCASHO. The lowest poten-
C      tials are convoluted to escape unreasonably high accuracy.
C-----------------------------------------------------------------------
C      Update history: 10-8-93
C
C-----------------------------------------------------------------------
      REAL KSI0
      PARAMETER (ENERR=0.02,TWOELM=2*511)
C-----------------------------------------------------------------------
C      Convolution of the first shells
C-----------------------------------------------------------------------
      C1 = 153.6*STEP*DENS/(BE2*AMED)
      C2 = 2.*LOG(PLIN)-BE2
      KSI0 = C1*ZMED
      X = 2.*LOG(E0MED/PLASM) + 1.
      CALL GSTCOR(X,E0MED,PLOG,DENS,D)
      A0 = LOG(TWOELM*TRNSMA/E0MED**2)+C2-D
      EMEAN = KSI0*A0
      DO 10 I = 1,NSMED
         IF (ESMED(I).GT.EMEAN*ENERR/ALFA) GOTO 20
   10 CONTINUE
   20 J = MAX(I - 1,1)
      S1 = 0.
      Z1 = 0.
      DO 30 I = 1,J
         S1 = S1 + LOG(ESMED(I))*ZSMED(I)
         Z1 = Z1 + ZSMED(I)
   30 CONTINUE
      S1  = EXP(S1/Z1)
      NOSC = NSMED - J + 1
      DO 40 I = 2,NOSC
         X = ESMED(I + J - 1)/S1
         IOSC(I) = X + 0.5
         EOSC(I) = S1*IOSC(I)*ALFA
         ZOSC(I) = ZSMED(I + J - 1)
   40 CONTINUE
      EOSC(1) = S1*ALFA
      IOSC(1) = 1
      ZOSC(1) = Z1
C-----------------------------------------------------------------------
C      Calculation of the oscillator parameters
C-----------------------------------------------------------------------
      C3 = C2 + 0.423
      DO 50 I = 1,NOSC
         X = C1*ZOSC(I)
         BOSC(I) = X/EOSC(I)
         X = 2.*LOG(EOSC(I)/PLASM)+1.
         CALL GSTCOR(X,EOSC(I),PLOG,DENS,D)
         AOSC(I) = LOG(TWOELM/EOSC(I)) +C3 -D
   50 CONTINUE
      END
+DECK,GPSCIN.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GPSCIN(EBEG,EEND,ECUR,COEFF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    ******************************************************************
C.
+SELF,IF=-SINGLE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+SELF
      REAL COEFF(4)
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      YBEG = EBEG/ECUR
      YEND = EEND/ECUR
      YBEGIN = ONE/YBEG
      YENDIN = ONE/YEND
*
      EINV = ONE/ECUR
      C1 = COEFF(1)*EINV
      C2 = COEFF(2)*EINV**2
      C3 = COEFF(3)*EINV**3
      C4 = COEFF(4)*EINV**4
*
      CONS1 = 0.5*(C1+C3)
      CONS2 = C2+C4
      CONS3 = 0.5*CONS2
      CONS4 = 0.5*C3
      CONS5 = C4/3
*
*     VALBEG = CONS1*F1(YBEG)+CONS3*F2(YBEG)+
*    +         YBEGIN*(CONS2+YBEGIN*(CONS4+YBEGIN*CONS5))
*     VALEND = CONS1*F1(YEND)+CONS3*F2(YEND)+
*    +         YENDIN*(CONS2+YENDIN*(CONS4+YENDIN*CONS5))
*
*     GPSCIN = VALEND-VALBEG
      GPSCIN =
     +      CONS1*LOG(ABS((YEND**2-1)*YBEG**2/((YBEG**2-1)*YEND**2)))+
     +      CONS2*(YENDIN-YBEGIN)+
     +      CONS3*LOG(ABS((1-YEND)*(1+YBEG)/((1-YBEG)*(1+YEND))))+
     +      CONS4*(YENDIN**2-YBEGIN**2)+CONS5*(YENDIN**3-YBEGIN**3)
*
      END
+DECK,GSTCOR.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GSTCOR(CC,POT,X,DENS,DELTA)
 
C.
C.    *****************************************************************
C.    *                                                               *
C.    *      Sternheimer correction as computed in GDRELX             *
C.    *                                                               *
C.    *    ==>Called by :                                             *
C.    *       Author    L.Urban    *********                          *
C.    *                                                               *
C.    *****************************************************************
*
*         condensed material ? ( dens .gt. 0.05 ? )
      IF(DENS.GT.0.05) THEN
*        IF(POT.LT.1.E-7) THEN   (POT was in GeV, now in keV)
         IF(POT.LT.0.1) THEN
            IF(CC.LT.3.681) THEN
               X0=0.2
            ELSE
               X0=0.326*CC-1.
            ENDIF
            X1=2.
         ELSE
            IF(CC.LT.5.215) THEN
               X0=0.2
            ELSE
               X0=0.326*CC-1.5
            ENDIF
            X1=3.
         ENDIF
*         gas ?   ( dens . le . 0.05 ? )
      ELSE
         IF(CC.LE.12.25) THEN
            IP=INT((CC-10.)/0.5)+1
            IF(IP.LT.0) IP=0
            IF(IP.GT.4) IP=4
            X0=1.6+0.1*FLOAT(IP)
            X1=4.
         ELSE
            IF(CC.LE.13.804) THEN
               X0=2.
               X1=5.
            ELSE
               X0=0.326*CC-2.5
               X1=5.
            ENDIF
         ENDIF
      ENDIF
*
      XA=CC/4.606
      XM=3.
      AA=4.606*(XA-X0)/(X1-X0)**XM
*
      DELTA=0.
      IF(X.GT.X0) THEN
         DELTA=4.606*X-CC
         IF(X.LT.X1) DELTA=DELTA+AA*(X1-X)**XM
      ENDIF
 
      END
+DECK,GSTDN.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GSTDN(LGE)
*   ********************************************************************
*   *                                                                  *
*   *    dN^2/dxdE function for the preparation of the table as in     *
*   *    Grishin,Ermilova,Kotelnikov,NIM A307(1991),273                *
*   *                                                                  *
*   *    ==> Called by : GSTTAB                                        *
*   *        Author    : P. Nevski                                     *
*   *                                                                  *
*   ********************************************************************
+SEQ,GCONSP.
+SEQ,GCSTRA.
*
      REAL LGE
      COMPLEX I,CEPS1,C1,C2
      SEXP(X) = EXP(MAX(X,-99.))
*
*     ------------------------------------------------------------------
      I=(0.,1.)
      E=EXP(LGE)
*
*    Epsilon-1
      E0     = MAX(LGE,EMIN)
      E2INV  = 1/E**2
      CEPS1  =  CMPLX(GSTINT(LGE,EMM,EPSR,NTAB)*E2INV,
     +       SEXP(GSTINT(E0,EMM,EPSI,NTAB)))
      C1     = 1/GAMMA2-CEPS1*BETA2
      C2     = C1/(1+CEPS1)*LOG(2*BETA2*MEEV/(E*C1))
      GSTDN  = S2/BETA2 * (-2*AIMAG(C2)/(WP2*PI) + (1-SEXP(GSTINT(E0
     +, EMM,FINT,NTAB)))*E2INV) * E
      END
+DECK,GSTINI.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GSTINI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Initialization of tables for energy loss straggling in       *
C.    *   thin gas layers                                              *
C.    *                                                                *
C.    *   ==> Called by : GPHYSI                                       *
C.    *       Authors   : K. Lassila-Perini, I. Gavrilenko, P. Nevski  *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCCUTS.
+SEQ,GCJLOC.
+SEQ,GCMATE.
+SEQ,GCSTRA
C...
      DIMENSION GAMTT(21),FN(300),EN(300)
      DIMENSION ENOLD(300)
C...
      DATA GAMTT
     +  /     1.1 ,     1.2 ,     1.3 ,     1.5 ,     1.8 ,
     +        2.0 ,     2.5 ,     3.0 ,     4.0 ,     7.0 ,
     +       10.0 ,    20.0 ,    40.0 ,    70.0 ,   100.0 ,
     +      300.0 ,   600.0 ,  1000.0 ,  3000.0 , 10000.0 ,
     +    50000.0 /
C...
      DO 10 I=1,21
         GAMLOG(I) = LOG(GAMTT(I))
   10 CONTINUE
*
      JPHXS = LQ(JPHOT-1)
* NZ = number of elements in the cross-section bank
      NZ    = Q(JPHXS+1)
* NI = number of intervals
      NI    = Q(JPHXS+2+3*NZ)
      NFACT = 140/NI
      EMAX  = LOG(DCUTE*1E9)
      DO 30 NNP = 1,NI
         EM(NNP) = LOG(1E3*Q(JPHXS+2+3*NZ+1+(NNP-1)*5))
         IF (NNP.NE.NI) THEN
            EM2 = LOG(1E3*Q(JPHXS+2+3*NZ+1+NNP*5))
         ELSE
            EM2 = EMAX
         ENDIF
         EESTE = (EM2-EM(NNP))/NFACT
         DO 20 NPNP=1,NFACT
            EMM((NNP-1)*NFACT+NPNP) = EM(NNP) + (NPNP-1)*EESTE
            IF (NPNP.EQ.1.AND.NNP.NE.1)
     +        EMM((NNP-1)*NFACT+NPNP) = EM(NNP) + .3*EESTE
            IF (EMM((NNP-1)*NFACT+NPNP).GT.EMAX) THEN
               NP = (NNP-1)*NFACT+NPNP -1
               GOTO 40
            ENDIF
   20    CONTINUE
   30 CONTINUE
   40 EPS   = .001
*
      CALL GSTXIN
*
*
* Create and fill the banks. The number of intervals is decreased
* in GSTTAB. It is supposed that the EN vector is the same for
* every GAM, if not en error message is printed.
*
      DO 80 I = 1,21
         GAM = GAMTT(I)
         CALL GSTTAB(GAM,NT,EN,FN)
         IF (I.EQ.1) THEN
            CALL MZBOOK(IXCONS,JTSTCO,JTSTRA,-1,'STCO',0,0,NT*21,3,-1)
            CALL MZBOOK(IXCONS,JTSTEN,JTSTRA,-2,'STEN',0,0,NT,3,-1)
            DO 50 II=1,NT
               ENOLD(II) = EN(II)
   50       CONTINUE
         ELSE
            DO 60 III=1,NT
               IF (ENOLD(III).NE.EN(III)) PRINT *,'ERROR in GSTINI     '
     +         //'              (straggling): Energy vector EN is '
     +         //'changing in GSTTAB'
   60       CONTINUE
         ENDIF
         DO 70 J=1,NT
            Q(JTSTCO+(J-1)*21+I) = FN(NT+1-J)
   70    CONTINUE
   80 CONTINUE
*
* ***
      DO 90 J=1,NT
         Q(JTSTEN+J) = EN(NT+1-J)
   90 CONTINUE
*
      NNWE = 0
      DO 110 J=1,NT
         DO 100 I=1,21
            ANL1 = Q(JTSTCO+(J-1)*21+I)
            IF(ANL1.LE.0.) THEN
               GO TO 120
            ENDIF
            Q(JTSTCO+(J-1)*21+I) = LOG(ANL1)
  100    CONTINUE
         NNWE = NNWE+1
  110 CONTINUE
  120 Q(JTSTRA+1) = NNWE
*
      END
+DECK,GSTINT.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GSTINT(X,A,F,N)
*
*       Simple linear interpolation
*
      DIMENSION A(N),F(N)
      DATA K1,K2,NO/0,0,0/
*
*       Check (N==NO) & (A(K1)<X<A(K2))
*
      IF (N.NE.NO.OR.A(K1).GT.X.OR.X.GT.A(K2)) THEN
*
*       Skip Unless N>1
*
         IF (N.LE.1) THEN
            GSTINT=F(1)
            GO TO 999
         ENDIF
         K1=1
         K2=N
         NO=N
*
*       Loop over K2-K1>1
*
  10     K=(K1+K2)/2
*
*       Check A(K)<X
*
         IF (A(K).LT.X) THEN
            K1=K
         ELSE
            K2=K
         END IF
         IF(K2-K1.GT.1) GO TO 10
      END IF
      X1=A(K1)
      X2=A(K2)
      GSTINT=(F(K1)*(X-X2)+F(K2)*(X1-X))/(X1-X2)
*
 999  CONTINUE
      END
+DECK,GSTREN.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GSTREN (GAMMA,ECUT,STEP)
C.    ******************************************************************
C.    *                                                                *
C.    *   Simulation of energy loss straggling in thin layers.         *
C.    *   Sampling is done from the tables which are prepared          *
C.    *   in GSTINI.                                                   *
C.    *                                                                *
C.    *   ==> Called by : GTELEC, GTHADR, GTMUON                       *
C.    *       Authors   : K. Lassila-Perini, I. Gavrilenko             *
C.    *                                                                *
C.    ******************************************************************
+SEQ,GCBANK.
+SEQ,GCJLOC.
+SEQ,GCMATE.
+SEQ,GCSTRA
C
      DIMENSION ANGL(200),RNDM(2)
C...
*   Reading the tables, if the medium has not changed
      NP     = Q(JTSTRA+1)
*
      EC       = 1.E9*ECUT
      GSTLOC   = 0.
      IF(STEP.LE.0.) GO TO 90
C...
*   Interpolate the tables for the current gamma-factor
      GAML     = LOG(GAMMA)
      IF(GAML.GT.GAMLOG(21)) THEN
         DO 10 J=1,NP
            ANGL(J)=Q(JTSTCO+J*21)
   10    CONTINUE
      ELSE
C...
         DO 20 I = 2,21
            IF(GAML.LE.GAMLOG(I)) THEN
               DGG = (GAML-GAMLOG(I-1))/(GAMLOG(I)-GAMLOG(I-1))
               IP=I
               GO TO 30
            ENDIF
   20    CONTINUE
   30    DG1=1.-DGG
C...
         DO 40 K = 1,NP
            ANGL(K) = Q(JTSTCO+(K-1)*21+IP-1)*DG1+
     +                Q(JTSTCO+(K-1)*21+IP  )*DGG
   40    CONTINUE
      ENDIF
*
*    The sampling from the tables
      ANMIN   = EXP(ANGL(NP))
      ANMAX   = EXP(ANGL( 1))
*
      DAN      = ANMAX-ANMIN
      AMU      = DAN*STEP
      CALL GPOISS(AMU,N,1)
      NICOLL   = MAX(N,1)
      DO 80  I  = 1,NICOLL
   50    K1 = 1
         K2 = NP
         CALL GRNDM(RNDM,1)
         R = LOG(RNDM(1)*DAN+ANMIN)
   60    K = (K1+K2)/2
         IF(R.GT.ANGL(K)) THEN
            K2=K
         ELSEIF(R.LT.ANGL(K)) THEN
            K1=K
         ELSE
            E=Q(JTSTEN+K)
            GOTO 70
         ENDIF
         IF(K2-K1.GT.1 ) GO TO 60
*
         E = Q(JTSTEN+K2)+(R-ANGL(K2))*
     +       (Q(JTSTEN+K1)-Q(JTSTEN+K2))/(ANGL(K1)-ANGL(K2))
   70    EE = EXP(E)
         IF(EE.GT.EC) GO TO 50
*
* *** Total energy calculation
         GSTLOC = GSTLOC+EE
   80 CONTINUE
*
   90 GSTREN  = GSTLOC*1.E-9
      END
+DECK,GSTTAB.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GSTTAB(GAMMA,NT,EN,FN)
C   ********************************************************************
C   *                                                                  *
C   *  dN^2/dEdx table for a gamma factor                              *
C   *                                                                  *
C   *  ==> Called by : GSTINI                                          *
C   *      Authors   : P. Nevski                                       *
C   *                                                                  *
C   ********************************************************************
+SEQ,GCSTRA
      EXTERNAL GSTDN
+SELF, IF=-SINGLE
      DOUBLE PRECISION DGAMM, DGAM2, DBET2
+SELF.
 
      DIMENSION EN(1),FN(1)
      PARAMETER (RENER=0.05)
*
*     ------------------------------------------------------------------
*
C   ----  final tables for dN/dx integral vs Energy for a gamma   ------
      DGAMM = GAMMA
      DGAM2 = DGAMM**2
      GAMMA2= DGAM2
      DBET2 = 1-1/DGAM2
      BETA2 = DBET2
      S=0
      NT=0
      ES=0
      EI=EMAX
C   Loop over I=NTAB,1,-1
      DO 10 I=NTAB,1,-1
         EO=EI
         EI=EMM(I)
         S=S+GXGINT(GSTDN,EI,EO,EPPS)
C      Skip Unless ABS(ES-EI)>RENER \ I==1
         IF ((ABS(ES-EI).LE.RENER).AND.(I.NE.1))GO TO 10
         ES=EI
         NT=NT+1
         EN(NT)=EI
         FN(NT)=S
   10 CONTINUE
      DNDX=S
      END
+DECK,GSTXIN.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GSTXIN
*   ********************************************************************
*   *                                                                  *
*   *   Initialization of the values needed in computation of          *
*   *   dN^2/dE/dx as in                                               *
*   *   Grishin,Ermilova,Kotelnikov,NIM A307(1991),273                 *
*   *                 PLN 18.04.92, data tables of ILG                 *
*   *                                                                  *
*   *   ==> Called by : GSTINI                                         *
*.  *       Authors   : P. Nevski, K. Lassila-Perini                   *
*   *                                                                  *
*   ********************************************************************
+SEQ,GCONSP.
+SEQ,GCMATE.
+SEQ,GCCUTS.
+SEQ,GCSTRA.
*
      REAL NAV,MB,ME,NE
*
*   1 ev to erg [erg]
      PARAMETER (ERG=1.60218E-12)
*   1mb to cm2
      PARAMETER (MB=1E-18)
*   Electron mass [g]
      PARAMETER (ME=9.10943E-28)
*   Electron charge[ESU]
      PARAMETER (QE=4.80321E-10)
*   Plank constant[erg]
      PARAMETER (H=1.05457E-27)
*
*     ------------------------------------------------------------------
*
*   -----    physic constants
      EPPS=0.01
      EMIN=EM(1)-EPPS
      EMAX=LOG(DCUTE*1.E9)
*
      NAV = AVO*1.E24
*
*   Electron mass in ev
      MEEV=ME*CLIGHT**2/ERG
*
*   electron radius[cm]
      R0=QE**2/(ME*CLIGHT**2)
*
*   Plank constant in ev
      HE=H*CLIGHT/ERG
*
*   Gas density
      RO=DENS
*
*   Electron density
      NE=NAV*Z/A*RO
*
*   plasma freq**2 [ev]
      WP2=4*PI*R0*NE*HE**2
*
*   x-section to F.osc
      S1=MB/(2*PI**2*R0*HE*Z)
*
*   dN/dx scale
      S2=2*PI*R0*NE*QE**2/ERG
*
      NTAB = NP
      SFINT=0
*
*    Integration of the oscillator strength function
*    (photoelectric cross-section)
      DO 10  IE=NTAB,1,-1
         E1 = EMM(IE)
         IF (IE.EQ.NTAB) THEN
            E2 = EMAX
         ELSE
            E2 = EMM(IE+1)
         ENDIF
         SFINT = SFINT+ GOSCIN(EXP(E1),EXP(E2))
         FINT(IE)=SFINT
   10 CONTINUE
*
*   Normalization of the integrated cross-section
      DO 20  IE=1,NTAB
         FINT(IE)=LOG(FINT(IE)/SFINT)
   20 CONTINUE
*
*   Calculation of the real and imaginary parts of the
*   complex dielectric constant
      DO 30  IE=1,NTAB
         E=EXP(EMM(IE))
         EPSI(IE)=LOG(WP2*PIBY2*GPHSG2(E*1E-9)/(SFINT*E))
*      scaled by
         EPSR(IE)=WP2*GKOKRI(E,EXP(EMIN),DCUTE*1E9)*E/SFINT
   30 CONTINUE
      END
+DECK,GXGINT.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GXGINT(EXT,A,B,EPS)
*
*    Gauss integration routine
*
+SEQ,GCUNIT.
+SELF,IF=-SINGLE
      DOUBLE PRECISION OTB,U1,U2,W1,W2,Y
+SELF
      EXTERNAL EXT
      PARAMETER (U1=.3399810,U2=.8611363,W1=.6521452,W2=.3478548)
*
*-----------------------------------------------------------------------
*
      N      = 5
      OTB    = 0
      DHALF  = (B-A)/N
   10 CONTINUE
*
*   Convergence loop
*
      Y = OTB
      OTB = 0
      D = DHALF
      DHALF = 0.5*D
      CENTX = A-DHALF
      D1 = U1*DHALF
      D2 = U2*DHALF
*
*   Piecewise integration loop
*
      DO 20 I=1,N
         CENTX=CENTX+D
         OTB = OTB +W2*(EXT(CENTX-D2)+EXT(CENTX+D2)) +W1*(EXT(CENTX-D1)
     +   +EXT(CENTX+D1))
   20 CONTINUE
      OTB=OTB*DHALF
*
      IF(EPS.GT.0.AND.ABS(OTB-Y).GT.ABS(EPS*OTB)) THEN
         N = 2*N
         IF (N.GT.100 000) THEN
*
*   Check N>100 000
*
            WRITE(CHMAIL,10000) EPS, ABS((OTB-Y)/OTB)
            CALL GMAIL(1,0)
            GO TO 30
         END IF
         GOTO 10
      ENDIF
*
   30 CONTINUE
      GXGINT=OTB
10000 FORMAT('*** GXGINT : required precision ',G10.3,
     +      ' obtained precision ',G10.3)
      END
+PATCH,GUSER
+DECK,GUDCAY
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUDCAY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to decay particles                          *
C.    *                                                                *
C.    *    ==>Called by : GDECAY                                       *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      END
+DECK,GUDIGI
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUDIGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to digitize one event                       *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      END
+DECK,GUDTIM
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GUDTIM(DETREP,HITREP,IW1,DIS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User function called by GCDRIF to return drift time      *
C.    *                                                                *
C.    *    ==>Called by : GCDRIF                                       *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      GUDTIM=0.
      END
+DECK,GUFLD
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUFLD(X,F)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to compute the magnetic field F             *
C.    *       at space point X                                         *
C.    *                                                                *
C.    *    ==>Called by : GHELIX,GRKUTA                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),F(3)
C.
C.    ------------------------------------------------------------------
C.
      F(1)=0.
      F(2)=0.
      F(3)=0.
C
      END
+DECK,GUHADR
*CMZ :  3.21/03 07/10/94  18.41.50  by  S.Giani
*-- Author :
      SUBROUTINE GUHADR
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to generate one hadronic interaction        *
C.    *                                                                *
C.    *    ==>Called by : GTHADR,GTNEUT                                *
C.    *                                                                *
C.    ******************************************************************
C.
*======================================================================*
*                                                                      *
*   An interface with a part of the FLUKA shower code is available in  *
*   GEANT 3.21. The following conditions and warnings must be taken    *
*   into account when using the FLUKA routines.                        *
*                                                                      *
*======================================================================*
*======================================================================*
*                                                                      *
*                   FFFF   L      U  U  K  K   AA                      *
*                   F      L      U  U  K K   A  A                     *
*                   FFF    L      U  U  KK    AAAA                     *
*                   F      L      U  U  K K   A  A                     *
*                   F      LLLL    UU   K  K  A  A                     *
*                                                                      *
*                   (C) Copyright of the authors                       *
*                                                                      *
*             A. Fasso'*, A. Ferrari#, J. Ranft$, P.R. Sala#           *
*                                                                      *
*               *: CERN, #: INFN -Milan, $: CERN/Frascati              *
*                                                                      *
*                (e-mail: FERRARIA@CERNVM.CERN.CH)                     *
*                                                                      *
*======================================================================*
*                                                                      *
*   - All the rights concerning FLUKA or parts of it are only of the   *
*     authors and are independent from those of the GEANT code         *
*                                                                      *
*   - FLUKA [1-6] is a standalone code capable of simulating the inter-*
*     action and transport of all components of EM and hadronic cas-   *
*     cades up to several TeV. However, only cross sections and        *
*     models for hadronic elastic and inelastic interactions (end 1992 *
*     status) are included in this GEANT version.                      *
*                                                                      *
*   - The most recent FLUKA model [4,6] for nucleon and pion interac-  *
*     tions in the intermediate energy range is not fully implemented  *
*     in GEANT. Only a simplified version, limited to p and n below    *
*     250 MeV, is available in GEANT 3.21. A coarser model is used for *
*     other projectiles in this energy range. However the implemented  *
*     parts should be adequate for most detector simulations and sim-  *
*     ilar applications for which GEANT is generally used. Their accu- *
*     racy could be insufficient for some nuclear physics studies or   *
*     demanding simulations at low energies, where the more sophistic- *
*     ated models [4,6] could be required.                             *
*                                                                      *
*   - The performances of GEANT-FLUKA are therefore not representative *
*     of those of FLUKA standalone and should be referenced as such    *
*     rather than simply GEANT or FLUKA.                               *
*                                                                      *
*   - The authors reserve the right of publishing about the physical   *
*     models developed for FLUKA. Running the FLUKA routines in isol-  *
*     ation for benchmarks (or equivalent use) is not permitted,       *
*     except after consultations or in collaboration with the authors. *
*                                                                      *
*   - The FLUKA routines are supposed to be included and used in       *
*     GEANT only. Any other use must be authorized by the authors.     *
*                                                                      *
*   - References: at least reference [5] should be always quoted when  *
*                 reporting results obtained with GEANT-FLUKA          *
*                                                                      *
* [1] A. Fasso', A. Ferrari, J. Ranft, P. R. Sala, G. R. Stevenson and *
*     J. M. Zazula, "FLUKA92", presented at the workshop on "Simulat-  *
*     ing Accelerator Radiation Environment", SARE, Santa Fe, 11-15    *
*     january (1993), Proceedings in press.                            *
*                                                                      *
* [2] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, Proc. MC93 Int. Conf. *
*     on Monte-Carlo Simulation in High-Energy and Nuclear Physics,    *
*     Tallahassee, Florida, 22-26 february (1993), World Scientific,   *
*     p. 88 (1994).                                                    *
*                                                                      *
* [3] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, ibidem, p. 100 (1994) *
*                                                                      *
* [4] A. Ferrari and P.R. Sala, ibidem, p. 277 (1994).                 *
*                                                                      *
* [5] A. Fasso', A. Ferrari, J. Ranft and P.R. Sala, "FLUKA: present   *
*     status and future developments", presented at the IV Int. Conf.  *
*     on Calorimetry in High Energy Physics, La Biodola (Elba),        *
*     September 19-25 1993, Proceedings in press.                      *
*                                                                      *
* [6] A. Fasso', A. Ferrari, J. Ranft, and P.R. Sala, "FLUKA: Perf-    *
*     ormances and Applications in the Intermediate Energy Range",     *
*     presented at the "Specialists' Meeting on Shielding Aspects of   *
*     Accelerators, Targets & Irradiation Facilities", Arlington,      *
*     April 28-29 1994, Proceedings in press.                          *
*                                                                      *
*======================================================================*
C.
C.    ------------------------------------------------------------------
C.
C          GHEISHA only if IHADR<3 (default)
C
      CALL GHEISH
C
      END
+DECK,GUIGET
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUIGET(NMENU,NCOMD,NPAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine for interactive control of GEANT            *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>, GINCOM                              *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,GUINME
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUINME(X,SH,P,IYES)
C.
C.    **********************************************
C.    *                                            *
C.    *    USER ROUTINE TO PROVIDE GINME FUNCTION  *
C.    *    FOR ALL USER SHAPES IDENTIFIED BY THE   *
C.    *    SHAPE NUMBER SH. POINT IS GIVEN IN X    *
C.    *    THE PARAMETERS ARE GIVEN IN P. IYES IS  *
C.    *    RETURNED 1 IF POINT IS IN, 0 IF POINT   *
C.    *    IS OUT AND LESS THAN ZERO IF SHAPE      *
C.    *    NUMBER IS NOT SUPPORTED.                *
C.    *                                            *
C.    *    ==>Called by : GINME                    *
C.    *                                            *
C.    **********************************************
C.
      DIMENSION X(3),P(*)
C
      IYES=-1
      END
+DECK,GUINTI
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUINTI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine for interactive version                     *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>,  GINTRI                             *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,GUKINE
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUKINE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Read or Generates Kinematics for primary tracks          *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,GUNEAR.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUNEAR(ISEARC, ICALL, X, JNEAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    User search                                                 *
C.    *       ISEARC to identify the given volume                      *
C.    *       ICALL  to identify the calling routine                   *
C.    *              1 GMEDIA like                                     *
C.    *              2 GNEXT like                                      *
C.    *       X      coordinates (+direction for ICALL=2)              *
C.    *       JNEAR  address of default list of neighbours             *
C.    *              (list to be overwriten by user)                   *
C.    *                                                                *
C.    *    Called by : GFTRAC, GINVOL, GTMEDI, GTNEXT, GNEXT, GMEDIA   *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(*)
C.    ------------------------------------------------------------------
*                                                             END GUNEAR
      END
+DECK,GUOUT
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUOUT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each event             *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,GUPHAD
*CMZ :  3.21/03 07/10/94  18.38.33  by  S.Giani
*-- Author :
      SUBROUTINE GUPHAD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to compute Hadron. inter. probabilities     *
C.    *                                                                *
C.    *    ==>Called by : GTHADR,GTNEUT                                *
C.    *                                                                *
C.    ******************************************************************
C.
*======================================================================*
*                                                                      *
*   An interface with a part of the FLUKA shower code is available in  *
*   GEANT 3.21. The following conditions and warnings must be taken    *
*   into account when using the FLUKA routines.                        *
*                                                                      *
*======================================================================*
*======================================================================*
*                                                                      *
*                   FFFF   L      U  U  K  K   AA                      *
*                   F      L      U  U  K K   A  A                     *
*                   FFF    L      U  U  KK    AAAA                     *
*                   F      L      U  U  K K   A  A                     *
*                   F      LLLL    UU   K  K  A  A                     *
*                                                                      *
*                   (C) Copyright of the authors                       *
*                                                                      *
*             A. Fasso'*, A. Ferrari#, J. Ranft$, P.R. Sala#           *
*                                                                      *
*               *: CERN, #: INFN -Milan, $: CERN/Frascati              *
*                                                                      *
*                (e-mail: FERRARIA@CERNVM.CERN.CH)                     *
*                                                                      *
*======================================================================*
*                                                                      *
*   - All the rights concerning FLUKA or parts of it are only of the   *
*     authors and are independent from those of the GEANT code         *
*                                                                      *
*   - FLUKA [1-6] is a standalone code capable of simulating the inter-*
*     action and transport of all components of EM and hadronic cas-   *
*     cades up to several TeV. However, only cross sections and        *
*     models for hadronic elastic and inelastic interactions (end 1992 *
*     status) are included in this GEANT version.                      *
*                                                                      *
*   - The most recent FLUKA model [4,6] for nucleon and pion interac-  *
*     tions in the intermediate energy range is not fully implemented  *
*     in GEANT. Only a simplified version, limited to p and n below    *
*     250 MeV, is available in GEANT 3.21. A coarser model is used for *
*     other projectiles in this energy range. However the implemented  *
*     parts should be adequate for most detector simulations and sim-  *
*     ilar applications for which GEANT is generally used. Their accu- *
*     racy could be insufficient for some nuclear physics studies or   *
*     demanding simulations at low energies, where the more sophistic- *
*     ated models [4,6] could be required.                             *
*                                                                      *
*   - The performances of GEANT-FLUKA are therefore not representative *
*     of those of FLUKA standalone and should be referenced as such    *
*     rather than simply GEANT or FLUKA.                               *
*                                                                      *
*   - The authors reserve the right of publishing about the physical   *
*     models developed for FLUKA. Running the FLUKA routines in isol-  *
*     ation for benchmarks (or equivalent use) is not permitted,       *
*     except after consultations or in collaboration with the authors. *
*                                                                      *
*   - The FLUKA routines are supposed to be included and used in       *
*     GEANT only. Any other use must be authorized by the authors.     *
*                                                                      *
*   - References: at least reference [5] should be always quoted when  *
*                 reporting results obtained with GEANT-FLUKA          *
*                                                                      *
* [1] A. Fasso', A. Ferrari, J. Ranft, P. R. Sala, G. R. Stevenson and *
*     J. M. Zazula, "FLUKA92", presented at the workshop on "Simulat-  *
*     ing Accelerator Radiation Environment", SARE, Santa Fe, 11-15    *
*     january (1993), Proceedings in press.                            *
*                                                                      *
* [2] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, Proc. MC93 Int. Conf. *
*     on Monte-Carlo Simulation in High-Energy and Nuclear Physics,    *
*     Tallahassee, Florida, 22-26 february (1993), World Scientific,   *
*     p. 88 (1994).                                                    *
*                                                                      *
* [3] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, ibidem, p. 100 (1994) *
*                                                                      *
* [4] A. Ferrari and P.R. Sala, ibidem, p. 277 (1994).                 *
*                                                                      *
* [5] A. Fasso', A. Ferrari, J. Ranft and P.R. Sala, "FLUKA: present   *
*     status and future developments", presented at the IV Int. Conf.  *
*     on Calorimetry in High Energy Physics, La Biodola (Elba),        *
*     September 19-25 1993, Proceedings in press.                      *
*                                                                      *
* [6] A. Fasso', A. Ferrari, J. Ranft, and P.R. Sala, "FLUKA: Perf-    *
*     ormances and Applications in the Intermediate Energy Range",     *
*     presented at the "Specialists' Meeting on Shielding Aspects of   *
*     Accelerators, Targets & Irradiation Facilities", Arlington,      *
*     April 28-29 1994, Proceedings in press.                          *
*                                                                      *
*======================================================================*
C.
C.    ------------------------------------------------------------------
C.
C             GPGHEI for GHEISHA
C
      CALL GPGHEI
      END
+DECK,GUSKIP.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUSKIP (ISKIP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   User routine to skip unwanted tracks                         *
C.    *                                                                *
C.    *   Called by : GSSTAK                                           *
C.    *   Author    : F.Bruyant                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
C.    ------------------------------------------------------------------
*
      ISKIP = 0
*                                                             END GUSKIP
      END
 
+DECK,GUSTEP
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUSTEP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each tracking step     *
C.    *       INWVOL is different from 0 when the track has reached    *
C.    *              a volume boundary                                 *
C.    *       ISTOP is different from 0 if the track has stopped       *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCTMED
+SEQ,GCTRAK
C.
C.    ------------------------------------------------------------------
C.
      END
+DECK,GUSWIM
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUSWIM(CHARGE,STEP,VECT,VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to control tracking of one track            *
C.    *       in a magnetic field                                      *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTHADR,GTMUON                         *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCTMED
      DIMENSION VECT(6),VOUT(6)
C.
C.    ------------------------------------------------------------------
C.
         IF (IFIELD.EQ.3)THEN
            CALL GHELX3(FIELDM*CHARGE,STEP,VECT,VOUT)
         ELSEIF(IFIELD.EQ.2)THEN
            CALL GHELIX(CHARGE,STEP,VECT,VOUT)
         ELSE
            CALL GRKUTA(CHARGE,STEP,VECT,VOUT)
         ENDIF
C
      END
+DECK, GUTRAK
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUTRAK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to control tracking of one track            *
C.    *                                                                *
C.    *    ==>Called by : GTREVE                                       *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
*
      CALL GTRACK
*                                                             END GUTRAK
      END
+DECK,GUTREV
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUTREV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to control tracking of one event            *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      CALL GTREVE
C
      END
+DECK,GUVIEW
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUVIEW(IDS,IVS,ICS,IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine for interactive version                     *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>, GINC1                               *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      CHARACTER*(*) ICS
+SEQ,GCJUMP, IF=USRJMP
+SELF, IF=-USRJMP
      CALL GUSTEP
+SELF, IF=USRJMP
      CALL JUMPT0(JUSTEP)
+SELF
      END
+DECK,GUPARA.
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUPARA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called every time a particle falls below    *
C.    *       parametrization threshold. This routine should create    *
C.    *       the parametrization stack, and, when this is full,       *
C.    *       parametrize the shower and track the geantinos.          *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCFLAG
+SEQ,GCKINE
+SEQ,GCPARM
+SEQ,GCTMED
+SEQ,GCTRAK
C.
C.    ------------------------------------------------------------------
C.
*      CALL GSPARA
*
      END
+DECK,GUPLSH
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      FUNCTION GUPLSH(MED0,MED1)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GLISUR                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCTMED
C.
C.    ------------------------------------------------------------------
C.
*
* *** By default this defines perfect smoothness
      GUPLSH = 1.
C
      END
