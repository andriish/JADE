C   20/02/81 107091035  MEMBER NAME  BACKTR   (PATRECSR)    SHELTRAN
      SUBROUTINE BACKTR
C
C     BACKTRACING VERSION 5 (MAR 2,79)
C     MAIN PROGRAM FOR BACKTRACING
C
      IMPLICIT INTEGER*2 (H)
C
C
#include "cjdrch.for"
#include "cworkmx.for"
#include "cdsmax.for"
#include "cworkpr.for"
#include "clbpgm.for"
#include "cpatlm.for"
      DIMENSION HORD(200),HTEMP(10)
      DIMENSION LSTCL(3),LFTCL(3),NCELL(3),TANDEL(3)
      EQUIVALENCE (IBCK(1),LSTCL(1)),(IBCK(4),LFTCL(1))
      EQUIVALENCE (IBCK(7),NCELL(1)),(DBCK(1),TANDEL(1))
      EQUIVALENCE (ADWRK(486),HTEMP(1)),(ADWRK(491),HORD(1))
      DATA HPST/'PS'/
      DATA MSKCR1,MSKCR2,MSKZEN /Z100,Z200,Z80/,MSKERA/ZFFFFBFFF/
      DATA MSKLR0/Z1000/,MSKKIL/Z20000/,MSKLRA/ZFFFFEFFF/
      DATA MSKDSP,MSKERR,MSKSKP/Z2000,Z4000,Z8000/
C
C
C     PRINT 3462, (IPCL(I),I=1,HNTR)
C     PRINT 3463, (NRHT(I),I=1,HNTR)
C     PRINT 3464, (NWR1(I),I=1,HNTR)
C     PRINT 3460, (DS1(I),I=1,HNTR)
C     PRINT 3465, (SL1(I),I=1,HNTR)
C     PRINT 3466, (NWR2(I),I=1,HNTR)
C     PRINT 3467, (DS2(I),I=1,HNTR)
C     PRINT 3468, (SL2(I),I=1,HNTR)
C     PRINT 3469, (LBL(I),I=1,HNTR)
C3462  FORMAT(' CELL#',30I4)
C3463  FORMAT(' NO OF HITS',30I4)
C3464  FORMAT(' WIRE1',30I4)
C3466  FORMAT(' WIRE2',30I4)
C3469  FORMAT(' LBL  ',20(1X,Z4))
C3460  FORMAT(' DRIFT1',10F7.3)
C3465  FORMAT(' SLOPE1',10F7.3)
C3467  FORMAT(' DRIFT2',10F7.3)
C3468  FORMAT(' SLOPE2',10F7.3)
      LBPGM(10)=1
      IF(HNTR.LE.0.OR.HPRO.NE.HPST) RETURN
      FOR I=1,HNTR
      HORD(I)=I
      CFOR
      IF HNTR.GT.1
      THEN
      INR=HNTR-1
      FOR IBK=1,INR
      IBC=IBK+1
      IF IPCL(IBK).EQ.IPCL(IBC)
      THEN
      IF NWR2(IBK).GT.NWR2(IBC).AND.NWR1(IBK).GT.NWR1(IBC)
      THEN
      TEMP=HORD(IBK)
      HORD(IBK)=HORD(IBC)
      HORD(IBC)=TEMP
C     PRINT 563,HORD(IBK),HORD(IBC),IBK
C 563  FORMAT(' ((((((((',3I5)
      CIF
      CIF
      CFOR
      CIF
      IBFIT=0
      ISP=0
      ITOL1=2
      IS=0
      ZERO=0
N     INIT TRACK ELEMENT ARRAYS
      CALL SETSL(HUSE(1),0,400,ZERO)
      CALL SETSL(NTR,0,2004,ZERO)
      FOR I=1,HNTR
      IF(LAND(LBL(I),MSKKIL).NE.0) HUSE(I)=1
      CFOR
N     GET AN INITIAL TRACK STARTING IN CELL 96
      FOR ITRL=1,HNTR
N     K IS THE CURRENT TRACK POINTER
      K=HNTR-ITRL+1
      K=HORD(K)
N     HAS IT BEEN USED YET?
      IF HUSE(K).EQ.0
      THEN
      IF NTR.LT.100
      THEN
N     CONTINUATION COUNTER
      ICNT = 0
N     EXTRACT CELL NO
      ICL=IPCL(K)
      IJFLG=0
      LRING=1
N     NORMAL TOLERANCES
      ITOL=1
N     CALCULATE RING NO
      IF(ICL.GT.NCELL(1)) LRING=2
      IF(ICL.GT.NCELL(2)+NCELL(1)) LRING=3
N     ENTER ONCE FOR LRING=2
      IF LRING.LE.ITOL1
N     AND ONCE FOR LRING=1
      THEN
N     INCOMPLETE TRACKS?
      IF IS.GT.0
      THEN
N     FLAG TO INCREASE NORMAL TOLERANCES
N     ITOL NE 1 MEANS TOLERANCES HAVE BEEN INCREASED
      ITOL=2
N     REMEMBER RING,TRACK POINTERS
      INTR=NTR
      IIK=K
N     DECREASE ITOL1 COUNTER
      ITOL1=ITOL1-1
      ILRNG=LRING
N     FIX NO. OF INCOMPLETE TRACKS TO BE TRIED
      IS1=IS
N     RESET COUNTER FOR NO. OF INCOMPLETE TRACKS
      IS=0
C     PRINT 662
C 662  FORMAT('0************* LOOSER TOLERANCES *********** ')
N     LOOP OVER INCOMPLETE TRACKS
      FOR IU=1,IS1
N     EXTRACT TRACK NO.
      NTR=HSP1(IU)
N     EXTRACT TRACK ELEMENT NO.
      K=HISTR(HNREL(NTR),NTR)
      LR=1
      IF(K.LT.0) LR=-1
      K=IABS(K)
N     TURN OFF ERROR BIT
      LBL(K)=LAND(LBL(K),MSKERA)
C     CALL CHKX(2,NTR,LR,K)
N     EXTRACT CELL NO.
      ICL=IPCL(K)
N     CALCULATE RING NO
      LRING=1
      IF(ICL.GT.NCELL(1)) LRING=2
      IF(ICL.GT.NCELL(2)+NCELL(1)) LRING=3
      KRING=LRING
      IPST=1
      IJFLG=0
N     IF A PREVIOUS CONNECTION ACROSS BOUNDARY
      ITMP=HISTR(1,NTR)
N     THEN SET IPST=0
      ITMP=IABS(ITMP)
      ITMP=IPCL(ITMP)
      IF(ICL.NE.ITMP) IPST=0
C     CALL CHKX(3,ICL,ITMP,IPST)
C     PRINT 4458,NTR,K,ICL,KRING
N     DOES THIS TRACK HAVE LR=0 BIT SET?
      IF LAND(LBL(K),MSKLR0).NE.0
      THEN
      ITMP=HNREL(NTR)
N     RESET LR=0 BIT FOR THE WHOLE TRACK
      FOR IX=1,ITMP
      IJ=HISTR(IX,NTR)
      IJ=IABS(IJ)
      LBL(IJ)=LAND(LBL(IJ),MSKLRA)
      CFOR
N     IF ONLY ONE TRACK ELEMENT
      IF ITMP.EQ.1
      THEN
      LR=0
      ELSE
N     FOR MORE THAN ONE ELEMENT IN THE TRACK
      IJFLG=1
      CIF
      CIF
      PERFORM CONT1
      CFOR
      NTR=INTR
N     RESET FLAGS
      ICNT=0
      IJFLG=0
      ITOL=1
      K=IIK
      LRING=ILRNG
C     PRINT 662
      CIF
      CIF
N     IS THIS TRACK STILL UNUSED?
      IF HUSE(K).EQ.0
      THEN
N     EXTRACT CELL NO
      ICL=IPCL(K)
      KRING=LRING
N     INCREMENT TRACK NUMBER
      NTR = NTR + 1
C     PRINT 4458,NTR,K,ICL,KRING
C 4458 FORMAT('0NTR=',I4,' TRACK=',I4,' CELL=',I4,' RING=',I4)
N     GET READY TO STORE AWAY TRACK
      IKX=K
N     DETERMINE LEFT-RIGHT SOLN
      CALL LFRT(LR2)
      LR=LR2
N     IF IT IS UNKNOWN THEN SET IT TEMPORARILY
      IF(LR.EQ.0) LR=1
N     STORE THIS TRACK AWAY
      CALL BSTORE
N     RESET LR IN CASE IT WAS ZERO BEFORE
      LR=LR2
N     TRY TO FIND A CONTINUATION OF THIS TRACK
      PERFORM CONT1
      CIF
      CIF
      CIF
      CFOR
      FOR KTR=1,NTR
      ITMP=HNREL(KTR)
N     CHECK FOR DISCREPANCY BETWEEN
N     LR FROM LBL AND FROM BACKTR
      PERFORM CELLFL
      IF(KMP1.EQ.KMP2) LBL(ITKEL)=LOR(LBL(ITKEL),MSKLR0)
      IF(KMP1.EQ.KMP2) LBL(ITKEL1)=LOR(LBL(ITKEL1),MSKLR0)
C     IF(KMP1.EQ.KMP2) PRINT 457
C 457  FORMAT(' ++++++++++ LR=0 +++++++++++++++')
      FOR MG=1,ITMP
      JK=HISTR(MG,KTR)
      IKX=IABS(JK)
      CALL LFRT(LR2)
N     SET BIT 18 FOR DISCREPANCY
      IF JK*LR2.LT.0
      THEN
      IF IBKK(20).NE.0.AND.NRHT(IKX).GE.IBKK(19)
      THEN
C     HISTR(MG,KTR)=-HISTR(MG,KTR)
C     PRINT 209,IKX,KTR
C209   FORMAT('  TRACKEL ',I5,'    FROM TRACK',I5,'  FORCED LR ')
      ELSE
      LBL(IKX)=LOR(LBL(IKX),MSKDSP)
C     PRINT 453,IKX
      CIF
      CIF
C 453  FORMAT(' ====== WRONG LR FLAG ,TRACK===================== ',I4)
      CFOR
      CFOR
C     PRINT 3456,NTR
C     PRINT 3457,(HNREL(III),III=1,NTR)
C     PRINT 3458,((HISTR(KK,III),KK=1,6),III=1,NTR)
C3456  FORMAT('0NTR ',I10)
C3457  FORMAT(' NREL ',30I4)
C3458  FORMAT(' HISTR ',30I4)
C     PRINT 3469, (LBL(I),I=1,HNTR)
      IF NTR.GT.1
      THEN
      FOR KTR=1,NTR
      PERFORM CELLFL
      IR1=1
      IR2=1
      IF(KMP1.GT.NCELL(1)) IR1=2
      IF(KMP1.GT.NCELL(1)+NCELL(2)) IR1=3
      IF(KMP2.GT.NCELL(1)) IR2=2
      IF(KMP2.GT.NCELL(1)+NCELL(2)) IR2=3
      IF(IR2.EQ.1.AND.IR1.EQ.3.AND.LAND(MSKSKP,LBL(ITKEL)).EQ.0)
     *  HORD(KTR)=1
      IF(IR2.EQ.1.AND.IR1.EQ.2) HORD(KTR)=6
      IF(LAND(MSKSKP,LBL(ITKEL)).NE.0) HORD(KTR)=2
      IF(IR2.EQ.2.AND.IR1.EQ.3) HORD(KTR)=3
      IF IR1.EQ.IR2
      THEN
      IF(IR1.EQ.3) HORD(KTR)=5
      IF(IR1.EQ.2) HORD(KTR)=4
      IF(IR1.EQ.1) HORD(KTR)=7
      CIF
      CFOR
C     PRINT 286,(HORD(IO),IO=1,NTR)
C286  FORMAT(' ',30I3)
      INR=NTR-1
      FOR IBK=1,INR
      IUP=IBK+1
      FOR IBC=IUP,NTR
      IF HORD(IBC).LT.HORD(IBK)
      THEN
      CALL MVC(HTEMP(1),0,HISTR(1,IBC),0,18)
      CALL MVC(HISTR(1,IBC),0,HISTR(1,IBK),0,18)
      CALL MVC(HISTR(1,IBK),0,HTEMP(1),0,18)
      TEMP=HNREL(IBC)
      HNREL(IBC)=HNREL(IBK)
      HNREL(IBK)=TEMP
      TEMP=HORD(IBC)
      HORD(IBC)=HORD(IBK)
      HORD(IBK)=TEMP
      CIF
      CFOR
      CFOR
C     PRINT 3457,(HNREL(III),III=1,NTR)
C     PRINT 3458,((HISTR(KK,III),KK=1,6),III=1,NTR)
      IF IYBKK(11).NE.0
      THEN
      HPFRE0=HPFREE
      IMOSS=99
      CALL BAKPAK(IMOSS)
      HPFREE=HPFRE0
      CIF
      IF IYBKK(15).NE.0
      THEN
      HPFRE0=HPFREE
      IMOSS=0
      CALL BAKPAK(IMOSS)
      HPFREE=HPFRE0
      CIF
      IP0=0
N     SEARCH FOR TRACKS WITH NO ELS
      FOR I=1,100
      IF HNREL(I).EQ.0
      THEN
      IP0=I
      XFOR
      CIF
      CFOR
      IF IP0.NE.0
      THEN
N     COMPRESS BACKTR ARRAY
      FOR I=1,100
      IF IP0.LT.I
      THEN
      IF HNREL(I).NE.0
      THEN
      HNREL(IP0)=HNREL(I)
      HNREL(I)=0
      FOR J=1,9
      HISTR(J,IP0)=HISTR(J,I)
      HISTR(J,I)=0
      CFOR
      IP0=IP0+1
      CIF
      CIF
      CFOR
      CIF
      ICOUNT=0
N      HOW MANY TRACKS
      FOR I=1,100
      IF(HNREL(I).NE.0) ICOUNT=ICOUNT+1
      CFOR
N     UPDATE NTR
      NTR=ICOUNT
      CIF
      RETURN
C
C    *********************************************************
C
      PROC CONT1
C
C   THIS PROCEDURE CALLS CONT FOR EACH RING
C
      PERFORM CONT
N     IF WE WERE SUCCESSFUL THEN TRY AGAIN
      IF KRING.GT.0.AND.IRIFLG.NE.0
      THEN
      PERFORM CONT
N     TRY FOR A MATCH INTO THE LAST RING
      IF KRING.GT.0.AND.IRIFLG.NE.0
      THEN
      PERFORM CONT
      CIF
      CIF
      CPROC
C
C    *********************************************************
C
      PROC CONT
C
C   THIS PROCEDURE FINDS FIRST MATCHING TRACK IN NEXT RING,
C      CORRECTLY STORING ANY TRACKS GOING OUT THROUGH THE SIDE WALL
C
N     INCREMENT CONT COUNTER
      ICNT = ICNT + 1
N     CHECK FOR TRACK GOING THROUGH SIDEWALL(IN AN OUTWARD SENSE)
      IF ICNT.EQ.1.AND.ITOL.EQ.1
      THEN
      IUDFLG=3
      ILIM=ILOUT
      KY=K
      ICY=ICL
      IDUM=0
      WHILE IDUM.EQ.0
C     PRINT 2345,K
C2345 FORMAT(' PERFORM SIDOUT TRACK=',I4)
      ISTREL=HNREL(NTR)+1
N     TRY SIDE CONNECTION
      CALL BSIDE
      IF IRIFLG.NE.1
      THEN
      XWHILE
      CIF
      INTFLG=0
      IF HNTCEL(ICX+1)-HNTCEL(ICX).GT.1
      THEN
N     WITH A TRACK ELEMENT IN THE UPPER
      NTRLX1=HNTCEL(ICX)
N     HALF OF THE CELL
      NTRLX2=HNTCEL(ICX+1)-1
      IBFIT=-2
N     LOOP OVER ALL TRACK ELS IN THIS CELL
      FOR KK=NTRLX1,NTRLX2
N     WITH LOWER TRACK EL FIXED AT KX
      IF HUSE(KK).EQ.0
      THEN
      IW=NWR1(KK)
      IF IW.GE.ILBOT
      THEN
N     TRY CONNECTION WITHIN A CELL
      CALL  INTJN1(KK,KT,INTFLG,DT)
      IF INTFLG.NE.0
      THEN
      IKX=KK
      LR3=1
      IF(INTFLG.EQ.-1.OR.(LAND(LBL(KT),MSKCR1).NE.0.AND.LAND(LBL(IKX),
     * MSKCR1).EQ.0)) LR3=-1
      LRR=LR
      LR=-LR
      PERFORM INCRSS
      LR=LR2
      CALL BSTORE
      K=IKX
      PERFORM SRTREL
      ICL=ICX
      LR=LRR
      XFOR
      CIF
      CIF
      CIF
      CFOR
      IBFIT=0
      CIF
      IF INTFLG.EQ.0
      THEN
      PERFORM SRTREL
      XWHILE
      CIF
      CWHILE
      ICL=ICY
      K=KY
      PERFORM CROSS
      CIF
N     STARTING WIRE NR
      IW = NWR1(K)
      IUDFLG=6
      IF IW.GE.ILBOT
      THEN
N     TRY JOINING TRACK ELS WITHIN A CELL
      PERFORM INTJN
      CIF
N     CHECK FOR TRACK GOING THROUGH SIDEWALL(IN AN INWARD DIRECTION)
      ILIM=-ILIN
      IDUM=0
      WHILE IDUM.EQ.0
C     PRINT 2346,K
C2346 FORMAT(' PERFORM SIDIN TRACK=',I4)
N     TRY SIDE CONNECTION
      CALL BSIDE
N     UPDATE CELL AND TRACK POINTERS AFTER SUCCESSFUL MATCH
N     FOR INWARD GOING TRACKS ONLY
      ICL=ICX
      K=KT
      IF IRIFLG.EQ.0
      THEN
      XWHILE
      CIF
      PERFORM CROSS
N     STARTING WIRE NR
      IW = NWR1(K)
      IF IW.GE.ILBOT
      THEN
N     TRY JOINING TRACK ELS WITHIN A CELL
      PERFORM INTJN
      IF ISUFLG.EQ.0
      THEN
      XWHILE
      CIF
      ELSE
      XWHILE
      CIF
      CWHILE
N     RING CONTINUATION FLAGS PRESET
      IRIFLG = 0
      IUDFLG=0
      IF KRING.GT.1
N     CONNECT TRACK THROUGH RINGS
      THEN
      CALL RINCON
      PERFORM CROSS
      CIF
      IF IRIFLG.EQ.0
      THEN
      IF LRING.NE.1.AND.KRING.NE.LRING
      THEN
N     POSSIBLE BACKTR ERROR
      LBL(K)=LOR(LBL(K),MSKERR)
C     PRINT 6543,K
C6543 FORMAT(' ==================POSSIBLE ERROR=============,TRACK=',I5)
N     STORE AWAY INCOMPLETE TRACK NO.
      IF IS.LT.20
      THEN
      IS=IS+1
      HSP1(IS)=NTR
C     CALL CHKX(1,IS,HSP1(IS),NTR)
      CIF
      CIF
      IF IJFLG.EQ.1
      THEN
N     SEARCH TO SEE IF AMBIGUITY
      PERFORM SEAR
N     SHOULD BE REVERSED
      CIF
      IF KRING.EQ.2.AND.ITOL.EQ.1
N     STORE AWAY FOR POSSIBLE JOINING WITH
      THEN
N     AN ELEMENT IN RING 1(SKIP A RING)
      IF ISP.LT.10
      THEN
      ISP=ISP+1
      ISKP(ISP)=NTR
C     CALL CHKX(37,ISP,ISKP(ISP),NTR)
      CIF
      CIF
      IF LR.EQ.0
      THEN
C     PRINT 456
C456  FORMAT(' ========================= LR=0 =====================')
N     SET BIT 19 FOR UNDETERMINED AMBIGUITY
      LBL(K)=LOR(LBL(K),MSKLR0)
      CIF
      CIF
      IF LRING.EQ.1.AND.IRIFLG.EQ.0
      THEN
N     POSSIBLY ABLE TO JOIN AN EL
      IF LAND(LBL(K),MSKZEN).EQ.0.AND.ICNT.EQ.1.AND.ISP.GT.0
N     IN  RING 1 WITH ONE IN RING 3
      THEN
N     (I.E. NO HITS IN RING 2)
C     PRINT 893
C893  FORMAT('  $$$$$$$$$ SKIP A RING $$$$$$$$')
      JTRK=HISTR(1,NTR)
      JTRK=IABS(JTRK)
      IC1=2*IPCL(JTRK)+47
      INM=HNREL(NTR)
      INTR=NTR
C     CALL CHKX(84,JTRK,IC1,NTR)
      FOR I=1,ISP
N     ISKP(I) CONTAINS TRACK NO OF POSSIBLE
      IJ=ISKP(I)
N     TRACK IN RING 3
      IK=HISTR(HNREL(IJ),IJ)
      IC=IABS(IK)
      IK=IPCL(IC)
N     IS THE CELL CORRECT
      IF IK.EQ.IC1.OR.IK.EQ.IC1+1
N     WE HAVE A MATCH
      THEN
      IF LAND(LBL(IC),MSKERR).NE.0
      THEN
C     CALL CHKX(97,JTRK,IC,IK)
      IF ABS(ABS(SL1(IC))-ABS(SL2(JTRK))).LT.BKK(10).AND.ABS(SL1(IC))
     * .LT.BKK(11).AND. ABS(SL2(JTRK)).LT.BKK(11)
      THEN
      IXYB=0
      IF IYBKK(1).NE.0
      THEN
      PERFORM SKPFIT
      CIF
      IF IXYB.EQ.0
      THEN
      NTR=IJ
      PERFORM SETSKP
      INM=HNREL(NTR)
      FOR JZ=1,INM
      IK=HISTR(JZ,NTR)
      IK=IABS(IK)
      LBL(IK)=LOR(LBL(IK),MSKSKP)
      LBL(IK)=LAND(LBL(IK),MSKLRA)
      CFOR
      LBL(IC)=LAND(LBL(IC),MSKERA)
      HNREL(INTR)=0
      NTR=INTR-1
      XFOR
      CIF
      CIF
      CIF
      CIF
      CFOR
      CIF
      CIF
      CPROC
C
C    *************************************************************
C
C
      PROC INTJN
C
C     THIS PROC JOINS INCOMPLETE TRACK ELEMENTS WITHIN ONE CELL
C     THE CODING ASSUMES THAT THE FIRST TRACK ELEMENT FOUND
C     IS ALWAYS THE OUTERMOST ONE
C
      ISUFLG=0
N     MORE THAN ONE EL IN CELL
      IF HNTCEL(ICL+1)-HNTCEL(ICL).GT.1
      THEN
N     ZERO ITK ARRAY
      NTRLX1=HNTCEL(ICL)
      NTRLX2=HNTCEL(ICL+1)-1
      WHILE IW.GE.ILBOT
      IRL=0
      KK=K
      CALL SETSL(ITK(1,1),0,160,ZERO)
      FOR KX=NTRLX1,NTRLX2
      IF HUSE(KX).EQ.0
      THEN
N     ATTEMPT CONNECTION WITHIN CELL
      CALL INTJN1(KK,KX,INTFLG,DTMP)
      IF INTFLG.NE.0
      THEN
      PERFORM AWY
      CIF
      CIF
      CFOR
N     IF SUCCESSFUL SEE IF THERE EXISTS A
      IF IRL.GT.0
N     BETTER CONNECTION IN THIS CELL
      THEN
      IBFIT=-3
N     AT LEAST THREE ELS IN THIS CELL
      IF HNTCEL(ICL+1)-HNTCEL(ICL).GT.2
      THEN
      IRT=IRL
N     FOR EACH CONNECTION TRY ANOTHER
      FOR JK=1,IRT
N     CONNECTION WITH ALL THE OTHER ELS
      KX=ITK(JK,1)
N     IN THIS CELL
      FOR KK=NTRLX1,NTRLX2
      IF HUSE(KK).EQ.0
      THEN
      IW=NWR1(KK)
      IF IW.GE.ILBOT
      THEN
      CALL INTJN1(KK,KX,INTFLG,DTMP)
      IF INTFLG.NE.0
      THEN
      PERFORM AWY
      CIF
      CIF
      CIF
      CFOR
      CFOR
      CIF
      IBFIT=0
      CIF
      IF IRL.GT.1
      THEN
      CALL CHOOSE
      CIF
      IW=-100
      IF ITK(1,4).EQ.K
      THEN
      IKX=ITK(1,1)
N     LR3=-1 MEANS PARENT AND CANDIDATE HAVE DIFFERENT AMBIGUITIES
      LR3=1
      IF(ITK(1,3).EQ.-1.OR.(LAND(LBL(IKX),MSKCR1).NE.0
     * .AND.LAND(LBL(K),MSKCR1).EQ.0)) LR3=-1
      PERFORM INCRSS
      LR=LR2
      IPST=1
      KTR=NTR
      PERFORM CELLFL
      IF(KMP1.NE.KMP2) IPST=0
      CALL BSTORE
      K=IKX
      IW=NWR1(K)
      ISUFLG=1
      CIF
      CWHILE
      CIF
      CPROC
C
C     *******************************************************
C
      PROC AWY
C
C     THIS PROC PUTS INTERNAL TRACK EL
C     CONNECTION INFORMATION INTO THE
C     ITK ARRAY
C
      IF IRL.LT.10
      THEN
N     IRL COUNTS THE NUMBER OF CONNECTIONS
      IRL=IRL+1
N     CANDIDATE(I.E. TRACK EL IN LOWER PART OF CELL)
      ITK(IRL,1)=KX
N     WHEN -VE THIS MEANS OPP SIDES OF WIRE
      ITK(IRL,3)=INTFLG
N     PARENT(I.E. TRACK EL IN UPPER PART OF CELL)
      ITK(IRL,4)=KK
N     GOODNESS OF JOIN
      DTEMP(IRL)=DTMP
      ELSE
C     PRINT 5923
C5923 FORMAT(' TOO MANY CHOICES ¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢')
      CIF
      CPROC
C
C     *******************************************************
C
      PROC INCRSS
C
C     THIS PROC DETERMINES WHETHER CANDIDATE AND PARENT HAVE
C     DIFFERENT AMBIGUITY
C
      CALL LFRT(LR2)
N     DETERMINE LR OF CANDIDATE AND STORE IN LR2
      IF LR2.EQ.0
      THEN
      IF LR.NE.0
      THEN
      LR2=LR*LR3
      ELSE
      LR2=LR3
      IJFLG=1
      IPST=1
      CIF
      ELSE
      IF LR.EQ.0
      THEN
      IF(LR2*LR3.EQ.-1) HISTR(1,NTR)=-HISTR(1,NTR)
      ELSE
      IF LR2.NE.LR*LR3
      THEN
C     IF(IJFLG.EQ.1) CALL COREC
C     IF(HNREL(NTR).EQ.1) HISTR(1,NTR)=-HISTR(1,NTR)
      LR2=-LR2
      CIF
      CIF
      CIF
      CPROC
C
C    *************************************************************
C
      PROC CROSS
C
C     THIS PROC CORRECTS LR FLAG WHEN A TRACK
C     CROSSES THE WIRE PLANE
C
      IF IRIFLG.EQ.1
      THEN
N     CORRECT LR FLAG FOR SUCCESSFUL SIDE CONNECTION
      IF(IUDFLG.EQ.6) LR=-LR
      IF LAND(LBL(K),MSKCR1).NE.0.AND.LAND(LBL(K),MSKCR2).EQ.0
      THEN
N     CHANGE THE CURRENT LR FLAG
      LR=-LR
N     CHANGE THE AMBIGUITY OF PREVIOUSLY STORED TRACK
      HISTR(HNREL(NTR),NTR)=-HISTR(HNREL(NTR),NTR)
C     PRINT 2231,K
C2231 FORMAT(' CHANGE AMBIGUITY OF TRACK BECAUSE OF WIRE CROSSING',I4)
      CIF
      CIF
      CPROC
C
C     *************************************************************
C
      PROC SEAR
C
C     THIS PROC IS CALLED AT THE END OF
C     CONNECTING A TRACK AND IT REMAINS WITH IJFLG=1
C     (I.E. THE AMBIGUITY HAS NOT BEEN RESOLVED AND
C     AND THE TRACK HAS BEEN STORED AWAY WITH ARBITRARY
C     AMBIGUITY) (E.G. LR=0 IN RING 2 AND THEN CONNECTED
C     TO ATRACK IN IN RING 1)
C     IT SEARCHES THROUGH THE STORED ELEMENTS
C     OF THIS TRACK AND IF IT FINDS
C     A DISCREPANCY BETWEEN THE STORED AMBIGUITY
C     AND THE ONE FROM WIRE STAGGERING IT REVERSES
C     THE AMBIGUITY FOR ALL STORED ELS AND RETURNS
C
      ITMP=HNREL(NTR)
      FOR I=1,ITMP
      JK=HISTR(I,NTR)
      IKX=IABS(JK)
      CALL LFRT(LR2)
      IF LR2.NE.0
      THEN
N     REVERSED STORED AMBIGUITIES
      IF(LR2*JK.LT.0) CALL COREC
      XFOR
      CIF
      CFOR
C     PRINT 97
C97   FORMAT(' &&&&&&&&&&&& LR=0 &&&&&&&&&&&&')
      FOR I=1,ITMP
N     ALL THE STORED ELS ARE ZERO SO SET BIT 19
      JK=HISTR(I,NTR)
      IKX=IABS(JK)
      LBL(IKX)=LOR(LBL(IKX),MSKLR0)
      CFOR
      CPROC
C
C     *******************************************************
C
      PROC SRTREL
C
C
      I9=HNREL(NTR)
      FOR IO=ISTREL,I9
      ITEM=HISTR(IO,NTR)
      J9=IO-2+1
      FOR JO=1,J9
      HISTR(IO-JO+1,NTR)=HISTR(IO-JO,NTR)
      CFOR
      HISTR(1,NTR)=ITEM
      CFOR
      CPROC
C
      PROC CELLFL
C
C
C
      KMP1=HISTR(1,KTR)
      KMP1=IABS(KMP1)
      ITKEL1=KMP1
      KMP1=IPCL(KMP1)
      KMP2=HISTR(HNREL(KTR),KTR)
      KMP2=IABS(KMP2)
      ITKEL=KMP2
      KMP2=IPCL(KMP2)
      CPROC
C
      PROC SKPFIT
C
C
C
      IXYB=0
      NTR=IJ
      IBCD=HNREL(NTR)
      CALL MVC(HTEMP(1),0,HISTR(1,NTR),0,18)
      PERFORM SETSKP
C     PRINT 36
C36   FORMAT('0  SKIP-RING FIT  ')
      IAB=HNREL(NTR)
C     PRINT 37,NTR,(HISTR(IR,NTR),IR=1,IAB)
C37   FORMAT(' NTR, HISTR ',11I5)
C     PRINT 38,(HTEMP(IR),IR=1,9)
C38   FORMAT(' OLD HISTR ',9I5)
      CALL BAKFIT(IXYB,4)
      CALL MVC(HISTR(1,NTR),0,HTEMP(1),0,18)
      HNREL(NTR)=IBCD
      NTR=INTR
      CPROC
C
      PROC SETSKP
C
C
      IJLR=LR
      FOR JZ=1,INM
      IKX=HISTR(JZ,INTR)
      IF IJLR.EQ.0.OR.IJFLG.NE.0
      THEN
      LR=1
      IF(LAND(IK,1).EQ.1) LR=-1
C     CALL CHKX(91,LR,IK,LR2)
      ELSE
      LR=ISIGN(1,IKX)
      CIF
      IKX=IABS(IKX)
      CALL BSTORE
      CFOR
      LR=IJLR
      CPROC
      END
