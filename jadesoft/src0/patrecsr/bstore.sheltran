C   30/10/79 107101030  MEMBER NAME  BSTORE1  (PATRECSR)    SHELTRAN
      SUBROUTINE BSTORE
C
C     THIS SUB STORES FOUND TRACK
C
      IMPLICIT INTEGER*2 (H)
#include "cworkpr.for"
#include "cworkmx.for"
#include "cpatlm.for"
      IF(HNREL(NTR).EQ.9) RETURN
      HNREL(NTR) = HNREL(NTR) + 1
      KR = HNREL(NTR)
      HISTR(KR,NTR) = IKX*LR
      HUSE(IKX) = 1
      RETURN
      END
      FUNCTION SLCOR(SL,LRS)
C
C     THIS SUB TRANSFORMS SLOPES BECAUSE OF LORENTZ ANGLE
C
      IMPLICIT INTEGER*2 (H)
#include "cjdrch.for"
C     LEFT SOLN
      IF(LRS.EQ.-1)SLCOR=DRICOS*SL/(1.+SL*DRISIN)
C     RIGHT SOLN
      IF(LRS.EQ.1) SLCOR=DRICOS*SL/(1.-SL*DRISIN)
      RETURN
      END
      SUBROUTINE CHOOSE
C
C     THIS SUB CHOOSES BEST SOLN WHEN MORE THAN
C     ONE REMAINS AFTER COMPARING SLOPES AND DRIFT TIME
C     IT CHOOSES THE SOLN WITH THE BEST QUANTITY
C     'DTEMP' THAT ALSO HAS TRACK K AS ITS PARENT
C
      IMPLICIT INTEGER*2 (H)
#include "cworkmx.for"
#include "cpatlm.for"
#include "cworkpr.for"
C     PRINT 2228,(ITK(I,1),ITK(I,2),ITK(I,3),ITK(I,4),DTEMP(I),I=1,IRL)
C2228 FORMAT(' MORE THAN ONE SOLN ',4I4,F10.7)
N     ICHOOS IS A DUMMY VARIABLE FOR THE WHILE LOOP
      ICHOOS=1
      IT=IRL-1
      WHILE ICHOOS.EQ.1
      FOR I=1,IT
N     SORT THE ITK ARRAY BASED ON DTEMP
      ITMP=I+1
      FOR J=ITMP,IRL
      IF DTEMP(I).GT.DTEMP(J)
      THEN
      TEMP=DTEMP(I)
      DTEMP(I)=DTEMP(J)
      DTEMP(J)=TEMP
      FOR JK=1,4
      TEMP=ITK(I,JK)
      ITK(I,JK)=ITK(J,JK)
      ITK(J,JK)=TEMP
      CFOR
      CIF
      CFOR
      CFOR
N     PARENT TRACK EL NO. FOR BEST SOLUTION
      IP=ITK(1,4)
N     CANDIDATE TRACK EL NO. FOR BEST SOLUTION
      IC=ITK(1,1)
      IF DTEMP(1).NE.100.
      THEN
N     DOES THE BEST CHOICE HAVE K AS PARENT
      IF IP.NE.K
N     NO, THEN CANCEL ALL TRACKS HAVING THIS
      THEN
N     PARENT OR THIS CANDIDATE
      FOR J=1,IRL
      IF DTEMP(J).NE.100.
      THEN
      IF(ITK(J,4).EQ.IP.OR.ITK(J,1).EQ.IC) DTEMP(J)=100.
      CIF
      CFOR
      ELSE
N     SUCCESS
      XWHILE
      CIF
      ELSE
N     FAILURE
      XWHILE
      CIF
      CWHILE
      IF DTEMP(1).NE.100.
      THEN
N      DUMMY STATEMENTS
      ITWO=2
      ITHREE=ITWO+1
N     SUCCESS
C     PRINT 2230,ITK(1,1),ITK(1,2),ITK(1,3),ITK(1,4)
C2230 FORMAT(' CHOOSE TRACK ',I4,' LR(PARENT)',I4,' LR(CANDIDATE)',
C    * I4,' PARENT TRACK',I4)
      ELSE
N     FAILURE
      IRIFLG=0
C     PRINT 6543
C6543 FORMAT (' REJECT THE BEST CHOICE FOR THIS TRACK')
      CIF
      RETURN
      END
      SUBROUTINE INTJN1(KK,KX,INTFLG,DTMP)
C
C     THIS SUB JOINS TWO TRACK ELS IN ONE CELL
C     PARENT(OR THE TRACK EL IN THE UPPER PART OF THE CELL)
C     IS KK, CANDIDATE(OR THE TRACK EL IN THE LOWER PART
C     OF THE CELL) IS KX,IW IS NWR1(KK),INTFLG IS RETURNED=1
C     FOR SUCCESS AND 0 FOR FAILURE,DTMP RETURNS A QUANTITY
C     PROPORTIONAL TO THE QUALITY OF THE JOIN.
C
      IMPLICIT INTEGER*2 (H)
C
#include "cpatlm.for"
#include "cworkpr.for"
#include "cworkmx.for"
#include "cjdrch.for"
C
      DIMENSION HTEMP(9)
      DATA MSKCR1 /Z100/,MSKFIT/Z20000/,MSKAIT/ZFFFDFFFF/
      MAMB=0
      IF(NRHT(KK).GE.IBKK(19).AND.NRHT(KX).GE.IBKK(19)
     & .AND.IBKK(20).NE.0) MAMB=1
      INTFLG=0
      IWX=ITRKAR(KX,6)
      IOL=IBKK(1)-1
      IGAP=IBKK(2)+1
N     MATCHING OF FIRST AND LAST WIRES HIT
      IF IWX.LE.IW+IOL.AND.IWX.GE.IW-IGAP
      THEN
      ICROSS=1
      SLA=SL1(KK)/RINCR(KRING)
      SLB=SL2(KX)/RINCR(KRING)
      JT=IKX
      IKX=KX
      CALL LFRT(LRA)
      IKX=KK
      CALL LFRT(LR2)
      IKX=JT
      IF(IUDFLG.EQ.3.AND.LR.NE.0.AND.LRA.EQ.0) LRA=LR
      IF(IUDFLG.EQ.6.AND.LR.NE.0.AND.LR2.EQ.0) LR2=LR
      IDIW=IW-IWX
      IF(IDIW.LT.0) IDIW=0
      IF MAMB.NE.0.AND.LAND(MSKCR1,LBL(KK)).EQ.0.AND.
     ¢ LAND(MSKCR1,LBL(KX)).EQ.0
      THEN
      IF(LRA.NE.LR2) ICROSS=-1
      IF(LRA.EQ.0.OR.LR2.EQ.0) ICROSS=0
C     PRINT 289,KK,KX
C289  FORMAT(' OPP SIDES OF THE WIRE PLANE FOR TRACKS',2I5)
      CIF
      DSEX=TRKAR(KK,4)-SL1(KK)*IDIW
      DX=DSEX-TRKAR(KX,7)
      IF MAMB.EQ.0.OR.ICROSS.EQ.0
      THEN
      IF(SL2(KX).LT.0..AND.SL1(KK).GT.0..AND.LAND(LBL(KK),MSKCR1).EQ.0
     * .AND.LAND(LBL(KX),MSKCR1).EQ.0.AND.(DS1(KK).LT.BKK(5)
     ¢ .OR.DS2(KX).LT.BKK(5))) ICROSS=-1
      CIF
      IF ICROSS.EQ.-1
      THEN
      SLA=-SLA
      DX=TRKAR(KX,7)+DSEX
      CIF
      IF LAND(LBL(KK),MSKCR1).NE.0.AND.LAND(LBL(KX),MSKCR1).NE.0
       THEN
      DX=TRKAR(KX,7)+DSEX
N     OPPOSITE SIDES OF THE WIRE PLANE
      SLA=-SLA
C      CALL CHKX(-88,SLA,DSEX,DX)
      IF(MAMB.NE.0.AND.LRA*LR2.LT.0) DX=1000000.
      CIF
      IF(ICROSS.EQ.0) ICROSS=1
      IF(LAND(MSKCR1,LBL(KK)).EQ.0.AND.LAND(MSKCR1,LBL(KX)).NE.0
     & .AND.LRA*LR2.GT.0.AND.MAMB.NE.0) DX=10000000.
      IF(LAND(MSKCR1,LBL(KX)).EQ.0.AND.LAND(MSKCR1,LBL(KK)).NE.0
     & .AND.LRA*LR2.LT.0.AND.MAMB.NE.0) DX=10000000.
N     ARE DRIFT SPACES SIMILAR?
      IF ABS(DX).LT.DCELL
      THEN
C     PRINT 6378,KK,KX,IWX,IW,DX
C6378 FORMAT(' JOIN TWO TKELS',2I4,' WIRE NOS. ',2I4,'  DX=',F7.3)
N     SET UP SLOPE LIMIT
      SLOLIM=(ABS(SLA)+ABS(SLB))/2.*BKK(14)+BKK(15)
N     COMPARE SLOPES
      DTMP=ABS(SLA-SLB)
C     PRINT 211,DTMP,SLOLIM
C 211 FORMAT(' SLOPE (CAND.-PARENT)',F10.5,'SLOLIM',F10.5)
N     SUCCESS
      IF DTMP.LT.SLOLIM
      THEN
      IB=0
      IF IBKK(16).NE.0.AND.IBFIT.EQ.0
      THEN
      PERFORM INTFIT
      CIF
      IF IB.EQ.0
      THEN
      INTFLG=ICROSS
      DTMP=ABS(DTMP*DX)
      CIF
      CIF
      KMP1=HISTR(1,NTR)
      KMP1=IABS(KMP1)
      KMP1=IPCL(KMP1)
      IF(KMP1.EQ.IPCL(KX).AND.IBKK(20).NE.0.AND.MAMB.EQ.0) IJFLG=1
      CIF
      CIF
      RETURN
C
C     *********************************************
C
      PROC INTFIT
C
C
C
      IB=0
      IF HNREL(NTR).LT.9
      THEN
      CALL MVC(HTEMP(1),0,HISTR(1,NTR),0,18)
      IKST=IPST
      IKFLG=IJFLG
      IBJ=IKX
      IKX=KX
      LR3=1
      IF(ICROSS.EQ.-1.OR.(LAND(LBL(KX),MSKCR1).NE.0.AND.
     & LAND(LBL(KK),MSKCR1).EQ.0)) LR3=-1
      PERFORM INCRSS
      HNREL(NTR)=HNREL(NTR)+1
      LRC=LR2
      HISTR(HNREL(NTR),NTR)=LRC*KX
C     LBL(KX)=LOR(LBL(KX),MSKFIT)
      CALL BAKFIT(IB,1)
C     IF(IB.NE.0) PRINT 36
C36   FORMAT('   INTJ  FIT    ')
      IAB=HNREL(NTR)
C     IF(IB.NE.0) PRINT 37,KX,NTR,(HISTR(IR,NTR),IR=1,IAB)
C     IF(IB.NE.0) PRINT 38,(HTEMP(IR),IR=1,9)
C37   FORMAT(' KX, NTR,HISTR :',11I5)
C38   FORMAT(' OLD HISTR :',9I5)
      HNREL(NTR)=HNREL(NTR)-1
C     LBL(KX)=LAND(LBL(KX),MSKAIT)
      CALL MVC(HISTR(1,NTR),0,HTEMP(1),0,18)
      IKX=IBJ
      IJFLG=IKFLG
      IPST=IKST
      CIF
      CPROC
      PROC INCRSS
C
C     THIS PROC DETERMINES WHETHER CANDIDATE AND PARENT HAVE
C     DIFFERENT AMBIGUITY
C
      CALL LFRT(LR2)
N     DETERMINE LR OF CANDIDATE AND STORE IN LR2
      IF LR2.EQ.0
      THEN
      IF LR.NE.0
      THEN
      LR2=LR*LR3
      ELSE
      LR2=LR3
      IJFLG=1
      IPST=1
      CIF
      ELSE
      IF LR.EQ.0
      THEN
      IF(LR2*LR3.EQ.-1) HISTR(1,NTR)=-HISTR(1,NTR)
      ELSE
      IF LR2.NE.LR*LR3
      THEN
C     IF(IJFLG.EQ.1) CALL COREC
C     IF(HNREL(NTR).EQ.1) HISTR(1,NTR)=-HISTR(1,NTR)
      LR2=-LR2
      CIF
      CIF
      CIF
      CPROC
      END
      SUBROUTINE COREC
C
C     THIS SUB CORRECTS L-R AMBIGUITY OF PREVIOUSLY
C     STORED TRACKS WHEN THEY HAVE BEEN STORED AWAY WITH AN
C     ARBITRARILY SET AMBIGUITY(IJFLG=1) AND A TEST OF
C     THE AMBIGUITY FROM WIRE STAGGERING INDICATES
C     A DISCREPANCY
C
      IMPLICIT INTEGER*2 (H)
#include "cworkmx.for"
#include "cpatlm.for"
#include "cworkpr.for"
      ITMP=HNREL(NTR)
      FOR I=1,ITMP
      HISTR(I,NTR)=-HISTR(I,NTR)
      CFOR
      IJFLG=0
C     PRINT 666
C666  FORMAT('  COREC================')
      RETURN
      END
      SUBROUTINE SIDE1
C
C     THIS SUB PRESETS CERTAIN QUANTITIES FOR
C     THE PROC SIDCN1 WHERE THE CONNECTION ACROSS
C     CELL SIDEWALLS IS ATTEMPTED
C
      IMPLICIT INTEGER*2 (H)
#include "cworkpr.for"
#include "cworkmx.for"
#include "cpatlm.for"
#include "cdsmax.for"
#include "cjdrch.for"
      DIMENSION LSTCL(3),LFTCL(3),NCELL(3),TANDEL(3)
      EQUIVALENCE (IBCK(1),LSTCL(1)),(IBCK(4),LFTCL(1))
      EQUIVALENCE (IBCK(7),NCELL(1)),(DBCK(1),TANDEL(1))
      DIMENSION HTEMP(9)
      DATA MSKCR1 /Z100/,MSKFIT/Z20000/,MSKAIT/ZFFFDFFFF/
N     IIWW IS THE FIRST WIRE THAT IS NOT HIT
      IIWW=IW+1
      IF(IIWW.GT.16) IIWW=16
      IF(IIWW.LT.1) IIWW=1
N     DSMX IS THE MAX DRIFT SPACE FOR THIS WIRE,CELL,AMBIGUITY
      BSL=A
N     CHECK IF DRIFT SPACE IS MAX
      IF(IUDFLG.EQ.6) BSL=-BSL
      DRIFT=DS+.5*BSL
      IRT=LR1
      IM1=6
      IM2=3
      PERFORM SIDCX
      IWEX=HMCH(IIWW,KRING,LR1)+1
      IF(IWEX.GT.16) IWEX=16
      IF(IWEX.LT.1) IWEX=1
C     CALL CHKX(70,IIWW,IIWW,IWEX)
C     CALL CHKX(-70,DTMP,DTMP,DTMP)
C     ELSE
C     DTMP=100.
C     PRINT 6654,SLWALL,BSL
C6654 FORMAT(' WRONG SLOPE FOR SIDCON  ',2F10.5)
C     CIF
      IF DTMP.LT.2.*CLIM.OR.DTMP.LT.2.
      THEN
C     PRINT 2216,DS,A,DSMX,DTMP
C2216 FORMAT(' CELSID   DS=',F7.3,'A=',F7.3,'DSMX=',F7.3,'DIFF=',F7.3)
C     PRINT 2218
C2218 FORMAT(' CELSID   SUCCEEDS')
N     TRY A SIDE CONNECTION
      PERFORM SIDCN1
N     IS IT SUCCESSFUL?
      IF IKX.GT.0
      THEN
      IF LRCORN.EQ.0
      THEN
N     RESET THINGS FOR ANOTHER GO
      ICX=ICT
      IRIFLG=1
      KT=IKX
      CIF
N     FAILURE
      ELSE
      IWT=ILIM
      CIF
      ELSE
C     PRINT 2217
C2217 FORMAT(' CELSID   FAILS')
      IWT=ILIM
      CIF
      RETURN
C
C   *************************************************************
C
      PROC SIDCN1
C
C  THIS PROC FINDS A MATCH THROUGH SIDEWALL OF ONE RING
C
N     IKX WILL CONTAIN MATHING TRACK NO. IF SUCCESSFUL
      IKX=0
      ICNFLG=0
N     PRESET COUNTERS IN CASE MORE THAN ONE SOLN IS FOUND
      IF(LRCORN.EQ.0) IRL=0
N     TRACK ELEMENTS IN NEIGHBOR CELL ?
      NTRLX1 = HNTCEL(ICT)
      NTRLX2 = HNTCEL(ICT+1)-1
C     PRINT 2219,ICT,NTRLX1,NTRLX2
C2219 FORMAT(' TRY SIDCON     CELL=',I4,' TRACKS=',2I4)
N     EXPECTED WIRE NO. IN NEIGHBOUR CELL DEPENDS ON L-R SIDE
N     ADD 1 OR SUBTRACT 1 TO EXPECTED WIRE NO.
N     DEPENDING ON WHETHER TRACK IS GOING OUT OR IN
N     LOOP TRACK ELEMENTS IN NEIGHBOR CELL
      FOR KX = NTRLX1,NTRLX2
N     CHECK THAT IT HASN'T BEEN USED YET
      IF HUSE(KX).EQ.0
      THEN
      IPER=0
      IF IBKK(20).NE.0.AND.NRHT(KX).GE.IBKK(19)
      THEN
      JT=IKX
      IKX=KX
      CALL LFRT(LK)
      IKX=JT
      IF(LAND(MSKCR1,LBL(KX)).NE.0.AND.IUDFLG.EQ.6) LK=-LK
      IF(LK.NE.3-2*LR1) IPER=1
      IF(LK.EQ.0) IPER=0
      CIF
      IF IPER.EQ.0
      THEN
N     WIRE NO. OF CANDIDATE TRACK
      IIWW= ITRKAR(KX,IUDFLG)+1
      IF(IIWW.GT.16) IIWW=16
      IF(IIWW.LT.1) IIWW=1
N     DSMX IS THE MAX DRIFT SPACE FOR THIS WIRE,CELL,AMBIGUITY
      BSL=TRKAR(KX,IUDFLG+2)
N     CHECK IF DRIFT SPACE IS MAX
      IF(IUDFLG.EQ.3) BSL=-BSL
      DRIFT=TRKAR(KX,IUDFLG+1)+.5*BSL
      IRT=3-LR1
      IM1=3
      IM2=6
      PERFORM SIDCX
      IWX=IIWW
C     CALL CHKX(70,IIWW,IWX,IWEX)
C     PRINT 2220,DTMP,IWEX,IWX
C2220 FORMAT(' DSX-DSMAX=',F7.3,'EXPECTED WIRE=',I4,' ACTUAL WIRE=',I4)
N     DOES CANDIDATE TRACK HAVE A MAX DRIFT SPACE?
C     ELSE
C     DTMP=100.
C     PRINT 6654,SLWALL,BSL
C     CIF
      IF DTMP.LT.2.*CLIM.OR.DTMP.LT.2.
N     COMPARE SLOPES
      THEN
      IF IABS(IWX-IWEX).LE.IBKK(6)-1
      THEN
C
C     THIS PROC CALCULATES SLOPE OF PARENT TRACK
C     IN THE CANDIDATE TRACKS CELL
      LRS=2*LR1-3
      SLB=A/RINCR(KRING)
N     COMPENSATE FOR LORENTZ ANGLE
      SL=SLCOR(SLB,LRS)
N     ROTATE TO NEIGHBOUR CELL CO-ORDINATE SYSTEM
      T=TANDEL(KRING)
N     EXPECTED SLOPE
      SLEX=(T-SL)/(1.+SL*T)
C     CALL CHKX(-62,SL,T,SLEX)
      LRS=-LRS
N     GET CANDIDATE SLOPE
      SLE=TRKAR(KX,IUDFLG+2)/RINCR(KRING)
N     COMPENSATE LORENTZ ANGLE
      SLC=SLCOR(SLE,LRS)
C     CALL CHKX(-63,SLE,SLC,SLC)
N     TOLERANCE ON SLOPE MATCHING
C     SLOLIM=ABS(SLEX)*FACTSL+CONSL
C     IF(SLOLIM.LE..1) SLOLIM=.045
C     IF(SLOLIM.GT..1) SLOLIM=.5
      SLOLIM=(ABS(SLE)+ABS(SLB))/2.*BKK(12)+BKK(13)
      DTMP=SLEX-SLC
C     PRINT 2229,KX,DTMP,SLOLIM
C2229 FORMAT(' COMP SLOPES, TRACK=',I4,' SLEX-SL ',F7.3,' SLOLIM',F7.3)
      IF ABS(DTMP).LT.SLOLIM
N     SUCCESS SO STORE IT AWAY
      THEN
      IF LRCORN.NE.0
      THEN
      IKX=KX
C     PRINT 2221,IKX
      XFOR
      CIF
      IB=0
      IF IBKK(17).NE.0.AND.IBFIT.EQ.0
      THEN
      PERFORM SIDFIT
      CIF
      IF IB.EQ.0
      THEN
      IRL=IRL+1
      DTEMP(IRL)=ABS(DTMP)
      ITK(IRL,1)=KX
      ITK(IRL,4)=KT
      ICNFLG=1
      ELSE
N     FAILURE
      ICNFLG=0
      CIF
      ELSE
N     FAILURE
      ICNFLG=0
      CIF
      IF(IRL.GT.0.AND.LRCORN.EQ.0) ICNFLG=1
      CIF
      CIF
      ELSE
C     PRINT 59,KX
C59   FORMAT('   TRACK',I5,'   REFUSED AS CAND IN SIDCON')
      CIF
      CIF
      CFOR
N     HAVE WE AT LEAST ONE MATCH?
      IF ICNFLG.EQ.1
      THEN
N     IF MORE THAN ONE THEN WE MUST CHOOSE WHICH TO TAKE
      IF IRL.GT.1
      THEN
      CALL CHOOSE
      CIF
N     PUT AWAY THE MATCHING TRACK NUMBER
      IKX=ITK(1,1)
C     PRINT 2221,IKX
C2221 FORMAT(' SUCCESS IN SIDCON,TRACK=',I4)
      CIF
      CPROC
C
C     ********************************************************
C
      PROC SIDCX
C
C
C
      CLIM=.5*BSL
      DXNEW=DSMAX(IIWW,KRING,IRT)-DRIFT
      DXOLD=9999.
C     SLWALL=DSMAX(2,KRING,LR1)-DSMAX(1,KRING,LR1)
C     IF BSL.GT.SLWALL
C     THEN
      WHILE DXNEW.GT.CLIM
      IF IIWW.EQ.16.OR.IIWW.EQ.1
      THEN
C     PRINT 432
C 432 FORMAT(' WIRE NO. OUT OF RANGE  ')
      XWHILE
      CIF
      DRIFT=DRIFT+BSL
      IF(IUDFLG.EQ.IM1) IIWW=IIWW-1
      IF(IUDFLG.EQ.IM2) IIWW=IIWW+1
      DSMX=DSMAX(IIWW,KRING,IRT)
      DXNEW=DSMX-DRIFT
      IF ABS(DXNEW).GT.ABS(DXOLD)
      THEN
C     PRINT 902
C902  FORMAT( '  DIVERGENCE  ')
      DTMP=100.
      XWHILE
      CIF
C     CALL CHKX(69,IIWW,IUDFLG,IIWW)
C     CALL CHKX(-69,DXNEW,DXOLD,DRIFT)
      IF DXNEW.LT.1.
      THEN
      XWHILE
      ELSE
      DXOLD=DXNEW
      CIF
      CWHILE
      DTMP=DXNEW
      CPROC
C
C     *******************************************************
C
      PROC SIDFIT
C
C
C
      IB=0
      IF HNREL(NTR).LT.9
      THEN
      IKFLG=IJFLG
      CALL MVC(HTEMP(1),0,HISTR(1,NTR),0,18)
      IF(LR.EQ.-1.AND.LR1.EQ.2.OR.LR.EQ.1.AND.LR1.EQ.1) CALL COREC
      IF(LR.EQ.0.AND.LR1.EQ.1) HISTR(1,NTR)=-HISTR(1,NTR)
      HNREL(NTR)=HNREL(NTR)+1
      IF(LR1.EQ.2) LRC=-1
      IF(LR1.EQ.1) LRC=1
      IF(LAND(LBL(KX),MSKCR1).NE.0.AND.IUDFLG.EQ.6) LRC=-LRC
      IKRA=HISTR(1,NTR)
      IKRA=IABS(IKRA)
      IF(IKRA.EQ.KT.AND.IUDFLG.EQ.3.AND.LAND(MSKCR1,LBL(KT)).NE.0)
     * CALL COREC
      HISTR(HNREL(NTR),NTR)=KX*LRC
C     LBL(KX)=LOR(LBL(KX),MSKFIT)
      IAB=HNREL(NTR)
      CALL BAKFIT(IB,3)
C     IF(IB.NE.0) PRINT 36
C36   FORMAT('   SIDE  FIT    ')
C     IF(IB.NE.0) PRINT 37,KX,NTR,(HISTR(IR,NTR),IR=1,IAB)
C     IF(IB.NE.0) PRINT 38,(HTEMP(IR),IR=1,9)
C37   FORMAT(' KX, NTR,HISTR :',11I5)
C38   FORMAT(' OLD HISTR :',9I5)
      HNREL(NTR)=HNREL(NTR)-1
C     LBL(KX)=LAND(LBL(KX),MSKAIT)
      CALL MVC(HISTR(1,NTR),0,HTEMP(1),0,18)
      IJFLG=IKFLG
      CIF
      CPROC
      END
      SUBROUTINE LFRT(LR2)
C
C     THIS SUB EXTRACTS LEFT-RIGHT SOLN BASED
C     ON THE LABEL IN MIDOUT(WIRE STAGGERING)
C
      IMPLICIT INTEGER*2 (H)
#include "cworkmx.for"
#include "cworkpr.for"
#include "cpatlm.for"
      DATA MSKLFT,MSKRT/Z400,Z800/
      LR2=0
      IPST=0
      I1=LAND(LBL(IKX),MSKLFT)
      I2=LAND(LBL(IKX),MSKRT)
C     LEFT SOLN
      IF(I1.NE.0) LR2=-1
C     RIGHT SOLN
      IF(I2.NE.0) LR2=1
C     CAN'T TELL
      IF(I1*I2.NE.0) LR2=0
      IF(LR2.NE.0) IPST=1
      RETURN
      END
